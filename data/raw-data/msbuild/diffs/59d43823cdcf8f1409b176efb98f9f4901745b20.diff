diff --git a/.gitignore b/.gitignore
index cc15003e7c1..e902f62318d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -218,5 +218,7 @@ Samples/MultiprocessBuild/PortableTask.dll
 
 #Stage1 build folder for when doing bootstrap builds
 stage1/
+.tools
 
-.tools
\ No newline at end of file
+# ETL traces    
+*.etl.zip
\ No newline at end of file
diff --git a/PerfViewData.etl.zip b/PerfViewData.etl.zip
deleted file mode 100644
index 823543440d2..00000000000
Binary files a/PerfViewData.etl.zip and /dev/null differ
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 196a105dd77..86a44b3822f 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -532,7 +532,7 @@ public void ValidXmlXmlReaderCache()
         public void LoadCommonTargets()
         {
             ProjectCollection projectCollection = new ProjectCollection();
-            string toolsPath = projectCollection.Toolsets.Where(toolset => (string.Compare(toolset.ToolsVersion, ObjectModelHelpers.MSBuildDefaultToolsVersion, StringComparison.OrdinalIgnoreCase) == 0)).First().ToolsPath;
+            string toolsPath = projectCollection.Toolsets.Where(toolset => (string.Equals(toolset.ToolsVersion, ObjectModelHelpers.MSBuildDefaultToolsVersion, StringComparison.OrdinalIgnoreCase))).First().ToolsPath;
 
             string[] targets =
             {
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index c41249a0afc..3172b22b806 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -957,7 +957,7 @@ public void CopyFromWithItemListExpressionClonesMetadata()
         /// Expression like @(x) should not clone metadata, even if the item type is different.
         /// It's obvious that it shouldn't clone it if the item type is the same.
         /// If it is different, it doesn't clone it for performance; even if the item definition metadata
-        /// changes later (this is design time), the inheritors of that item definition type 
+        /// changes later (this is design time), the inheritors of that item definition type
         /// (even those that have subsequently been transformed to a different itemtype) should see
         /// the changes, by design.
         /// Just to make sure we don't change that behavior, we test it here.
@@ -1340,7 +1340,7 @@ public void BuiltInMisqualifiedMetadataExpression()
         }
 
         /// <summary>
-        /// Metadata condition should work correctly with built-in metadata 
+        /// Metadata condition should work correctly with built-in metadata
         /// </summary>
         [Fact]
         public void BuiltInMetadataInMetadataCondition()
@@ -2272,7 +2272,7 @@ public void RemoveWithItemReferenceOnIntrinsicMatchingMetadata()
         [Fact]
         public void RemoveWithPropertyReferenceInMatchOnMetadata()
         {
-            string content = 
+            string content =
                 @"<Project>
                     <PropertyGroup>
                         <Meta1>v0</Meta1>
@@ -2493,7 +2493,7 @@ public void UpdateShouldRespectCondition()
                               <i Update='c'>
                                   <m1 Condition='1 == 0'>from_false_metadata</m1>
                               </i>";
-            
+
             var project = ObjectModelHelpers.CreateInMemoryProject(ObjectModelHelpers.FormatProjectContentsWithItemGroupFragment(projectContents));
 
             var expectedInitial = new Dictionary<string, string>
@@ -3351,7 +3351,7 @@ private static List<ProjectItem> GetItemsFromFragmentWithGlobs(string itemGroupF
 
         /// <summary>
         /// Get the item of type "i" using the item Xml fragment provided.
-        /// If there is more than one, fail. 
+        /// If there is more than one, fail.
         /// </summary>
         private static ProjectItem GetOneItemFromFragment(string fragment)
         {
@@ -3363,7 +3363,7 @@ private static ProjectItem GetOneItemFromFragment(string fragment)
 
         /// <summary>
         /// Get the item of type "i" in the project provided.
-        /// If there is more than one, fail. 
+        /// If there is more than one, fail.
         /// </summary>
         private static ProjectItem GetOneItem(string content)
         {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
index fe148f879e4..14ecdd51296 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/Helpers/ViewValidation.evaluation.cs
@@ -241,7 +241,7 @@ private static void Verify(SdkReference view, SdkReference real, ValidationConte
             if (view == null && real == null) return;
             Assert.NotNull(view);
             Assert.NotNull(real);
-            
+
             Assert.Equal(real.Name, view.Name);
             Assert.Equal(real.Version, view.Version);
             Assert.Equal(real.MinimumVersion, view.MinimumVersion);
@@ -290,7 +290,7 @@ public static void Verify(ProjectPair pair, ValidationContext context = null)
             if (pair == null) return;
             var real = pair.Real;
             var view = pair.View;
-            context = context ?? new ValidationContext();
+            context ??= new ValidationContext();
             context.Pair = pair;
 
 
@@ -320,7 +320,6 @@ public static void Verify(ProjectPair pair, ValidationContext context = null)
                 Verify(view.ImportsIncludingDuplicates, real.ImportsIncludingDuplicates, Verify, context);
             }
 
-            
             Verify(view.AllEvaluatedProperties, real.AllEvaluatedProperties, Verify, context);
             Verify(view.AllEvaluatedItemDefinitionMetadata, real.AllEvaluatedItemDefinitionMetadata, Verify, context);
             Verify(view.AllEvaluatedItems, real.AllEvaluatedItems, Verify, context);
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
index bf3f9272979..5fc916cfdd3 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/LinkedSpecialCasesScenarios.cs
@@ -85,7 +85,7 @@ public LinkedSpecialCasesScenarios(MyTestCollectionGroup group)
 
         private ProjectPair GetNewInMemoryProject(string path, string content = null)
         {
-            content = content ?? TestCollectionGroup.SampleProjectFile;
+            content ??= TestCollectionGroup.SampleProjectFile;
             var tempPath = this.StdGroup.Disk.GetAbsolutePath(path);
             var newReal = this.StdGroup.Target.LoadInMemoryWithSettings(content, ProjectLoadSettings.IgnoreMissingImports);
             newReal.Xml.FullPath = tempPath;
@@ -108,7 +108,7 @@ private void CloneAndAddInternal(ProjectRootElement sourceProject)
             xmlPair.View.Save();
             Assert.False(xmlPair.View.HasUnsavedChanges);
 
-            sourceProject = sourceProject ?? xmlPair.View;
+            sourceProject ??= xmlPair.View;
 
 
             // var existingItemGroup1 = sourceProject.QuerySingleChildrenWithValidation<ProjectItemGroupElement>((ig) => ig.Label == "Group1");
@@ -162,7 +162,7 @@ private void CopyFromInternal(ProjectRootElement sourceProject)
             xmlPair.View.Save();
             Assert.False(xmlPair.View.HasUnsavedChanges);
 
-            sourceProject = sourceProject ?? xmlPair.View;
+            sourceProject ??= xmlPair.View;
 
             var existingItemGroupList = sourceProject.AllChildren.OfType<ProjectItemGroupElement>().Where(((ig) => ig.Label == "Group1")).ToList();
             Assert.Single(existingItemGroupList);
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index c9e4fdd7302..93eeb2927b1 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -502,7 +502,7 @@ private void TestSkipIsolationConstraints(string glob, string referencePath, boo
 
             glob = $"$([MSBuild]::Escape('{glob}'))";
 
-            projectContents = projectContents ?? $@"
+            projectContents ??= $@"
 <Project>
     <ItemGroup>
         <{ItemTypeNames.GraphIsolationExemptReference} Include=`{glob};ShouldNotMatchAnything`/>
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index 292aaeba626..623b39580ca 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -483,7 +483,7 @@ public void RegisterDuplicateForwardingLoggerLogger()
             int countForwardingLogger = 0;
             foreach (string loggerName in _initializedService.RegisteredLoggerTypeNames)
             {
-                if (String.Compare("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase))
                 {
                     countForwardingLogger++;
                 }
@@ -585,7 +585,7 @@ public void RegisterGoodDiscriptions()
             int countForwardingLogger = 0;
             foreach (string loggerName in _initializedService.RegisteredLoggerTypeNames)
             {
-                if (String.Compare("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("Microsoft.Build.Logging.ConfigurableForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase))
                 {
                     countForwardingLogger++;
                 }
@@ -597,7 +597,7 @@ public void RegisterGoodDiscriptions()
             countForwardingLogger = 0;
             foreach (string loggerName in _initializedService.RegisteredLoggerTypeNames)
             {
-                if (String.Compare("Microsoft.Build.BackEnd.Logging.CentralForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("Microsoft.Build.BackEnd.Logging.CentralForwardingLogger", loggerName, StringComparison.OrdinalIgnoreCase))
                 {
                     countForwardingLogger++;
                 }
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 6a9e26fbc0e..34522d98c12 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -1003,8 +1003,8 @@ private void SimpleSymlinkInputCheck(DateTime symlinkWriteTime, DateTime targetW
 
                     long symlinkWriteTimeTicks = symlinkWriteTime.ToFileTimeUtc();
 
-                    if (SetFileTime(handle, ref symlinkWriteTimeTicks, ref symlinkWriteTimeTicks,
-                            ref symlinkWriteTimeTicks) != true)
+                    if (!SetFileTime(handle, ref symlinkWriteTimeTicks, ref symlinkWriteTimeTicks,
+                            ref symlinkWriteTimeTicks))
                     {
                         Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());
                     }
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 99dbc5198e6..3e9209e6f88 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -325,7 +325,7 @@ public void MSBuildLastTaskResult()
         }
 
         /// <summary>
-        /// Verifies that we can add "recursivedir" built-in metadata as target outputs. 
+        /// Verifies that we can add "recursivedir" built-in metadata as target outputs.
         /// This is to support wildcards in CreateItem. Allowing anything
         /// else could let the item get corrupt (inconsistent values for Filename and FullPath, for example)
         /// </summary>
@@ -408,7 +408,7 @@ public void OtherBuiltInMetadataErrors2()
         }
 
         /// <summary>
-        /// Verify that properties can be passed in to a task and out as items, despite the 
+        /// Verify that properties can be passed in to a task and out as items, despite the
         /// built-in metadata restrictions.
         /// </summary>
         [Fact]
@@ -468,7 +468,7 @@ public void IllegalFileCharsInItemsOutOfTask()
         }
 
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -493,7 +493,7 @@ public void NullMetadataOnOutputItems()
         }
 
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -551,7 +551,7 @@ public void SameAssemblyFromDifferentRelativePathsSharesAssemblyLoadContext()
 
 #if FEATURE_CODETASKFACTORY
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         public void NullMetadataOnOutputItems_InlineTask()
@@ -591,7 +591,7 @@ public void NullMetadataOnOutputItems_InlineTask()
         }
 
         /// <summary>
-        /// If an item being output from a task has null metadata, we shouldn't crash. 
+        /// If an item being output from a task has null metadata, we shouldn't crash.
         /// </summary>
         [Fact]
         [Trait("Category", "non-mono-tests")]
@@ -633,9 +633,9 @@ public void NullMetadataOnLegacyOutputItems_InlineTask()
 #endif
 
         /// <summary>
-        /// Validates that the defining project metadata is set (or not set) as expected in 
-        /// various task output-related operations, using a task built against the current 
-        /// version of MSBuild.  
+        /// Validates that the defining project metadata is set (or not set) as expected in
+        /// various task output-related operations, using a task built against the current
+        /// version of MSBuild.
         /// </summary>
         [Fact]
         public void ValidateDefiningProjectMetadataOnTaskOutputs()
@@ -645,9 +645,9 @@ public void ValidateDefiningProjectMetadataOnTaskOutputs()
         }
 
         /// <summary>
-        /// Validates that the defining project metadata is set (or not set) as expected in 
-        /// various task output-related operations, using a task built against V4 MSBuild, 
-        /// which didn't support the defining project metadata.  
+        /// Validates that the defining project metadata is set (or not set) as expected in
+        /// various task output-related operations, using a task built against V4 MSBuild,
+        /// which didn't support the defining project metadata.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -786,7 +786,7 @@ Task IRequestBuilderCallback.BlockOnTargetInProgress(int blockingRequestId, stri
  *********************************************************************************/
 
         /// <summary>
-        /// Helper method for validating the setting of defining project metadata on items 
+        /// Helper method for validating the setting of defining project metadata on items
         /// coming from task outputs
         /// </summary>
         private void ValidateDefiningProjectMetadataOnTaskOutputsHelper(string customTaskPath)
@@ -1116,7 +1116,7 @@ private class MockHost : MockLoggingService, IBuildComponentHost, IBuildComponen
 
             /// <summary>
             /// Constructor
-            /// 
+            ///
             /// UNDONE: Refactor this, and the other MockHosts, to use a common base implementation.  The duplication of the
             /// logging implementation alone is unfortunate.
             /// </summary>
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 458a2f90242..89da8a06c20 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -1200,7 +1200,7 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
                 {
                     foreach (ProjectTaskInstance childNode in target.Tasks)
                     {
-                        if (0 == String.Compare(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                        if (String.Equals(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
                         {
                             string projectsParameter = childNode.GetParameter("Projects");
                             if (projectsParameter != "@(ProjectReference)")
@@ -1369,56 +1369,56 @@ public void TestDisambiguateProjectTargetName()
 
             ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)));
 
-            ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
-            ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
-            ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
-            ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase) == 0).First().Value;
+            ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)).First().Value;
+            ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)).First().Value;
+            ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)).First().Value;
+            ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)).First().Value;
 
             // Check that the appropriate target is being passed to the child projects
             Assert.Null(buildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             Assert.Equal("Clean", cleanTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             Assert.Equal("Rebuild", rebuildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             Assert.Equal("Publish", publishTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Targets"));
 
             // Check that the child projects in question are the members of the "ProjectReference" item group
             Assert.Equal("@(ProjectReference)", buildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             Assert.Equal("@(ProjectReference->Reverse())", cleanTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             Assert.Equal("@(ProjectReference)", rebuildTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             Assert.Equal("@(ProjectReference)", publishTarget.Tasks.Where
                 (
-                task => String.Compare(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase) == 0
+                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase)
                 ).First().GetParameter("Projects"));
 
             // We should have only the four standard targets plus the two validation targets (ValidateSolutionConfiguration and ValidateToolsVersions).
@@ -2179,26 +2179,26 @@ public void CustomTargetNamesAreInInMetaproj()
 
             ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "One" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Two", "Three", "Four" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Build" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Five", "Rebuild" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase) == 0));
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase)));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
 
             instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "My_Project:Six" });
 
-            Assert.Single(instances[0].Targets.Where(target => String.Compare(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase) == 0));
+            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
         }
 
         /// <summary>
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index 92551b26db8..be35abeaf4e 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -941,7 +941,7 @@ private string[] getFiles(string path, string pattern)
             matches.RemoveAll(
                 delegate (string candidate)
                 {
-                    bool sameFolder = (0 == String.Compare(Path.GetDirectoryName(candidate),
+                    bool sameFolder = (String.Equals(Path.GetDirectoryName(candidate),
                                                            pathWithoutTrailingSlash,
                                                            StringComparison.OrdinalIgnoreCase));
                     return !sameFolder || !Regex.IsMatch(Path.GetFileName(candidate), finalPattern);
diff --git a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
index 3aeffe5ff37..c05f8d2b76e 100644
--- a/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/EvaluationLogging_Tests.cs
@@ -81,7 +81,7 @@ private static void AssertLoggingEvents(
                 var projectFile = env.CreateFile().Path;
                 File.WriteAllText(projectFile, projectContents);
 
-                firstEvaluationLogger = firstEvaluationLogger ?? new MockLogger();
+                firstEvaluationLogger ??= new MockLogger();
                 collection.RegisterLogger(firstEvaluationLogger);
 
                 var project = new Project(projectFile, null, null, collection);
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 185930eccca..c144e3651c0 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -2463,7 +2463,7 @@ public void MSBuildExtensionsPath64Default()
 
             if (!string.IsNullOrEmpty(expected))
             {
-                expected = expected + @"\MSBuild";
+                expected += @"\MSBuild";
             }
 
             Project project = new Project();
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 7e112a07c26..ba561084f8f 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -3821,7 +3821,7 @@ public void Medley()
                     caughtException = true;
                 }
                 Assert.True(
-                        (success == false || caughtException),
+                        (!success || caughtException),
                         "FAILURE: Expected '" + errorTests[i] + "' to not parse or not be evaluated but it evaluated to '" + result + "'"
                     );
             }
diff --git a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
index f9aa33d6321..f0564b0dcba 100644
--- a/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ItemSpec_Tests.cs
@@ -76,7 +76,7 @@ public void FragmentGlobsWorkAfterStateIsPartiallyInitializedByOtherOperations()
 
         private ProjectInstanceItemSpec CreateItemSpecFrom(string itemSpec, ProjectInstanceExpander expander, IElementLocation location = null)
         {
-            location = location ?? MockElementLocation.Instance;
+            location ??= MockElementLocation.Instance;
 
             return new ProjectInstanceItemSpec(itemSpec, expander, location, Path.GetDirectoryName(location.File));
         }
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index 4cde1fc90bc..844c88dc8a8 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -77,7 +77,7 @@ public static void AssertOuterBuildAsNonRoot(
 
         public static void AssertNonMultitargetingNode(ProjectGraphNode node, Dictionary<string, string> additionalGlobalProperties = null)
         {
-            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+            additionalGlobalProperties ??= new Dictionary<string, string>();
 
             IsNotMultitargeting(node).ShouldBeTrue();
             node.ProjectInstance.GlobalProperties.ShouldBeSameIgnoringOrder(EmptyGlobalProperties.AddRange(additionalGlobalProperties));
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 45734a1188c..a0b6ad62da7 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -1516,7 +1516,7 @@ private static void AssertOuterBuildAsRoot(
             Dictionary<string, string> additionalGlobalProperties = null,
             int expectedInnerBuildCount = 2)
         {
-            additionalGlobalProperties = additionalGlobalProperties ?? new Dictionary<string, string>();
+            additionalGlobalProperties ??= new Dictionary<string, string>();
 
             AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
 
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index aab69e7f57c..73013170d5e 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -422,7 +422,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
             // (current node, expected output dictionary) -> actual expected output for current node
             Func<ProjectGraphNode, ExpectedNodeBuildOutput, string[]> expectedOutputProducer = null)
         {
-            expectedOutputProducer = expectedOutputProducer ?? ((node, expectedOutputs) => expectedOutputs[node]);
+            expectedOutputProducer ??= ((node, expectedOutputs) => expectedOutputs[node]);
 
             var results = new Dictionary<string, (BuildResult Result, MockLogger Logger)>(topoSortedNodes.Count);
 
diff --git a/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
index 103589548de..808c0edc4a7 100644
--- a/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectTaskInstance_Internal_Tests.cs
@@ -66,7 +66,7 @@ public void ProjectTaskInstanceCanSerializeViaTranslator(
             IDictionary<string, (string, MockElementLocation)> parameters,
             List<ProjectTaskInstanceChild> outputs)
         {
-            parameters = parameters ?? new Dictionary<string, (string, MockElementLocation)>();
+            parameters ??= new Dictionary<string, (string, MockElementLocation)>();
 
             var parametersCopy = new Dictionary<string, (string, ElementLocation)>(parameters.Count);
             foreach (var param in parameters)
diff --git a/src/Build.UnitTests/SolutionFileBuilder.cs b/src/Build.UnitTests/SolutionFileBuilder.cs
index 5e5103b9c1b..233957ac6c2 100644
--- a/src/Build.UnitTests/SolutionFileBuilder.cs
+++ b/src/Build.UnitTests/SolutionFileBuilder.cs
@@ -132,7 +132,7 @@ public string BuildSolution()
                 }
             }
 
-            ProjectConfigurations = ProjectConfigurations ?? projectInfos.ToDictionary(
+            ProjectConfigurations ??= projectInfos.ToDictionary(
                 p => p.Key,
                 p => SolutionConfigurationPlatforms.ToDictionary(
                     sc => sc,
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 10f220aaca2..c8a2838afbb 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1291,7 +1291,7 @@ private void HandleExecuteSubmissionException(BuildSubmission submission, Except
         {
             if (ex is InvalidProjectFileException projectException)
             {
-                if (projectException.HasBeenLogged != true)
+                if (!projectException.HasBeenLogged)
                 {
                     BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                     ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(buildEventContext, projectException);
@@ -1318,7 +1318,7 @@ private void HandleExecuteSubmissionException(GraphBuildSubmission submission, E
         {
             if (ex is InvalidProjectFileException projectException)
             {
-                if (projectException.HasBeenLogged != true)
+                if (!projectException.HasBeenLogged)
                 {
                     BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                     ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(buildEventContext, projectException);
@@ -1370,7 +1370,7 @@ private void IssueBuildSubmissionToScheduler(BuildSubmission submission, bool al
                 InvalidProjectFileException projectException = ex as InvalidProjectFileException;
                 if (projectException != null)
                 {
-                    if (projectException.HasBeenLogged != true)
+                    if (!projectException.HasBeenLogged)
                     {
                         BuildEventContext projectBuildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                         ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(projectBuildEventContext, projectException);
@@ -1526,7 +1526,7 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                     foreach (var innerException in aggregateException.InnerExceptions)
                     {
                         var projectException = (InvalidProjectFileException) innerException;
-                        if (projectException.HasBeenLogged != true)
+                        if (!projectException.HasBeenLogged)
                         {
                             BuildEventContext projectBuildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
                             ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(projectBuildEventContext, projectException);
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 48a3fcedb87..57a7c8995b2 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -192,7 +192,7 @@ public void WaitForConfiguration(BuildRequestConfiguration configuration)
         {
             ErrorUtilities.VerifyThrow(configuration.WasGeneratedByNode, "Configuration has already been resolved.");
 
-            _unresolvedConfigurationsToIssue = _unresolvedConfigurationsToIssue ?? new List<BuildRequestConfiguration>();
+            _unresolvedConfigurationsToIssue ??= new List<BuildRequestConfiguration>();
             _unresolvedConfigurationsToIssue.Add(configuration);
         }
 
@@ -369,7 +369,7 @@ public void ReportResult(BuildResult result)
                 if (addResults)
                 {
                     // Update the local results record
-                    _outstandingResults = _outstandingResults ?? new Dictionary<int, BuildResult>();
+                    _outstandingResults ??= new Dictionary<int, BuildResult>();
                     ErrorUtilities.VerifyThrow(!_outstandingResults.ContainsKey(result.NodeRequestId), "Request already contains results.");
                     _outstandingResults.Add(result.NodeRequestId, result);
                 }
@@ -508,7 +508,7 @@ private void WaitForResult(BuildRequest newRequest, bool addToIssueList)
 
                 if (newRequest.IsConfigurationResolved)
                 {
-                    _outstandingRequests = _outstandingRequests ?? new Dictionary<int, BuildRequest>();
+                    _outstandingRequests ??= new Dictionary<int, BuildRequest>();
 
                     ErrorUtilities.VerifyThrow(!_outstandingRequests.ContainsKey(newRequest.NodeRequestId), "Already waiting for local request {0}", newRequest.NodeRequestId);
                     _outstandingRequests.Add(newRequest.NodeRequestId, newRequest);
@@ -516,7 +516,7 @@ private void WaitForResult(BuildRequest newRequest, bool addToIssueList)
                 else
                 {
                     ErrorUtilities.VerifyThrow(addToIssueList, "Requests with unresolved configurations should always be added to the issue list.");
-                    _unresolvedConfigurations = _unresolvedConfigurations ?? new Dictionary<int, List<BuildRequest>>();
+                    _unresolvedConfigurations ??= new Dictionary<int, List<BuildRequest>>();
 
                     if (!_unresolvedConfigurations.ContainsKey(newRequest.ConfigurationId))
                     {
@@ -528,7 +528,7 @@ private void WaitForResult(BuildRequest newRequest, bool addToIssueList)
 
                 if (addToIssueList)
                 {
-                    _requestsToIssue = _requestsToIssue ?? new List<BuildRequest>();
+                    _requestsToIssue ??= new List<BuildRequest>();
                     _requestsToIssue.Add(newRequest);
                 }
 
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
index dfc0b880b02..176c2bd91e2 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/FullyQualifiedBuildRequest.cs
@@ -24,6 +24,7 @@ internal class FullyQualifiedBuildRequest
         /// <param name="config">The configuration to use for the request.</param>
         /// <param name="targets">The set of targets to build.</param>
         /// <param name="resultsNeeded">Whether or not to wait for the results of this request.</param>
+        /// <param name="skipStaticGraphIsolationConstraints">Whether to skip the constraints of static graph isolation.</param>
         /// <param name="flags">Flags specified for the build request.</param>
         public FullyQualifiedBuildRequest(
             BuildRequestConfiguration config,
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index caeb65b2bce..34481657373 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -32,6 +32,7 @@ internal class NodeEndpointOutOfProc : NodeEndpointOutOfProcBase
         /// <param name="pipeName">The name of the pipe to which we should connect.</param>
         /// <param name="host">The component host.</param>
         /// <param name="enableReuse">Whether this node may be reused for a later build.</param>
+        /// <param name="lowPriority">Whether this node is low priority.</param>
         internal NodeEndpointOutOfProc(
             string pipeName, 
             IBuildComponentHost host,
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 4955b739cd1..6a03fba1dc7 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -99,9 +99,7 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool
         /// <summary>
         /// Shuts down all of the managed nodes permanently.
         /// </summary>
-        /// <param name="hostHandshake">host handshake key</param>
-        /// <param name="hostHandshakeWithLowPriority">host handshake key with low priority added</param>
-        /// <param name="clientHandshake">client handshake key</param>
+        /// <param name="nodeReuse">Whether to reuse the node</param>
         /// <param name="terminateNode">Delegate used to tell the node provider that a context has terminated</param>
         protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate terminateNode)
         {
@@ -424,12 +422,12 @@ private int LaunchNode(string msbuildLocation, string commandLineArgs)
                     startInfo.hStdInput = BackendNativeMethods.InvalidHandle;
                     startInfo.hStdOutput = BackendNativeMethods.InvalidHandle;
                     startInfo.dwFlags = BackendNativeMethods.STARTFUSESTDHANDLES;
-                    creationFlags = creationFlags | BackendNativeMethods.CREATENOWINDOW;
+                    creationFlags |= BackendNativeMethods.CREATENOWINDOW;
                 }
             }
             else
             {
-                creationFlags = creationFlags | BackendNativeMethods.CREATE_NEW_CONSOLE;
+                creationFlags |= BackendNativeMethods.CREATE_NEW_CONSOLE;
             }
 
             BackendNativeMethods.SECURITY_ATTRIBUTES processSecurityAttributes = new BackendNativeMethods.SECURITY_ATTRIBUTES();
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index 6e18d9ec4ef..4e57c5f2ae1 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.BackEnd
     internal delegate IBuildComponent BuildComponentFactoryDelegate(BuildComponentType type);
 
     /// <summary>
-    /// An enumeration of all component types recognized by the system    
+    /// An enumeration of all component types recognized by the system
     /// </summary>
     internal enum BuildComponentType
     {
@@ -95,7 +95,7 @@ internal enum BuildComponentType
         RequestBuilder,
 
         /// <summary>
-        /// The component responsible for building targets.        
+        /// The component responsible for building targets.
         /// </summary>
         TargetBuilder,
 
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 04b7ac6c238..02fdef8be56 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -202,14 +202,14 @@ bool IncludeTaskInputs
         /// <summary>
         /// Adds a set of warning codes to treat as low importance messages for the specified project instance ID.
         /// </summary>
-        /// <param name="projectInstanceId">A <see cref="BuildEventContext.ProjectInstanceId"/> to associate with the list of warning codes.</param>
+        /// <param name="buildEventContext">A <see cref="BuildEventContext"/> to associate with the list of warning codes.</param>
         /// <param name="codes">The list of warning codes to treat as low importance messsages.</param>
         void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet<string> codes);
 
         /// <summary>
         /// Adds a set of warning codes to treat as errors for the specified project instance ID.
         /// </summary>
-        /// <param name="projectInstanceId">A <see cref="BuildEventContext.ProjectInstanceId"/> to associate with the list of warning codes.</param>
+        /// <param name="buildEventContext">A <see cref="BuildEventContext"/> to associate with the list of warning codes.</param>
         /// <param name="codes">The list of warning codes to treat as errors.</param>
         void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet<string> codes);
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index aab7e18ae35..18ab9c2a2f5 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -121,7 +121,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         private bool _onlyLogCriticalEvents;
 
         /// <summary>
-        /// Contains a dictionary of loggerId's and the sink which the logger (of the given Id) is expecting to consume its messages 
+        /// Contains a dictionary of loggerId's and the sink which the logger (of the given Id) is expecting to consume its messages
         /// </summary>
         private Dictionary<int, IBuildEventSink> _eventSinkDictionary;
 
@@ -137,7 +137,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
         private List<LoggerDescription> _loggerDescriptions;
 
         /// <summary>
-        /// The event source to which filters will listen to get the build events which are logged to the logging service through the 
+        /// The event source to which filters will listen to get the build events which are logged to the logging service through the
         /// logging helper methods. Ie LogMessage and LogMessageEvent
         /// </summary>
         private EventSourceSink _filterEventSource;
@@ -245,7 +245,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler, IBu
 
         /// <summary>
         /// By default our logMode is Asynchronous. We do this
-        /// because we are hoping it will make the system 
+        /// because we are hoping it will make the system
         /// more responsive when there are a large number of logging messages
         /// </summary>
         private LoggerMode _logMode = LoggerMode.Asynchronous;
@@ -444,7 +444,7 @@ public int MaxCPUCount
 
         /// <summary>
         /// The list of descriptions which describe how to create forwarding loggers on a node.
-        /// This is used by the node provider to get a list of registered descriptions so that 
+        /// This is used by the node provider to get a list of registered descriptions so that
         /// they can be transmitted to child nodes.
         /// </summary>
         public ICollection<LoggerDescription> LoggerDescriptions => _loggerDescriptions;
@@ -455,7 +455,7 @@ public int MaxCPUCount
         public ICollection<ILogger> Loggers => _loggers;
 
         /// <summary>
-        /// What type of logging mode is the logger running under. 
+        /// What type of logging mode is the logger running under.
         /// Is it Synchronous or Asynchronous
         /// </summary>
         public LoggerMode LoggingMode => _logMode;
@@ -483,7 +483,7 @@ public ISet<string> WarningsAsMessages
         /// </summary>
         public bool IncludeEvaluationMetaprojects
         {
-            get => (_includeEvaluationMetaprojects = _includeEvaluationMetaprojects ?? _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationMetaprojects)).Value;
+            get => _includeEvaluationMetaprojects ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationMetaprojects);
             set => _includeEvaluationMetaprojects = value;
         }
 
@@ -492,7 +492,7 @@ public bool IncludeEvaluationMetaprojects
         /// </summary>
         public bool IncludeEvaluationProfile
         {
-            get => (_includeEvaluationProfile = _includeEvaluationProfile ??_eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationProfiles)).Value;
+            get => _includeEvaluationProfile ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeEvaluationProfiles);
             set => _includeEvaluationProfile = value;
         }
 
@@ -501,7 +501,7 @@ public bool IncludeEvaluationProfile
         /// </summary>
         public bool IncludeTaskInputs
         {
-            get => (_includeTaskInputs = _includeTaskInputs ?? _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeTaskInputs)).Value;
+            get => _includeTaskInputs ??= _eventSinkDictionary.Values.OfType<EventSourceSink>().Any(sink => sink.IncludeTaskInputs);
             set => _includeTaskInputs = value;
         }
 
@@ -870,11 +870,11 @@ public void UnregisterAllLoggers()
         }
 
         /// <summary>
-        /// Register a distributed logger. This involves creating a new eventsource sink 
-        /// and associating this with the central logger. In addition the sinkId needs 
-        /// to be put in the loggerDescription so that nodes know what they need to 
+        /// Register a distributed logger. This involves creating a new eventsource sink
+        /// and associating this with the central logger. In addition the sinkId needs
+        /// to be put in the loggerDescription so that nodes know what they need to
         /// tag onto the event so that the message goes to the correct logger.
-        /// 
+        ///
         /// The central logger is initialized before the distributed logger
         /// </summary>
         /// <param name="centralLogger">Central logger to receive messages from the forwarding logger, This logger cannot have been registered before</param>
@@ -997,7 +997,7 @@ public void InitializeNodeLoggers(ICollection<LoggerDescription> descriptions, I
         /// <summary>
         /// Will Log a build Event. Will also take into account OnlyLogCriticalEvents when determining
         /// if to drop the event or to log it.
-        /// 
+        ///
         /// Only the following events will be logged if OnlyLogCriticalEvents is true:
         /// CustomEventArgs
         /// BuildErrorEventArgs
@@ -1053,7 +1053,7 @@ public void LogBuildEvent(BuildEventArgs buildEvent)
 
         /// <summary>
         /// This method will becalled from multiple threads in asynchronous mode.
-        /// 
+        ///
         /// Determine where to send the buildevent either to the filters or to a specific sink.
         /// When in Asynchronous mode the event should to into the logging queue (as long as we are initialized).
         /// In Synchronous mode the event should be routed to the correct sink or logger right away
@@ -1366,7 +1366,7 @@ private void RouteBuildEvent(object loggingEvent)
         }
 
         /// <summary>
-        /// Route the build event to the correct filter or sink depending on what the sinId is in the build event. 
+        /// Route the build event to the correct filter or sink depending on what the sinId is in the build event.
         /// </summary>
         private void RouteBuildEvent(KeyValuePair<int, BuildEventArgs> nodeEvent)
         {
@@ -1485,10 +1485,10 @@ private void InitializeLogger(ILogger logger, IEventSource sourceForLogger)
         }
 
         /// <summary>
-        /// When an exception is raised in the logging thread, we do not want the application to terminate right away. 
+        /// When an exception is raised in the logging thread, we do not want the application to terminate right away.
         /// Whidbey and orcas msbuild have the logger exceptions occurring on the engine thread so that the host can
         /// catch and deal with these exceptions as they may occur somewhat frequently due to user generated loggers.
-        /// This method will raise the exception on a delegate to which the engine is registered to. This delegate will 
+        /// This method will raise the exception on a delegate to which the engine is registered to. This delegate will
         /// send the exception to the engine so that it can be raised on the engine thread.
         /// </summary>
         /// <param name="ex">Exception to raise to event handlers</param>
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index ee3e3794976..409c75b14be 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -171,7 +171,7 @@ internal TargetLoggingContext LogTargetBatchStarted(string projectFullPath, Proj
         /// </summary>
         /// <remarks>
         /// This class is designed to be passed to loggers.
-        /// The expense of copying items is only incurred if and when 
+        /// The expense of copying items is only incurred if and when
         /// a logger chooses to enumerate over it.
         /// The type of the items enumerated over is imposed by backwards compatibility for ProjectStartedEvent.
         /// </remarks>
@@ -221,7 +221,7 @@ IEnumerator IEnumerable.GetEnumerator()
         /// </summary>
         /// <remarks>
         /// This class is designed to be passed to loggers.
-        /// The expense of copying items is only incurred if and when 
+        /// The expense of copying items is only incurred if and when
         /// a logger chooses to enumerate over it.
         /// The type of the items enumerated over is imposed by backwards compatibility for ProjectStartedEvent.
         /// </remarks>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index 02d22f3a0cd..f0485c1d0eb 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -132,7 +132,7 @@ ElementLocation elementLocation
                 // Add any item types that we were explicitly told to assume.
                 if (implicitBatchableItemType != null)
                 {
-                    consumedItemReferences = consumedItemReferences ?? new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                    consumedItemReferences ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
                     consumedItemReferences.Add(implicitBatchableItemType);
                 }
 
@@ -232,7 +232,7 @@ ElementLocation elementLocation
                     // in the tag anywhere.  Adding it to this list allows us (down below in this
                     // method) to check that every item in this list has a value for each 
                     // unqualified metadata reference.
-                    consumedItemReferenceNames = consumedItemReferenceNames ?? new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                    consumedItemReferenceNames ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
                     consumedItemReferenceNames.Add(consumedMetadataReference.ItemName);
                 }
             }
@@ -395,7 +395,7 @@ ElementLocation elementLocation
 
                 if (
                         (metadataItemName != null) &&
-                        (0 != String.Compare(item.ItemType, metadataItemName, StringComparison.OrdinalIgnoreCase))
+                        (!String.Equals(item.ItemType, metadataItemName, StringComparison.OrdinalIgnoreCase))
                     )
                 {
                     itemMetadataValues[metadataQualifiedName] = String.Empty;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
index 38b986e050f..c278aa84730 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IRequestBuilder.cs
@@ -28,6 +28,7 @@ namespace Microsoft.Build.BackEnd
     /// <param name="issuingEntry">The build request entry which is being blocked.</param>
     /// <param name="blockingGlobalRequestId">The request on which we are blocked.</param>
     /// <param name="blockingTarget">The target on which we are blocked.</param>
+    /// <param name="partialBuildResult">The partial build result on which we are blocked.</param>
     internal delegate void BuildRequestBlockedDelegate(BuildRequestEntry issuingEntry, int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult);
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index d87997b4a68..844924e7625 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -235,6 +235,8 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
         /// </summary>
         /// <param name="child">The item specification to evaluate and remove.</param>
         /// <param name="bucket">The batching bucket.</param>
+        /// <param name="matchOnMetadata">Metadata matching.</param>
+        /// <param name="matchingOptions">Options matching.</param>
         private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, HashSet<string> matchOnMetadata, MatchOnMetadataOptions matchingOptions)
         {
             ICollection<ProjectItemInstance> group = bucket.Lookup.GetItems(child.ItemType);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 1e941967529..6e1484e42b7 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -378,13 +378,13 @@ private void MergeScopeIntoLastScope()
             // adds to the world
             if (PrimaryAddTable != null)
             {
-                SecondaryTable = SecondaryTable ?? new ItemDictionary<ProjectItemInstance>();
+                SecondaryTable ??= new ItemDictionary<ProjectItemInstance>();
                 SecondaryTable.ImportItems(PrimaryAddTable);
             }
 
             if (PrimaryRemoveTable != null)
             {
-                SecondaryTable = SecondaryTable ?? new ItemDictionary<ProjectItemInstance>();
+                SecondaryTable ??= new ItemDictionary<ProjectItemInstance>();
                 SecondaryTable.RemoveItems(PrimaryRemoveTable);
             }
 
@@ -392,14 +392,14 @@ private void MergeScopeIntoLastScope()
             {
                 foreach (KeyValuePair<string, Dictionary<ProjectItemInstance, MetadataModifications>> entry in PrimaryModifyTable)
                 {
-                    SecondaryTable = SecondaryTable ?? new ItemDictionary<ProjectItemInstance>();
+                    SecondaryTable ??= new ItemDictionary<ProjectItemInstance>();
                     ApplyModificationsToTable(SecondaryTable, entry.Key, entry.Value);
                 }
             }
 
             if (PrimaryPropertySets != null)
             {
-                SecondaryProperties = SecondaryProperties ?? new PropertyDictionary<ProjectPropertyInstance>(PrimaryPropertySets.Count);
+                SecondaryProperties ??= new PropertyDictionary<ProjectPropertyInstance>(PrimaryPropertySets.Count);
                 SecondaryProperties.ImportProperties(PrimaryPropertySets);
             }
         }
@@ -479,7 +479,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> adds = scope.Adds[itemType];
                     if (adds.Count != 0)
                     {
-                        allAdds = allAdds ?? new List<ProjectItemInstance>(adds.Count);
+                        allAdds ??= new List<ProjectItemInstance>(adds.Count);
                         allAdds.AddRange(adds);
                     }
                 }
@@ -490,7 +490,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     ICollection<ProjectItemInstance> removes = scope.Removes[itemType];
                     if (removes.Count != 0)
                     {
-                        allRemoves = allRemoves ?? new List<ProjectItemInstance>(removes.Count);
+                        allRemoves ??= new List<ProjectItemInstance>(removes.Count);
                         allRemoves.AddRange(removes);
                     }
                 }
@@ -503,7 +503,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
                     {
                         if (modifies.Count != 0)
                         {
-                            allModifies = allModifies ?? new Dictionary<ProjectItemInstance, MetadataModifications>(modifies.Count);
+                            allModifies ??= new Dictionary<ProjectItemInstance, MetadataModifications>(modifies.Count);
 
                             // We already have some modifies for this type
                             foreach (KeyValuePair<ProjectItemInstance, MetadataModifications> modify in modifies)
@@ -538,7 +538,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
             {
                 // We can just hand out this group verbatim -
                 // that avoids any importing
-                groupFound = groupFound ?? Array.Empty<ProjectItemInstance>();
+                groupFound ??= Array.Empty<ProjectItemInstance>();
 
                 return groupFound;
             }
@@ -593,7 +593,7 @@ public ICollection<ProjectItemInstance> GetItems(string itemType)
         /// </summary>
         internal void PopulateWithItems(string itemType, ICollection<ProjectItemInstance> group)
         {
-            PrimaryTable = PrimaryTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryTable ??= new ItemDictionary<ProjectItemInstance>();
             ICollection<ProjectItemInstance> existing = PrimaryTable[itemType];
             ErrorUtilities.VerifyThrow(existing.Count == 0, "Cannot add an itemgroup of this type.");
 
@@ -613,7 +613,7 @@ internal void PopulateWithItems(string itemType, ICollection<ProjectItemInstance
         /// </summary>
         internal void PopulateWithItem(ProjectItemInstance item)
         {
-            PrimaryTable = PrimaryTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryTable ??= new ItemDictionary<ProjectItemInstance>();
             PrimaryTable.Add(item);
         }
 
@@ -626,7 +626,7 @@ internal void SetProperty(ProjectPropertyInstance property)
             MustNotBeOuterScope();
 
             // Put in the set table
-            PrimaryPropertySets = PrimaryPropertySets ?? new PropertyDictionary<ProjectPropertyInstance>();
+            PrimaryPropertySets ??= new PropertyDictionary<ProjectPropertyInstance>();
             PrimaryPropertySets.Set(property);
         }
 
@@ -651,7 +651,7 @@ internal void AddNewItemsOfItemType(string itemType, ICollection<ProjectItemInst
             }
 
             // Put them in the add table
-            PrimaryAddTable = PrimaryAddTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryAddTable ??= new ItemDictionary<ProjectItemInstance>();
             IEnumerable<ProjectItemInstance> itemsToAdd = group;
             if (doNotAddDuplicates)
             {
@@ -684,7 +684,7 @@ internal void AddNewItem(ProjectItemInstance item)
 #endif
 
             // Put in the add table
-            PrimaryAddTable = PrimaryAddTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryAddTable ??= new ItemDictionary<ProjectItemInstance>();
             PrimaryAddTable.Add(item);
         }
 
@@ -710,7 +710,7 @@ internal void RemoveItem(ProjectItemInstance item)
             item = RetrieveOriginalFromCloneTable(item);
 
             // Put in the remove table
-            PrimaryRemoveTable = PrimaryRemoveTable ?? new ItemDictionary<ProjectItemInstance>();
+            PrimaryRemoveTable ??= new ItemDictionary<ProjectItemInstance>();
             PrimaryRemoveTable.Add(item);
 
             // No need to remove this item from the primary add table if it's 
@@ -753,7 +753,7 @@ internal void ModifyItems(string itemType, ICollection<ProjectItemInstance> grou
 
             // We don't need to check whether the item is in the add table vs. the main table; either
             // way the modification will be applied.
-            PrimaryModifyTable = PrimaryModifyTable ?? new ItemTypeToItemsMetadataUpdateDictionary(MSBuildNameIgnoreCaseComparer.Default);
+            PrimaryModifyTable ??= new ItemTypeToItemsMetadataUpdateDictionary(MSBuildNameIgnoreCaseComparer.Default);
             Dictionary<ProjectItemInstance, MetadataModifications> modifiesOfType;
             if (!PrimaryModifyTable.TryGetValue(itemType, out modifiesOfType))
             {
@@ -790,7 +790,7 @@ private void ApplyModifies(ItemDictionary<ProjectItemInstance> result, Dictionar
             // FUTURE - don't need to clone here for non intrinsic tasks, but at present, they don't do modifies
 
             // Store the clone, in case we're asked to modify or remove it later (we will record it against the real item)
-            _cloneTable = _cloneTable ?? new Dictionary<ProjectItemInstance, ProjectItemInstance>();
+            _cloneTable ??= new Dictionary<ProjectItemInstance, ProjectItemInstance>();
 
             foreach (var modify in allModifies)
             {
@@ -1271,7 +1271,7 @@ public bool Remove
             /// </summary>
             public bool KeepValue
             {
-                get { return (_remove == false && _newValue == null); }
+                get { return (!_remove && _newValue == null); }
             }
 
             /// <summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 50ab2f1fb1a..048dec2c69c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -990,7 +990,7 @@ private void RaiseOnBlockedRequest(int blockingGlobalRequestId, string blockingT
         /// This method is called to reset the current directory to the one appropriate for this project.  It should be called any time
         /// the project is resumed.
         /// If the directory does not exist, does nothing.
-        /// This is because if the project has not been saved, this directory may not exist, yet it is often useful to still be able to build the project. 
+        /// This is because if the project has not been saved, this directory may not exist, yet it is often useful to still be able to build the project.
         /// No errors are masked by doing this: errors loading the project from disk are reported at load time, if necessary.
         /// </summary>
         private void SetProjectCurrentDirectory()
@@ -1293,7 +1293,7 @@ private ISet<string> ParseWarningCodes(string warnings)
             {
                 return null;
             }
-            
+
             return new HashSet<string>(ExpressionShredder.SplitSemiColonSeparatedList(warnings), StringComparer.OrdinalIgnoreCase);
         }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index 0da7932c92c..cf38d87a357 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -26,11 +26,11 @@ namespace Microsoft.Build.BackEnd
     /// pushed onto the stack.  The main loop for the Target Builder simply evaluates the top item on the stack to determine
     /// which action to take.  These actions comprise the target state machine, as represented by the states of the
     /// TargetEntry object.
-    /// 
+    ///
     /// When a target completes, all of its outputs are available in the Lookup contained in the TargetEntry.  In fact, everything that it changed
     /// in the global state is available by virtue of its Lookup being merged with the current Target's lookup.
-    /// 
-    /// For CallTarget tasks, this behavior is not the same.  Rather the Lookup from a CallTarget call does not get merged until the calling 
+    ///
+    /// For CallTarget tasks, this behavior is not the same.  Rather the Lookup from a CallTarget call does not get merged until the calling
     /// Target has completed.  This is considered erroneous behavior and 'normal' version of CallTarget will be implemented which does not exhibit
     /// this.
     /// </remarks>
@@ -588,9 +588,9 @@ private bool CheckSkipTarget(ref bool stopProcessingStack, TargetEntry currentTa
         }
 
         /// <summary>
-        /// When a target build fails, we don't just stop building that target; we also pop all of the other dependency targets of its 
-        /// parent target off the stack. Extract that logic into a standalone method so that it can be used when dealing with targets that 
-        /// are skipped-unsuccessful as well as first-time failures. 
+        /// When a target build fails, we don't just stop building that target; we also pop all of the other dependency targets of its
+        /// parent target off the stack. Extract that logic into a standalone method so that it can be used when dealing with targets that
+        /// are skipped-unsuccessful as well as first-time failures.
         /// </summary>
         private void PopDependencyTargetsOnTargetFailure(TargetEntry topEntry, TargetResult targetResult, ref bool stopProcessingStack)
         {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 1b868063b93..4e7d49cb87c 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -32,7 +32,7 @@ internal enum TargetEntryState
     {
         /// <summary>
         /// The target's dependencies need to be evaluated and pushed onto the target stack.
-        /// 
+        ///
         /// Transitions:
         /// Execution, ErrorExecution
         /// </summary>
@@ -40,7 +40,7 @@ internal enum TargetEntryState
 
         /// <summary>
         /// The target is ready to execute its tasks, batched as needed.
-        /// 
+        ///
         /// Transitions:
         /// ErrorExecution, Completed
         /// </summary>
@@ -48,7 +48,7 @@ internal enum TargetEntryState
 
         /// <summary>
         /// The target is ready to provide error tasks.
-        /// 
+        ///
         /// Transitions:
         /// None
         /// </summary>
@@ -56,7 +56,7 @@ internal enum TargetEntryState
 
         /// <summary>
         /// The target has finished building.  All of the results are in the Lookup.
-        /// 
+        ///
         /// Transitions:
         /// None
         /// </summary>
@@ -243,7 +243,7 @@ internal TargetResult Result
         }
 
         /// <summary>
-        /// Retrieves the Lookup this target was initialized with, including any modifications which have 
+        /// Retrieves the Lookup this target was initialized with, including any modifications which have
         /// been made to it while running.
         /// </summary>
         internal Lookup Lookup
@@ -853,7 +853,7 @@ private async Task<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder, Targe
         }
 
         /// <summary>
-        /// Gets the task execution mode based 
+        /// Gets the task execution mode based
         /// </summary>
         /// <param name="analysis">The result of the up-to-date check.</param>
         /// <returns>The mode to be used to execute tasks.</returns>
@@ -874,7 +874,7 @@ private TaskExecutionMode GetTaskExecutionMode(DependencyAnalysisResult analysis
             if ((analysis == DependencyAnalysisResult.FullBuild) ||
                 (analysis == DependencyAnalysisResult.IncrementalBuild))
             {
-                executionMode = executionMode | TaskExecutionMode.ExecuteTaskAndGatherOutputs;
+                executionMode |= TaskExecutionMode.ExecuteTaskAndGatherOutputs;
             }
 
             return executionMode;
@@ -892,7 +892,7 @@ private void VerifyState(TargetEntryState actual, TargetEntryState expected)
 
         /// <summary>
         /// Gets the list of parameters which are batchable for a target
-        /// PERF: (Refactor) This used to be a method on the target, and it would 
+        /// PERF: (Refactor) This used to be a method on the target, and it would
         /// cache its values so this would only be computed once for each
         /// target.  We should consider doing something similar for perf reasons.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index b8afb6b8c86..82742a61bfd 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -48,7 +48,7 @@ internal enum ContinueOnError
 
     /// <summary>
     /// The TaskBuilder is one of two components related to building tasks, the other being the TaskExecutionHost.  The TaskBuilder is
-    /// responsible for all parts dealing with the XML/task declaration.  It determines if the task is intrinsic or extrinsic, 
+    /// responsible for all parts dealing with the XML/task declaration.  It determines if the task is intrinsic or extrinsic,
     /// looks up the task in the task registry, determines the task parameters and requests them to be set, and requests outputs
     /// when task execution has been completed.  It is not responsible for reflection over the task instance or anything which
     /// requires dealing with the task instance directly - those actions are handled by the TaskExecutionHost.
@@ -77,7 +77,7 @@ internal class TaskBuilder : ITaskBuilder, IBuildComponent
 
         /// <summary>
         /// The task instance for extrinsic tasks
-        /// </summary> 
+        /// </summary>
         private ProjectTaskInstance _taskNode;
 
         /// <summary>
@@ -87,7 +87,7 @@ internal class TaskBuilder : ITaskBuilder, IBuildComponent
 
         /// <summary>
         /// indicates whether to ignore task execution failures
-        /// </summary> 
+        /// </summary>
         private ContinueOnError _continueOnError;
 
         /// <summary>
@@ -135,7 +135,7 @@ internal TaskBuilder()
         /// <param name="cancellationToken">The <see cref="CancellationToken"/> to use when executing the task.</param>
         /// <returns>The result of running the task batch.</returns>
         /// <remarks>
-        /// The ExecuteTask method takes a task as specified by XML and executes it.  This procedure is comprised 
+        /// The ExecuteTask method takes a task as specified by XML and executes it.  This procedure is comprised
         /// of the following steps:
         /// 1. Loading the Task from its containing assembly by looking it up in the task registry
         /// 2. Determining if the task is batched.  If it is, create the batches and execute each as if it were a non-batched task
@@ -281,7 +281,7 @@ private List<string> CreateListOfParameterValues()
         }
 
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         /// <returns>true, if successful</returns>
         private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lookup)
@@ -331,7 +331,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                         break;
                     }
                 }
-                
+
                 taskResult = aggregateResult;
             }
             finally
@@ -360,7 +360,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
         /// <summary>
         /// Execute a single bucket
         /// </summary>
-        /// <returns>true if execution succeeded</returns>        
+        /// <returns>true if execution succeeded</returns>
         private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask, Dictionary<string, string> lookupHash)
         {
             // On Intrinsic tasks, we do not allow batchable params, therefore metadata is excluded.
@@ -512,7 +512,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
         }
 
         /// <summary>
-        /// Returns the set of parameters that can contribute to a task's identity, and their values for this particular task.  
+        /// Returns the set of parameters that can contribute to a task's identity, and their values for this particular task.
         /// </summary>
         private IDictionary<string, string> GatherTaskIdentityParameters(Expander<ProjectPropertyInstance, ProjectItemInstance> expander)
         {
@@ -544,8 +544,8 @@ private IDictionary<string, string> GatherTaskIdentityParameters(Expander<Projec
         /// Executes the task using an STA thread.
         /// </summary>
         /// <comment>
-        /// STA thread launching also being used in XMakeCommandLine\OutOfProcTaskAppDomainWrapperBase.cs, InstantiateAndExecuteTaskInSTAThread method.  
-        /// Any bug fixes made to this code, please ensure that you also fix that code.  
+        /// STA thread launching also being used in XMakeCommandLine\OutOfProcTaskAppDomainWrapperBase.cs, InstantiateAndExecuteTaskInSTAThread method.
+        /// Any bug fixes made to this code, please ensure that you also fix that code.
         /// </comment>
         [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Exception is caught and rethrown in the correct thread.")]
         private WorkUnitResult ExecuteTaskInSTAThread(ItemBucket bucket, TaskLoggingContext taskLoggingContext, IDictionary<string, string> taskIdentityParameters, TaskHost taskHost, TaskExecutionMode howToExecuteTask)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 8ca8c3dce58..95b3a212c20 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -37,7 +37,7 @@ internal class TaskHost :
         IBuildEngine7
     {
         /// <summary>
-        /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set. 
+        /// True if the "secret" environment variable MSBUILDNOINPROCNODE is set.
         /// </summary>
         private static bool s_onlyUseOutOfProcNodes = Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") == "1";
 
@@ -131,7 +131,7 @@ public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, Elemen
         /// Returns true in the multiproc case
         /// </summary>
         /// <comment>
-        /// If MSBUILDNOINPROCNODE is set, then even if there's only one node in the buildparameters, it will be an out-of-proc node.  
+        /// If MSBUILDNOINPROCNODE is set, then even if there's only one node in the buildparameters, it will be an out-of-proc node.
         /// </comment>
         public bool IsRunningMultipleNodes
         {
@@ -320,7 +320,7 @@ public bool BuildProjectFilesInParallel(string[] projectFileNames, string[] targ
         #region IBuildEngine3 Members
 
         /// <summary>
-        /// Builds multiple project files in parallel. 
+        /// Builds multiple project files in parallel.
         /// Thread safe.
         /// </summary>
         /// <param name="projectFileNames">The list of projects to build</param>
@@ -726,7 +726,7 @@ public async Task<BuildEngineResult> InternalBuildProjects(string[] projectFileN
 #if FEATURE_APPDOMAIN
         /// <inheritdoc />
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// </summary>
         /// <returns>The lease object to control this object's lifetime.</returns>
@@ -966,7 +966,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                         }
                     }
 
-                    ErrorUtilities.VerifyThrow(results.Length == projectFileNames.Length || overallSuccess == false, "The number of results returned {0} cannot be less than the number of project files {1} unless one of the results indicated failure.", results.Length, projectFileNames.Length);
+                    ErrorUtilities.VerifyThrow(results.Length == projectFileNames.Length || !overallSuccess, "The number of results returned {0} cannot be less than the number of project files {1} unless one of the results indicated failure.", results.Length, projectFileNames.Length);
                 }
 
                 BuildRequestsSucceeded = overallSuccess;
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
index 3bd3b5969da..228827e77ee 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulableRequest.cs
@@ -325,7 +325,7 @@ public void Reacquire()
         /// </summary>
         /// <param name="blockingRequest">The request which is blocking this one.</param>
         /// <param name="activeTargets">The list of targets this request was currently building at the time it became blocked.</param>
-        /// <param name="blockerBlockingTarget">Target that we are blocked on which is being built by <paramref name="blockingRequest"/></param>
+        /// <param name="blockingTarget">Target that we are blocked on which is being built by <paramref name="blockingRequest"/></param>
         public void BlockByRequest(SchedulableRequest blockingRequest, string[] activeTargets, string blockingTarget = null)
         {
             VerifyOneOfStates(new SchedulableRequestState[] { SchedulableRequestState.Blocked, SchedulableRequestState.Executing });
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 4a02fe60a6d..a85292ea0b8 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -33,9 +33,9 @@ internal class Scheduler : IScheduler
         internal const int InvalidNodeId = -1;
 
         /// <summary>
-        /// ID used to indicate that the results for a particular configuration may at one point 
-        /// have resided on this node, but currently do not and will need to be transferred back 
-        /// in order to be used.  
+        /// ID used to indicate that the results for a particular configuration may at one point
+        /// have resided on this node, but currently do not and will need to be transferred back
+        /// in order to be used.
         /// </summary>
         internal const int ResultsTransferredId = -2;
 
@@ -50,8 +50,8 @@ internal class Scheduler : IScheduler
         internal const int VirtualNode = 0;
 
         /// <summary>
-        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the default multiplier for the amount by which 
-        /// the count of configurations on any one node can exceed the average configuration count is 1.1 -- 
+        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the default multiplier for the amount by which
+        /// the count of configurations on any one node can exceed the average configuration count is 1.1 --
         /// + 10%.
         /// </summary>
         private const double DefaultCustomSchedulerForSQLConfigurationLimitMultiplier = 1.1;
@@ -81,13 +81,13 @@ internal class Scheduler : IScheduler
         private Dictionary<int, NodeInfo> _availableNodes;
 
         /// <summary>
-        /// The number of inproc nodes that can be created without hitting the 
+        /// The number of inproc nodes that can be created without hitting the
         /// node limit.
         /// </summary>
         private int _currentInProcNodeCount = 0;
 
         /// <summary>
-        /// The number of out-of-proc nodes that can be created without hitting the 
+        /// The number of out-of-proc nodes that can be created without hitting the
         /// node limit.
         /// </summary>
         private int _currentOutOfProcNodeCount = 0;
@@ -135,9 +135,9 @@ internal class Scheduler : IScheduler
         private string _debugDumpPath;
 
         /// <summary>
-        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the user may also choose to set 
-        /// MSBUILDCUSTOMSCHEDULERFORSQLCONFIGURATIONLIMITMULTIPLIER to the value by which they want 
-        /// the max configuration count for any one node to exceed the average configuration count.  
+        /// If MSBUILDCUSTOMSCHEDULER = CustomSchedulerForSQL, the user may also choose to set
+        /// MSBUILDCUSTOMSCHEDULERFORSQLCONFIGURATIONLIMITMULTIPLIER to the value by which they want
+        /// the max configuration count for any one node to exceed the average configuration count.
         /// If that env var is not set, or is set to an invalid value (negative, less than 1, non-numeric)
         /// then we use the default value instead.
         /// </summary>
@@ -198,8 +198,8 @@ public Scheduler()
         #region Delegates
 
         /// <summary>
-        /// In the circumstance where we want to specify the scheduling algorithm via the secret environment variable 
-        /// MSBUILDCUSTOMSCHEDULING, the scheduling algorithm used will be assigned to a delegate of this type. 
+        /// In the circumstance where we want to specify the scheduling algorithm via the secret environment variable
+        /// MSBUILDCUSTOMSCHEDULING, the scheduling algorithm used will be assigned to a delegate of this type.
         /// </summary>
         internal delegate void AssignUnscheduledRequestsDelegate(List<ScheduleResponse> responses, HashSet<int> idleNodes);
 
@@ -742,8 +742,8 @@ private void AssignUnscheduledRequestsToNodes(List<ScheduleResponse> responses,
         }
 
         /// <summary>
-        /// Reads in the scheduling plan if one exists and has not previously been read; returns true if the scheduling plan 
-        /// both exists and is valid, or false otherwise. 
+        /// Reads in the scheduling plan if one exists and has not previously been read; returns true if the scheduling plan
+        /// both exists and is valid, or false otherwise.
         /// </summary>
         private bool GetSchedulingPlanAndAlgorithm()
         {
@@ -1164,13 +1164,13 @@ private void AssignUnscheduledRequestsFIFO(List<ScheduleResponse> responses, Has
         }
 
         /// <summary>
-        /// Custom scheduler for the SQL folks to solve a performance problem with their builds where they end up with a few long-running 
-        /// requests on all but one node, and then a very large number of short-running requests on that one node -- which is by design for 
-        /// our current scheduler, but makes it so that later in the build, when these configurations are re-entered with new requests, the 
-        /// build becomes essentially serial because so many of the configurations are tied to that one node.  
-        /// 
-        /// Fixes that problem by intentionally choosing to refrain from assigning new configurations to idle nodes if those idle nodes already 
-        /// have more than their fair share of the existing configurations assigned to them. 
+        /// Custom scheduler for the SQL folks to solve a performance problem with their builds where they end up with a few long-running
+        /// requests on all but one node, and then a very large number of short-running requests on that one node -- which is by design for
+        /// our current scheduler, but makes it so that later in the build, when these configurations are re-entered with new requests, the
+        /// build becomes essentially serial because so many of the configurations are tied to that one node.
+        ///
+        /// Fixes that problem by intentionally choosing to refrain from assigning new configurations to idle nodes if those idle nodes already
+        /// have more than their fair share of the existing configurations assigned to them.
         /// </summary>
         private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List<ScheduleResponse> responses, HashSet<int> idleNodes)
         {
@@ -1328,14 +1328,14 @@ private bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId)
 
         /// <summary>
         /// Adds CreateNode responses to satisfy all the affinities in the list of requests, with the following constraints:
-        /// 
+        ///
         /// a) Issue no more than one response to create an inproc node, and aggressively issues as many requests for an out-of-proc node
-        ///    as there are requests to assign to them. 
-        ///    
+        ///    as there are requests to assign to them.
+        ///
         /// b) Don't exceed the max node count, *unless* there isn't even one node of the necessary affinity yet. (That means that even if there's a max
-        ///    node count of e.g., 3, and we have already created 3 out of proc nodes, we will still create an inproc node if affinity requires it; if 
+        ///    node count of e.g., 3, and we have already created 3 out of proc nodes, we will still create an inproc node if affinity requires it; if
         ///    we didn't, the build would jam.)
-        ///    
+        ///
         /// Returns true if there is a pending response to create a new node.
         /// </summary>
         private bool CreateNewNodeIfPossible(List<ScheduleResponse> responses, IEnumerable<SchedulableRequest> requests)
@@ -1685,7 +1685,7 @@ private void ResumeReadyRequestIfAny(int nodeId, List<ScheduleResponse> response
         }
 
         /// <summary>
-        /// Attempts to get results from the cache for this request.  If results are available, reports them to the 
+        /// Attempts to get results from the cache for this request.  If results are available, reports them to the
         /// correct node.  If that action causes the parent to become ready and its node is idle, the parent is
         /// resumed.
         /// </summary>
@@ -1973,8 +1973,8 @@ private NodeAffinity GetNodeAffinityForRequest(BuildRequest request)
         }
 
         /// <summary>
-        /// Iterates through the set of available nodes and checks whether any of them is 
-        /// capable of servicing this request or any of the requests that it is blocked 
+        /// Iterates through the set of available nodes and checks whether any of them is
+        /// capable of servicing this request or any of the requests that it is blocked
         /// by (regardless of whether they are currently available to do so).
         /// </summary>
         private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request)
@@ -2013,7 +2013,7 @@ private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request)
         /// assigns a new request id.
         /// </summary>
         /// <remarks>
-        /// UNDONE: (Performance) This algorithm should be modified so we don't have to iterate over all of the 
+        /// UNDONE: (Performance) This algorithm should be modified so we don't have to iterate over all of the
         /// requests to find a matching one.  A HashSet with proper equality semantics and a good hash code for the BuildRequest
         /// would speed this considerably, especially for large numbers of projects in a build.
         /// </remarks>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index c3a86600cde..1f9eb065df4 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -47,6 +47,7 @@ internal virtual IList<SdkResolver> LoadResolvers(LoggingContext loggingContext,
         ///     Root\SdkResolver\(ResolverName)\(ResolverName).dll.
         /// </summary>
         /// <param name="rootFolder"></param>
+        /// <param name="location"></param>
         /// <returns></returns>
         internal virtual IList<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location)
         {
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 1738a0518e8..4d170a3853c 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -161,7 +161,7 @@ public OutOfProcNode()
             ((IBuildComponentHost) this).RegisterFactory(BuildComponentType.SdkResolverService, sdkResolverServiceFactory.CreateInstance);
 
             _sdkResolverService = (this as IBuildComponentHost).GetComponent(BuildComponentType.SdkResolverService) as ISdkResolverService;
-            
+
             if (s_projectRootElementCacheBase == null)
             {
                 s_projectRootElementCacheBase = new ProjectRootElementCache(true /* automatically reload any changes from disk */);
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index d9879b580da..e5d4460efd7 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -263,7 +263,7 @@ internal BuildRequestConfiguration()
 
         /// <summary>
         /// When reset caches is false we need to only keep around the configurations which are being asked for during the design time build.
-        /// Other configurations need to be cleared. If this configuration is marked as ExplicitlyLoadedConfiguration then it should not be cleared when 
+        /// Other configurations need to be cleared. If this configuration is marked as ExplicitlyLoadedConfiguration then it should not be cleared when
         /// Reset Caches is false.
         /// </summary>
         public bool ExplicitlyLoaded { get; set; }
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 465f2b21122..ec0d6b998c9 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -502,7 +502,7 @@ public void MergeResults(BuildResult results)
             }
 
             // If there is an exception and we did not previously have one, add it in.
-            _requestException = _requestException ?? results.Exception;
+            _requestException ??= results.Exception;
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 81183622bb9..27ad473350a 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -257,12 +257,12 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
 
             if (_taskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute())
             {
-                requirements = requirements | TaskRequirements.RequireSTAThread;
+                requirements |= TaskRequirements.RequireSTAThread;
             }
 
             if (_taskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute())
             {
-                requirements = requirements | TaskRequirements.RequireSeparateAppDomain;
+                requirements |= TaskRequirements.RequireSeparateAppDomain;
 
                 // we're going to be remoting across the appdomain boundary, so
                 // create the list that we'll use to disconnect the taskitems once we're done
@@ -1480,7 +1480,7 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
                         // if individual items in the array are null, ignore them
                         if (output != null)
                         {
-                            joinedOutputs = joinedOutputs ?? new StringBuilder();
+                            joinedOutputs ??= new StringBuilder();
 
                             if (joinedOutputs.Length > 0)
                             {
@@ -1556,7 +1556,7 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
                         // if individual outputs in the array are null, ignore them
                         if (output != null)
                         {
-                            joinedOutputs = joinedOutputs ?? new StringBuilder();
+                            joinedOutputs ??= new StringBuilder();
 
                             if (joinedOutputs.Length > 0)
                             {
diff --git a/src/Build/Collections/LookasideStringInterner.cs b/src/Build/Collections/LookasideStringInterner.cs
index a71f382b43f..6d99af25cf4 100644
--- a/src/Build/Collections/LookasideStringInterner.cs
+++ b/src/Build/Collections/LookasideStringInterner.cs
@@ -11,9 +11,9 @@ namespace Microsoft.Build.Collections
     /// A simple string interner designed for IPC.
     /// </summary>
     /// <remarks>
-    /// This interner works by providing a way to convert strings to integer IDs.  When used as a form of compression, 
+    /// This interner works by providing a way to convert strings to integer IDs.  When used as a form of compression,
     /// clients will intern their strings and record the set of IDs returned, then transmit those IDs instead of the
-    /// original strings.  The interner itself is also transmitted ahead of time, with the IDs, allowing 
+    /// original strings.  The interner itself is also transmitted ahead of time, with the IDs, allowing
     /// reconstruction of the original strings.  This ensures each string is transmitted exactly once.
     /// </remarks>
     internal class LookasideStringInterner : ITranslatable
@@ -52,7 +52,7 @@ public LookasideStringInterner(StringComparer comparer, int defaultCollectionSiz
         /// Constructor to be used during deserialization.
         /// </summary>
         /// <remarks>
-        /// Intern cannot be used on this interner if it came from serialization, since we do 
+        /// Intern cannot be used on this interner if it came from serialization, since we do
         /// not reconstruct the interning dictionary.
         /// </remarks>
         public LookasideStringInterner(ITranslator translator)
diff --git a/src/Build/Collections/WeakValueDictionary.cs b/src/Build/Collections/WeakValueDictionary.cs
index 7051dcef8bd..6193363093d 100644
--- a/src/Build/Collections/WeakValueDictionary.cs
+++ b/src/Build/Collections/WeakValueDictionary.cs
@@ -206,7 +206,7 @@ public int Scavenge()
 
                 if (!entry.Value.TryGetTarget(out _))
                 {
-                    remove = remove ?? new List<K>();
+                    remove ??= new List<K>();
                     remove.Add(entry.Key);
                 }
             }
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 8c91b70d256..b55ba655ff4 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -481,7 +481,7 @@ internal void AddToXml(ProjectElement child)
                 // Therefore, we need to traverse both directions to find the first sibling of the same type as the one being added.
                 // If none is found, then the node being added is inserted as the only node of its kind
 
-                bool SiblingIsExplicitElement(ProjectElement _) => _.ExpressedAsAttribute == false;
+                bool SiblingIsExplicitElement(ProjectElement _) => !_.ExpressedAsAttribute;
 
                 if (TrySearchLeftSiblings(child.PreviousSibling, SiblingIsExplicitElement, out ProjectElement referenceSibling))
                 {
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index bc67482cf94..4c663e3c513 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -2031,6 +2031,7 @@ bool preserveFormatting
         /// </summary>
         /// <param name="fullPath">The full path to the document to load.</param>
         /// <param name="preserveFormatting"><code>true</code> to preserve the formatting of the document, otherwise <code>false</code>.</param>
+        /// <param name="loadAsReadOnly">Whether to load the file in read-only mode.</param>
         private XmlDocumentWithLocation LoadDocument(string fullPath, bool preserveFormatting, bool loadAsReadOnly)
         {
             ErrorUtilities.VerifyThrowInternalRooted(fullPath);
diff --git a/src/Build/Construction/ProjectTargetElement.cs b/src/Build/Construction/ProjectTargetElement.cs
index c1b1f309d1a..8bbebd63f45 100644
--- a/src/Build/Construction/ProjectTargetElement.cs
+++ b/src/Build/Construction/ProjectTargetElement.cs
@@ -114,7 +114,7 @@ public string Name
         }
 
         /// <summary>
-        /// Gets or sets the Inputs value. 
+        /// Gets or sets the Inputs value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -134,7 +134,7 @@ public string Inputs
         }
 
         /// <summary>
-        /// Gets or sets the Outputs value. 
+        /// Gets or sets the Outputs value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -154,7 +154,7 @@ public string Outputs
         }
 
         /// <summary>
-        /// Gets or sets the TrimDuplicateOutputs value. 
+        /// Gets or sets the TrimDuplicateOutputs value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -182,7 +182,7 @@ public string KeepDuplicateOutputs
         }
 
         /// <summary>
-        /// Gets or sets the DependsOnTargets value. 
+        /// Gets or sets the DependsOnTargets value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -202,7 +202,7 @@ public string DependsOnTargets
         }
 
         /// <summary>
-        /// Gets or sets the BeforeTargets value. 
+        /// Gets or sets the BeforeTargets value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -222,7 +222,7 @@ public string BeforeTargets
         }
 
         /// <summary>
-        /// Gets or sets the AfterTargets value. 
+        /// Gets or sets the AfterTargets value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -242,10 +242,10 @@ public string AfterTargets
         }
 
         /// <summary>
-        /// Gets or sets the Returns value. 
-        /// Returns null if the attribute is not present -- empty string is an allowable 
-        /// value for both getting and setting. 
-        /// Removes the attribute only if the value is set to null. 
+        /// Gets or sets the Returns value.
+        /// Returns null if the attribute is not present -- empty string is an allowable
+        /// value for both getting and setting.
+        /// Removes the attribute only if the value is set to null.
         /// </summary>
         public string Returns
         {
diff --git a/src/Build/Construction/ProjectTaskElement.cs b/src/Build/Construction/ProjectTaskElement.cs
index f09324cbbc0..91b64d434dc 100644
--- a/src/Build/Construction/ProjectTaskElement.cs
+++ b/src/Build/Construction/ProjectTaskElement.cs
@@ -60,7 +60,7 @@ private ProjectTaskElement(XmlElementWithLocation xmlElement, ProjectRootElement
         }
 
         /// <summary>
-        /// Gets or sets the continue on error value. 
+        /// Gets or sets the continue on error value.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -80,7 +80,7 @@ public string ContinueOnError
         }
 
         /// <summary>
-        /// Gets or sets the runtime value for the task. 
+        /// Gets or sets the runtime value for the task.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -100,7 +100,7 @@ public string MSBuildRuntime
         }
 
         /// <summary>
-        /// Gets or sets the architecture value for the task. 
+        /// Gets or sets the architecture value for the task.
         /// Returns empty string if it is not present.
         /// Removes the attribute if the value to set is empty.
         /// </summary>
@@ -226,8 +226,8 @@ public IEnumerable<KeyValuePair<string, ElementLocation>> ParameterLocations
         }
 
         /// <summary>
-        /// Convenience method to add an Output Item to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add an Output Item to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputItem(string taskParameter, string itemType)
         {
@@ -238,8 +238,8 @@ public ProjectOutputElement AddOutputItem(string taskParameter, string itemType)
         }
 
         /// <summary>
-        /// Convenience method to add a conditioned Output Item to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add a conditioned Output Item to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputItem(string taskParameter, string itemType, string condition)
         {
@@ -256,8 +256,8 @@ public ProjectOutputElement AddOutputItem(string taskParameter, string itemType,
         }
 
         /// <summary>
-        /// Convenience method to add an Output Property to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add an Output Property to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName)
         {
@@ -268,8 +268,8 @@ public ProjectOutputElement AddOutputProperty(string taskParameter, string prope
         }
 
         /// <summary>
-        /// Convenience method to add a conditioned Output Property to this task. 
-        /// Adds after the last child. 
+        /// Convenience method to add a conditioned Output Property to this task.
+        /// Adds after the last child.
         /// </summary>
         public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName, string condition)
         {
@@ -377,7 +377,7 @@ public void RemoveAllParameters()
                 {
                     if (!XMakeAttributes.IsSpecialTaskAttribute(attribute.Name))
                     {
-                        toRemove = toRemove ?? new List<XmlAttribute>();
+                        toRemove ??= new List<XmlAttribute>();
                         toRemove.Add(attribute);
                     }
                 }
diff --git a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
index 0fd18ad17f7..0700c134ddb 100644
--- a/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectConfigurationInSolution.cs
@@ -51,7 +51,7 @@ internal ProjectConfigurationInSolution(string configurationName, string platfor
         /// </summary>
         private static string RemoveSpaceFromAnyCpuPlatform(string platformName)
         {
-            if (string.Compare(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase))
             {
                 return "AnyCPU";
             }
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index a9b1c636710..9bd2f1723a1 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -287,9 +287,9 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
                     // MSBuild supports project files with an empty (supported in Visual Studio 2017) or the default MSBuild
                     // namespace.
                     bool emptyNamespace = string.IsNullOrEmpty(mainProjectElement.NamespaceURI);
-                    bool defaultNamespace = String.Compare(mainProjectElement.NamespaceURI,
+                    bool defaultNamespace = String.Equals(mainProjectElement.NamespaceURI,
                                                 XMakeAttributes.defaultXmlNamespace,
-                                                StringComparison.OrdinalIgnoreCase) == 0;
+                                                StringComparison.OrdinalIgnoreCase);
                     bool projectElementInvalid = ElementContainsInvalidNamespaceDefitions(mainProjectElement);
 
                     // If the MSBuild namespace is declared, it is very likely an MSBuild project that should be built.
@@ -434,7 +434,7 @@ internal static string DisambiguateProjectTargetName(string uniqueProjectName)
             // entry point targets
             foreach (string projectName in projectNamesToDisambiguate)
             {
-                if (String.Compare(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase))
                 {
                     // Prepend "Solution:" so that the collision is resolved, but the
                     // log of the solution project still looks reasonable.
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index af7e336438e..ba79cd99cc5 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -1130,7 +1130,7 @@ string propertyValue
             else
             {
                 // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
-                if (string.Compare(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
                     string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
 
@@ -1158,7 +1158,7 @@ string propertyValue
                         }
                     }
                 }
-                else if (String.Compare(propertyName, "TargetFrameworkMoniker", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(propertyName, "TargetFrameworkMoniker", StringComparison.OrdinalIgnoreCase))
                 {
                     //Website project need to back support 3.5 msbuild parser for the Blend (it is not move to .Net4.0 yet.)
                     //However, 3.5 version of Solution parser can't handle a equal sign in the value.  
@@ -1222,29 +1222,29 @@ ProjectInSolution proj
             ValidateProjectRelativePath(proj);
 
             // Figure out what type of project this is.
-            if ((String.Compare(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsCsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsVbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, cpsFsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, fsProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, dbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase) == 0))
+            if ((String.Equals(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsCsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsVbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, cpsFsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, fsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, dbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)))
             {
                 proj.ProjectType = SolutionProjectType.KnownToBeMSBuildFormat;
             }
-            else if (String.Compare(projectTypeGuid, sharedProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, sharedProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.SharedProject;
             }
-            else if (String.Compare(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.SolutionFolder;
             }
             // MSBuild format VC projects have the same project type guid as old style VC projects.
             // If it's not an old-style VC project, we'll assume it's MSBuild format
-            else if (String.Compare(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 if (String.Equals(proj.Extension, ".vcproj", StringComparison.OrdinalIgnoreCase))
                 {
@@ -1260,12 +1260,12 @@ ProjectInSolution proj
                     proj.ProjectType = SolutionProjectType.KnownToBeMSBuildFormat;
                 }
             }
-            else if (String.Compare(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.WebProject;
                 ContainsWebProjects = true;
             }
-            else if (String.Compare(projectTypeGuid, wdProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, wdProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.WebDeploymentProject;
                 ContainsWebDeploymentProjects = true;
@@ -1351,7 +1351,7 @@ internal void ParseSolutionConfigurations()
                 string fullConfigurationName = configurationNames[0].Trim();
 
                 //Fixing bug 555577: Solution file can have description information, in which case we ignore.
-                if (0 == String.Compare(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
                 {
                     continue;
                 }
@@ -1492,7 +1492,7 @@ public string GetDefaultConfigurationName()
             // Pick the Debug configuration as default if present
             foreach (SolutionConfigurationInSolution solutionConfiguration in SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     _defaultConfigurationName = solutionConfiguration.ConfigurationName;
                     break;
@@ -1525,13 +1525,13 @@ public string GetDefaultPlatformName()
             // Pick the Mixed Platforms platform as default if present
             foreach (SolutionConfigurationInSolution solutionConfiguration in SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase))
                 {
                     _defaultPlatformName = solutionConfiguration.PlatformName;
                     break;
                 }
                 // We would like this to be chosen if Mixed platforms does not exist.
-                else if (string.Compare(solutionConfiguration.PlatformName, "Any CPU", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (string.Equals(solutionConfiguration.PlatformName, "Any CPU", StringComparison.OrdinalIgnoreCase))
                 {
                     _defaultPlatformName = solutionConfiguration.PlatformName;
                 }
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 3070e99ee29..b648a919617 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -101,7 +101,7 @@ internal class SolutionProjectGenerator
         private readonly SolutionFile _solutionFile;
 
         /// <summary>
-        /// The global properties passed under which the project should be opened. 
+        /// The global properties passed under which the project should be opened.
         /// </summary>
         private readonly IDictionary<string, string> _globalProperties;
 
@@ -111,7 +111,7 @@ internal class SolutionProjectGenerator
         private readonly string _toolsVersionOverride;
 
         /// <summary>
-        /// The context of this build (used for logging purposes). 
+        /// The context of this build (used for logging purposes).
         /// </summary>
         private readonly BuildEventContext _projectBuildEventContext;
 
@@ -168,7 +168,7 @@ private SolutionProjectGenerator(
         }
 
         /// <summary>
-        /// This method generates an MSBuild project file from the list of projects and project dependencies 
+        /// This method generates an MSBuild project file from the list of projects and project dependencies
         /// that have been collected from the solution file.
         /// </summary>
         /// <param name="solution">The parser which contains the solution file.</param>
@@ -321,7 +321,7 @@ params object[] args
         /// <summary>
         /// Normally the active solution configuration/platform is determined when we build the solution
         /// wrapper project, not when we create it. However, we need to know them to scan project references
-        /// for the right project configuration/platform. It's unlikely that references would be conditional, 
+        /// for the right project configuration/platform. It's unlikely that references would be conditional,
         /// but still possible and we want to get that case right.
         /// </summary>
         internal static string PredictActiveSolutionConfigurationName(SolutionFile solutionFile, IDictionary<string, string> globalProperties)
@@ -376,7 +376,7 @@ private static string DetermineWrapperProjectToolsVersion(string toolsVersionOve
 
 #if FEATURE_ASPNET_COMPILER
         /// <summary>
-        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced 
+        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced
         /// assemblies for the complete list of dependencies, PDBs, satellites, etc.  The invoke
         /// the Copy task to copy all these files (or at least the ones that RAR determined should
         /// be copied local) into the web project's bin directory.
@@ -439,10 +439,10 @@ string conditionDescribingValidConfigurations
         }
 
         /// <summary>
-        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of 
-        /// a web project.  These .REFRESH files are just text files that contain absolute or 
-        /// relative paths to the referenced assemblies.  The goal of these tasks is to 
-        /// search all *.REFRESH files and extract fully-qualified absolute paths for 
+        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of
+        /// a web project.  These .REFRESH files are just text files that contain absolute or
+        /// relative paths to the referenced assemblies.  The goal of these tasks is to
+        /// search all *.REFRESH files and extract fully-qualified absolute paths for
         /// each of the references.
         /// </summary>
         private static void AddTasksToResolveAutoRefreshFileReferences
@@ -1140,35 +1140,35 @@ private bool CanBuildDirectly(ProjectInstance traversalProject, ProjectInSolutio
         }
 
         /// <summary>
-        /// Produces a set of targets which allows the MSBuild scheduler to schedule projects in the order automatically by 
+        /// Produces a set of targets which allows the MSBuild scheduler to schedule projects in the order automatically by
         /// following their dependencies without enforcing build levels.
         /// </summary>
         /// <remarks>
         /// We want MSBuild to be able to parallelize the builds of these projects where possible and still honor references.
         /// Since the project files referenced by the solution do not (necessarily) themselves contain actual project references
         /// to the projects they depend on, we need to synthesize this relationship ourselves.  This is done by creating a target
-        /// which first invokes the project's dependencies, then invokes the actual project itself.  However, invoking the 
-        /// dependencies must also invoke their dependencies and so on down the line.  
-        /// 
+        /// which first invokes the project's dependencies, then invokes the actual project itself.  However, invoking the
+        /// dependencies must also invoke their dependencies and so on down the line.
+        ///
         /// Additionally, we do not wish to create a separate MSBuild project to contain this target yet we want to parallelize
         /// calls to these targets.  The way to do this is to pass in different global properties to the same project in the same
         /// MSBuild call.  MSBuild easily allows this using the AdditionalProperties metadata which can be specified on an Item.
-        /// 
+        ///
         /// Assuming the solution project we are generating is called "foo.proj", we can accomplish this parallelism as follows:
         /// <ItemGroup>
         ///     <ProjectReference Include="Project0"/>
         ///     <ProjectReference Include="Project1"/>
         ///     <ProjectReference Include="Project2"/>
         /// </ItemGroup>
-        /// 
+        ///
         /// We now have expressed the top level reference to all projects as @(SolutionReference) and each project's
         /// set of references as @(PROJECTNAMEReference).  We construct our target as:
-        /// 
+        ///
         /// <Target Name="Build">
         ///     <MSBuild Projects="@(ProjectReference)" Targets="Build" />
         ///     <MSBuild Projects="actualProjectName" Targets="Build" />
         /// </Target>
-        /// 
+        ///
         /// The first MSBuild call re-invokes the solution project instructing it to build the reference projects for the
         /// current project.  The second MSBuild call invokes the actual project itself.  Because all reference projects have
         /// the same additional properties, MSBuild will only build the first one it comes across and the rest will be
@@ -1739,7 +1739,7 @@ string solutionFile
 
         /// <summary>
         /// When adding a target to build a web project, we want to put a Condition on the Target node that
-        /// effectively says "Only build this target if the web project is active (marked for building) in the 
+        /// effectively says "Only build this target if the web project is active (marked for building) in the
         /// current solution configuration.
         /// </summary>
         private string ComputeTargetConditionForWebProject(ProjectInSolution project)
@@ -1763,8 +1763,8 @@ private string ComputeTargetConditionForWebProject(ProjectInSolution project)
                         condition.Append(")");
                     }
                 }
-                else if (String.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0 ||
-                         String.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) ||
+                         String.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     // we don't have a project configuration that matches the solution configuration but
                     // the solution configuration is called "Release" or "Debug" which are standard AspNetConfigurations
@@ -2104,7 +2104,7 @@ private string DetermineChildProjectToolsVersion(string wrapperProjectToolsVersi
         /// <summary>
         /// Normally the active solution configuration/platform is determined when we build the solution
         /// wrapper project, not when we create it. However, we need to know them to scan project references
-        /// for the right project configuration/platform. It's unlikely that references would be conditional, 
+        /// for the right project configuration/platform. It's unlikely that references would be conditional,
         /// but still possible and we want to get that case right.
         /// </summary>
         private string PredictActiveSolutionConfigurationName()
@@ -2114,7 +2114,7 @@ private string PredictActiveSolutionConfigurationName()
 
         /// <summary>
         /// Loads each MSBuild project in this solution and looks for its project-to-project references so that
-        /// we know what build order we should use when building the solution. 
+        /// we know what build order we should use when building the solution.
         /// </summary>
         private void ScanProjectDependencies(string childProjectToolsVersion, string fullSolutionConfigurationName)
         {
@@ -2254,12 +2254,12 @@ private void AddPropertyGroupForSolutionConfiguration(ProjectRootElement travers
         /// <summary>
         /// Creates the default Venus configuration property based on the selected solution configuration.
         /// Unfortunately, Venus projects only expose one project configuration in the IDE (Debug) although
-        /// they allow building Debug and Release from command line. This means that if we wanted to use 
+        /// they allow building Debug and Release from command line. This means that if we wanted to use
         /// the project configuration from the active solution configuration for Venus projects, we'd always
         /// end up with Debug and there'd be no way to build the Release configuration. To work around this,
         /// we use a special mechanism for choosing ASP.NET project configuration: we set it to Release if
-        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution 
-        /// configuration. The property is also settable from the command line, in which case it takes 
+        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution
+        /// configuration. The property is also settable from the command line, in which case it takes
         /// precedence over this algorithm.
         /// </summary>
         private static void AddVenusConfigurationDefaults(ProjectRootElement traversalProject)
@@ -2311,7 +2311,7 @@ private void AddGlobalProperties(ProjectRootElement traversalProject)
 
         /// <summary>
         /// Special hack for web projects. It can happen that there is no Release configuration for solutions
-        /// containing web projects, yet we still want to be able to build the Release configuration for 
+        /// containing web projects, yet we still want to be able to build the Release configuration for
         /// those projects. Since the ASP.NET project configuration defaults to the solution configuration,
         /// we allow Release even if it doesn't actually exist in the solution.
         /// </summary>
@@ -2322,7 +2322,7 @@ private void AddFakeReleaseSolutionConfigurationIfNecessary()
                 bool solutionHasReleaseConfiguration = false;
                 foreach (SolutionConfigurationInSolution solutionConfiguration in _solutionFile.SolutionConfigurations)
                 {
-                    if (string.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase))
                     {
                         solutionHasReleaseConfiguration = true;
                         break;
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index a5b6532d975..a0c4d6aa161 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -90,9 +90,9 @@ public class Project : ILinkableObject
         /// - <see cref="ProjectItem.RemoveMetadata"/>
         /// - <see cref="ProjectItem.SetMetadataValue(string,string)"/>
         /// - <see cref="ProjectItem.SetMetadataValue(string,string, bool)"/>
-        /// 
+        ///
         /// When this property is set to true, the previous item operations throw an <exception cref="InvalidOperationException"></exception>
-        /// instead of expanding the item element. 
+        /// instead of expanding the item element.
         /// </summary>
         public bool ThrowInsteadOfSplittingItemElement
         {
@@ -390,7 +390,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         }
 
         /// <summary>
-        /// Construct over an existing project file, evaluating with the specified global properties and 
+        /// Construct over an existing project file, evaluating with the specified global properties and
         /// using the tools version provided, either or both of which may be null.
         /// Project is added to the global project collection.
         /// Throws InvalidProjectFileException if the evaluation fails.
@@ -407,7 +407,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         }
 
         /// <summary>
-        /// Construct over an existing project file, evaluating with the specified global properties and 
+        /// Construct over an existing project file, evaluating with the specified global properties and
         /// using the tools version provided, either or both of which may be null.
         /// Project is added to the global project collection.
         /// Throws InvalidProjectFileException if the evaluation fails.
@@ -425,7 +425,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         }
 
         /// <summary>
-        /// Construct over an existing project file, evaluating with the specified global properties and 
+        /// Construct over an existing project file, evaluating with the specified global properties and
         /// using the tools version provided, either or both of which may be null.
         /// Project is added to the global project collection.
         /// Throws InvalidProjectFileException if the evaluation fails.
@@ -572,7 +572,7 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Whether this project is dirty such that it needs reevaluation.
         /// This may be because its underlying XML has changed (either through this project or another)
-        /// either the XML of the main project or an imported file; 
+        /// either the XML of the main project or an imported file;
         /// or because its toolset may have changed.
         /// </summary>
         public bool IsDirty => implementation.IsDirty;
@@ -583,8 +583,8 @@ private enum BuildEnabledSetting
         /// </summary>
         /// <remarks>
         /// This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
-        /// 
-        /// In order to easily tell when we're dirtied, setting and removing global properties is done with 
+        ///
+        /// In order to easily tell when we're dirtied, setting and removing global properties is done with
         /// <see cref="SetGlobalProperty">SetGlobalProperty</see> and <see cref="RemoveGlobalProperty">RemoveGlobalProperty</see>.
         /// </remarks>
         public IDictionary<string, string> GlobalProperties => implementation.GlobalProperties;
@@ -594,7 +594,7 @@ private enum BuildEnabledSetting
         /// This is an ordered collection.
         /// </summary>
         /// <comments>
-        /// data.ItemTypes is a KeyCollection, so it doesn't need any 
+        /// data.ItemTypes is a KeyCollection, so it doesn't need any
         /// additional read-only protection
         /// </comments>
         public ICollection<string> ItemTypes => implementation.ItemTypes;
@@ -608,17 +608,17 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Collection of possible values implied for properties contained in the conditions found on properties,
         /// property groups, imports, and whens.
-        /// 
+        ///
         /// For example, if the following conditions existed on properties in a project:
-        /// 
+        ///
         /// Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
         /// Condition="'$(Configuration)' == 'Release'"
-        /// 
+        ///
         /// the table would be populated with
-        /// 
+        ///
         /// { "Configuration", { "Debug", "Release" }}
         /// { "Platform", { "x86" }}
-        /// 
+        ///
         /// This is used by Visual Studio to determine the configurations defined in the project.
         /// </summary>
         public IDictionary<string, List<string>> ConditionedProperties => implementation.ConditionedProperties;
@@ -639,7 +639,7 @@ private enum BuildEnabledSetting
         /// Items in this project, ordered within groups of item types,
         /// including items whose conditions evaluated to false, or that were
         /// contained within item groups who themselves had conditioned evaluated to false.
-        /// This is useful for hosts that wish to display all items, even if they might not be part 
+        /// This is useful for hosts that wish to display all items, even if they might not be part
         /// of the build in the current configuration.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
@@ -672,7 +672,7 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Properties encountered during evaluation. These are read during the first evaluation pass.
         /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-        /// were subsequently overridden by others with the same name. It does not include any 
+        /// were subsequently overridden by others with the same name. It does not include any
         /// properties whose conditions did not evaluate to true.
         /// It does not include any properties added since the last evaluation.
         /// </summary>
@@ -681,7 +681,7 @@ private enum BuildEnabledSetting
         /// <summary>
         /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
         /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-        /// were subsequently overridden by others with the same name and item type. It does not include any 
+        /// were subsequently overridden by others with the same name and item type. It does not include any
         /// elements whose conditions did not evaluate to true.
         /// It does not include any item definition metadata added since the last evaluation.
         /// </summary>
@@ -689,7 +689,7 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// Items encountered during evaluation. These are read during the third evaluation pass.
-        /// Unlike those returned by the Items property, these are ordered with respect to all other items 
+        /// Unlike those returned by the Items property, these are ordered with respect to all other items
         /// encountered during evaluation, not just ordered with respect to items of the same item type.
         /// In some applications, like the F# language, this complete mutual ordering is significant, and such hosts
         /// can use this property.
@@ -712,7 +712,7 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// The sub-toolset version that, combined with the ToolsVersion, was used to determine
-        /// the toolset properties for this project.  
+        /// the toolset properties for this project.
         /// </summary>
         public string SubToolsetVersion => implementation.SubToolsetVersion;
 
@@ -737,7 +737,7 @@ public string FullPath
 
         /// <summary>
         /// Whether ReevaluateIfNecessary is temporarily disabled.
-        /// This is useful when the host expects to make a number of reads and writes 
+        /// This is useful when the host expects to make a number of reads and writes
         /// to the project, and wants to temporarily sacrifice correctness for performance.
         /// </summary>
         public bool SkipEvaluation
@@ -767,10 +767,10 @@ public bool DisableMarkDirty
         /// control which projects it allows to run targets/tasks.  By default, for a newly
         /// created project, we will use whatever setting is in the parent project collection.
         /// When build is disabled, the Build method on this class will fail. However if
-        /// the host has already created a ProjectInstance, it can still build it. (It is 
+        /// the host has already created a ProjectInstance, it can still build it. (It is
         /// free to put a similar check around where it does this.)
         /// </summary>
-        public bool IsBuildEnabled 
+        public bool IsBuildEnabled
         {
             [DebuggerStepThrough]
             get => implementation.IsBuildEnabled;
@@ -794,19 +794,19 @@ public bool IsBuildEnabled
         /// The ID of the last evaluation for this Project.
         /// A project is always evaluated upon construction and can subsequently get evaluated multiple times via
         /// <see cref="Project.ReevaluateIfNecessary()" />
-        /// 
+        ///
         /// It is an arbitrary number that changes when this project reevaluates.
         /// Hosts don't know whether an evaluation actually happened in an interval, but they can compare this number to
         /// their previously stored value to find out, and if so perhaps decide to update their own state.
         /// Note that the number may not increase monotonically.
-        /// 
+        ///
         /// This number corresponds to the <seealso cref="BuildEventContext.EvaluationId"/> and can be used to connect
         /// evaluation logging events back to the Project instance.
         /// </summary>
         public int LastEvaluationId => implementation.LastEvaluationId;
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable 
+        /// List of names of the properties that, while global, are still treated as overridable
         /// </summary>
         internal ISet<string> GlobalPropertiesToTreatAsLocal => implementationInternal.GlobalPropertiesToTreatAsLocal;
 
@@ -840,21 +840,21 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item)
         /// Finds all the globs specified in item includes.
         /// </summary>
         /// <example>
-        /// 
+        ///
         /// <code>
         ///<P>*.txt</P>
-        /// 
+        ///
         ///<Bar Include="bar"/> (both outside and inside project cone)
         ///<Zar Include="C:\**\*.foo"/> (both outside and inside project cone)
         ///<Foo Include="*.a;*.b" Exclude="3.a"/>
         ///<Foo Remove="2.a" />
         ///<Foo Include="**\*.b" Exclude="1.b;**\obj\*.b;**\bar\*.b"/>
-        ///<Foo Include="$(P)"/> 
+        ///<Foo Include="$(P)"/>
         ///<Foo Include="*.a;@(Bar);3.a"/> (If Bar has globs, they will have been included when querying Bar ProjectItems for globs)
         ///<Foo Include="*.cs" Exclude="@(Bar)"/>
         ///</code>
-        /// 
-        ///Example result: 
+        ///
+        ///Example result:
         ///[
         ///GlobResult(glob: "C:\**\*.foo", exclude: []),
         ///GlobResult(glob: ["*.a", "*.b"], exclude=["3.a"], remove=["2.a"]),
@@ -867,13 +867,13 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item)
         /// <remarks>
         /// <see cref="GlobResult.MsBuildGlob"/> is a <see cref="IMSBuildGlob"/> that combines all globs in the include element and ignores
         /// all the fragments in the exclude attribute and all the fragments in all Remove elements that apply to the include element.
-        /// 
+        ///
         /// Users can construct a composite glob that incorporates all the globs in the Project:
         /// <code>
         /// var uberGlob = new CompositeGlob(project.GetAllGlobs().Select(r => r.MSBuildGlob).ToArray());
         /// uberGlob.IsMatch("foo.cs");
         /// </code>
-        /// 
+        ///
         /// </remarks>
         /// <returns>
         /// List of <see cref="GlobResult"/>.
@@ -907,6 +907,7 @@ public List<GlobResult> GetAllGlobs(string itemType)
         /// <summary>
         /// See <see cref="GetAllGlobs(string)"/>
         /// </summary>
+        /// <param name="itemType">type of the item</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -922,7 +923,7 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         /// - elements that would update the string (not yet implemented)
         /// - elements that would remove the string (not yet implemented)
         /// </summary>
-        /// 
+        ///
         /// <example>
         /// The following snippet shows what <c>GetItemProvenance("a.cs")</c> returns for various item elements
         /// <code>
@@ -935,28 +936,28 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         ///     <P>a.cs;*.cs;@(A)</P>
         /// </PropertyGroup>
         /// </code>
-        /// 
+        ///
         /// </example>
-        /// 
+        ///
         /// <remarks>
         /// This method and its overloads are useful for clients that need to inspect all the item elements
         /// that might refer to a specific item instance. For example, Visual Studio uses it to inspect
         /// projects with globs. Upon a file system or IDE file artifact change, VS calls this method to find all the items
         /// that might refer to the detected file change (e.g. 'which item elements refer to "Program.cs"?').
         /// It uses such information to know which elements it should edit to reflect the user or file system changes.
-        /// 
+        ///
         /// Literal string matching tries to first match the strings. If the check fails, it then tries to match
         /// the strings as if they represented files: it normalizes both strings as files relative to the current project directory
         ///
         /// GetItemProvenance suffers from some sources of inaccuracy:
         /// - it is performed after evaluation, thus is insensitive to item data flow when item references are present
         /// (it sees items as they are at the end of evaluation)
-        /// 
+        ///
         /// This API and its return types are prone to change.
         /// </remarks>
-        /// 
+        ///
         /// <param name="itemToMatch">The string to perform matching against</param>
-        /// 
+        ///
         /// <returns>
         /// A list of <see cref="ProvenanceResult"/>, sorted in project evaluation order.
         /// </returns>
@@ -968,6 +969,7 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch)
         /// <summary>
         /// See <see cref="GetItemProvenance(string)"/>
         /// </summary>
+        /// <param name="itemToMatch">The string to perform matching against</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -990,6 +992,8 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemT
         /// <summary>
         /// See <see cref="GetItemProvenance(string, string)"/>
         /// </summary>
+        /// <param name="itemToMatch">The string to perform matching against</param>
+        /// <param name="itemType">The type of the item to perform matching against</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -1002,7 +1006,7 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemT
         /// <summary>
         /// Overload of <see cref="GetItemProvenance(string)"/>
         /// </summary>
-        /// <param name="item"> 
+        /// <param name="item">
         /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
         /// The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
         /// The element that produced this <paramref name="item"/> is included in the results.
@@ -1015,6 +1019,11 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item)
         /// <summary>
         /// See <see cref="GetItemProvenance(ProjectItem)"/>
         /// </summary>
+        /// <param name="item">
+        /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
+        /// The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
+        /// The element that produced this <paramref name="item"/> is included in the results.
+        /// </param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
         ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -1025,7 +1034,7 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationCont
         }
 
         /// <summary>
-        /// Gets the escaped value of the provided metadatum. 
+        /// Gets the escaped value of the provided metadatum.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectMetadata metadatum)
         {
@@ -1035,7 +1044,7 @@ public static string GetMetadataValueEscaped(ProjectMetadata metadatum)
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item.
         /// </summary>
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IItem is an internal interface; this is less confusing to outside customers. ")]
         public static string GetMetadataValueEscaped(ProjectItem item, string name)
@@ -1046,7 +1055,7 @@ public static string GetMetadataValueEscaped(ProjectItem item, string name)
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item definition. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item definition.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectItemDefinition item, string name)
         {
@@ -1068,7 +1077,7 @@ public static string GetPropertyValueEscaped(ProjectProperty property)
 
         /// <summary>
         /// Returns an iterator over the "logical project". The logical project is defined as
-        /// the unevaluated project obtained from the single MSBuild file that is the result 
+        /// the unevaluated project obtained from the single MSBuild file that is the result
         /// of inlining the text of all imports of the original MSBuild project manifest file.
         /// </summary>
         public IEnumerable<ProjectElement> GetLogicalProject()
@@ -1087,7 +1096,7 @@ public ProjectProperty GetProperty(string name)
         }
 
         /// <summary>
-        /// Get the unescaped value of a property in this project, or 
+        /// Get the unescaped value of a property in this project, or
         /// an empty string if it does not exist.
         /// </summary>
         /// <remarks>
@@ -1196,7 +1205,7 @@ public IList<ProjectItem> AddItemFast(string itemType, string unevaluatedInclude
         /// Use AddItem or RemoveItem to modify items in this project.
         /// </summary>
         /// <comments>
-        /// data.GetItems returns a read-only collection, so no need to re-wrap it here. 
+        /// data.GetItems returns a read-only collection, so no need to re-wrap it here.
         /// </comments>
         public ICollection<ProjectItem> GetItems(string itemType)
         {
@@ -1209,7 +1218,7 @@ public ICollection<ProjectItem> GetItems(string itemType)
         /// This is a read-only list: use AddItem or RemoveItem to modify items in this project.
         /// </summary>
         /// <comments>
-        /// ItemDictionary[] returns a read only collection, so no need to wrap it. 
+        /// ItemDictionary[] returns a read only collection, so no need to wrap it.
         /// </comments>
         public ICollection<ProjectItem> GetItemsIgnoringCondition(string itemType)
         {
@@ -1309,6 +1318,7 @@ public string ExpandString(string unexpandedValue)
         /// This instance can be used to build independently.
         /// Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
         /// </summary>
+        /// <returns>the created project instance</returns>
         public ProjectInstance CreateProjectInstance()
         {
             return CreateProjectInstance(ProjectInstanceSettings.None, null);
@@ -1318,9 +1328,11 @@ public ProjectInstance CreateProjectInstance()
         /// Returns an instance based on this project, but completely disconnected.
         /// This instance can be used to build independently.
         /// Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
-        /// The instance is immutable; none of the objects that form it can be modified. This makes it safe to 
+        /// The instance is immutable; none of the objects that form it can be modified. This makes it safe to
         /// access concurrently from multiple threads.
         /// </summary>
+        /// <param name="settings">The project instance creation settings</param>
+        /// <returns>the created project instance</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         {
             return CreateProjectInstance(settings, null);
@@ -1329,8 +1341,9 @@ public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         /// <summary>
         /// See <see cref="CreateProjectInstance(ProjectInstanceSettings)"/>
         /// </summary>
+        /// <param name="settings">The project instance creation settings</param>
         /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
-        /// <returns></returns>
+        /// <returns>the created project instance</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
         {
             return implementation.CreateProjectInstance(settings, evaluationContext);
@@ -1414,7 +1427,7 @@ public void Save(TextWriter writer)
         }
 
         /// <summary>
-        /// Saves a "logical" or "preprocessed" project file, that includes all the imported 
+        /// Saves a "logical" or "preprocessed" project file, that includes all the imported
         /// files as if they formed a single file.
         /// </summary>
         public void SaveLogicalProject(TextWriter writer)
@@ -1551,6 +1564,9 @@ public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<Fo
         /// <summary>
         /// See <see cref="Build(string[], IEnumerable&lt;ILogger&gt;, IEnumerable&lt;ForwardingLoggerRecord&gt;)"/>
         /// </summary>
+        /// <param name="targets"></param>
+        /// <param name="loggers"></param>
+        /// <param name="remoteLoggers"></param>
         /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
         {
@@ -1576,10 +1592,10 @@ internal bool UsesProjectRootElement(ProjectRootElement xmlRootElement)
         /// A ProjectItemElement could have resulted in several items if it contains wildcards or item or property expressions.
         /// Before any edit to a ProjectItem (remove, rename, set metadata, or remove metadata) this must be called to make
         /// sure that the edit does not affect any other ProjectItems originating in the same ProjectItemElement.
-        /// 
+        ///
         /// For example, an item xml with an include of "@(x)" could evaluate to items "a", "b", and "c". If "b" is removed, then the original
         /// item xml must be removed and replaced with three, then the one corresponding to "b" can be removed.
-        /// 
+        ///
         /// This is an unsophisticated approach; the best that can be said is that the result will likely be correct, if not ideal.
         /// For example, perhaps the user would rather remove the item from the original list "x" instead of expanding the list.
         /// Or, perhaps the user would rather the property in "$(p)\a;$(p)\b" not be expanded when "$(p)\b" is removed.
@@ -1622,7 +1638,7 @@ internal bool ItemElementRequiresSplitting(ProjectItemElement itemElement)
         }
 
         /// <summary>
-        /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the 
+        /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the
         /// item we wish to add, and does not have a condition or an exclude.
         /// Works conservatively - if there is anything that might cause doubt, considers the candidate to not be suitable.
         /// Returns true if it is suitable, otherwise false.
@@ -1637,7 +1653,7 @@ internal bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItem
 
         /// <summary>
         /// Before an item changes its item type, it must be removed from
-        /// our datastructures, which key off item type. 
+        /// our datastructures, which key off item type.
         /// This should be called ONLY by ProjectItems, in this situation.
         /// </summary>
         internal void RemoveItemBeforeItemTypeChange(ProjectItem item)
@@ -1718,7 +1734,7 @@ internal void VerifyThrowInvalidOperationNotZombie()
         /// <summary>
         /// Verify that the provided object location is in the same file as the project.
         /// If it is not, throws an InvalidOperationException indicating that imported evaluated objects should not be modified.
-        /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the 
+        /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the
         /// main project, but for some reason was actually read in from an imported targets file.
         /// </summary>
         internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml)
@@ -1730,7 +1746,6 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
         /// <summary>
         /// Internal project evaluation implementation
         /// </summary>
-        /// <remarks>
         private class ProjectImpl : ProjectLink, IProjectLinkInternal
         {
             /// <summary>
@@ -1782,14 +1797,13 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             private RenameHandlerDelegate _renameHandler;
 
             /// <summary>
-            /// 
+            ///
             /// </summary>
             /// <param name="owner">The owning project object</param>
             /// <param name="xml">ProjectRootElement to use</param>
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
             /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
-            /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
             /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
@@ -1814,7 +1828,6 @@ public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, st
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
             /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
-            /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
@@ -1838,7 +1851,7 @@ public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, strin
             }
 
             /// <summary>
-            /// Construct over an existing project file, evaluating with the specified global properties and 
+            /// Construct over an existing project file, evaluating with the specified global properties and
             /// using the tools version provided, either or both of which may be null.
             /// Project is added to the global project collection.
             /// Throws InvalidProjectFileException if the evaluation fails.
@@ -1850,7 +1863,6 @@ public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, strin
             /// <param name="globalProperties">The global properties. May be null.</param>
             /// <param name="toolsVersion">The tools version. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
-            /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public ProjectImpl(Project owner, string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
@@ -1903,9 +1915,9 @@ public ProjectImpl(Project owner, string projectFile, IDictionary<string, string
             /// - <see cref="ProjectItem.RemoveMetadata"/>
             /// - <see cref="ProjectItem.SetMetadataValue(string,string)"/>
             /// - <see cref="ProjectItem.SetMetadataValue(string,string, bool)"/>
-            /// 
+            ///
             /// When this property is set to true, the previous item operations throw an <exception cref="InvalidOperationException"></exception>
-            /// instead of expanding the item element. 
+            /// instead of expanding the item element.
             /// </summary>
             public override bool ThrowInsteadOfSplittingItemElement { get; set; }
 
@@ -1954,7 +1966,7 @@ public bool IsZombified
             /// <summary>
             /// Whether this project is dirty such that it needs reevaluation.
             /// This may be because its underlying XML has changed (either through this project or another)
-            /// either the XML of the main project or an imported file; 
+            /// either the XML of the main project or an imported file;
             /// or because its toolset may have changed.
             /// </summary>
             public override bool IsDirty
@@ -2022,8 +2034,8 @@ public override bool IsDirty
             /// </summary>
             /// <remarks>
             /// This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
-            /// 
-            /// In order to easily tell when we're dirtied, setting and removing global properties is done with 
+            ///
+            /// In order to easily tell when we're dirtied, setting and removing global properties is done with
             /// <see cref="SetGlobalProperty">SetGlobalProperty</see> and <see cref="RemoveGlobalProperty">RemoveGlobalProperty</see>.
             /// </remarks>
             public override IDictionary<string, string> GlobalProperties
@@ -2051,7 +2063,7 @@ public override IDictionary<string, string> GlobalProperties
             /// This is an ordered collection.
             /// </summary>
             /// <comments>
-            /// data.ItemTypes is a KeyCollection, so it doesn't need any 
+            /// data.ItemTypes is a KeyCollection, so it doesn't need any
             /// additional read-only protection
             /// </comments>
             public override ICollection<string> ItemTypes => _data.ItemTypes;
@@ -2065,17 +2077,17 @@ public override IDictionary<string, string> GlobalProperties
             /// <summary>
             /// Collection of possible values implied for properties contained in the conditions found on properties,
             /// property groups, imports, and whens.
-            /// 
+            ///
             /// For example, if the following conditions existed on properties in a project:
-            /// 
+            ///
             /// Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
             /// Condition="'$(Configuration)' == 'Release'"
-            /// 
+            ///
             /// the table would be populated with
-            /// 
+            ///
             /// { "Configuration", { "Debug", "Release" }}
             /// { "Platform", { "x86" }}
-            /// 
+            ///
             /// This is used by Visual Studio to determine the configurations defined in the project.
             /// </summary>
             public override IDictionary<string, List<string>> ConditionedProperties
@@ -2108,7 +2120,7 @@ public override IDictionary<string, List<string>> ConditionedProperties
             /// Items in this project, ordered within groups of item types,
             /// including items whose conditions evaluated to false, or that were
             /// contained within item groups who themselves had conditioned evaluated to false.
-            /// This is useful for hosts that wish to display all items, even if they might not be part 
+            /// This is useful for hosts that wish to display all items, even if they might not be part
             /// of the build in the current configuration.
             /// </summary>
             [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
@@ -2199,7 +2211,7 @@ public override IDictionary<string, ProjectTargetInstance> Targets
             /// <summary>
             /// Properties encountered during evaluation. These are read during the first evaluation pass.
             /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-            /// were subsequently overridden by others with the same name. It does not include any 
+            /// were subsequently overridden by others with the same name. It does not include any
             /// properties whose conditions did not evaluate to true.
             /// It does not include any properties added since the last evaluation.
             /// </summary>
@@ -2221,7 +2233,7 @@ public override ICollection<ProjectProperty> AllEvaluatedProperties
             /// <summary>
             /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
             /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-            /// were subsequently overridden by others with the same name and item type. It does not include any 
+            /// were subsequently overridden by others with the same name and item type. It does not include any
             /// elements whose conditions did not evaluate to true.
             /// It does not include any item definition metadata added since the last evaluation.
             /// </summary>
@@ -2242,7 +2254,7 @@ public override ICollection<ProjectMetadata> AllEvaluatedItemDefinitionMetadata
 
             /// <summary>
             /// Items encountered during evaluation. These are read during the third evaluation pass.
-            /// Unlike those returned by the Items property, these are ordered with respect to all other items 
+            /// Unlike those returned by the Items property, these are ordered with respect to all other items
             /// encountered during evaluation, not just ordered with respect to items of the same item type.
             /// In some applications, like the F# language, this complete mutual ordering is significant, and such hosts
             /// can use this property.
@@ -2278,7 +2290,7 @@ public override ICollection<ProjectItem> AllEvaluatedItems
 
             /// <summary>
             /// The sub-toolset version that, combined with the ToolsVersion, was used to determine
-            /// the toolset properties for this project.  
+            /// the toolset properties for this project.
             /// </summary>
             public override string SubToolsetVersion => _data.SubToolsetVersion;
 
@@ -2303,7 +2315,7 @@ public string FullPath
 
             /// <summary>
             /// Whether ReevaluateIfNecessary is temporarily disabled.
-            /// This is useful when the host expects to make a number of reads and writes 
+            /// This is useful when the host expects to make a number of reads and writes
             /// to the project, and wants to temporarily sacrifice correctness for performance.
             /// </summary>
             public override bool SkipEvaluation { get; set; }
@@ -2321,7 +2333,7 @@ public string FullPath
             /// control which projects it allows to run targets/tasks.  By default, for a newly
             /// created project, we will use whatever setting is in the parent project collection.
             /// When build is disabled, the Build method on this class will fail. However if
-            /// the host has already created a ProjectInstance, it can still build it. (It is 
+            /// the host has already created a ProjectInstance, it can still build it. (It is
             /// free to put a similar check around where it does this.)
             /// </summary>
             public override bool IsBuildEnabled
@@ -2364,19 +2376,19 @@ public override bool IsBuildEnabled
             /// The ID of the last evaluation for this Project.
             /// A project is always evaluated upon construction and can subsequently get evaluated multiple times via
             /// <see cref="ProjectLink.ReevaluateIfNecessary" />
-            /// 
+            ///
             /// It is an arbitrary number that changes when this project reevaluates.
             /// Hosts don't know whether an evaluation actually happened in an interval, but they can compare this number to
             /// their previously stored value to find out, and if so perhaps decide to update their own state.
             /// Note that the number may not increase monotonically.
-            /// 
+            ///
             /// This number corresponds to the <seealso cref="BuildEventContext.EvaluationId"/> and can be used to connect
             /// evaluation logging events back to the Project instance.
             /// </summary>
             public override int LastEvaluationId => _data.EvaluationId;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable 
+            /// List of names of the properties that, while global, are still treated as overridable
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _data.GlobalPropertiesToTreatAsLocal;
 
@@ -2400,6 +2412,7 @@ public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext
             /// <summary>
             /// See <see cref="ProjectLink.GetAllGlobs(string, EvaluationContext)"/>
             /// </summary>
+            /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2580,6 +2593,7 @@ private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dict
             /// <summary>
             /// See <see cref="ProjectLink.GetItemProvenance(string, EvaluationContext)"/>
             /// </summary>
+            /// <param name="itemToMatch">The string to perform matching against</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2592,6 +2606,8 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, Eva
             /// <summary>
             /// See <see cref="ProjectLink.GetItemProvenance(string, string, EvaluationContext)"/>
             /// </summary>
+            /// <param name="itemToMatch">The string to perform matching against</param>
+            /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2604,6 +2620,11 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, str
             /// <summary>
             /// See <see cref="ProjectLink.GetItemProvenance(ProjectItem, EvaluationContext)"/>
             /// </summary>
+            /// /// <param name="item"> 
+            /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
+            /// The search is also constrained on item elements appearing before the item element that produced this <paramref name="item"/>.
+            /// The element that produced this <paramref name="item"/> is included in the results.
+            /// </param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
             ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
@@ -2624,7 +2645,7 @@ public override List<ProvenanceResult> GetItemProvenance(ProjectItem item, Evalu
             /// Some project APIs need to do analysis that requires the Evaluator to record more data than usual as it evaluates.
             /// This method checks if the Evaluator was run with the extra required settings and if not, does a re-evaluation.
             /// If a re-evaluation was necessary, it saves this information so a next call does not re-evaluate.
-            /// 
+            ///
             /// Using this method avoids storing extra data in memory when its not needed.
             /// </summary>
             /// <param name="evaluationContext"></param>
@@ -2632,7 +2653,7 @@ private List<ProjectItemElement> GetEvaluatedItemElements(EvaluationContext eval
             {
                 if (!_loadSettings.HasFlag(ProjectLoadSettings.RecordEvaluatedItemElements))
                 {
-                    _loadSettings = _loadSettings | ProjectLoadSettings.RecordEvaluatedItemElements;
+                    _loadSettings |= ProjectLoadSettings.RecordEvaluatedItemElements;
                     Reevaluate(LoggingService, _loadSettings, evaluationContext);
                 }
 
@@ -2726,7 +2747,7 @@ ProvenanceResult SingleItemSpecProvenance(string itemSpec, IElementLocation elem
             /// Since:
             ///     - we have no proper AST and interpreter for itemspecs that we can do analysis on
             ///     - GetItemProvenance needs to have correct counts for exclude strings (as correct as it can get while doing it after evaluation)
-            /// 
+            ///
             /// The temporary hack is to use the expander to expand the strings, and if any property or item references were encountered, return Provenance.Inconclusive
             /// </summary>
             private static int ItemMatchesInItemSpecString(string itemToMatch, string itemSpec, IElementLocation elementLocation, string projectDirectory, Expander<ProjectProperty, ProjectItem> expander, out Provenance provenance)
@@ -2780,7 +2801,7 @@ private static int ItemMatchesInItemSpec(string itemToMatch, EvaluationItemSpec
 
             /// <summary>
             /// Returns an iterator over the "logical project". The logical project is defined as
-            /// the unevaluated project obtained from the single MSBuild file that is the result 
+            /// the unevaluated project obtained from the single MSBuild file that is the result
             /// of inlining the text of all imports of the original MSBuild project manifest file.
             /// </summary>
             public override IEnumerable<ProjectElement> GetLogicalProject()
@@ -2822,7 +2843,7 @@ public override ProjectProperty GetProperty(string name)
             }
 
             /// <summary>
-            /// Get the unescaped value of a property in this project, or 
+            /// Get the unescaped value of a property in this project, or
             /// an empty string if it does not exist.
             /// </summary>
             /// <remarks>
@@ -3029,7 +3050,7 @@ public override IList<ProjectItem> AddItemFast(string itemType, string unevaluat
             /// Use AddItem or RemoveItem to modify items in this project.
             /// </summary>
             /// <comments>
-            /// data.GetItems returns a read-only collection, so no need to re-wrap it here. 
+            /// data.GetItems returns a read-only collection, so no need to re-wrap it here.
             /// </comments>
             public override ICollection<ProjectItem> GetItems(string itemType)
             {
@@ -3043,7 +3064,7 @@ public override ICollection<ProjectItem> GetItems(string itemType)
             /// This is a read-only list: use AddItem or RemoveItem to modify items in this project.
             /// </summary>
             /// <comments>
-            /// ItemDictionary[] returns a read only collection, so no need to wrap it. 
+            /// ItemDictionary[] returns a read only collection, so no need to wrap it.
             /// </comments>
             public override ICollection<ProjectItem> GetItemsIgnoringCondition(string itemType)
             {
@@ -3195,6 +3216,7 @@ public override string ExpandString(string unexpandedValue)
             /// <summary>
             /// See <see cref="ProjectLink.CreateProjectInstance(ProjectInstanceSettings, EvaluationContext)"/>
             /// </summary>
+            /// <param name="settings">Project instance creation settings</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             /// <returns></returns>
             public override ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
@@ -3232,7 +3254,7 @@ public override void ReevaluateIfNecessary(EvaluationContext evaluationContext)
             }
 
             /// <summary>
-            /// Saves a "logical" or "preprocessed" project file, that includes all the imported 
+            /// Saves a "logical" or "preprocessed" project file, that includes all the imported
             /// files as if they formed a single file.
             /// </summary>
             public override void SaveLogicalProject(TextWriter writer)
@@ -3249,6 +3271,9 @@ public override void SaveLogicalProject(TextWriter writer)
             /// <summary>
             /// See <see cref="ProjectLink.Build"/>
             /// </summary>
+            /// <param name="targets">targets to build</param>
+            /// <param name="loggers">List of loggers</param>
+            /// <param name="remoteLoggers">remote loggers for multi proc logging</param>
             /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
             public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
             {
@@ -3299,10 +3324,10 @@ public bool UsesProjectRootElement(ProjectRootElement xmlRootElement)
             /// A ProjectItemElement could have resulted in several items if it contains wildcards or item or property expressions.
             /// Before any edit to a ProjectItem (remove, rename, set metadata, or remove metadata) this must be called to make
             /// sure that the edit does not affect any other ProjectItems originating in the same ProjectItemElement.
-            /// 
+            ///
             /// For example, an item xml with an include of "@(x)" could evaluate to items "a", "b", and "c". If "b" is removed, then the original
             /// item xml must be removed and replaced with three, then the one corresponding to "b" can be removed.
-            /// 
+            ///
             /// This is an unsophisticated approach; the best that can be said is that the result will likely be correct, if not ideal.
             /// For example, perhaps the user would rather remove the item from the original list "x" instead of expanding the list.
             /// Or, perhaps the user would rather the property in "$(p)\a;$(p)\b" not be expanded when "$(p)\b" is removed.
@@ -3345,7 +3370,7 @@ internal bool ItemElementRequiresSplitting(ProjectItemElement itemElement)
             }
 
             /// <summary>
-            /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the 
+            /// Examines the provided ProjectItemElement to see if it has a wildcard that would match the
             /// item we wish to add, and does not have a condition or an exclude.
             /// Works conservatively - if there is anything that might cause doubt, considers the candidate to not be suitable.
             /// Returns true if it is suitable, otherwise false.
@@ -3392,7 +3417,7 @@ public bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItemXm
 
             /// <summary>
             /// Before an item changes its item type, it must be removed from
-            /// our datastructures, which key off item type. 
+            /// our datastructures, which key off item type.
             /// This should be called ONLY by ProjectItems, in this situation.
             /// </summary>
             public void RemoveItemBeforeItemTypeChange(ProjectItem item)
@@ -3489,7 +3514,7 @@ public override void Unload()
             /// <summary>
             /// Verify that the provided object location is in the same file as the project.
             /// If it is not, throws an InvalidOperationException indicating that imported evaluated objects should not be modified.
-            /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the 
+            /// This prevents, for example, accidentally updating something like the OutputPath property, that you want be in the
             /// main project, but for some reason was actually read in from an imported targets file.
             /// </summary>
             internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml)
@@ -3601,7 +3626,7 @@ private void ReevaluateIfNecessary(
 
             /// <summary>
             /// Creates a project instance based on this project using the specified logging service.
-            /// </summary>  
+            /// </summary>
             private ProjectInstance CreateProjectInstance(
                 ILoggingService loggingServiceForEvaluation,
                 ProjectInstanceSettings settings,
@@ -3728,12 +3753,12 @@ private void ProjectRootElement_ProjectXmlChangedHandler(object sender, ProjectX
             /// <summary>
             /// Tries to find a ProjectItemElement already in the project file XML that has a wildcard that would match the
             /// item we wish to add, does not have a condition or an exclude, and is within an itemgroup without a condition.
-            /// 
+            ///
             /// For perf reasons, this method does several jobs in one.
             /// If it finds a suitable existing item element, it returns that as the out parameter, otherwise the out parameter returns null.
             /// Otherwise, if it finds an item element suitable to be just below our new element, it returns that.
             /// Otherwise, if it finds an item group at least that's suitable to put our element in somewhere, it returns that.
-            /// 
+            ///
             /// Returns null if the include of the item being added itself has wildcards, or semicolons, as the case is too difficult.
             /// </summary>
             private ProjectElement GetAnySuitableExistingItemXml(string itemType, string unevaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata, out ProjectItemElement suitableExistingItemXml)
@@ -3916,7 +3941,7 @@ internal class Data : IItemProvider<ProjectItem>, IPropertyProvider<ProjectPrope
             private static WeakReference<RetrievableEntryHashSet<ProjectTargetInstance>> s_typicalTargetsCollection;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable 
+            /// List of names of the properties that, while global, are still treated as overridable
             /// </summary>
             private ISet<string> _globalPropertiesToTreatAsLocal;
 
@@ -3967,7 +3992,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => this.Project.ProjectCollection.EnvironmentProperties;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable 
+            /// List of names of the properties that, while global, are still treated as overridable
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _globalPropertiesToTreatAsLocal ?? (_globalPropertiesToTreatAsLocal =
                                                                       new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default));
@@ -4004,13 +4029,13 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
 
             /// <summary>
             /// The externally specified sub-toolset version that, combined with the ToolsVersion, is used to determine
-            /// the toolset properties for this project.  
+            /// the toolset properties for this project.
             /// </summary>
             public string ExplicitSubToolsetVersion { get; }
 
             /// <summary>
             /// The sub-toolset version that, combined with the ToolsVersion, was used to determine
-            /// the toolset properties for this project.  
+            /// the toolset properties for this project.
             /// </summary>
             public string SubToolsetVersion { get; private set; }
 
@@ -4040,17 +4065,17 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Collection of possible values implied for properties contained in the conditions found on properties,
             /// property groups, imports, and whens.
-            /// 
+            ///
             /// For example, if the following conditions existed on properties in a project:
-            /// 
+            ///
             /// Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
             /// Condition="'$(Configuration)' == 'Release'"
-            /// 
+            ///
             /// the table would be populated with
-            /// 
+            ///
             /// { "Configuration", { "Debug", "Release" }}
             /// { "Platform", { "x86" }}
-            /// 
+            ///
             /// This is used by Visual Studio to determine the configurations defined in the project.
             /// </summary>
             public Dictionary<string, List<string>> ConditionedProperties { get; private set; }
@@ -4073,7 +4098,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// Read only collection.
             /// </summary>
             /// <comments>
-            /// item.ItemTypes is a KeyCollection, so it doesn't need any 
+            /// item.ItemTypes is a KeyCollection, so it doesn't need any
             /// additional read-only protection
             /// </comments>
             public ICollection<string> ItemTypes => Items.ItemTypes;
@@ -4081,7 +4106,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Properties encountered during evaluation. These are read during the first evaluation pass.
             /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-            /// were subsequently overridden by others with the same name. It does not include any 
+            /// were subsequently overridden by others with the same name. It does not include any
             /// properties whose conditions did not evaluate to true.
             /// It does not include any properties added since the last evaluation.
             /// </summary>
@@ -4090,7 +4115,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
             /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-            /// were subsequently overridden by others with the same name and item type. It does not include any 
+            /// were subsequently overridden by others with the same name and item type. It does not include any
             /// elements whose conditions did not evaluate to true.
             /// It does not include any item definition metadata added since the last evaluation.
             /// </summary>
@@ -4283,7 +4308,7 @@ public void AddItemIgnoringCondition(ProjectItem item)
             /// <summary>
             /// Properties encountered during evaluation. These are read during the first evaluation pass.
             /// Unlike those returned by the Properties property, these are ordered, and includes any properties that
-            /// were subsequently overridden by others with the same name. It does not include any 
+            /// were subsequently overridden by others with the same name. It does not include any
             /// properties whose conditions did not evaluate to true.
             /// </summary>
             public void AddToAllEvaluatedPropertiesList(ProjectProperty property)
@@ -4295,7 +4320,7 @@ public void AddToAllEvaluatedPropertiesList(ProjectProperty property)
             /// <summary>
             /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
             /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-            /// were subsequently overridden by others with the same name and item type. It does not include any 
+            /// were subsequently overridden by others with the same name and item type. It does not include any
             /// elements whose conditions did not evaluate to true.
             /// </summary>
             public void AddToAllEvaluatedItemDefinitionMetadataList(ProjectMetadata itemDefinitionMetadatum)
@@ -4388,7 +4413,7 @@ public void AddTarget(ProjectTargetInstance target)
             /// <remarks>
             /// This may include imported files that ended up contributing nothing to the evaluated project.
             /// These might otherwise have no strong references to them at all.
-            /// If they are dirtied, though, they might affect the evaluated project; and that's why we record them. 
+            /// If they are dirtied, though, they might affect the evaluated project; and that's why we record them.
             /// Mostly these will be common imports, so they'll be shared anyway.
             /// </remarks>
             public void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult)
@@ -4514,7 +4539,7 @@ internal ICollection<ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInc
             }
 
             /// <summary>
-            /// Get the value of a property in this project, or 
+            /// Get the value of a property in this project, or
             /// an empty string if it does not exist.
             /// Returns the unescaped value.
             /// </summary>
@@ -4589,7 +4614,7 @@ public GlobResult(ProjectItemElement itemElement, IEnumerable<string> includeGlo
     public enum Provenance
     {
         /// <summary>
-        /// Undefined is the bottom element and should not appear in actual results 
+        /// Undefined is the bottom element and should not appear in actual results
         /// </summary>
         Undefined = 0,
 
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index ce296a6a0cf..4b9c602b48b 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -208,7 +208,7 @@ public void Dispose()
 
         /// <summary>
         /// Whether reevaluation is temporarily disabled on projects in this collection.
-        /// This is useful when the host expects to make a number of reads and writes 
+        /// This is useful when the host expects to make a number of reads and writes
         /// to projects, and wants to temporarily sacrifice correctness for performance.
         /// </summary>
         private bool _skipEvaluation;
@@ -227,7 +227,7 @@ public void Dispose()
         private int _maxNodeCount;
 
         /// <summary>
-        /// Instantiates a project collection with no global properties or loggers that reads toolset 
+        /// Instantiates a project collection with no global properties or loggers that reads toolset
         /// information from the configuration file and registry.
         /// </summary>
         public ProjectCollection()
@@ -406,7 +406,7 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab
 
         /// <summary>
         /// Retrieves the global project collection object.
-        /// This is a singleton project collection with no global properties or loggers that reads toolset 
+        /// This is a singleton project collection with no global properties or loggers that reads toolset
         /// information from the configuration file and registry.
         /// May throw InvalidToolsetDefinitionException.
         /// Thread safe.
@@ -482,7 +482,7 @@ public static string DisplayVersion
         /// <summary>
         /// The default tools version of this project collection. Projects use this tools version if they
         /// aren't otherwise told what tools version to use.
-        /// This value is gotten from the .exe.config file, or else in the registry, 
+        /// This value is gotten from the .exe.config file, or else in the registry,
         /// or if neither specify a default tools version then it is hard-coded to the tools version "2.0".
         /// Setter throws InvalidOperationException if a toolset with the provided tools version has not been defined.
         /// Always defined.
@@ -531,8 +531,8 @@ public string DefaultToolsVersion
         /// </summary>
         /// <remarks>
         /// This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
-        /// 
-        /// To be consistent with Project, setting and removing global properties is done with 
+        ///
+        /// To be consistent with Project, setting and removing global properties is done with
         /// <see cref="SetGlobalProperty">SetGlobalProperty</see> and <see cref="RemoveGlobalProperty">RemoveGlobalProperty</see>.
         /// </remarks>
         public IDictionary<string, string> GlobalProperties
@@ -739,7 +739,7 @@ public HostServices HostServices
 
         /// <summary>
         /// Whether reevaluation is temporarily disabled on projects in this collection.
-        /// This is useful when the host expects to make a number of reads and writes 
+        /// This is useful when the host expects to make a number of reads and writes
         /// to projects, and wants to temporarily sacrifice correctness for performance.
         /// </summary>
         public bool SkipEvaluation
@@ -849,7 +849,7 @@ internal PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesCollection
             get
             {
                 var clone = new PropertyDictionary<ProjectPropertyInstance>();
-                
+
                 using (_locker.EnterUpgradeableReadLock())
                 {
                     foreach (ProjectPropertyInstance property in _globalProperties)
@@ -962,7 +962,7 @@ public static string Unescape(string escapedString)
         }
 
         /// <summary>
-        /// Returns true if there is a toolset defined for the specified 
+        /// Returns true if there is a toolset defined for the specified
         /// tools version, otherwise false.
         /// </summary>
         public bool ContainsToolset(string toolsVersion) => GetToolset(toolsVersion) != null;
@@ -1042,7 +1042,7 @@ public Toolset GetToolset(string toolsVersion)
         }
 
         /// <summary>
-        /// Figure out what ToolsVersion to use to actually build the project with. 
+        /// Figure out what ToolsVersion to use to actually build the project with.
         /// </summary>
         /// <param name="explicitToolsVersion">The user-specified ToolsVersion (through e.g. /tv: on the command line). May be null</param>
         /// <param name="toolsVersionFromProject">The ToolsVersion from the project file. May be null</param>
@@ -1752,8 +1752,8 @@ internal void ResetToolsetsForTests(ToolsetRegistryReader registryReaderForTests
 #endif
 
         /// <summary>
-        /// Populate Toolsets with a dictionary of (toolset version, Toolset) 
-        /// using information from the registry and config file, if any.  
+        /// Populate Toolsets with a dictionary of (toolset version, Toolset)
+        /// using information from the registry and config file, if any.
         /// </summary>
         private void InitializeToolsetCollection(
 #if FEATURE_WIN32_REGISTRY
@@ -2360,7 +2360,7 @@ private class LoadedProjectCollection : IEnumerable<Project>
             /// with different global properties and/or tools version.
             /// </summary>
             /// <remarks>
-            /// If hosts tend to load lots of projects with the same path, the value will have to be 
+            /// If hosts tend to load lots of projects with the same path, the value will have to be
             /// changed to a more efficient type of collection.
             ///
             /// Lock on this object. Concurrent load must be thread safe.
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 36ab13bf25d..17c7a9716ef 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -521,7 +521,7 @@ ProjectMetadata IItem<ProjectMetadata>.GetMetadata(string name)
         /// </summary>
         ProjectMetadata IItem<ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedInclude)
         {
-            _directMetadata = _directMetadata ?? new PropertyDictionary<ProjectMetadata>();
+            _directMetadata ??= new PropertyDictionary<ProjectMetadata>();
 
             ProjectMetadata predecessor = GetMetadata(metadataElement.Name);
 
@@ -598,7 +598,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
 
             if (!propagateMetadataToSiblingItems)
             {
-                _directMetadata = _directMetadata ?? new PropertyDictionary<ProjectMetadata>();
+                _directMetadata ??= new PropertyDictionary<ProjectMetadata>();
                 _directMetadata.Set(metadatum);
             }
             else
@@ -607,7 +607,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
 
                 foreach (var siblingItem in siblingItems)
                 {
-                    siblingItem._directMetadata = siblingItem._directMetadata ?? new PropertyDictionary<ProjectMetadata>();
+                    siblingItem._directMetadata ??= new PropertyDictionary<ProjectMetadata>();
                     siblingItem._directMetadata.Set(metadatum.DeepClone());
                 }
             }
@@ -1060,14 +1060,14 @@ private ProjectItem CreateItem(string evaluatedIncludeEscaped, string evaluatedI
 
                 if (source._inheritedItemDefinitions != null)
                 {
-                    inheritedItemDefinitionsClone = inheritedItemDefinitionsClone ?? new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
+                    inheritedItemDefinitionsClone ??= new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
                     inheritedItemDefinitionsClone.AddRange(source._inheritedItemDefinitions);
                 }
 
                 ProjectItemDefinition sourceItemDefinition;
                 if (_project.ItemDefinitions.TryGetValue(source.ItemType, out sourceItemDefinition))
                 {
-                    inheritedItemDefinitionsClone = inheritedItemDefinitionsClone ?? new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
+                    inheritedItemDefinitionsClone ??= new List<ProjectItemDefinition>(inheritedItemDefinitionsCount + 1);
                     inheritedItemDefinitionsClone.Add(sourceItemDefinition);
                 }
 
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index 08ca675b7a0..f716c3e61d4 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -173,7 +173,7 @@ public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue)
 
             ProjectMetadataElement metadatumXml = itemDefinition.AddMetadata(name, unevaluatedValue);
 
-            _metadata = _metadata ?? new PropertyDictionary<ProjectMetadata>();
+            _metadata ??= new PropertyDictionary<ProjectMetadata>();
 
             string evaluatedValueEscaped = _project.ExpandMetadataValueBestEffortLeaveEscaped(this, unevaluatedValue, metadatumXml.Location);
 
@@ -192,7 +192,7 @@ public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue)
         /// </summary>
         ProjectMetadata IItemDefinition<ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue, ProjectMetadata predecessor)
         {
-            _metadata = _metadata ?? new PropertyDictionary<ProjectMetadata>();
+            _metadata ??= new PropertyDictionary<ProjectMetadata>();
 
             ProjectMetadata metadatum = new ProjectMetadata(this, metadataElement, evaluatedValue, predecessor);
             _metadata.Set(metadatum);
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index b6cf7ce139e..1c1c85f3df2 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -14,7 +14,7 @@
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
-    /// An evaluated design-time property 
+    /// An evaluated design-time property
     /// </summary>
     [DebuggerDisplay("{Name}={EvaluatedValue} [{UnevaluatedValue}]")]
     public abstract class ProjectProperty : IKeyed, IValued, IProperty, IEquatable<ProjectProperty>
@@ -57,7 +57,7 @@ internal ProjectProperty(Project project, string evaluatedValueEscaped)
         /// </summary>
         /// <comment>
         /// If this could be set, it would be necessary to have a callback
-        /// so that the containing collections could be updated, as they use the name as 
+        /// so that the containing collections could be updated, as they use the name as
         /// their key.
         /// </comment>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -232,7 +232,7 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
         #endregion
 
         /// <summary>
-        /// Creates a property without backing XML. 
+        /// Creates a property without backing XML.
         /// Property MAY BE global, and property MAY HAVE a reserved name (such as "MSBuildProjectDirectory") if indicated.
         /// This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
         /// All other properties originate in XML, and should have a backing XML object.
@@ -278,7 +278,7 @@ internal void UpdateEvaluatedValue(string evaluatedValueEscaped)
         /// <remarks>
         /// The reason we do this and not just look at project.GlobalProperties is
         /// that when the project is being loaded, the GlobalProperties collection is already populated.  When we do our
-        /// evaluation, we may attempt to add some properties, such as environment variables, to the master Properties 
+        /// evaluation, we may attempt to add some properties, such as environment variables, to the master Properties
         /// collection.  As GlobalProperties are supposed to override these and thus be added last, we can't check against
         /// the GlobalProperties collection as they are being added.  The correct behavior is to always check against the
         /// collection which is accumulating properties as we go, which is the Properties collection.  Once the project has
@@ -331,7 +331,7 @@ internal ProjectPropertyXmlBacked(Project project, ProjectPropertyElement xml, s
             /// </summary>
             /// <comment>
             /// If this could be set, it would be necessary to have a callback
-            /// so that the containing collections could be updated, as they use the name as 
+            /// so that the containing collections could be updated, as they use the name as
             /// their key.
             /// </comment>
             [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -348,7 +348,7 @@ public override string Name
             /// </summary>
             /// <remarks>
             /// The containing project will be dirtied by the XML modification.
-            /// If there is no XML backing, the evaluated value returned is the value of the property that has been 
+            /// If there is no XML backing, the evaluated value returned is the value of the property that has been
             /// escaped as necessary.
             /// </remarks>
             public override string UnevaluatedValue
@@ -496,7 +496,7 @@ private class ProjectPropertyNotXmlBacked : ProjectProperty
             private readonly string _name;
 
             /// <summary>
-            /// Creates a property without backing XML. 
+            /// Creates a property without backing XML.
             /// Property MAY BE global, and property MAY HAVE a reserved name (such as "MSBuildProjectDirectory") if indicated.
             /// This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
             /// All other properties originate in XML, and should have a backing XML object.
@@ -518,7 +518,7 @@ internal ProjectPropertyNotXmlBacked(Project project, string name, string evalua
             /// </summary>
             /// <comment>
             /// If this could be set, it would be necessary to have a callback
-            /// so that the containing collections could be updated, as they use the name as 
+            /// so that the containing collections could be updated, as they use the name as
             /// their key.
             /// </comment>
             [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -535,7 +535,7 @@ public override string Name
             /// </summary>
             /// <remarks>
             /// The containing project will be dirtied.
-            /// As there is no XML backing, the evaluated value returned is the value of the property that has been 
+            /// As there is no XML backing, the evaluated value returned is the value of the property that has been
             /// escaped as necessary.
             /// </remarks>
             public override string UnevaluatedValue
@@ -628,9 +628,5 @@ public override bool IsImported
                 get { return false; }
             }
         }
-
-        /// <summary>
-        /// External projects support
-        /// </summary>
     }
 }
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 8ce8b05ed9d..75eac2dd601 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -43,89 +43,89 @@ public class Toolset : ITranslatable
     {
         /// <summary>
         /// these files list all default tasks and task assemblies that do not need to be explicitly declared by projects
-        /// </summary> 
+        /// </summary>
         private const string DefaultTasksFilePattern = "*.tasks";
 
         /// <summary>
         /// these files list all Override tasks and task assemblies that do not need to be explicitly declared by projects
-        /// </summary> 
+        /// </summary>
         private const string OverrideTasksFilePattern = "*.overridetasks";
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
-        /// Regkey that we check to see whether Dev10 is installed.  This should exist if any SKU of Dev10 is installed, 
-        /// but is not removed even when the last version of Dev10 is uninstalled, due to 10.0\bsln sticking around. 
+        /// Regkey that we check to see whether Dev10 is installed.  This should exist if any SKU of Dev10 is installed,
+        /// but is not removed even when the last version of Dev10 is uninstalled, due to 10.0\bsln sticking around.
         /// </summary>
         private const string Dev10OverallInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0";
 
         /// <summary>
-        /// Regkey that we check to see whether Dev10 Ultimate is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether Dev10 Ultimate is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10UltimateInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\vstscore";
 
         /// <summary>
-        /// Regkey that we check to see whether Dev10 Premium is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether Dev10 Premium is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10PremiumInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\vstdcore";
 
         /// <summary>
-        /// Regkey that we check to see whether Dev10 Professional is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether Dev10 Professional is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10ProfessionalInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\procore";
 
         /// <summary>
-        /// Regkey that we check to see whether C# Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether C# Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VCSExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vcs\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether VB Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether VB Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VBExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vb\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether VC Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether VC Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VCExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vc\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether VWD Express 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether VWD Express 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10VWDExpressInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vns\Servicing\10.0\xcor";
 
         /// <summary>
-        /// Regkey that we check to see whether LightSwitch 2010 is installed.  This will exist if it is installed, and be 
-        /// properly removed after it has been uninstalled.  
+        /// Regkey that we check to see whether LightSwitch 2010 is installed.  This will exist if it is installed, and be
+        /// properly removed after it has been uninstalled.
         /// </summary>
         private const string Dev10LightSwitchInstallKeyRegistryPath = @"Software\Microsoft\DevDiv\vs\Servicing\10.0\vslscore";
 
         /// <summary>
-        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on 
-        /// the current machine, false otherwise. 
+        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on
+        /// the current machine, false otherwise.
         /// </summary>
         private static bool? s_dev10IsInstalled = null;
 #endif // FEATURE_WIN32_REGISTRY
 
         /// <summary>
         /// Name of the tools version
-        /// </summary> 
+        /// </summary>
         private string _toolsVersion;
 
         /// <summary>
         /// The MSBuildBinPath (and ToolsPath) for this tools version
-        /// </summary> 
+        /// </summary>
         private string _toolsPath;
 
         /// <summary>
         /// The properties defined by the toolset.
-        /// </summary> 
+        /// </summary>
         private PropertyDictionary<ProjectPropertyInstance> _properties;
 
         /// <summary>
@@ -150,22 +150,22 @@ public class Toolset : ITranslatable
 
         /// <summary>
         /// indicates if the default tasks file has already been scanned
-        /// </summary> 
+        /// </summary>
         private bool _defaultTasksRegistrationAttempted;
 
         /// <summary>
         /// indicates if the override tasks file has already been scanned
-        /// </summary> 
+        /// </summary>
         private bool _overrideTasksRegistrationAttempted;
 
         /// <summary>
         /// holds all the default tasks we know about and the assemblies they exist in
-        /// </summary> 
+        /// </summary>
         private TaskRegistry _defaultTaskRegistry;
 
         /// <summary>
         /// holds all the override tasks we know about and the assemblies they exist in
-        /// </summary> 
+        /// </summary>
         private TaskRegistry _overrideTaskRegistry;
 
         /// <summary>
@@ -194,13 +194,13 @@ public class Toolset : ITranslatable
         private PropertyDictionary<ProjectPropertyInstance> _propertyBag;
 
         /// <summary>
-        /// SubToolsets that map to this toolset. 
+        /// SubToolsets that map to this toolset.
         /// </summary>
         private Dictionary<string, SubToolset> _subToolsets;
 
         /// <summary>
-        /// If no sub-toolset is specified, this is the default sub-toolset version.  Null == no default 
-        /// sub-toolset, just use the base toolset. 
+        /// If no sub-toolset is specified, this is the default sub-toolset version.  Null == no default
+        /// sub-toolset, just use the base toolset.
         /// </summary>
         private string _defaultSubToolsetVersion;
 
@@ -464,16 +464,16 @@ public IDictionary<string, SubToolset> SubToolsets
         }
 
         /// <summary>
-        /// Returns the default sub-toolset version for this sub-toolset.  Heuristic used is: 
-        /// 1) If Visual Studio 2010 is installed and our ToolsVersion is "4.0", use the base toolset, and return 
-        ///    a sub-toolset version of "10.0", to be set as a publicly visible property so that e.g. targets can 
-        ///    consume it.  This is to handle the fact that Visual Studio 2010 did not have any concept of sub-toolsets. 
-        /// 2) Otherwise, use the highest-versioned sub-toolset found.  Sub-toolsets with numbered versions will 
-        ///    be ordered numerically; any additional sub-toolsets will be prepended to the beginning of the list in 
-        ///    the order found. We use the highest-versioned sub-toolset because, in the absence of any other information, 
-        ///    we assume that higher-versioned tools will be more likely to be able to generate something more correct.  
-        /// 
-        /// Will return null if there is no sub-toolset available (and Dev10 is not installed). 
+        /// Returns the default sub-toolset version for this sub-toolset.  Heuristic used is:
+        /// 1) If Visual Studio 2010 is installed and our ToolsVersion is "4.0", use the base toolset, and return
+        ///    a sub-toolset version of "10.0", to be set as a publicly visible property so that e.g. targets can
+        ///    consume it.  This is to handle the fact that Visual Studio 2010 did not have any concept of sub-toolsets.
+        /// 2) Otherwise, use the highest-versioned sub-toolset found.  Sub-toolsets with numbered versions will
+        ///    be ordered numerically; any additional sub-toolsets will be prepended to the beginning of the list in
+        ///    the order found. We use the highest-versioned sub-toolset because, in the absence of any other information,
+        ///    we assume that higher-versioned tools will be more likely to be able to generate something more correct.
+        ///
+        /// Will return null if there is no sub-toolset available (and Dev10 is not installed).
         /// </summary>
         public string DefaultSubToolsetVersion
         {
@@ -520,11 +520,11 @@ public string DefaultSubToolsetVersion
         }
 
         /// <summary>
-        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on 
-        /// the current machine, false otherwise. 
+        /// Null if it hasn't been figured out yet; true if (some variation of) Visual Studio 2010 is installed on
+        /// the current machine, false otherwise.
         /// </summary>
         /// <comments>
-        /// Internal so that unit tests can use it too. 
+        /// Internal so that unit tests can use it too.
         /// </comments>
         internal static bool Dev10IsInstalled
         {
@@ -631,13 +631,13 @@ void ITranslatable.Translate(ITranslator translator)
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 2. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
+        /// 1. If "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 2. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
         /// </summary>
         public string GenerateSubToolsetVersion()
         {
@@ -647,17 +647,17 @@ public string GenerateSubToolsetVersion()
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
-        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
-        /// 4. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
-        /// 
-        /// The global properties dictionary may be null. 
+        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it.
+        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset.
+        /// 4. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
+        ///
+        /// The global properties dictionary may be null.
         /// </summary>
         [SuppressMessage("Microsoft.Usage", "CA2233:OperationsShouldNotOverflow", MessageId = "solutionVersion-1", Justification = "Method called in restricted places. Checks done by the callee and inside the method.")]
         public string GenerateSubToolsetVersion(IDictionary<string, string> overrideGlobalProperties, int solutionVersion)
@@ -666,9 +666,9 @@ public string GenerateSubToolsetVersion(IDictionary<string, string> overrideGlob
         }
 
         /// <summary>
-        /// Given a property name and a sub-toolset version, searches for that property first in the 
-        /// sub-toolset, then falls back to the base toolset if necessary, and returns the property 
-        /// if it was found. 
+        /// Given a property name and a sub-toolset version, searches for that property first in the
+        /// sub-toolset, then falls back to the base toolset if necessary, and returns the property
+        /// if it was found.
         /// </summary>
         public ProjectPropertyInstance GetProperty(string propertyName, string subToolsetVersion)
         {
@@ -750,17 +750,17 @@ internal static string[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingServic
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
-        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
-        /// 4. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
-        /// 
-        /// The global properties dictionary may be null. 
+        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it.
+        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset.
+        /// 4. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
+        ///
+        /// The global properties dictionary may be null.
         /// </summary>
         internal string GenerateSubToolsetVersion(PropertyDictionary<ProjectPropertyInstance> overrideGlobalProperties)
         {
@@ -783,17 +783,17 @@ internal string GenerateSubToolsetVersion(PropertyDictionary<ProjectPropertyInst
 
         /// <summary>
         /// Generates the sub-toolset version to be used with this toolset.  Sub-toolset version is based on:
-        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it. 
-        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment), 
-        ///    use that. 
-        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset. 
-        /// 4. Otherwise, use the default sub-toolset version for this toolset. 
-        /// 
-        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used, 
-        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing 
-        /// sub-toolset.  
-        /// 
-        /// The global properties dictionary may be null. 
+        /// 1. If the "VisualStudioVersion" global property exists in the set of properties passed to us, use it.
+        /// 2. Otherwise, if "VisualStudioVersion" is set as a property on the toolset itself (global or environment),
+        ///    use that.
+        /// 3. Otherwise, use Visual Studio version from solution file if it maps to an existing sub-toolset.
+        /// 4. Otherwise, use the default sub-toolset version for this toolset.
+        ///
+        /// The sub-toolset version returned may be null; if so, that means that no sub-toolset should be used,
+        /// just the base toolset on its own. The sub-toolset version returned may not map to an existing
+        /// sub-toolset.
+        ///
+        /// The global properties dictionary may be null.
         /// </summary>
         internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
         {
@@ -834,7 +834,7 @@ internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution)
         }
 
         /// <summary>
-        /// Return a task registry stub for the tasks in the *.tasks file for this toolset         
+        /// Return a task registry stub for the tasks in the *.tasks file for this toolset
         /// </summary>
         /// <param name="loggingServices">The logging services used to log during task registration.</param>
         /// <param name="buildEventContext">The build event context used to log during task registration.</param>
@@ -862,7 +862,7 @@ internal string GenerateSubToolsetVersionUsingVisualStudioVersion(IDictionary<st
         }
 
         /// <summary>
-        /// Return a task registry for the override tasks in the *.overridetasks file for this toolset         
+        /// Return a task registry for the override tasks in the *.overridetasks file for this toolset
         /// </summary>
         /// <param name="loggingServices">The logging services used to log during task registration.</param>
         /// <param name="buildEventContext">The build event context used to log during task registration.</param>
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index f8eb8933415..b8ee7c0dbd6 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -106,7 +106,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> ToolsVersions
         protected override string MSBuildOverrideTasksPath => ConfigurationSection?.MSBuildOverrideTasksPath;
 
         /// <summary>
-        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the tools version that should be used by 
+        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the tools version that should be used by
         /// default to build projects with this version of MSBuild.
         /// </summary>
         protected override string DefaultOverrideToolsVersion => ConfigurationSection?.DefaultOverrideToolsVersion;
@@ -171,7 +171,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
         /// <summary>
         /// Provides an enumerator over the set of sub-toolset names available to a particular
         /// tools version.  MSBuild config files do not currently support sub-toolsets, so
-        /// we return nothing. 
+        /// we return nothing.
         /// </summary>
         /// <param name="toolsVersion">The tools version.</param>
         /// <returns>An enumeration of the sub-toolsets that belong to that tools version.</returns>
@@ -181,9 +181,9 @@ protected override IEnumerable<string> GetSubToolsetVersions(string toolsVersion
         }
 
         /// <summary>
-        /// Provides an enumerator over property definitions for a specified sub-toolset version 
-        /// under a specified toolset version. In the ToolsetConfigurationReader case, breaks 
-        /// immediately because we do not currently support sub-toolsets in the configuration file. 
+        /// Provides an enumerator over property definitions for a specified sub-toolset version
+        /// under a specified toolset version. In the ToolsetConfigurationReader case, breaks
+        /// immediately because we do not currently support sub-toolsets in the configuration file.
         /// </summary>
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version.</param>
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 325ec703d9c..3c140fc14b9 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -150,7 +150,7 @@ ToolsetDefinitionLocations locations
                 if (NativeMethodsShared.IsWindows || registryReader != null)
                 {
                     // If we haven't been provided a registry reader (i.e. unit tests), create one
-                    registryReader = registryReader ?? new ToolsetRegistryReader(environmentProperties, globalProperties);
+                    registryReader ??= new ToolsetRegistryReader(environmentProperties, globalProperties);
 
                     // We do not accumulate properties when reading them from the registry, because the order
                     // in which values are returned to us is essentially random: so we disallow one property
@@ -626,7 +626,7 @@ private static void AppendStandardProperties(
         /// <param name="expander">The expander used to expand the value of the properties.  Ref because if we are accumulating the properties, we need to re-create the expander to account for the new property value.</param>
         private void EvaluateAndSetProperty(ToolsetPropertyDefinition property, PropertyDictionary<ProjectPropertyInstance> properties, PropertyDictionary<ProjectPropertyInstance> globalProperties, PropertyDictionary<ProjectPropertyInstance> initialProperties, bool accumulateProperties, ref string toolsPath, ref string binPath, ref Expander<ProjectPropertyInstance, ProjectItemInstance> expander)
         {
-            if (0 == String.Compare(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
             {
                 toolsPath = ExpandPropertyUnescaped(property, expander);
                 toolsPath = ExpandRelativePathsRelativeToExeLocation(toolsPath);
@@ -641,7 +641,7 @@ private void EvaluateAndSetProperty(ToolsetPropertyDefinition property, Property
                     );
                 }
             }
-            else if (0 == String.Compare(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
             {
                 binPath = ExpandPropertyUnescaped(property, expander);
                 binPath = ExpandRelativePathsRelativeToExeLocation(binPath);
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index ef54e940924..356b13845ba 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -43,12 +43,12 @@ internal class ToolsetRegistryReader : ToolsetReader
     {
         /// <summary>
         /// Registry location for storing tools version dependent data for msbuild
-        /// </summary> 
+        /// </summary>
         private const string MSBuildRegistryPath = @"SOFTWARE\Microsoft\MSBuild";
 
         /// <summary>
         /// Cached registry wrapper at root of the msbuild entries
-        /// </summary> 
+        /// </summary>
         private RegistryKeyWrapper _msbuildRegistryWrapper;
 
         /// <summary>
@@ -229,8 +229,8 @@ protected override IEnumerable<string> GetSubToolsetVersions(string toolsVersion
         }
 
         /// <summary>
-        /// Provides an enumerator over property definitions for a specified sub-toolset version 
-        /// under a specified toolset version. 
+        /// Provides an enumerator over property definitions for a specified sub-toolset version
+        /// under a specified toolset version.
         /// </summary>
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version.</param>
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index 58ff9b221a7..c551e6c16f1 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -105,7 +105,7 @@ bool initializationException
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index 802e25fd388..7331feccb1e 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -29,7 +29,7 @@ internal FunctionCallExpressionNode(string functionName, List<GenericExpressionN
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (String.Compare(_functionName, "exists", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(_functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
@@ -67,7 +67,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     return false;
                 }
             }
-            else if (String.Compare(_functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(_functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
diff --git a/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs b/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs
index 2e58501c88b..0b3ba717d50 100644
--- a/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/LessThanExpressionNode.cs
@@ -15,6 +15,9 @@ internal sealed class LessThanExpressionNode : NumericComparisonExpressionNode
         /// <summary>
         /// Compare numerically
         /// </summary>
+        /// <param name="left">left input</param>
+        /// <param name="right">right input</param>
+        /// <returns>true if right is higher than left, false otherwise</returns>
         protected override bool Compare(double left, double right)
         {
             return left < right;
@@ -23,7 +26,9 @@ protected override bool Compare(double left, double right)
         /// <summary>
         /// Compare Versions. This is only intended to compare version formats like "A.B.C.D" which can otherwise not be compared numerically
         /// </summary>
-        /// <returns></returns>
+        /// <param name="left">left version</param>
+        /// <param name="right">right version</param>
+        /// <returns>true if right version is higher than left, false otherwise</returns>
         protected override bool Compare(Version left, Version right)
         {
             return left < right;
@@ -32,6 +37,9 @@ protected override bool Compare(Version left, Version right)
         /// <summary>
         /// Compare mixed numbers and Versions
         /// </summary>
+        /// <param name="left">left version</param>
+        /// <param name="right">right number</param>
+        /// <returns>true if right is higher than major version of left, false otherwise</returns>
         protected override bool Compare(Version left, double right)
         {
             if (left.Major != right)
@@ -47,6 +55,9 @@ protected override bool Compare(Version left, double right)
         /// <summary>
         /// Compare mixed numbers and Versions
         /// </summary>
+        /// <param name="left">left number</param>
+        /// <param name="right">right version</param>
+        /// <returns>true if the major version of right is higher than left, false otherwise</returns>
         protected override bool Compare(double left, Version right)
         {
             if (right.Major != left)
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 57e434ccdbf..a0fabb89403 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -627,11 +627,11 @@ private bool ParseRemaining()
         private bool ParseSimpleStringOrFunction(int start)
         {
             SkipSimpleStringChars();
-            if (0 == string.Compare(_expression.Substring(start, _parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
+            if (string.Equals(_expression.Substring(start, _parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
             {
                 _lookahead = Token.And;
             }
-            else if (0 == string.Compare(_expression.Substring(start, _parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(_expression.Substring(start, _parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
             {
                 _lookahead = Token.Or;
             }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 0be48a483ba..ae617160848 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -34,7 +34,7 @@ namespace Microsoft.Build.Evaluation
 {
     /// <summary>
     /// Evaluates a ProjectRootElement, updating the fresh Project.Data passed in.
-    /// Handles evaluating conditions, expanding expressions, and building up the 
+    /// Handles evaluating conditions, expanding expressions, and building up the
     /// lists of applicable properties, items, and itemdefinitions, as well as gathering targets and tasks
     /// and creating a TaskRegistry from the using tasks.
     /// </summary>
@@ -88,7 +88,7 @@ internal class Evaluator<P, I, M, D>
         private readonly List<Pair<string, ProjectUsingTaskElement>> _usingTaskElements;
 
         /// <summary>
-        /// List of ProjectTargetElement's traversing into imports. 
+        /// List of ProjectTargetElement's traversing into imports.
         /// Gathered during the first pass to avoid traversing again.
         /// </summary>
         private readonly List<ProjectTargetElement> _targetElements;
@@ -99,14 +99,14 @@ internal class Evaluator<P, I, M, D>
         private readonly Dictionary<string, ProjectImportElement> _importsSeen;
 
         /// <summary>
-        /// Depth first collection of InitialTargets strings declared in the main 
+        /// Depth first collection of InitialTargets strings declared in the main
         /// Project and all its imported files, split on semicolons.
         /// </summary>
         private readonly List<string> _initialTargetsList;
 
         /// <summary>
-        /// Dictionary of project full paths and a boolean that indicates whether at least one 
-        /// of their targets has the "Returns" attribute set.  
+        /// Dictionary of project full paths and a boolean that indicates whether at least one
+        /// of their targets has the "Returns" attribute set.
         /// </summary>
         private readonly Dictionary<ProjectRootElement, NGen<bool>> _projectSupportsReturnsAttribute;
 
@@ -139,7 +139,7 @@ internal class Evaluator<P, I, M, D>
         /// The current build submission ID.
         /// </summary>
         private readonly int _submissionId;
-        
+
         private readonly EvaluationContext _evaluationContext;
 
         /// <summary>
@@ -647,7 +647,7 @@ private void Evaluate()
                 }
 
                 SetAllProjectsProperty();
-                
+
                 List<string> initialTargets = new List<string>(_initialTargetsList.Count);
                 foreach (var initialTarget in _initialTargetsList)
                 {
@@ -966,7 +966,7 @@ private void UpdateDefaultTargets(ProjectRootElement currentProjectOrImport)
                         string target = EscapingUtilities.UnescapeAll(temp[i].Trim());
                         if (target.Length > 0)
                         {
-                            _data.DefaultTargets = _data.DefaultTargets ?? new List<string>(temp.Count);
+                            _data.DefaultTargets ??= new List<string>(temp.Count);
                             _data.DefaultTargets.Add(target);
                         }
                     }
@@ -980,7 +980,7 @@ private void UpdateDefaultTargets(ProjectRootElement currentProjectOrImport)
         private void EvaluatePropertyGroupElement(ProjectPropertyGroupElement propertyGroupElement)
         {
             using (_evaluationProfiler.TrackElement(propertyGroupElement))
-            { 
+            {
                 if (EvaluateConditionCollectingConditionedProperties(propertyGroupElement, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties))
                 {
                     foreach (ProjectPropertyElement propertyElement in propertyGroupElement.Properties)
@@ -1135,7 +1135,7 @@ private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement,
         }
 
         /// <summary>
-        /// Set the built-in properties, most of which are read-only 
+        /// Set the built-in properties, most of which are read-only
         /// </summary>
         private ICollection<P> AddBuiltInProperties()
         {
@@ -1474,7 +1474,7 @@ private void EvaluateImportElement(string directoryOfImportingFile, ProjectImpor
                 foreach (ProjectRootElement importedProjectRootElement in importedProjectRootElements)
                 {
                     _data.RecordImport(importElement, importedProjectRootElement, importedProjectRootElement.Version, sdkResult);
-                    
+
                     PerformDepthFirstPass(importedProjectRootElement);
                 }
             }
@@ -1506,7 +1506,7 @@ private void EvaluateImportGroupElement(string directoryOfImportingFile, Project
         /// </summary>
         /// <remarks>
         /// We enter here in both the property and item passes, since Chooses can contain both.
-        /// However, we only evaluate the When conditions on the first pass, so we only pulse 
+        /// However, we only evaluate the When conditions on the first pass, so we only pulse
         /// those states on that pass. On the other pass, it's as if they're not there.
         /// </remarks>
         private void EvaluateChooseElement(ProjectChooseElement chooseElement)
@@ -1575,7 +1575,7 @@ private bool EvaluateWhenOrOtherwiseChildren(IEnumerable<ProjectElement> childre
         /// <summary>
         /// Expands and loads project imports.
         /// <remarks>
-        /// Imports may contain references to "projectImportSearchPaths" defined in the app.config 
+        /// Imports may contain references to "projectImportSearchPaths" defined in the app.config
         /// toolset section. If this is the case, this method will search for the imported project
         /// in those additional paths if the default fails.
         /// </remarks>
@@ -1642,7 +1642,7 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
             var pathsToSearch = new string[fallbackSearchPathMatch.SearchPaths.Count + 1];
             pathsToSearch[0] = prop?.EvaluatedValue;                       // The actual value of the property, with no fallbacks
             fallbackSearchPathMatch.SearchPaths.CopyTo(pathsToSearch, 1);  // The list of fallbacks, in order
-            
+
             string extensionPropertyRefAsString = fallbackSearchPathMatch.MsBuildPropertyFormat;
 
             _evaluationLoggingContext.LogComment(MessageImportance.Low, "SearchPathsForMSBuildExtensionsPath",
@@ -1951,7 +1951,7 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
         /// <summary>
         /// Load and parse the specified project import, which may have wildcards,
         /// into one or more ProjectRootElements.
-        /// Caches the parsed import into the provided collection, so future 
+        /// Caches the parsed import into the provided collection, so future
         /// requests can be satisfied without re-parsing it.
         /// </summary>
         private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(string directoryOfImportingFile, ProjectImportElement importElement, string unescapedExpression,
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 43f73fda702..7c0686853ca 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -580,7 +580,7 @@ private static void AddArgument(List<string> arguments, ReuseableStringBuilder a
             string argValue = OpportunisticIntern.InternableToString(argumentBuilder).Trim();
 
             // We support passing of null through the argument constant value null
-            if (String.Compare("null", argValue, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals("null", argValue, StringComparison.OrdinalIgnoreCase))
             {
                 arguments.Add(null);
             }
@@ -706,6 +706,7 @@ private static class MetadataExpander
             /// <param name="expression">The expression containing item metadata references</param>
             /// <param name="metadata"></param>
             /// <param name="options"></param>
+            /// <param name="elementLocation"></param>
             /// <returns>The string with item metadata expanded in-place, escaped.</returns>
             internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation)
             {
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index ce854e2339e..a4b4bb26288 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -386,7 +386,7 @@ private static void GetReferencedItemNamesAndMetadata(string expression, int sta
                     // well formed, so make sure the name's in the table
                     if ((whatToShredFor & ShredderOptions.ItemTypes) != 0)
                     {
-                        pair.Items = pair.Items ?? new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+                        pair.Items ??= new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
                         pair.Items.Add(name);
                     }
 
@@ -455,7 +455,7 @@ private static void GetReferencedItemNamesAndMetadata(string expression, int sta
 
                     if ((whatToShredFor & ShredderOptions.MetadataOutsideTransforms) != 0)
                     {
-                        pair.Metadata = pair.Metadata ?? new Dictionary<string, MetadataReference>(MSBuildNameIgnoreCaseComparer.Default);
+                        pair.Metadata ??= new Dictionary<string, MetadataReference>(MSBuildNameIgnoreCaseComparer.Default);
                         pair.Metadata[qualifiedMetadataName] = new MetadataReference(itemName, metadataName);
                     }
 
@@ -667,7 +667,7 @@ private static bool Sink(string expression, ref int i, int end, char c1, char c2
         {
             if (i < end - 1 && expression[i] == c1 && expression[i + 1] == c2)
             {
-                i = i + 2;
+                i += 2;
                 return true;
             }
 
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 79174f86b83..90ceb27ef60 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -223,7 +223,7 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
 
                         // See if this asks for a specific SDK
                         var m = RegistrySdkRegex.Value.Match(keyName);
-                        
+
                         if (m.Success && m.Groups.Count >= 1 && valueName.Equals("InstallRoot", StringComparison.OrdinalIgnoreCase))
                         {
                             return Path.Combine(NativeMethodsShared.FrameworkBasePath, m.Groups[0].Value) + Path.DirectorySeparatorChar;
@@ -311,6 +311,7 @@ internal static string MakeRelative(string basePath, string path)
         /// </summary>
         /// <param name="startingDirectory">The directory to start the search in.</param>
         /// <param name="fileName">The name of the file to search for.</param>
+        /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// <returns>The full path of the directory containing the file if it is found, otherwise an empty string. </returns>
         internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName, IFileSystem fileSystem)
         {
@@ -322,6 +323,7 @@ internal static string GetDirectoryNameOfFileAbove(string startingDirectory, str
         /// </summary>
         /// <param name="file">The name of the file to search for.</param>
         /// <param name="startingDirectory">An optional directory to start the search in.  The default location is the directory
+        /// <param name="fileSystem">The file system abstraction to use that implements file system operations</param>
         /// of the file containing the property function.</param>
         /// <returns>The full path of the file if it is found, otherwise an empty string.</returns>
         internal static string GetPathOfFileAbove(string file, string startingDirectory, IFileSystem fileSystem)
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 1027af72a64..165407a7f02 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -317,6 +317,7 @@ public bool MatchesItem(I item)
         /// </summary>
         /// <param name="item">The item to attempt to find a match for based on matching metadata</param>
         /// <param name="metadata">Names of metadata to look for matches for</param>
+        /// <param name="options">metadata option matching</param>
         /// <returns></returns>
         public bool MatchesItemOnMetadata(IItem item, IEnumerable<string> metadata, MatchOnMetadataOptions options)
         {
diff --git a/src/Build/Evaluation/Preprocessor.cs b/src/Build/Evaluation/Preprocessor.cs
index dedb60450d1..794e709cefb 100644
--- a/src/Build/Evaluation/Preprocessor.cs
+++ b/src/Build/Evaluation/Preprocessor.cs
@@ -16,7 +16,7 @@
 namespace Microsoft.Build.Evaluation
 {
     /// <summary>
-    /// Creates a view of an evaluated project's XML as if it had all been loaded from 
+    /// Creates a view of an evaluated project's XML as if it had all been loaded from
     /// a single file, instead of being assembled by pulling in imported files as it actually was.
     /// </summary>
     /// <remarks>
@@ -73,7 +73,7 @@ private Preprocessor(Project project)
         }
 
         /// <summary>
-        /// Returns an XmlDocument representing the evaluated project's XML as if it all had 
+        /// Returns an XmlDocument representing the evaluated project's XML as if it all had
         /// been loaded from a single file, instead of being assembled by pulling in imported files.
         /// </summary>
         internal static XmlDocument GetPreprocessedDocument(Project project)
@@ -193,7 +193,7 @@ private void AddImplicitImportNodes(XmlElement documentElement)
                     {
                         documentElement.InsertBefore(xmlElement, documentElement.FirstChild);
                     }
-                    
+
                     lastImplicitImportAdded = xmlElement;
                 }
                 else
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 5d9b15567be..0630cd6407b 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -38,6 +38,7 @@ internal class PropertyTrackingEvaluatorDataWrapper<P, I, M, D> : IEvaluatorData
         /// </summary>
         /// <param name="dataToWrap">The underlying <see cref="IEvaluatorData{P,I,M,D}"/> to wrap for property tracking.</param>
         /// <param name="evaluationLoggingContext">The <see cref="EvaluationLoggingContext"/> used to log relevant events.</param>
+        /// <param name="settingValue">Property tracking setting value</param>
         public PropertyTrackingEvaluatorDataWrapper(IEvaluatorData<P, I, M, D> dataToWrap, EvaluationLoggingContext evaluationLoggingContext, int settingValue)
         {
             ErrorUtilities.VerifyThrowInternalNull(dataToWrap, nameof(dataToWrap));
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index 1f07b22d429..b411f73aed9 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -146,7 +146,7 @@ private string NormalizeMatchInput(string stringToMatch)
             // Ensure trailing slash because the fixed directory part has a trailing slash.
             if (stringToMatch == string.Empty)
             {
-                normalizedInput = normalizedInput + Path.DirectorySeparatorChar;
+                normalizedInput += Path.DirectorySeparatorChar;
             }
 
             return normalizedInput;
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index f304a90ad46..a7f9ce4b7ae 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -177,7 +177,6 @@ public ProjectGraph(IEnumerable<string> entryProjectFiles, ProjectCollection pro
         ///     If a null reference is returned from <paramref name="projectInstanceFactory" />, the InnerException contains
         ///     <see cref="InvalidOperationException" />
         /// </exception>
-        /// </exception>
         public ProjectGraph(string entryProjectFile, ProjectCollection projectCollection, ProjectInstanceFactoryFunc projectInstanceFactory)
             : this(new ProjectGraphEntryPoint(entryProjectFile).AsEnumerable(), projectCollection, projectInstanceFactory)
         {
diff --git a/src/Build/Instance/HostServices.cs b/src/Build/Instance/HostServices.cs
index a6e3697450a..e970792b439 100644
--- a/src/Build/Instance/HostServices.cs
+++ b/src/Build/Instance/HostServices.cs
@@ -130,7 +130,7 @@ public void RegisterHostObject(string projectFile, string targetName, string tas
             bool isExplicit;
             bool hasExplicitOutOfProcAffinity = (GetNodeAffinity(projectFile, out isExplicit) == NodeAffinity.OutOfProc) && (isExplicit);
             ErrorUtilities.VerifyThrowInvalidOperation(!hasExplicitOutOfProcAffinity || hostObject == null, "InvalidHostObjectOnOutOfProcProject");
-            _hostObjectMap = _hostObjectMap ?? new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
+            _hostObjectMap ??= new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
 
             HostObjects hostObjects = GetHostObjectsFromMapByKeyOrCreateNew(projectFile);
 
@@ -148,6 +148,9 @@ public void RegisterHostObject(string projectFile, string targetName, string tas
         /// Register and unregister from ROT.
         /// Ensure the host object has appropriate COM interface that can be used in task.
         /// </summary>
+        /// <param name="projectFile">project file name</param>
+        /// <param name="targetName">target name</param>
+        /// <param name="taskName">task name</param>
         /// <param name="monikerName">the Moniker used to register host object in ROT</param>
         public void RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName)
         {
@@ -156,7 +159,7 @@ public void RegisterHostObject(string projectFile, string targetName, string tas
             ErrorUtilities.VerifyThrowArgumentNull(taskName, "taskName");
             ErrorUtilities.VerifyThrowArgumentNull(monikerName, "monikerName");
 
-            _hostObjectMap = _hostObjectMap ?? new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
+            _hostObjectMap ??= new Dictionary<string, HostObjects>(StringComparer.OrdinalIgnoreCase);
 
             HostObjects hostObjects = GetHostObjectsFromMapByKeyOrCreateNew(projectFile);
 
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 4021ae22c38..e4e7d589d3c 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -62,7 +62,7 @@ public enum ProjectInstanceSettings
     /// and call it several times to build it.
     /// </summary>
     /// <comments>
-    /// Neither this class nor none of its constituents are allowed to have 
+    /// Neither this class nor none of its constituents are allowed to have
     /// references to any of the Construction or Evaluation objects.
     /// This class is immutable except for adding instance items and setting instance properties.
     /// It only exposes items and properties: targets, host services, and the task registry are not exposed as they are only the concern of build.
@@ -100,7 +100,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         private PropertyDictionary<ProjectPropertyInstance> _globalProperties;
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable 
+        /// List of names of the properties that, while global, are still treated as overridable
         /// </summary>
         private ISet<string> _globalPropertiesToTreatAsLocal;
 
@@ -134,7 +134,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         /// The project's root directory, for evaluation of relative paths and
         /// setting the current directory during build.
         /// Is never null.
-        /// If the project has not been loaded from disk and has not been given a path, returns the current directory from 
+        /// If the project has not been loaded from disk and has not been given a path, returns the current directory from
         /// the time the project was loaded - this is the same behavior as Whidbey/Orcas.
         /// If the project has not been loaded from disk but has been given a path, this path may not exist.
         /// </summary>
@@ -158,7 +158,7 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
         private HostServices _hostServices;
 
         /// <summary>
-        /// Whether when we read a ToolsVersion that is not equivalent to the current one on the Project tag, we 
+        /// Whether when we read a ToolsVersion that is not equivalent to the current one on the Project tag, we
         /// treat it as the current one.
         /// </summary>
         private bool _usingDifferentToolsVersionFromProjectFile;
@@ -258,6 +258,7 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
         /// <param name="projectCollection">Project collection</param>
+        /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
         /// <returns>A new project instance</returns>
         private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
@@ -339,6 +340,7 @@ public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globa
         /// <param name="toolsVersion">The tools version.</param>
         /// <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
         /// <param name="projectCollection">Project collection</param>
+        /// <param name="projectLoadSettings">Project load settings</param>
         /// <param name="evaluationContext">The context to use for evaluation.</param>
         /// <returns>A new project instance</returns>
         private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
@@ -397,8 +399,8 @@ internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFro
         /// This is ideal if the project is simply going to be built, and not displayed or edited.
         /// Global properties may be null.
         /// Tools version may be null.
-        /// Used by SolutionProjectGenerator so that it can explicitly pass the vsVersionFromSolution in for use in 
-        /// determining the sub-toolset version. 
+        /// Used by SolutionProjectGenerator so that it can explicitly pass the vsVersionFromSolution in for use in
+        /// determining the sub-toolset version.
         /// </summary>
         /// <param name="xml">The project root element</param>
         /// <param name="globalProperties">The global properties to use.</param>
@@ -456,7 +458,7 @@ internal ProjectInstance(Evaluation.Project.Data data, string directory, string
             _directory = directory;
             _projectFileLocation = ElementLocation.Create(fullPath);
             _hostServices = hostServices;
-            
+
             EvaluationId = data.EvaluationId;
 
             var immutable = (settings & ProjectInstanceSettings.Immutable) == ProjectInstanceSettings.Immutable;
@@ -788,7 +790,7 @@ public List<ProjectItemElement> EvaluatedItemElements
 
         /// <summary>
         /// Serialize the entire project instance state.
-        /// 
+        ///
         /// When false, only a part of the project instance state is serialized (properties and items).
         /// In this case out of proc nodes re-evaluate the project instance from disk to obtain the un-serialized state.
         /// This partial state recombination may lead to build issues when the project instance state differs from what is on disk.
@@ -816,7 +818,7 @@ public bool TranslateEntireState
 
         /// <summary>
         /// The ID of the evaluation that produced this ProjectInstance.
-        /// 
+        ///
         /// See <see cref="Project.LastEvaluationId"/>.
         /// </summary>
         public int EvaluationId
@@ -918,7 +920,7 @@ public bool IsImmutable
         }
 
         /// <summary>
-        /// Task classes and locations known to this project. 
+        /// Task classes and locations known to this project.
         /// This is the project-specific task registry, which is consulted before
         /// the toolset's task registry.
         /// Only set during evaluation, so does not check for immutability.
@@ -943,7 +945,7 @@ Toolset IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMeta
 
         /// <summary>
         /// The sub-toolset version we should use during the build, used to determine which set of sub-toolset
-        /// properties we should merge into this toolset. 
+        /// properties we should merge into this toolset.
         /// </summary>
         string IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SubToolsetVersion
         {
@@ -982,7 +984,7 @@ PropertyDictionary<ProjectPropertyInstance> IEvaluatorData<ProjectPropertyInstan
         }
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable 
+        /// List of names of the properties that, while global, are still treated as overridable
         /// </summary>
         ISet<string> IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.GlobalPropertiesToTreatAsLocal
         {
@@ -1165,7 +1167,7 @@ internal bool ExplicitToolsVersionSpecified
 
         /// <summary>
         /// The sub-toolset version we should use during the build, used to determine which set of sub-toolset
-        /// properties we should merge into this toolset. 
+        /// properties we should merge into this toolset.
         /// </summary>
         internal string SubToolsetVersion
         {
@@ -1198,7 +1200,7 @@ internal ItemDictionary<ProjectItemInstance> ItemsToBuildWith
         }
 
         /// <summary>
-        /// Task classes and locations known to this project. 
+        /// Task classes and locations known to this project.
         /// This is the project-specific task registry, which is consulted before
         /// the toolset's task registry.
         /// </summary>
@@ -1212,7 +1214,7 @@ internal TaskRegistry TaskRegistry
         }
 
         /// <summary>
-        /// Number of targets in the project. 
+        /// Number of targets in the project.
         /// </summary>
         internal int TargetsCount
         {
@@ -1252,7 +1254,7 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinitionInstanc
         }
 
         /// <summary>
-        /// Gets the escaped value of the provided metadatum. 
+        /// Gets the escaped value of the provided metadatum.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectMetadataInstance metadatum)
         {
@@ -1262,7 +1264,7 @@ public static string GetMetadataValueEscaped(ProjectMetadataInstance metadatum)
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item.
         /// </summary>
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IItem is an internal interface; this is less confusing to outside customers. ")]
         public static string GetMetadataValueEscaped(ProjectItemInstance item, string name)
@@ -1273,7 +1275,7 @@ public static string GetMetadataValueEscaped(ProjectItemInstance item, string na
         }
 
         /// <summary>
-        /// Gets the escaped value of the metadatum with the provided name on the provided item definition. 
+        /// Gets the escaped value of the metadatum with the provided name on the provided item definition.
         /// </summary>
         public static string GetMetadataValueEscaped(ProjectItemDefinitionInstance item, string name)
         {
@@ -1361,7 +1363,7 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// <summary>
         /// Properties encountered during evaluation. These are read during the first evaluation pass.
         /// Unlike those returned by the Properties property, these are ordered, and include any properties that
-        /// were subsequently overridden by others with the same name. It does not include any 
+        /// were subsequently overridden by others with the same name. It does not include any
         /// properties whose conditions did not evaluate to true.
         /// </summary>
         /// <remarks>
@@ -1375,7 +1377,7 @@ void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadat
         /// <summary>
         /// Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
         /// Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
-        /// were subsequently overridden by others with the same name and item type. It does not include any 
+        /// were subsequently overridden by others with the same name and item type. It does not include any
         /// elements whose conditions did not evaluate to true.
         /// </summary>
         /// <remarks>
@@ -1503,7 +1505,7 @@ ProjectPropertyInstance IPropertyProvider<ProjectPropertyInstance>.GetProperty(s
         }
 
         /// <summary>
-        /// Get the value of a property in this project, or 
+        /// Get the value of a property in this project, or
         /// an empty string if it does not exist.
         /// </summary>
         /// <remarks>
@@ -1511,7 +1513,7 @@ ProjectPropertyInstance IPropertyProvider<ProjectPropertyInstance>.GetProperty(s
         /// at all are not distinguished between by this method.
         /// This is because the build does not distinguish between the two.
         /// The reason this method exists when users can simply do GetProperty(..).EvaluatedValue,
-        /// is that the caller would have to check for null every time. For properties, empty and undefined are 
+        /// is that the caller would have to check for null every time. For properties, empty and undefined are
         /// not distinguished, so it much more useful to also have a method that returns empty string in
         /// either case.
         /// This function returns the unescaped value.
@@ -1550,9 +1552,9 @@ public ProjectPropertyInstance SetProperty(string name, string evaluatedValue)
         /// in use by another ProjectInstance.
         /// </remarks>
         /// <comments>
-        /// For purposes of declaring the project that defined this item (for use with e.g. the 
-        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items 
-        /// like those added by this API. 
+        /// For purposes of declaring the project that defined this item (for use with e.g. the
+        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items
+        /// like those added by this API.
         /// </comments>
         public ProjectItemInstance AddItem(string itemType, string evaluatedInclude)
         {
@@ -1573,9 +1575,9 @@ public ProjectItemInstance AddItem(string itemType, string evaluatedInclude)
         /// in use by another ProjectInstance.
         /// </remarks>
         /// <comments>
-        /// For purposes of declaring the project that defined this item (for use with e.g. the 
-        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items 
-        /// like those added by this API. 
+        /// For purposes of declaring the project that defined this item (for use with e.g. the
+        /// DeclaringProject* metadata), the entrypoint project is used for synthesized items
+        /// like those added by this API.
         /// </comments>
         public ProjectItemInstance AddItem(string itemType, string evaluatedInclude, IEnumerable<KeyValuePair<string, string>> metadata)
         {
@@ -2436,8 +2438,8 @@ int submissionId
         }
 
         /// <summary>
-        /// Spawn the old engine to generate a solution wrapper project, so that our build ordering is somewhat more correct 
-        /// when solutions with toolsVersions &lt; 4.0 are passed to us. 
+        /// Spawn the old engine to generate a solution wrapper project, so that our build ordering is somewhat more correct
+        /// when solutions with toolsVersions &lt; 4.0 are passed to us.
         /// </summary>
         /// <comment>
         /// #############################################################################################
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 3d502f86f0e..0a9d9856515 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -35,7 +35,6 @@ public class ProjectItemDefinitionInstance : IKeyed, IMetadataTable, IItemDefini
         /// <summary>
         /// Constructs an empty project item definition instance.
         /// </summary>
-        /// <param name="projectInstance">The project instance to which this item definition belongs.</param>
         /// <param name="itemType">The type of item this definition object represents.</param>
         internal ProjectItemDefinitionInstance(string itemType)
         {
@@ -127,7 +126,7 @@ public IEnumerable<string> MetadataNames
         }
 
         /// <summary>
-        /// Implementation of IKeyed exposing the item type, so these 
+        /// Implementation of IKeyed exposing the item type, so these
         /// can be put in a dictionary conveniently.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -198,7 +197,7 @@ string IMetadataTable.GetEscapedValueIfPresent(string specifiedItemType, string
         ProjectMetadataInstance IItemDefinition<ProjectMetadataInstance>.SetMetadata(ProjectMetadataElement xml, string evaluatedValue, ProjectMetadataInstance predecessor)
         {
             // No mutability check as this is used during creation (evaluation)
-            _metadata = _metadata ?? new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+            _metadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
 
             ProjectMetadataInstance metadatum = new ProjectMetadataInstance(xml.Name, evaluatedValue);
             _metadata[xml.Name] = metadatum;
diff --git a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
index e04e915f2bb..17b6caf7a06 100644
--- a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
@@ -50,6 +50,7 @@ public class ProjectItemGroupTaskItemInstance: ITranslatable
         /// </summary>
         private string _matchOnMetadataOptions;
 
+        /// <summary>
         /// The list of metadata to keep.
         /// </summary>
         private string _keepMetadata;
@@ -196,6 +197,7 @@ List<ProjectItemGroupTaskMetadataInstance> metadata
 
         private ProjectItemGroupTaskItemInstance()
         {
+
         }
 
         /// <summary>
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index bdda0096b5f..0087b90ad60 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -52,7 +52,7 @@ public class ProjectItemInstance : IKeyed, IItem<ProjectMetadataInstance>, ITask
         /// <summary>
         /// Constructor for items with no metadata.
         /// Include may be empty.
-        /// Called before the build when virtual items are added, 
+        /// Called before the build when virtual items are added,
         /// and during the build when tasks emit items.
         /// Mutability follows the project.
         /// </summary>
@@ -64,7 +64,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         /// <summary>
         /// Constructor for items with no metadata.
         /// Include may be empty.
-        /// Called before the build when virtual items are added, 
+        /// Called before the build when virtual items are added,
         /// and during the build when tasks emit items.
         /// Mutability follows the project.
         /// </summary>
@@ -75,7 +75,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
 
         /// <summary>
         /// Constructor for items with metadata.
-        /// Called before the build when virtual items are added, 
+        /// Called before the build when virtual items are added,
         /// and during the build when tasks emit items.
         /// Include may be empty.
         /// Direct metadata may be null, indicating no metadata. It will be cloned.
@@ -159,7 +159,7 @@ public ProjectInstance Project
         /// Item type, for example "Compile"
         /// </summary>
         /// <remarks>
-        /// This cannot be set, as it is used as the key into 
+        /// This cannot be set, as it is used as the key into
         /// the project's items table.
         /// </remarks>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
@@ -339,7 +339,7 @@ internal string ProjectFullPath
 
         /// <summary>
         /// Get any metadata in the item that has the specified name,
-        /// otherwise returns null. 
+        /// otherwise returns null.
         /// Includes any metadata inherited from item definitions.
         /// Includes any built-in metadata.
         /// </summary>
@@ -349,7 +349,7 @@ public ProjectMetadataInstance GetMetadata(string name)
         }
 
         /// <summary>
-        /// Get the value of a metadata on this item, or 
+        /// Get the value of a metadata on this item, or
         /// String.Empty if it does not exist or has no value.
         /// Includes any metadata inherited from item definitions and any built-in metadata.
         /// To determine whether a piece of metadata is actually present
@@ -416,7 +416,7 @@ public override string ToString()
         }
 
         /// <summary>
-        /// Get the value of a metadata on this item, or 
+        /// Get the value of a metadata on this item, or
         /// String.Empty if it does not exist or has no value.
         /// Includes any metadata inherited from item definitions and any built-in metadata.
         /// To determine whether a piece of metadata is actually present
@@ -466,7 +466,7 @@ string ITaskItem2.GetMetadataValueEscaped(string name)
         /// ITaskItem implementation
         /// </summary>
         /// <comments>
-        /// MetadataValue is assumed to be in its escaped form. 
+        /// MetadataValue is assumed to be in its escaped form.
         /// </comments>
         void ITaskItem.SetMetadata(string metadataName, string metadataValue)
         {
@@ -477,7 +477,7 @@ void ITaskItem.SetMetadata(string metadataName, string metadataValue)
         /// ITaskItem2 implementation
         /// </summary>
         /// <comments>
-        /// Assumes metadataValue is unescaped. 
+        /// Assumes metadataValue is unescaped.
         /// </comments>
         void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue)
         {
@@ -627,7 +627,7 @@ internal void SetMetadata(CopyOnWritePropertyDictionary<ProjectMetadataInstance>
         }
 
         /// <summary>
-        /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir. 
+        /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir.
         /// This is not normally legal to set outside of evaluation. However, the CreateItem
         /// needs to be able to set it as a task output, because it supports wildcards. So as a special exception we allow
         /// tasks to set this particular metadata as a task output.
@@ -699,7 +699,7 @@ private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUs
             ProjectItemDefinitionInstance itemDefinition;
             if (projectToUse.ItemDefinitions.TryGetValue(itemTypeToUse, out itemDefinition))
             {
-                inheritedItemDefinitions = inheritedItemDefinitions ?? new List<ProjectItemDefinitionInstance>();
+                inheritedItemDefinitions ??= new List<ProjectItemDefinitionInstance>();
                 inheritedItemDefinitions.Add(itemDefinition);
             }
 
@@ -717,7 +717,7 @@ private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUs
         }
 
         /// <summary>
-        /// An item without an item type. Cast to an ITaskItem, this is 
+        /// An item without an item type. Cast to an ITaskItem, this is
         /// what is given to tasks. It is also used for target outputs.
         /// </summary>
         internal sealed class TaskItem :
@@ -863,9 +863,9 @@ private TaskItem(ITranslator translator, LookasideStringInterner interner)
             /// Gets or sets the unescaped include, or "name", for the item.
             /// </summary>
             /// <comments>
-            /// This one is a bit tricky.  Orcas assumed that the value being set was escaped, but 
+            /// This one is a bit tricky.  Orcas assumed that the value being set was escaped, but
             /// that the value being returned was unescaped.  Maintain that behaviour here.  To get
-            /// the escaped value, use ITaskItem2.EvaluatedIncludeEscaped. 
+            /// the escaped value, use ITaskItem2.EvaluatedIncludeEscaped.
             /// </comments>
             public string ItemSpec
             {
@@ -1278,7 +1278,7 @@ public string GetMetadataEscaped(string metadataName)
             /// ITaskItem implementation which sets metadata.
             /// </summary>
             /// <comments>
-            /// The value is assumed to be escaped. 
+            /// The value is assumed to be escaped.
             /// </comments>
             public void SetMetadata(string metadataName, string metadataValueEscaped)
             {
@@ -1288,7 +1288,7 @@ public void SetMetadata(string metadataName, string metadataValueEscaped)
             }
 
             /// <summary>
-            /// ITaskItem2 implementation which sets the literal value of metadata -- it is escaped 
+            /// ITaskItem2 implementation which sets the literal value of metadata -- it is escaped
             /// internally as necessary.
             /// </summary>
             void ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue)
@@ -1325,14 +1325,14 @@ public void CopyMetadataTo(ITaskItem destinationItem)
             /// Copies direct and item definition metadata.
             /// Does not copy built-in metadata, and will not overwrite existing, non-empty metadata.
             /// If the destination implements ITaskItem2, this avoids losing the escaped nature of values.
-            /// 
+            ///
             /// When copying metadata to a task item which can be accessed from a task (Utilities task item)
             /// this method will merge and expand any metadata originating with item definitions.
             /// </summary>
             /// <param name="destinationItem">destination item to copy the metadata from this to</param>
-            /// <param name="addOriginalItemSpec">Whether the OriginalItemSpec should be added as a piece 
-            /// of magic metadata. For copying of items this is useful but for cloning of items this adds 
-            /// additional metadata which is not useful because the OriginalItemSpec will always be identical 
+            /// <param name="addOriginalItemSpec">Whether the OriginalItemSpec should be added as a piece
+            /// of magic metadata. For copying of items this is useful but for cloning of items this adds
+            /// additional metadata which is not useful because the OriginalItemSpec will always be identical
             /// to the ItemSpec, and the addition will and will cause copy-on-write to trigger.
             /// </param>
             public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
@@ -1413,7 +1413,7 @@ public IDictionary CloneCustomMetadata()
 
             /// <summary>
             /// ITaskItem2 implementation which returns a clone of the metadata on this object.
-            /// Values returned are in their original escaped form. 
+            /// Values returned are in their original escaped form.
             /// </summary>
             /// <returns>The cloned metadata.</returns>
             IDictionary ITaskItem2.CloneCustomMetadataEscaped()
@@ -1691,7 +1691,7 @@ internal ProjectMetadataInstance SetMetadataObject(string name, string metadataV
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
-                _directMetadata = _directMetadata ?? new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
                 ProjectMetadataInstance metadatum = new ProjectMetadataInstance(name, metadataValueEscaped, allowItemSpecModifiers /* may not be built-in metadata name */);
                 _directMetadata.Set(metadatum);
 
@@ -1699,7 +1699,7 @@ internal ProjectMetadataInstance SetMetadataObject(string name, string metadataV
             }
 
             /// <summary>
-            /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir. 
+            /// Sets metadata where one built-in metadata is allowed to be set: RecursiveDir.
             /// This is not normally legal to set outside of evaluation. However, the CreateItem
             /// needs to be able to set it as a task output, because it supports wildcards. So as a special exception we allow
             /// tasks to set this particular metadata as a task output.
@@ -1713,7 +1713,7 @@ internal void SetMetadataOnTaskOutput(string name, string evaluatedValueEscaped)
 
                 if (!FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(name))
                 {
-                    _directMetadata = _directMetadata ?? new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                    _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
                     ProjectMetadataInstance metadatum = new ProjectMetadataInstance(name, evaluatedValueEscaped, true /* may be built-in metadata name */);
                     _directMetadata.Set(metadatum);
                 }
@@ -1915,14 +1915,14 @@ private ProjectItemInstance CreateItem(string includeEscaped, string includeBefo
                     List<ProjectItemDefinitionInstance> itemDefinitionsClone = null;
                     if (source._taskItem._itemDefinitions != null)
                     {
-                        itemDefinitionsClone = itemDefinitionsClone ?? new List<ProjectItemDefinitionInstance>(source._taskItem._itemDefinitions.Count + 1);
+                        itemDefinitionsClone ??= new List<ProjectItemDefinitionInstance>(source._taskItem._itemDefinitions.Count + 1);
                         itemDefinitionsClone.AddRange(source._taskItem._itemDefinitions);
                     }
 
                     ProjectItemDefinitionInstance sourceItemDefinition;
                     if (_project.ItemDefinitions.TryGetValue(source.ItemType, out sourceItemDefinition))
                     {
-                        itemDefinitionsClone = itemDefinitionsClone ?? new List<ProjectItemDefinitionInstance>();
+                        itemDefinitionsClone ??= new List<ProjectItemDefinitionInstance>();
                         itemDefinitionsClone.Add(sourceItemDefinition);
                     }
 
@@ -2057,7 +2057,7 @@ public void SetMetadata(IEnumerable<Pair<ProjectMetadataElement, string>> metada
             /// <summary>
             /// Implementation of IMetadataTable that can be passed to expander to expose only built-in metadata on this item.
             /// Built-in metadata is stored in a separate table so it can be cleared out when the item is renamed, as this invalidates the values.
-            /// Also, more importantly, because typically the same regular metadata values can be shared by many items, 
+            /// Also, more importantly, because typically the same regular metadata values can be shared by many items,
             /// and keeping item-specific metadata out of it could allow it to be implemented as a copy-on-write table.
             /// </summary>
             private class BuiltInMetadataTable : IMetadataTable
diff --git a/src/Build/Instance/ProjectTargetInstance.cs b/src/Build/Instance/ProjectTargetInstance.cs
index 74b7b03ef1c..e4dae8e9f8d 100644
--- a/src/Build/Instance/ProjectTargetInstance.cs
+++ b/src/Build/Instance/ProjectTargetInstance.cs
@@ -28,7 +28,7 @@ public sealed class ProjectTargetInstance : IImmutable, IKeyed, ITranslatable
         private string _name;
 
         /// <summary>
-        /// Condition on the target. 
+        /// Condition on the target.
         /// Evaluated during the build.
         /// </summary>
         private string _condition;
@@ -44,7 +44,7 @@ public sealed class ProjectTargetInstance : IImmutable, IKeyed, ITranslatable
         private string _outputs;
 
         /// <summary>
-        /// Return values on the target. 
+        /// Return values on the target.
         /// </summary>
         private string _returns;
 
@@ -76,8 +76,8 @@ public sealed class ProjectTargetInstance : IImmutable, IKeyed, ITranslatable
         /// <summary>
         /// Whether the project file that this target lives in has at least one target
         /// with a Returns attribute on it.  If so, the default behaviour for all targets
-        /// in the file without Returns attributes changes from returning the Outputs, to 
-        /// returning nothing. 
+        /// in the file without Returns attributes changes from returning the Outputs, to
+        /// returning nothing.
         /// </summary>
         private bool _parentProjectSupportsReturnsAttribute;
 
@@ -338,7 +338,7 @@ public ICollection<ProjectTaskInstance> Tasks
 
         /// <summary>
         /// Full path to the file from which this target originated.
-        /// If it originated in a project that was not loaded and has never been 
+        /// If it originated in a project that was not loaded and has never been
         /// given a path, returns an empty string.
         /// </summary>
         public string FullPath
@@ -450,8 +450,8 @@ string IKeyed.Key
         /// <summary>
         /// Whether the project file that this target lives in has at least one target
         /// with a Returns attribute on it.  If so, the default behaviour for all targets
-        /// in the file without Returns attributes changes from returning the Outputs, to 
-        /// returning nothing. 
+        /// in the file without Returns attributes changes from returning the Outputs, to
+        /// returning nothing.
         /// </summary>
         internal bool ParentProjectSupportsReturnsAttribute
         {
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index a2e1a5573b1..7261c567bcc 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -353,7 +353,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
             {
                 ErrorUtilities.VerifyThrowInternalNull(buildComponentHost, "buildComponentHost");
 
-                mergedParameters = mergedParameters ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                mergedParameters ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
                 string runtime = null;
                 string architecture = null;
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 072b94052e9..36aeda216b7 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -206,7 +206,7 @@ public object GetPropertyValue(TaskPropertyInfo property)
 
                 // If we returned an exception, then we want to throw it when we 
                 // do the get.  
-                if (value != null && (value as Exception) != null)
+                if (value is Exception)
                 {
                     throw (Exception)value;
                 }
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 54a1f7832e1..25a0ca80c70 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -69,11 +69,11 @@ public TaskFactoryLoggingHost(bool isRunningWithMultipleNodes, ElementLocation e
 
         /// <summary>
         /// Returns true in the multiproc case
-        /// REVIEW: Should this mean the same thing in the distributed build case?  If we have 
+        /// REVIEW: Should this mean the same thing in the distributed build case?  If we have
         /// a build which happens to be on a distributed cluster, but the build manager has only
         /// alotted a single machine to this build, is this true?  Because the build manager
         /// could later decide to add more nodes to this build.
-        /// UNDONE: This means we are building with multiple processes. If we are building on 
+        /// UNDONE: This means we are building with multiple processes. If we are building on
         /// one machine then I think the maxcpu-count is still 1. In my mind this means multiple nodes either distributed or on the same machine.
         /// </summary>
         public bool IsRunningMultipleNodes
@@ -247,7 +247,7 @@ public bool BuildProjectFile(string projectFileName, string[] targetNames, Syste
 
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// </summary>
         /// <returns>The lease object to control this object's lifetime.</returns>
diff --git a/src/Build/Instance/TaskFactoryWrapper.cs b/src/Build/Instance/TaskFactoryWrapper.cs
index b58f1a138cb..18660b24857 100644
--- a/src/Build/Instance/TaskFactoryWrapper.cs
+++ b/src/Build/Instance/TaskFactoryWrapper.cs
@@ -305,11 +305,11 @@ private void PopulatePropertyInfoCacheIfNecessary()
                     }
                 }
 
-                _propertyInfoCache = _propertyInfoCache ?? ReadOnlyEmptyDictionary<string, TaskPropertyInfo>.Instance;
+                _propertyInfoCache ??= ReadOnlyEmptyDictionary<string, TaskPropertyInfo>.Instance;
 
-                _namesOfPropertiesWithRequiredAttribute = _namesOfPropertiesWithRequiredAttribute ?? ReadOnlyEmptyDictionary<string, string>.Instance;
-                _namesOfPropertiesWithOutputAttribute = _namesOfPropertiesWithOutputAttribute ?? ReadOnlyEmptyDictionary<string, string>.Instance;
-                _namesOfPropertiesWithAmbiguousMatches = _namesOfPropertiesWithAmbiguousMatches ?? ReadOnlyEmptyDictionary<string, string>.Instance;
+                _namesOfPropertiesWithRequiredAttribute ??= ReadOnlyEmptyDictionary<string, string>.Instance;
+                _namesOfPropertiesWithOutputAttribute ??= ReadOnlyEmptyDictionary<string, string>.Instance;
+                _namesOfPropertiesWithAmbiguousMatches ??= ReadOnlyEmptyDictionary<string, string>.Instance;
             }
         }
         #endregion
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index fbdec9606fb..d7f07267381 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -37,7 +37,7 @@ namespace Microsoft.Build.Execution
     /// <example>
     /// &lt;UsingTask TaskName="Microsoft.Build.Tasks.Csc"                     ==> look for the "Csc" task in the
     ///            AssemblyName="Microsoft.Build.Tasks"/&gt;                       weakly-named "Microsoft.Build.Tasks" assembly
-    /// 
+    ///
     /// &lt;UsingTask TaskName="t1"                                            ==> look for the "t1" task in the
     ///            AssemblyName="mytasks, Culture=en, Version=1.0.0.0"/&gt;        strongly-named "mytasks" assembly
     ///
@@ -58,64 +58,64 @@ internal sealed class TaskRegistry : ITranslatable
         /// <summary>
         /// If true, we will force all tasks to run in the MSBuild task host EXCEPT
         /// a small well-known set of tasks that are known to depend on IBuildEngine
-        /// callbacks; as forcing those out of proc would be just setting them up for 
-        /// known failure.  
+        /// callbacks; as forcing those out of proc would be just setting them up for
+        /// known failure.
         /// </summary>
         private static bool s_forceTaskHostLaunch = (Environment.GetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC") == "1");
 
         /// <summary>
-        /// Simple name for the MSBuild tasks (v4), used for shimming in loading 
+        /// Simple name for the MSBuild tasks (v4), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV4SimpleName = "Microsoft.Build.Tasks.v4.0";
 
         /// <summary>
-        /// Filename for the MSBuild tasks (v4), used for shimming in loading 
+        /// Filename for the MSBuild tasks (v4), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV4Filename = s_tasksV4SimpleName + ".dll";
 
         /// <summary>
-        /// Expected location that MSBuild tasks (v4) is picked up from if the user 
-        /// references it with just a simple name, used for shimming in loading 
+        /// Expected location that MSBuild tasks (v4) is picked up from if the user
+        /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_potentialTasksV4Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV4Filename);
 
         /// <summary>
-        /// Simple name for the MSBuild tasks (v12), used for shimming in loading 
+        /// Simple name for the MSBuild tasks (v12), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV12SimpleName = "Microsoft.Build.Tasks.v12.0";
 
         /// <summary>
-        /// Filename for the MSBuild tasks (v12), used for shimming in loading 
+        /// Filename for the MSBuild tasks (v12), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksV12Filename = s_tasksV12SimpleName + ".dll";
 
         /// <summary>
-        /// Expected location that MSBuild tasks (v12) is picked up from if the user 
-        /// references it with just a simple name, used for shimming in loading 
+        /// Expected location that MSBuild tasks (v12) is picked up from if the user
+        /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_potentialTasksV12Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV12Filename);
 
         /// <summary>
-        /// Simple name for the MSBuild tasks (v14+), used for shimming in loading 
+        /// Simple name for the MSBuild tasks (v14+), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksCoreSimpleName = "Microsoft.Build.Tasks.Core";
 
         /// <summary>
-        /// Filename for the MSBuild tasks (v14+), used for shimming in loading 
+        /// Filename for the MSBuild tasks (v14+), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_tasksCoreFilename = s_tasksCoreSimpleName + ".dll";
 
         /// <summary>
-        /// Expected location that MSBuild tasks (v14+) is picked up from if the user 
-        /// references it with just a simple name, used for shimming in loading 
+        /// Expected location that MSBuild tasks (v14+) is picked up from if the user
+        /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
         private static string s_potentialTasksCoreLocation = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksCoreFilename);
@@ -129,7 +129,7 @@ internal sealed class TaskRegistry : ITranslatable
         /// <summary>
         /// Cache of tasks already found using fuzzy matching,
         /// keyed by the task name requested.
-        /// Value is a dictionary of all possible matches for that 
+        /// Value is a dictionary of all possible matches for that
         /// task name, by unique identity.
         /// </summary>
         private Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>> _cachedTaskRecordsWithFuzzyMatch;
@@ -163,7 +163,7 @@ private TaskRegistry()
         }
 
         /// <summary>
-        /// Creates a task registry that defers to the specified toolset's registry for those tasks it cannot resolve.        
+        /// Creates a task registry that defers to the specified toolset's registry for those tasks it cannot resolve.
         /// UNDONE: (Logging.) We can't pass the base task registry from the Toolset because we can't call GetTaskRegistry
         /// without logging context information.  When the Project load code is altered to contain logging service
         /// references, we can load the toolset task registry at the time this registry is created and pass it to
@@ -447,7 +447,7 @@ ElementLocation elementLocation
         /// </summary>
         /// <param name="taskName">The name of the task to retrieve.</param>
         /// <param name="taskProjectFile">The task's project file.</param>
-        /// <param name="taskIdentityParameters">The set of task identity parameters to be used to identify the 
+        /// <param name="taskIdentityParameters">The set of task identity parameters to be used to identify the
         /// correct task record match.</param>
         /// <param name="exactMatchRequired">True if an exact name match is required.</param>
         /// <param name="targetLoggingContext">The logging context.</param>
@@ -552,12 +552,12 @@ out bool retrievedFromCache
             // Cache the result, even if it is null.  We should never again do the work we just did, for this task name.
             if (exactMatchRequired)
             {
-                _cachedTaskRecordsWithExactMatch = _cachedTaskRecordsWithExactMatch ?? new Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
+                _cachedTaskRecordsWithExactMatch ??= new Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>(RegisteredTaskIdentity.RegisteredTaskIdentityComparer.Exact);
                 _cachedTaskRecordsWithExactMatch[taskIdentity] = taskRecord;
             }
             else
             {
-                _cachedTaskRecordsWithFuzzyMatch = _cachedTaskRecordsWithFuzzyMatch ?? new Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>>(StringComparer.OrdinalIgnoreCase);
+                _cachedTaskRecordsWithFuzzyMatch ??= new Dictionary<string, Dictionary<RegisteredTaskIdentity, RegisteredTaskRecord>>(StringComparer.OrdinalIgnoreCase);
 
                 // Since this is a fuzzy match, we could conceivably have several sets of task identity parameters that match
                 // each other ... but might be mutually exclusive themselves.  E.g. CLR4|x86 and CLR2|x64 both match *|*.  
@@ -634,7 +634,7 @@ private Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> GetReleva
         }
 
         /// <summary>
-        /// Registers an evaluated using task tag for future 
+        /// Registers an evaluated using task tag for future
         /// consultation
         /// </summary>
         private void RegisterTask(string taskName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, Dictionary<string, string> taskFactoryParameters, RegisteredTaskRecord.ParameterGroupAndTaskElementRecord inlineTaskRecord)
@@ -669,7 +669,7 @@ private static Dictionary<RegisteredTaskIdentity, List<RegisteredTaskRecord>> Cr
         }
 
         /// <summary>
-        /// Given a task name and a list of records which may contain the task, this helper method will ask the records to see if the task name 
+        /// Given a task name and a list of records which may contain the task, this helper method will ask the records to see if the task name
         /// can be created by the factories which are wrapped by the records. (this is done by instantiating the task factory and asking it).
         /// </summary>
         private RegisteredTaskRecord GetMatchingRegistration
@@ -695,7 +695,7 @@ ElementLocation elementLocation
         }
 
         /// <summary>
-        /// An object representing the identity of a task -- not just task name, but also 
+        /// An object representing the identity of a task -- not just task name, but also
         /// the set of identity parameters
         /// </summary>
         [DebuggerDisplay("{Name} ParameterCount = {TaskIdentityParameters.Count}")]
@@ -753,7 +753,7 @@ public IDictionary<string, string> TaskIdentityParameters
             }
 
             /// <summary>
-            /// Comparer used to figure out whether two RegisteredTaskIdentities are equal or not. 
+            /// Comparer used to figure out whether two RegisteredTaskIdentities are equal or not.
             /// </summary>
             internal class RegisteredTaskIdentityComparer : IEqualityComparer<RegisteredTaskIdentity>
             {
@@ -763,8 +763,8 @@ internal class RegisteredTaskIdentityComparer : IEqualityComparer<RegisteredTask
                 private static RegisteredTaskIdentityComparer s_exact = new RegisteredTaskIdentityComparer(true /* exact match */);
 
                 /// <summary>
-                /// The singleton comparer to use when a fuzzy match is desired.  Note that this still does an exact match on the 
-                /// name, but does a fuzzy match on the task identity parameters. 
+                /// The singleton comparer to use when a fuzzy match is desired.  Note that this still does an exact match on the
+                /// name, but does a fuzzy match on the task identity parameters.
                 /// </summary>
                 private static RegisteredTaskIdentityComparer s_fuzzy = new RegisteredTaskIdentityComparer(false /* fuzzy match */);
 
@@ -782,7 +782,7 @@ private RegisteredTaskIdentityComparer(bool exactMatchRequired)
                 }
 
                 /// <summary>
-                /// The singleton comparer to use for when an exact match is desired 
+                /// The singleton comparer to use for when an exact match is desired
                 /// </summary>
                 public static RegisteredTaskIdentityComparer Exact
                 {
@@ -790,7 +790,7 @@ public static RegisteredTaskIdentityComparer Exact
                 }
 
                 /// <summary>
-                /// The singleton comparer to use for when a fuzzy match is desired 
+                /// The singleton comparer to use for when a fuzzy match is desired
                 /// </summary>
                 public static RegisteredTaskIdentityComparer Fuzzy
                 {
@@ -798,9 +798,9 @@ public static RegisteredTaskIdentityComparer Fuzzy
                 }
 
                 /// <summary>
-                /// Returns true if these two identities match "fuzzily" -- if the names pass a partial type name 
-                /// match and the task identity parameters would constitute a valid merge (e.g. "don't care" and 
-                /// something explicit).  Otherwise returns false. 
+                /// Returns true if these two identities match "fuzzily" -- if the names pass a partial type name
+                /// match and the task identity parameters would constitute a valid merge (e.g. "don't care" and
+                /// something explicit).  Otherwise returns false.
                 /// </summary>
                 public static bool IsPartialMatch(RegisteredTaskIdentity x, RegisteredTaskIdentity y)
                 {
@@ -815,7 +815,7 @@ public static bool IsPartialMatch(RegisteredTaskIdentity x, RegisteredTaskIdenti
                 }
 
                 /// <summary>
-                /// Returns true if the two task identities are equal; false otherwise. 
+                /// Returns true if the two task identities are equal; false otherwise.
                 /// </summary>
                 public bool Equals(RegisteredTaskIdentity x, RegisteredTaskIdentity y)
                 {
@@ -888,8 +888,8 @@ public int GetHashCode(RegisteredTaskIdentity obj)
 
                 /// <summary>
                 /// Returns true if the two dictionaries representing sets of task identity parameters match; false otherwise.
-                /// Internal so that RegisteredTaskRecord can use this function in its determination of whether the task factory 
-                /// supports a certain task identity.  
+                /// Internal so that RegisteredTaskRecord can use this function in its determination of whether the task factory
+                /// supports a certain task identity.
                 /// </summary>
                 private static bool IdentityParametersMatch(IDictionary<string, string> x, IDictionary<string, string> y, bool exactMatchRequired)
                 {
@@ -996,13 +996,13 @@ internal class RegisteredTaskRecord : ITranslatable
 
             /// <summary>
             /// Task factory used to create CodeDom-based inline tasks.  Special-cased as one of two officially
-            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue. 
+            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue.
             /// </summary>
             internal const string CodeTaskFactory = "CodeTaskFactory";
 
             /// <summary>
             /// Task factory used to create CodeDom-based inline tasks.  Special-cased as one of two officially
-            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue. 
+            /// supported task factories in Microsoft.Build.Tasks.vX.Y.dll to deal with versioning issue.
             /// </summary>
             internal const string XamlTaskFactory = "XamlTaskFactory";
 
@@ -1055,14 +1055,14 @@ internal class RegisteredTaskRecord : ITranslatable
             private TaskFactoryWrapper _taskFactoryWrapperInstance;
 
             /// <summary>
-            /// Cache of task names which can be created by the factory. 
-            /// When ever a taskName is checked against the factory we cache the result so we do not have to 
+            /// Cache of task names which can be created by the factory.
+            /// When ever a taskName is checked against the factory we cache the result so we do not have to
             /// make possibly expensive calls over and over again.
             /// </summary>
             private Dictionary<RegisteredTaskIdentity, object> _taskNamesCreatableByFactory;
 
             /// <summary>
-            /// Set of parameters that can be used by the task factory specifically.  
+            /// Set of parameters that can be used by the task factory specifically.
             /// </summary>
             private Dictionary<string, string> _taskFactoryParameters;
 
@@ -1158,14 +1158,14 @@ internal ParameterGroupAndTaskElementRecord ParameterGroupAndTaskBody
             }
 
             /// <summary>
-            /// Identity of this task. 
+            /// Identity of this task.
             /// </summary>
             internal RegisteredTaskIdentity TaskIdentity => _taskIdentity;
 
             /// <summary>
-            /// Ask the question, whether or not the task name can be created by the task factory. 
-            /// To answer this question we need to instantiate and initialize the task factory and ask it if it can create the given task name. 
-            /// This question is useful for assembly tasks where the task may or may not be in an assembly, this can also be useful if the task factory 
+            /// Ask the question, whether or not the task name can be created by the task factory.
+            /// To answer this question we need to instantiate and initialize the task factory and ask it if it can create the given task name.
+            /// This question is useful for assembly tasks where the task may or may not be in an assembly, this can also be useful if the task factory
             /// loads an external file and uses that to generate the tasks.
             /// </summary>
             /// <returns>true if the task can be created by the factory, false if it cannot be created</returns>
@@ -1261,7 +1261,7 @@ internal bool CanTaskBeCreatedByFactory(string taskName, string taskProjectFile,
             }
 
             /// <summary>
-            /// Given a Registered task record and a task name. Check create an instance of the task factory using the record. 
+            /// Given a Registered task record and a task name. Check create an instance of the task factory using the record.
             /// If the factory is a assembly task factory see if the assemblyFile has the correct task inside of it.
             /// </summary>
             internal TaskFactoryWrapper GetTaskFactoryFromRegistrationRecord(string taskName, string taskProjectFile, IDictionary<string, string> taskIdentityParameters, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation)
@@ -1603,7 +1603,7 @@ private void ParseUsingTaskParameterGroupElement<P, I>(UsingTaskParameterGroupEl
                     where P : class, IProperty
                     where I : class, IItem
                 {
-                    _usingTaskParameters = _usingTaskParameters ?? new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
+                    _usingTaskParameters ??= new Dictionary<string, TaskPropertyInfo>(StringComparer.OrdinalIgnoreCase);
 
                     // Go through each of the parameters and create new ParameterInfo objects from them
                     foreach (ProjectUsingTaskParameterElement parameter in usingTaskParameterGroup.Parameters)
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 4bb3379dfcf..16979041d22 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -64,7 +64,7 @@ internal static ConsoleColor BackgroundColor
 
         /// <summary>
         /// Gets or sets the number of MSBuild processes participating in the build. If greater than 1,
-        /// include the node ID 
+        /// include the node ID
         /// </summary>
         public int NumberOfProcessors { get; set; } = 1;
 
@@ -113,7 +113,7 @@ public void ParseParameters()
         }
 
         /// <summary>
-        /// An implementation of IComparer useful for comparing the keys 
+        /// An implementation of IComparer useful for comparing the keys
         /// on DictionaryEntry's
         /// </summary>
         /// <remarks>Uses CurrentCulture for display purposes</remarks>
@@ -126,7 +126,7 @@ public int Compare(DictionaryEntry a, DictionaryEntry b)
         }
 
         /// <summary>
-        /// An implementation of IComparer useful for comparing the ItemSpecs 
+        /// An implementation of IComparer useful for comparing the ItemSpecs
         /// on ITaskItem's
         /// </summary>
         /// <remarks>Uses CurrentCulture for display purposes</remarks>
@@ -208,7 +208,7 @@ internal void WriteLinePrettyFromResource(int indentLevel, string resourceString
         }
 
         /// <summary>
-        /// Writes to the log, using the default indentation. Does not 
+        /// Writes to the log, using the default indentation. Does not
         /// terminate with a newline.
         /// </summary>
         internal void WritePretty(string formattedString)
@@ -271,7 +271,7 @@ internal void ShowPerfSummary()
         }
 
         /// <summary>
-        /// Writes to the log, using the specified indentation. Does not 
+        /// Writes to the log, using the specified indentation. Does not
         /// terminate with a newline.
         /// </summary>
         internal void WritePretty(int indentLevel, string formattedString)
@@ -481,7 +481,7 @@ internal void InitializeConsoleMethods(LoggerVerbosity logverbosity, WriteHandle
         /// <summary>
         /// Writes out the list of property names and their values.
         /// This could be done at any time during the build to show the latest
-        /// property values, using the cached reference to the list from the 
+        /// property values, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         /// <param name="properties">List of properties</param>
@@ -520,7 +520,7 @@ internal void WriteEnvironment(IDictionary<string, string> environment)
         }
 
         /// <summary>
-        /// Generate a list which contains the properties referenced by the properties 
+        /// Generate a list which contains the properties referenced by the properties
         /// enumerable object
         /// </summary>
         internal List<DictionaryEntry> ExtractPropertyList(IEnumerable properties)
@@ -578,7 +578,7 @@ internal virtual void OutputProperties(List<DictionaryEntry> list)
         /// <summary>
         /// Writes out the list of item specs and their metadata.
         /// This could be done at any time during the build to show the latest
-        /// items, using the cached reference to the list from the 
+        /// items, using the cached reference to the list from the
         /// appropriate ProjectStarted event.
         /// </summary>
         internal void WriteItems(SortedList itemTypes)
@@ -836,13 +836,13 @@ internal virtual void PrintCounterMessage(WriteLinePrettyFromResourceDelegate wr
             }
 
             /// <summary>
-            /// Returns an IComparer that will put performance counters 
+            /// Returns an IComparer that will put performance counters
             /// in descending order by elapsed time.
             /// </summary>
             internal static IComparer DescendingByElapsedTimeComparer => new DescendingByElapsedTime();
 
             /// <summary>
-            /// Private IComparer class for sorting performance counters 
+            /// Private IComparer class for sorting performance counters
             /// in descending order by elapsed time.
             /// </summary>
             internal class DescendingByElapsedTime : IComparer
@@ -1217,7 +1217,7 @@ private bool ApplyVerbosityParameter(string parameterValue)
         internal Dictionary<string, PerformanceCounter> taskPerformanceCounters;
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         internal Dictionary<string, PerformanceCounter> projectEvaluationPerformanceCounters;
 
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index 40fe85aa219..b865a4764b0 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -119,19 +119,19 @@ private void InitializeBaseConsoleLogger()
                 {
                     if (param.Length <= 0) continue;
 
-                    if (0 == string.Compare(param, "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                     {
                         useMPLogger = true;
                     }
-                    if (0 == string.Compare(param, "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                     {
                         useMPLogger = false;
                     }
-                    if (0 == string.Compare(param, "DISABLECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "DISABLECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
                     {
                         disableConsoleColor = true;
                     }
-                    if (0 == string.Compare(param, "FORCECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(param, "FORCECONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
                     {
                         forceConsoleColor = true;
                     }
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index b064862ba9b..c9b9ca599f0 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -141,15 +141,15 @@ private void ApplyParameter(string parameterName)
 
             // If any of the following parameters are set, we will make sure we forward the events
             // necessary for the central logger to emit the requested information
-            if (0 == String.Compare(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 _showPerfSummary = true;
             }
-            else if (0 == String.Compare(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 _showSummary = false;
             }
-            else if (0 == String.Compare(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
             {
                 _showCommandLine = true;
             }
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index e5a3eb3b459..bfe303f9955 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -70,7 +70,7 @@ private void ParseFileLoggerParameters()
         /// </summary>
         private void ApplyFileLoggerParameter(string parameterName, string parameterValue)
         {
-            if (String.Compare("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase))
             {
                 if (string.IsNullOrEmpty(parameterValue))
                 {
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 057b509102e..5a2eb9d20ae 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -123,7 +123,7 @@ internal override bool ApplyParameter(string parameterName, string parameterValu
                 return true;
             }
 
-            if (0 == String.Compare(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
             {
                 if (String.IsNullOrEmpty(parameterValue))
                 {
@@ -144,17 +144,17 @@ internal override bool ApplyParameter(string parameterName, string parameterValu
 
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
             {
                 _showTimeStamp = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
             {
                 _showEventId = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
             {
                 _forceNoAlign = true;
                 _alignMessages = false;
@@ -461,7 +461,7 @@ private void ShowErrorWarningSummary(IEnumerable<BuildEventArgs> listToProcess)
 
                 // If the target where the error occurred is the same as the previous message do not print the location
                 // where the error occurred again
-                if (String.Compare(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase) != 0)
+                if (!String.Equals(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase))
                 {
                     // If no targetName was specified then do not show the target where the error occurred
                     if (!string.IsNullOrEmpty(valuePair.Key.TargetName))
@@ -1348,7 +1348,7 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
                             // Calculate how many chars will fit on the console buffer
                             int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);
                             WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), (prefixAlreadyWritten && index == 0 && i == 0), adjustedPrefixWidth);
-                            index = index + amountToCopy;
+                            index += amountToCopy;
                         }
                     }
                     else
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index 101d788f8e9..0d8e9fa54aa 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -601,7 +601,7 @@ public override bool Equals(object obj)
             {
                 return false;
             }
-            return s_eventComparer.Equals(_entryPointContext, key.EntryPointContext) && (String.Compare(_targetName, key.TargetName, StringComparison.OrdinalIgnoreCase) == 0);
+            return s_eventComparer.Equals(_entryPointContext, key.EntryPointContext) && (String.Equals(_targetName, key.TargetName, StringComparison.OrdinalIgnoreCase));
         }
 
         public override int GetHashCode()
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
index 27f3067ecf7..0de0274f582 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectMetadataLink.cs
@@ -45,6 +45,7 @@ public static object GetParent(ProjectMetadata metadata)
 
         /// <summary>
         /// Helper utility for External projects provider implementation to get access of the EvaluatedValueEscaped
+        /// </summary>
         public static string GetEvaluatedValueEscaped(ProjectMetadata metadata)
         {
             return metadata.EvaluatedValueEscaped;
diff --git a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
index b0f9a943622..ee5c1263f3a 100644
--- a/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
+++ b/src/Build/ObjectModelRemoting/DefinitionObjectsLinks/ProjectPropertyLink.cs
@@ -65,6 +65,7 @@ public abstract class ProjectPropertyLink
 
         /// <summary>
         /// Helper utility for External projects provider implementation to get access of the EvaluatedValueEscaped
+        /// </summary>
         public static string GetEvaluatedValueEscaped(ProjectProperty property)
         {
             return property.EvaluatedValueEscapedIntenral;
diff --git a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
index 5989bc53ffe..98ce259b750 100644
--- a/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
+++ b/src/Build/ObjectModelRemoting/LinkedObjectFactory.cs
@@ -75,15 +75,15 @@ public static IReadOnlyCollection<Project> GetLocalProjects(ProjectCollection co
 
         public ProjectItem Create(ProjectItemLink link, Project project = null, ProjectItemElement xml = null)
         {
-            project = project ?? link.Project;
-            xml = xml ?? link.Xml;
+            project ??= link.Project;
+            xml ??= link.Xml;
 
             return new LinkedProjectItem(xml, project, link);
         }
 
         public ProjectItemDefinition Create(ProjectItemDefinitionLink link, Project project = null)
         {
-            project = project ?? link.Project;
+            project ??= link.Project;
 
             return new LinkedProjectItemDefinition(link, project, link.ItemType);
         }
@@ -100,14 +100,14 @@ public Project Create(ProjectLink link)
 
         public ProjectMetadata Create(ProjectMetadataLink link, object parent = null)
         {
-            parent = parent ?? link.Parent;
+            parent ??= link.Parent;
 
             return new LinkedProjectMetadata(parent, link);
         }
 
         public ProjectProperty Create(ProjectPropertyLink link, Project project = null )
         {
-            project = project ?? link.Project;
+            project ??= link.Project;
 
             return new LinkedProjectProperty(project, link);
         }
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 106a9360ec7..3bb52fd3d73 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -26,7 +26,7 @@ internal class NuGetFrameworkWrapper
 
         public NuGetFrameworkWrapper()
         {
-            /// Resolve the location of the NuGet.Frameworks assembly
+            // Resolve the location of the NuGet.Frameworks assembly
             var assemblyDirectory = BuildEnvironmentHelper.Instance.Mode == BuildEnvironmentMode.VisualStudio ?
                 Path.Combine(BuildEnvironmentHelper.Instance.VisualStudioInstallRootDirectory, "Common7", "IDE", "CommonExtensions", "Microsoft", "NuGet") :
                 BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory;
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index c0534a9a64b..e277165f314 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -23,7 +23,7 @@ namespace Microsoft.Build.Utilities
     /// Unlike System.Version, does not tolerate whitespace, and '+' is ignored as
     /// semver metadata as described above, not tolerated as positive sign of integer
     /// component.
-    /// <summary>
+    /// </summary>
     /// <remarks>
     /// Tolerating leading 'v' allows using $(TargetFrameworkVersion) directly.
     ///
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index a0681677b05..6c1657d1e9d 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -254,7 +254,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the start of a comment
                         insideComment = true;
-                        i = i + 3;
+                        i += 3;
                         continue;
                     }
                 }
@@ -278,7 +278,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the end of a comment
                         insideComment = false;
-                        i = i + 2;
+                        i += 2;
                         continue;
                     }
                 }
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index 8a54c20ef6a..3c1528a3064 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -163,7 +163,7 @@ internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLoca
         }
 
         /// <summary>
-        /// Sets the value of an attribute, removing the attribute if the value is null, but still setting it 
+        /// Sets the value of an attribute, removing the attribute if the value is null, but still setting it
         /// if the value is the empty string. Returns the attribute, or null if it was removed.
         /// UNDONE: Make this return a bool if the attribute did not change, so we can avoid dirtying.
         /// </summary>
@@ -185,7 +185,7 @@ internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLoca
         }
 
         /// <summary>
-        /// Returns the value of the attribute. 
+        /// Returns the value of the attribute.
         /// If the attribute is null, returns an empty string.
         /// </summary>
         internal static string GetAttributeValue(XmlAttributeWithLocation attribute, bool returnNullForNonexistentAttributes)
@@ -201,7 +201,7 @@ internal static string GetAttributeValue(XmlAttributeWithLocation attribute, boo
         }
 
         /// <summary>
-        /// Returns the value of the attribute. 
+        /// Returns the value of the attribute.
         /// If the attribute is not present, returns an empty string.
         /// </summary>
         internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName)
@@ -210,8 +210,8 @@ internal static string GetAttributeValue(XmlElementWithLocation element, string
         }
 
         /// <summary>
-        /// Returns the value of the attribute. 
-        /// If the attribute is not present, returns either null or an empty string, depending on the value 
+        /// Returns the value of the attribute.
+        /// If the attribute is not present, returns either null or an empty string, depending on the value
         /// of nullIfNotExists.
         /// </summary>
         internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName, bool nullIfNotExists)
diff --git a/src/Build/Xml/XmlReaderExtension.cs b/src/Build/Xml/XmlReaderExtension.cs
index 77ec4045b3c..9a6b8a3898a 100644
--- a/src/Build/Xml/XmlReaderExtension.cs
+++ b/src/Build/Xml/XmlReaderExtension.cs
@@ -19,6 +19,7 @@ internal class XmlReaderExtension : IDisposable
         ///     Creates an XmlReaderExtension with handle to an XmlReader.
         /// </summary>
         /// <param name="filePath">Path to the file on disk.</param>
+        /// <param name="loadAsReadOnly">Whther to load the file in real only mode.</param>
         /// <returns>Disposable XmlReaderExtension object.</returns>
         internal static XmlReaderExtension Create(string filePath, bool loadAsReadOnly)
         {
diff --git a/src/Deprecated/Conversion/AdditionalOptionsParser.cs b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
index 6d256826243..3bcc7bd9bf8 100644
--- a/src/Deprecated/Conversion/AdditionalOptionsParser.cs
+++ b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
@@ -31,7 +31,7 @@ internal enum SwitchesToMigrate
     internal enum SwitchValueType
     {
         /// <summary>
-        /// Boolean value 
+        /// Boolean value
         /// </summary>
         SVT_Boolean,
 
@@ -41,7 +41,7 @@ internal enum SwitchValueType
         SVT_String,
 
         /// <summary>
-        /// This switch can occur multiple times and the 
+        /// This switch can occur multiple times and the
         /// final value is the ';' delimeted concat of all the
         /// individual occurrences
         /// </summary>
@@ -50,7 +50,7 @@ internal enum SwitchValueType
 
     /// <summary>
     /// This class contains the migration info for a switch
-    /// that we want to migrate 
+    /// that we want to migrate
     /// </summary>
     internal sealed class CompSwitchInfo
     {
@@ -110,32 +110,32 @@ string switchProjectPropertyName
     }
 
     /// <summary>
-    /// 
+    ///
     /// Class:       AdditionalOptionsParser
     /// Owner:       ParthaD
-    /// 
-    /// This class contains the logic to parse the AdditionalOptions project 
+    ///
+    /// This class contains the logic to parse the AdditionalOptions project
     /// property of v7.x J# projects and add the individual options as project
     /// properties of the upgraded projects.
-    /// 
+    ///
     /// AdditionalOptions project property in v7.x was basically a string that
     /// was passed ditto to the compiler.
     /// It was used to hold J# compiler options that didnt have an 1-1 equivalent
     /// project property.
     /// For v8.0 and beyond, each J# compiler option has a corresponding project
     /// property.
-    /// 
+    ///
     /// AdditionalOptions property string is broken down into list of options.
     /// White space (only ' ' and '\t') are considered as delimiters if not wrapped
-    /// inside double quotes ("). 
+    /// inside double quotes (").
     /// NOTE:
     ///  1. Other unicode spaces or double quotes sequences not considered
-    ///  2. Backslash (\) not considered as possible escape char for ". 
-    /// 
+    ///  2. Backslash (\) not considered as possible escape char for ".
+    ///
     /// Once broken down into individual options, only a few compiler options are
     /// seached for (viz. the options for which v8.0 has new project properties)
     /// Everything else is ignored.
-    /// 
+    ///
     /// Refer to SwitchesToMigrade enum for the switches that are migrated.
     /// </summary>
     internal sealed class AdditionalOptionsParser
@@ -151,7 +151,7 @@ internal sealed class AdditionalOptionsParser
                 null,
                 "CodePage"
             ),
-            
+
             // /x:[all | net]
             new CompSwitchInfo(
                 SwitchesToMigrate.STM_DisableLangExtensions,
@@ -187,7 +187,7 @@ internal sealed class AdditionalOptionsParser
                 null,
                 "SecureScoping"
             ),
-            
+
             // /win32res:<file>
             new CompSwitchInfo(
                 SwitchesToMigrate.STM_Win32Resource,
@@ -216,7 +216,7 @@ ProjectPropertyGroupElement configPropertyGroup
             // Tokenize the additional options first
             string[] compSwitchList;
             compSwitchList = TokenizeAdditionalOptionsValue(additionalOptionsValue);
-            
+
             // Extract the switch arguments
             foreach (string compSwitch in compSwitchList)
             {
@@ -228,11 +228,11 @@ ProjectPropertyGroupElement configPropertyGroup
                     }
                 }
             }
-            
+
             // Finally populate the project file and we'r done!
             PopulatePropertyGroup(configPropertyGroup);
         }
-        
+
         /// <summary>
         /// This will tokenize the given string using ' ' and '\t' as delimiters
         /// The delimiters are escaped inside a pair of quotes
@@ -241,7 +241,7 @@ ProjectPropertyGroupElement configPropertyGroup
         private string[] TokenizeAdditionalOptionsValue(string additionalOptionsValue)
         {
             ArrayList tokens = new ArrayList();
-            
+
             bool inQuotes = false;
             StringBuilder option = new StringBuilder();
             foreach (char c in additionalOptionsValue)
@@ -353,7 +353,7 @@ private bool ExtractSwitchInfo(CompSwitchInfo compSwitchInfo, string compSwitch)
 
                 case SwitchValueType.SVT_MultiString:
                     Debug.Assert(
-                        null != compSwitchInfo.SwitchValue, 
+                        null != compSwitchInfo.SwitchValue,
                         "Non null switch value expected for a multistring switch: " + matchedID
                     );
 
@@ -402,7 +402,7 @@ private void PopulatePropertyGroup(ProjectPropertyGroupElement configPropertyGro
                         if (null != compSwitchInfo.SwitchValue)
                         {
                             configPropertyGroup.AddProperty(
-                                propertyName, 
+                                propertyName,
                                 compSwitchInfo.SwitchValue.ToString().ToLower(CultureInfo.InvariantCulture)
                             );
                         }
diff --git a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
index 83265f55cdd..af98c8f06b8 100644
--- a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
+++ b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
@@ -7,6 +7,7 @@
     <IsPackable>true</IsPackable>
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which contains logic for converting projects.  NOTE: This assembly is deprecated.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
+    <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
   </PropertyGroup>
   <ItemGroup>
     <!-- Source Files -->
diff --git a/src/Deprecated/Conversion/OldVSProjectFileReader.cs b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
index b720fe5e527..aacedaa71a1 100644
--- a/src/Deprecated/Conversion/OldVSProjectFileReader.cs
+++ b/src/Deprecated/Conversion/OldVSProjectFileReader.cs
@@ -463,7 +463,7 @@ string xmlAttributeText
                         // Case-sensitive comparison to see if the entity name matches any of
                         // the well-known ones that were emitted by the XML writer in the VS.NET
                         // 2002/2003 project system.
-                        if (0 == String.Compare(entityName, entities[i], StringComparison.Ordinal))
+                        if (String.Equals(entityName, entities[i], StringComparison.Ordinal))
                         {
                             foundEntity = true;
                             break;
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index 67cb40b8c39..80418eb0315 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -516,7 +516,7 @@ private void ConvertInMemoryToMSBuildProject()
                 // Find matching imports but don't delete whilst enumerating else it will throw an error
                 foreach (ProjectImportElement nextImport in xmakeProject.Imports)
                 {
-                    if (String.Compare(nextImport.Project, @"$(MSBuildBinPath)\Microsoft.WinFX.targets", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(nextImport.Project, @"$(MSBuildBinPath)\Microsoft.WinFX.targets", StringComparison.OrdinalIgnoreCase))
                     {
                         listOfImportsToBeDeleted.Add(nextImport);
                     }
@@ -583,7 +583,7 @@ private void ConvertInMemoryToMSBuildProject()
                 {
                     if ((!nextItem.ItemType.Equals("Reference", StringComparison.OrdinalIgnoreCase)) &&
                         (nextItem.Include.Trim().EndsWith(".xaml", StringComparison.OrdinalIgnoreCase)))
-                        
+
                     {
                         if (!nextItem.Metadata.Any(m => String.Equals(m.Name, "Generator", StringComparison.OrdinalIgnoreCase)))
                         {
@@ -632,15 +632,15 @@ private void ConvertInMemoryToMSBuildProject()
 
                 // Fix up TargetFrameworkSubset
                 changedProject = FixTargetFrameworkSubset() || changedProject;
-                
+
                 var hasFSharpSpecificConversions = FSharpSpecificConversions(true);
-                
+
                 changedProject = hasFSharpSpecificConversions || changedProject;
                 changedProject = VBSpecificConversions() || changedProject;
 
                 // Do asset compat repair for any project that was previously a TV < 12.0
                 if (
-                        String.IsNullOrEmpty(oldToolsVersion) || 
+                        String.IsNullOrEmpty(oldToolsVersion) ||
                         String.Equals(oldToolsVersion, "3.5", StringComparison.OrdinalIgnoreCase) ||
                         String.Equals(oldToolsVersion, "4.0", StringComparison.OrdinalIgnoreCase)
                     )
@@ -708,7 +708,7 @@ private bool DoRepairForAssetCompat()
             var toRepairImports = RequiresRepairForAssetCompat();
 
             if (toRepairImports == null || toRepairImports.Count() == 0)
-            { 
+            {
                 // no need to repair
                 return false;
             }
@@ -717,7 +717,7 @@ private bool DoRepairForAssetCompat()
             {
                 RepairImportForAssetCompat(toRepairImport);
             }
-            
+
             //
             // Add PropertyGroup with Conditions right before where the Imports occur
             //   <PropertyGroup>
@@ -752,7 +752,7 @@ private bool DoRepairForAssetCompat()
 
         /// <summary>
         /// Repairs the given import element
-        /// Change Import to use $(VSToolsPath), with Condition using $(VSToolsPath) 
+        /// Change Import to use $(VSToolsPath), with Condition using $(VSToolsPath)
         /// e.g. From: Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\WebApplications\Microsoft.WebApplication.targets"
         ///        To: Import Project="$(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\WebApplications\Microsoft.WebApplication.targets" Condition="false"
         ///            Import Project="$(VSToolsPath)\WebApplications\Microsoft.WebApplication.targets"
@@ -814,14 +814,13 @@ private string ExtractImportTargetsString(string importProjectValue)
         /// </summary>
         /// <returns>bool</returns>
         private IEnumerable<ProjectImportElement> RequiresRepairForAssetCompat()
-        { 
+        {
             // check if the project has the to-repair pattern in the Imports
             // pattern: $(MSBuildExtensionsPath32)\Microsoft\VisualStudio\v10.0\
             var toRepairImports =  from import in xmakeProject.Imports
                                    where HasRepairPattern(import)
                                    select import;
 
-            
             return toRepairImports;
         }
 
@@ -894,7 +893,7 @@ private bool FixTargetFrameworkSubset()
                         parentGroup.SetProperty(XMakeProjectStrings.TargetFrameworkProfile, XMakeProjectStrings.ClientProfile);
                         changedProject = true;
                     }
-            
+
                     // In all cases, <TargetFrameworkSubset/> is no longer supported.  If it comes from the project
                     // that we're converting, then we forcibly remove it.  If it comes from some import... the user is
                     // on their own.  
@@ -913,13 +912,13 @@ private bool FixTargetFrameworkSubset()
 
         /// <summary>
         /// Performs conversions specific to F# projects (VS2008 CTP -> VS2012) and (VS2010 -> VS2012).
-        /// This involves: changing the location of FSharp targets, 
+        /// This involves: changing the location of FSharp targets,
         /// and for 2008CTP, adding explicit mscorlib and FSharp.Core references.
         /// </summary>
         /// <param name="actuallyMakeChanges">if true, make the changes, otherwise, don't actually make any changes, but do report the return boolean as to whether you would make changes</param>
         /// <returns>true if anything was (would be) changed, false otherwise</returns>
         public bool FSharpSpecificConversions(bool actuallyMakeChanges)
-        {           
+        {
             // For FSharp projects, should import different location of FSharp targets
             const string fsharpFS10TargetsPath = @"$(MSBuildExtensionsPath)\FSharp\1.0\Microsoft.FSharp.Targets";
             const string fsharpFS10TargetsPath32 = @"$(MSBuildExtensionsPath32)\FSharp\1.0\Microsoft.FSharp.Targets";
@@ -943,7 +942,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
             ProjectImportElement fsharpTargetsDev12PlusImport = null;
             ProjectImportElement fsharpTargetsDev11PortableImport = null;
 
-            if (actuallyMakeChanges == false && this.xmakeProject == null)
+            if (!actuallyMakeChanges && this.xmakeProject == null)
             {
                 // when coming down the actuallyMakeChanges==false code path (from the F# project system's UpgradeProject_CheckOnly method), we may not have loaded the Xml yet, so do that now
                 this.xmakeProject = ProjectRootElement.Open(oldProjectFile);
@@ -951,10 +950,10 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
 
             // local function: string equality check using OrdinalIgnoreCase comparison
             Func<string, string, bool> equals = (s1, s2) => String.Equals(s1, s2, StringComparison.OrdinalIgnoreCase);
-            
+
             // local function: wraps specified string value into Exists('value')
             Func<string, string> exists = s => string.Format(CultureInfo.InvariantCulture, "Exists('{0}')", s);
-            
+
             // local function: 
             // Creates property group element containing one property fsharpDev12PlusProperty with value 'path'. 
             // If addCondition is true, property group will have Exists(path) condition
@@ -965,7 +964,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                     parent.AppendChild(propGroup);
                     var prop = xmakeProject.CreatePropertyElement(fsharpDev12PlusProperty);
                     prop.Value = path;
-                    propGroup.AppendChild(prop);                    
+                    propGroup.AppendChild(prop);
                 };
 
             foreach (ProjectImportElement importElement in xmakeProject.Imports)
@@ -1012,11 +1011,11 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 return false;
 
             if (!actuallyMakeChanges)
-                return true;            
+                return true;
 
             // both branches adds this elements to the project
             var chooseElement = xmakeProject.CreateChooseElement(); // (1)
-            
+
             if (fsharpTargetsDev11PortableImport != null)
             {
                 // Dev11 portable library
@@ -1039,7 +1038,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 // portable libraries are supported since Dev11
                 var whenVsVersionIsDev11 = xmakeProject.CreateWhenElement("'$(VisualStudioVersion)' == '11.0'"); // (2)
                 chooseElement.AppendChild(whenVsVersionIsDev11);
-                
+
                 appendPropertyGroupForDev12PlusTargetsPath(fsharpPortableDev11TargetsPath, whenVsVersionIsDev11);
 
                 var otherwiseIfVsVersionIsDev12Plus = xmakeProject.CreateOtherwiseElement(); // (3)
@@ -1129,7 +1128,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 {
                     referencesItemGroup.AddItem(ReferenceItemType, "mscorlib");
                 }
-            }            
+            }
 
             // try to find reference to FSharp.Core 
             ProjectItemElement fsharpCoreItem = null;
@@ -1189,10 +1188,9 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
 
             newFSharpCoreItem?.AddMetadata("Private", "True");
 
-            
             const string MinimumVisualStudioVersionProperty = "MinimumVisualStudioVersion";
             var hasMinimumVSVersion = xmakeProject.Properties.Any(prop => prop.Name == MinimumVisualStudioVersionProperty);
-            
+
             foreach(var group in xmakeProject.PropertyGroups)
             {
                 // find first non-conditional property group to add TargetFSharpCoreVersion property
@@ -1517,7 +1515,7 @@ XmlElementWithLocation      languageElement
             // convert web projects -- that's Venus's job.
             string projectType = languageElement.GetAttribute(VSProjectAttributes.projectType);
             ProjectErrorUtilities.VerifyThrowInvalidProject(projectType == null || projectType.Length == 0 ||
-                (String.Compare(projectType, VSProjectAttributes.local, StringComparison.OrdinalIgnoreCase) == 0),
+                (String.Equals(projectType, VSProjectAttributes.local, StringComparison.OrdinalIgnoreCase)),
                 languageElement.Location, "ProjectTypeCannotBeConverted", projectType);
 
             // All of the attributes on the language tag get converted to XMake
@@ -1710,7 +1708,7 @@ private void AddFinalPropertiesAndImports(XmlElementWithLocation languageElement
                 {
                     if (this.outputType?.Length > 0)
                     {
-                        if (String.Compare(this.outputType, XMakeProjectStrings.winExe, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(this.outputType, XMakeProjectStrings.winExe, StringComparison.OrdinalIgnoreCase))
                         {
                             if (this.hasWindowsFormsReference)
                             {
@@ -1722,11 +1720,11 @@ private void AddFinalPropertiesAndImports(XmlElementWithLocation languageElement
                                 this.globalPropertyGroup.AddProperty(XMakeProjectStrings.myType, XMakeProjectStrings.console);
                             }
                         }
-                        else if (String.Compare(this.outputType, XMakeProjectStrings.exe, StringComparison.OrdinalIgnoreCase) == 0)
+                        else if (String.Equals(this.outputType, XMakeProjectStrings.exe, StringComparison.OrdinalIgnoreCase))
                         {
                             this.globalPropertyGroup.AddProperty(XMakeProjectStrings.myType, XMakeProjectStrings.console);
                         }
-                        else if (String.Compare(this.outputType, XMakeProjectStrings.library, StringComparison.OrdinalIgnoreCase) == 0)
+                        else if (String.Equals(this.outputType, XMakeProjectStrings.library, StringComparison.OrdinalIgnoreCase))
                         {
                             this.globalPropertyGroup.AddProperty(XMakeProjectStrings.myType, XMakeProjectStrings.windows);
                         }
@@ -2173,11 +2171,11 @@ XmlElementWithLocation      configElement
                 if (String.IsNullOrEmpty(debugType))
                 {
                     string debugSymbols = configElement.GetAttribute(XMakeProjectStrings.debugSymbols);
-                    if (  0 == String.Compare ( debugSymbols, "true", StringComparison.OrdinalIgnoreCase ) )
+                    if (  String.Equals ( debugSymbols, "true", StringComparison.OrdinalIgnoreCase ) )
                     {
                         configPropertyGroup.AddProperty(VSProjectAttributes.debugType, VSProjectAttributes.debugTypeFull);
                     }
-                    else if ( 0 == String.Compare(debugSymbols, "false", StringComparison.OrdinalIgnoreCase) )
+                    else if ( String.Equals(debugSymbols, "false", StringComparison.OrdinalIgnoreCase) )
                     {
                         configPropertyGroup.AddProperty(VSProjectAttributes.debugType, VSProjectAttributes.debugTypeNone);
                     }
@@ -2517,14 +2515,14 @@ ProjectItemGroupElement referencesItemGroup
                    ( this.language == VSProjectElements.EVisualBasic ) ) )
             {
                 if ( ( this.frameworkVersionForVSD == XMakeProjectStrings.vTwo ) &&
-                     ( 0 == String.Compare ( referenceName, VSProjectElements.SystemDataCommon, StringComparison.OrdinalIgnoreCase ) ) )
+                     ( String.Equals ( referenceName, VSProjectElements.SystemDataCommon, StringComparison.OrdinalIgnoreCase ) ) )
                 {
                     // We need to remove all references to "System.Data.Common" for VSD projects only.
                     //   Note : We only want to do this for projects that will be updated to v2.0
                     //          System.Data.Common is still valid for v1.0 upgraded projects.
                     return;
                 }
-                else if ( 0 == String.Compare ( referenceName, VSProjectElements.SystemSR, StringComparison.OrdinalIgnoreCase ) )
+                else if ( String.Equals ( referenceName, VSProjectElements.SystemSR, StringComparison.OrdinalIgnoreCase ) )
                 {
                     // We always want to remove all references to "System.SR"
                     return;
@@ -2532,7 +2530,7 @@ ProjectItemGroupElement referencesItemGroup
             }
 
             if ( ( this.language == VSProjectElements.EVisualBasic ) &&
-                 ( 0 == String.Compare ( referenceName, VSProjectElements.MSCorLib, StringComparison.OrdinalIgnoreCase ) ) )
+                 ( String.Equals ( referenceName, VSProjectElements.MSCorLib, StringComparison.OrdinalIgnoreCase ) ) )
             {
                 // We also want to get rid of all 'mscorlib' references for VB projects only.
                 return;
@@ -2672,13 +2670,13 @@ private ProjectItemElement ConvertProjectToProjectReference(XmlElementWithLocati
             {
                 // For VSD Projects, we want to transform all Everett ( .csdproj & .vbdproj ) project 2 project references into
                 // Whidbey ( .csproj & .vbproj ) references.
-                if (0 == String.Compare(Path.GetExtension(pathToReferencedProject),
+                if (String.Equals(Path.GetExtension(pathToReferencedProject),
                                         XMakeProjectStrings.csdprojFileExtension,
                                         StringComparison.OrdinalIgnoreCase))
                 {
                     pathToReferencedProject = Path.ChangeExtension(pathToReferencedProject, XMakeProjectStrings.csprojFileExtension);
                 }
-                else if (0 == String.Compare(Path.GetExtension(pathToReferencedProject),
+                else if (String.Equals(Path.GetExtension(pathToReferencedProject),
                                              XMakeProjectStrings.vbdprojFileExtension,
                                              StringComparison.OrdinalIgnoreCase))
                 {
@@ -2742,7 +2740,7 @@ private ProjectItemElement ConvertAssemblyReference(XmlElementWithLocation refer
 
             // MyType should only be added when System.Windows.Forms is present. If this
             // reference is seen, then set a flag so we can later add MyType.
-            if (0 == String.Compare("System.Windows.Forms", assemblyName, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals("System.Windows.Forms", assemblyName, StringComparison.OrdinalIgnoreCase))
             {
                 hasWindowsFormsReference = true;
             }
@@ -2792,7 +2790,7 @@ private void SearchForSolutionFile
                 {
                     // Check that the extension really is ".SLN", because the above call to
                     // GetFiles will also return files such as blah.SLN1 and bloo.SLN2.
-                    if (0 == String.Compare(".sln", slnFile.Extension, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(".sln", slnFile.Extension, StringComparison.OrdinalIgnoreCase))
                     {
                         // Parse the .SLN file.
                         SolutionFile solutionParser = new SolutionFile();
@@ -3224,7 +3222,7 @@ ProjectItemGroupElement filesItemGroup
             // Bug Whidbey #248965. If a .resx file is completely empty, do not include a reference
             // to it in the upgraded project file.
             if (!
-                (0 == String.Compare(Path.GetExtension(relPath), ".resx", StringComparison.OrdinalIgnoreCase)
+                (String.Equals(Path.GetExtension(relPath), ".resx", StringComparison.OrdinalIgnoreCase)
                  && IsFilePresentButEmpty(relPath, linkPath))
                )
             {
@@ -3295,7 +3293,7 @@ ProjectItemGroupElement filesItemGroup
                 // mark it to copy if newer.
                 if ( ( ( ( this.language == VSProjectElements.ECSharp ) ||
                          ( this.language == VSProjectElements.EVisualBasic ) ) ) &&
-                     ( 0 == String.Compare ( buildAction, XMakeProjectStrings.content, StringComparison.OrdinalIgnoreCase ) ) )
+                     ( String.Equals ( buildAction, XMakeProjectStrings.content, StringComparison.OrdinalIgnoreCase ) ) )
                 {
                     newFileItem.AddMetadata ( XMakeProjectStrings.copytooutput,
                                               XMakeProjectStrings.preservenewest );
@@ -3408,7 +3406,7 @@ ProjectItemGroupElement filesItemGroup
 
             ProjectItemElement newFolderItem;
 
-            if ((webReferences != null) && (0 == String.Compare(webReferences, "true", StringComparison.OrdinalIgnoreCase)))
+            if ((webReferences != null) && (String.Equals(webReferences, "true", StringComparison.OrdinalIgnoreCase)))
             {
                 // This is a web reference folder.
 
@@ -3801,7 +3799,7 @@ out bool                    isTriumphProject
                         string officeDocumentFullPath = Path.GetFullPath(Path.Combine(projectFileDirectory, officeDocumentPath));
 
                         // If the office document is in the project directory ...
-                        if (0 == String.Compare(projectFileDirectory, Path.GetDirectoryName(officeDocumentFullPath), StringComparison.OrdinalIgnoreCase))
+                        if (String.Equals(projectFileDirectory, Path.GetDirectoryName(officeDocumentFullPath), StringComparison.OrdinalIgnoreCase))
                         {
                             // If the office document actually exists on disk ...
                             if (File.Exists(officeDocumentFullPath))
diff --git a/src/Deprecated/Engine/Choose/GroupingCollection.cs b/src/Deprecated/Engine/Choose/GroupingCollection.cs
index 09e844192ec..5624527929b 100644
--- a/src/Deprecated/Engine/Choose/GroupingCollection.cs
+++ b/src/Deprecated/Engine/Choose/GroupingCollection.cs
@@ -562,7 +562,7 @@ internal void RemoveAllPropertyGroupsByCondition(string condition, bool includeI
             ArrayList propertiesToRemove = new ArrayList();
             foreach (BuildPropertyGroup propertyGroup in this.PropertyGroupsAll)
             {
-                if (0 == String.Compare(condition.Trim(), propertyGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
+                if (String.Equals(condition.Trim(), propertyGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
                     && (!propertyGroup.IsImported || includeImportedPropertyGroups))
                 {
                     propertiesToRemove.Add(propertyGroup);
@@ -622,7 +622,7 @@ internal void RemoveAllItemGroupsByCondition(string condition)
 
             foreach (BuildItemGroup itemGroup in this.ItemGroupsAll)
             {
-                if (0 == String.Compare(condition.Trim(), itemGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
+                if (String.Equals(condition.Trim(), itemGroup.Condition.Trim(), StringComparison.OrdinalIgnoreCase) 
                     && !itemGroup.IsImported)
                 {
                     itemsToRemove.Add(itemGroup);
@@ -652,7 +652,7 @@ internal void RemoveItemsByName(string itemName)
                 // ones that are of the requested item type.
                 foreach (BuildItem item in itemGroup)
                 {
-                    if ((0 == String.Compare(item.Name, itemName, StringComparison.OrdinalIgnoreCase)) &&
+                    if ((String.Equals(item.Name, itemName, StringComparison.OrdinalIgnoreCase)) &&
                             !item.IsImported
                         )
                     {
diff --git a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
index 2d4685a52d2..dfa1b8bba90 100644
--- a/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/FunctionCallExpressionNode.cs
@@ -35,7 +35,7 @@ internal FunctionCallExpressionNode(string functionName, ArrayList arguments)
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluationState state)
         {
-            if (String.Compare(functionName, "exists", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
@@ -68,7 +68,7 @@ internal override bool BoolEvaluate(ConditionEvaluationState state)
                 // Both Exists functions return false if the value is null or empty
                 return File.Exists(expandedValue) || Directory.Exists(expandedValue);
             }
-            else if (String.Compare(functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(functionName, "HasTrailingSlash", StringComparison.OrdinalIgnoreCase))
             {
                 // Check we only have one argument
                 VerifyArgumentCount(1, state);
diff --git a/src/Deprecated/Engine/Conditionals/Scanner.cs b/src/Deprecated/Engine/Conditionals/Scanner.cs
index 833df5cb9ac..83ae741d5ac 100644
--- a/src/Deprecated/Engine/Conditionals/Scanner.cs
+++ b/src/Deprecated/Engine/Conditionals/Scanner.cs
@@ -553,11 +553,11 @@ private bool ParseRemaining()
         private bool ParseSimpleStringOrFunction( int start )
         {
             SkipSimpleStringChars();
-            if (0 == string.Compare(expression.Substring(start, parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
+            if (string.Equals(expression.Substring(start, parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
             {
                 lookahead = new Token(Token.TokenType.And, expression.Substring(start, parsePoint - start));
             }
-            else if (0 == string.Compare(expression.Substring(start, parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
+            else if (string.Equals(expression.Substring(start, parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
             {
                 lookahead = new Token(Token.TokenType.Or, expression.Substring(start, parsePoint - start));
             }
diff --git a/src/Deprecated/Engine/Engine/BatchingEngine.cs b/src/Deprecated/Engine/Engine/BatchingEngine.cs
index a6d1a640536..f7665e917bc 100644
--- a/src/Deprecated/Engine/Engine/BatchingEngine.cs
+++ b/src/Deprecated/Engine/Engine/BatchingEngine.cs
@@ -392,7 +392,7 @@ Dictionary<string, MetadataReference> consumedMetadataReferences
 
                 if  (
                         (metadataItemName != null) &&
-                        (0 != String.Compare(item.Name, metadataItemName, StringComparison.OrdinalIgnoreCase))
+                        (!String.Equals(item.Name, metadataItemName, StringComparison.OrdinalIgnoreCase))
                     )
                 {
                     itemMetadataValues[metadataQualifiedName] = String.Empty;
diff --git a/src/Deprecated/Engine/Engine/BuildTask.cs b/src/Deprecated/Engine/Engine/BuildTask.cs
index 170055d5f72..b7f2b14a0d4 100644
--- a/src/Deprecated/Engine/Engine/BuildTask.cs
+++ b/src/Deprecated/Engine/Engine/BuildTask.cs
@@ -55,7 +55,7 @@ public class BuildTask
         #region Constructors
         /// <summary>
         /// This constructor initializes a persisted task from an existing task
-        /// element which exists either in the main project file or one of the 
+        /// element which exists either in the main project file or one of the
         /// imported files.
         /// </summary>
         /// <param name="taskElement"></param>
@@ -96,7 +96,7 @@ bool            importedFromAnotherProject
 
                     // this only makes sense in the context of the new OM, 
                     // so just ignore it.  
-                    case XMakeAttributes.msbuildRuntime: 
+                    case XMakeAttributes.msbuildRuntime:
                         // do nothing
                         break;
 
@@ -112,8 +112,8 @@ bool            importedFromAnotherProject
         }
 
         /// <summary>
-        /// Default constructor.  This is not allowed, because it leaves the 
-        /// BuildTask in a bad state. But we have to have it, otherwise FXCop 
+        /// Default constructor.  This is not allowed, because it leaves the
+        /// BuildTask in a bad state. But we have to have it, otherwise FXCop
         /// complains.
         /// </summary>
         /// <owner>rgoel</owner>
@@ -142,7 +142,7 @@ internal XmlElement TaskXmlElement
         }
 
         /// <summary>
-        /// Accessor for the task's "name" element.  
+        /// Accessor for the task's "name" element.
         /// </summary>
         /// <owner>RGoel</owner>
         public string Name
@@ -202,7 +202,7 @@ public bool ContinueOnError
                 {
                     return true;
                 }
-                else 
+                else
                 {
                     return false;
                 }
@@ -237,7 +237,7 @@ public bool ContinueOnError
         }
 
         /// <summary>
-        /// System.Type object corresponding to the task class that implements 
+        /// System.Type object corresponding to the task class that implements
         /// the functionality that runs this task object.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -258,7 +258,7 @@ public Type Type
                                                    parentProject.ProjectBuildEventContext.TaskId
                                                );
 
-                int handleId = parentEngine.EngineCallback.CreateTaskContext(parentProject, ParentTarget, null, taskElement, 
+                int handleId = parentEngine.EngineCallback.CreateTaskContext(parentProject, ParentTarget, null, taskElement,
                                                                                 EngineCallback.inProcNode, taskContext);
                 EngineLoggingServices loggingServices = parentEngine.LoggingServices;
                 TaskExecutionModule taskExecutionModule = parentEngine.NodeManager.TaskExecutionModule;
@@ -313,12 +313,12 @@ internal Target ParentTarget
         #region Methods
 
         /// <summary>
-        /// This retrieves the list of all parameter names from the element 
-        /// node of this task. Note that it excludes anything that a specific 
-        /// property is exposed for or that isn't valid here (Name, Condition, 
+        /// This retrieves the list of all parameter names from the element
+        /// node of this task. Note that it excludes anything that a specific
+        /// property is exposed for or that isn't valid here (Name, Condition,
         /// ContinueOnError).
-        /// 
-        /// Note that if there are none, it returns string[0], rather than null, 
+        ///
+        /// Note that if there are none, it returns string[0], rather than null,
         /// as it makes writing foreach statements over the return value so
         /// much simpler.
         /// </summary>
@@ -336,7 +336,7 @@ public string[] GetParameterNames()
             {
                 string attributeValue = attrib.Name;
 
-                if (!XMakeAttributes.IsSpecialTaskAttribute(attributeValue)) 
+                if (!XMakeAttributes.IsSpecialTaskAttribute(attributeValue))
                 {
                     list.Add(attributeValue);
                 }
@@ -349,7 +349,7 @@ public string[] GetParameterNames()
         /// This retrieves an arbitrary attribute from the task element.  These
         /// are attributes that the project author has placed on the task element
         /// that have no meaning to MSBuild other than that they get passed to the
-        /// task itself as arguments.  
+        /// task itself as arguments.
         /// </summary>
         /// <owner>RGoel</owner>
         public string GetParameterValue
@@ -365,7 +365,7 @@ string attributeName
             error.VerifyThrowInvalidOperation(this.taskElement != null,
                 "CannotUseParameters");
 
-            string attributeValue; 
+            string attributeValue;
 
             // If this is a persisted Task, grab the attribute directly from the
             // task element.
@@ -378,7 +378,7 @@ string attributeName
         /// This sets an arbitrary attribute on the task element.  These
         /// are attributes that the project author has placed on the task element
         /// that get passed in to the task.
-        /// 
+        ///
         /// This optionally escapes the parameter value so it will be treated as a literal.
         /// </summary>
         /// <param name="parameterName"></param>
@@ -509,7 +509,7 @@ public bool Execute
 
         /// <summary>
         /// Indicates that something has changed within the task element, so the project
-        /// needs to be saved and re-evaluated at next build.  Send the "dirtiness" 
+        /// needs to be saved and re-evaluated at next build.  Send the "dirtiness"
         /// notification up the chain.
         /// </summary>
         /// <owner>RGoel</owner>
diff --git a/src/Deprecated/Engine/Engine/CacheManager.cs b/src/Deprecated/Engine/Engine/CacheManager.cs
index 2263370a656..894d4a82ae8 100644
--- a/src/Deprecated/Engine/Engine/CacheManager.cs
+++ b/src/Deprecated/Engine/Engine/CacheManager.cs
@@ -75,7 +75,7 @@ private CacheScope GetCacheScopeIfExists(string scopeName, BuildPropertyGroup sc
                     {
                         for (int i = 0; i < scopesByName.Count; i++)
                         {
-                            if (scopesByName[i].ScopeProperties.IsEquivalent(scopeProperties) && (String.Compare(scopeToolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase) == 0))
+                            if (scopesByName[i].ScopeProperties.IsEquivalent(scopeProperties) && (String.Equals(scopeToolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase)))
                             {
                                 cacheScope = scopesByName[i];
                                 break;
@@ -216,7 +216,7 @@ internal void ClearCacheScope(string projectName, BuildPropertyGroup buildProper
                     {
                         for (int i = 0; i < scopesByName.Count; i++)
                         {
-                            if (scopesByName[i].ScopeProperties.IsEquivalent(buildPropertyGroup) && (String.Compare(toolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase) == 0))
+                            if (scopesByName[i].ScopeProperties.IsEquivalent(buildPropertyGroup) && (String.Equals(toolsVersion, scopesByName[i].ScopeToolsVersion, StringComparison.OrdinalIgnoreCase)))
                             {
                                 scopesByName.RemoveAt(i);
                                 break;
diff --git a/src/Deprecated/Engine/Engine/CacheScope.cs b/src/Deprecated/Engine/Engine/CacheScope.cs
index 9946ae323d4..68441ada9e4 100644
--- a/src/Deprecated/Engine/Engine/CacheScope.cs
+++ b/src/Deprecated/Engine/Engine/CacheScope.cs
@@ -246,7 +246,7 @@ internal void AddCacheEntryForBuildResults(BuildResult buildResult)
                     // If the project file is malformed the build may fail without initializing the initialtargets or
                     // the default targests fields. The retrieval code expects non-null values
                     // so it is necessary to replace null with empty string
-                    ErrorUtilities.VerifyThrow(buildResult.EvaluationResult == false || buildResult.InitialTargets != null 
+                    ErrorUtilities.VerifyThrow(!buildResult.EvaluationResult || buildResult.InitialTargets != null 
                                                && buildResult.DefaultTargets != null , 
                                                "Expect initial targets to be non-null for successful builds");
                     string defaultTargets = buildResult.DefaultTargets == null ? String.Empty : buildResult.DefaultTargets;
diff --git a/src/Deprecated/Engine/Engine/Engine.cs b/src/Deprecated/Engine/Engine/Engine.cs
index dc406b56e31..c12432ec36c 100644
--- a/src/Deprecated/Engine/Engine/Engine.cs
+++ b/src/Deprecated/Engine/Engine/Engine.cs
@@ -117,7 +117,7 @@ public class Engine
 
         // The name of the current default toolsVersion. Starts with Constants.defaultVersion
         private string defaultToolsVersion;
-        
+
         // The node Id which the engine is running on
         private int nodeId;
 
@@ -167,7 +167,7 @@ public class Engine
         private DualQueue<BuildRequest> buildRequests;
 
         private ManualResetEvent engineAbortEvent = new ManualResetEvent(false);
-        
+
         // a cached version of the engineAbortEvent so we don't have to wait on it to determine the value.
         // If we do have to wait for something to happen we still need the event though.
         private volatile bool engineAbortCachedValue = false;
@@ -202,7 +202,7 @@ public class Engine
 
         // this seed is used to generate unique logger ids for each distributed logger
         private int lastUsedLoggerId;
-        
+
         // this boolean is true if central logging is enabled 
         private bool enabledCentralLogging;
 
@@ -266,7 +266,7 @@ public class Engine
         /// <summary>
         /// Default constructor that reads toolset information from both the registry
         /// and configuration file.
-        /// The need for parameterless constructor is dictated by COM interop. 
+        /// The need for parameterless constructor is dictated by COM interop.
         /// </summary>
         public Engine()
             : this(1 /* cpu */, false /* not child node */, 0 /* default NodeId */, null/*No msbuild.exe path*/, null, ToolsetDefinitionLocations.ConfigurationFile | ToolsetDefinitionLocations.Registry)
@@ -297,7 +297,7 @@ public Engine(BuildPropertyGroup globalProperties)
         }
 
         /// <summary>
-        /// Constructor to specify whether toolsets should be initialized from the msbuild configuration file and from the registry 
+        /// Constructor to specify whether toolsets should be initialized from the msbuild configuration file and from the registry
         /// </summary>
         public Engine(ToolsetDefinitionLocations locations)
             : this(null, locations)
@@ -305,7 +305,7 @@ public Engine(ToolsetDefinitionLocations locations)
         }
 
         /// <summary>
-        /// Constructor to specify the global properties the engine should inherit and 
+        /// Constructor to specify the global properties the engine should inherit and
         /// the locations the engine should inspect for toolset definitions.
         /// </summary>
         public Engine(BuildPropertyGroup globalProperties, ToolsetDefinitionLocations locations)
@@ -330,7 +330,7 @@ internal Engine(BuildPropertyGroup globalProperties, ToolsetDefinitionLocations
             // Override the startup directory with the one we were passed
             ErrorUtilities.VerifyThrow(startupDirectory != null, "Need startup directory");
             this.startupDirectory = startupDirectory;
-            
+
             forwardPropertiesFromChild = Environment.GetEnvironmentVariable("MSBuildForwardPropertiesFromChild");
             // Get a list of properties which should be serialized
             if (!String.IsNullOrEmpty(forwardPropertiesFromChild))
@@ -340,16 +340,16 @@ internal Engine(BuildPropertyGroup globalProperties, ToolsetDefinitionLocations
         }
 
         /// <summary>
-        /// Constructor to init all data except for BinPath which is initialized separately because 
+        /// Constructor to init all data except for BinPath which is initialized separately because
         /// a parameterless constructor is needed for COM interop
         /// </summary>
         internal Engine
         (
-            int numberOfCpus, 
-            bool isChildNode, 
-            int parentNodeId, 
+            int numberOfCpus,
+            bool isChildNode,
+            int parentNodeId,
             string localNodeProviderParameters,
-            BuildPropertyGroup globalProperties, 
+            BuildPropertyGroup globalProperties,
             ToolsetDefinitionLocations locations
         )
         {
@@ -478,7 +478,7 @@ private void InitializeLocalNodeProvider(ToolsetDefinitionLocations locations)
         /// </summary>
         /// <remarks>
         /// BinPath is an obsolete concept. We retain it for now for all the hosts that use the BinPath
-        /// property, or the Engine(binPath) constructor, but internally it is just the tools path 
+        /// property, or the Engine(binPath) constructor, but internally it is just the tools path
         /// of the default tools version.
         /// </remarks>
         /// <value>The MSBuild path.</value>
@@ -508,7 +508,7 @@ public bool IsBuilding
                 return numberOfProjectsInProgress > 0;
             }
         }
-        
+
         /// <summary>
         /// The node Id the current engine instance is running on
         /// </summary>
@@ -638,7 +638,7 @@ internal BuildPropertyGroup EnvironmentProperties
                 return this.environmentProperties;
             }
         }
-        
+
         /// <summary>
         ///  Get a new TaskId
         /// (NOT Thread safe)
@@ -718,7 +718,7 @@ internal Hashtable ImportedProjectsCache
         /// Returns the table of projects loaded by the host.
         /// </summary>
         /// <owner>RGoel</owner>
-        /// <remarks>Marked "internal" for unit tests only.  To maintain encapsulation, please try not to 
+        /// <remarks>Marked "internal" for unit tests only.  To maintain encapsulation, please try not to
         /// use this accessor in real msbuild code, except from within this class.</remarks>
         internal Hashtable ProjectsLoadedByHost
         {
@@ -872,7 +872,7 @@ internal ManualResetEvent FlushRequestEvent
         }
 
         /// <summary>
-        /// The current directory at the time the Engine was constructed -- 
+        /// The current directory at the time the Engine was constructed --
         /// if msbuild.exe is hosting, this is the current directory when
         /// msbuild.exe was started
         /// </summary>
@@ -880,7 +880,7 @@ internal string StartupDirectory
         {
             get { return startupDirectory; }
         }
-        
+
         #endregion
 
         #region Methods
@@ -935,7 +935,7 @@ internal void UpdateToolsPath(string toolsVersion, string toolsPath)
             {
                 buildProperties = toolsetStateMap[toolsVersion].BuildProperties.Clone(true /* deep clone */);
             }
-            
+
             toolsets.Add(new Toolset(toolsVersion, toolsPath, buildProperties));
         }
 
@@ -955,7 +955,7 @@ private void DirtyProjectsUsingToolsVersion(string toolsVersion)
         }
 
         /// <summary>
-        /// Populate ToolsetStateMap with a dictionary of (toolset version, ToolsetState) 
+        /// Populate ToolsetStateMap with a dictionary of (toolset version, ToolsetState)
         /// using information from the registry and config file, if any.
         /// </summary>
         /// <remarks>Internal for unit testing purposes only</remarks>
@@ -1007,7 +1007,7 @@ internal void PopulateToolsetStateMap(ToolsetDefinitionLocations locations)
         /// <summary>
         /// The default tools version of this Engine. Projects use this tools version if they
         /// aren't otherwise told what tools version to use.
-        /// This value is gotten from the .exe.config file, or else in the registry, 
+        /// This value is gotten from the .exe.config file, or else in the registry,
         /// or if neither specify a default tools version then it is hard-coded to the tools version "2.0".
         /// </summary>
         public string DefaultToolsVersion
@@ -1103,7 +1103,7 @@ private void RegisterLoggerInternal(ILogger logger, EventSource sourceForLogger,
         }
 
         /// <summary>
-        /// Called to register distributed loggers with the engine. 
+        /// Called to register distributed loggers with the engine.
         /// This method is not thread safe. All loggers should registered prior to
         /// starting the build in order to guarantee uniform behavior
         /// </summary>
@@ -1251,7 +1251,7 @@ internal void UnregisterLoggersInternal(ArrayList loggersToUnregister)
 
         /// <summary>
         /// Log BuildFinished event (if there is no unhandled exception) and clear
-        /// the projects loaded by host from the 
+        /// the projects loaded by host from the
         /// </summary>
         internal void EndingEngineExecution(bool buildResult, bool exitedDueToError)
         {
@@ -1551,7 +1551,7 @@ string targetName
         {
             return BuildProject(project, (targetName == null) ? null : new string[] { targetName }, null, BuildSettings.None);
         }
-        
+
         /// <summary>
         /// Builds a list of targets in an already-loaded project.
         /// </summary>
@@ -1630,8 +1630,8 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
             int flushTimeout = EngineLoggingServices.flushTimeoutInMS; // Timeout with which the log is flushed
             bool forceFlush = false;
             while (
-                    continueExecution && 
-                    (terminatingBuildRequest == null || terminatingBuildRequest.BuildCompleted == false)
+                    continueExecution &&
+                    (terminatingBuildRequest == null || !terminatingBuildRequest.BuildCompleted)
                   )
             {
                 int eventType = 0;
@@ -1669,7 +1669,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
                     // Decrement time remaining until deadlock check
                     if (loopTimeoutRemaining != Timeout.Infinite)
                     {
-                        loopTimeoutRemaining = flushTimeout > loopTimeoutRemaining ? 
+                        loopTimeoutRemaining = flushTimeout > loopTimeoutRemaining ?
                                                   0 : loopTimeoutRemaining - flushTimeout;
                     }
                     // Always force a flush on a time
@@ -1814,7 +1814,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
                 // TEM will be null if we're shutting down
                 if (NodeManager.TaskExecutionModule != null)
                 {
-                    if (NodeManager.TaskExecutionModule.UseBreadthFirstTraversal == false /* using depth first traversal */ &&
+                    if (!NodeManager.TaskExecutionModule.UseBreadthFirstTraversal /* using depth first traversal */ &&
                         buildRequests.Count == 0 && taskOutputUpdates.Count == 0 &&
                         NodeManager.TaskExecutionModule.IsIdle
                         )
@@ -1852,7 +1852,7 @@ internal BuildResult EngineBuildLoop(BuildRequest terminatingBuildRequest)
         /// </summary>
         private void BuildProjectInternal
         (
-            BuildRequest buildRequest, 
+            BuildRequest buildRequest,
             ProjectBuildState buildContext,
             TaskExecutionContext taskExecutionContext,
             bool initialCall
@@ -1883,7 +1883,7 @@ bool initialCall
                 }
 
                 try
-                { 
+                {
                     if (initialCall)
                     {
                         BuildProjectInternalInitial(buildRequest, project);
@@ -1975,12 +1975,12 @@ Decrementing from 0 projects in progress causes an exception.
                 buildRequest.StartTime = DateTime.Now.Ticks;
                 buildRequest.ProcessingStartTime = buildRequest.StartTime;
             }
-            
+
             if (startRootProjectBuild)
             {
                 StartRootProjectBuild(buildRequest, project);
             }
-            
+
             project.BuildInternal(buildRequest);
         }
 
@@ -2203,7 +2203,7 @@ IDictionary targetOutputs
         /// </summary>
         /// <remarks>
         /// If this project file is already in our list of in-progress projects, we use the
-        /// existing Project object instead of instantiating a new one. Always use this method to 
+        /// existing Project object instead of instantiating a new one. Always use this method to
         /// build projects within projects, otherwise the build won't be optimized.
         /// </remarks>
         /// <param name="projectFile"></param>
@@ -2234,7 +2234,7 @@ BuildSettings buildFlags
         /// </summary>
         /// <remarks>
         /// If this project file is already in our list of in-progress projects, we use the
-        /// existing Project object instead of instantiating a new one. Always use this method to 
+        /// existing Project object instead of instantiating a new one. Always use this method to
         /// build projects within projects, otherwise the build won't be optimized.
         /// </remarks>
         /// <param name="projectFile"></param>
@@ -2262,7 +2262,7 @@ string toolsVersion
 
         /// <summary>
         /// Loads a set of project files from disk, and builds the given list of targets for each one. This overload
-        /// takes a set of global properties for each project to use for the build, returns the target outputs, 
+        /// takes a set of global properties for each project to use for the build, returns the target outputs,
         /// and also allows the caller to specify additional build flags.
         /// </summary>
         /// <param name="projectFiles">Array of project files to build (can't be null)</param>
@@ -2297,7 +2297,7 @@ string [] toolsVersions
             }
 
             return PostProjectEvaluationRequests
-                (null, projectFiles, targetNamesPerProject, globalPropertiesPerProject, targetOutputsPerProject, 
+                (null, projectFiles, targetNamesPerProject, globalPropertiesPerProject, targetOutputsPerProject,
                  buildFlags, toolsVersions);
         }
 
@@ -2317,7 +2317,7 @@ string [] toolVersions
             fatalErrorContext = null;
 
             BuildEventContext buildEventContext;
-               
+
             // Already have an instantiated project in the OM and it has not fired a project started event for itself yet
             if (project?.HaveUsedInitialProjectContextId == false)
             {
@@ -2332,7 +2332,7 @@ string [] toolVersions
                                                 BuildEventContext.InvalidTaskId
                                                 );
             }
-            
+
             // Currently, MSBuild requires that the calling thread be marked "STA" -- single
             // threaded apartment.  This is because today we are calling the tasks' Execute()
             // method on this main thread, and there are tasks out there that create unmarshallable
@@ -2364,7 +2364,7 @@ string [] toolVersions
                     targetOutputsWorkingCopy[i] = new Hashtable(StringComparer.OrdinalIgnoreCase);
                 }
 
-                buildRequests[i] = 
+                buildRequests[i] =
                     CreateLocalBuildRequest(buildEventContext, project, projectFiles[i], targetNames[i],
                                             globalPropertiesPerProject[i], targetOutputsWorkingCopy[i], buildFlags,
                                             toolVersions[i]);
@@ -2437,8 +2437,8 @@ string [] toolVersions
         }
 
         /// <summary>
-        /// Create a build request which will be posted to the local engine queue, having a HandleId of -1 meaning it came from the local 
-        /// engine rather than an engine call back 
+        /// Create a build request which will be posted to the local engine queue, having a HandleId of -1 meaning it came from the local
+        /// engine rather than an engine call back
         /// </summary>
         /// <returns></returns>
         private BuildRequest CreateLocalBuildRequest(BuildEventContext buildEventContext, Project project, string projectFile, string[] targetNames, BuildPropertyGroup globalProperties, IDictionary targetOutputs, BuildSettings buildFlags, string toolsVersion)
@@ -2481,7 +2481,7 @@ private BuildRequest CreateLocalBuildRequest(BuildEventContext buildEventContext
         /// </summary>
         /// <remarks>
         /// If this project file is already in our list of in-progress projects, we use the
-        /// existing Project object instead of instantiating a new one. Always use this method to 
+        /// existing Project object instead of instantiating a new one. Always use this method to
         /// build projects within projects, otherwise the build won't be optimized.
         /// </remarks>
         internal void BuildProjectFileInternal
@@ -2642,7 +2642,7 @@ private void HandleProjectFileInternalException(BuildRequest buildRequest)
         {
             // Flush out all the logging messages, which may have been posted outside target execution
             primaryLoggingServices.ProcessPostedLoggingEvents();
-            
+
             // Mark evaluation as complete
             buildRequest.BuildCompleted = true;
 
@@ -2663,9 +2663,9 @@ private void HandleProjectFileInternalException(BuildRequest buildRequest)
         /// <param name="cachedResult"></param>
         private void ProcessCachedResult
         (
-            BuildRequest buildRequest, 
-            FileInfo projectFileInfo, 
-            ArrayList actuallyBuiltTargets, 
+            BuildRequest buildRequest,
+            FileInfo projectFileInfo,
+            ArrayList actuallyBuiltTargets,
             BuildResult cachedResult
         )
         {
@@ -2853,24 +2853,24 @@ bool toolsVersionPeekedFromProjectFile
 
             return returnProject;
         }
-        
+
         /// <summary>
-        /// When using the MSBuild task to build a child project, we need to figure out the set of 
+        /// When using the MSBuild task to build a child project, we need to figure out the set of
         /// global properties that the child should be built with.  It is a merge of whatever
         /// properties the parent project was being built with, plus whatever properties were
         /// actually passed into the MSBuild task (in the "Properties" parameter).  However,
-        /// the slightly wrinkle is the child project may have actually been one that is 
+        /// the slightly wrinkle is the child project may have actually been one that is
         /// currently loaded in the IDE, and the IDE controls what Configuration/Platform each
         /// project should be built with, so we have to honor that too.  So, the order in which
         /// we look at global properties are:
-        /// 
+        ///
         ///     1.  Whatever global properties the parent project was building with.  (The parent
         ///         project is the one that called the &lt;MSBuild&lt; task.
-        ///     2.  If the child project was already previously loaded by the host, whatever global 
+        ///     2.  If the child project was already previously loaded by the host, whatever global
         ///         properties were sent into the child project by the host (via Project.GlobalProperties).
         ///     3.  Whatever properties were passed into the "Properties" parameter of the &lt;MSBuild&lt;
         ///         task.
-        /// 
+        ///
         /// </summary>
         /// <param name="parentProjectGlobalProperties"></param>
         /// <param name="childProjectFile"></param>
@@ -2895,11 +2895,11 @@ IDictionary globalPropertiesPassedIntoTask
                 // If the project file doesn't actually exist on disk, it's a failure.
                 ErrorUtilities.VerifyThrowArgument(File.Exists(childProjectFile), "ProjectFileNotFound", childProjectFile);
             }
-            
+
             // Create a new BuildPropertyGroup to represent the final set of global properties that we're going to
             // use for the child project.
             BuildPropertyGroup finalGlobalProperties = new BuildPropertyGroup();
-            
+
             // Start with the global properties from the parent project.
             if (postMergeProperties == null)
             {
@@ -2909,7 +2909,7 @@ IDictionary globalPropertiesPassedIntoTask
             {
                 finalGlobalProperties.ImportProperties(postMergeProperties);
             }
-            
+
             // childProjectFile could be null when no Projects were passed into the MSBuild task, which
             // means parentProject == childProject, which means no need to import the same properties again.
             if (childProjectFile != null)
@@ -2927,13 +2927,13 @@ IDictionary globalPropertiesPassedIntoTask
                     finalGlobalProperties.ImportProperties(loadedProjectWithSameFullPath.GlobalProperties);
                 }
             }
-            
+
             // Finally, whatever global properties were passed into the task ... those are the final winners.
             if (globalPropertiesPassedIntoTask != null)
             {
                 foreach (DictionaryEntry newGlobalProperty in globalPropertiesPassedIntoTask)
                 {
-                    finalGlobalProperties.SetProperty((string) newGlobalProperty.Key, 
+                    finalGlobalProperties.SetProperty((string) newGlobalProperty.Key,
                         (string) newGlobalProperty.Value);
                 }
             }
@@ -2975,7 +2975,7 @@ internal TaskExecutionContext GetTaskOutputUpdates()
         }
 
         /// <summary>
-        /// This function collects status about the inprogress targets and engine operations. 
+        /// This function collects status about the inprogress targets and engine operations.
         /// This function should always run from the engine domain because it touch engine data
         /// structures.
         /// </summary>
@@ -2999,7 +2999,7 @@ internal NodeStatus RequestStatus(int requestId)
                     }
                 }
             }
-            TargetInProgessState[] stateOfInProgressTargets = 
+            TargetInProgessState[] stateOfInProgressTargets =
                     new TargetInProgessState[waitingTargets.Length + inProgressTargets.Count];
             for (int i = 0; i < waitingTargets.Length; i++)
             {
diff --git a/src/Deprecated/Engine/Engine/EngineCallback.cs b/src/Deprecated/Engine/Engine/EngineCallback.cs
index 96e658cbd95..0afa060bbbd 100644
--- a/src/Deprecated/Engine/Engine/EngineCallback.cs
+++ b/src/Deprecated/Engine/Engine/EngineCallback.cs
@@ -21,7 +21,7 @@ internal class EngineCallback : IEngineCallback
     {
         #region Constructors
         /// <summary>
-        /// Creates a callback class. There should only be one callback per engine under normal 
+        /// Creates a callback class. There should only be one callback per engine under normal
         /// circumstances.
         /// </summary>
         internal EngineCallback(Engine parentEngine)
@@ -116,7 +116,7 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
                                                                    buildRequest.ProjectFileName,
                                                                    buildRequest.GlobalPropertiesPassedByTask);
                         }
-                        catch (ArgumentException e) 
+                        catch (ArgumentException e)
                         {
                             ConvertToInvalidProjectException(buildRequest, parentProject, e);
                         }
@@ -139,7 +139,7 @@ private void ProcessBuildRequest(BuildRequest buildRequest)
                         // as what is being requested, just re-use it.  Otherwise, we need to instantiate a new
                         // project object that has the same project contents but different global properties.
                         if (!projectToBuild.GlobalProperties.IsEquivalent(buildRequest.GlobalProperties) &&
-                            (String.Compare(parentProject.ToolsVersion, buildRequest.ToolsetVersion, StringComparison.OrdinalIgnoreCase) == 0))
+                            (String.Equals(parentProject.ToolsVersion, buildRequest.ToolsetVersion, StringComparison.OrdinalIgnoreCase)))
                         {
                             projectToBuild = parentEngine.GetMatchingProject(parentProject,
                                                  parentProject.FullFileName, buildRequest.GlobalProperties,
@@ -182,8 +182,8 @@ private static void ConvertToInvalidProjectException(BuildRequest buildRequest,
         /// </summary>
         internal void PostTaskOutputs
         (
-            int handleId, 
-            bool taskExecutedSuccessfully, 
+            int handleId,
+            bool taskExecutedSuccessfully,
             Exception thrownException,
             long executionTime
         )
@@ -208,7 +208,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
 
             // Cache the results
             routingContext.CacheScope.AddCacheEntryForBuildResults(buildResult);
-            
+
             if (Engine.debugMode)
             {
                 Console.WriteLine("Received result for HandleId " + buildResult.HandleId + ":" + buildResult.RequestId + " mapped to " + routingContext.ParentHandleId + ":" + routingContext.ParentRequestId);
@@ -216,7 +216,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
 
             // Update the results with the original handle id and request id, so that 
             buildResult.HandleId = routingContext.ParentHandleId;
-       
+
             // If the build result is created from a generated build request a done notice should be posted as other targets could be waiting for this target to finish
             if (buildResult.HandleId != invalidEngineHandle)
             {
@@ -230,7 +230,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
                 routingContext.TriggeringBuildRequest.BuildCompleted = true;
                 parentEngine.PostEngineCommand(new HostBuildRequestCompletionEngineCommand());
             }
-            
+
             // At this point the execution context we created for the execution of this build request can be deleted
             lock (freedContexts)
             {
@@ -243,7 +243,7 @@ public void PostBuildResultToHost(BuildResult buildResult)
         /// </summary>
         public void SetCacheEntries
         (
-            int handleId, CacheEntry[] entries, 
+            int handleId, CacheEntry[] entries,
             string cacheScope, string cacheKey, string cacheVersion,
             CacheContentType cacheContentType, bool localNodeOnly
         )
@@ -290,13 +290,13 @@ public void SetCacheEntries
                 }
             }
         }
-        
+
         /// <summary>
         /// Called either on the main or child node. This is the routing method for getting cache entries.
         /// </summary>
         public CacheEntry[] GetCacheEntries
         (
-            int handleId, string[] names, 
+            int handleId, string[] names,
             string cacheScope, string cacheKey, string cacheVersion,
             CacheContentType cacheContentType, bool localNodeOnly
         )
@@ -356,7 +356,7 @@ public CacheEntry[] GetCacheEntries
         }
 
         /// <summary>
-        /// Submit the logging message to the engine queue. Note that we are currently not utilizing the 
+        /// Submit the logging message to the engine queue. Note that we are currently not utilizing the
         /// handleId, but plan to do so in the future to fill out the data structure passed to the engine
         /// </summary>
         public void PostLoggingMessagesToHost(int nodeId, NodeLoggingEvent[] nodeLoggingEventArray)
@@ -387,7 +387,7 @@ internal void GetLineColumnOfXmlNode(int handleId, out int lineNumber, out int c
         internal ITaskRegistry GetEngineTaskRegistry(int handleId)
         {
             TaskExecutionContext executionContext = GetTaskContextFromHandleId(handleId);
-            return parentEngine.GetTaskRegistry(executionContext.BuildEventContext, 
+            return parentEngine.GetTaskRegistry(executionContext.BuildEventContext,
                                     executionContext.ParentProject.ToolsVersion);
         }
 
@@ -492,16 +492,16 @@ internal RequestRoutingContext GetRoutingContextFromHandleId(int handleId)
         /// </summary>
         internal int CreateTaskContext
         (
-            Project parentProject, 
+            Project parentProject,
             Target  parentTarget,
             ProjectBuildState buildContext,
-            XmlElement taskNode, 
+            XmlElement taskNode,
             int nodeIndex,
             BuildEventContext taskContext
         )
         {
             int handleId = nextContextId;
-            nextContextId = nextContextId + 1;
+            nextContextId += 1;
 
             TaskExecutionContext executionContext =
                 new TaskExecutionContext(parentProject, parentTarget, taskNode, buildContext, handleId, nodeIndex, taskContext);
@@ -527,10 +527,10 @@ BuildEventContext buildEventContext
         )
         {
             int handleId = nextContextId;
-            nextContextId = nextContextId + 1;
+            nextContextId += 1;
 
             RequestRoutingContext executionContext =
-                new RequestRoutingContext(handleId, nodeIndex, parentHandleId, parentNodeIndex, parentRequestId, 
+                new RequestRoutingContext(handleId, nodeIndex, parentHandleId, parentNodeIndex, parentRequestId,
                                           cacheScope, triggeringBuildRequest, buildEventContext);
 
             executionContexts.Add(handleId, executionContext);
@@ -567,7 +567,7 @@ internal void ClearContextState(int handleId)
 
         #region Constants
         /// <summary>
-        /// Number assigned to an invalid engine handle, This handleId is used by Buildrequests 
+        /// Number assigned to an invalid engine handle, This handleId is used by Buildrequests
         /// to show they are a routing context
         /// </summary>
         internal const int invalidEngineHandle = -1;
diff --git a/src/Deprecated/Engine/Engine/EngineProxy.cs b/src/Deprecated/Engine/Engine/EngineProxy.cs
index b8c5e81117f..828c709fff5 100644
--- a/src/Deprecated/Engine/Engine/EngineProxy.cs
+++ b/src/Deprecated/Engine/Engine/EngineProxy.cs
@@ -46,7 +46,7 @@ internal sealed class EngineProxy : MarshalByRefObject, IBuildEngine3
         private string projectFileOfTaskNode;
 
         /// <summary>
-        /// The token identifing the context of this evaluation 
+        /// The token identifing the context of this evaluation
         /// </summary>
         private int handleId;
 
@@ -56,7 +56,7 @@ internal sealed class EngineProxy : MarshalByRefObject, IBuildEngine3
         private bool continueOnError;
 
         /// <summary>
-        /// The module within which this class has been created. Used for all callbacks to 
+        /// The module within which this class has been created. Used for all callbacks to
         /// engine.
         /// </summary>
         private TaskExecutionModule parentModule;
@@ -102,7 +102,7 @@ private EngineProxy()
         {
             // do nothing
         }
-     
+
         /// <summary>
         /// Create an instance of this class to represent the IBuildEngine2 interface to the task
         /// including the event location where the log messages are raised
@@ -115,10 +115,10 @@ private EngineProxy()
         /// <param name="buildEventContext">Event Context where events will be seen to be raised from. Task messages will get this as their event context</param>
         internal EngineProxy
         (
-            TaskExecutionModule parentModule, 
-            int handleId, 
+            TaskExecutionModule parentModule,
+            int handleId,
             string parentProjectFullFileName,
-            string projectFileOfTaskNode, 
+            string projectFileOfTaskNode,
             EngineLoggingServices loggingServices,
             BuildEventContext buildEventContext
         )
@@ -190,14 +190,14 @@ public void LogErrorEvent(BuildErrorEventArgs e)
                     e = new BuildErrorEventArgs
                         (
                             e.Subcategory,
-                            e.Code, 
-                            e.File, 
-                            e.LineNumber, 
-                            e.ColumnNumber, 
-                            e.EndLineNumber, 
-                            e.EndColumnNumber, 
+                            e.Code,
+                            e.File,
+                            e.LineNumber,
+                            e.ColumnNumber,
+                            e.EndLineNumber,
+                            e.EndColumnNumber,
                             message,  // this is the new message from above
-                            e.HelpKeyword, 
+                            e.HelpKeyword,
                             e.SenderName
                         );
                 }
@@ -250,7 +250,7 @@ public void LogWarningEvent(BuildWarningEventArgs e)
         }
 
         /// <summary>
-        /// 
+        ///
         /// </summary>
         /// <param name="file">File field from the original BuildEventArgs</param>
         /// <param name="message">Message field from the original BuildEventArgs</param>
@@ -430,9 +430,9 @@ IDictionary targetOutputs
         /// <returns>result of call to engine</returns>
         public bool BuildProjectFile
             (
-            string projectFileName, 
-            string[] targetNames, 
-            IDictionary globalProperties, 
+            string projectFileName,
+            string[] targetNames,
+            IDictionary globalProperties,
             IDictionary targetOutputs,
             string toolsVersion
             )
@@ -485,7 +485,7 @@ bool unloadProjectsOnCompletion
         }
 
         /// <summary>
-        /// Not implemented for the proxy 
+        /// Not implemented for the proxy
         /// </summary>
 	public void Yield()
 	{
@@ -504,12 +504,12 @@ public void Reacquire()
         /// <remarks>
         /// 1) it is acceptable to pass null for both <c>targetNames</c> and <c>targetOutputs</c>
         /// 2) if no targets are specified, the default targets are built
-        /// 
+        ///
         /// </remarks>
         /// <param name="projectFileNames">The project to build.</param>
         /// <param name="targetNames">The targets in the project to build (can be null).</param>
         /// <param name="globalProperties">An array of hashtables of additional global properties to apply
-        ///     to the child project (array entries can be null). 
+        ///     to the child project (array entries can be null).
         ///     The key and value in the hashtable should both be strings.</param>
         /// <param name="removeGlobalProperties">A list of global properties which should be removed.</param>
         /// <param name="toolsVersions">A tools version recognized by the Engine that will be used during this build (can be null).</param>
@@ -531,7 +531,7 @@ bool returnTargetOutputs
 
                 ErrorUtilities.VerifyThrowArgumentNull(projectFileNames, "projectFileNames");
                 ErrorUtilities.VerifyThrowArgumentNull(globalProperties, "globalPropertiesPerProject");
-                
+
                 Dictionary<string, ITaskItem[]>[] targetOutputsPerProject = null;
 
                 if (returnTargetOutputs)
@@ -552,7 +552,7 @@ bool returnTargetOutputs
         }
 
         /// <summary>
-        /// InitializeLifetimeService is called when the remote object is activated. 
+        /// InitializeLifetimeService is called when the remote object is activated.
         /// This method will determine how long the lifetime for the object will be.
         /// </summary>
         public override object InitializeLifetimeService()
@@ -573,7 +573,7 @@ public override object InitializeLifetimeService()
                 int leaseTimeFromEnvironment;
                 if (int.TryParse(initialLeaseTimeFromEnvironment , out leaseTimeFromEnvironment) && leaseTimeFromEnvironment > 0)
                 {
-                      initialLeaseTime = leaseTimeFromEnvironment;        
+                      initialLeaseTime = leaseTimeFromEnvironment;
                 }
             }
 
@@ -593,7 +593,7 @@ public override object InitializeLifetimeService()
                 int leaseExtensionFromEnvironment;
                 if (int.TryParse(leaseExtensionTimeFromEnvironment , out leaseExtensionFromEnvironment) && leaseExtensionFromEnvironment > 0)
                 {
-                      leaseExtensionTime = leaseExtensionFromEnvironment;        
+                      leaseExtensionTime = leaseExtensionFromEnvironment;
                 }
             }
 
@@ -618,20 +618,19 @@ internal void MarkAsInActive()
             loggingServices = null;
             parentModule = null;
             buildEventContext = null;
-            
+
             // Clear out the sponsor (who is responsible for keeping the EngineProxy remoting lease alive until the task is done)
             // this will be null if the engineproxy was never sent accross an appdomain boundry.
             if (sponsor != null)
             {
                 ILease lease = (ILease)RemotingServices.GetLifetimeService(this);
-             
                 lease?.Unregister(sponsor);
-                
+
                 sponsor.Close();
                 sponsor = null;
             }
         }
-	
+
         #region Properties
         /// <summary>
         /// Provide a way to change the BuildEventContext of the engine proxy. This is important in batching where each batch will need its own buildEventContext.
diff --git a/src/Deprecated/Engine/Engine/Expander.cs b/src/Deprecated/Engine/Engine/Expander.cs
index 6afa9f5075b..e00a01136da 100644
--- a/src/Deprecated/Engine/Engine/Expander.cs
+++ b/src/Deprecated/Engine/Engine/Expander.cs
@@ -1676,7 +1676,7 @@ private static void AddArgument(List<string> arguments, StringBuilder argumentBu
                 // to our arguments. 
                 string argValue = argumentBuilder.ToString().Trim();
                 // We support passing of null through the argument constant value null
-                if (String.Compare("null", argValue, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals("null", argValue, StringComparison.OrdinalIgnoreCase))
                 {
                     arguments.Add(null);
                 }
diff --git a/src/Deprecated/Engine/Engine/Node.cs b/src/Deprecated/Engine/Engine/Node.cs
index 8dff72ee5b9..5881de4307c 100644
--- a/src/Deprecated/Engine/Engine/Node.cs
+++ b/src/Deprecated/Engine/Engine/Node.cs
@@ -29,8 +29,8 @@ internal class Node
         /// </summary>
         internal Node
         (
-            int nodeId, 
-            LoggerDescription[] nodeLoggers, 
+            int nodeId,
+            LoggerDescription[] nodeLoggers,
             IEngineCallback parentCallback,
             BuildPropertyGroup parentGlobalProperties,
             ToolsetDefinitionLocations toolsetSearchLocations,
@@ -127,7 +127,7 @@ internal void PostBuildRequestToHost(BuildRequest currentRequest)
             TaskExecutionContext taskExecutionContext = localEngine.EngineCallback.GetTaskContextFromHandleId(currentRequest.HandleId);
             while (!taskExecutionContext.BuildContext.BuildRequest.IsExternalRequest)
             {
-                ErrorUtilities.VerifyThrow(taskExecutionContext.BuildContext.BuildRequest.IsGeneratedRequest, 
+                ErrorUtilities.VerifyThrow(taskExecutionContext.BuildContext.BuildRequest.IsGeneratedRequest,
                                            "Must be a generated request");
 
                 taskExecutionContext =
@@ -214,7 +214,7 @@ internal void PostStatus(NodeStatus nodeStatus, bool blockUntilSent)
 
         /// <summary>
         /// A variation of PostStatus that throws instead of calling ReportUnhandledError
-        /// if there's a problem. This allows ReportUnhandledError itself to post status 
+        /// if there's a problem. This allows ReportUnhandledError itself to post status
         /// without the possibility of a loop.
         /// </summary>
         internal void PostStatusThrow(NodeStatus nodeStatus, bool blockUntilSent)
@@ -251,7 +251,7 @@ BuildRequest buildRequest
                             launchedEngineLoopThread = true;
                             ThreadStart threadState = new ThreadStart(this.NodeLocalEngineLoop);
                             Thread taskThread = new Thread(threadState);
-                            taskThread.Name = "MSBuild Child Engine";                            
+                            taskThread.Name = "MSBuild Child Engine";
                             taskThread.SetApartmentState(ApartmentState.STA);
                             taskThread.Start();
                         }
@@ -305,7 +305,7 @@ internal void PostBuildResult(BuildResult buildResult)
                 buildResult.HandleId = nodeRequestMapping.HandleId;
                 buildResult.RequestId = nodeRequestMapping.RequestId;
                 nodeRequestMapping.AddResultToCache(buildResult);
-                
+
                 // posts the result to the inproc node
                 localEngine.Router.PostDoneNotice(0, buildResult);
             }
diff --git a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
index d32de91db4e..e920e05c323 100644
--- a/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
+++ b/src/Deprecated/Engine/Engine/NodeLoggingEvent.cs
@@ -199,7 +199,7 @@ internal virtual void WriteToStream(BinaryWriter writer, Hashtable loggingTypeCa
                 else
                 {
                     // The customer serialization methods are not availiable, default to .net serialization
-                    writer.BaseStream.Position = writer.BaseStream.Position - 1;
+                    writer.BaseStream.Position -= 1;
                     writer.Write((byte)0);
                     binaryFormatter.Serialize(writer.BaseStream, e);
                 }
diff --git a/src/Deprecated/Engine/Engine/NodeManager.cs b/src/Deprecated/Engine/Engine/NodeManager.cs
index fe60e2a2a1b..b850e2bcc9f 100644
--- a/src/Deprecated/Engine/Engine/NodeManager.cs
+++ b/src/Deprecated/Engine/Engine/NodeManager.cs
@@ -135,7 +135,7 @@ internal NodeStatus[] RequestStatusForNodes(int responseTimeout)
                     // Calculate the time remaining and only continue if there is time left
                     TimeSpan timeSpent = new TimeSpan(DateTime.Now.Ticks - startTime);
                     startTime = DateTime.Now.Ticks;
-                    responseTimeout = responseTimeout - (int)timeSpent.TotalMilliseconds;
+                    responseTimeout -= (int)timeSpent.TotalMilliseconds;
                     if (responseTimeout <= 0)
                     {
                         Console.WriteLine("Response time out out exceeded :" + DateTime.Now.Ticks);
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index 6b8f1746e70..064ca7d6b4f 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -49,7 +49,7 @@ public enum PropertyPosition
         /// </summary>
         UseExistingOrCreateAfterLastImport = 1
     };
-    
+
     /// <summary>
     /// Whether we are in the first (properties) pass, or the second (items) pass.
     /// </summary>
@@ -62,7 +62,7 @@ internal enum ProcessingPass
         /// <summary>
         /// Second pass (evaluating items)
         /// </summary>
-        Pass2        
+        Pass2
     };
 
     /// <summary>
@@ -316,7 +316,7 @@ public class Project
 
         /// <summary>
         /// Items need the project directory in order to evaluate their built-in
-        /// metadata (like "%(FullPath)") when their itemspec is relative. We store this 
+        /// metadata (like "%(FullPath)") when their itemspec is relative. We store this
         /// here in thread-local-storage because we cannot modify the public constructors
         /// to require it, and also it can change during the life of a BuildItem
         /// (when the item is passed to another project).
@@ -595,7 +595,7 @@ public string DefaultTargets
         }
 
         /// <summary>
-        /// Returns the array of actual target names that will be built by default. First choice is 
+        /// Returns the array of actual target names that will be built by default. First choice is
         /// the defaultTargets attribute on the Project node, if not present we fall back to the first target
         /// in the project file. Return value is null if there are no targets in the project file.
         /// </summary>
@@ -623,7 +623,7 @@ internal string[] DefaultBuildTargets
         /// Read-write accessor for the "InitialTargets" attribute of the
         /// &lt;Project&gt; element.  This is passed in and out as a semicolon-separated
         /// list of target names.  The "get" returns all of the initial targets in both
-        /// the main project and all imported projects (after property expansion).  The 
+        /// the main project and all imported projects (after property expansion).  The
         /// "set" only sets the initial targets for the main project.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -792,12 +792,12 @@ public bool BuildEnabled
 
         /// <summary>
         /// When gotten, returns the effective tools version being used by this project.
-        /// If the tools version is being overridden, the overriding value will be the effective tools version. 
-        /// Otherwise, if there is a ToolsVersion attribute on the Project element, that is the effective tools version. 
+        /// If the tools version is being overridden, the overriding value will be the effective tools version.
+        /// Otherwise, if there is a ToolsVersion attribute on the Project element, that is the effective tools version.
         /// Otherwise, the default tools version of the parent engine is the effective tools version.
-        /// 
+        ///
         /// When set, overrides the current tools version of this project with the provided value.
-        /// 
+        ///
         /// NOTE: This is distinct to the ToolsVersion attribute, if any, on the Project element.
         /// To get and set the ToolsVersion attribute on the Project element use the Project.DefaultToolsVersion
         /// property.
@@ -843,14 +843,14 @@ internal bool OverridingToolsVersion
         }
 
         /// <summary>
-        /// Public read-write accessor for the ToolsVersion xml attribute found on the 
+        /// Public read-write accessor for the ToolsVersion xml attribute found on the
         /// &lt;Project /&gt; element.  If this attribute is not present on the &lt;Project/&gt;
         /// element, getting the value will return the default tools version of the parent Engine.
-        /// 
+        ///
         /// NOTE: This value is distinct from the effective tools version used during a build,
         /// as that value may be overridden during construction of the Project instance or
-        /// by setting the Project.ToolsVersion property. Setting this attribute value will not change the 
-        /// effective tools version if it has been overridden. To change the effective tools version, 
+        /// by setting the Project.ToolsVersion property. Setting this attribute value will not change the
+        /// effective tools version if it has been overridden. To change the effective tools version,
         /// set the Project.ToolsVersion property.
         /// </summary>
         public string DefaultToolsVersion
@@ -901,7 +901,7 @@ public string DefaultToolsVersion
                 // version is actually valid
                 ProjectElement.SetAttribute(XMakeAttributes.toolsVersion, value);
 
-                if (overridingToolsVersion == false)
+                if (!overridingToolsVersion)
                 {
                     this.toolsVersion = DefaultToolsVersion;
                 }
@@ -958,7 +958,7 @@ internal ITaskRegistry TaskRegistry
         }
 
         /// <summary>
-        /// The project directory where the project file is in, this can be empty if the project is constructed in memory and does 
+        /// The project directory where the project file is in, this can be empty if the project is constructed in memory and does
         /// not come from a file location
         /// </summary>
         internal string ProjectDirectory
@@ -1445,7 +1445,7 @@ private void SetDefaultTargets(string defaultTargetsList, BuildPropertyGroup pro
 
         /// <summary>
         /// Determines whether a project file can be considered equivalent to this Project, taking into account
-        /// the set of global properties and the tools version (if any) that that project file 
+        /// the set of global properties and the tools version (if any) that that project file
         /// is going to be built with.
         /// </summary>
         /// <param name="projectFullPath"></param>
@@ -1454,7 +1454,7 @@ private void SetDefaultTargets(string defaultTargetsList, BuildPropertyGroup pro
         /// <returns></returns>
         internal bool IsEquivalentToProject(string projectFullPath, BuildPropertyGroup projectGlobalProperties, string projectToolsVersion)
         {
-            if (String.Compare(projectFullPath, this.FullFileName, StringComparison.OrdinalIgnoreCase) != 0)
+            if (!String.Equals(projectFullPath, this.FullFileName, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
@@ -1468,7 +1468,7 @@ internal bool IsEquivalentToProject(string projectFullPath, BuildPropertyGroup p
                 projectToolsVersion = this.DefaultToolsVersion;
             }
 
-            return (String.Compare(ToolsVersion, projectToolsVersion, StringComparison.OrdinalIgnoreCase) == 0
+            return (String.Equals(ToolsVersion, projectToolsVersion, StringComparison.OrdinalIgnoreCase)
                 && this.GlobalProperties.IsEquivalent(projectGlobalProperties));
         }
 
@@ -1667,7 +1667,7 @@ private void SetProjectFileReservedProperties
             this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.programFiles32,
                     FrameworkLocationHelper.programFiles32, PropertyType.ReservedProperty));
 
-            this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.assemblyVersion, 
+            this.ReservedProperties.SetProperty(new BuildProperty(ReservedPropertyNames.assemblyVersion,
                     Constants.AssemblyVersion, PropertyType.ReservedProperty));
 
             if (this.fullFileName.Length == 0)
@@ -2077,7 +2077,7 @@ private void InternalLoadFromXmlDocument(XmlDocument projectXml, ProjectLoadSett
                 ProjectErrorUtilities.VerifyThrowInvalidProject(this.mainProjectElement.LocalName == XMakeElements.project,
                     this.mainProjectElement, "UnrecognizedElement", this.mainProjectElement.Name);
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject((mainProjectElement.Prefix.Length == 0) && (String.Compare(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0),
+                ProjectErrorUtilities.VerifyThrowInvalidProject((mainProjectElement.Prefix.Length == 0) && (String.Equals(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase)),
                     mainProjectElement, "ProjectMustBeInMSBuildXmlNamespace", XMakeAttributes.defaultXmlNamespace);
 
                 MarkProjectAsDirtyForReprocessXml();
@@ -2143,7 +2143,7 @@ Encoding encoding
 
                 // Update the project filename/path if it has changed.
                 string newFullProjectFilePath = Path.GetFullPath(projectFileName);
-                if (0 != String.Compare(newFullProjectFilePath, this.FullFileName, StringComparison.OrdinalIgnoreCase))
+                if (!String.Equals(newFullProjectFilePath, this.FullFileName, StringComparison.OrdinalIgnoreCase))
                 {
                     this.FullFileName = newFullProjectFilePath;
                 }
@@ -2358,7 +2358,7 @@ PropertyPosition position
         }
 
         /// <summary>
-        /// Sets a property, and optionally escapes it so that it will be treated as a literal 
+        /// Sets a property, and optionally escapes it so that it will be treated as a literal
         /// value despite any special characters that may be in it.
         /// </summary>
         /// <param name="propertyName"></param>
@@ -2376,7 +2376,7 @@ public void SetProperty
             bool treatPropertyValueAsLiteral
             )
         {
-            this.SetProperty(propertyName, 
+            this.SetProperty(propertyName,
                 treatPropertyValueAsLiteral ? EscapingUtilities.Escape(propertyValue) : propertyValue,
                 condition, position);
         }
@@ -2554,8 +2554,8 @@ ref BuildProperty matchingProperty
                 }
 
                 if (propertyGroup.IsImported == importedPropertyGroup &&
-                    (0 == String.Compare(propertyGroup.Condition.Trim(), condition.Trim(), StringComparison.OrdinalIgnoreCase)) &&
-                    (!importedPropertyGroup || (importedPropertyGroup && (0 == String.Compare(propertyGroup.ImportedFromFilename, importedFilename, StringComparison.OrdinalIgnoreCase)))))
+                    (String.Equals(propertyGroup.Condition.Trim(), condition.Trim(), StringComparison.OrdinalIgnoreCase)) &&
+                    (!importedPropertyGroup || (importedPropertyGroup && (String.Equals(propertyGroup.ImportedFromFilename, importedFilename, StringComparison.OrdinalIgnoreCase)))))
                 {
                     if (matchingPropertyGroup == null)
                     {
@@ -2570,7 +2570,7 @@ ref BuildProperty matchingProperty
                     // property.
                     foreach (BuildProperty property in propertyGroup)
                     {
-                        if (0 == String.Compare(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
+                        if (String.Equals(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
                         {
                             matchingProperty = property;
                         }
@@ -2803,7 +2803,7 @@ string itemInclude
                     // the same type as the new item being added.
                     foreach (BuildItem originalItem in itemGroup)
                     {
-                        if ( 0 == String.Compare( originalItem.Name, itemName, StringComparison.OrdinalIgnoreCase))
+                        if ( String.Equals( originalItem.Name, itemName, StringComparison.OrdinalIgnoreCase))
                         {
                             // If the new item that the user is trying to add is already covered by 
                             // a wildcard in an existing item of the project, then there's really
@@ -3165,7 +3165,7 @@ public bool Build
             string targetName
             )
         {
-            return this.ParentEngine.BuildProject(this, (targetName == null) ? null : new string[] {targetName}, 
+            return this.ParentEngine.BuildProject(this, (targetName == null) ? null : new string[] {targetName},
                 null, BuildSettings.None);
         }
 
@@ -3520,7 +3520,7 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
             ProjectBuildState buildContext = null;
 
             string[] targetNamesToBuild = buildRequest.TargetNames;
-            
+
             // Initialize to the parent requests project context id
             int projectContextId = buildRequest.ParentBuildEventContext.ProjectContextId;
 
@@ -3565,7 +3565,7 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
                 // Only log the project started event after making sure the project is reevaluated if necessary,
                 // otherwise we could log stale item/property information.
                 if (!ParentEngine.LoggingServices.OnlyLogCriticalEvents && buildRequest.FireProjectStartedFinishedEvents)
-                {  
+                {
                     string joinedTargetNamesToBuild = null;
                     if (targetNamesToBuild?.Length > 0)
                     {
@@ -3608,7 +3608,7 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
                     BuildItemGroupProxy itemsProxy = new BuildItemGroupProxy(this.evaluatedItems);
 
                     ParentEngine.LoggingServices.LogProjectStarted(this.projectId, buildRequest.ParentBuildEventContext, buildEventContext, FullFileName, joinedTargetNamesToBuild, propertiesProxy, itemsProxy);
-                    
+
                     // See comment on DefaultToolsVersion setter.
                     if (treatinghigherToolsVersionsAs40)
                     {
@@ -3730,7 +3730,7 @@ private void ProcessMainProjectElement
             // Technically, this belongs in ProcessProjectAttributes. However, ToolsVersion
             // affects strategic reserved properties, so it's better to process it before anything else happens
             ProcessToolsVersionDependentProperties();
-            
+
             if (IsValidated)
             {
                 // Validate the project schema. If we have a file, then validate that
@@ -3765,12 +3765,12 @@ private void ProcessMainProjectElement
             // variables ... so we need to set these up early.
             this.evaluatedProperties.Clear();
             this.evaluatedProperties.ImportInitialProperties(this.EnvironmentProperties, this.ReservedProperties, this.Toolset.BuildProperties, this.GlobalProperties);
-            
+
             // Process the attributes of the <project> element.
             ProcessProjectAttributes(this.mainProjectElement, false);
 
             // Figure out where the project is located
-            this.projectDirectory = !string.IsNullOrEmpty(this.fullFileName) ? 
+            this.projectDirectory = !string.IsNullOrEmpty(this.fullFileName) ?
                 Path.GetDirectoryName(this.fullFileName) : Directory.GetCurrentDirectory();
 
             // Process the child elements of the <Project> element, instantiating
@@ -4045,8 +4045,8 @@ bool        importedProject
                 // Do not expand properties or items before passing in the value of the
                 // condition attribute to EvaluateCondition, otherwise special characters
                 // inside the property values can really confuse the condition parser.
-                if (!Utilities.EvaluateCondition(temp.Condition, temp.ConditionAttribute, 
-                    new Expander(this.evaluatedProperties), this.conditionedPropertiesTable, 
+                if (!Utilities.EvaluateCondition(temp.Condition, temp.ConditionAttribute,
+                    new Expander(this.evaluatedProperties), this.conditionedPropertiesTable,
                     ParserOptions.AllowProperties, ParentEngine.LoggingServices, projectBuildEventContext))
                 {
                     return;
@@ -4058,14 +4058,14 @@ bool        importedProject
 
             // Expand any $(propertyname) references inside the "Project" attribute value.
             string expandedImportedFilename = (new Expander(this.evaluatedProperties)).ExpandAllIntoStringLeaveEscaped(temp.ProjectPath, temp.ProjectPathAttribute);
-            
+
             // Expand any wildcards
             string[] importedFilenames = EngineFileUtilities.GetFileListEscaped(projectDirectoryLocation, expandedImportedFilename);
 
             for (int i = 0; i < importedFilenames.Length; i++)
             {
                 string importedFilename = EscapingUtilities.UnescapeAll(importedFilenames[i]);
-                         
+
                 ProjectErrorUtilities.VerifyThrowInvalidProject((importedFilename != null) && (importedFilename.Length != 0),
                     importElement, "MissingRequiredAttribute",
                     XMakeAttributes.project, XMakeElements.import);
@@ -4117,7 +4117,7 @@ bool        importedProject
                             ProjectErrorUtilities.VerifyThrowInvalidProject(importedChildNode.LocalName == XMakeElements.project,
                                 importedChildNode, "UnrecognizedElement", importedChildNode.Name);
 
-                            ProjectErrorUtilities.VerifyThrowInvalidProject((importedChildNode.Prefix.Length == 0) && (String.Compare(importedChildNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0),
+                            ProjectErrorUtilities.VerifyThrowInvalidProject((importedChildNode.Prefix.Length == 0) && (String.Equals(importedChildNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase)),
                                 importedChildNode, "ProjectMustBeInMSBuildXmlNamespace", XMakeAttributes.defaultXmlNamespace);
 
                             // We have the <Project> element, so process it.
@@ -4159,7 +4159,7 @@ private XmlDocument LoadImportedProject(Import import)
             // also prevents the same file from being imported twice, even it it's not a
             // circular dependency, but that's fine -- no good reason to do that anyway.
             if ((this.imports[import.EvaluatedProjectPath] != null) ||
-                (string.Compare(this.FullFileName, import.EvaluatedProjectPath, StringComparison.OrdinalIgnoreCase) == 0))
+                (string.Equals(this.FullFileName, import.EvaluatedProjectPath, StringComparison.OrdinalIgnoreCase)))
             {
                 ParentEngine.LoggingServices.LogWarning(projectBuildEventContext, Utilities.CreateBuildEventFileInfo(import.ProjectPathAttribute, FullFileName),
                     "DuplicateImport", import.EvaluatedProjectPath);
@@ -4184,7 +4184,7 @@ private XmlDocument LoadImportedProject(Import import)
                         // look up the engine's cache to see if we've already loaded this imported project on behalf of another
                         // top-level project
                         ImportedProject previouslyImportedProject = (ImportedProject)ParentEngine.ImportedProjectsCache[import.EvaluatedProjectPath];
-                        
+
                         // if this project hasn't been imported before, or if it has changed on disk, we need to load it
                         if ((previouslyImportedProject?.HasChangedOnDisk(import.EvaluatedProjectPath) != false))
                         {
@@ -4251,7 +4251,7 @@ internal void OnRenameOfImportedFile(string oldFileName, string newFileName)
                 {
                     // ... then check the filename of the PropertyGroup to see if it
                     // matches the *old* file name.
-                    if (0 == String.Compare(pg.ImportedFromFilename, oldFileName, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(pg.ImportedFromFilename, oldFileName, StringComparison.OrdinalIgnoreCase))
                     {
                         // Okay, we found a PropertyGroup that appears to have originated from
                         // the imported file that just got renamed.  We should update the PropertyGroup
@@ -4429,7 +4429,7 @@ private void EvaluateAllUsingTasks()
         }
 
         /// <summary>
-        /// Adds an item to the appropriate project's evaluated items collection.  This method is 
+        /// Adds an item to the appropriate project's evaluated items collection.  This method is
         /// NOT to be used during the build process to add items that are emitted by tasks.
         /// This is only for the purposes of adding statically-declared items in the logical
         /// project file, or items added to the project file by an IDE modifying the project contents.
@@ -4456,7 +4456,7 @@ internal void AddToItemListByNameIgnoringCondition(BuildItem item)
         }
 
         /// <summary>
-        /// Adds an item to the appropriate project's evaluated items collection.  This method is 
+        /// Adds an item to the appropriate project's evaluated items collection.  This method is
         /// NOT to be used during the build process to add items that are emitted by tasks.
         /// This is only for the purposes of adding statically-declared items in the logical
         /// project file, or items added to the project file by an IDE modifying the project contents.
@@ -4491,7 +4491,7 @@ internal void AddToItemListByName(BuildItem item)
         /// <owner>jomof</owner>
         internal static bool IsSolutionFilename(string filename)
         {
-            return (string.Compare(Path.GetExtension(filename), ".sln", StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(Path.GetExtension(filename), ".sln", StringComparison.OrdinalIgnoreCase));
         }
 
         /// <summary>
@@ -4500,7 +4500,7 @@ internal static bool IsSolutionFilename(string filename)
         /// <owner>LukaszG</owner>
         internal static bool IsVCProjFilename(string filename)
         {
-            return (string.Compare(Path.GetExtension(filename), ".vcproj", StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(Path.GetExtension(filename), ".vcproj", StringComparison.OrdinalIgnoreCase));
         }
     }
 }
diff --git a/src/Deprecated/Engine/Engine/ProjectBuildState.cs b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
index 1e77263e737..72de222753b 100644
--- a/src/Deprecated/Engine/Engine/ProjectBuildState.cs
+++ b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
@@ -138,7 +138,7 @@ internal string GetNextTarget()
         {
             if ((indexOfTargetInProgress + 1) < targetNamesToBuild.Count)
             {
-                indexOfTargetInProgress = indexOfTargetInProgress + 1;
+                indexOfTargetInProgress += 1;
                 return (string)targetNamesToBuild[indexOfTargetInProgress];
             }
             else
@@ -209,7 +209,7 @@ internal bool ContainsCycle(string name)
             if (!containsCycle && requiredTargets?.Count > 0)
             {
                 containsCycle = 
-                    (String.Compare(name, (string)targetNamesToBuild[indexOfTargetInProgress], StringComparison.OrdinalIgnoreCase) == 0);
+                    (String.Equals(name, (string)targetNamesToBuild[indexOfTargetInProgress], StringComparison.OrdinalIgnoreCase));
             }
             return containsCycle;
         }
diff --git a/src/Deprecated/Engine/Engine/ProjectManager.cs b/src/Deprecated/Engine/Engine/ProjectManager.cs
index 7b5a6917d02..ba497699405 100644
--- a/src/Deprecated/Engine/Engine/ProjectManager.cs
+++ b/src/Deprecated/Engine/Engine/ProjectManager.cs
@@ -396,7 +396,7 @@ internal static ProjectEntry GetProjectEntry(Hashtable entryTable, string projec
                 // Loop through them and find the one with the matching set of global properties.
                 foreach (ProjectEntry projectEntry in projectsWithFullPath)
                 {
-                    if ((String.Compare(projectEntry.toolsVersion, toolsVersion, StringComparison.OrdinalIgnoreCase) == 0) &&
+                    if ((String.Equals(projectEntry.toolsVersion, toolsVersion, StringComparison.OrdinalIgnoreCase)) &&
                         projectEntry.globalProperties.IsEquivalent(globalProperties))
                     {
                         return projectEntry;
diff --git a/src/Deprecated/Engine/Engine/Scheduler.cs b/src/Deprecated/Engine/Engine/Scheduler.cs
index 32a7cf4770b..d2a36cab2cf 100644
--- a/src/Deprecated/Engine/Engine/Scheduler.cs
+++ b/src/Deprecated/Engine/Engine/Scheduler.cs
@@ -156,11 +156,11 @@ internal int CalculateNodeForBuildRequest(BuildRequest currentRequest, int nodeI
                         }
                         #endregion
                     }
-                    else 
+                    else
                     {
                         // round robin schedule the build request 
                         nodeUsed = (lastUsedNode % nodes.Length);
-                        
+
                         // Running total of the number of times this round robin scheduler has been called
                         lastUsedNode++;
 
@@ -209,7 +209,7 @@ internal void NotifyOfSchedulingDecision(BuildRequest currentRequest, int nodeUs
             // Update the records
             ScheduleRecordKey recordKey = new ScheduleRecordKey(currentRequest.HandleId, currentRequest.RequestId);
             ScheduleRecordKey parentKey = new ScheduleRecordKey(currentRequest.ParentHandleId, currentRequest.ParentRequestId);
-            ScheduleRecord record = new ScheduleRecord(recordKey, parentKey, nodeUsed, currentRequest.ProjectFileName, 
+            ScheduleRecord record = new ScheduleRecord(recordKey, parentKey, nodeUsed, currentRequest.ProjectFileName,
                                                        currentRequest.ToolsetVersion, currentRequest.TargetNames);
 
             lock (scheduleTableLock)
@@ -265,7 +265,7 @@ internal void NotifyOfBuildResult(int nodeId, BuildResult buildResult)
                         ErrorUtilities.VerifyThrow(handleIdToScheduleRecord.ContainsKey(scheduleRecord.ParentKey),
                                                    "Parent schedule record should be in the table");
                         ScheduleRecord parentRecord = handleIdToScheduleRecord[scheduleRecord.ParentKey];
-                        
+
                         // As long as there are child requests under the parent request the parent request is considered blocked
                         // Remove this build request from the list of requests the parent request is waiting on. This may unblock the parent request
                         parentRecord.ReportChildCompleted(recordKey);
@@ -283,14 +283,14 @@ internal void NotifyOfBuildResult(int nodeId, BuildResult buildResult)
                 if (parentEngine.ProfileBuild && scheduleRecord != null && buildResult.TaskTime != 0 )
                 {
                     Console.WriteLine("N " + scheduleRecord.EvaluationNode + " Name " + scheduleRecord.ProjectName + ":" +
-                                      scheduleRecord.ParentKey.HandleId + ":" + scheduleRecord.ParentKey.RequestId + 
+                                      scheduleRecord.ParentKey.HandleId + ":" + scheduleRecord.ParentKey.RequestId +
                                       " Total " + buildResult.TotalTime + " Engine " + buildResult.EngineTime + " Task " + buildResult.TaskTime);
                 }
             }
         }
 
         /// <summary>
-        /// Called when the engine is in the process of sending a buildRequest to a child node. The entire purpose of this method 
+        /// Called when the engine is in the process of sending a buildRequest to a child node. The entire purpose of this method
         /// is to switch the traversal strategy of the systems if there are nodes which do not have enough work availiable to them.
         /// </summary>
         internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, int parentHandleId)
@@ -315,14 +315,14 @@ internal void NotifyOfBuildRequest(int nodeIndex, BuildRequest currentRequest, i
                         }
                     }
 
-                    if (useBreadthFirstTraversal == false)
+                    if (!useBreadthFirstTraversal)
                     {
                         if (Engine.debugMode)
                         {
                              Console.WriteLine("Switching to depth first traversal because all node have workitems");
                         }
                         parentEngine.NodeManager.TaskExecutionModule.UseBreadthFirstTraversal = false;
-                        
+
                         // Switch to depth first and change the traversal strategy of the entire system by notifying all child nodes of the change
                         parentEngine.PostEngineCommand(new ChangeTraversalTypeCommand(false, false));
                     }
@@ -410,7 +410,7 @@ internal void DumpState()
         #region Data
 
         /// <summary>
-        /// NodeId of the engine who instantiated the scheduler. This is used to determine if a 
+        /// NodeId of the engine who instantiated the scheduler. This is used to determine if a
         /// BuildRequest should be build locally as the project has already been loaded on this node.
         /// </summary>
         private int localNodeId;
@@ -428,10 +428,10 @@ internal void DumpState()
         private int[] totalRequestsPerNode;
 
         /// <summary>
-        /// The number of BuildRequests blocked waiting for results for each node. 
+        /// The number of BuildRequests blocked waiting for results for each node.
         /// This will be incremented once when a build request is scheduled which was generated as part of a msbuild callback
         /// and once for each call to NotifyOfBlockedRequest.
-        /// 
+        ///
         /// It is decremented for each call to NotifyOfUnblockedRequest and once all of the child requests have been fullfilled.
         /// </summary>
         private int[] blockedRequestsPerNode;
@@ -458,8 +458,8 @@ internal void DumpState()
         private Dictionary<ScheduleRecordKey, ScheduleRecord> handleIdToScheduleRecord;
 
         /// <summary>
-        /// Indicates the scheduler is instantiated on a child node. This is being determined by 
-        /// initializaing the variable to true in the constructor and then setting it to false in the 
+        /// Indicates the scheduler is instantiated on a child node. This is being determined by
+        /// initializaing the variable to true in the constructor and then setting it to false in the
         /// initialize method (the initialize method will only be called on the parent engine)
         /// </summary>
         private bool childMode;
@@ -474,7 +474,6 @@ internal void DumpState()
         /// </summary>
         private const int nodeWorkLoadProjectCount = 4;
 
-        
         /// <summary>
         /// Used to calculate which node a build request should be sent to if the scheduler is operating in a round robin fashion.
         /// Each time a build request is scheduled to a node in CalculateNodeForBuildRequest the lastUsedNode is incremented.
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index bfdf1d5d8d9..ea7489b7b76 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -600,7 +600,7 @@ ProjectBuildState buildContext
                          buildContext.NameOfBlockingTarget == null))
                     {
                         error.VerifyThrow(
-                            String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), this.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                            String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), this.Name, StringComparison.OrdinalIgnoreCase),
                             "The name of the target in progress is inconsistent with the target being built");
 
                         error.VerifyThrow(targetOutputItems != null,
diff --git a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
index d9456bffd51..2844e472df7 100644
--- a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
+++ b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
@@ -576,7 +576,7 @@ private void InitializeForRunningSingleTargetBatch()
                 // if we're doing an incremental build, we need to effectively run the task twice -- once
                 // to infer the outputs for up-to-date input items, and once to actually execute the task;
                 // as a result we need separate sets of item and property collections to track changes
-                if (howToBuild == DependencyAnalysisResult.IncrementalBuild)    
+                if (howToBuild == DependencyAnalysisResult.IncrementalBuild)
                 {
                     // subset the relevant items to those that are up-to-date
                     foreach (DictionaryEntry upToDateTargetInputsEntry in upToDateTargetInputs)
@@ -713,7 +713,7 @@ private TaskExecutionMode DetermineExecutionMode()
             if ((howToBuild == DependencyAnalysisResult.FullBuild) ||
                 (howToBuild == DependencyAnalysisResult.IncrementalBuild))
             {
-                executionMode = executionMode | TaskExecutionMode.ExecuteTaskAndGatherOutputs;
+                executionMode |= TaskExecutionMode.ExecuteTaskAndGatherOutputs;
             }
             return executionMode;
         }
@@ -740,7 +740,7 @@ private void ExecuteIntrinsicTask(XmlElement taskNode)
             BuildEventContext buildEventContext = PrepareBuildEventContext(true);
             TaskExecutionMode executionMode = DetermineExecutionMode();
 
-            IntrinsicTask task = new IntrinsicTask(taskNode, 
+            IntrinsicTask task = new IntrinsicTask(taskNode,
                                                    parentEngine.LoggingServices,
                                                    buildEventContext,
                                                    parentProject.ProjectDirectory,
@@ -826,10 +826,10 @@ private void ProcessTaskOutputs(TaskExecutionContext executionContext)
                             // by bad user input), the build should be terminated. The exception
                             // will be logged as a fatal build error in engine. The exceptions caused
                             // by user code are converted into LogFatalTaskError messages by the TaskEngine
-                            RemoteErrorException.Throw(executionContext.ThrownException, 
-                                                       targetBuildEventContext, 
+                            RemoteErrorException.Throw(executionContext.ThrownException,
+                                                       targetBuildEventContext,
                                                        "RemoteErrorDuringTaskExecution",
-                                                       parentProject.FullFileName, 
+                                                       parentProject.FullFileName,
                                                        targetClass.Name);
                         }
                     }
@@ -889,7 +889,7 @@ private void FinishRunningTargetBatches(ProjectBuildState buildContext)
             foreach (ItemBucket bucket in buckets)
             {
                 bucket.Lookup.LeaveScope();
-            }         
+            }
 
             // and also leave the extra scope we created with the cloned project items
             projectContent.LeaveScope();
@@ -909,7 +909,7 @@ private void FinishRunningTargetBatches(ProjectBuildState buildContext)
                     buildContext.NameOfBlockingTarget == null)
                 {
                     ErrorUtilities.VerifyThrow(
-                        String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                        String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase),
                         "The name of the target in progress is inconsistent with the target being built");
 
                     ErrorUtilities.VerifyThrow(targetOutputItems != null,
@@ -979,7 +979,7 @@ internal List<ProjectBuildState> GetWaitingBuildContexts()
         }
 
         /// <summary>
-        /// Iterate over the contexts waiting for the target - triggering updates for each of them since the target 
+        /// Iterate over the contexts waiting for the target - triggering updates for each of them since the target
         /// is complete
         /// </summary>
         internal void NotifyWaitingTargets(ProjectBuildState errorContext)
@@ -1008,7 +1008,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 {
                     continue;
                 }
-                
+
                 parentEngine.Scheduler.NotifyOfUnblockedRequest(buildContext.BuildRequest);
 
                 ErrorUtilities.VerifyThrow(
@@ -1019,7 +1019,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 if (buildContext.NameOfBlockingTarget == null)
                 {
                     ErrorUtilities.VerifyThrow(
-                        String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                        String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), targetClass.Name, StringComparison.OrdinalIgnoreCase),
                         "The name of the target in progress is inconsistent with the target being built");
 
                     // This target was part of a sequential request so we need to notify the parent project
@@ -1035,7 +1035,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                     // The target on the waiting list must be waiting for this target to complete due to
                     // a dependent or onerror relationship between targets
                     ErrorUtilities.VerifyThrow(
-                        String.Compare(buildContext.NameOfBlockingTarget, targetClass.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                        String.Equals(buildContext.NameOfBlockingTarget, targetClass.Name, StringComparison.OrdinalIgnoreCase),
                         "This target should only be updated once the dependent target is completed");
 
                     if (Engine.debugMode)
@@ -1045,8 +1045,8 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 }
 
                 // Post a dummy context to the queue to cause the target to run in this context
-                TaskExecutionContext taskExecutionContext = 
-                    new TaskExecutionContext(parentProject, null, null, buildContext, 
+                TaskExecutionContext taskExecutionContext =
+                    new TaskExecutionContext(parentProject, null, null, buildContext,
                                              EngineCallback.invalidEngineHandle, EngineCallback.inProcNode, null);
                 parentEngine.PostTaskOutputUpdates(taskExecutionContext);
             }
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index bf69df6dbdc..fef8afe8e60 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -30,7 +30,7 @@ namespace Microsoft.Build.BuildEngine
     internal enum TaskExecutionMode
     {
         /// <summary>
-        /// This entry is necessary to use the enum with binary math. It is never used outside 
+        /// This entry is necessary to use the enum with binary math. It is never used outside
         /// intermediate calculations.
         /// </summary>
         Invalid = 0,
@@ -159,7 +159,7 @@ private List<string> CreateListOfParameterValues()
         /// 2) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by exact name
         /// 3) checks the tasks declared by the project, searching by fuzzy match (missing namespace, etc.)
         /// 4) checks the global task declarations (in *.TASKS in MSbuild bin dir), searching by fuzzy match (missing namespace, etc.)
-        /// 
+        ///
         /// The search ordering is meant to reduce the number of assemblies we scan, because loading assemblies can be expensive.
         /// The tasks and assemblies declared by the project are scanned first, on the assumption that if the project declared
         /// them, they are likely used.
@@ -254,7 +254,7 @@ private AppDomain PrepareAppDomain()
         }
 
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         /// <returns>true, if successful</returns>
         internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
@@ -278,7 +278,7 @@ internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
                 {
                     lookupHash = Utilities.CreateTableIfNecessary((Hashtable)null);
                 }
-		
+
 		// Loop through each of the batch buckets and execute them one at a time
                 for (int i=0; i < buckets.Count; i++)
                 {
@@ -1111,13 +1111,13 @@ ItemBucket bucket
             // DevDiv bugs: 33981
             foreach (XmlAttribute taskNodeAttribute in taskNode.Attributes)
             {
-                if (String.Compare(taskNodeAttribute.Name, taskParameterName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(taskNodeAttribute.Name, taskParameterName, StringComparison.OrdinalIgnoreCase))
                 {
                     taskParameterAttribute = taskNodeAttribute;
                     break;
                 }
             }
- 
+
             if (taskParameterAttribute != null)
             {
                 if (taskOutputSpecification.IsItemVector)
@@ -1581,8 +1581,8 @@ object parameterValue
         }
 
         /// <summary>
-        /// This function correctly computes the line/column number of the task node 
-        /// in the project file (or .TARGETS file) that called it. The XmlNode available 
+        /// This function correctly computes the line/column number of the task node
+        /// in the project file (or .TARGETS file) that called it. The XmlNode available
         /// to the task engine lacks this information so we call back into the build engine
         /// to obtain it.
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs b/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
index 47694f4d3d3..1f014fc5526 100644
--- a/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngineAssemblyResolver.cs
@@ -38,10 +38,10 @@ internal void Initialize(string taskAssemblyFileToResolve)
         }
 
         /// <summary>
-        /// Installs an AssemblyResolve handler in the current AppDomain. This class can be created in any AppDomain, 
+        /// Installs an AssemblyResolve handler in the current AppDomain. This class can be created in any AppDomain,
         /// so it's possible to create an AppDomain, create an instance of this class in it and use this method to install
         /// an event handler in that AppDomain. Since the event handler instance is stored internally, this method
-        /// should only be called once before a corresponding call to RemoveHandler (not that it would make sense to do 
+        /// should only be called once before a corresponding call to RemoveHandler (not that it would make sense to do
         /// anything else).
         /// </summary>
         /// <owner>lukaszg</owner>
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
index 29ef370c0c2..0f35fb5e17c 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionModule.cs
@@ -30,7 +30,7 @@ internal class TaskExecutionModule
         /// </summary>
         internal TaskExecutionModule
         (
-            EngineCallback engineCallback, 
+            EngineCallback engineCallback,
             TaskExecutionModuleMode moduleMode,
             bool profileExecution
         )
@@ -128,7 +128,7 @@ internal bool UseBreadthFirstTraversal
         }
 
         /// <summary>
-        /// Returns true if the TEM doesn't have a thread in user code and there are no pending 
+        /// Returns true if the TEM doesn't have a thread in user code and there are no pending
         /// workitems
         /// </summary>
         internal bool IsIdle
@@ -140,7 +140,7 @@ internal bool IsIdle
         }
 
         /// <summary>
-        /// Return total time spent executing the tasks by this TEM. This value is only valid if the TEM is created with 
+        /// Return total time spent executing the tasks by this TEM. This value is only valid if the TEM is created with
         /// profileExecution set to true, otherwise this value will be 0
         /// </summary>
         internal long TaskExecutionTime
@@ -155,7 +155,7 @@ internal long TaskExecutionTime
         #region Method used internally inside the TEM boundary (i.e. not called from the engine)
 
         /// <summary>
-        /// This method passes the task outputs to the engine, it is virtual for testing purposes to 
+        /// This method passes the task outputs to the engine, it is virtual for testing purposes to
         /// create a mock TEM
         /// </summary>
         virtual internal void PostTaskOutputs
@@ -176,15 +176,15 @@ long executionTime
         /// <returns>result of call to engine</returns>
         virtual internal bool BuildProjectFile
         (
-            int handleId, 
-            string[] projectFileNames, 
-            string[] targetNames, 
+            int handleId,
+            string[] projectFileNames,
+            string[] targetNames,
             IDictionary[] globalPropertiesPerProject,
             IDictionary[] targetOutputsPerProject,
             EngineLoggingServices loggingServices,
             string [] toolsVersions,
             bool useResultsCache,
-            bool unloadProjectsOnCompletion, 
+            bool unloadProjectsOnCompletion,
             BuildEventContext taskContext
         )
         {
@@ -290,16 +290,16 @@ BuildEventContext taskContext
 
             return overallResult;
         }
-       
+
        /// <summary>
        /// Once the buildRequests from the EngineCallback have been created they are sent to this method which will
        /// post the build requests to the parent engine and then wait on the results to come back.
        /// This method uses either a breadthFirst or depthFirst traversal strategy when sending buildRequests to the parent engine.
        /// This method will start in breadthFirst traversal. It will continue to use this strategy until one of two events occur:
-       ///     1. The parent node sents a message indicating the TEM should switch to depthFirst traversal. 
+       ///     1. The parent node sents a message indicating the TEM should switch to depthFirst traversal.
        ///     2. The number of buildRequests is larger than the batchRequestSize.
        /// In both of these cases the system will go from a breadthFirstTraversal to a depthFirst Traversal. In the second case
-       /// a message will be sent to the parent engine to switch the system to depthFirst traversal as the system is starting to 
+       /// a message will be sent to the parent engine to switch the system to depthFirst traversal as the system is starting to
        /// be overloaded with work.
        /// In a depth first strategy the buildRequests will be sent to the parent engine one at a time and waiting for results for
        /// each buildRequest sent. In a breadthFirst traversal strategy some number of the buildrequests will be sent to the parent engine
@@ -319,7 +319,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
             {
                 int currentRequestIndex = 0; // Which build request is being processed
                 int numberOfRequestsToSend = 0; // How many buildRequests are going to be sent based on the number of buildRequests remaining and the build request batch size.
-                
+
                 // Arrays that will be used to partion the buildRequests array when sending batches of builds requests at a time.
                 BuildRequest[] wrapperArrayBreadthFirst = new BuildRequest[batchRequestSize];
                 BuildResult[] resultsArrayBreadthFirst = new BuildResult[batchRequestSize];
@@ -343,7 +343,7 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
                             wrapperArrayBreadthFirst = new BuildRequest[numberOfRequestsToSend];
                             resultsArrayBreadthFirst = new BuildResult[numberOfRequestsToSend];
                         }
-                        
+
                         // Fill the wrapper array with one batch of build requests
                         for (int i = 0; i < numberOfRequestsToSend; i++)
                         {
@@ -353,14 +353,14 @@ private void WaitForBuildResults(int handleId, BuildResult[] buildResultsLocal,
                         }
 
                         engineCallback.PostBuildRequestsToHost(wrapperArrayBreadthFirst);
-                        
+
                         // Only switch from breadth to depth if there are more thanbatchRequestSize items
                         if ((buildRequests.Length - currentRequestIndex) > batchRequestSize)
                         {
                             engineCallback.PostStatus(nodeId, new NodeStatus(false /* use depth first traversal*/), false /* don't block waiting on the send */);
                             breadthFirstTraversal = false;
                         }
-                        
+
                         workerThread.WaitForResults(handleId, resultsArrayBreadthFirst, wrapperArrayBreadthFirst);
                         Array.Copy(resultsArrayBreadthFirst, 0, buildResultsLocal, currentRequestIndex, numberOfRequestsToSend);
                         currentRequestIndex += numberOfRequestsToSend;
@@ -434,8 +434,8 @@ internal bool RethrowTaskExceptions()
 
         #region Methods called from the engine
         /// <summary>
-        /// Called to execute a task within a target. This method instantiates the task, sets its parameters, 
-        /// and executes it. 
+        /// Called to execute a task within a target. This method instantiates the task, sets its parameters,
+        /// and executes it.
         /// </summary>
         /// <param name="taskState"></param>
         public void ExecuteTask(TaskExecutionState taskState)
@@ -648,12 +648,12 @@ internal TaskWorkerThread GetWorkerThread()
 
         /// <summary>
         /// In a multiproc build this is the maximum number of build requests which will be sent at a time to the parent engine
-        /// A default of 10 was an arbitrary number but turned out to be a good balance between being too small 
+        /// A default of 10 was an arbitrary number but turned out to be a good balance between being too small
         /// causing the system to run out of work too quickly and being too big and flooding the system with requests.
         /// </summary>
         private const int defaultBatchRequestSize = 10;
         private int batchRequestSize = defaultBatchRequestSize;
-        
+
         /// <summary>
         /// The nodeId of the node the TaskExecutionModule is running on
         /// </summary>
diff --git a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
index a804c1bfb93..d49e9d6992c 100644
--- a/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
+++ b/src/Deprecated/Engine/Engine/TaskWorkerThread.cs
@@ -142,7 +142,7 @@ internal int WorkItemCount
 
         /// <summary>
         /// This a base loop of a worker thread. The worker thread is asleep waiting for either an
-        /// event indicating that it should shut down or that it should become active and take 
+        /// event indicating that it should shut down or that it should become active and take
         /// ownership of the work item queue
         /// </summary>
         private void MainThreadLoop()
@@ -308,8 +308,8 @@ private WaitHandle [] GetHandlesArray( NodeLoopExecutionMode executionMode )
         /// </summary>
         private void NodeActionLoop
         (
-            NodeLoopExecutionMode executionMode, 
-            int handleId, 
+            NodeLoopExecutionMode executionMode,
+            int handleId,
             BuildResult [] buildResults
         )
         {
@@ -330,7 +330,7 @@ BuildResult [] buildResults
                     entryTime = DateTime.Now.Ticks;
                 }
             }
-            
+
             bool continueExecution = true;
             while (continueExecution)
             {
@@ -430,7 +430,7 @@ BuildResult [] buildResults
                     {
                         LinkedListNode<BuildResult> currentNode = postedBuildResults.First;
                         while (currentNode != null)
-                        {   
+                        {
                             BuildResult buildResult = currentNode.Value;
                             ErrorUtilities.VerifyThrow(
                                             buildResult.RequestId < buildResults.Length,
@@ -454,7 +454,7 @@ BuildResult [] buildResults
                     }
                 }
                 // Check if we need to update the state
-                if (executionMode == NodeLoopExecutionMode.BaseActiveThread && !threadActive) 
+                if (executionMode == NodeLoopExecutionMode.BaseActiveThread && !threadActive)
                 {
                     continueExecution = false;
                 }
@@ -500,7 +500,7 @@ internal void ActivateThread()
         /// </summary>
         internal void WaitForResults
         (
-            int handleId, 
+            int handleId,
             BuildResult[] buildResults,
             BuildRequest [] buildRequests
         )
@@ -512,7 +512,7 @@ BuildRequest [] buildRequests
             {
                 waitingTasks.Add(handleId, taskData);
             }
-            workerThread.NodeActionLoop(workerThread.threadActive ? NodeLoopExecutionMode.WaitingActiveThread : 
+            workerThread.NodeActionLoop(workerThread.threadActive ? NodeLoopExecutionMode.WaitingActiveThread :
                                         NodeLoopExecutionMode.WaitingPassiveThread,
                                         handleId, buildResults);
             lock (waitingTasks)
diff --git a/src/Deprecated/Engine/Engine/ToolsetReader.cs b/src/Deprecated/Engine/Engine/ToolsetReader.cs
index f573b78cc11..cf783629fbd 100644
--- a/src/Deprecated/Engine/Engine/ToolsetReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetReader.cs
@@ -24,7 +24,7 @@ public PropertyDefinition(string name, string value, string source)
 
             // value can be the empty string but not null
             error.VerifyThrowArgumentNull(value, "value");
-            
+
             this.name = name;
             this.value = value;
             this.source = source;
@@ -54,7 +54,7 @@ public string Value
 
         /// <summary>
         /// A description of the location where the property was defined,
-        /// such as a registry key path or a path to a config file and 
+        /// such as a registry key path or a path to a config file and
         /// line number.
         /// </summary>
         public string Source
@@ -65,7 +65,7 @@ public string Source
             }
         }
     }
-    
+
     internal abstract class ToolsetReader
     {
         /// <summary>
@@ -140,12 +140,12 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
                 // We do not accumulate properties when reading them from the registry, because the order
                 // in which values are returned to us is essentially random: so we disallow one property
                 // in the registry to refer to another also in the registry
-                defaultToolsVersionFromRegistry = 
+                defaultToolsVersionFromRegistry =
                     registryReaderToUse.ReadToolsets(toolsets, globalProperties, initialProperties, false /* do not accumulate properties */);
             }
 
             string defaultToolsVersionFromConfiguration = null;
-            
+
             ToolsetConfigurationReader configurationReaderToUse = null;
             if ((locations & ToolsetDefinitionLocations.ConfigurationFile) == ToolsetDefinitionLocations.ConfigurationFile)
             {
@@ -165,7 +165,7 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
                         configurationReaderToUse.ReadToolsets(toolsets, globalProperties, initialProperties, true /* accumulate properties */);
                 }
             }
-            
+
             // We'll use the default from the configuration file if it was specified, otherwise we'll try
             // the one from the registry.  It's possible (and valid) that neither the configuration file
             // nor the registry specify a default, in which case we'll just return null.
@@ -209,9 +209,9 @@ internal static string ReadAllToolsets(ToolsetCollection toolsets,
         }
 
         /// <summary>
-        /// Creating a ToolsetConfigurationReader, and also reading toolsets from the 
-        /// configuration file, are a little expensive. To try to avoid this cost if it's 
-        /// not necessary, we'll check if the file exists first. If it exists, we'll scan for 
+        /// Creating a ToolsetConfigurationReader, and also reading toolsets from the
+        /// configuration file, are a little expensive. To try to avoid this cost if it's
+        /// not necessary, we'll check if the file exists first. If it exists, we'll scan for
         /// the string "toolsVersion" to see if it might actually have any tools versions
         /// defined in it.
         /// </summary>
@@ -265,7 +265,7 @@ internal string ReadToolsets(ToolsetCollection toolsets,
             // they'll get a nice error saying that toolset isn't available and listing those that are.
             return defaultToolsVersion;
         }
-        
+
         /// <summary>
         /// Reads all the toolsets and populates the given ToolsetCollection with them
         /// </summary>
@@ -313,13 +313,13 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
             string toolsPath = null;
             string binPath = null;
             BuildPropertyGroup properties = new BuildPropertyGroup();
-            
+
             IEnumerable<PropertyDefinition> rawProperties = GetPropertyDefinitions(toolsVersion.Name);
             Expander expander = new Expander(initialProperties);
 
             foreach (PropertyDefinition property in rawProperties)
             {
-                if (0 == String.Compare(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(property.Name, ReservedPropertyNames.toolsPath, StringComparison.OrdinalIgnoreCase))
                 {
                     toolsPath = ExpandProperty(property, expander);
                     toolsPath = ExpandRelativePathsRelativeToExeLocation(toolsPath);
@@ -334,7 +334,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
                         );
                     }
                 }
-                else if (0 == String.Compare(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(property.Name, ReservedPropertyNames.binPath, StringComparison.OrdinalIgnoreCase))
                 {
                     binPath = ExpandProperty(property, expander);
                     binPath = ExpandRelativePathsRelativeToExeLocation(binPath);
@@ -360,7 +360,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
                     // It's an arbitrary property
                     string propertyValue = ExpandProperty(property, expander);
                     PropertyDefinition expandedProperty = new PropertyDefinition(property.Name, propertyValue, property.Source);
-                    
+
                     SetProperty(expandedProperty, properties, globalProperties);
 
                     if (accumulateProperties)
@@ -368,7 +368,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
                         SetProperty(expandedProperty, initialProperties, globalProperties);
                     }
                 }
-                
+
                 if (accumulateProperties)
                 {
                     expander = new Expander(initialProperties);
@@ -388,7 +388,7 @@ private Toolset ReadToolset(PropertyDefinition toolsVersion,
             }
 
             Toolset toolset = null;
-            
+
             try
             {
                 toolset = new Toolset(toolsVersion.Name, toolsPath == null ? binPath : toolsPath, properties);
diff --git a/src/Deprecated/Engine/Engine/ToolsetState.cs b/src/Deprecated/Engine/Engine/ToolsetState.cs
index 79d23d08ae5..9febd3edfea 100644
--- a/src/Deprecated/Engine/Engine/ToolsetState.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetState.cs
@@ -230,7 +230,7 @@ private void RegisterDefaultTasks(BuildEventContext buildEventContext)
                                     ProjectErrorUtilities.VerifyThrowInvalidProject(topLevelNode.LocalName == XMakeElements.project,
                                         topLevelNode, "UnrecognizedElement", topLevelNode.Name);
 
-                                    ProjectErrorUtilities.VerifyThrowInvalidProject((topLevelNode.Prefix.Length == 0) && (String.Compare(topLevelNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0),
+                                    ProjectErrorUtilities.VerifyThrowInvalidProject((topLevelNode.Prefix.Length == 0) && (String.Equals(topLevelNode.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase)),
                                         topLevelNode, "ProjectMustBeInMSBuildXmlNamespace", XMakeAttributes.defaultXmlNamespace);
 
                                     // the <Project> tag can only the XML namespace -- no other attributes
diff --git a/src/Deprecated/Engine/Engine/Utilities.cs b/src/Deprecated/Engine/Engine/Utilities.cs
index eb54fda085a..ce453502b25 100644
--- a/src/Deprecated/Engine/Engine/Utilities.cs
+++ b/src/Deprecated/Engine/Engine/Utilities.cs
@@ -476,7 +476,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the start of a comment
                         insideComment = true;
-                        i = i + 3;
+                        i += 3;
                         continue;
                     }
                 }
@@ -500,7 +500,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
                     {
                         // Found the end of a comment
                         insideComment = false;
-                        i = i + 2;
+                        i += 2;
                         continue;
                     }
                 }
diff --git a/src/Deprecated/Engine/Engine/XmlSearcher.cs b/src/Deprecated/Engine/Engine/XmlSearcher.cs
index f6a663a3ebf..5d8ea7f8353 100644
--- a/src/Deprecated/Engine/Engine/XmlSearcher.cs
+++ b/src/Deprecated/Engine/Engine/XmlSearcher.cs
@@ -282,7 +282,7 @@ out int foundColumnNumber
                                         // letter of the tag name, whereas we would prefer to point at the opening
                                         // left-angle-bracket.  (Whitespace between the left-angle-bracket and
                                         // the tag name is not allowed in XML, so this is safe.)
-                                        foundColumnNumber = foundColumnNumber - 1;
+                                        foundColumnNumber -= 1;
                                     }
                                 }
                                 else if (reader.MoveToFirstAttribute()) 
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index d088dd1c1a6..df33c9ffca7 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -84,11 +84,11 @@ public InternalLoggerException(string message, Exception innerException)
         /// <param name="helpKeyword"></param>
         internal InternalLoggerException
         (
-            string message, 
-            Exception innerException, 
-            BuildEventArgs e, 
-            string errorCode, 
-            string helpKeyword, 
+            string message,
+            Exception innerException,
+            BuildEventArgs e,
+            string errorCode,
+            string helpKeyword,
             bool initializationException
          )
             : base(message, innerException)
@@ -107,7 +107,7 @@ bool initializationException
         #region Serialization (update when adding new class members)
 
         /// <summary>
-        /// Protected constructor used for (de)serialization. 
+        /// Protected constructor used for (de)serialization.
         /// If we ever add new members to this class, we'll need to update this.
         /// </summary>
         /// <param name="info"></param>
@@ -220,11 +220,11 @@ public bool InitializationException
         /// <param name="messageArgs"></param>
         internal static void Throw
         (
-            Exception innerException, 
-            BuildEventArgs e, 
-            string messageResourceName, 
+            Exception innerException,
+            BuildEventArgs e,
+            string messageResourceName,
             bool initializationException,
-            params string[] messageArgs 
+            params string[] messageArgs
         )
         {
             ErrorUtilities.VerifyThrow(messageResourceName != null, "Need error message.");
diff --git a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
index 5220071c14c..ccf85258677 100644
--- a/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
+++ b/src/Deprecated/Engine/Introspector/TargetCycleDetector.cs
@@ -13,12 +13,12 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class is used to construct and analyze the graph of inprogress targets in order to find
-    /// cycles inside the graph. To find cycles a post order traversal is used to assign a post order 
+    /// cycles inside the graph. To find cycles a post order traversal is used to assign a post order
     /// traversal to each node. Back edges indicate cycles in the graph and they can indentified by
-    /// a link from lower index node to a higher index node. 
-    /// 
+    /// a link from lower index node to a higher index node.
+    ///
     /// The graph arrives in pieces from individual nodes and needs to be stiched together by identifying
-    /// the parent and child for each cross node link. To do that it is necessary to match up parent 
+    /// the parent and child for each cross node link. To do that it is necessary to match up parent
     /// build request for a child with and outstanding request from the parent (see LinkCrossNodeBuildRequests)
     /// </summary>
     internal class TargetCycleDetector
@@ -176,7 +176,7 @@ private void LinkCrossNodeBuildRequests()
         {
             foreach (GraphNode node in dependencyGraph.Values)
             {
-                TargetInProgessState.TargetIdWrapper[] parentsForBuildRequests = 
+                TargetInProgessState.TargetIdWrapper[] parentsForBuildRequests =
                     new TargetInProgessState.TargetIdWrapper[node.targetState.ParentBuildRequests.Count];
 
                 for (int j = 0; j < node.targetState.ParentBuildRequests.Count; j++ )
@@ -235,7 +235,7 @@ private void LinkCrossNodeBuildRequests()
                             {
                                 // Verify that the project name is the same
                                 ErrorUtilities.VerifyThrow(
-                                    String.Compare(buildRequest.ProjectFileName, externalRequests[i].ProjectFileName, StringComparison.OrdinalIgnoreCase) == 0,
+                                    String.Equals(buildRequest.ProjectFileName, externalRequests[i].ProjectFileName, StringComparison.OrdinalIgnoreCase),
                                     "The two requests should have the same project name");
 
                                 // Link the two graph nodes together
@@ -316,10 +316,10 @@ private void DumpCycleSequence(GraphNode parent, GraphNode child)
             {
                 node.traversalIndex = GraphNode.InvalidIndex;
             }
-            BuildEventContext buildEventContext = 
+            BuildEventContext buildEventContext =
                 new BuildEventContext(child.targetState.TargetId.nodeId,
-                                 child.targetState.TargetId.id, 
-                                 BuildEventContext.InvalidProjectContextId, 
+                                 child.targetState.TargetId.id,
+                                 BuildEventContext.InvalidProjectContextId,
                                  BuildEventContext.InvalidTaskId
                                 );
             DumpCycleSequenceOutput(parent, child, buildEventContext);
diff --git a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
index ebae02be411..eb9feec1cf0 100644
--- a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
+++ b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
@@ -201,7 +201,7 @@ out BuildRequest parentRequest
             {
                 // The build context must have formed due to IBuildEngine call
                 ErrorUtilities.VerifyThrow(
-                    String.Compare(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), target.Name, StringComparison.OrdinalIgnoreCase) == 0,
+                    String.Equals(EscapingUtilities.UnescapeAll(buildContext.NameOfTargetInProgress), target.Name, StringComparison.OrdinalIgnoreCase),
                     "The target should be the in progress target for the context");
                 // This target is called due to IBuildEngine or host request
                 return FindParentTargetForBuildRequest(engineCallback, buildContext.BuildRequest, out parentRequest);
@@ -581,7 +581,7 @@ public override bool Equals(object obj)
                 if (other != null)
                 {
                     if (other.projectId == projectId && other.nodeId == nodeId &&
-                        (String.Compare(other.name, name, StringComparison.OrdinalIgnoreCase) == 0))
+                        (String.Equals(other.name, name, StringComparison.OrdinalIgnoreCase)))
                     {
                         return true;
                     }
diff --git a/src/Deprecated/Engine/Items/BuildItem.cs b/src/Deprecated/Engine/Items/BuildItem.cs
index a2b9370376f..b2fb839a615 100644
--- a/src/Deprecated/Engine/Items/BuildItem.cs
+++ b/src/Deprecated/Engine/Items/BuildItem.cs
@@ -1661,7 +1661,7 @@ private string GetItemSpecModifier(string modifier)
 
             if (modifiedItemSpec.Length == 0)
             {
-                if (String.Compare(modifier, FileUtilities.ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(modifier, FileUtilities.ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase))
                 {
                     modifiedItemSpec = ExtractRecursivePortionOfFinalItemSpecDirectory();
 
diff --git a/src/Deprecated/Engine/Items/BuildItemGroup.cs b/src/Deprecated/Engine/Items/BuildItemGroup.cs
index 86fa8fc922d..86906da9e00 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroup.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroup.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.BuildEngine
 {
     /// <summary>
     /// This class represents a collection of items.  It may be represented
-    /// physically by an &lt;ItemGroup&gt; element persisted in the project file, 
+    /// physically by an &lt;ItemGroup&gt; element persisted in the project file,
     /// or it may just be a virtual BuildItemGroup (e.g., the evaluated items).
     /// </summary>
     [DebuggerDisplay("BuildItemGroup (Count = { Count }, Condition = { Condition })")]
@@ -363,7 +363,7 @@ internal void AddExistingItemAt(int index, BuildItem itemToAdd)
         /// <summary>
         /// Adds an BuildItem to this BuildItemGroup.  If this is a persisted BuildItemGroup, then
         /// this method also inserts the BuildItem's XML into the appropriate location
-        /// in the XML document.  For persisted ItemGroups, the behavior is that 
+        /// in the XML document.  For persisted ItemGroups, the behavior is that
         /// it tries to insert the new BuildItem such that it is "near" other items of the
         /// same type.  ("Near" is defined as just after the last existing item
         /// of the same type, or at the end if none is found.)
@@ -392,7 +392,7 @@ internal void AddItem(BuildItem itemToAdd)
                 int insertionIndex = items.Count;
                 for (int i = 0; i < items.Count; i++)
                 {
-                    if ( 0 == String.Compare(itemToAdd.Name, items[i].Name, StringComparison.OrdinalIgnoreCase))
+                    if ( String.Equals(itemToAdd.Name, items[i].Name, StringComparison.OrdinalIgnoreCase))
                     {
                         insertionIndex = i + 1;
 
@@ -439,7 +439,7 @@ internal void AddItem(BuildItem itemToAdd)
         }
 
         /// <summary>
-        /// Creates a new BuildItem defined by the given "Type" and "Include", and 
+        /// Creates a new BuildItem defined by the given "Type" and "Include", and
         /// adds it to the end of this BuildItemGroup.
         /// If the group is persisted, the item is persisted; otherwise it is virtual
         /// </summary>
@@ -453,7 +453,7 @@ public BuildItem AddNewItem(string itemName, string itemInclude)
                 newItem = new BuildItem(xml.OwnerDocument, itemName, itemInclude, parentProject.ItemDefinitionLibrary);
             }
             else
-            { 
+            {
                 // Create a new virtual BuildItem.
                 newItem = new BuildItem(itemName, itemInclude);
             }
@@ -539,8 +539,8 @@ private void RemoveItemElement(BuildItem item)
         /// <summary>
         /// Clones the BuildItemGroup.  A shallow clone here is one that references
         /// the same BuildItem objects as the original, whereas a deep clone actually
-        /// clones the BuildItem objects as well.  If this is a persisted BuildItemGroup, 
-        /// only deep clones are allowed, because you can't have the same XML 
+        /// clones the BuildItem objects as well.  If this is a persisted BuildItemGroup,
+        /// only deep clones are allowed, because you can't have the same XML
         /// element belonging to two parents.
         /// </summary>
         public BuildItemGroup Clone(bool deepClone)
@@ -764,8 +764,8 @@ internal void Evaluate
         (
             BuildPropertyGroup existingProperties,
             Hashtable existingItemsByName,
-            bool collectItemsIgnoringCondition, 
-            bool collectItemsRespectingCondition, 
+            bool collectItemsIgnoringCondition,
+            bool collectItemsRespectingCondition,
             ProcessingPass pass
         )
         {
@@ -894,7 +894,7 @@ bool expandMetadata
                     itemsToInclude.RemoveItem(item);
                 }
             }
-            
+
             return itemsToInclude;
         }
 
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index e626597fe4f..cc741b9b68b 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -372,7 +372,7 @@ private static bool Sink(string expression, ref int i, int end, char c1, char c2
         {
             if (i < end - 1 && expression[i] == c1 && expression[i + 1] == c2)
             {
-                i = i + 2;
+                i += 2;
                 return true;
             }
 
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index 1f6040afc72..ac297c651c5 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -201,7 +201,7 @@ private static bool CreateGlobalEvents(int nodeNumber)
 
             // Indicate to the parent process, this node is currently is ready to start to recieve requests
             globalNodeInUse = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeInUseEventName(nodeNumber));
-            
+
             // Used by the parent process to inform the child process to shutdown due to the child process
             // not recieving the initialization command.
             globalNodeErrorShutdown = new EventWaitHandle(false, EventResetMode.ManualReset, LocalNodeProviderGlobalNames.NodeErrorShutdownEventName(nodeNumber));
@@ -330,7 +330,7 @@ public static void StartLocalNodeServer(int nodeNumber)
         #region Methods
 
         /// <summary>
-        /// This method is run in its own thread, it is responsible for reading messages sent from the parent process 
+        /// This method is run in its own thread, it is responsible for reading messages sent from the parent process
         /// through the shared memory region.
         /// </summary>
         private void SharedMemoryReaderThread()
@@ -442,7 +442,7 @@ internal void ShutdownNode(Node.NodeShutdownLevel shutdownLevel, bool exitProces
                 // accomplished by calling this method again with the ErrorShutdown handle
                 if ( shutdownLevel == Node.NodeShutdownLevel.BuildCompleteSuccess || shutdownLevel == Node.NodeShutdownLevel.BuildCompleteFailure )
                 {
-                    ShutdownNode(Node.NodeShutdownLevel.ErrorShutdown, false, true); 
+                    ShutdownNode(Node.NodeShutdownLevel.ErrorShutdown, false, true);
                 }
                 // Signal all the communication threads to exit
                 shutdownEvent.Set();
@@ -611,9 +611,9 @@ internal static string DumpFileName
         private static ManualResetEvent communicationThreadExitEvent = new ManualResetEvent(false);
         private static ManualResetEvent shutdownEvent = new ManualResetEvent(false);
         private static ManualResetEvent notInUseEvent = new ManualResetEvent(false);
-        
+
         /// <summary>
-        /// Indicates the node is now in use. This means the node has recieved an activate command with initialization 
+        /// Indicates the node is now in use. This means the node has recieved an activate command with initialization
         /// data from the parent procss
         /// </summary>
         private static ManualResetEvent inUseEvent    = new ManualResetEvent(false);
@@ -627,7 +627,7 @@ internal static string DumpFileName
         // Timeouts && Constants
         private const int inactivityTimeout   = 60 * 1000; // 60 seconds of inactivity to exit
         private const int parentCheckInterval = 5 * 1000; // Check if the parent process is there every 5 seconds
-	
+
         #endregion
 
     }
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
index b507db38ce2..f74b594474b 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
@@ -56,7 +56,7 @@ string startupDirectory
                         }
                         else // Only the parameter name is known, this could be for a boolean parameter
                         {
-                            ApplyParameter(parameters[param], null); 
+                            ApplyParameter(parameters[param], null);
                         }
                     }
                 }
@@ -124,7 +124,7 @@ public void ApplyParameter(string parameterName, string parameterValue)
         {
             ErrorUtilities.VerifyThrowArgumentNull(parameterName, "parameterName");
 
-            if (0 == String.Compare(parameterName, "MAXCPUCOUNT", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, "MAXCPUCOUNT", StringComparison.OrdinalIgnoreCase))
             {
                  try
                 {
@@ -139,11 +139,11 @@ public void ApplyParameter(string parameterName, string parameterValue)
                     //
                 }
             }
-            else if (0 == String.Compare(parameterName, "MSBUILDLOCATION", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "MSBUILDLOCATION", StringComparison.OrdinalIgnoreCase))
             {
                 this.locationOfMSBuildExe = parameterValue;
             }
-            else if (0 == String.Compare(parameterName, "NODEREUSE", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "NODEREUSE", StringComparison.OrdinalIgnoreCase))
             {
                 try
                 {
@@ -249,7 +249,7 @@ public void PostBuildRequestToNode(int nodeIndex, BuildRequest buildRequest)
                             }
                             ThreadStart threadState = new ThreadStart(this.LaunchNodeAndPostBuildRequest);
                             Thread taskThread = new Thread(threadState);
-                            taskThread.Name = "MSBuild Node Launcher";                            
+                            taskThread.Name = "MSBuild Node Launcher";
                             taskThread.Start();
                         }
                         nodeData[nodeIndex].TargetList.AddFirst(new LinkedListNode<BuildRequest>(buildRequest));
@@ -293,10 +293,10 @@ public void ShutdownNodes(Node.NodeShutdownLevel nodeShutdownLevel)
             SendShutdownRequests(nodeShutdownLevel);
 
             DateTime startTime = DateTime.Now;
-            
+
             // Wait for all nodes to shutdown
             bool timeoutExpired = false;
-            
+
             // Loop until we are ready to shutdown. We are ready to shutdown when
             // all nodes either have sent their shutdown completed response or they are dead.
             // Secondly, we will exit the loop if our shudtownTimeout has expired
@@ -364,7 +364,7 @@ internal bool ReadyToShutdown()
         /// </summary>
         public void UpdateSettings
         (
-            bool enableCentralizedLogging, 
+            bool enableCentralizedLogging,
             bool enableOnlyLogCriticalEvents,
             bool useBreadthFirstTraversalSetting
         )
@@ -478,10 +478,9 @@ private bool IsNodeProcessAliveOrUninitialized(int nodeId)
             {
                 return false;
             }
-            
+
             try
             {
-
                 bool isUninitialized = nodeData[nodeId].ProcessId == LocalNodeInfo.unInitializedProcessId;
 
                 if (isUninitialized)
@@ -719,7 +718,7 @@ private void InitializeNode(int nodeIndex)
             finally
             {
                 // Make sure to decrement the active node count if the communication has failed
-                if (nodeConnected != true)
+                if (!nodeConnected)
                 {
                     DecreaseActiveNodeCount(nodeData[nodeIndex].NodeId);
                     nodeData[nodeIndex].CommunicationFailed = true;
@@ -729,7 +728,7 @@ private void InitializeNode(int nodeIndex)
 
         /// <summary>
         /// This function attempts to find out if there is currently a node running
-        /// for a given index. The node is running if the global mutex with a 
+        /// for a given index. The node is running if the global mutex with a
         /// "Node_" + nodeId + "_ActiveReady" as a name was created
         /// </summary>
         private static  bool checkIfNodeActive(int nodeNumber)
@@ -775,7 +774,7 @@ private void LaunchNode(int nodeIndex)
                     startInfo.hStdInput = NativeMethods.InvalidHandle;
                     startInfo.hStdOutput = NativeMethods.InvalidHandle;
                     startInfo.dwFlags = NativeMethods.STARTF_USESTDHANDLES;
-                    dwCreationFlags = dwCreationFlags | NativeMethods.CREATE_NO_WINDOW;
+                    dwCreationFlags |= NativeMethods.CREATE_NO_WINDOW;
                 }
 
                 NativeMethods.SECURITY_ATTRIBUTES pSec = new NativeMethods.SECURITY_ATTRIBUTES();
@@ -820,7 +819,7 @@ private void LaunchNode(int nodeIndex)
         private void ReportNodeCommunicationFailure
         (
             int nodeIndex,
-            Exception innerException, 
+            Exception innerException,
             bool decreaseActiveNodeCount
         )
         {
@@ -845,7 +844,7 @@ bool decreaseActiveNodeCount
                 // We can't really do anything except re-throw so this problem can be diagnosed.
                 throw wrappedException;
             }
-            
+
             engineCallback.PostStatus(nodeData[nodeIndex].NodeId, nodeStatus, false);
         }
 
diff --git a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
index 6c9d72ce068..47f1f7c65af 100644
--- a/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
+++ b/src/Deprecated/Engine/LocalProvider/SharedMemory.cs
@@ -25,7 +25,7 @@ internal enum SharedMemoryType
     }
 
     /// <summary>
-    /// The shared memory is used to transmit serialized LocalCallDescriptors. 
+    /// The shared memory is used to transmit serialized LocalCallDescriptors.
     /// These local call descriptors encapsulate commands and data that needs
     /// to be communicated between the parent and child objects. This enumeration
     /// is used by the shared memory to mark what kind of LocalCallDescriptor
@@ -36,7 +36,7 @@ internal enum SharedMemoryType
     internal enum ObjectType
     {
         // Has the object been serialized using .net serialization (binary formatter)
-        NetSerialization = 1, 
+        NetSerialization = 1,
         // Used to mark that the next int read represents how many bytes are in the
         // large object which is about to be sent      
         FrameMarker = 2,
@@ -61,10 +61,10 @@ internal enum ObjectType
     }
 
     /// <summary>
-    /// This class is responsible for providing a communication channel between 
+    /// This class is responsible for providing a communication channel between
     /// a child process and a parent process. Each process (child or parent) will
     /// have two SharedMemory class instances, one for reading and one for writing.
-    /// For example, a parent will have one shared memory class to "read" data 
+    /// For example, a parent will have one shared memory class to "read" data
     /// sent from the child and one "write" shared The shared memory communicates
     /// through named shared memory regions.
     /// </summary>
@@ -81,7 +81,7 @@ private SharedMemory()
         /// </summary>
         /// <param name="name">
         /// The name the shared memory will be given, this is combination of node,
-        /// username, admin status, and some other ones, 
+        /// username, admin status, and some other ones,
         /// see LocalNodeProviderGlobalNames.NodeInputMemoryName for greater detail.
         /// </param>
         /// <param name="type">
@@ -89,19 +89,19 @@ private SharedMemory()
         ///  within the shared memory class. For example,
         ///  read only means, only create a memory stream,
         ///  a read lock and a backing byte array and a binary reader. A write
-        ///  only type means,  create a memory stream, write lock and a binary writer. 
+        ///  only type means,  create a memory stream, write lock and a binary writer.
         ///  This type however does not set the type of the memory mapped section,
         ///  the memory mapped section itself is created
         ///  with READWRITE access.
         ///</param>
         /// <param name="allowExistingMapping">
-        ///  The shared memory is given a parameter to determine whether or not to 
-        ///  reuse an existing mapped memory secion. When the node is first created 
+        ///  The shared memory is given a parameter to determine whether or not to
+        ///  reuse an existing mapped memory secion. When the node is first created
         ///  this is false, however when the shared memory threads are created this
-        ///  is true. We do this because we create the shared memory when the node 
+        ///  is true. We do this because we create the shared memory when the node
         ///  is created, at this point the there should be no shared memory with the
-        ///  same name. However when we create the reader and writer threads 
-        ///  (which happens on node reuse) we want to reuse the memory. 
+        ///  same name. However when we create the reader and writer threads
+        ///  (which happens on node reuse) we want to reuse the memory.
         ///</param>
         internal SharedMemory(string name, SharedMemoryType type, bool allowExistingMapping)
         {
@@ -224,7 +224,7 @@ private void InitializeMemoryMapping(string memoryMapName, bool allowExistingMap
                         0,  // Start mapped view at low order offset 0
                          // The size of the shared memory plus some extra space for an int
                          // to write the number of bytes written
-                        (IntPtr)(size + 4)  
+                        (IntPtr)(size + 4)
                     );
 
                 // Check to see if the file view has been created on the fileMapping.
@@ -356,7 +356,7 @@ internal bool IsUsable
         /// Returns the readActionCounter as a WaitHandle. This WaitHandle is used
         /// to notify the SharedMemory reader threads that there is something ready
         /// in the shared memory to be read. The ReadFlag will remain set as long as
-        /// the number of times the shared memory has been read is less than the 
+        /// the number of times the shared memory has been read is less than the
         /// number of times writer thread has written to the shared memory.
         /// </summary>
         internal WaitHandle ReadFlag
@@ -437,7 +437,7 @@ private void IncrementUnreadBatchCounter()
         }
 
         /// <summary>
-        /// A batch has just been read out of shared memory. 
+        /// A batch has just been read out of shared memory.
         /// </summary>
         private void DecrementUnreadBatchCounter()
         {
@@ -449,10 +449,10 @@ private void DecrementUnreadBatchCounter()
         /// This function write out a set of objects into the shared buffer.
         /// In normal operation all the objects in the queue are serialized into
         /// the buffer followed by an end marker class. If the buffer is not big
-        /// enough to contain a single object the object is broken into 
+        /// enough to contain a single object the object is broken into
         /// multiple buffers as follows - first a frame marker is sent containing
         /// the size of the serialized object + size of end marker. The reader makes
-        /// sure upon receiving the frame marker that its buffer is large enough 
+        /// sure upon receiving the frame marker that its buffer is large enough
         /// to contain the object about to be sent. After the frame marker the object
         /// is sent as a series of buffers until all of it is written out.
         /// </summary>
@@ -553,7 +553,7 @@ internal void Write(DualQueue<LocalCallDescriptor> objectsToWrite, DualQueue<Loc
                             (int)writeLength // Length of bytes to write
                         );
 
-                        writeBytesRemaining = writeBytesRemaining - writeLength;
+                        writeBytesRemaining -= writeLength;
                         IncrementUnreadBatchCounter();
 
                         // Once the object is fully sent - remove it from the queue
@@ -688,9 +688,9 @@ private void SerializeCallDescriptorToStream(DualQueue<LocalCallDescriptor> obje
         /// <summary>
         /// This function reads data from the shared memory buffer and returns a list
         /// of deserialized LocalCallDescriptors or null. The method will return null
-        /// if the object being sent accross is a multi buffer object. Read needs to 
+        /// if the object being sent accross is a multi buffer object. Read needs to
         /// be called multiple times until the entire large object has been recived.
-        /// Once this has happened the large object is deserialized and returned in 
+        /// Once this has happened the large object is deserialized and returned in
         /// the Ilist. Read is used by the shared memory reader threads in the LocalNode
         /// (child end) and the LocalNodeProvider(ParentEnd) to read LocalCallDescriptors
         /// from the shared memory. Read is called from loops in the SharedMemoryReaderThread
@@ -798,12 +798,12 @@ internal IList Read()
         }
 
         /// <summary>
-        /// This method first reads the objectId as an int from the stream, 
-        /// this int should be found in the "ObjectType" enumeration. This 
-        /// objectId informs the method what kind of object should be 
+        /// This method first reads the objectId as an int from the stream,
+        /// this int should be found in the "ObjectType" enumeration. This
+        /// objectId informs the method what kind of object should be
         /// deserialized and returned from the method. The objectId is an
-        /// output parameter. This parameter is also returned so it can be 
-        /// used in the read and write methods to determine if 
+        /// output parameter. This parameter is also returned so it can be
+        /// used in the read and write methods to determine if
         /// a frame or end marker was found.
         /// </summary>
         private object DeserializeFromStream(out int objectId)
@@ -911,12 +911,12 @@ internal void Reset()
         private IntPtr pageFileView;
 
         private BinaryFormatter binaryFormatter;
-        
+
         // Binary reader and writer used to read and write from the memory streams used to contain the deserialized LocalCallDescriptors before and after they are copied 
         // to and from the shared memory region.
         private BinaryWriter binaryWriter;
         private BinaryReader binaryReader;
-        
+
         /// <summary>
         /// Memory stream to contain the deserialized objects before they are sent accross the shared memory region
         /// </summary>
@@ -925,7 +925,7 @@ internal void Reset()
         // Backing byte array of the readStream
         private byte[] readBuffer;
         private MemoryStream readStream;
-        
+
         // The count on a semaphore is decremented each time a thread enters the semaphore,
         // and incremented when a thread releases the semaphore. 
         // When the count is zero, subsequent requests block until other threads release the semaphore. 
@@ -933,7 +933,7 @@ internal void Reset()
 
         // unreadBatchCounter is used to track how many batches are remaining to be read from shared memory.
         private Semaphore unreadBatchCounter;
- 
+
         //Used to inform the shared memory reader threads the writer thread has written something in shared memory to read.
 	//The semaphore is incremented when the shared memory is full and when there is an unreadBatch availiable to be read or the shared memory is full.
 	//The semaphore is decremented when the shared memory reader thread is about to read from the shared memory.
@@ -942,7 +942,7 @@ internal void Reset()
         // Whether or not the shared memory is full
         private EventWaitHandle fullFlag;
         private EventWaitHandle notFullFlag;
-        
+
         private object writeLock;
         private object readLock;
 
@@ -955,7 +955,7 @@ internal void Reset()
 
         // Have we disposed this object yet;
         private bool disposed;
-        
+
         // Is the memory read only or write only
         private SharedMemoryType type;
 
@@ -963,7 +963,7 @@ internal void Reset()
         // we were spending a lot of time reflecting for these methods. The loggingTypeCache, caches the methodInfo for the classes and then look them
         // up when serializing or deserializing the objects. 
         private Hashtable loggingTypeCache;
-        
+
         // Keep a pointer to the queue which contains the large object which is being deserialized. We do this because we want to make sure 
         // after the object is properly sent we dequeue off the correct queue.
         private DualQueue<LocalCallDescriptor> largeObjectsQueue;
diff --git a/src/Deprecated/Engine/Logging/ConsoleLogger.cs b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
index c3fbfd7f1f4..221b2933f9a 100644
--- a/src/Deprecated/Engine/Logging/ConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
@@ -121,11 +121,11 @@ private void InitializeBaseConsoleLogger()
                     {
                         if (parameterComponents[param].Length > 0)
                         {
-                            if (0 == String.Compare(parameterComponents[param], "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                            if (String.Equals(parameterComponents[param], "ENABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                             {
                                 useMPLogger = true;
                             }
-                            if (0 == String.Compare(parameterComponents[param], "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
+                            if (String.Equals(parameterComponents[param], "DISABLEMPLOGGING", StringComparison.OrdinalIgnoreCase))
                             {
                                 useMPLogger = false;
                             }
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index f94d291ca7e..5d4231797e6 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -136,15 +136,15 @@ private void ApplyParameter(string parameterName)
 
             // If any of the following parameters are set, we will make sure we forward the events
             // necessary for the central logger to emit the requested information
-            if (0 == String.Compare(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, PerformanceSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 this.showPerfSummary = true;
             }
-            else if (0 == String.Compare(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, NoSummaryDescription, StringComparison.OrdinalIgnoreCase))
             {
                 this.showSummary = false;
             }
-            else if (0 == String.Compare(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, ShowCommandLineDescription, StringComparison.OrdinalIgnoreCase))
             {
                 showCommandLine = true;
             }
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
index e1670a11352..c9a35cc22dd 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -67,7 +67,7 @@ private void ParseFileLoggerParameters()
         /// </summary>
         private void ApplyFileLoggerParameter(string parameterName, string parameterValue)
         {
-            if (String.Compare("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals("LOGFILE", parameterName, StringComparison.OrdinalIgnoreCase))
             {
                 if(string.IsNullOrEmpty(parameterValue))
                 {
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 5e82a875b4b..5c872e2d197 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -102,22 +102,22 @@ internal override bool ApplyParameter(string parameterName, string parameterValu
             {
                 return true;
             }
-            if (0 == String.Compare(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(parameterName, "SHOWCOMMANDLINE", StringComparison.OrdinalIgnoreCase))
             {
                 showCommandline = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWTIMESTAMP", StringComparison.OrdinalIgnoreCase))
             {
                 showTimeStamp = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "SHOWEVENTID", StringComparison.OrdinalIgnoreCase))
             {
                 showEventId = true;
                 return true;
             }
-            else if (0 == String.Compare(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(parameterName, "FORCENOALIGN", StringComparison.OrdinalIgnoreCase))
             {
                 forceNoAlign = true;
                 alignMessages = false;
@@ -430,7 +430,7 @@ private void ShowErrorWarningSummary<T>(ArrayList listToProcess) where T : Build
 
                 //If the target where the error occurred is the same as the previous message do not print the location
                 // where the error occurred again
-                if (String.Compare(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase) != 0)
+                if (!String.Equals(previousTarget, valuePair.Key.TargetName, StringComparison.OrdinalIgnoreCase))
                 {
                     //If no targetName was specified then do not show the target where the error occurred
                     if (! string.IsNullOrEmpty(valuePair.Key.TargetName))
@@ -1175,7 +1175,7 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
                             // Calculate how many chars will fit on the console buffer
                             amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);
                             WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), (prefixAlreadyWritten && index == 0 && i == 0), adjustedPrefixWidth);
-                            index = index + amountToCopy;
+                            index += amountToCopy;
                         }
                     }
                     else
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index ec6f9e65a17..5bd93664b6f 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -565,7 +565,7 @@ public override bool Equals(object obj)
             {
                 return false;
             }
-           return  eventComparer.Equals(entryPointContext, key.EntryPointContext) && (String.Compare(targetName, key.TargetName, StringComparison.OrdinalIgnoreCase) == 0);
+           return  eventComparer.Equals(entryPointContext, key.EntryPointContext) && (String.Equals(targetName, key.TargetName, StringComparison.OrdinalIgnoreCase));
         }
 
         public override int GetHashCode()
diff --git a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
index 5015d92adb4..1626f53236d 100644
--- a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
+++ b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
@@ -13,6 +13,7 @@
     <IsPackable>true</IsPackable>
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which contains the legacy compatibility shim for the MSBuild engine.  NOTE: This assembly is deprecated.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
+    <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
   </PropertyGroup>
   
   <ItemGroup>
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index e7814ef493f..6083b4c799e 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -54,9 +54,9 @@ internal enum PropertyType
     }
 
     /// <summary>
-    /// This class holds an MSBuild property.  This may be a property that is 
+    /// This class holds an MSBuild property.  This may be a property that is
     /// represented in the MSBuild project file by an XML element, or it
-    /// may not be represented in any real XML file (e.g., global properties, 
+    /// may not be represented in any real XML file (e.g., global properties,
     /// environment properties, etc.)
     /// </summary>
     /// <owner>rgoel</owner>
@@ -135,7 +135,7 @@ private static string Intern(string stringToIntern)
                 customInternTable.Add(stringToIntern, stringToIntern);
                 value = stringToIntern;
             }
-            
+
             return value;
         }
 
@@ -186,7 +186,7 @@ internal BuildProperty
             XmlElement      propertyElement,
             PropertyType    propertyType
         ) :
-            this(propertyElement, 
+            this(propertyElement,
                  propertyElement != null ? Utilities.GetXmlNodeInnerContents(propertyElement) : null,
                  propertyType)
         {
@@ -231,7 +231,7 @@ PropertyType propertyType
                         break;
 
                     default:
-                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyAttribute); 
+                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyAttribute);
                         break;
                 }
             }
@@ -256,7 +256,7 @@ internal BuildProperty
         (
             XmlDocument ownerDocument,
             string propertyName,
-            string propertyValue, 
+            string propertyValue,
             PropertyType propertyType
         )
         {
@@ -322,7 +322,7 @@ PropertyType propertyType
         internal BuildProperty
         (
             string propertyName,
-            string propertyValue, 
+            string propertyValue,
             PropertyType propertyType
         ) :
             this(null, propertyName, propertyValue, propertyType)
@@ -330,8 +330,8 @@ PropertyType propertyType
         }
 
         /// <summary>
-        /// Constructor, which initializes the property from just the property 
-        /// name and value, creating it as a "normal" property.  This ends up 
+        /// Constructor, which initializes the property from just the property
+        /// name and value, creating it as a "normal" property.  This ends up
         /// creating a new XML element for the property under a dummy XML document.
         /// </summary>
         /// <param name="propertyName"></param>
@@ -347,7 +347,7 @@ string propertyValue
         }
 
         /// <summary>
-        /// Default constructor.  This is not allowed because it leaves the 
+        /// Default constructor.  This is not allowed because it leaves the
         /// property in a bad state -- without a name or value.  But we have to
         /// have it, otherwise FXCop complains.
         /// </summary>
@@ -365,16 +365,16 @@ private BuildProperty
 
         /// <summary>
         /// Accessor for the property name.  This is read-only, so one cannot
-        /// change the property name once it's set ... your only option is 
+        /// change the property name once it's set ... your only option is
         /// to create a new BuildProperty object.  The reason is that BuildProperty objects
-        /// are often stored in hash tables where the hash function is based 
+        /// are often stored in hash tables where the hash function is based
         /// on the property name.  Modifying the property name of an existing
         /// BuildProperty object would make the hash table incorrect.
         /// </summary>
         /// <owner>RGoel</owner>
         public string Name
         {
-            get 
+            get
             {
                 if (propertyElement != null)
                 {
@@ -403,13 +403,13 @@ public string Value
             get
             {
                 // If we are not persisted, propertyName and propertyValue must not be null.
-                ErrorUtilities.VerifyThrow(this.propertyValue != null, 
+                ErrorUtilities.VerifyThrow(this.propertyValue != null,
                     "BuildProperty object doesn't have a name/value pair.");
 
                 return this.propertyValue;
             }
 
-            set 
+            set
             {
                 ErrorUtilities.VerifyThrowInvalidOperation(this.type != PropertyType.ImportedProperty,
                     "CannotModifyImportedProjects", this.Name);
@@ -491,7 +491,7 @@ public string FinalValue
         }
 
         /// <summary>
-        /// Accessor for the property type.  This is internal, so that nobody 
+        /// Accessor for the property type.  This is internal, so that nobody
         /// calling the OM can modify the type.  We actually need to modify
         /// it in certain cases internally.  C# doesn't allow a different
         /// access mode for the "get" vs. the "set", so we've made them both
@@ -500,12 +500,12 @@ public string FinalValue
         /// <owner>RGoel</owner>
         internal PropertyType Type
         {
-            get 
+            get
             {
                 return this.type;
             }
 
-            set 
+            set
             {
                 this.type = value;
             }
@@ -604,7 +604,7 @@ internal BuildPropertyGroup ParentPersistedPropertyGroup
         #region Methods
 
         /// <summary>
-        /// Given a property bag, this method evaluates the current property, 
+        /// Given a property bag, this method evaluates the current property,
         /// expanding any property references contained within.  It stores this
         /// evaluated value in the "finalValue" member.
         /// </summary>
@@ -636,11 +636,11 @@ private void MarkPropertyAsDirty
 
         /// <summary>
         /// Creates a shallow or deep clone of this BuildProperty object.
-        /// 
-        /// A shallow clone points at the same XML element as the original, so 
-        /// that modifications to the name or value will be reflected in both 
+        ///
+        /// A shallow clone points at the same XML element as the original, so
+        /// that modifications to the name or value will be reflected in both
         /// copies.  However, the two copies could have different a finalValue.
-        /// 
+        ///
         /// A deep clone actually clones the XML element as well, so that the
         /// two copies are completely independent of each other.
         /// </summary>
@@ -709,9 +709,9 @@ BuildProperty compareToProperty
             // just a back-pointer, and doesn't really contribute to the "identity" of
             // the property.
 
-            return 
+            return
                 (compareToProperty != null) &&
-                (0 == String.Compare(compareToProperty.propertyName, this.propertyName, StringComparison.OrdinalIgnoreCase)) &&
+                (String.Equals(compareToProperty.propertyName, this.propertyName, StringComparison.OrdinalIgnoreCase)) &&
                 (compareToProperty.propertyValue                == this.propertyValue) &&
                 (compareToProperty.FinalValue                   == this.FinalValue) &&
                 (compareToProperty.type                         == this.type);
@@ -742,7 +742,7 @@ public override string ToString
         public static explicit operator string
         (
             BuildProperty propertyToCast
-        ) 
+        )
         {
             if (propertyToCast == null)
             {
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index da1024b9787..6576ef8491a 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -242,7 +242,7 @@ internal BuildPropertyGroup(Project parentProject, XmlElement propertyGroupEleme
 
                     // Unrecognized attribute.
                     default:
-                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyGroupAttribute); 
+                        ProjectXmlUtilities.ThrowProjectInvalidAttribute(propertyGroupAttribute);
                         break;
                 }
             }
@@ -386,7 +386,7 @@ internal XmlAttribute ConditionAttribute
         }
 
         /// <summary>
-        /// Accessor for the XmlElement representing this property group.  This is 
+        /// Accessor for the XmlElement representing this property group.  This is
         /// internal to MSBuild, and is read-only.
         /// </summary>
         /// <owner>RGoel</owner>
@@ -525,7 +525,7 @@ internal string ImportedFromFilename
         /// <returns>The property with the given name, or null if it does not exist in this group</returns>
         public BuildProperty this[string propertyName]
         {
-            get 
+            get
             {
                 // We don't support this method for PropertyGroups that are persisted.
                 // This is because persisted PropertyGroups can contain multiple 
@@ -545,7 +545,7 @@ public BuildProperty this[string propertyName]
 
                 // Make sure that the property name passed into the indexer matches
                 // the property name on the BuildProperty object.
-                error.VerifyThrowArgument(0 == String.Compare(propertyName, value.Name, StringComparison.OrdinalIgnoreCase),
+                error.VerifyThrowArgument(String.Equals(propertyName, value.Name, StringComparison.OrdinalIgnoreCase),
                     "PropertyNamesDoNotMatch", "BuildProperty");
 
                 this.SetProperty(value);
@@ -627,7 +627,7 @@ bool deepClone
                     // Do not set the ParentProject on the new BuildPropertyGroup, because it isn't really
                     // part of the project
                     clone = new BuildPropertyGroup(null, propertyTableByName.Count);
-                    
+
                     foreach (DictionaryEntry propertyEntry in this.propertyTableByName)
                     {
                         // If the caller requested a deep clone, then deep clone the BuildProperty object,
@@ -707,8 +707,8 @@ part of the project */
         /// <summary>
         /// ImportInitialProperties is used when setting up an evaluated BuildProperty
         /// Group with the initial set of properties from MSBuild reserved properties,
-        /// environment variables, tools version dependent properties, and global 
-        /// properties.  After this virtual BuildPropertyGroup has been populated with 
+        /// environment variables, tools version dependent properties, and global
+        /// properties.  After this virtual BuildPropertyGroup has been populated with
         /// these, we can continue to read in the properties from the project file.
         /// </summary>
         /// <param name="environmentProperties"></param>
@@ -718,9 +718,9 @@ part of the project */
         /// <owner>RGoel</owner>
         internal void ImportInitialProperties
         (
-            BuildPropertyGroup environmentProperties, 
-            BuildPropertyGroup reservedProperties, 
-            BuildPropertyGroup toolsVersionDependentProperties, 
+            BuildPropertyGroup environmentProperties,
+            BuildPropertyGroup reservedProperties,
+            BuildPropertyGroup toolsVersionDependentProperties,
             BuildPropertyGroup globalProperties
         )
         {
@@ -754,7 +754,7 @@ BuildPropertyGroup globalProperties
         }
 
         /// <summary>
-        /// Sets a property. 
+        /// Sets a property.
         ///
         /// Either overrides the value of the property with the given name, or adds it if it
         /// doesn't already exist. Setting to the same value as before does nothing.
@@ -831,7 +831,7 @@ BuildProperty newProperty
                 }
                 else
                 {
-                    error.VerifyThrow((existingProperty == null) || (existingProperty.Type != PropertyType.OutputProperty), 
+                    error.VerifyThrow((existingProperty == null) || (existingProperty.Type != PropertyType.OutputProperty),
                         "If the property already exists in the main property table, it can't already be there as an output property, because then we would have stored an entry in propertiesOverriddenByOutputProperties.");
 
                     // NOTE: Use Hashtable.Add() because each output property should only be added to this
@@ -851,8 +851,8 @@ BuildProperty newProperty
         }
 
         /// <summary>
-        /// Sets a property taking the property name and value as strings directly. 
-        /// 
+        /// Sets a property taking the property name and value as strings directly.
+        ///
         /// Either overrides the value of the property with the given name, or adds it if it
         /// doesn't already exist. Setting to the same value as before does nothing.
         ///
@@ -883,7 +883,7 @@ public void SetProperty
             bool treatPropertyValueAsLiteral
             )
         {
-            this.SetProperty(propertyName, 
+            this.SetProperty(propertyName,
                 treatPropertyValueAsLiteral ? EscapingUtilities.Escape(propertyValue) : propertyValue);
         }
 
@@ -964,12 +964,12 @@ Project importedProject
         }
 
         /// <summary>
-        /// Adds an existing BuildProperty to the list of properties, does not attempt 
+        /// Adds an existing BuildProperty to the list of properties, does not attempt
         /// to add backing Xml for the item.
         /// </summary>
         /// <param name="propertyToAdd"></param>
         /// <owner>JomoF</owner>
-        internal void AddExistingProperty 
+        internal void AddExistingProperty
         (
             BuildProperty propertyToAdd
         )
@@ -1004,7 +1004,7 @@ BuildProperty propertyToAdd
             // Make sure the property to be added has an XML element backing it,
             // and that its XML belongs to the same XML document as our BuildPropertyGroup.
             error.VerifyThrow(propertyToAdd.PropertyElement != null, "BuildProperty does not have an XML element");
-            error.VerifyThrow(propertyToAdd.PropertyElement.OwnerDocument == this.ownerDocument, 
+            error.VerifyThrow(propertyToAdd.PropertyElement.OwnerDocument == this.ownerDocument,
                 "Cannot add an BuildProperty with a different XML owner document.");
 
             // For persisted groups, just append the property at the end of the <BuildPropertyGroup> tag.
@@ -1087,7 +1087,7 @@ string propertyName
                 // name.
                 foreach (BuildProperty property in this)
                 {
-                    if (0 == String.Compare(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(property.Name, propertyName, StringComparison.OrdinalIgnoreCase))
                     {
                         // Add the property to our list of things to remove.
                         propertiesToRemove.Add(property);
@@ -1277,7 +1277,7 @@ internal void MarkPropertyGroupAsDirty
         /// the previously gathered variables, and set new ones. This method
         /// will not, however, unset previously set variables.
         /// Requires property group to be virtual.
-        /// 
+        ///
         /// NOTE: this method does not allow environment variables to override
         /// previously set properties of type "GlobalProperty" or "ReservedProperty"
         /// </summary>
@@ -1323,7 +1323,7 @@ private void SetExtensionsPathProperties()
             // "MSBuildExtensionsPath32". This points to whatever the value of "Program Files (x86)" environment variable is;
             // but on a 32 bit box this isn't set, and we should use "Program Files" instead.
             string programFiles = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
-    
+
             // Similarly for "MSBuildExtensionsPath32". This points to whatever the value of "Program Files (x86)" environment variable is;
             // but on a 32 bit box this isn't set, and we should use "Program Files" instead.
             string programFiles32 = Environment.GetEnvironmentVariable(Constants.programFilesx86);
@@ -1342,7 +1342,7 @@ private void SetExtensionsPathProperties()
 
             bool useLegacyMSBuildExtensionsPathBehavior = !String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLEGACYEXTENSIONSPATH"));
 
-            string extensionsPath; 
+            string extensionsPath;
             if (useLegacyMSBuildExtensionsPathBehavior)
             {
                 extensionsPath = Path.Combine(programFiles, ReservedPropertyNames.extensionsPathSuffix);
@@ -1357,7 +1357,7 @@ private void SetExtensionsPathProperties()
 
         /// <summary>
         /// This method does a comparison of the actual contents of two property bags
-        /// and returns True if they are equal, else False.  Equality means that 
+        /// and returns True if they are equal, else False.  Equality means that
         /// the two collections contain the same set of property names (case insensitive)
         /// with the same values (case sensitive).
         /// Requires property group to be virtual.
@@ -1474,11 +1474,11 @@ string arg
 
             // If this is a persisted element, then we should have an
             // ArrayList of BuildProperty objects, but not a hash table.
-            error.VerifyThrow(this.propertyList != null, 
+            error.VerifyThrow(this.propertyList != null,
                 "ArrayList of BuildProperty objects expected for this BuildPropertyGroup.");
-            error.VerifyThrow(this.propertyTableByName == null, 
+            error.VerifyThrow(this.propertyTableByName == null,
                 "HashTable of BuildProperty objects not expected for this BuildPropertyGroup.");
-            error.VerifyThrow(this.ownerDocument != null, 
+            error.VerifyThrow(this.ownerDocument != null,
                 "There must be an owner document. It should have been set in the constructor.");
         }
 
@@ -1491,7 +1491,7 @@ private void MustBelongToPropertyGroup
             XmlElement propertyElement
         )
         {
-            error.VerifyThrowInvalidOperation(propertyElement != null, 
+            error.VerifyThrowInvalidOperation(propertyElement != null,
                 "PropertyDoesNotBelongToPropertyGroup");
             error.VerifyThrowInvalidOperation(propertyElement.ParentNode == this.propertyGroupElement,
                 "PropertyDoesNotBelongToPropertyGroup");
diff --git a/src/Deprecated/Engine/Resources/Constants.cs b/src/Deprecated/Engine/Resources/Constants.cs
index 23106a2504e..30c3ff7b0e5 100644
--- a/src/Deprecated/Engine/Resources/Constants.cs
+++ b/src/Deprecated/Engine/Resources/Constants.cs
@@ -45,16 +45,16 @@ internal static bool IsReservedProperty(string property)
         {
             return 
                 (
-                    (String.Compare(property, projectDirectory, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectFile, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectExtension, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectFullPath, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectName, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, binPath, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, toolsPath, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, projectDefaultTargets, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, programFiles32, StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(property, assemblyVersion, StringComparison.OrdinalIgnoreCase) == 0)
+                    (String.Equals(property, projectDirectory, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectFile, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectExtension, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectFullPath, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectName, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, binPath, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, toolsPath, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, projectDefaultTargets, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, programFiles32, StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(property, assemblyVersion, StringComparison.OrdinalIgnoreCase))
                     // Intentionally do not include MSBuildExtensionsPath or MSBuildExtensionsPath32 in this list.  We need tasks to be able to override those.
                 );
         }
diff --git a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
index 8544f1df8b1..dd92e681f9b 100644
--- a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
@@ -395,7 +395,7 @@ internal bool Equals(AssemblyNameExtension that)
             }
 
             // Do the names match?
-            if (0 != String.Compare(Name, that.Name, StringComparison.OrdinalIgnoreCase))
+            if (!String.Equals(Name, that.Name, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
diff --git a/src/Deprecated/Engine/Shared/ConversionUtilities.cs b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
index 0ea5e8ad182..bd0dcb8683a 100644
--- a/src/Deprecated/Engine/Shared/ConversionUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ConversionUtilities.cs
@@ -53,12 +53,12 @@ internal static bool CanConvertStringToBool(string parameterValue)
         /// </summary>
         private static bool ValidBooleanTrue(string parameterValue)
         {
-            return ((String.Compare(parameterValue, "true", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "on", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "yes", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!false", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!off", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!no", StringComparison.OrdinalIgnoreCase) == 0));
+            return ((String.Equals(parameterValue, "true", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "on", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "yes", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!false", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!off", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!no", StringComparison.OrdinalIgnoreCase)));
         }
 
         /// <summary>
@@ -67,12 +67,12 @@ private static bool ValidBooleanTrue(string parameterValue)
         /// </summary>
         private static bool ValidBooleanFalse(string parameterValue)
         {
-            return ((String.Compare(parameterValue, "false", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "off", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "no", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!true", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!on", StringComparison.OrdinalIgnoreCase) == 0) ||
-                    (String.Compare(parameterValue, "!yes", StringComparison.OrdinalIgnoreCase) == 0));
+            return ((String.Equals(parameterValue, "false", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "off", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "no", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!true", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!on", StringComparison.OrdinalIgnoreCase)) ||
+                    (String.Equals(parameterValue, "!yes", StringComparison.OrdinalIgnoreCase)));
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Shared/EscapingUtilities.cs b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
index 998f7579669..4edc578dfac 100644
--- a/src/Deprecated/Engine/Shared/EscapingUtilities.cs
+++ b/src/Deprecated/Engine/Shared/EscapingUtilities.cs
@@ -16,7 +16,7 @@ static internal class EscapingUtilities
     {
         /// <summary>
         /// Replaces all instances of %XX in the input string with the character represented
-        /// by the hexadecimal number XX. 
+        /// by the hexadecimal number XX.
         /// </summary>
         /// <param name="escapedString"></param>
         /// <returns>unescaped string</returns>
@@ -31,7 +31,7 @@ string escapedString
 
         /// <summary>
         /// Replaces all instances of %XX in the input string with the character represented
-        /// by the hexadecimal number XX. 
+        /// by the hexadecimal number XX.
         /// </summary>
         /// <param name="escapedString"></param>
         /// <param name="escapingWasNecessary"></param>
@@ -53,7 +53,7 @@ out bool escapingWasNecessary
             {
                 return escapedString;
             }
-            
+
             // This is where we're going to build up the final string to return to the caller.
             StringBuilder unescapedString = new StringBuilder();
 
@@ -76,7 +76,7 @@ out bool escapingWasNecessary
 
                     // Convert the %XX to an actual real character.
                     string hexString = escapedString.Substring(indexOfPercent + 1, 2);
-                    char unescapedCharacter = (char) int.Parse(hexString, System.Globalization.NumberStyles.HexNumber, 
+                    char unescapedCharacter = (char) int.Parse(hexString, System.Globalization.NumberStyles.HexNumber,
                         CultureInfo.InvariantCulture);
 
                     // if the unescaped character is not on the exception list, append it
@@ -170,7 +170,7 @@ string escapedString
                     )
                 {
                     // It has either a '%2' or a '%3'.  This is looking very promising.
-                    return 
+                    return
                         (
                             (-1 != escapedString.IndexOf("%2a", StringComparison.Ordinal)) ||
                             (-1 != escapedString.IndexOf("%2A", StringComparison.Ordinal)) ||
@@ -184,9 +184,9 @@ string escapedString
 
         /// <summary>
         /// Special characters that need escaping.
-        /// It's VERY important that the percent character is the FIRST on the list - since it's both a character 
-        /// we escape and use in escape sequences, we can unintentionally escape other escape sequences if we 
-        /// don't process it first. Of course we'll have a similar problem if we ever decide to escape hex digits 
+        /// It's VERY important that the percent character is the FIRST on the list - since it's both a character
+        /// we escape and use in escape sequences, we can unintentionally escape other escape sequences if we
+        /// don't process it first. Of course we'll have a similar problem if we ever decide to escape hex digits
         /// (that would require rewriting the algorithm) but since it seems unlikely that we ever do, this should
         /// be good enough to avoid complicating the algorithm at this point.
         /// </summary>
diff --git a/src/Deprecated/Engine/Shared/FileUtilities.cs b/src/Deprecated/Engine/Shared/FileUtilities.cs
index 919d67eb40b..4c088e00f9a 100644
--- a/src/Deprecated/Engine/Shared/FileUtilities.cs
+++ b/src/Deprecated/Engine/Shared/FileUtilities.cs
@@ -331,7 +331,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
 
                 try
                 {
-                    if (String.Compare(modifier, ItemSpecModifiers.FullPath, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(modifier, ItemSpecModifiers.FullPath, StringComparison.OrdinalIgnoreCase))
                     {
                         if(currentDirectory == null)
                         {
@@ -340,7 +340,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
 
                         modifiedItemSpec = GetFullPath(itemSpec, currentDirectory);
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.RootDir, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.RootDir, StringComparison.OrdinalIgnoreCase))
                     {
                         if (currentDirectory == null)
                         {
@@ -360,7 +360,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec += Path.DirectorySeparatorChar;
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Filename, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Filename, StringComparison.OrdinalIgnoreCase))
                     {
                         // if the item-spec is a root directory, it can have no filename
                         if (Path.GetDirectoryName(itemSpec) == null)
@@ -374,7 +374,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = Path.GetFileNameWithoutExtension(itemSpec);
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Extension, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Extension, StringComparison.OrdinalIgnoreCase))
                     {
                         // if the item-spec is a root directory, it can have no extension
                         if (Path.GetDirectoryName(itemSpec) == null)
@@ -388,11 +388,11 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = Path.GetExtension(itemSpec);
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.RelativeDir, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.RelativeDir, StringComparison.OrdinalIgnoreCase))
                     {
                         modifiedItemSpec = GetDirectory(itemSpec);
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Directory, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Directory, StringComparison.OrdinalIgnoreCase))
                     {
                         if (currentDirectory == null)
                         {
@@ -415,16 +415,16 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = modifiedItemSpec.Substring(root.Length + 1);
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.RecursiveDir, StringComparison.OrdinalIgnoreCase))
                     {
                         // only the BuildItem class can compute this modifier -- so leave empty
                         modifiedItemSpec = String.Empty;
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.Identity, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.Identity, StringComparison.OrdinalIgnoreCase))
                     {
                         modifiedItemSpec = itemSpec;
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.ModifiedTime, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.ModifiedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         isVolatile = true;
 
@@ -444,7 +444,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = String.Empty;
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.CreatedTime, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.CreatedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         isVolatile = true;
 
@@ -462,7 +462,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                             modifiedItemSpec = String.Empty;
                         }
                     }
-                    else if (String.Compare(modifier, ItemSpecModifiers.AccessedTime, StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(modifier, ItemSpecModifiers.AccessedTime, StringComparison.OrdinalIgnoreCase))
                     {
                         isVolatile = true;
 
diff --git a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
index bd0ef0a0c5b..d5a8422995e 100644
--- a/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
+++ b/src/Deprecated/Engine/Shared/FrameworkLocationHelper.cs
@@ -465,7 +465,7 @@ internal static bool CheckForFrameworkInstallation(string registryEntryToCheckIn
             if (String.IsNullOrEmpty(complusInstallRoot) && String.IsNullOrEmpty(complusVersion))
             {
                 // If the registry entry is 1 then the framework is installed. Go ahead and find the directory. If it is not 1 then the framework is not installed, return null.
-                return String.Compare("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase) == 0;
+                return String.Equals("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase);
             }
 
             return true;
@@ -517,7 +517,7 @@ GetDirectories getDirectories
             // This was removed in beta2
             // We should favor \v3.5 over \v3.5.xxxxx
             // versions previous to 2.0 have .xxxx version numbers.  3.0 and 3.5 do not.
-            if (max.EndsWith(prefix, StringComparison.OrdinalIgnoreCase) != true )
+            if (!max.EndsWith(prefix, StringComparison.OrdinalIgnoreCase))
             {
                 for (int i = 1; i < directories.Length; ++i)
                 {
diff --git a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
index ee6cb1b6727..e443b6f188c 100644
--- a/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectConfigurationInSolution.cs
@@ -50,7 +50,7 @@ internal bool IncludeInBuild
         /// <owner>LukaszG</owner>
         static private string RemoveSpaceFromAnyCpuPlatform(string platformName)
         {
-            if (string.Compare(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(platformName, "Any CPU", StringComparison.OrdinalIgnoreCase))
                 return "AnyCPU";
 
             return platformName;
diff --git a/src/Deprecated/Engine/Shared/ProjectInSolution.cs b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
index 90604ee33e0..c3cf27ccd70 100644
--- a/src/Deprecated/Engine/Shared/ProjectInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
@@ -251,7 +251,7 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
 
                 if (mainProjectElement?.LocalName == "Project")
                 {
-                    if (String.Compare(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase))
                     {
                         canBeMSBuildProjectFile = true;
                         return canBeMSBuildProjectFile;
@@ -374,7 +374,7 @@ static internal string DisambiguateProjectTargetName(string uniqueProjectName)
             // entry point targets
             foreach (string projectName in projectNamesToDisambiguate)
             {
-                if (String.Compare(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(uniqueProjectName, projectName, StringComparison.OrdinalIgnoreCase))
                 {
                     // Prepend "Solution:" so that the collision is resolved, but the
                     // log of the solution project still looks reasonable.
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 5afdb923307..2dc255497a1 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -934,7 +934,7 @@ string propertyValue
             else
             {
                 // ProjectReferences = "{FD705688-88D1-4C22-9BFF-86235D89C2FC}|CSClassLibrary1.dll;{F0726D09-042B-4A7A-8A01-6BED2422BD5D}|VCClassLibrary1.dll;" 
-                if (string.Compare(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(propertyName, "ProjectReferences", StringComparison.OrdinalIgnoreCase))
                 {
                     string[] projectReferenceEntries = propertyValue.Split(new char[] { ';' });
 
@@ -1014,21 +1014,21 @@ ProjectInSolution proj
             ValidateProjectRelativePath(proj);
             
             // Figure out what type of project this is.
-            if ((String.Compare(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase) == 0))
+            if ((String.Equals(projectTypeGuid, vbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, csProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)))
             {
                 proj.ProjectType = SolutionProjectType.ManagedProject;
             }
-            else if (String.Compare(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, solutionFolderGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.SolutionFolder;
             }
-            else if (String.Compare(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, vcProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.VCProject;
             }
-            else if (String.Compare(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(projectTypeGuid, webProjectGuid, StringComparison.OrdinalIgnoreCase))
             {
                 proj.ProjectType = SolutionProjectType.WebProject;
                 solutionContainsWebProjects = true;
@@ -1108,7 +1108,7 @@ internal void ParseSolutionConfigurations()
                 string fullConfigurationName = configurationNames[0].Trim();
 
                 //Fixing bug 555577: Solution file can have description information, in which case we ignore.
-                if (0 == String.Compare(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(fullConfigurationName, "DESCRIPTION", StringComparison.OrdinalIgnoreCase))
                     continue;
 
                 // Both names must be identical
@@ -1250,7 +1250,7 @@ internal string GetDefaultConfigurationName()
             // Pick the Debug configuration as default if present
             foreach (ConfigurationInSolution solutionConfiguration in this.SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     defaultConfigurationName = solutionConfiguration.ConfigurationName;
                     break;
@@ -1285,7 +1285,7 @@ internal string GetDefaultPlatformName()
             // Pick the Mixed Platforms platform as default if present
             foreach (ConfigurationInSolution solutionConfiguration in this.SolutionConfigurations)
             {
-                if (string.Compare(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(solutionConfiguration.PlatformName, "Mixed Platforms", StringComparison.OrdinalIgnoreCase))
                 {
                     defaultPlatformName = solutionConfiguration.PlatformName;
                     break;
diff --git a/src/Deprecated/Engine/Shared/TypeLoader.cs b/src/Deprecated/Engine/Shared/TypeLoader.cs
index 9485f1065c1..b8066557901 100644
--- a/src/Deprecated/Engine/Shared/TypeLoader.cs
+++ b/src/Deprecated/Engine/Shared/TypeLoader.cs
@@ -224,7 +224,7 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
             // check if the type names match exactly
             else
             {
-                isPartialMatch = (String.Compare(typeName1, typeName2, StringComparison.OrdinalIgnoreCase) == 0);
+                isPartialMatch = (String.Equals(typeName1, typeName2, StringComparison.OrdinalIgnoreCase));
             }
 
             return isPartialMatch;
diff --git a/src/Deprecated/Engine/Shared/XMakeAttributes.cs b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
index d7a94ebf80b..dd34b370cb4 100644
--- a/src/Deprecated/Engine/Shared/XMakeAttributes.cs
+++ b/src/Deprecated/Engine/Shared/XMakeAttributes.cs
@@ -91,10 +91,10 @@ string attribute
         internal static bool IsBadlyCasedSpecialTaskAttribute(string attribute)
         {
             return (!IsSpecialTaskAttribute(attribute) &&
-                ((String.Compare(attribute, condition, StringComparison.OrdinalIgnoreCase) == 0) ||
-                (String.Compare(attribute, continueOnError, StringComparison.OrdinalIgnoreCase) == 0) || 
-                (String.Compare(attribute, msbuildRuntime, StringComparison.OrdinalIgnoreCase) == 0) || 
-                (String.Compare(attribute, msbuildArchitecture, StringComparison.OrdinalIgnoreCase) == 0)));
+                ((String.Equals(attribute, condition, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(attribute, continueOnError, StringComparison.OrdinalIgnoreCase)) || 
+                (String.Equals(attribute, msbuildRuntime, StringComparison.OrdinalIgnoreCase)) || 
+                (String.Equals(attribute, msbuildArchitecture, StringComparison.OrdinalIgnoreCase))));
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Shared/XmlUtilities.cs b/src/Deprecated/Engine/Shared/XmlUtilities.cs
index ed3e9f42c97..9c1418ee16f 100644
--- a/src/Deprecated/Engine/Shared/XmlUtilities.cs
+++ b/src/Deprecated/Engine/Shared/XmlUtilities.cs
@@ -211,14 +211,14 @@ string attributeName
                     {
                         if (xmlReader.NodeType == XmlNodeType.Element)
                         {
-                            if (String.Compare(xmlReader.Name, elementName, StringComparison.OrdinalIgnoreCase) == 0)
+                            if (String.Equals(xmlReader.Name, elementName, StringComparison.OrdinalIgnoreCase))
                             {
                                 if (xmlReader.HasAttributes)
                                 {
                                     for (int i = 0; i < xmlReader.AttributeCount; i++)
                                     {
                                         xmlReader.MoveToAttribute(i);
-                                        if (String.Compare(xmlReader.Name, attributeName, StringComparison.OrdinalIgnoreCase) == 0)
+                                        if (String.Equals(xmlReader.Name, attributeName, StringComparison.OrdinalIgnoreCase))
                                         {
                                             attributeValue = xmlReader.Value;
                                             break;
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index ee28925fc59..5166776fe9c 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -30,7 +30,7 @@ static public class SolutionWrapperProject
 
         /// <summary>
         /// Given the full path to a solution, returns a string containing the v3.5 MSBuild-format
-        /// wrapper project for that solution.  
+        /// wrapper project for that solution.
         /// </summary>
         /// <param name="solutionPath">Full path to the solution we are wrapping</param>
         /// <param name="toolsVersionOverride">May be null.  If non-null, contains the ToolsVersion passed in on the command line</param>\
@@ -55,7 +55,7 @@ static public string Generate(string solutionPath, string toolsVersionOverride,
         /// </summary>
         /// <param name="solution"></param>
         /// <param name="msbuildProject"></param>
-        /// <param name="toolsVersionOverride">Tools Version override (may be null). 
+        /// <param name="toolsVersionOverride">Tools Version override (may be null).
         /// Any /tv:xxx switch would cause a value here.</param>
         /// <returns></returns>
         /// <owner>RGoel</owner>
@@ -200,7 +200,7 @@ private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile,  s
                 parentEngine.LoggingServices.LogComment(projectBuildEventContext, "SolutionCacheNotApplicable", "Configuration", cacheSolutionConfigurationName, fullSolutionConfigurationName);
                 return false;
             }
-            
+
             if (!String.Equals(wrapperProjectToolsVersion, cacheToolsVersion, StringComparison.OrdinalIgnoreCase))
             {
                 parentEngine.LoggingServices.LogComment(projectBuildEventContext, "SolutionCacheNotApplicable", "ToolsVersion", cacheToolsVersion, wrapperProjectToolsVersion);
@@ -260,7 +260,7 @@ private static bool IsCacheUpToDate(Engine parentEngine, string solutionFile,  s
             else
             {
                 return true;
-            }   
+            }
         }
 
         /// <summary>
@@ -445,7 +445,7 @@ private static void AddCacheRelatedProperties(Project msbuildProject, string ful
                 // Only add projects that correspond to actual files on disk. Solution folders and web projects correspond to folders, so we don't care about them.
                 if (project.ProjectType != SolutionProjectType.SolutionFolder && project.ProjectType != SolutionProjectType.WebProject)
                 {
-                    cacheItemGroup.AddNewItem(cacheProjectListName, EscapingUtilities.Escape(project.RelativePath)); 
+                    cacheItemGroup.AddNewItem(cacheProjectListName, EscapingUtilities.Escape(project.RelativePath));
                 }
             }
         }
@@ -503,10 +503,10 @@ private static string DetermineChildProjectToolsVersion(Engine parentEngine, str
         /// <owner>RGoel, LukaszG</owner>
         static private BuildTask AddMSBuildTaskElement
         (
-            Target target, 
+            Target target,
             string projectPath,
-            string msbuildTargetName, 
-            string configurationName, 
+            string msbuildTargetName,
+            string configurationName,
             string platformName,
             bool specifyProjectToolsVersion
         )
@@ -543,7 +543,7 @@ bool specifyProjectToolsVersion
         /// <param name="msbuildProject"></param>
         /// <param name="solution"></param>
         /// <param name="proj"></param>
-        /// <param name="targetOutputItemName">The name of the item exposing this target's outputs.  May be null.</param>        
+        /// <param name="targetOutputItemName">The name of the item exposing this target's outputs.  May be null.</param>
         /// <param name="subTargetName"></param>
         /// <owner>RGoel, LukaszG</owner>
         static private void AddTargetForManagedProject
@@ -569,7 +569,7 @@ string subTargetName
             {
                 newTarget.TargetElement.SetAttribute("Outputs", string.Format(CultureInfo.InvariantCulture, "@({0})", targetOutputItemName));
             }
-            
+
             // Only create build items if we're called with the null subtarget. We're getting called
             // a total of four times and only want to create the build items once.
             bool createBuildItems = (subTargetName == null);
@@ -599,7 +599,7 @@ string subTargetName
                         // PERF: We could emit two <MSBuild> tasks, with a condition on them. But this doubles the size of
                         // the solution wrapper project, and the cost is too high. The consequence is that when solution wrapper
                         // projects are emitted to disk (with MSBUILDEMITSOLUION=1) they cannot be reused for tools version v2.0.
-                        bool specifyProjectToolsVersion = 
+                        bool specifyProjectToolsVersion =
                             String.Equals(msbuildProject.ToolsVersion, "2.0", StringComparison.OrdinalIgnoreCase) ? false : true;
 
                         BuildTask msbuildTask = AddMSBuildTaskElement(newTarget, proj.RelativePath, subTargetName,
@@ -718,7 +718,7 @@ out string addedReferenceGuids
                     (referencedProject.ProjectConfigurations.TryGetValue(solutionConfiguration.FullName, out referencedProjectConfiguration)) &&
                     (referencedProjectConfiguration != null))
                 {
-                    string outputReferenceItemNameWithSuffix = string.Format(CultureInfo.InvariantCulture, "{0}_{1}", 
+                    string outputReferenceItemNameWithSuffix = string.Format(CultureInfo.InvariantCulture, "{0}_{1}",
                         outputReferenceItemName, outputReferenceItemNameSuffix);
 
                     bool addCreateItem = false;
@@ -733,7 +733,7 @@ out string addedReferenceGuids
                         BuildTask msbuildTask = AddMSBuildTaskElement(target, referencedProject.RelativePath, "GetTargetPath",
                             referencedProjectConfiguration.ConfigurationName, referencedProjectConfiguration.PlatformName, specifyProjectToolsVersion);
                         msbuildTask.Condition = condition;
-                        msbuildTask.AddOutputItem("TargetOutputs", outputReferenceItemNameWithSuffix);                        
+                        msbuildTask.AddOutputItem("TargetOutputs", outputReferenceItemNameWithSuffix);
 
                         if (referenceGuids.Length > 0)
                         {
@@ -766,7 +766,7 @@ out string addedReferenceGuids
 
                         vcbuildTask.Condition = GetConditionStringForConfiguration(solutionConfiguration);
                         vcbuildTask.AddOutputItem("ResolvedOutputPaths", outputReferenceItemNameWithSuffix);
-                        
+
                         if (outputImportLibraryItemName != null)
                         {
                             vcbuildTask.AddOutputItem("ResolvedImportLibraryPaths", outputImportLibraryItemName);
@@ -953,15 +953,15 @@ string subTargetName
                         if (proj.ProjectReferences.Count > 0)
                         {
                             projectPath = AddCreateTemporaryVCProjectTasks(solution, msbuildProject, newTarget, proj,
-                                solutionConfiguration, subTargetName, 
+                                solutionConfiguration, subTargetName,
                                 vcProjectConfiguration.FullName);
                         }
 
                         newTask = VCWrapperProject.AddVCBuildTaskElement(
                             msbuildProject,
                             newTarget,
-                            EscapingUtilities.Escape(Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.SolutionFile))), 
-                            projectPath, subTargetName, 
+                            EscapingUtilities.Escape(Path.Combine(solution.SolutionFileDirectory, Path.GetFileName(solution.SolutionFile))),
+                            projectPath, subTargetName,
                             null, EscapingUtilities.Escape(vcProjectConfiguration.FullName));
 
                         // Delete the temporary VC project
@@ -1032,7 +1032,7 @@ Project msbuildProject
 
             // TFV v3.5 supported by TV 4.0, TV 3.5
             getFrameworkPathTask.AddOutputItem(
-                "FrameworkVersion35Path", 
+                "FrameworkVersion35Path",
                 "_CombinedTargetFrameworkDirectoriesItem",
                 " ('$(TargetFrameworkVersion)' == 'v3.5' or '$(TargetFrameworkVersion)' == 'v4.0') and '$(MSBuildToolsVersion)' != '2.0'");
 
@@ -1083,9 +1083,9 @@ string conditionDescribingValidConfigurations
 
             newTask.Condition = conditionDescribingValidConfigurations;
         }
-            
+
         /// <summary>
-        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced 
+        /// Add a call to the ResolveAssemblyReference task to crack the pre-resolved referenced
         /// assemblies for the complete list of dependencies, PDBs, satellites, etc.  The invoke
         /// the Copy task to copy all these files (or at least the ones that RAR determined should
         /// be copied local) into the web project's bin directory.
@@ -1097,9 +1097,9 @@ string conditionDescribingValidConfigurations
         /// <owner>RGoel</owner>
         static private void AddTasksToCopyAllDependenciesIntoBinDir
             (
-            Target target, 
-            ProjectInSolution proj, 
-            string referenceItemName, 
+            Target target,
+            ProjectInSolution proj,
+            string referenceItemName,
             string conditionDescribingValidConfigurations
             )
         {
@@ -1139,7 +1139,7 @@ string conditionDescribingValidConfigurations
             BuildTask copyTask = target.AddNewTask("Copy");
             copyTask.SetParameterValue("SourceFiles", "@(" + copyLocalFilesItemName + ")", false /* DO NOT treat as literal */);
             copyTask.SetParameterValue("DestinationFiles", String.Format(CultureInfo.InvariantCulture,
-                @"@({0}->'{1}%(DestinationSubDirectory)%(Filename)%(Extension)')", 
+                @"@({0}->'{1}%(DestinationSubDirectory)%(Filename)%(Extension)')",
                 copyLocalFilesItemName, destinationFolder), false /* DO NOT treat as literal */);
             copyTask.Condition = conditionDescribingValidConfigurations;
         }
@@ -1156,16 +1156,16 @@ string conditionDescribingValidConfigurations
         /// <owner>RGoel</owner>
         static private void AddPropertyGroupForAspNetConfiguration
             (
-            Project msbuildProject, 
-            ProjectInSolution proj, 
-            string configurationName, 
+            Project msbuildProject,
+            ProjectInSolution proj,
+            string configurationName,
             AspNetCompilerParameters aspNetCompilerParameters,
             string solutionFile
             )
         {
             // Add a new PropertyGroup that is condition'd on the Configuration.
             BuildPropertyGroup newPropertyGroup = msbuildProject.AddNewPropertyGroup(false /* insertAtEndOfProject = false */);
-            newPropertyGroup.Condition = String.Format(CultureInfo.InvariantCulture, " '$(AspNetConfiguration)' == '{0}' ", 
+            newPropertyGroup.Condition = String.Format(CultureInfo.InvariantCulture, " '$(AspNetConfiguration)' == '{0}' ",
                 EscapingUtilities.Escape(configurationName));
 
             // Add properties into the property group for each of the AspNetCompiler properties.
@@ -1218,8 +1218,8 @@ string solutionFile
                     // override the AspNetTargetPath.  What we want to do in this case is concatenate:
                     //  $(OutDir) + "\_PublishedWebsites" + (the last portion of the folder in the AspNetPhysicalPath).
                     BuildProperty targetPathOverrideProperty = newPropertyGroup.AddNewProperty(GenerateSafePropertyName(proj, "AspNetTargetPath"),
-                        @"$(OutDir)" + 
-                        EscapingUtilities.Escape(webProjectOverrideFolder) + Path.DirectorySeparatorChar + 
+                        @"$(OutDir)" +
+                        EscapingUtilities.Escape(webProjectOverrideFolder) + Path.DirectorySeparatorChar +
                         EscapingUtilities.Escape(lastFolderInPhysicalPath) + Path.DirectorySeparatorChar);
                     targetPathOverrideProperty.Condition = " '$(OutDir)' != '' ";
                 }
@@ -1227,10 +1227,10 @@ string solutionFile
         }
 
         /// <summary>
-        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of 
-        /// a web project.  These .REFRESH files are just text files that contain absolute or 
-        /// relative paths to the referenced assemblies.  The goal of these tasks is to 
-        /// search all *.REFRESH files and extract fully-qualified absolute paths for 
+        /// This code handles the *.REFRESH files that are in the "bin" subdirectory of
+        /// a web project.  These .REFRESH files are just text files that contain absolute or
+        /// relative paths to the referenced assemblies.  The goal of these tasks is to
+        /// search all *.REFRESH files and extract fully-qualified absolute paths for
         /// each of the references.
         /// </summary>
         /// <param name="target"></param>
@@ -1239,8 +1239,8 @@ string solutionFile
         /// <owner>RGoel</owner>
         static private void AddTasksToResolveAutoRefreshFileReferences
             (
-            Target target, 
-            ProjectInSolution proj, 
+            Target target,
+            ProjectInSolution proj,
             string referenceItemName
             )
         {
@@ -1254,7 +1254,7 @@ string referenceItemName
             // Read the lines out of each .REFRESH file; they should be paths to .DLLs.  Put these paths
             // into an item list.
             BuildTask readLinesTask = target.AddNewTask("ReadLinesFromFile");
-            readLinesTask.SetParameterValue("File", 
+            readLinesTask.SetParameterValue("File",
                 String.Format(CultureInfo.InvariantCulture, @"%({0}_RefreshFile.Identity)", referenceItemName));
             readLinesTask.Condition = String.Format(CultureInfo.InvariantCulture, @" '%({0}_RefreshFile.Identity)' != '' ", referenceItemName);
             readLinesTask.AddOutputItem("Lines", referenceItemName + "_ReferenceRelPath");
@@ -1264,14 +1264,14 @@ string referenceItemName
             // directly to RAR later.
             BuildTask combinePathTask = target.AddNewTask("CombinePath");
             combinePathTask.SetParameterValue("BasePath", webRoot);
-            combinePathTask.SetParameterValue("Paths", 
+            combinePathTask.SetParameterValue("Paths",
                 String.Format(CultureInfo.InvariantCulture, @"@({0}_ReferenceRelPath)", referenceItemName));
             combinePathTask.AddOutputItem("CombinedPaths", referenceItemName);
         }
 
         /// <summary>
         /// When adding a target to build a web project, we want to put a Condition on the Target node that
-        /// effectively says "Only build this target if the web project is active (marked for building) in the 
+        /// effectively says "Only build this target if the web project is active (marked for building) in the
         /// current solution configuration.
         /// </summary>
         /// <param name="solution"></param>
@@ -1304,8 +1304,8 @@ ProjectInSolution proj
                         condition.Append(")");
                     }
                 }
-                else if (String.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0 ||
-                         String.Compare(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) ||
+                         String.Equals(solutionConfiguration.ConfigurationName, "Debug", StringComparison.OrdinalIgnoreCase))
                 {
                     // we don't have a project configuration that matches the solution configuration but
                     // the solution configuration is called "Release" or "Debug" which are standard AspNetConfigurations
@@ -1392,14 +1392,14 @@ string subTargetName
                     // subTargetName=null and once when subTargetName="Rebuild".
                     if (subTargetName == null)
                     {
-                        AddPropertyGroupForAspNetConfiguration(msbuildProject, proj, configurationName, 
+                        AddPropertyGroupForAspNetConfiguration(msbuildProject, proj, configurationName,
                             aspNetCompilerParameters, solution.SolutionFile);
                     }
 
                     // Update our big condition string to include this configuration.
                     conditionDescribingValidConfigurations.Append(" or ");
                     conditionDescribingValidConfigurations.Append(
-                        String.Format(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')", 
+                        String.Format(CultureInfo.InvariantCulture, "('$(AspNetConfiguration)' == '{0}')",
                         EscapingUtilities.Escape(configurationName)));
                 }
 
@@ -1496,7 +1496,7 @@ private static string MakeIntoSafeItemName(string name)
         /// <param name="textResourceName">Resource string name to use in the tag text</param>
         /// <param name="args">Additional parameters to pass to FormatString</param>
         /// <owner>LukaszG</owner>
-        static internal BuildTask AddErrorWarningMessageElement(Target target, string elementType, 
+        static internal BuildTask AddErrorWarningMessageElement(Target target, string elementType,
             bool treatAsLiteral, string textResourceName, params object[] args)
         {
             string code = null;
@@ -1525,7 +1525,7 @@ static internal BuildTask AddErrorWarningMessageElement(Target target, string el
         /// <param name="msbuildProject">The project to add the target to</param>
         /// <param name="proj">The project to add as a target.</param>
         /// <param name="subTargetName">The target to call within the project that's being added.</param>
-        /// <param name="errorMessage">Optional detailed error message to print out in case we already tried accessing the 
+        /// <param name="errorMessage">Optional detailed error message to print out in case we already tried accessing the
         /// project file before and failed.</param>
         /// <owner>RGoel</owner>
         static private void AddTargetForUnknownProjectType
@@ -1596,8 +1596,8 @@ string errorMessage
         /// <owner>RGoel</owner>
         static private Target AddAllDependencyTarget
         (
-            Project msbuildProject, 
-            string targetName, 
+            Project msbuildProject,
+            string targetName,
             string targetOutputItemName,
             string subTargetName,
             Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
@@ -1605,7 +1605,7 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
         {
             Target newTarget = msbuildProject.Targets.AddNewTarget(targetName);
             newTarget.Condition = "'$(CurrentSolutionConfigurationContents)' != ''";
-            
+
             if (!String.IsNullOrEmpty(targetOutputItemName))
             {
                 newTarget.TargetElement.SetAttribute("Outputs", string.Format(CultureInfo.InvariantCulture, "@({0})", targetOutputItemName));
@@ -1639,14 +1639,14 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
                     msbuildTask.SetParameterValue("UseResultsCache", "$(UseResultsCache)");
                 }
 
-                BuildTask messageTask = AddErrorWarningMessageElement(newTarget, XMakeElements.message, false /* don't treat as literal */, "SolutionProjectSkippedForBuilding", 
+                BuildTask messageTask = AddErrorWarningMessageElement(newTarget, XMakeElements.message, false /* don't treat as literal */, "SolutionProjectSkippedForBuilding",
                     string.Format(CultureInfo.InvariantCulture, "%(SkipLevel{0}.Identity)", dependencyLevel), "$(Configuration)|$(Platform)");
                 messageTask.Condition = string.Format(CultureInfo.InvariantCulture, "@(SkipLevel{0}) != ''", dependencyLevel);
 
                 BuildTask warningTask = AddErrorWarningMessageElement(newTarget, XMakeElements.warning, false /* don't treat as literal */, "SolutionProjectConfigurationMissing",
                     string.Format(CultureInfo.InvariantCulture, "%(MissingConfigLevel{0}.Identity)", dependencyLevel), "$(Configuration)|$(Platform)");
                 warningTask.Condition = string.Format(CultureInfo.InvariantCulture, "@(MissingConfigLevel{0}) != ''", dependencyLevel);
-                
+
                 string allProjects = GetAllNonMSBuildProjectDependencies(projectsByDependencyLevel, dependencyLevel, subTargetName);
                 if (allProjects.Length > 0)
                 {
@@ -1709,8 +1709,8 @@ static private string GetProjectDependencies(SolutionParser solution, ProjectInS
         /// <returns></returns>
         static private string GetAllNonMSBuildProjectDependencies
         (
-            Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel, 
-            int dependencyLevel, 
+            Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel,
+            int dependencyLevel,
             string subTargetName
         )
         {
@@ -1758,7 +1758,7 @@ string subTargetName
         static private string GetConditionStringForConfiguration(ConfigurationInSolution configuration)
         {
             return string.Format(CultureInfo.InvariantCulture, " ('$(Configuration)' == '{0}') and ('$(Platform)' == '{1}') ",
-                EscapingUtilities.Escape(configuration.ConfigurationName), 
+                EscapingUtilities.Escape(configuration.ConfigurationName),
                 EscapingUtilities.Escape(configuration.PlatformName));
         }
 
@@ -1793,7 +1793,7 @@ SolutionParser solution
         /// <owner>LukaszG</owner>
         static internal void AddPropertyGroupForSolutionConfiguration
         (
-            Project msbuildProject, 
+            Project msbuildProject,
             SolutionParser solution,
             ConfigurationInSolution solutionConfiguration
         )
@@ -1827,12 +1827,12 @@ ConfigurationInSolution solutionConfiguration
         /// <summary>
         /// Creates the default Venus configuration property based on the selected solution configuration.
         /// Unfortunately, Venus projects only expose one project configuration in the IDE (Debug) although
-        /// they allow building Debug and Release from command line. This means that if we wanted to use 
+        /// they allow building Debug and Release from command line. This means that if we wanted to use
         /// the project configuration from the active solution configuration for Venus projects, we'd always
         /// end up with Debug and there'd be no way to build the Release configuration. To work around this,
         /// we use a special mechanism for choosing ASP.NET project configuration: we set it to Release if
-        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution 
-        /// configuration. The property is also settable from the command line, in which case it takes 
+        /// we're building a Release solution configuration, and to Debug if we're building a Debug solution
+        /// configuration. The property is also settable from the command line, in which case it takes
         /// precedence over this algorithm.
         /// </summary>
         /// <param name="msbuildProject"></param>
@@ -1888,7 +1888,7 @@ static private void AddGlobalProperties(Project msbuildProject, SolutionParser s
 
         /// <summary>
         /// Special hack for web projects. It can happen that there is no Release configuration for solutions
-        /// containing web projects, yet we still want to be able to build the Release configuration for 
+        /// containing web projects, yet we still want to be able to build the Release configuration for
         /// those projects. Since the ASP.NET project configuration defaults to the solution configuration,
         /// we allow Release even if it doesn't actually exist in the solution.
         /// </summary>
@@ -1901,7 +1901,7 @@ static private void AddFakeReleaseSolutionConfigurationIfNecessary(SolutionParse
                 bool solutionHasReleaseConfiguration = false;
                 foreach (ConfigurationInSolution solutionConfiguration in solution.SolutionConfigurations)
                 {
-                    if (string.Compare(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(solutionConfiguration.ConfigurationName, "Release", StringComparison.OrdinalIgnoreCase))
                     {
                         solutionHasReleaseConfiguration = true;
                         break;
@@ -1941,13 +1941,13 @@ static private void AddInitialTargets(Project msbuildProject)
                 "SolutionToolsVersionDoesNotSupportProjectToolsVersion", "$(MSBuildToolsVersion)");
             toolsVersionErrorTask.Condition = "'$(MSBuildToolsVersion)' == '2.0' and ('$(ProjectToolsVersion)' != '2.0' and '$(ProjectToolsVersion)' != '')";
 
-            msbuildProject.InitialTargets = initialTarget.Name + ";" + validateToolsVersionsTarget.Name;            
-        }          
+            msbuildProject.InitialTargets = initialTarget.Name + ";" + validateToolsVersionsTarget.Name;
+        }
 
         /// <summary>
         /// Normally the active solution configuration/platform is determined when we build the solution
         /// wrapper project, not when we create it. However, we need to know them to scan project references
-        /// for the right project configuration/platform. It's unlikely that references would be conditional, 
+        /// for the right project configuration/platform. It's unlikely that references would be conditional,
         /// but still possible and we want to get that case right.
         /// </summary>
         /// <returns></returns>
@@ -1979,7 +1979,7 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionParser
         {
             string activeSolutionConfiguration;
             string activeSolutionPlatform;
-            
+
             BuildProperty configurationProperty = parentEngine.GlobalProperties["Configuration"];
             BuildProperty platformProperty = parentEngine.GlobalProperties["Platform"];
 
@@ -2008,7 +2008,7 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionParser
 
         /// <summary>
         /// Loads each MSBuild project in this solution and looks for its project-to-project references so that
-        /// we know what build order we should use when building the solution. 
+        /// we know what build order we should use when building the solution.
         /// </summary>
         /// <owner>LukaszG</owner>
         static private void ScanProjectDependencies(SolutionParser solution, Engine parentEngine, string childProjectToolsVersion, string fullSolutionConfigurationName, BuildEventContext projectBuildEventContext)
@@ -2029,7 +2029,7 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                     continue;
                 }
 
-                if ((project.ProjectType == SolutionProjectType.ManagedProject) || 
+                if ((project.ProjectType == SolutionProjectType.ManagedProject) ||
                     ((project.ProjectType == SolutionProjectType.Unknown) && (project.CanBeMSBuildProjectFile(out message))))
                 {
                     try
@@ -2037,7 +2037,7 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                         //Will fail to load a throw an error if the tools version is incorrect.
                         Project msbuildProject = new Project(parentEngine, childProjectToolsVersion);
                         msbuildProject.IsLoadedByHost = false;
-                        
+
                         // this is before building the solution wrapper project, so the current directory may be not set to
                         // the one containing the solution file, and we'd get the relative path wrong
                         msbuildProject.Load(project.AbsolutePath);
@@ -2046,11 +2046,11 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                         // so set it before retrieving references.
                         msbuildProject.GlobalProperties.SetProperty("Configuration",
                             project.ProjectConfigurations[fullSolutionConfigurationName].ConfigurationName, true /* treat as literal */);
-                        msbuildProject.GlobalProperties.SetProperty("Platform", 
+                        msbuildProject.GlobalProperties.SetProperty("Platform",
                             project.ProjectConfigurations[fullSolutionConfigurationName].PlatformName, true /* treat as literal */);
-                        
+
                         BuildItemGroup references = msbuildProject.GetEvaluatedItemsByName("ProjectReference");
-                        
+
                         foreach (BuildItem reference in references)
                         {
                             string referencedProjectGuid = reference.GetEvaluatedMetadata("Project");   // Need unescaped data here.
@@ -2088,7 +2088,7 @@ static private void ScanProjectDependencies(SolutionParser solution, Engine pare
                             // Grab the guid with its curly braces...
                             referencedWebProjectGuid = referencedWebProjectGuid.Substring(0, 38);
                             AddDependencyByGuid(solution, project, parentEngine, projectBuildEventContext, referencedWebProjectGuid);
-                        }                                                
+                        }
                     }
                     // We don't want any problems scanning the project file to result in aborting the build.
                     catch (Exception e)
@@ -2172,7 +2172,7 @@ static private void AddDependencyByGuid(SolutionParser solution, ProjectInSoluti
         /// For MSBuild projects, project dependencies you can set in the IDE only represent build order constraints.
         /// If both projects are VC however, the VC project system treats dependencies as regular P2P references.
         /// This behavior is a carry-over from the days of VC5/6, that's how P2P refs were done back then. Tricky.
-        /// To compensate for that, we need to add a P2P reference for every dependency between two VC projects. 
+        /// To compensate for that, we need to add a P2P reference for every dependency between two VC projects.
         /// MSBuild -> VC, VC -> MSBuild dependencies are not affected.
         /// </summary>
         /// <param name="solution"></param>
@@ -2273,11 +2273,11 @@ static private void AssignDependencyLevels(SolutionParser solution, Dictionary<i
         }
 
         /// <summary>
-        /// Add virtual references for reference chains containing VC static library projects. 
+        /// Add virtual references for reference chains containing VC static library projects.
         /// Since static libraries have no link step, any references they have to be passed
         /// to their parent project, if any. So for example, in a chain like
         /// native dll -> native static lib1 -> native static lib2
-        /// we need to add a virtual reference between the native dll and the static lib2 
+        /// we need to add a virtual reference between the native dll and the static lib2
         /// to maintain parity with the IDE behavior.
         /// </summary>
         /// <param name="solution"></param>
@@ -2312,7 +2312,7 @@ private static void GatherChildReferencesForStaticLibraries(SolutionParser solut
                     {
                         foreach (string childReferenceGuid in referencedProject.ProjectReferences)
                         {
-                            if (!project.ProjectReferences.Contains(childReferenceGuid) && 
+                            if (!project.ProjectReferences.Contains(childReferenceGuid) &&
                                 !referenceGuidsToAdd.Contains(childReferenceGuid))
                             {
                                 referenceGuidsToAdd.Add(childReferenceGuid);
diff --git a/src/Deprecated/Engine/Solution/VCProjectParser.cs b/src/Deprecated/Engine/Solution/VCProjectParser.cs
index a58f9d2bf4e..0aaaa4658d5 100644
--- a/src/Deprecated/Engine/Solution/VCProjectParser.cs
+++ b/src/Deprecated/Engine/Solution/VCProjectParser.cs
@@ -58,8 +58,8 @@ internal static bool IsStaticLibrary(XmlDocument project, string configurationNa
                         XmlElement element = (XmlElement)configurationNode;
 
                         // Look for configuration that matches our name
-                        if ((string.Compare(element.Name, "Configuration", StringComparison.OrdinalIgnoreCase) == 0) &&
-                            (string.Compare(element.GetAttribute("Name"), configurationName, StringComparison.OrdinalIgnoreCase) == 0))
+                        if ((string.Equals(element.Name, "Configuration", StringComparison.OrdinalIgnoreCase)) &&
+                            (string.Equals(element.GetAttribute("Name"), configurationName, StringComparison.OrdinalIgnoreCase)))
                         {
                             configurationElement = element;
 
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index 1dbbd8dcff8..54b620c6013 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -56,8 +56,6 @@
     <GenerateResourceMSBuildRuntime>CurrentRuntime</GenerateResourceMSBuildRuntime>
 
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
-    <!-- Disable warnings from XML documentation. https://github.com/Microsoft/msbuild/issues/2927 -->
-    <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
 
     <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) -excludeApiList:&quot;$(RepoRoot)ref\ExcludeAPIList.txt&quot;</GenAPIAdditionalParameters>
     <GenAPIAdditionalParameters>$(GenAPIAdditionalParameters) -excludeAttributesList:&quot;$(RepoRoot)ref\ExcludeAttributeList.txt&quot;</GenAPIAdditionalParameters>
diff --git a/src/Framework/EnvironmentVariableReadEventArgs.cs b/src/Framework/EnvironmentVariableReadEventArgs.cs
index f34cade967b..809a1b097fd 100644
--- a/src/Framework/EnvironmentVariableReadEventArgs.cs
+++ b/src/Framework/EnvironmentVariableReadEventArgs.cs
@@ -22,6 +22,10 @@ public EnvironmentVariableReadEventArgs()
         /// Initializes an instance of the EnvironmentVariableReadEventArgs class.
         /// </summary>
         /// <param name="environmentVariableName">The name of the environment variable that was read.</param>
+        /// <param name="message">The value of the environment variable that was read.</param>
+        /// <param name="helpKeyword">Help keyword.</param>
+        /// <param name="senderName">The name of the sender of the event.</param>
+        /// <param name="importance">The importance of the message.</param>
         public EnvironmentVariableReadEventArgs(
             string environmentVariableName,
             string message,
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index ee9e9cba954..5d73b6aa153 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -1,8 +1,4 @@
-﻿using System;
-using System.Collections.Generic;
-using System.Diagnostics.Tracing;
-using System.Runtime.InteropServices;
-using System.Threading;
+﻿using System.Diagnostics.Tracing;
 
 namespace Microsoft.Build.Eventing
 {
@@ -331,7 +327,7 @@ public void SaveStop(string fileLocation)
             WriteEvent(40, fileLocation);
         }
 
-        /// <param name="targetName"/>The name of the target being executed.</param>
+        /// <param name="targetName">The name of the target being executed.</param>
         [Event(43)]
         public void TargetStart(string targetName)
         {
diff --git a/src/Framework/PropertyInitialValueSetEventArgs.cs b/src/Framework/PropertyInitialValueSetEventArgs.cs
index 49754632277..d73247be932 100644
--- a/src/Framework/PropertyInitialValueSetEventArgs.cs
+++ b/src/Framework/PropertyInitialValueSetEventArgs.cs
@@ -22,6 +22,10 @@ public PropertyInitialValueSetEventArgs() { }
         /// <param name="propertyName">The name of the property.</param>
         /// <param name="propertyValue">The value of the property.</param>
         /// <param name="propertySource">The source of the property.</param>
+        /// <param name="message">The message of the property.</param>
+        /// <param name="helpKeyword">The help keyword.</param>
+        /// <param name="senderName">The sender name of the event.</param>
+        /// <param name="importance">The importance of the message.</param>
         public PropertyInitialValueSetEventArgs(
             string propertyName,
             string propertyValue,
diff --git a/src/Framework/PropertyReassignmentEventArgs.cs b/src/Framework/PropertyReassignmentEventArgs.cs
index 6de36dab633..7f9ccb491a5 100644
--- a/src/Framework/PropertyReassignmentEventArgs.cs
+++ b/src/Framework/PropertyReassignmentEventArgs.cs
@@ -25,6 +25,10 @@ public PropertyReassignmentEventArgs()
         /// <param name="previousValue">The previous value of the reassigned property.</param>
         /// <param name="newValue">The new value of the reassigned property.</param>
         /// <param name="location">The location of the reassignment.</param>
+        /// <param name="message">The message of the reassignment event.</param>
+        /// <param name="helpKeyword">The help keyword of the reassignment.</param>
+        /// <param name="senderName">The sender name of the reassignment event.</param>
+        /// <param name="importance">The importance of the message.</param>
         public PropertyReassignmentEventArgs(
             string propertyName,
             string previousValue,
diff --git a/src/Framework/Sdk/SdkResultFactory.cs b/src/Framework/Sdk/SdkResultFactory.cs
index 88f6a008124..70f672cd62e 100644
--- a/src/Framework/Sdk/SdkResultFactory.cs
+++ b/src/Framework/Sdk/SdkResultFactory.cs
@@ -49,6 +49,7 @@ public virtual SdkResult IndicateSuccess(string path,
         /// components to take more appropriate action (for example installing optional workloads or downloading NuGet SDKs).
         /// </remarks>
         /// <param name="paths">SDK paths which should be imported</param>
+        /// <param name="version">SDK version which should be imported</param>
         /// <param name="propertiesToAdd">Properties to set in the evaluation</param>
         /// <param name="itemsToAdd">Items to add to the evaluation</param>
         /// <param name="warnings">Optional warnings to display during resolution.</param>
diff --git a/src/Framework/UninitializedPropertyReadEventArgs.cs b/src/Framework/UninitializedPropertyReadEventArgs.cs
index 62448bdb008..fa11b3c8f89 100644
--- a/src/Framework/UninitializedPropertyReadEventArgs.cs
+++ b/src/Framework/UninitializedPropertyReadEventArgs.cs
@@ -22,6 +22,10 @@ public UninitializedPropertyReadEventArgs()
         /// Creates an instance of the UninitializedPropertyReadEventArgs class
         /// </summary>
         /// <param name="propertyName">The name of the uninitialized property that was read.</param>
+        /// <param name="message">The message of the uninitialized property that was read.</param>
+        /// <param name="helpKeyword">The helpKeyword of the uninitialized property that was read.</param>
+        /// <param name="senderName">The sender name of the event.</param>
+        /// <param name="importance">The message importance of the event.</param>
         public UninitializedPropertyReadEventArgs(
             string propertyName,
             string message,
diff --git a/src/Framework/XamlTypes/DataSource.cs b/src/Framework/XamlTypes/DataSource.cs
index 64c683badc6..515bbaa392c 100644
--- a/src/Framework/XamlTypes/DataSource.cs
+++ b/src/Framework/XamlTypes/DataSource.cs
@@ -27,8 +27,8 @@ public enum DefaultValueSourceLocation
     /// <summary>
     /// Represents the location and grouping for a <see cref="BaseProperty"/>.
     /// </summary>
-    /// <remarks> 
-    /// Those who manually 
+    /// <remarks>
+    /// Those who manually
     /// instantiate this class should remember to call <see cref="BeginInit"/> before setting the first
     /// property and <see cref="EndInit"/> after setting the last property of the object.
     /// </remarks>
@@ -52,12 +52,12 @@ public DataSource()
         #region Properties
 
         /// <summary>
-        /// The storage location for this data source. 
+        /// The storage location for this data source.
         /// </summary>
         /// <remarks>
-        /// This field is mandatory unless <see cref="PersistenceStyle"/> is set. In that case, the parent 
-        /// <see cref="DataSource"/> will be used with the specified style. Example values are <c>ProjectFile</c> and 
-        /// <c>UserFile</c>. <c>ProjectFile</c> causes the property value to be written to and read from the project 
+        /// This field is mandatory unless <see cref="PersistenceStyle"/> is set. In that case, the parent
+        /// <see cref="DataSource"/> will be used with the specified style. Example values are <c>ProjectFile</c> and
+        /// <c>UserFile</c>. <c>ProjectFile</c> causes the property value to be written to and read from the project
         /// manifest file or the property sheet (depending on which node in the solution explorer/property manager window
         /// is used to spawn the property pages UI). <c>UserFile</c> causes the property value to be written to and read
         /// from the .user file.
@@ -72,7 +72,7 @@ public string Persistence
         /// The storage style for this data source.
         /// </summary>
         /// <remarks>
-        /// For example, with <see cref="Persistence"/> of <c>ProjectFile</c>, this field can be <c>Element</c> (default) to 
+        /// For example, with <see cref="Persistence"/> of <c>ProjectFile</c>, this field can be <c>Element</c> (default) to
         /// save as a child XML Element, or <c>Attribute</c> to save properties as an XML attribute.
         /// </remarks>
         public string PersistenceStyle
@@ -146,7 +146,7 @@ public bool HasConfigurationCondition
         /// Among other things this governs how the data is treated during build.
         /// </summary>
         /// <example>
-        /// A value of <c>Item</c> for this property indicates that this property is actually 
+        /// A value of <c>Item</c> for this property indicates that this property is actually
         /// an item array - the list of all items with the item type specified by <see cref="ItemType"/>.
         /// </example>
         public string SourceType
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index e60e926fef0..a2cc9a8d075 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -1580,14 +1580,14 @@ internal string[] GetFiles(string path, string searchPattern)
                 List<string> fileNamesToReturn = new List<string>();
                 foreach (string file in _directoryFileNameList)
                 {
-                    if (String.Compare(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase))
                     {
-                        if (String.Compare(Path.GetExtension(file), ".sln", StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(Path.GetExtension(file), ".sln", StringComparison.OrdinalIgnoreCase))
                         {
                             fileNamesToReturn.Add(file);
                         }
                     }
-                    else if (String.Compare(searchPattern, "*.*proj", StringComparison.OrdinalIgnoreCase) == 0)
+                    else if (String.Equals(searchPattern, "*.*proj", StringComparison.OrdinalIgnoreCase))
                     {
                         if (Path.GetExtension(file).Contains("proj"))
                         {
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 1002783c334..a4e3f1f2045 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -298,7 +298,7 @@ out string duplicateSwitchErrorMessage
             {
                 foreach (string parameterlessSwitchName in switchInfo.switchNames)
                 {
-                    if (String.Compare(switchName, parameterlessSwitchName, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(switchName, parameterlessSwitchName, StringComparison.OrdinalIgnoreCase))
                     {
                         parameterlessSwitch = switchInfo.parameterlessSwitch;
                         duplicateSwitchErrorMessage = switchInfo.duplicateSwitchErrorMessage;
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 20d4e65b201..247e3208f41 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -622,7 +622,7 @@ private void HandlePacket(INodePacket packet)
         /// </summary>
         private void HandleTaskHostConfiguration(TaskHostConfiguration taskHostConfiguration)
         {
-            ErrorUtilities.VerifyThrow(_isTaskExecuting == false, "Why are we getting a TaskHostConfiguration packet while we're still executing a task?");
+            ErrorUtilities.VerifyThrow(!_isTaskExecuting, "Why are we getting a TaskHostConfiguration packet while we're still executing a task?");
             _currentConfiguration = taskHostConfiguration;
 
             // Kick off the task running thread.
@@ -636,7 +636,7 @@ private void HandleTaskHostConfiguration(TaskHostConfiguration taskHostConfigura
         /// </summary>
         private void CompleteTask()
         {
-            ErrorUtilities.VerifyThrow(_isTaskExecuting == false, "The task should be done executing before CompleteTask.");
+            ErrorUtilities.VerifyThrow(!_isTaskExecuting, "The task should be done executing before CompleteTask.");
             if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
             {
                 TaskHostTaskComplete taskCompletePacketToSend;
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index f96f9d5bc4d..94b5b802a99 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1859,7 +1859,7 @@ private static void GatherResponseFileSwitch(string unquotedCommandLineArg, Comm
 
                     foreach (string includedResponseFile in s_includedResponseFiles)
                     {
-                        if (String.Compare(responseFile, includedResponseFile, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(responseFile, includedResponseFile, StringComparison.OrdinalIgnoreCase))
                         {
                             commandLineSwitches.SetParameterError("RepeatedResponseFileError", unquotedCommandLineArg);
                             isRepeatedResponseFile = true;
@@ -2194,7 +2194,7 @@ bool recursing
                         if (!String.Equals(projectDirectory, s_exePath, StringComparison.OrdinalIgnoreCase))
                         {
                             // this combines any found, with higher precedence, with the switches from the original auto response file switches
-                            found = found | GatherAutoResponseFileSwitches(projectDirectory, switchesFromAutoResponseFile);
+                            found |= GatherAutoResponseFileSwitches(projectDirectory, switchesFromAutoResponseFile);
                         }
 
                         if (found)
@@ -2814,7 +2814,7 @@ DirectoryGetFiles getFiles
                     string solutionName = Path.GetFileNameWithoutExtension(potentialSolutionFiles[0]);
                     string projectName = Path.GetFileNameWithoutExtension(potentialProjectFiles[0]);
                     // Compare the names and error if they are not identical
-                    InitializationException.VerifyThrow(String.Compare(solutionName, projectName, StringComparison.OrdinalIgnoreCase) == 0, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
+                    InitializationException.VerifyThrow(String.Equals(solutionName, projectName, StringComparison.OrdinalIgnoreCase), projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
                 }
                 // If there is more than one solution file in the current directory we have no idea which one to use
                 else if (potentialSolutionFiles.Length > 1)
@@ -2834,17 +2834,17 @@ DirectoryGetFiles getFiles
                         string secondPotentialProjectExtension = Path.GetExtension(potentialProjectFiles[1]);
 
                         // If the two projects have the same extension we can't decide which one to pick
-                        if (String.Compare(firstPotentialProjectExtension, secondPotentialProjectExtension, StringComparison.OrdinalIgnoreCase) != 0)
+                        if (!String.Equals(firstPotentialProjectExtension, secondPotentialProjectExtension, StringComparison.OrdinalIgnoreCase))
                         {
                             // Check to see if the first project is the proj, if it is use it
-                            if (String.Compare(firstPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase) == 0)
+                            if (String.Equals(firstPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
                                 potentialProjectFiles = new string[] { potentialProjectFiles[0] };
                                 // We have made a decision
                                 isAmbiguousProject = false;
                             }
                             // If the first project is not the proj check to see if the second one is the proj, if so use it
-                            else if (String.Compare(secondPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase) == 0)
+                            else if (String.Equals(secondPotentialProjectExtension, ".proj", StringComparison.OrdinalIgnoreCase))
                             {
                                 potentialProjectFiles = new string[] { potentialProjectFiles[1] };
                                 // We have made a decision
@@ -2910,7 +2910,7 @@ private static Dictionary<string, object> ValidateExtensions(string[] projectsEx
 
                     // The parsed extension does not match the passed in extension, this means that there were
                     // some other chars before the last extension
-                    if (string.Compare(extension, extensionToIgnore, StringComparison.OrdinalIgnoreCase) != 0)
+                    if (!string.Equals(extension, extensionToIgnore, StringComparison.OrdinalIgnoreCase))
                     {
                         InitializationException.Throw("InvalidExtensionToIgnore", extensionToIgnore, null, false);
                     }
@@ -3540,7 +3540,7 @@ private static LoggerDescription ParseLoggingParameter(string parameter, string
             // DDB Bug msbuild.exe -Logger:FileLogger,Microsoft.Build.Engine fails due to moved engine file.
             // Only add strong naming if the assembly is a non-strong named 'Microsoft.Build.Engine' (i.e, no additional characteristics)
             // Concat full Strong Assembly to match v4.0
-            if (String.Compare(loggerAssemblySpec, "Microsoft.Build.Engine", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(loggerAssemblySpec, "Microsoft.Build.Engine", StringComparison.OrdinalIgnoreCase))
             {
                 loggerAssemblySpec = "Microsoft.Build.Engine,Version=4.0.0.0,Culture=neutral,PublicKeyToken=b03f5f7f11d50a3a";
             }
diff --git a/src/MSBuildTaskHost/TypeLoader.cs b/src/MSBuildTaskHost/TypeLoader.cs
index 7aa1fd6d81f..a3b95a2eb36 100644
--- a/src/MSBuildTaskHost/TypeLoader.cs
+++ b/src/MSBuildTaskHost/TypeLoader.cs
@@ -118,7 +118,7 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
             }
             else
             {
-                isPartialMatch = (String.Compare(typeName1, typeName2, StringComparison.OrdinalIgnoreCase) == 0);
+                isPartialMatch = (String.Equals(typeName1, typeName2, StringComparison.OrdinalIgnoreCase));
             }
 
             return isPartialMatch;
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index e2cf13588fb..58df8312ba2 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -279,7 +279,7 @@ private bool MatchingPlatformExists(string platform, string platformValue)
                 string[] platforms = platformValue.Split(MSBuildConstants.SemicolonChar);
                 foreach (string p in platforms)
                 {
-                    if (String.Compare(p, platform, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(p, platform, StringComparison.OrdinalIgnoreCase))
                     {
                         match = true;
                         break;
@@ -369,7 +369,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
             // Loop over versions from registry.
             foreach (string version in versions)
             {
-                if ((version.Length > 0) && (String.Compare(version.Substring(0, 1), "v", StringComparison.OrdinalIgnoreCase) == 0))
+                if ((version.Length > 0) && (String.Equals(version.Substring(0, 1), "v", StringComparison.OrdinalIgnoreCase)))
                 {
                     Version candidateVersion = VersionUtilities.ConvertToVersion(version);
 
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 758e90ee4e6..1986216d384 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -99,7 +99,7 @@ internal AssemblyNameExtension(string assemblyName) : this()
 
         /// <summary>
         /// Construct from a string, but immediately construct a real AssemblyName.
-        /// This will cause an exception to be thrown up front if the assembly name 
+        /// This will cause an exception to be thrown up front if the assembly name
         /// isn't well formed.
         /// </summary>
         /// <param name="assemblyName">
@@ -320,7 +320,7 @@ internal Version Version
         }
 
         /// <summary>
-        /// Is the assembly a complex name or a simple name. A simple name is where only the name is set 
+        /// Is the assembly a complex name or a simple name. A simple name is where only the name is set
         /// a complex name is where the version, culture or publickeytoken is also set
         /// </summary>
         internal bool IsSimpleName
@@ -545,7 +545,7 @@ internal int CompareBaseNameTo(AssemblyNameExtension that)
         }
 
         /// <summary>
-        /// An implementation of compare that compares two base 
+        /// An implementation of compare that compares two base
         /// names as quickly as possible.
         /// </summary>
         /// <param name="that"></param>
@@ -847,7 +847,7 @@ private static AssemblyName GetAssemblyNameFromDisplayName(string displayName)
         }
 
         /// <summary>
-        /// Return a string that has AssemblyName special characters escaped. 
+        /// Return a string that has AssemblyName special characters escaped.
         /// Those characters are Equals(=), Comma(,), Quote("), Apostrophe('), Backslash(\).
         /// </summary>
         /// <remarks>
@@ -896,9 +896,9 @@ internal bool PartialNameCompare(AssemblyNameExtension that, bool considerRetarg
         /// <summary>
         /// Do a partial comparison between two assembly name extensions.
         /// Compare the fields of A and B on the following conditions:
-        /// 1) A.Field has a non null value 
+        /// 1) A.Field has a non null value
         /// 2) The field has been selected in the comparison flags or the default comparison flags are passed in.
-        /// 
+        ///
         /// If A.Field is null then we will not compare A.Field and B.Field even when the comparison flag is set for that field unless skipNullFields is false.
         /// </summary>
         internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags)
@@ -909,9 +909,9 @@ internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFl
         /// <summary>
         /// Do a partial comparison between two assembly name extensions.
         /// Compare the fields of A and B on the following conditions:
-        /// 1) A.Field has a non null value 
+        /// 1) A.Field has a non null value
         /// 2) The field has been selected in the comparison flags or the default comparison flags are passed in.
-        /// 
+        ///
         /// If A.Field is null then we will not compare A.Field and B.Field even when the comparison flag is set for that field unless skipNullFields is false.
         /// </summary>
         internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags, bool considerRetargetableFlag)
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index d40444aecfc..a5c7fb21cdd 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -23,7 +23,7 @@ internal class BuildEnvironmentHelper
 
         /// <summary>
         /// Name of the Visual Studio (and Blend) process.
-        // VS ASP intellisense server fails without Microsoft.VisualStudio.Web.Host. Remove when issue fixed: https://devdiv.visualstudio.com/DevDiv/_workitems/edit/574986
+        /// VS ASP intellisense server fails without Microsoft.VisualStudio.Web.Host. Remove when issue fixed: https://devdiv.visualstudio.com/DevDiv/_workitems/edit/574986
         /// </summary>
         private static readonly string[] s_visualStudioProcess = {"DEVENV", "BLEND", "Microsoft.VisualStudio.Web.Host"};
 
@@ -471,7 +471,7 @@ internal enum BuildEnvironmentMode
         VisualStudio,
 
         /// <summary>
-        /// Running in a standalone toolset mode. All toolsets and extensions paths are relative to the app 
+        /// Running in a standalone toolset mode. All toolsets and extensions paths are relative to the app
         /// running and not dependent on Visual Studio. (e.g. dotnet CLI, open source clone of our repo)
         /// </summary>
         Standalone,
diff --git a/src/Shared/CanonicalError.cs b/src/Shared/CanonicalError.cs
index b4346085d21..f0c247113f6 100644
--- a/src/Shared/CanonicalError.cs
+++ b/src/Shared/CanonicalError.cs
@@ -316,11 +316,11 @@ internal static Parts Parse(string message)
                 }
 
                 category = match.Groups["CATEGORY"].Value.Trim();
-                if (0 == String.Compare(category, "error", StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(category, "error", StringComparison.OrdinalIgnoreCase))
                 {
                     parsedMessage.category = Parts.Category.Error;
                 }
-                else if (0 == String.Compare(category, "warning", StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(category, "warning", StringComparison.OrdinalIgnoreCase))
                 {
                     parsedMessage.category = Parts.Category.Warning;
                 }
@@ -354,11 +354,11 @@ internal static Parts Parse(string message)
             parsedMessage.subcategory = match.Groups["SUBCATEGORY"].Value.Trim();
 
             // Next, see if category is something that is recognized.
-            if (0 == String.Compare(category, "error", StringComparison.OrdinalIgnoreCase))
+            if (String.Equals(category, "error", StringComparison.OrdinalIgnoreCase))
             {
                 parsedMessage.category = Parts.Category.Error;
             }
-            else if (0 == String.Compare(category, "warning", StringComparison.OrdinalIgnoreCase))
+            else if (String.Equals(category, "warning", StringComparison.OrdinalIgnoreCase))
             {
                 parsedMessage.category = Parts.Category.Warning;
             }
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index 1a5c9dde2b4..05124895e55 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -200,6 +200,7 @@ int threadId
         /// <param name="columnNumber">column number (0 if n/a)</param>
         /// <param name="endColumnNumber">end column number (0 if n/a)</param>
         /// <param name="threadId">thread id</param>
+        /// <param name="logOutputProperties">log output properties</param>
         /// <returns>The formatted message string.</returns>
         internal static string FormatEventMessage
         (
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 3308d9db3cd..f3fb4d1462a 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -866,7 +866,7 @@ private void GetFilesRecursive(
                         continue;
                     }
                 }
-                files = files ?? new List<string>();
+                files ??= new List<string>();
                 files.Add(file);
             }
             // Add all matched files at once to reduce thread contention
@@ -2284,7 +2284,7 @@ private string[] GetFilesImplementation(
                     var excludeBaseDirectory = excludeState.BaseDirectory;
                     var includeBaseDirectory = state.BaseDirectory;
 
-                    if (string.Compare(excludeBaseDirectory, includeBaseDirectory, StringComparison.OrdinalIgnoreCase) != 0)
+                    if (!string.Equals(excludeBaseDirectory, includeBaseDirectory, StringComparison.OrdinalIgnoreCase))
                     {
                         //  What to do if the BaseDirectory for the exclude search doesn't match the one for inclusion?
                         //  - If paths don't match (one isn't a prefix of the other), then ignore the exclude search.  Examples:
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 24f9bf523b8..8dea0fdaadd 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -301,7 +301,7 @@ internal static bool ContainsRelativePathSegments(string path)
                     }
                     else
                     {
-                        i = i + 2;
+                        i += 2;
                         continue;
                     }
                 }
@@ -909,7 +909,7 @@ internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSys
 
             try
             {
-                fileSystem = fileSystem ?? DefaultFileSystem;
+                fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
                     ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.DirectoryExists)
@@ -933,7 +933,7 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =
 
             try
             {
-                fileSystem = fileSystem ?? DefaultFileSystem;
+                fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
                     ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.FileExists)
@@ -957,7 +957,7 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
 
             try
             {
-                fileSystem = fileSystem ?? DefaultFileSystem;
+                fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
                     ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.DirectoryEntryExists)
@@ -1321,7 +1321,7 @@ internal static StreamReader OpenRead(string path, Encoding encoding = null, boo
         /// </summary>
         internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName, IFileSystem fileSystem = null)
         {
-            fileSystem = fileSystem ?? DefaultFileSystem;
+            fileSystem ??= DefaultFileSystem;
 
             // Canonicalize our starting location
             string lookInDirectory = GetFullPath(startingDirectory);
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index 8c1855e413d..9ab2e9faf9e 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -20,10 +20,10 @@ internal static class FileUtilitiesRegex
         private static readonly char _forwardSlash = '/';
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern: "<drive letter>:"
+        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:", "D:")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern</param>
+        /// <returns>true if follows the drive pattern, false otherwise</returns>
         internal static bool IsDrivePattern(string pattern)
         {
             // Format must be two characters long: "<drive letter>:"
@@ -32,10 +32,10 @@ internal static bool IsDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern: "<drive letter>:/" or "<drive letter>:\"
+        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:/" or "C:\")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern with slash</param>
+        /// <returns>true if follows the drive pattern with slash, false otherwise</returns>
         internal static bool IsDrivePatternWithSlash(string pattern)
         {
             return pattern.Length == 3 &&
@@ -43,10 +43,10 @@ internal static bool IsDrivePatternWithSlash(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern: "<drive letter>:".
+        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern</param>
+        /// <returns>true if starts with drive pattern, false otherwise</returns>
         internal static bool StartsWithDrivePattern(string pattern)
         {
             // Format dictates a length of at least 2,
@@ -58,10 +58,10 @@ internal static bool StartsWithDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern: "<drive letter>:/" or "<drive letter>:\".
+        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:/" or "C:\")
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for drive pattern</param>
+        /// <returns>true if starts with drive pattern with slash, false otherwise</returns>
         internal static bool StartsWithDrivePatternWithSlash(string pattern)
         {
             // Format dictates a length of at least 3,
@@ -74,10 +74,10 @@ internal static bool StartsWithDrivePatternWithSlash(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified file-spec comprises exactly "\\<server>\<share>" (with no trailing characters).
+        /// Indicates whether the specified file-spec comprises exactly "\\server\share" (with no trailing characters).
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern</param>
+        /// <returns>true if comprises Unc pattern</returns>
         internal static bool IsUncPattern(string pattern)
         {
             //Return value == pattern.length means:
@@ -88,10 +88,10 @@ internal static bool IsUncPattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified file-spec begins with "\\<server>\<share>".
+        /// Indicates whether the specified file-spec begins with "\\server\share".
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern</param>
+        /// <returns>true if starts with Unc pattern</returns>
         internal static bool StartsWithUncPattern(string pattern)
         {
             //Any non -1 value returned means there was a match, therefore is begins with the pattern.
@@ -99,10 +99,10 @@ internal static bool StartsWithUncPattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the file-spec begins with a UNC pattern and how long the match is. -1 indicates no match.
+        /// Indicates whether the file-spec begins with a UNC pattern and how long the match is.
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern</param>
+        /// <returns>length of the match, -1 if no match</returns>
         internal static int StartsWithUncPatternMatchLength(string pattern)
         {
             if (!MeetsUncPatternMinimumRequirements(pattern))
@@ -150,10 +150,9 @@ internal static int StartsWithUncPatternMatchLength(string pattern)
 
         /// <summary>
         /// Indicates whether or not the file-spec meets the minimum requirements of a UNC pattern.
-        /// UNC pattern requires a minimum length of 5 and first two characters must be a slash.
         /// </summary>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
+        /// <param name="pattern">input to check for Unc pattern minimum requirements</param>
+        /// <returns>true if the UNC pattern is a minimum length of 5 and the first two characters are be a slash, false otherwise.</returns>
 #if !NET35
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
 #endif
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 294a6b3ec81..7637ab3340c 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -29,7 +29,7 @@ namespace Microsoft.Build.Shared
     internal enum DotNetFrameworkArchitecture
     {
         /// <summary>
-        /// Indicates the .NET Framework that is currently being run under.  
+        /// Indicates the .NET Framework that is currently being run under.
         /// </summary>
         Current = 0,
 
@@ -217,7 +217,7 @@ internal static class FrameworkLocationHelper
 
             // v4.7.1
             CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion471, visualStudioVersion150),
-            
+
             // v4.7.2
             CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion472, visualStudioVersion150),
 
@@ -428,13 +428,13 @@ internal static string PathToDotNetFrameworkSdkV20
 
         /// <summary>
         /// Because there is no longer a strong 1:1 mapping between FX versions and SDK
-        /// versions, if we're unable to locate the desired SDK version, we will try to 
+        /// versions, if we're unable to locate the desired SDK version, we will try to
         /// use whichever SDK version is installed by looking at the key pointing to the
         /// "latest" version.
         ///
-        /// This isn't ideal, but it will allow our tasks to function on any of several 
+        /// This isn't ideal, but it will allow our tasks to function on any of several
         /// related SDKs even if they don't have exactly the same versions.
-        /// 
+        ///
         /// NOTE:  This returns the path to the root of the fallback SDK
         /// </summary>
         private static string FallbackDotNetFrameworkSdkInstallPath
@@ -476,15 +476,15 @@ private static string FallbackDotNetFrameworkSdkInstallPath
 
         /// <summary>
         /// Because there is no longer a strong 1:1 mapping between FX versions and SDK
-        /// versions, if we're unable to locate the desired SDK version, we will try to 
+        /// versions, if we're unable to locate the desired SDK version, we will try to
         /// use whichever SDK version is installed by looking at the key pointing to the
         /// "latest" version.
         ///
-        /// This isn't ideal, but it will allow our tasks to function on any of several 
+        /// This isn't ideal, but it will allow our tasks to function on any of several
         /// related SDKs even if they don't have exactly the same versions.
-        /// 
+        ///
         /// NOTE:  This explicitly returns the path to the 3.5 tools (bin) under the fallback
-        /// SDK, to match the data we're pulling from the registry now.  
+        /// SDK, to match the data we're pulling from the registry now.
         /// </summary>
         private static string PathToV35ToolsInFallbackDotNetFrameworkSdk
         {
@@ -507,8 +507,7 @@ private static string PathToV35ToolsInFallbackDotNetFrameworkSdk
                             // Path.Combine leaves no trailing slash, so if we had one before, be sure to add it back in
                             if (endsWithASlash)
                             {
-                                s_pathToV35ToolsInFallbackDotNetFrameworkSdk = s_pathToV35ToolsInFallbackDotNetFrameworkSdk
-                                                                             + Path.DirectorySeparatorChar;
+                                s_pathToV35ToolsInFallbackDotNetFrameworkSdk += Path.DirectorySeparatorChar;
                             }
                         }
                         else
@@ -524,15 +523,15 @@ private static string PathToV35ToolsInFallbackDotNetFrameworkSdk
 
         /// <summary>
         /// Because there is no longer a strong 1:1 mapping between FX versions and SDK
-        /// versions, if we're unable to locate the desired SDK version, we will try to 
+        /// versions, if we're unable to locate the desired SDK version, we will try to
         /// use whichever SDK version is installed by looking at the key pointing to the
         /// "latest" version.
         ///
-        /// This isn't ideal, but it will allow our tasks to function on any of several 
+        /// This isn't ideal, but it will allow our tasks to function on any of several
         /// related SDKs even if they don't have exactly the same versions.
-        /// 
-        /// NOTE:  This explicitly returns the path to the 4.X tools (bin\NetFX 4.0 Tools) 
-        /// under the fallback SDK, to match the data we're pulling from the registry now.  
+        ///
+        /// NOTE:  This explicitly returns the path to the 4.X tools (bin\NetFX 4.0 Tools)
+        /// under the fallback SDK, to match the data we're pulling from the registry now.
         /// </summary>
         private static string PathToV4ToolsInFallbackDotNetFrameworkSdk
         {
@@ -553,7 +552,7 @@ private static string PathToV4ToolsInFallbackDotNetFrameworkSdk
                             // Path.Combine leaves no trailing slash, so if we had one before, be sure to add it back in
                             if (endsWithASlash)
                             {
-                                s_pathToV4ToolsInFallbackDotNetFrameworkSdk = s_pathToV4ToolsInFallbackDotNetFrameworkSdk + "\\";
+                                s_pathToV4ToolsInFallbackDotNetFrameworkSdk += "\\";
                             }
                         }
                         else
@@ -686,7 +685,7 @@ private static bool CheckForFrameworkInstallation(string registryEntryToCheckIns
                 if (NativeMethodsShared.IsWindows)
                 {
                     // If the registry entry is 1 then the framework is installed. Go ahead and find the directory. If it is not 1 then the framework is not installed, return null.
-                    return String.Compare("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase) == 0;
+                    return String.Equals("1", FindRegistryValueUnderKey(registryEntryToCheckInstall, registryValueToCheckInstall), StringComparison.OrdinalIgnoreCase);
                 }
                 // False for non-windows since there is nothing in the registry
                 else
@@ -766,7 +765,7 @@ DotNetFrameworkArchitecture architecture
             else if (indexOfFramework64 == -1 && architecture == DotNetFrameworkArchitecture.Bitness64)
             {
                 // need to add 64 -- since this is a heuristic, we assume that we just need to append.  
-                baseLocation = baseLocation + "64";
+                baseLocation += "64";
             }
             // we don't need to do anything if it's DotNetFrameworkArchitecture.Current.  
 
@@ -869,7 +868,7 @@ internal static string GenerateProgramFiles64()
         }
 
         /// <summary>
-        /// Generate the path to the program files reference assembly location by taking in the program files special folder and then 
+        /// Generate the path to the program files reference assembly location by taking in the program files special folder and then
         /// using that path to generate the path to the reference assemblies location.
         /// </summary>
         internal static string GenerateProgramFilesReferenceAssemblyRoot()
@@ -892,15 +891,15 @@ internal static string GenerateProgramFilesReferenceAssemblyRoot()
         }
 
         /// <summary>
-        /// Given a ToolsVersion, find the path to the build tools folder for that ToolsVersion. 
+        /// Given a ToolsVersion, find the path to the build tools folder for that ToolsVersion.
         /// </summary>
         /// <param name="toolsVersion">The ToolsVersion to look up</param>
         /// <param name="architecture">Target build tools architecture.</param>
-        /// <returns>The path to the build tools folder for that ToolsVersion, if it exists, or 
+        /// <returns>The path to the build tools folder for that ToolsVersion, if it exists, or
         /// null otherwise</returns>
         internal static string GeneratePathToBuildToolsForToolsVersion(string toolsVersion, DotNetFrameworkArchitecture architecture)
         {
-            if (string.Compare(toolsVersion, MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal) == 0)
+            if (string.Equals(toolsVersion, MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
             {
                 return GetPathToBuildToolsFromEnvironment(architecture);
             }
@@ -991,7 +990,7 @@ internal static string RemoveDirectories(string path, int numberOfLevelsToRemove
 
                 if (fixedPath != null && endedWithASlash)
                 {
-                    fixedPath = fixedPath + Path.DirectorySeparatorChar;
+                    fixedPath += Path.DirectorySeparatorChar;
                 }
             }
 
@@ -999,7 +998,7 @@ internal static string RemoveDirectories(string path, int numberOfLevelsToRemove
         }
 
         /// <summary>
-        /// Look up the path to the build tools directory for the requested ToolsVersion in the .exe.config file of this executable 
+        /// Look up the path to the build tools directory for the requested ToolsVersion in the .exe.config file of this executable
         /// </summary>
         private static string GetPathToBuildToolsFromEnvironment(DotNetFrameworkArchitecture architecture)
         {
@@ -1016,7 +1015,7 @@ private static string GetPathToBuildToolsFromEnvironment(DotNetFrameworkArchitec
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
-        /// Look up the path to the build tools directory in the registry for the requested ToolsVersion and requested architecture  
+        /// Look up the path to the build tools directory in the registry for the requested ToolsVersion and requested architecture
         /// </summary>
         private static string GetPathToBuildToolsFromRegistry(string toolsVersion, DotNetFrameworkArchitecture architecture)
         {
diff --git a/src/Shared/LanguageParser/StreamMappedString.cs b/src/Shared/LanguageParser/StreamMappedString.cs
index 71876fbd0ed..9b31944fa7b 100644
--- a/src/Shared/LanguageParser/StreamMappedString.cs
+++ b/src/Shared/LanguageParser/StreamMappedString.cs
@@ -71,7 +71,8 @@ sealed internal class StreamMappedString
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="binaryStream"></param>
+        /// <param name="binaryStream">The raw binary stream that's being read.</param>
+        /// <param name="forceANSI">When false, try to guess the encoding of binaryStream. When true, force the encoding to ANSI.</param>
         public StreamMappedString(Stream binaryStream, bool forceANSI)
             : this(binaryStream, forceANSI, /* pageSize */ DefaultPageSize)
         {
@@ -80,7 +81,9 @@ public StreamMappedString(Stream binaryStream, bool forceANSI)
         /// <summary>
         /// Construct.
         /// </summary>
-        /// <param name="binaryStream"></param>
+        /// <param name="binaryStream">The raw binary stream that's being read.</param>
+        /// <param name="forceANSI">When false, try to guess the encoding of binaryStream. When true, force the encoding to ANSI.</param>
+        /// <param name="pageSize">Size of pages to use for reading from source file.</param>
         internal StreamMappedString(Stream binaryStream, bool forceANSI, int pageSize)
         {
             _binaryStream = binaryStream;
@@ -92,7 +95,6 @@ internal StreamMappedString(Stream binaryStream, bool forceANSI, int pageSize)
         /// <summary>
         /// Restart the stream reader at the beginning.
         /// </summary>
-        /// <param name="binaryStream"></param>
         private void RestartReader()
         {
             _currentPageNumber = -1;
@@ -340,7 +342,6 @@ private bool IsZeroLengthStream()
         /// COnvert from absolute offset to relative offset within a particular page.
         /// </summary>
         /// <param name="offset"></param>
-        /// <param name="pageNumber"></param>
         /// <returns></returns>
         private int AbsoluteOffsetToPageOffset(int offset)
         {
@@ -360,7 +361,7 @@ private int PageFromAbsoluteOffset(int offset)
         /// <summary>
         /// Returns true of the given position is passed the end of the file.
         /// </summary>
-        /// <param name="position"></param>
+        /// <param name="offset"></param>
         /// <returns></returns>
         public bool IsPastEnd(int offset)
         {
diff --git a/src/Shared/LanguageParser/token.cs b/src/Shared/LanguageParser/token.cs
index 5deedb0a4a6..50156ea1906 100644
--- a/src/Shared/LanguageParser/token.cs
+++ b/src/Shared/LanguageParser/token.cs
@@ -59,7 +59,7 @@ internal int Line
          */
         internal bool EqualsIgnoreCase(string compareTo)
         {
-            return (String.Compare(_innerText, compareTo, StringComparison.OrdinalIgnoreCase) == 0);
+            return (String.Equals(_innerText, compareTo, StringComparison.OrdinalIgnoreCase));
         }
     }
 
diff --git a/src/Shared/LanguageParser/tokenCharReader.cs b/src/Shared/LanguageParser/tokenCharReader.cs
index fa744d0aa4e..aa8aa07d3d4 100644
--- a/src/Shared/LanguageParser/tokenCharReader.cs
+++ b/src/Shared/LanguageParser/tokenCharReader.cs
@@ -161,12 +161,12 @@ private bool Sink(string match, bool ignoreCase)
 
             if
             (
-                String.Compare
+                String.Equals
                 (
                     match,
                     compare,
                     (ignoreCase /* ignore case */) ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal
-                ) == 0
+                )
             )
             {
                 Skip(match.Length);
diff --git a/src/Shared/MSBuildNameIgnoreCaseComparer.cs b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
index 2ec0b14c481..e5f0f0ad199 100644
--- a/src/Shared/MSBuildNameIgnoreCaseComparer.cs
+++ b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
@@ -93,8 +93,8 @@ public bool Equals(string compareToString, string constrainedString, int start,
                             {
                                 int chx = px[i];
                                 int chy = py[i + start];
-                                chx = chx & 0x00DF; // Extract the uppercase character
-                                chy = chy & 0x00DF; // Extract the uppercase character
+                                chx &= 0x00DF; // Extract the uppercase character
+                                chy &= 0x00DF; // Extract the uppercase character
 
                                 if (chx != chy)
                                 {
@@ -149,7 +149,7 @@ public int GetHashCode(string obj, int start, int length)
                             // the string, and not the null terminator etc.
                             if (length == 1)
                             {
-                                val = val & 0xFFFF;
+                                val &= 0xFFFF;
                             }
 
                             hash1 = ((hash1 << 5) + hash1 + (hash1 >> 27)) ^ val;
@@ -162,7 +162,7 @@ public int GetHashCode(string obj, int start, int length)
                             val = pint[1] & 0x00DF00DF;
                             if (length == 3)
                             {
-                                val = val & 0xFFFF;
+                                val &= 0xFFFF;
                             }
 
                             hash2 = ((hash2 << 5) + hash2 + (hash2 >> 27)) ^ val;
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 43d914ac1f0..1eb2840cbe9 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -1027,7 +1027,7 @@ private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
                 if (!handle.IsInvalid)
                 {
                     FILETIME ftCreationTime, ftLastAccessTime, ftLastWriteTime;
-                    if (!GetFileTime(handle, out ftCreationTime, out ftLastAccessTime, out ftLastWriteTime) != true)
+                    if (GetFileTime(handle, out ftCreationTime, out ftLastAccessTime, out ftLastWriteTime))
                     {
                         long fileTime = ((long)(uint)ftLastWriteTime.dwHighDateTime) << 32 |
                                         (long)(uint)ftLastWriteTime.dwLowDateTime;
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 19973530259..5d9d3110393 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -68,7 +68,7 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
 
         /// <summary>
         /// Set when a packet is available in the packet queue
-        /// </summary>      
+        /// </summary>
         private AutoResetEvent _packetAvailable;
 
         /// <summary>
@@ -87,7 +87,7 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         private INodePacketFactory _packetFactory;
 
         /// <summary>
-        /// The asynchronous packet queue.  
+        /// The asynchronous packet queue.
         /// </summary>
         /// <remarks>
         /// Operations on this queue must be synchronized since it is accessible by multiple threads.
@@ -143,7 +143,7 @@ public void Listen(INodePacketFactory factory)
         }
 
         /// <summary>
-        /// Causes this node to connect to the matched endpoint.  
+        /// Causes this node to connect to the matched endpoint.
         /// </summary>
         /// <param name="factory">The factory used to create packets.</param>
         public void Connect(INodePacketFactory factory)
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index 9c6f2361554..c311159d878 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -84,7 +84,6 @@ params object[] args
         /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
         /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
         /// </summary>
-        /// <param name="condition">The condition to check.</param>
         /// <param name="errorSubCategoryResourceName">The resource string for the error sub-category (can be null).</param>
         /// <param name="projectFile">The invalid project file.</param>
         /// <param name="resourceName">The resource string for the error message.</param>
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index a25cdf34a7d..60e91c6d8d4 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -69,7 +69,7 @@ internal static string ExtractMessageCode(bool msbuildCodeOnly, string message,
 
                 code = message.Substring(i, 7);
 
-                i = i + 8;
+                i += 8;
             }
             else
 #endif
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 9f031270a1f..2a362fcc45e 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -86,6 +86,7 @@ internal class TaskHostConfiguration : INodePacket
 
         private Dictionary<string, string> _globalParameters;
 
+#if FEATURE_APPDOMAIN
         /// <summary>
         /// Constructor
         /// </summary>
@@ -102,6 +103,25 @@ internal class TaskHostConfiguration : INodePacket
         /// <param name="taskName">Name of the task.</param>
         /// <param name="taskLocation">Location of the assembly the task is to be loaded from.</param>
         /// <param name="taskParameters">Parameters to apply to the task.</param>
+        /// <param name="globalParameters">global properties for the current project.</param>
+#else
+        /// <summary>
+        /// Constructor
+        /// </summary>
+        /// <param name="nodeId">The ID of the node being configured.</param>
+        /// <param name="startupDirectory">The startup directory for the task being executed.</param>
+        /// <param name="buildProcessEnvironment">The set of environment variables to apply to the task execution process.</param>
+        /// <param name="culture">The culture of the thread that will execute the task.</param>
+        /// <param name="uiCulture">The UI culture of the thread that will execute the task.</param>
+        /// <param name="lineNumberOfTask">The line number of the location from which this task was invoked.</param>
+        /// <param name="columnNumberOfTask">The column number of the location from which this task was invoked.</param>
+        /// <param name="projectFileOfTask">The project file from which this task was invoked.</param>
+        /// <param name="continueOnError">Flag to continue with the build after a the task failed</param>
+        /// <param name="taskName">Name of the task.</param>
+        /// <param name="taskLocation">Location of the assembly the task is to be loaded from.</param>
+        /// <param name="taskParameters">Parameters to apply to the task.</param>
+        /// <param name="globalParameters">global properties for the current project.</param>
+#endif
         public TaskHostConfiguration
             (
                 int nodeId,
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index c383cf1bc1b..d38886bdc25 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -95,7 +95,7 @@ public TaskParameter(object wrappedParameter)
 
             Type wrappedParameterType = wrappedParameter.GetType();
 
-            if ((wrappedParameter as Exception) != null)
+            if (wrappedParameter is Exception)
             {
                 _parameterType = TaskParameterType.Invalid;
                 _wrappedParameter = wrappedParameter;
@@ -620,7 +620,7 @@ public void SetMetadata(string metadataName, string metadataValue)
                 // That's why this is IsItemSpecModifier and not IsDerivableItemSpecModifier.
                 ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(metadataName), "Shared.CannotChangeItemSpecModifiers", metadataName);
 
-                _customEscapedMetadata = _customEscapedMetadata ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                _customEscapedMetadata ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
                 _customEscapedMetadata[metadataName] = metadataValue ?? String.Empty;
             }
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index 8764ad77c12..ae76d151a37 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -15,8 +15,8 @@ namespace Microsoft.Build.Shared
     internal static partial class FileUtilities
     {
         /// <summary>
-        /// Generates a unique directory name in the temporary folder.  
-        /// Caller must delete when finished. 
+        /// Generates a unique directory name in the temporary folder.
+        /// Caller must delete when finished.
         /// </summary>
         /// <param name="createDirectory"></param>
         internal static string GetTemporaryDirectory(bool createDirectory = true)
@@ -86,7 +86,7 @@ internal static string GetTemporaryFile(string directory, string extension, bool
 
             try
             {
-                directory = directory ?? Path.GetTempPath();
+                directory ??= Path.GetTempPath();
 
                 Directory.CreateDirectory(directory);
 
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 4fb6b9f9f40..050b3c87d75 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -105,7 +105,7 @@ public string toolsVersion
         }
 
         /// <summary>
-        /// Property element collection 
+        /// Property element collection
         /// </summary>
         [ConfigurationProperty("", IsDefaultCollection = true)]
         public PropertyElementCollection PropertyElements
@@ -321,7 +321,7 @@ internal sealed class PropertyElementCollection : ConfigurationElementCollection
 
             /// <summary>
             /// Collection type
-            /// This has to be public as cannot change access modifier when overriding  
+            /// This has to be public as cannot change access modifier when overriding
             /// </summary>
             public override ConfigurationElementCollectionType CollectionType
             {
@@ -610,7 +610,7 @@ private void UpdateToolsVersionMap(ConfigurationElement element)
     /// <summary>
     /// This class is used to programmatically read msbuildToolsets section
     /// in from the configuration file.  An example of application config file:
-    /// 
+    ///
     /// &lt;configuration&gt;
     ///     &lt;msbuildToolsets default="2.0"&gt;
     ///         &lt;toolset toolsVersion="2.0"&gt;
@@ -622,7 +622,7 @@ private void UpdateToolsVersionMap(ConfigurationElement element)
     ///         &lt;/toolset&gt;
     ///     &lt;/msbuildToolsets&gt;
     /// &lt;/configuration&gt;
-    /// 
+    ///
     /// </summary>
     /// <remarks>
     /// Internal for unit testing only
@@ -630,7 +630,7 @@ private void UpdateToolsVersionMap(ConfigurationElement element)
     internal sealed class ToolsetConfigurationSection : ConfigurationSection
     {
         /// <summary>
-        /// toolsVersion element collection 
+        /// toolsVersion element collection
         /// </summary>
         [ConfigurationProperty("", IsDefaultCollection = true)]
         public ToolsetElementCollection Toolsets
@@ -688,7 +688,7 @@ public string MSBuildOverrideTasksPath
         }
 
         /// <summary>
-        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the toolsversion that should be used by 
+        /// DefaultOverrideToolsVersion attribute on msbuildToolsets element, specifying the toolsversion that should be used by
         /// default to build projects with this version of MSBuild.
         /// </summary>
         [ConfigurationProperty("DefaultOverrideToolsVersion")]
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 3fa68f16c03..cb273f710ed 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -201,7 +201,7 @@ public bool LogTaskInputs
         public readonly bool IgnoreEmptyImports = Environment.GetEnvironmentVariable("MSBUILDIGNOREEMPTYIMPORTS") == "1";
 
         /// <summary>
-        /// Whether to respect the TreatAsLocalProperty parameter on the Project tag. 
+        /// Whether to respect the TreatAsLocalProperty parameter on the Project tag.
         /// </summary>
         public readonly bool IgnoreTreatAsLocalProperty = Environment.GetEnvironmentVariable("MSBUILDIGNORETREATASLOCALPROPERTY") != null;
 
diff --git a/src/Shared/TranslatorHelpers.cs b/src/Shared/TranslatorHelpers.cs
index 20a1a75f2fa..f1cd7166213 100644
--- a/src/Shared/TranslatorHelpers.cs
+++ b/src/Shared/TranslatorHelpers.cs
@@ -21,7 +21,7 @@ internal static class TranslatorHelpers
         /// <typeparam name="T">The reference type.</typeparam>
         /// <param name="translator">The translator</param>
         /// <param name="instance">The value to be translated.</param>
-        /// <param name="factory">The factory method used to instantiate values of type T.</param>
+        /// <param name="valueFactory">The factory method used to instantiate values of type T.</param>
         public static void Translate<T>(
             this ITranslator translator,
             ref T instance,
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 54b63fa5f1d..3dfd5b8447b 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -132,7 +132,7 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
             }
             else
             {
-                isPartialMatch = (String.Compare(typeName1, typeName2, StringComparison.OrdinalIgnoreCase) == 0);
+                isPartialMatch = (String.Equals(typeName1, typeName2, StringComparison.OrdinalIgnoreCase));
             }
 
             return isPartialMatch;
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index 28dc9c73667..293b4dbcec3 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -1964,7 +1964,7 @@ private int GetMatchingFiles(string[] candidates, string path, string pattern, I
                             if
                             (
                                 pattern == null ||
-                                String.Compare(pattern, "*.*", StringComparison.OrdinalIgnoreCase) == 0
+                                String.Equals(pattern, "*.*", StringComparison.OrdinalIgnoreCase)
                             )
                             {
                                 ++hits;
@@ -1974,7 +1974,7 @@ private int GetMatchingFiles(string[] candidates, string path, string pattern, I
                             {
                                 string tail = pattern.Substring(1);
                                 string candidateTail = candidate.Substring(candidate.Length - tail.Length);
-                                if (String.Compare(tail, candidateTail, StringComparison.OrdinalIgnoreCase) == 0)
+                                if (String.Equals(tail, candidateTail, StringComparison.OrdinalIgnoreCase))
                                 {
                                     ++hits;
                                     files.Add(FileMatcher.Normalize(candidate));
@@ -1984,11 +1984,11 @@ private int GetMatchingFiles(string[] candidates, string path, string pattern, I
                             {
                                 string leader = pattern.Substring(0, pattern.Length - 4);
                                 string candidateLeader = candidate.Substring(candidate.Length - leader.Length - 4, leader.Length);
-                                if (String.Compare(leader, candidateLeader, StringComparison.OrdinalIgnoreCase) == 0)
+                                if (String.Equals(leader, candidateLeader, StringComparison.OrdinalIgnoreCase))
                                 {
                                     string tail = pattern.Substring(pattern.Length - 2);
                                     string candidateTail = candidate.Substring(candidate.Length - 2);
-                                    if (String.Compare(tail, candidateTail, StringComparison.OrdinalIgnoreCase) == 0)
+                                    if (String.Equals(tail, candidateTail, StringComparison.OrdinalIgnoreCase))
                                     {
                                         ++hits;
                                         files.Add(FileMatcher.Normalize(candidate));
@@ -2045,7 +2045,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
 
                                 if
                                 (
-                                    String.Compare(pattern, "*.*", StringComparison.OrdinalIgnoreCase) == 0
+                                    String.Equals(pattern, "*.*", StringComparison.OrdinalIgnoreCase)
                                     || pattern == null
                                 )
                                 {
@@ -2059,7 +2059,7 @@ private void GetMatchingDirectories(string[] candidates, string path, string pat
                                 {
                                     string tail = pattern.Substring(1);
                                     string baseMatchTail = baseMatch.Substring(1);
-                                    if (String.Compare(tail, baseMatchTail, StringComparison.OrdinalIgnoreCase) == 0)
+                                    if (String.Equals(tail, baseMatchTail, StringComparison.OrdinalIgnoreCase))
                                     {
                                         directories.Add(FileMatcher.Normalize(match));
                                     }
@@ -2316,7 +2316,7 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
                     int timesFound = 0;
                     foreach (string file in normalizedFiles)
                     {
-                        if (String.Compare(file, matchingFile, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(file, matchingFile, StringComparison.OrdinalIgnoreCase))
                         {
                             ++timesFound;
                         }
@@ -2335,7 +2335,7 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
                     int timesFound = 0;
                     foreach (string file in normalizedFiles)
                     {
-                        if (String.Compare(file, nonmatchingFile, StringComparison.OrdinalIgnoreCase) == 0)
+                        if (String.Equals(file, nonmatchingFile, StringComparison.OrdinalIgnoreCase))
                         {
                             ++timesFound;
                         }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 6eaea480bb1..6988124e6e4 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1348,7 +1348,7 @@ public static BuildResult BuildProjectFileUsingBuildManager(string projectFile,
         {
             using (var buildManager = new BuildManager())
             {
-                parameters = parameters ?? new BuildParameters();
+                parameters ??= new BuildParameters();
 
                 if (logger != null)
                 {
@@ -1604,7 +1604,7 @@ internal static ProjectGraph CreateProjectGraph(
             IEnumerable<int> entryPoints = null,
             ProjectCollection projectCollection = null)
         {
-            createProjectFile = createProjectFile ?? CreateProjectFile;
+            createProjectFile ??= CreateProjectFile;
 
             var nodes = new Dictionary<int, (bool IsRoot, string ProjectPath)>();
 
diff --git a/src/Shared/WeakStringCache.Concurrent.cs b/src/Shared/WeakStringCache.Concurrent.cs
index bf9c6ed8ca3..bd30282b614 100644
--- a/src/Shared/WeakStringCache.Concurrent.cs
+++ b/src/Shared/WeakStringCache.Concurrent.cs
@@ -26,6 +26,7 @@ public WeakStringCache()
         /// adds the resulting string to the cache, and returns it, setting cacheHit to false.
         /// </summary>
         /// <param name="internable">The internable describing the string we're looking for.</param>
+        /// <param name="cacheHit">true if match found in cache, false otherwise.</param>
         /// <returns>A string matching the given internable.</returns>
         /// <remarks>
         /// This method performs two operations on the underlying ConcurrentDictionary on both cache hit and cache miss.
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 067950dd794..abf1346f0cd 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -471,7 +471,7 @@ public void Basic()
             // Process the primary items.
             foreach (ITaskItem item in t.ResolvedFiles)
             {
-                if (String.Compare(item.ItemSpec, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(item.ItemSpec, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase))
                 {
                     systemXmlFound = true;
                     item.GetMetadata("DestinationSubDirectory").ShouldBe("", StringCompareShould.IgnoreCase);
@@ -530,13 +530,13 @@ public void Basic()
                     item.GetMetadata("CopyLocal").ShouldBe("true", StringCompareShould.IgnoreCase);
                     item.GetMetadata("FusionName").ShouldBe("MyMissingAssembly", StringCompareShould.IgnoreCase);
                 }
-                else if (String.Compare(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
                 {
                     // The version of System.Xml.dll in C:\MyProject is an older version.
                     // This version is not a match. When want the current version which should have been in a different directory.
                     Assert.True(false, "Wrong version of System.Xml.dll matched--version was wrong");
                 }
-                else if (String.Compare(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(item.ItemSpec, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase))
                 {
                     // The version of System.Data.dll in C:\MyProject has an incorrect PKT
                     // This version is not a match.
@@ -587,14 +587,14 @@ public void Basic()
             // Process the satellites.
             foreach (ITaskItem item in t.SatelliteFiles)
             {
-                if (String.Compare(item.ItemSpec, Path.Combine(s_myVersion20Path, "en", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(item.ItemSpec, Path.Combine(s_myVersion20Path, "en", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase))
                 {
                     enSatellitePdbFound = true;
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.imageRuntime));
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.winMDFile));
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.winmdImplmentationFile));
                 }
-                else if (String.Compare(item.ItemSpec, Path.Combine(s_myVersion20Path, "en-GB", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase) == 0)
+                else if (String.Equals(item.ItemSpec, Path.Combine(s_myVersion20Path, "en-GB", "System.XML.resources.pdb"), StringComparison.OrdinalIgnoreCase))
                 {
                     engbSatellitePdbFound = true;
                     Assert.Empty(item.GetMetadata(ItemMetadataNames.imageRuntime));
@@ -4337,7 +4337,7 @@ public void RegressQFE626()
 
             foreach (ITaskItem item in t.ResolvedDependencyFiles)
             {
-                if (0 == String.Compare(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
                 {
                     Assert.Equal("false", item.GetMetadata("CopyLocal"));
                 }
@@ -4400,12 +4400,12 @@ public void Regress265054()
 
             foreach (ITaskItem item in t.ResolvedDependencyFiles)
             {
-                if (0 == String.Compare(item.ItemSpec, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase))
                 {
                     Assert.Equal("false", item.GetMetadata("CopyLocal"));
                 }
 
-                if (0 == String.Compare(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
                 {
                     Assert.Equal("true", item.GetMetadata("CopyLocal"));
                 }
@@ -7985,7 +7985,7 @@ private int RunTargetFrameworkFilteringTest(string projectTargetFramework)
                 }
                 Assert.NotEqual(0, mask); // "Unexpected assembly in resolved list."
                 Assert.Equal(0, (mask & set)); // "Assembly found twice in resolved list."
-                set = set | mask;
+                set |= mask;
             }
             return set;
         }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 1483ed1e8f1..5b2c9c4de6b 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -642,11 +642,11 @@ internal static string[] GetFiles(string path, string pattern)
             {
                 string baseDir = Path.GetDirectoryName(file);
 
-                if (0 == String.Compare(baseDir, path, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(baseDir, path, StringComparison.OrdinalIgnoreCase))
                 {
                     string fileExtension = Path.GetExtension(file);
 
-                    if (0 == String.Compare(fileExtension, extension, StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(fileExtension, extension, StringComparison.OrdinalIgnoreCase))
                     {
                         matches.Add(file);
                     }
@@ -709,36 +709,36 @@ private static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAs
             imageRuntimeVersion = getAssemblyRuntimeVersion(fullPath);
             isManagedWinMD = false;
 
-            if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 isManagedWinMD = true;
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
@@ -746,7 +746,7 @@ private static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAs
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
@@ -758,11 +758,11 @@ private static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAs
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\FakeSDK\WindowsMetadata\SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
-            else if (String.Compare(fullPath, @"C:\WinMDLib\LibWithWinmdAndNoDll.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(fullPath, @"C:\WinMDLib\LibWithWinmdAndNoDll.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
@@ -836,8 +836,8 @@ internal static bool FileExists(string path)
                 {
                     uniqueFileExists[lowerPath] = 0;
                 }
-                
-                uniqueFileExists[lowerPath] = uniqueFileExists[lowerPath] + 1;
+
+                uniqueFileExists[lowerPath] += 1;
             }
 
             // First, MyMissingAssembly doesn't exist anywhere.
@@ -853,7 +853,7 @@ internal static bool FileExists(string path)
 
             foreach (string file in s_existentFiles)
             {
-                if (0 == String.Compare(path, file, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(path, file, StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
@@ -880,7 +880,7 @@ internal static bool DirectoryExists(string path)
 
             foreach (string dir in existentDirs)
             {
-                if (0 == String.Compare(path, dir, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(path, dir, StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
@@ -906,7 +906,7 @@ internal static string[] GetDirectories(string path, string pattern)
 
                 return paths;
             }
-            else if (String.Compare(path, @".", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @".", StringComparison.OrdinalIgnoreCase))
             {
                 // Pretend the current directory has a few subfolders.
                 return new string[] {
@@ -924,74 +924,74 @@ internal static string[] GetDirectories(string path, string pattern)
         /// <returns>Image runtime version</returns>
         internal static string GetRuntimeVersion(string path)
         {
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0, CLR V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleClrOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleClrOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "CLR V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleBadWindowsRuntime.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleBadWindowsRuntime.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "Windows Runtime";
             }
-            else if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndOther.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndOther.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0, Other V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return "V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return "V2.0.50727";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0";
             }
-            else if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return "WindowsRuntime 1.0";
             }
@@ -1047,7 +1047,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, @"c:\OldClrBug\MyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, @"c:\OldClrBug\MyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase)
             )
             {
                 // An older LKG of the CLR could throw a FileLoadException if it doesn't recognize
@@ -1057,7 +1057,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase)
             )
             {
                 // This is an mscorlib that returns null for its assembly name.
@@ -1066,7 +1066,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "BadImage.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "BadImage.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 throw new System.BadImageFormatException(@"The format of the file '" + Path.Combine(s_myVersion20Path, "BadImage.dll") + "' is invalid");
@@ -1074,9 +1074,9 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myProjectPath, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myProjectPath, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 // This is an mscorlib.dll with no metadata.
@@ -1085,8 +1085,8 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 // This is an mscorlib.dll with no metadata.
@@ -1098,129 +1098,129 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 throw new FileNotFoundException(path);
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "DependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "DependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnFoo45Framework, Version=4.5.0.0, PublicKeyToken=null, Culture=Neutral");
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "DependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "DependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnFoo4Framework, Version=4.0.0.0, PublicKeyToken=null, Culture=Neutral");
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "DependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "DependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnFoo35Framework, Version=3.5.0.0, PublicKeyToken=null, Culture=Neutral");
             }
 
-            if (String.Compare(path, @"c:\Regress315619\A\MyAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress315619\A\MyAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyAssembly, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"c:\Regress315619\B\MyAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress315619\B\MyAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyAssembly, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress442570_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
-            if (String.Compare(path, @"c:\Regress387218\v1\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\v1\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\Regress387218\v2\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\v2\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"c:\Regress390219\v1\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\v1\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=1.0.0.0, Culture=fr, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\Regress390219\v2\D.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\v2\D.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=2.0.0.0, Culture=en, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\MyStronglyNamed\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyStronglyNamed\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neUtral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\MyNameMismatch\Foo.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyNameMismatch\Foo.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Notice the metadata assembly name does not match the base file name.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neUtral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"c:\MyEscapedName\=A=.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyEscapedName\=A=.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Notice the metadata assembly name does not match the base file name.
                 return new AssemblyNameExtension("\\=A\\=, Version=2.0.0.0, Culture=neUtral, PublicKeyToken=b77a5c561934e089", true);
             }
 
-            if (String.Compare(path, @"c:\MyEscapedName\__'ASP'dw0024ry.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyEscapedName\__'ASP'dw0024ry.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Notice the metadata assembly name does not match the base file name.
                 return new AssemblyNameExtension("__\\'ASP\\'dw0024ry", true);
             }
 
-            if (String.Compare(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate an assembly that throws an UnauthorizedAccessException upon access.
                 throw new UnauthorizedAccessException();
             }
 
-            if (String.Compare(path, Path.Combine(Path.GetTempPath(), @"RawFileNameRelative\System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(Path.GetTempPath(), @"RawFileNameRelative\System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
-            if (String.Compare(path, Path.Combine(Path.GetTempPath(), @"RelativeAssemblyFiles\System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(Path.GetTempPath(), @"RelativeAssemblyFiles\System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.XML.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
             // This is an assembly with an earlier version.
-            if (String.Compare(path, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myProjectPath, "System.Xml.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension(AssemblyRef.SystemXml);
             }
 
             // This is an assembly with an incorrect PKT.
-            if (String.Compare(path, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myProjectPath, "System.Data.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=A77a5c561934e089");
@@ -1232,19 +1232,19 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 return new AssemblyNameExtension("MyGacAssembly, Version=9.2.3401.1, Culture=neutral, PublicKeyToken=a6694b450823df78");
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System, VeRSion=2.0.0.0, Culture=neutRAl, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System, VeRSion=4.0.0.0, Culture=neutRAl, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("System, VeRSion=9.0.0.0, Culture=neutRAl, PublicKeyToken=b77a5c561934e089");
@@ -1252,7 +1252,7 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "System.Data.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "System.Data.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 // Simulate a strongly named assembly.
@@ -1275,68 +1275,66 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
             {
                 return new AssemblyNameExtension("E, Version=0.0.0.0, Culture=neutral, PUBlicKeyToken=null");
             }
-
-            if (String.Compare(path, s_unifyMeDll_V05Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V05Path, StringComparison.OrdinalIgnoreCase))
             {
                 throw new FileNotFoundException();
             }
 
-            if (String.Compare(path, s_unifyMeDll_V10Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V10Path, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("UnifyMe, Version=1.0.0.0, Culture=nEUtral, PublicKeyToken=b77a5c561934e089, ProcessorArchitecture=MSIL");
             }
 
-            if (String.Compare(path, @"C:\Framework\Everett\System.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Framework\Everett\System.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("System, Version=1.0.5000.0, Culture=neutral, PublICKeyToken=" + AssemblyRef.EcmaPublicKey);
             }
 
-            if (String.Compare(path, @"C:\Framework\Whidbey\System.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Framework\Whidbey\System.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=" + AssemblyRef.EcmaPublicKey);
             }
-
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnEverettSystem, VersION=1.0.5000.0, Culture=neutral, PublicKeyToken=feedbeadbadcadbe");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, Version=0.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderA\C.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderA\C.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("C, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderB\C.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderB\C.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, VERSion=1.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, VeRSIon=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnUnified, Version=3.0.0.0, Culture=neutral, PublicKEYToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, s_unifyMeDll_V20Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V20Path, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("UnifyMe, Version=2.0.0.0, Culture=neutral, PublicKeyTOKEn=b77a5c561934e089");
             }
 
-            if (String.Compare(path, s_unifyMeDll_V30Path, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_unifyMeDll_V30Path, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("UnifyMe, Version=3.0.0.0, Culture=neutral, PublICkeyToken=b77a5c561934e089");
             }
@@ -1356,417 +1354,417 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 return new AssemblyNameExtension("G, Version=2.0.0.0, Culture=neutral, PublicKEyToken=aaaaaaaaaaaaaaaa");
             }
 
-            if (String.Compare(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, @"C:\Regress317975\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, @"C:\Regress317975\v2\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\v2\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
             // Set up assembly names for testing target framework version checks
             // Is version 4 and will only depends on 4.0 assemblies
-            if (String.Compare(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnOnlyv4Assemblies, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
             // Is version 9 and will not have any dependencies, will be in the redist list
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("ReferenceVersion9, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
             // Is a third party assembly which depends on a version 9 assembly
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
             //A second assembly which depends on version 9 framework assemblies.
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9Also, Version=9.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9, Version=1.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOn9, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089");
             }
 
-            if (String.Compare(path, s_regress444809_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_V2_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_V2_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("B, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("D, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\Regress714052\X86\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\X86\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
 
-            if (String.Compare(path, @"C:\Regress714052\MSIL\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\MSIL\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
 
-            if (String.Compare(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, @"C:\Regress714052\X86\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\X86\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
-            if (String.Compare(path, @"C:\Regress714052\Mix\b.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\Mix\b.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
-            if (String.Compare(path, @"C:\Regress714052\MSIL\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\MSIL\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=MSIL");
             }
-            if (String.Compare(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress714052\None\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("B, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("V, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("W, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("X, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("Z, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("Y, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("Microsoft.Build, Version=12.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("DependsOnMSBuild12, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\WinMD\v4\MsCorlib.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\v4\MsCorlib.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("mscorlib, Version=4.0.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"C:\WinMD\v255\MsCorlib.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\v255\MsCorlib.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("mscorlib, Version=255.255.255.255, Culture=Neutral, PublicKeyToken=b77a5c561934e089");
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DotNetAssemblyDependsOnWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DotNetAssemblyDependsOn255WinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnInvalidPeHeader.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnInvalidPeHeader.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnInvalidPeHeader, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnAmd64.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnAmd64.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnAmd64, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnArm.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnArm.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnArm, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnIA64.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnIA64.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnIA64, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnArmv7.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnArmv7.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnArmv7, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnX86.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnX86.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnX86, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnUnknown.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnUnknown.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnUnknown, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMDArchVerification\DependsOnAnyCPUUnknown.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMDArchVerification\DependsOnAnyCPUUnknown.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DependsOnAnyCPUUnknown, Version=1.0.0.0");
             }
-            if (String.Compare(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("WinMDWithVersion255, Version=255.255.255.255");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly2, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly3, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeOnly4, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeReferencingSystem, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeReferencingSystemDNE, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndCLR.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SampleWindowsRuntimeAndCLR, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponents\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponents\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponents2\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponents2\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=2.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponent7s\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponent7s\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponents9\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponents9\MyGridWinMD.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponentsVv1\MyGridWinMD2.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponentsVv1\MyGridWinMD2.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD2, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\MyWinMDComponentsV1\MyGridWinMD3.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyWinMDComponentsV1\MyGridWinMD3.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("MyGridWinMD3, Version=1.0.0.0");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DebugX86SDKWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DebugNeutralSDKWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("X86SDKWinMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKWinMD.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("NeutralSDKWINMD, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\X86\DebugX86SDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("Debugx86SDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\Neutral\DebugNeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("DebugNeutralSDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\x86\x86SDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("X86SDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\CommonConfiguration\Neutral\NeutralSDKRA.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("NeutralSDKRA, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\FakeSDK\References\Debug\X86\SDKReference.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\FakeSDK\References\Debug\X86\SDKReference.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("SDKReference, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("b, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("A, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension("C, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder_x64\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder_x64\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("assemblyfromconfig_common, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=AMD64");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder_x86\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder_x86\assemblyfromconfig_common.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("assemblyfromconfig_common, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder5010x64\v5assembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder5010x64\v5assembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("v5assembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=AMD64");
             }
 
-            if (string.Compare(path, @"c:\assemblyfromconfig\folder501000x86\v5assembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, @"c:\assemblyfromconfig\folder501000x86\v5assembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("v5assembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
             }
 
-            if (string.Compare(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
 
-            if (string.Compare(path, s_nugetCache_N_Lib_NDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(path, s_nugetCache_N_Lib_NDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("N, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null");
             }
@@ -1852,7 +1850,7 @@ string path
         /// <returns>The array of dependent assembly names.</returns>
         internal static AssemblyNameExtension[] GetDependencies(string path)
         {
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo4Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1860,7 +1858,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo45Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1868,7 +1866,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_frameworksPath, "IndirectDependsOnFoo35Framework.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1876,7 +1874,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress454863_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress454863_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1884,7 +1882,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1892,7 +1890,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1900,7 +1898,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1908,7 +1906,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress387218\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1916,7 +1914,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress387218\B.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress387218\B.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1924,7 +1922,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress390219\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1932,7 +1930,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress390219\B.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress390219\B.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1940,7 +1938,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress442570_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1948,7 +1946,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\Microsoft.Office.Interop.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1956,7 +1954,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress313747\MS.Internal.Test.Automation.Office.Excel.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1964,7 +1962,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\OldClrBug\DependsMyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\OldClrBug\DependsMyFileLoadExceptionAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1972,7 +1970,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\Regress563286\DependsOnBadImage.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress563286\DependsOnBadImage.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1980,17 +1978,17 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\MyInaccessible\A.dll", StringComparison.OrdinalIgnoreCase))
             {
                 throw new UnauthorizedAccessException();
             }
 
-            if (String.Compare(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"c:\Regress313086\mscorlib.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -1998,7 +1996,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOnWinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2006,7 +2004,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\DotNetAssemblyDependsOn255WinMD.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2014,7 +2012,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeAndClr.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeAndClr.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                  {
@@ -2022,7 +2020,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                  };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                  {
@@ -2030,7 +2028,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                  };
             }
 
-            if (String.Compare(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\WinMDWithVersion255.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2038,7 +2036,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly2.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2046,7 +2044,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly3.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2057,7 +2055,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeOnly4.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2066,7 +2064,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystem.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2075,7 +2073,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\WinMD\SampleWindowsRuntimeReferencingSystemDNE.Winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2086,8 +2084,8 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
 
             if
             (
-                String.Compare(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
-                || String.Compare(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase) == 0
+                String.Equals(path, Path.Combine(s_myVersion20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
+                || String.Equals(path, Path.Combine(s_myVersionPocket20Path, "mscorlib.dll"), StringComparison.OrdinalIgnoreCase)
             )
             {
                 return new AssemblyNameExtension[]
@@ -2095,14 +2093,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"MyRelativeAssembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"MyRelativeAssembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myAppRootPath, "DependsOnSimpleA.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myAppRootPath, "DependsOnSimpleA.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2110,7 +2108,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress312873\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress312873\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2118,7 +2116,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderA\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderA\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2126,7 +2124,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress339786\FolderB\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress339786\FolderB\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2134,7 +2132,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\Regress317975\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2142,7 +2140,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\myassemblies\My.Assembly.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\myassemblies\My.Assembly.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2150,7 +2148,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "MyGrid.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "MyGrid.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2158,15 +2156,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\MyRawDropControls\MyRawDropControl.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\MyRawDropControls\MyRawDropControl.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
                     new AssemblyNameExtension("mscorlib, VeRsIon=2.0.0.0, Culture=neuTRal, PublicKeyToken=b77a5c561934e089")
                 };
             }
-
-            if (String.Compare(path, s_myLibraries_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2174,7 +2171,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_TDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_TDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2182,7 +2179,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2191,7 +2188,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_V1_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2199,7 +2196,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_V2_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_V2_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2207,14 +2204,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myLibraries_V1_E_EDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V05Path, "DependsOnWeaklyNamedUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V05Path, "DependsOnWeaklyNamedUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2222,7 +2219,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnEverettSystem.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2230,7 +2227,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V05Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2238,7 +2235,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V10Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2246,7 +2243,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V20Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2254,7 +2251,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myApp_V30Path, "DependsOnUnified.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2262,14 +2259,14 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_myMissingAssemblyAbsPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_myMissingAssemblyAbsPath, StringComparison.OrdinalIgnoreCase))
             {
                 throw new FileNotFoundException(path);
             }
 
             // Set up assembly names for testing target framework version checks
             // Is version 4 and will only depends on 4.0 assemblies
-            if (String.Compare(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_40ComponentDependsOnOnlyv4AssembliesDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2278,7 +2275,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             }
 
             // Is version 9 and will not have any dependencies, will be in the redist list
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "ReferenceVersion9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2288,7 +2285,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             }
 
             // Is a third party assembly which depends on a version 9 assembly
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2298,7 +2295,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             }
 
             //A second assembly which depends on version 9 framework assemblies.
-            if (String.Compare(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsMiscPath, "DependsOn9Also.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2306,7 +2303,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents10Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2314,7 +2311,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents20Path, "DependsOn9.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2322,7 +2319,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_CDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2331,7 +2328,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_BDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2339,7 +2336,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_regress444809_DDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2347,7 +2344,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "V.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2355,12 +2352,12 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponents2RootPath, "W.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "X.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2368,12 +2365,12 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Z.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Y.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2381,12 +2378,12 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "Microsoft.Build.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[] { };
             }
 
-            if (String.Compare(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "DependsOnMSBuild12.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2394,7 +2391,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion20Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2403,7 +2400,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion40Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2412,7 +2409,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, Path.Combine(s_myVersion90Path, "System.dll"), StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2421,7 +2418,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsOnlyDll\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2430,7 +2427,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\b.dll", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2439,13 +2436,13 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainsdllAndWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[0];
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\a.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a strongly named assembly.
                 return new AssemblyNameExtension[]
@@ -2454,7 +2451,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, @"C:\DirectoryContainstwoWinmd\c.winmd", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[0];
             }
@@ -2464,7 +2461,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 return new AssemblyNameExtension[0];
             }
 
-            if (String.Compare(path, s_portableDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_portableDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a portable assembly with a reference to System.Runtime
                 return new AssemblyNameExtension[]
@@ -2473,7 +2470,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_netstandardLibraryDllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_netstandardLibraryDllPath, StringComparison.OrdinalIgnoreCase))
             {
                 // Simulate a .NET Standard assembly
                 return new AssemblyNameExtension[]
@@ -2482,7 +2479,7 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
                 };
             }
 
-            if (String.Compare(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, s_dependsOnNuGet_ADllPath, StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension[]
                 {
@@ -2526,89 +2523,89 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (String.Compare(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "", "vBogusVersion", "v1.a.2.3", "v1.0", "v3.0", "v2.0.50727", "v2.0.x86chk", "RandomJunk" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "ZControlA", "ZControlB", "Infragistics.GridControl.1.0", "Infragistics.MyHKLMControl.1.0", "Infragistics.MyControlWithFutureTargetNDPVersion.1.0", "Infragistics.MyControlWithPastTargetNDPVersion.1.0", "Infragistics.MyControlWithServicePack.1.0" };
                 }
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "RawDropControls" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Infragistics.MyControlWithFutureTargetNDPVersion.1.0" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Infragistics.MyNDP1Control.1.0", "Infragistics.MyControlWithPastTargetNDPVersion.1.0" };
                 }
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return new string[] { };
@@ -2616,39 +2613,39 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     // This control has a service pack
                     return new string[] { "sp1", "sp2" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "v2.0.3600" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "PocketPC" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "AFETestDeviceControl" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "1234" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\Microsoft SDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\Microsoft SDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Windows" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "7.0", "8.0", "v8.0", "9.0" };
                 }
@@ -2656,105 +2653,105 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (String.Compare(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "v2.0.0" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "A", "B" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "X86" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "MSIL" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "None" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Mix" };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "vBogusVersion", "v2.0.50727" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "Infragistics.FancyControl.1.0", "Infragistics.MyHKLMControl.1.0" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "v2.0.3600" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "PocketPC" };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { };
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\Microsoft SDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new string[] { "8.0" };
                 }
@@ -2775,41 +2772,41 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlA", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponentsA";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\ZControlB", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponentsB";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.GridControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.x86chk\AssemblyFoldersEx\RawDropControls", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyRawDropControls";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents\HKCU Components";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v3.0\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return s_myComponentsV30Path;
                 }
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithFutureTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return s_myComponentsV20Path;
@@ -2817,7 +2814,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return @"C:\MyComponentBase";
@@ -2825,7 +2822,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp1", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp1", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return @"C:\MyComponentServicePack1";
@@ -2833,7 +2830,7 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp2", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyControlWithServicePack.1.0\sp2", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return @"C:\MyComponentServicePack2";
@@ -2841,18 +2838,18 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
                 if
                 (
-                    String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase) == 0
-                    || String.Compare(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase) == 0
+                    String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyNDP1Control.1.0", StringComparison.OrdinalIgnoreCase)
+                    || String.Equals(subKey, @"Software\Microsoft\.NetFramework\v1.0\AssemblyFoldersEx\Infragistics.MyControlWithPastTargetNDPVersion.1.0", StringComparison.OrdinalIgnoreCase)
                 )
                 {
                     return s_myComponentsV10Path;
                 }
 
-                if (String.Compare(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\V1Control";
                 }
-                if (String.Compare(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl\1234", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"SOFTWARE\Microsoft\.NETCompactFramework\v2.0.3600\PocketPC\AssemblyFoldersEx\AFETestDeviceControl\1234", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\V1ControlSP1";
                 }
@@ -2860,44 +2857,44 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.FancyControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents\HKLM Components";
                 }
 
-                if (String.Compare(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Microsoft\.NetFramework\v2.0.50727\AssemblyFoldersEx\Infragistics.MyHKLMControl.1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\MyComponents\HKLM Components";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\B", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\X86";
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\AssemblyFoldersEx\A", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\MSIL";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\X86\X86", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\X86";
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\Mix\Mix", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\Mix";
                 }
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\MSIL";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\MSIL\MSIL", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\MSIL";
                 }
 
-                if (String.Compare(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(subKey, @"Software\Regress714052\v2.0.0\None\None", StringComparison.OrdinalIgnoreCase))
                 {
                     return @"C:\Regress714052\None";
                 }
@@ -2947,7 +2944,7 @@ protected static bool ContainsItem(ITaskItem[] items, string spec)
         {
             foreach (ITaskItem item in items)
             {
-                if (0 == String.Compare(item.ItemSpec, spec, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(item.ItemSpec, spec, StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
diff --git a/src/Tasks.UnitTests/CommandLine_Support.cs b/src/Tasks.UnitTests/CommandLine_Support.cs
index bf3e66cb713..c807d9c934c 100644
--- a/src/Tasks.UnitTests/CommandLine_Support.cs
+++ b/src/Tasks.UnitTests/CommandLine_Support.cs
@@ -175,10 +175,10 @@ bool useResponseFile
                     // Skip anything shorter than the compare string.
                     continue;
                 }
-                if (String.Compare(s.Substring(0, startsWith.Length), startsWith, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(s.Substring(0, startsWith.Length), startsWith, StringComparison.OrdinalIgnoreCase))
                 {
                     // If this doesn't match the 'except' then this is an error.
-                    if (String.Compare(s, except, StringComparison.Ordinal) != 0)
+                    if (!String.Equals(s, except, StringComparison.Ordinal))
                     {
                         msg += String.Format(" Found something!\r\n");
                         Console.WriteLine(msg);
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 69c943c4551..2114a8f4fac 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -40,16 +40,16 @@ public bool UseSingleThreadedCopy
         private int _parallelismThreadCount = DefaultParallelismThreadCount;
 
         /// <summary>
-        /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run 
+        /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run
         /// the tests isolated from the current state of the environment, but put it back how it belongs
-        /// once we're done. 
+        /// once we're done.
         /// </summary>
         private readonly string _alwaysOverwriteReadOnlyFiles;
 
         /// <summary>
-        /// Temporarily save off the value of MSBUILDALWAYSRETRY, so that we can run 
+        /// Temporarily save off the value of MSBUILDALWAYSRETRY, so that we can run
         /// the tests isolated from the current state of the environment, but put it back how it belongs
-        /// once we're done. 
+        /// once we're done.
         /// </summary>
         private readonly string _alwaysRetry;
 
@@ -57,7 +57,7 @@ public bool UseSingleThreadedCopy
 
         /// <summary>
         /// There are a couple of environment variables that can affect the operation of the Copy
-        /// task.  Make sure none of them are set. 
+        /// task.  Make sure none of them are set.
         /// </summary>
         public Copy_Tests(ITestOutputHelper testOutputHelper)
         {
@@ -72,7 +72,7 @@ public Copy_Tests(ITestOutputHelper testOutputHelper)
         }
 
         /// <summary>
-        /// Restore the environment variables we cleared out at the beginning of the test. 
+        /// Restore the environment variables we cleared out at the beginning of the test.
         /// </summary>
         public void Dispose()
         {
@@ -189,7 +189,7 @@ public void DoNotNormallyCopyOverReadOnlyFile()
         }
 
         /// <summary>
-        /// If MSBUILDALWAYSOVERWRITEREADONLYFILES is set, then overwrite read-only even when 
+        /// If MSBUILDALWAYSOVERWRITEREADONLYFILES is set, then overwrite read-only even when
         /// OverwriteReadOnlyFiles is false
         /// </summary>
         [Fact]
@@ -256,7 +256,7 @@ public void CopyOverReadOnlyFileEnvironmentOverride()
         }
 
         /// <summary>
-        /// If MSBUILDALWAYSRETRY is set, keep retrying the copy. 
+        /// If MSBUILDALWAYSRETRY is set, keep retrying the copy.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
@@ -1011,7 +1011,7 @@ internal class CopyMonitor
         }
 
         /// <summary>
-        /// CopiedFiles should only include files that were successfully copied 
+        /// CopiedFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
         [Fact]
@@ -1547,7 +1547,7 @@ public void CopyWithDuplicatesUsingFiles()
         }
 
         /// <summary>
-        /// DestinationFiles should only include files that were successfully copied 
+        /// DestinationFiles should only include files that were successfully copied
         /// (or skipped), not files for which there was an error.
         /// </summary>
         [Fact]
@@ -1604,7 +1604,7 @@ public void DestinationFilesLengthNotEqualSourceFilesLength()
 
         /// <summary>
         /// If the destination path is too long, the task should not bubble up
-        /// the System.IO.PathTooLongException 
+        /// the System.IO.PathTooLongException
         /// </summary>
         [Fact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
@@ -1648,7 +1648,7 @@ public void Regress451057_ExitGracefullyIfPathNameIsTooLong()
 
         /// <summary>
         /// If the source path is too long, the task should not bubble up
-        /// the System.IO.PathTooLongException 
+        /// the System.IO.PathTooLongException
         /// </summary>
         [Fact]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
@@ -1769,7 +1769,7 @@ public void FailureWithNoRetries()
                 UseHardlinksIfPossible = UseHardLinks,
                 UseSymboliclinksIfPossible = UseSymbolicLinks,
             };
-            
+
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
             bool result = t.Execute(copyFunctor.Copy, _parallelismThreadCount);
 
@@ -1813,7 +1813,7 @@ public void DefaultNoHardlink()
             {
                 RetryDelayMilliseconds = 1,  // speed up tests!
             };
-            
+
             Assert.False(t.UseHardlinksIfPossible);
         }
 
diff --git a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
index 4cbd6362079..9a77edb3002 100644
--- a/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateCSharpManifestResourceName_Tests.cs
@@ -791,7 +791,7 @@ class MyForm
         /// <returns>The Stream</returns>
         private Stream CreateFileStream(string path, FileMode mode, FileAccess access)
         {
-            if (String.Compare(path, "SR1.strings", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, "SR1.strings", StringComparison.OrdinalIgnoreCase))
             {
                 return StreamHelpers.StringToStream("namespace MyStuff.Namespace { class Class {} }");
             }
diff --git a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
index e112dd0b4c0..ce70c6c1a2f 100644
--- a/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
+++ b/src/Tasks.UnitTests/CreateVisualBasicManifestResourceName_Tests.cs
@@ -410,7 +410,7 @@ End Class
         /// <returns>The Stream</returns>
         private Stream CreateFileStream(string path, FileMode mode, FileAccess access)
         {
-            if (String.Compare(path, "SR1.strings", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(path, "SR1.strings", StringComparison.OrdinalIgnoreCase))
             {
                 return StreamHelpers.StringToStream(
 @"
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index c5a56f24f1e..298548b0fbf 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -29,7 +29,7 @@ public void BasicMove()
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
                     sw.Write("This is a source temp file.");
                 FileInfo file = new FileInfo(sourceFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark read only
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
@@ -71,7 +71,7 @@ public void BasicMoveOverwriteReadOnlyFilesTrue()
                 using (StreamWriter sw = FileUtilities.OpenWrite(sourceFile, true))
                     sw.Write("This is a source temp file.");
                 FileInfo file = new FileInfo(sourceFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark read only
 
                 ITaskItem[] sourceFiles = new ITaskItem[] { new TaskItem(sourceFile) };
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
@@ -98,7 +98,7 @@ public void BasicMoveOverwriteReadOnlyFilesTrue()
                 if (File.Exists(sourceFile))
                 {
                     FileInfo file = new FileInfo(sourceFile);
-                    file.Attributes = file.Attributes & ~FileAttributes.ReadOnly; // mark read only
+                    file.Attributes &= ~FileAttributes.ReadOnly; // mark read only
                     File.Delete(sourceFile);
                 }
 
@@ -206,7 +206,7 @@ public void MoveOverExistingFileReadOnlyNoOverwrite()
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark destination read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark destination read only
 
                 Move t = new Move();
                 t.BuildEngine = new MockEngine(true /* log to console */);
@@ -230,7 +230,7 @@ public void MoveOverExistingFileReadOnlyNoOverwrite()
                 File.Delete(sourceFile);
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes ^ FileAttributes.ReadOnly; // mark destination writable only
+                file.Attributes ^= FileAttributes.ReadOnly; // mark destination writable only
                 File.Delete(destinationFile);
             }
         }
@@ -301,7 +301,7 @@ public void MoveOverExistingFileOverwriteReadOnly()
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes & ~FileAttributes.ReadOnly; // mark not read only
+                file.Attributes &= ~FileAttributes.ReadOnly; // mark not read only
 
                 Move t = new Move();
                 t.OverwriteReadOnlyFiles = true;
@@ -349,7 +349,7 @@ public void MoveOverExistingFileOverwriteReadOnlyOverWriteReadOnlyFilesTrue()
                 ITaskItem[] destinationFiles = new ITaskItem[] { new TaskItem(destinationFile) };
 
                 FileInfo file = new FileInfo(destinationFile);
-                file.Attributes = file.Attributes | FileAttributes.ReadOnly; // mark read only
+                file.Attributes |= FileAttributes.ReadOnly; // mark read only
 
                 Move t = new Move();
                 t.OverwriteReadOnlyFiles = true;
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 613c44e048d..51c2397ccac 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -218,7 +218,7 @@ public void CheckTaskItemToTypeLibAttr()
         }
 
         /// <summary>
-        /// Helper function for creating a ComReferenceInfo object using an existing TaskInfo object and 
+        /// Helper function for creating a ComReferenceInfo object using an existing TaskInfo object and
         /// typelib name/path. The type lib pointer will obviously not be initialized, so this object cannot
         /// be used in any code that uses it.
         /// </summary>
@@ -293,7 +293,7 @@ public void CheckIsExistingProjectReference()
 
             // find the Ax ref, matching with any type of reference - should NOT find it
             bool retValue = rcr.IsExistingProjectReference(axAttr, null, out ComReferenceInfo referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "ActiveX ref should NOT be found for any type of ref"
+            Assert.True(!retValue && referenceInfo == null); // "ActiveX ref should NOT be found for any type of ref"
 
             // find the Ax ref, matching with aximp types - should find it
             retValue = rcr.IsExistingProjectReference(axAttr, ComReferenceTypes.aximp, out referenceInfo);
@@ -301,7 +301,7 @@ public void CheckIsExistingProjectReference()
 
             // find the Ax ref, matching with tlbimp types - should NOT find it
             retValue = rcr.IsExistingProjectReference(axAttr, ComReferenceTypes.tlbimp, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "ActiveX ref should NOT be found for tlbimp ref types"
+            Assert.True(!retValue && referenceInfo == null); // "ActiveX ref should NOT be found for tlbimp ref types"
 
 
             // find the Tlb ref, matching with any type of reference - should find it
@@ -314,7 +314,7 @@ public void CheckIsExistingProjectReference()
 
             // find the Tlb ref, matching with pia types - should NOT find it
             retValue = rcr.IsExistingProjectReference(tlbAttr, ComReferenceTypes.primary, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "Tlb ref should NOT be found for primary ref types"
+            Assert.True(!retValue && referenceInfo == null); // "Tlb ref should NOT be found for primary ref types"
 
 
             // find the Pia ref, matching with any type of reference - should find it
@@ -327,11 +327,11 @@ public void CheckIsExistingProjectReference()
 
             // find the Pia ref, matching with pia types - should NOT find it
             retValue = rcr.IsExistingProjectReference(piaAttr, ComReferenceTypes.aximp, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "Pia ref should NOT be found for aximp ref types"
+            Assert.True(!retValue && referenceInfo == null); // "Pia ref should NOT be found for aximp ref types"
 
             // try to find a non existing reference
             retValue = rcr.IsExistingProjectReference(notInProjectAttr, null, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "not in project ref should not be found"
+            Assert.True(!retValue && referenceInfo == null); // "not in project ref should not be found"
         }
 
         /// <summary>
@@ -368,7 +368,7 @@ public void CheckIsExistingDependencyReference()
 
             // try to find a non existing reference - should not find it
             retValue = rcr.IsExistingDependencyReference(notInProjectAttr, out referenceInfo);
-            Assert.True(retValue == false && referenceInfo == null); // "not in project ref should not be found"
+            Assert.True(!retValue && referenceInfo == null); // "not in project ref should not be found"
 
             // Now, try to resolve a non-existent ComAssemblyReference. 
             string path;
@@ -378,7 +378,7 @@ public void CheckIsExistingDependencyReference()
         }
 
         /// <summary>
-        /// ResolveComReference automatically adds missing tlbimp references for aximp references. 
+        /// ResolveComReference automatically adds missing tlbimp references for aximp references.
         /// This test verifies we actually create the missing references.
         /// </summary>
         [Fact]
@@ -646,10 +646,10 @@ public void TestCheckForConflictingReferences()
 
         /// <summary>
         /// In order to make ResolveComReferences multitargetable, two properties, ExecuteAsTool
-        /// and SdkToolsPath were added.  In order to have correct behavior when using pre-4.0 
+        /// and SdkToolsPath were added.  In order to have correct behavior when using pre-4.0
         /// toolsversions, ExecuteAsTool must default to true, and the paths to the tools will be the
-        /// v3.5 path.  It is difficult to verify the tool paths in a unit test, however, so 
-        /// this was done by ad hoc testing and will be maintained by the dev suites.  
+        /// v3.5 path.  It is difficult to verify the tool paths in a unit test, however, so
+        /// this was done by ad hoc testing and will be maintained by the dev suites.
         /// </summary>
         [Fact]
         public void MultiTargetingDefaultSetCorrectly()
@@ -662,7 +662,7 @@ public void MultiTargetingDefaultSetCorrectly()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWCreateTlb()
@@ -673,7 +673,7 @@ public void AxReferenceKnowsItsRCWCreateTlb()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWCreateTlb_IncludeVersion()
@@ -684,7 +684,7 @@ public void AxReferenceKnowsItsRCWCreateTlb_IncludeVersion()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWTlbExists()
@@ -695,7 +695,7 @@ public void AxReferenceKnowsItsRCWTlbExists()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         ///
         /// Tests that still works when IncludeVersionInInteropName = true
         /// </summary>
@@ -708,7 +708,7 @@ public void AxReferenceKnowsItsRCWTlbExists_IncludeVersion()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         /// </summary>
         [Fact]
         public void AxReferenceKnowsItsRCWPiaExists()
@@ -719,7 +719,7 @@ public void AxReferenceKnowsItsRCWPiaExists()
         /// <summary>
         /// When calling AxImp.exe directly, the runtime-callable wrapper needs to be
         /// passed via the /rcw switch, so RCR needs to make sure that the ax reference knows about
-        /// its corresponding TLB wrapper. 
+        /// its corresponding TLB wrapper.
         ///
         /// Tests that still works when IncludeVersionInInteropName = true
         /// </summary>
@@ -732,8 +732,8 @@ public void AxReferenceKnowsItsRCWPiaExists_IncludeVersion()
         private enum RcwStyle { GenerateTlb, PreexistingTlb, PreexistingPia };
 
         /// <summary>
-        /// Helper method that will new up an AX and matching TLB reference, and verify that the AX reference 
-        /// sets its RCW appropriately. 
+        /// Helper method that will new up an AX and matching TLB reference, and verify that the AX reference
+        /// sets its RCW appropriately.
         /// </summary>
         private void CheckAxReferenceRCWTlbExists(RcwStyle rcwStyle, bool includeVersionInInteropName)
         {
diff --git a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
index b21f5de108b..eaca84dcc98 100644
--- a/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveNonMSBuildProjectOutput_Tests.cs
@@ -55,7 +55,7 @@ private void TestVerifyReferenceAttributesHelper(string itemSpec, string project
                 expectedMissingAttribute, missingAttr);
 
             Assert.Equal(result, expectedResult);
-            if (result == false)
+            if (!result)
             {
                 Assert.Equal(missingAttr, expectedMissingAttribute);
             }
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index 9aaecf85ef9..a4e0fb53426 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -527,7 +527,7 @@ public void CompiledDllWithType()
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
                 t.XmlContent = _xmlDocument;
-                xslCompiledPath.ItemSpec = xslCompiledPath.ItemSpec + ";xslt";
+                xslCompiledPath.ItemSpec += ";xslt";
                 t.XslCompiledDllPath = xslCompiledPath;
                 Assert.Equal(xslCompiledPath.ItemSpec, t.XslCompiledDllPath.ItemSpec);
                 Assert.True(t.Execute()); // "XsltComiledDll1 execution should've passed"
@@ -648,7 +648,7 @@ public void MissingXmlFile()
                 XslTransformation t = new XslTransformation();
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
-                xmlPaths[0].ItemSpec = xmlPaths[0].ItemSpec + "bad";
+                xmlPaths[0].ItemSpec += "bad";
                 t.XmlInputPaths = xmlPaths;
                 t.XslInputPath = xslPath;
                 Console.WriteLine(engine.Log);
@@ -678,7 +678,7 @@ public void MissingXsltFile()
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
                 t.XmlInputPaths = xmlPaths;
-                xslPath.ItemSpec = xslPath.ItemSpec + "bad";
+                xslPath.ItemSpec += "bad";
                 t.XslInputPath = xslPath;
                 Assert.False(t.Execute()); // "This test should've failed (bad xslt)."
                 Console.WriteLine(engine.Log);
@@ -707,7 +707,7 @@ public void MissingCompiledDllFile()
                 t.BuildEngine = engine;
                 t.OutputPaths = outputPaths;
                 t.XmlContent = _xmlDocument;
-                xslCompiledPath.ItemSpec = xslCompiledPath.ItemSpec + "bad;xslt";
+                xslCompiledPath.ItemSpec += "bad;xslt";
                 t.XslCompiledDllPath = xslCompiledPath;
                 Assert.False(t.Execute()); // "XsltComiledDllBad execution should've failed"
                 Console.WriteLine(engine.Log);
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index ce4f0954256..88df2dd738b 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -95,7 +95,7 @@ internal void Read(XmlReader reader)
         /// <returns></returns>
         internal static bool StringEquals(string a, string b)
         {
-            return String.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;
+            return String.Equals(a, b, StringComparison.OrdinalIgnoreCase);
         }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index f301ab38e41..ab6b685ba91 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -187,6 +187,7 @@ private void LazyInitialize()
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assemblyname of the reference.</param>
+        /// <param name="sdkName">The sdkname of the reference.</param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
index 992cd1ba6fd..dced5e5453e 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
@@ -18,6 +18,8 @@ internal class AssemblyFoldersResolver : Resolver
         /// <param name="searchPathElement"></param>
         /// <param name="getAssemblyName"></param>
         /// <param name="fileExists"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVesion"></param>
         public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
@@ -27,6 +29,7 @@ public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAsse
         /// Resolve a reference to a specific file name.
         /// </summary>
         /// <param name="assemblyName">The assemblyname of the reference.</param>
+        /// <param name="sdkName">The sdk name of the reference.</param>
         /// <param name="rawFileNameCandidate">The reference's 'include' treated as a raw file name.</param>
         /// <param name="isPrimaryProjectReference">Whether or not this reference was directly from the project file (and therefore not a dependency)</param>
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 5acebabb7eb..b7c394ebe42 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -558,7 +558,7 @@ internal static string GetRuntimeVersion(string path)
                 {
                     runtimeVersion = new StringBuilder(bufferLength);
                     hresult = NativeMethods.GetFileVersion(path, runtimeVersion, bufferLength, out _);
-                    bufferLength = bufferLength * 2;
+                    bufferLength *= 2;
                 } while (hresult == NativeMethodsShared.ERROR_INSUFFICIENT_BUFFER);
 
                 if (hresult == NativeMethodsShared.S_OK)
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolution.cs b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
index e9cc3fafc42..f2fe396824f 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolution.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
@@ -99,6 +99,7 @@ out userRequestedSpecificFile
             return null;
         }
 
+#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Compile search paths into an array of resolvers.
         /// </summary>
@@ -118,6 +119,24 @@ out userRequestedSpecificFile
         /// <param name="getAssemblyPathInGac"></param>
         /// <param name="log"></param>
         /// <returns></returns>
+#else
+        /// <summary>
+        /// Compile search paths into an array of resolvers.
+        /// </summary>
+        /// <param name="buildEngine"></param>
+        /// <param name="searchPaths"></param>
+        /// <param name="candidateAssemblyFiles">Paths to assembly files mentioned in the project.</param>
+        /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
+        /// <param name="frameworkPaths">Paths to FX folders.</param>
+        /// <param name="fileExists"></param>
+        /// <param name="getAssemblyName"></param>
+        /// <param name="installedAssemblies"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVersion"></param>
+        /// <param name="getAssemblyPathInGac"></param>
+        /// <param name="log"></param>
+        /// <returns></returns>
+#endif
         public static Resolver[] CompileSearchPaths
         (
             IBuildEngine buildEngine,
@@ -147,29 +166,29 @@ TaskLoggingHelper log
 
                 // Was {HintPathFromItem} specified? If so, take the Item's
                 // HintPath property.
-                if (0 == String.Compare(basePath, AssemblyResolutionConstants.hintPathSentinel, StringComparison.OrdinalIgnoreCase))
+                if (String.Equals(basePath, AssemblyResolutionConstants.hintPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new HintPathResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.frameworkPathSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.frameworkPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new FrameworkPathResolver(frameworkPaths, installedAssemblies, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.rawFileNameSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.rawFileNameSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new RawFilenameResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.candidateAssemblyFilesSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.candidateAssemblyFilesSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new CandidateAssemblyFilesResolver(candidateAssemblyFiles, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
 #if FEATURE_GAC
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new GacResolver(targetProcessorArchitecture, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, getAssemblyPathInGac);
                 }
 #endif
-                else if (0 == String.Compare(basePath, AssemblyResolutionConstants.assemblyFoldersSentinel, StringComparison.OrdinalIgnoreCase))
+                else if (String.Equals(basePath, AssemblyResolutionConstants.assemblyFoldersSentinel, StringComparison.OrdinalIgnoreCase))
                 {
                     resolvers[p] = new AssemblyFoldersResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
                 }
diff --git a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
index 066901110f3..eb126f0656a 100644
--- a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
+++ b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
@@ -26,6 +26,8 @@ internal class CandidateAssemblyFilesResolver : Resolver
         /// <param name="searchPathElement"></param>
         /// <param name="getAssemblyName"></param>
         /// <param name="fileExists"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVesion"></param>
         public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
             : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index 88473de9a22..5f0cdbf64e0 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -36,7 +36,7 @@ internal enum CopyLocalState
         NoBecausePrerequisite,
 
         /// <summary>
-        /// The Reference should be CopyLocal='false' because the Private attribute is set to 'false' in the project. 
+        /// The Reference should be CopyLocal='false' because the Private attribute is set to 'false' in the project.
         /// </summary>
         NoBecauseReferenceItemHadMetadata,
 
diff --git a/src/Tasks/AssemblyDependency/GacResolver.cs b/src/Tasks/AssemblyDependency/GacResolver.cs
index a8b77e6a55a..16342d58a31 100644
--- a/src/Tasks/AssemblyDependency/GacResolver.cs
+++ b/src/Tasks/AssemblyDependency/GacResolver.cs
@@ -43,7 +43,7 @@ public GacResolver(System.Reflection.ProcessorArchitecture targetProcessorArchit
         /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
         /// <param name="executableExtensions">Allowed executable extensions.</param>
         /// <param name="hintPath">The item's hintpath value.</param>
-        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the <AssemblyFolderKey> on the reference in the project.</param>
+        /// <param name="assemblyFolderKey">Like "hklm\Vendor RegKey" as provided to a reference by the &lt;AssemblyFolderKey&gt; on the reference in the project.</param>
         /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
         /// <param name="foundPath">The path where the file was found.</param>
         /// <param name="userRequestedSpecificFile">Whether or not the user wanted a specific file (for example, HintPath is a request for a specific file)</param>
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 37d3e19e4c7..96b53b98a28 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -146,7 +146,7 @@ public override bool Execute()
         /// </summary>
         private static bool IsMatch(AssemblyName suggestedRedirect, string name, string culture, string publicKeyToken)
         {
-            if (String.Compare(suggestedRedirect.Name, name, StringComparison.OrdinalIgnoreCase) != 0)
+            if (!String.Equals(suggestedRedirect.Name, name, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
@@ -166,7 +166,7 @@ private static bool IsMatch(AssemblyName suggestedRedirect, string name, string
             }
 
             if (!String.IsNullOrEmpty(culture) &&
-                String.Compare(cultureString, culture, StringComparison.OrdinalIgnoreCase) != 0)
+                !String.Equals(cultureString, culture, StringComparison.OrdinalIgnoreCase))
             {
                 return false;
             }
@@ -179,7 +179,7 @@ private static bool IsMatch(AssemblyName suggestedRedirect, string name, string
         /// </summary>
         private static bool ByteArrayMatchesString(Byte[] a, string s)
         {
-            return String.Compare(ResolveAssemblyReference.ByteArrayToString(a), s, StringComparison.OrdinalIgnoreCase) != 0;
+            return !String.Equals(ResolveAssemblyReference.ByteArrayToString(a), s, StringComparison.OrdinalIgnoreCase);
         }
 
         /// <summary>
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index bd27d48ab41..24e3b06dade 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -34,6 +34,12 @@ internal static class GlobalAssemblyCache
         /// </summary>
         /// <param name="assemblyName">The assembly name.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
+        /// <param name="getRuntimeVersion">Delegate to get the clr version of the file.</param>
+        /// <param name="targetedRuntime">Version of the targetted runtime.</param>
+        /// <param name="fileExists">Delegate to check whether the file exists.</param>
+        /// <param name="getPathFromFusionName">Delegate to get path to a file based on the fusion name.</param>
+        /// <param name="getGacEnumerator">Delegate to get the enumerator which will enumerate over the GAC.</param>
+        /// <param name="specificVersion">Whether to check for a specific version.</param>
         /// <returns>The path to the assembly. Empty if none exists.</returns>
         private static string GetLocationImpl(AssemblyNameExtension assemblyName, string targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntime, FileExists fileExists, GetPathFromFusionName getPathFromFusionName, GetGacEnumerator getGacEnumerator, bool specificVersion)
         {
@@ -211,7 +217,11 @@ private static string CheckForFullFusionNameInGac(AssemblyNameExtension assembly
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
         /// <param name="getRuntimeVersion">Delegate to get the runtime version from a file path</param>
         /// <param name="targetedRuntimeVersion">What version of the runtime are we targeting</param>
-        /// <param name="fullFusionName">Are we guranteed to have a full fusion name. This really can only happen if we have already resolved the assembly</param>
+        /// <param name="fullFusionName">Are we guaranteed to have a full fusion name. This really can only happen if we have already resolved the assembly</param>
+        /// <param name="fileExists">Delegate to check whether the file exists.</param>
+        /// <param name="getPathFromFusionName">Delegate to get path to a file based on the fusion name.</param>
+        /// <param name="getGacEnumerator">Delegate to get the enumerator which will enumerate over the GAC.</param>
+        /// <param name="specificVersion">Whether to check for a specific version.</param>
         /// <returns>The path to the assembly. Empty if none exists.</returns>
         internal static string GetLocation
         (
@@ -232,11 +242,16 @@ bool specificVersion
         /// <summary>
         /// Given a strong name, find its path in the GAC.
         /// </summary>
+        /// <param name="buildEngine">The build engine</param>
         /// <param name="strongName">The strong name.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64.</param>
         /// <param name="getRuntimeVersion">Delegate to get the runtime version from a file path</param>
         /// <param name="targetedRuntimeVersion">What version of the runtime are we targeting</param>
         /// <param name="fullFusionName">Are we guranteed to have a full fusion name. This really can only happen if we have already resolved the assembly</param>
+        /// <param name="fileExists">Delegate to check whether the file exists.</param>
+        /// <param name="getPathFromFusionName">Delegate to get path to a file based on the fusion name.</param>
+        /// <param name="getGacEnumerator">Delegate to get the enumerator which will enumerate over the GAC.</param>
+        /// <param name="specificVersion">Whether to check for a specific version.</param>
         /// <returns>The path to the assembly. Empty if none exists.</returns>
         internal static string GetLocation
         (
@@ -284,10 +299,10 @@ bool specificVersion
             }
 
             // A delegate was not passed in to use the default one
-            getPathFromFusionName = getPathFromFusionName ?? pathFromFusionName;
+            getPathFromFusionName ??= pathFromFusionName;
 
             // A delegate was not passed in to use the default one
-            getGacEnumerator = getGacEnumerator ?? gacEnumerator;
+            getGacEnumerator ??= gacEnumerator;
 
             // If we have no processor architecture set then we can tryout a number of processor architectures.
             string location;
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 1624b4f2143..1561d3eee24 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -145,9 +145,9 @@ internal sealed class ReferenceTable
         private readonly ConcurrentDictionary<string, AssemblyMetadata> _assemblyMetadataCache;
 
         /// <summary>
-        /// When we exclude an assembly from resolution because it is part of out exclusion list we need to let the user know why this is. 
-        /// There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different black list. We need to log a specific message 
-        /// depending on which black list we have found the offending assembly in. This delegate allows one to tie a set of logging messages to a black list so that when we 
+        /// When we exclude an assembly from resolution because it is part of out exclusion list we need to let the user know why this is.
+        /// There can be a number of reasons each for un-resolving a reference, these reasons are encapsulated by a different black list. We need to log a specific message
+        /// depending on which black list we have found the offending assembly in. This delegate allows one to tie a set of logging messages to a black list so that when we
         /// discover an assembly in the black list we can log the correct message.
         /// </summary>
         internal delegate void LogExclusionReason(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
@@ -158,6 +158,7 @@ internal sealed class ReferenceTable
         // PEHeader
         private const int PEHEADER = 0x00004550;
 
+#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Construct.
         /// </summary>
@@ -180,10 +181,10 @@ internal sealed class ReferenceTable
         /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
         /// <param name="getRegistrySubKeyNames">Used to get registry subkey names.</param>
         /// <param name="getRegistrySubKeyDefaultValue">Used to get registry default values.</param>
+        /// <param name="openBaseKey"></param>
         /// <param name="unresolveFrameworkAssembliesFromHigherFrameworks"></param>
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
         /// <param name="allowedAssemblyExtensions"></param>
-        /// <param name="openBaseKey"></param>
         /// <param name="getRuntimeVersion"></param>
         /// <param name="targetedRuntimeVersion"></param>
         /// <param name="projectTargetFramework"></param>
@@ -198,6 +199,45 @@ internal sealed class ReferenceTable
         /// <param name="readMachineTypeFromPEHeader"></param>
         /// <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
         /// <param name="ignoreFrameworkAttributeVersionMismatch"></param>
+#else
+        /// <summary>
+        /// Construct.
+        /// </summary>
+        /// <param name="buildEngine"></param>
+        /// <param name="findDependencies">If true, then search for dependencies.</param>
+        /// <param name="findSatellites">If true, then search for satellite files.</param>
+        /// <param name="findSerializationAssemblies">If true, then search for serialization assembly files.</param>
+        /// <param name="findRelatedFiles">If true, then search for related files.</param>
+        /// <param name="searchPaths">Paths to search for dependent assemblies on.</param>
+        /// <param name="relatedFileExtensions"></param>
+        /// <param name="candidateAssemblyFiles">List of literal assembly file names to be considered when SearchPaths has {CandidateAssemblyFiles}.</param>
+        /// <param name="resolvedSDKItems">Resolved sdk items</param>
+        /// <param name="frameworkPaths">Path to the FX.</param>
+        /// <param name="installedAssemblies">Installed assembly XML tables.</param>
+        /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
+        /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
+        /// <param name="directoryExists">Delegate used for files.</param>
+        /// <param name="getDirectories">Delegate used for getting directories.</param>
+        /// <param name="getAssemblyName">Delegate used for getting assembly names.</param>
+        /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
+        /// <param name="unresolveFrameworkAssembliesFromHigherFrameworks"></param>
+        /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
+        /// <param name="allowedAssemblyExtensions"></param>
+        /// <param name="getRuntimeVersion"></param>
+        /// <param name="targetedRuntimeVersion"></param>
+        /// <param name="projectTargetFramework"></param>
+        /// <param name="targetFrameworkMoniker"></param>
+        /// <param name="log"></param>
+        /// <param name="latestTargetFrameworkDirectories"></param>
+        /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
+        /// <param name="doNotCopyLocalIfInGac"></param>
+        /// <param name="getAssemblyPathInGac"></param>
+        /// <param name="isWinMDFile"></param>
+        /// <param name="ignoreVersionForFrameworkReferences"></param>
+        /// <param name="readMachineTypeFromPEHeader"></param>
+        /// <param name="warnOrErrorOnTargetArchitectureMismatch"></param>
+        /// <param name="ignoreFrameworkAttributeVersionMismatch"></param>
+#endif
         internal ReferenceTable
         (
             IBuildEngine buildEngine,
@@ -1046,7 +1086,7 @@ out FrameworkName frameworkName
         }
 
         /// <summary>
-        /// Given an enumerator of pre-unified assembly names, return an enumerator of unified 
+        /// Given an enumerator of pre-unified assembly names, return an enumerator of unified
         /// assembly names.
         /// </summary>
         private IEnumerable<UnifiedAssemblyName> GetUnifiedAssemblyNames
@@ -1193,10 +1233,10 @@ private static bool IsPseudoAssembly(string name)
         }
 
         /// <summary>
-        /// Based on the set of parent assemblies we want to add their directories to the list of resolvers so that 
+        /// Based on the set of parent assemblies we want to add their directories to the list of resolvers so that
         /// if the dependency is sitting beside the assembly which requires it then we will resolve the assembly from that location first.
-        /// 
-        /// The only time we do not want to do this is if the parent assembly came from the GAC or AssemblyFoldersEx then we want the assembly 
+        ///
+        /// The only time we do not want to do this is if the parent assembly came from the GAC or AssemblyFoldersEx then we want the assembly
         /// to be found using those resolvers so that our GAC and AssemblyFolders checks later on will work on those assemblies.
         /// </summary>
         internal static void CalculateParentAssemblyDirectories(List<string> parentReferenceFolders, Reference parentReference)
@@ -1224,7 +1264,7 @@ internal static void CalculateParentAssemblyDirectories(List<string> parentRefer
         }
 
         /// <summary>
-        /// Given an unresolved reference (one that we don't know the full name for yet), figure out the 
+        /// Given an unresolved reference (one that we don't know the full name for yet), figure out the
         /// full name. Should only be called on references that haven't been resolved yet--otherwise, its
         /// a perf problem.
         /// </summary>
@@ -1431,7 +1471,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
 
         /// <summary>
         /// References usually only contains who they depend on, they do not know who depends on them. Given a reference
-        /// A we cannot inspect A to find out that B,C,D depend on it. This method will traverse the references and build up this other direction of the graph, 
+        /// A we cannot inspect A to find out that B,C,D depend on it. This method will traverse the references and build up this other direction of the graph,
         /// therefore we will be able to know given reference A, that B,C,D depend on it.
         /// </summary>
         private static void AddToDependencyGraph(Dictionary<Reference, List<ReferenceAssemblyExtensionPair>> dependencyGraph, AssemblyNameExtension assemblyName, Reference assemblyReference)
@@ -1532,7 +1572,7 @@ internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec)
         }
 
         /// <summary>
-        /// Go through the dependency graph and make sure that for a reference to remove that we get rid of all dependency assemblies which are not referenced by any other 
+        /// Go through the dependency graph and make sure that for a reference to remove that we get rid of all dependency assemblies which are not referenced by any other
         /// assembly. The remove reference list should contain ALL primary references which should be removed because they, or one of their dependencies is in the black list.
         /// </summary>
         /// <param name="removedReference">Reference to remove dependencies for</param>
@@ -1577,7 +1617,7 @@ private static void RemoveDependencies(Reference removedReference, Dictionary<As
         /// Searches the table for references that haven't been resolved to their full file names and
         /// for dependencies that haven't yet been found.
         ///
-        /// If any are found, they're resolved and then dependencies are found. Then the process is repeated 
+        /// If any are found, they're resolved and then dependencies are found. Then the process is repeated
         /// until nothing is left unresolved.
         /// </summary>
         /// <param name="remappedAssembliesValue">The table of remapped assemblies.</param>
@@ -1770,7 +1810,7 @@ private void ResolveAssemblyFilenames()
         }
 
         /// <summary>
-        /// This methods looks for conflicts between assemblies and attempts to 
+        /// This methods looks for conflicts between assemblies and attempts to
         /// resolve them.
         /// </summary>
         private void ResolveConflictsBetweenReferences(Dictionary<string, List<AssemblyNameReference>> baseNameToReferences)
@@ -1809,7 +1849,7 @@ private void ResolveConflictsBetweenReferences(List<AssemblyNameReference> assem
         }
 
         /// <summary>
-        /// Based on the closure, get a table of ideal remappings needed to 
+        /// Based on the closure, get a table of ideal remappings needed to
         /// produce zero conflicts.
         /// </summary>
         internal void ResolveConflicts
@@ -1920,8 +1960,8 @@ out List<AssemblyNameReference> conflictingReferences
         }
 
         /// <summary>
-        /// If a reference is a higher version than what exists in the redist list of the target framework then 
-        /// this reference needs to be marked as excluded so that it is not allowed to be referenced. 
+        /// If a reference is a higher version than what exists in the redist list of the target framework then
+        /// this reference needs to be marked as excluded so that it is not allowed to be referenced.
         /// 
         /// If the user needs this reference then they need to set specific version to true.
         /// </summary>
@@ -1978,12 +2018,12 @@ private bool InLatestRedistList(AssemblyNameExtension assemblyName)
 
         /// <summary>
         /// Get the redist list which corresponds to the highest target framework for a given target framework moniker.
-        /// 
+        ///
         /// This is done in two ways:
         ///  First, if the latestTargetFrameworkDirectories parameter is passed into RAR those directories will be used to get the redist list
-        ///  regardless of the target framework moniker. 
-        ///  
-        /// Second, if latest Target Framework Directories is not passed in then we ask the ToollocationHelper for the highest target framework which has 
+        ///  regardless of the target framework moniker.
+        ///
+        /// Second, if latest Target Framework Directories is not passed in then we ask the ToollocationHelper for the highest target framework which has
         /// a TargetFrameworkIdentifier which matches the passed in TargetFrameworkMoniker.
         /// </summary>
         private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(FrameworkNameVersioning targetFrameworkMoniker)
@@ -2047,7 +2087,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
         }
 
         /// <summary>
-        /// Based on a target framework moniker, get the set of reference assembly directories which 
+        /// Based on a target framework moniker, get the set of reference assembly directories which
         /// correspond to the highest version of the target framework identifier property on the target framework moniker.
         /// </summary>
         private static IList<string> GetHighestVersionReferenceAssemblyDirectories(FrameworkNameVersioning targetFrameworkMoniker, out FrameworkNameVersioning highestVersionMoniker)
@@ -2066,7 +2106,7 @@ private static IList<string> GetHighestVersionReferenceAssemblyDirectories(Frame
             }
             return referenceAssemblyDirectories;
         }
-        
+
         /// <summary>
         /// Is the assemblyName in the current redist list and does it have a version number which is higher than what is in the current redist list.
         /// This may happen if someone passes in a p2p reference whcih is a framework assembly which is a higher version than what is in the redist list.
@@ -2147,7 +2187,7 @@ internal bool MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(
 
             return haveMarkedReference;
         }
-        
+
         /// <summary>
         /// Build a table of simple names mapped to assemblyname+reference.
         /// </summary>
@@ -2294,7 +2334,7 @@ out _
                     }
                 }
             }
-            
+
             // Remove the one chosen.
             int victor = 1 - victim;
 
@@ -2335,12 +2375,14 @@ private static bool IsAssemblyRemovedFromDotNetFramework(AssemblyNameExtension a
         }
 
         /// <summary>
-        /// Get unification information for the given assembly name. 
+        /// Get unification information for the given assembly name.
         /// </summary>
         /// <param name="assemblyName">The assembly name.</param>
         /// <param name="unifiedVersion">The new version of the assembly to use.</param>
         /// <param name="unificationReason">The reason this reference was unified.</param>
         /// <param name="isPrerequisite">True if this is a prereq assembly.</param>
+        /// <param name="isRedistRoot">May be true, false or null. Null means there was no IsRedistRoot in the redist list.</param>
+        /// <param name="redistName">Name of the corresponding Resist specified in the redist list.</param>
         /// <returns>True if there was a unification.</returns>
         private bool UnifyAssemblyNameVersions
         (
@@ -2451,6 +2493,8 @@ private bool CompareAssembliesIgnoringVersion(AssemblyName a, AssemblyName b)
         /// <param name="dependencyFiles">Dependent references fully resolved.</param>
         /// <param name="relatedFiles">Related files like .xmls and .pdbs.</param>
         /// <param name="satelliteFiles">Satellite files.</param>
+        /// <param name="serializationAssemblyFiles">Serialization assembly files.</param>
+        /// <param name="scatterFiles">Receives the list of associated scatter files.</param>
         /// <param name="copyLocalFiles">All copy-local files out of primaryFiles+dependencyFiles+relatedFiles+satelliteFiles.</param>
         internal void GetReferenceItems
         (
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 8afc2003518..39698c45681 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -29,12 +29,12 @@ namespace Microsoft.Build.Tasks
     public class ResolveAssemblyReference : TaskExtension
     {
         /// <summary>
-        /// key assembly used to trigger inclusion of facade references. 
+        /// key assembly used to trigger inclusion of facade references.
         /// </summary>
         private const string SystemRuntimeAssemblyName = "System.Runtime";
 
         /// <summary>
-        /// additional key assembly used to trigger inclusion of facade references. 
+        /// additional key assembly used to trigger inclusion of facade references.
         /// </summary>
         private const string NETStandardAssemblyName = "netstandard";
 
@@ -127,11 +127,11 @@ public bool UnresolveFrameworkAssembliesFromHigherFrameworks
 
         /// <summary>
         /// If there is a mismatch between the targetprocessor architecture and the architecture of a primary reference.
-        /// 
-        /// When this is error,  an error will be logged. 
-        /// 
+        ///
+        /// When this is error,  an error will be logged.
+        ///
         /// When this is warn, if there is a mismatch between the targetprocessor architecture and the architecture of a primary reference a warning will be logged.
-        /// 
+        ///
         /// When this is none, no error or warning will be logged.
         /// </summary>
         public string WarnOrErrorOnTargetArchitectureMismatch
@@ -154,12 +154,12 @@ public string WarnOrErrorOnTargetArchitectureMismatch
         ///
         /// Optional attributes are:
         ///     bool Private [default=true] -- means 'CopyLocal'
-        ///     string FusionName -- the simple or strong fusion name for this item. If this 
+        ///     string FusionName -- the simple or strong fusion name for this item. If this
         ///         attribute is present it can save time since the assembly file won't need
         ///         to be opened to get the fusion name.
         ///     bool ExternallyResolved [default=false] -- indicates that the reference and its
         ///        dependencies are resolved by an external system (commonly from nuget assets) and
-        ///        so several steps can be skipped as an optimization: finding dependencies, 
+        ///        so several steps can be skipped as an optimization: finding dependencies,
         ///        satellite assemblies, etc.
         /// </summary>
         public ITaskItem[] AssemblyFiles
@@ -169,9 +169,9 @@ public ITaskItem[] AssemblyFiles
         }
 
         /// <summary>
-        /// The list of directories which contain the redist lists for the most current 
+        /// The list of directories which contain the redist lists for the most current
         /// framework which can be targeted on the machine. If this is not set
-        /// Then we will looks for the highest framework installed on the machine 
+        /// Then we will looks for the highest framework installed on the machine
         /// for a given target framework identifier and use that.
         /// </summary>
         public string[] LatestTargetFrameworkDirectories
@@ -239,26 +239,26 @@ public string[] TargetFrameworkSubsets
         ///
         /// Optional attributes are:
         ///     bool Private [default=true] -- means 'CopyLocal'
-        ///     string HintPath [default=''] -- location of file name to consider as a reference, 
+        ///     string HintPath [default=''] -- location of file name to consider as a reference,
         ///         used when {HintPathFromItem} is one of the paths in SearchPaths.
-        ///     bool SpecificVersion [default=absent] -- 
-        ///         when true, the exact fusionname in the Include must be matched. 
+        ///     bool SpecificVersion [default=absent] --
+        ///         when true, the exact fusionname in the Include must be matched.
         ///         when false, any assembly with the same simple name will be a match.
-        ///         when absent, then look at the value in Include. 
+        ///         when absent, then look at the value in Include.
         ///           If its a simple name then behave as if specific version=false.
         ///           If its a strong name then behave as if specific version=true.
-        ///     string ExecutableExtension [default=absent] -- 
+        ///     string ExecutableExtension [default=absent] --
         ///         when present, the resolved assembly must have this extension.
         ///         when absent, .dll is considered and then .exe for each directory looked at.
-        ///     string SubType -- only items with empty SubTypes will be considered. Items 
+        ///     string SubType -- only items with empty SubTypes will be considered. Items
         ///         with non-empty subtypes will be ignored.
-        ///     string AssemblyFolderKey [default=absent] -- supported for legacy AssemblyFolder 
+        ///     string AssemblyFolderKey [default=absent] -- supported for legacy AssemblyFolder
         ///         resolution. This key can have a value like 'hklm\vendor folder'. When set, only
         ///         this particular assembly folder key will be used.
         ///            This is to support the scenario in VSWhidey#357946 in which there are multiple
         ///            side-by-side libraries installed and the user wants to pick an exact version.
-        ///     bool EmbedInteropTyeps [default=absent] -- 
-        ///         when true, we should treat this assembly as if it has no dependencies and should 
+        ///     bool EmbedInteropTyeps [default=absent] --
+        ///         when true, we should treat this assembly as if it has no dependencies and should
         ///         be completely embedded into the target assembly.
         /// </summary>
         public ITaskItem[] Assemblies
@@ -291,9 +291,9 @@ public ITaskItem[] ResolvedSDKReferences
         }
 
         /// <summary>
-        /// Path to the target frameworks directory. Required to figure out CopyLocal status 
+        /// Path to the target frameworks directory. Required to figure out CopyLocal status
         /// for resulting items.
-        /// If not present, then no resulting items will be deemed CopyLocal='true' unless they explicity 
+        /// If not present, then no resulting items will be deemed CopyLocal='true' unless they explicity
         /// have a Private='true' attribute on their source item.
         /// </summary>
         public string[] TargetFrameworkDirectories
@@ -304,14 +304,14 @@ public string[] TargetFrameworkDirectories
 
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be installed on the target machine.
-        /// 
+        ///
         /// Format of the file is like:
-        /// 
+        ///
         ///     <FileList Redist="Microsoft-Windows-CLRCoreComp" >
         ///         <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
         ///         etc.
         ///     </FileList>
-        /// 
+        ///
         /// When present, assemblies from this list will be candidates to automatically "unify" from prior versions up to
         /// the version listed in the XML. Also, assemblies with InGAC='true' will be considered prerequisites and will be CopyLocal='false'
         /// unless explicitly overridden.
@@ -330,16 +330,16 @@ public ITaskItem[] InstalledAssemblyTables
 
         /// <summary>
         /// A list of XML files that contain assemblies that are expected to be in the target subset
-        /// 
+        ///
         /// Format of the file is like:
-        /// 
+        ///
         ///     <FileList Redist="ClientSubset" >
         ///         <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
         ///         etc.
         ///     </FileList>
-        /// 
+        ///
         /// Items in this list may optionally specify the "FrameworkDirectory" metadata to associate an InstalledAssemblySubsetTable
-        /// with a particular framework directory. 
+        /// with a particular framework directory.
         /// If there is only a single TargetFrameworkDirectories element, then any items in this list missing the
         /// "FrameworkDirectory" metadata will be treated as though this metadata is set to the lone (unique) value passed
         /// to TargetFrameworkDirectories.
@@ -356,19 +356,19 @@ public ITaskItem[] InstalledAssemblySubsetTables
 
         /// <summary>
         /// A list of XML files that contain the full framework for the profile.
-        /// 
-        /// Normally nothing is passed in here, this is for the cases where the location of the xml file for the full framework 
+        ///
+        /// Normally nothing is passed in here, this is for the cases where the location of the xml file for the full framework
         /// is not under a RedistList folder.
-        /// 
+        ///
         /// Format of the file is like:
-        /// 
+        ///
         ///     <FileList Redist="MatchingRedistListName" >
         ///         <File AssemblyName="System" Version="2.0.0.0" PublicKeyToken="b77a5c561934e089" Culture="neutral" ProcessorArchitecture="MSIL" FileVersion="2.0.40824.0" InGAC="true" />
         ///         etc.
         ///     </FileList>
-        /// 
+        ///
         /// Items in this list must specify the "FrameworkDirectory" metadata to associate an redist list
-        /// with a particular framework directory. If the association is not made an error will be logged. The reason is, 
+        /// with a particular framework directory. If the association is not made an error will be logged. The reason is,
         /// The logic in rar assumes if a FrameworkDirectory is not set it will use the target framework directory.
         /// </summary>
         public ITaskItem[] FullFrameworkAssemblyTables
@@ -383,7 +383,7 @@ public ITaskItem[] FullFrameworkAssemblyTables
 
         /// <summary>
         /// [default=false]
-        /// Boolean property to control whether or not the task should look for and use additional installed 
+        /// Boolean property to control whether or not the task should look for and use additional installed
         /// assembly tables (a.k.a Redist Lists) found in the RedistList directory underneath the provided
         /// TargetFrameworkDirectories.
         /// </summary>
@@ -395,7 +395,7 @@ public bool IgnoreDefaultInstalledAssemblyTables
 
         /// <summary>
         /// [default=false]
-        /// Boolean property to control whether or not the task should look for and use additional installed 
+        /// Boolean property to control whether or not the task should look for and use additional installed
         /// assembly subset tables (a.k.a Subset Lists) found in the SubsetList directory underneath the provided
         /// TargetFrameworkDirectories.
         /// </summary>
@@ -415,14 +415,14 @@ public bool IgnoreVersionForFrameworkReferences
         }
 
         /// <summary>
-        /// The preferred target processor architecture. Used for resolving {GAC} references. 
+        /// The preferred target processor architecture. Used for resolving {GAC} references.
         /// Should be like x86, IA64 or AMD64.
-        /// 
+        ///
         /// This is the order of preference:
         /// (1) Assemblies in the GAC that match the supplied ProcessorArchitecture.
         /// (2) Assemblies in the GAC that have ProcessorArchitecture=MSIL
         /// (3) Assemblies in the GAC that have no ProcessorArchitecture.
-        /// 
+        ///
         /// If absent, then only consider assemblies in the GAC that have ProcessorArchitecture==MSIL or
         /// no ProcessorArchitecture (these are pre-Whidbey assemblies).
         /// </summary>
@@ -562,21 +562,21 @@ public bool AutoUnify
         }
 
         /// <summary>
-        ///  When determining if a dependency should be copied locally one of the checks done is to see if the 
-        ///  parent reference in the project file has the Private metadata set or not. If that metadata is set then 
-        ///  We will use that for the dependency as well. 
-        ///  
-        /// However, if the metadata is not set then the dependency will go through the same checks as the parent reference. 
+        ///  When determining if a dependency should be copied locally one of the checks done is to see if the
+        ///  parent reference in the project file has the Private metadata set or not. If that metadata is set then
+        ///  We will use that for the dependency as well.
+        ///
+        /// However, if the metadata is not set then the dependency will go through the same checks as the parent reference.
         /// One of these checks is to see if the reference is in the GAC. If a reference is in the GAC then we will not copy it locally
         /// as it is assumed it will be in the gac on the target machine as well. However this only applies to that specific reference and not its dependencies.
-        /// 
+        ///
         /// This means a reference in the project file may be copy local false due to it being in the GAC but the dependencies may still be copied locally because they are not in the GAC.
         /// This is the default behavior for RAR and causes the default value for this property to be true.
-        /// 
-        /// When this property is false we will still check project file references to see if they are in the GAC and set their copy local state as appropriate. 
-        /// However for dependencies we will not only check to see if they are in the GAC but we will also check to see if the parent reference from the project file is in the GAC. 
+        ///
+        /// When this property is false we will still check project file references to see if they are in the GAC and set their copy local state as appropriate.
+        /// However for dependencies we will not only check to see if they are in the GAC but we will also check to see if the parent reference from the project file is in the GAC.
         /// If the parent reference from the project file is in the GAC then we will not copy the dependency locally.
-        /// 
+        ///
         /// NOTE: If there are multiple parent reference and ANY of them does not come from the GAC then we will set copy local to true.
         /// </summary>
         public bool CopyLocalDependenciesWhenParentReferenceInGac
@@ -702,9 +702,9 @@ public string TargetFrameworkMonikerDisplayName
         }
 
         /// <summary>
-        /// Provide a set of names which if seen in the TargetFrameworkSubset list will cause the ignoring 
+        /// Provide a set of names which if seen in the TargetFrameworkSubset list will cause the ignoring
         /// of TargetFrameworkSubsets.
-        /// 
+        ///
         /// Full, Complete
         /// </summary>
         public string[] FullTargetFrameworkSubsetNames
@@ -741,7 +741,7 @@ public string ProfileName
 
         /// <summary>
         /// Set of folders which containd a RedistList directory which represent the full framework for a given client profile.
-        /// An example would be 
+        /// An example would be
         /// %programfiles%\reference assemblies\microsoft\framework\v4.0
         /// </summary>
         public string[] FullFrameworkFolders
@@ -782,9 +782,9 @@ public ITaskItem[] ResolvedFiles
         ///     string FusionName - the fusion name for this dependency.
         ///     string ResolvedFrom - the literal search path that this file was resolved from.
         ///     bool IsRedistRoot - Whether or not this assembly is the representative for an entire redist.
-        ///         'true' means the assembly is representative of an entire redist and should be indicated as 
+        ///         'true' means the assembly is representative of an entire redist and should be indicated as
         ///         an application dependency in an application manifest.
-        ///         'false' means the assembly is internal to a redist and should not be part of the 
+        ///         'false' means the assembly is internal to a redist and should not be part of the
         ///         application manifest.
         ///     string Redist - The name (if any) of the redist that contains this assembly.
         /// Does not include first order primary references--this list is in ResolvedFiles.
@@ -808,10 +808,10 @@ public ITaskItem[] RelatedFiles
         }
 
         /// <summary>
-        /// Any satellite files found. These will be CopyLocal=true iff the reference or dependency 
+        /// Any satellite files found. These will be CopyLocal=true iff the reference or dependency
         /// that caused this item to exist is CopyLocal=true.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
-        ///     string DestinationSubDirectory - the relative destination directory that this file 
+        ///     string DestinationSubDirectory - the relative destination directory that this file
         ///       should be copied to. This is mainly for satellites.
         /// </summary>
         [Output]
@@ -821,7 +821,7 @@ public ITaskItem[] SatelliteFiles
         }
 
         /// <summary>
-        /// Any XML serialization assemblies found. These will be CopyLocal=true iff the reference or dependency 
+        /// Any XML serialization assemblies found. These will be CopyLocal=true iff the reference or dependency
         /// that caused this item to exist is CopyLocal=true.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
         /// </summary>
@@ -853,9 +853,9 @@ public ITaskItem[] CopyLocalFiles
         }
 
         /// <summary>
-        /// Regardless of the value of AutoUnify, returns one item for every distinct conflicting assembly 
-        /// identity--including culture and PKT--that was found that did not have a suitable bindingRedirect 
-        /// entry in the ApplicationConfigurationFile. 
+        /// Regardless of the value of AutoUnify, returns one item for every distinct conflicting assembly
+        /// identity--including culture and PKT--that was found that did not have a suitable bindingRedirect
+        /// entry in the ApplicationConfigurationFile.
         ///
         /// Each returned ITaskItem will have the following values:
         ///  ItemSpec - the full fusion name of the assembly family with empty version=0.0.0.0
@@ -1417,7 +1417,7 @@ private void LogInputs()
         /// Log a specific item metadata.
         /// </summary>
         /// <param name="item"></param>
-        /// <param name="attribute"></param>
+        /// <param name="metadataName"></param>
         private void LogAttribute(ITaskItem item, string metadataName)
         {
             string metadataValue = item.GetMetadata(metadataName);
@@ -1567,6 +1567,7 @@ private void LogFullName(Reference reference, MessageImportance importance)
         /// show information about them.
         /// </summary>
         /// <param name="reference">The reference.</param>
+        /// <param name="fusionName">The fusion name.</param>
         /// <param name="importance">The importance of the message.</param>
         private void LogAssembliesConsideredAndRejected(Reference reference, string fusionName, MessageImportance importance)
         {
@@ -1881,6 +1882,7 @@ private List<DependentAssembly> GetAssemblyRemappingsFromAppConfig()
         #endregion
         #region ITask Members
 
+#if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Execute the task.
         /// </summary>
@@ -1892,7 +1894,28 @@ private List<DependentAssembly> GetAssemblyRemappingsFromAppConfig()
         /// <param name="getRegistrySubKeyNames">Used to get registry subkey names.</param>
         /// <param name="getRegistrySubKeyDefaultValue">Used to get registry default values.</param>
         /// <param name="getLastWriteTime">Delegate used to get the last write time.</param>
+        /// <param name="getRuntimeVersion">Delegate used to get the runtime version.</param>
+        /// <param name="openBaseKey">Key object to open.</param>
+        /// <param name="getAssemblyPathInGac">Delegate to get assembly path in the GAC.</param>
+        /// <param name="isWinMDFile">Delegate used for checking whether it is a WinMD file.</param>
+        /// <param name="readMachineTypeFromPEHeader">Delegate use to read machine type from PE Header</param>
+        /// <returns>True if there was success.</returns>
+#else
+        /// <summary>
+        /// Execute the task.
+        /// </summary>
+        /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
+        /// <param name="directoryExists">Delegate used for checking for the existence of a directory.</param>
+        /// <param name="getDirectories">Delegate used for finding directories.</param>
+        /// <param name="getAssemblyName">Delegate used for finding fusion names of assemblyFiles.</param>
+        /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
+        /// <param name="getLastWriteTime">Delegate used to get the last write time.</param>
+        /// <param name="getRuntimeVersion">Delegate used to get the runtime version.</param>
+        /// <param name="getAssemblyPathInGac">Delegate to get assembly path in the GAC.</param>
+        /// <param name="isWinMDFile">Delegate used for checking whether it is a WinMD file.</param>
+        /// <param name="readMachineTypeFromPEHeader">Delegate use to read machine type from PE Header</param>
         /// <returns>True if there was success.</returns>
+#endif
         internal bool Execute
         (
             FileExists fileExists,
@@ -2285,7 +2308,7 @@ out _copyLocalFiles
                             {
                                 // if we're finding dependencies and a given reference was not marked as ExternallyResolved
                                 // then its use of System.Runtime/.netstandard would already have been identified above.
-                                continue; 
+                                continue;
                             }
 
                             var rawDependencies = GetDependencies(resolvedReference, fileExists, getAssemblyMetadata, assemblyMetadataCache);
@@ -2488,6 +2511,7 @@ internal static Version SetTargetedRuntimeVersion(string targetedRuntimeVersionR
         /// <param name="installedAssemblyTableInfo">Installed assembly info of the profile redist lists</param>
         /// <param name="fullRedistAssemblyTableInfo">Installed assemblyInfo for the full framework redist lists</param>
         /// <param name="blackList">Generated exclusion list</param>
+        /// <param name="fullFrameworkRedistList">Redist list which will contain the full framework redist list.</param>
         private void HandleProfile(AssemblyTableInfo[] installedAssemblyTableInfo, out AssemblyTableInfo[] fullRedistAssemblyTableInfo, out Dictionary<string, string> blackList, out RedistList fullFrameworkRedistList)
         {
             // Redist list which will contain the full framework redist list.
@@ -2664,9 +2688,9 @@ private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableIn
 
         /// <summary>
         /// Determine if a black list should be used or not
-        /// 
+        ///
         /// The black list should only be used if there are TargetFrameworkSubsets to use or TargetFrameworkProfiles.
-        /// 
+        ///
         /// 1) If we find a Full or equivalent marker in the list of subsets passed in we do not want to generate a black list even if installedAssemblySubsets are passed in
         /// 2) If we are ignoring the default installed subset tables and we have not passed in any additional subset tables, we do not want to generate a black list
         /// 3) If no targetframework subsets were passed in and no additional subset tables were passed in, we do not want to generate a blacklist
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index 06286525f43..be72b128729 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -139,6 +139,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
         /// <param name="assemblyName">The assembly name to look up.</param>
         /// <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
         /// <param name="wantSpecificVersion">Whether the version needs to match exactly or loosely.</param>
+        /// <param name="allowMismatchBetweenFusionNameAndFileName">Whether to allow naming mismatch.</param>
         /// <param name="pathToCandidateAssembly">Path to a possible file.</param>
         /// <param name="searchLocation">Information about why the candidate file didn't match</param>
         protected bool FileMatchesAssemblyName
@@ -160,7 +161,7 @@ ResolutionSearchLocation searchLocation
             if (!allowMismatchBetweenFusionNameAndFileName)
             {
                 string candidateBaseName = Path.GetFileNameWithoutExtension(pathToCandidateAssembly);
-                if (String.Compare(assemblyName?.Name, candidateBaseName, StringComparison.CurrentCultureIgnoreCase) != 0)
+                if (!String.Equals(assemblyName?.Name, candidateBaseName, StringComparison.CurrentCultureIgnoreCase))
                 {
                     if (searchLocation != null)
                     {
@@ -284,6 +285,7 @@ ResolutionSearchLocation searchLocation
         /// </summary>
         /// <param name="assemblyName">The assembly name to look up.</param>
         /// <param name="isPrimaryProjectReference">True if this is a primary reference directly from the project file.</param>
+        /// <param name="wantSpecificVersion">Whether an exact version match is requested.</param>
         /// <param name="executableExtensions">The possible filename extensions of the assembly. Must be one of these or its no match.</param>
         /// <param name="directory">the directory to look in</param>
         /// <param name="assembliesConsideredAndRejected">Receives the list of locations that this function tried to find the assembly. May be "null".</param>
@@ -371,7 +373,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                     {
                         foreach (string executableExtension in executableExtensions)
                         {
-                            if (String.Compare(executableExtension, weakNameBaseExtension, StringComparison.CurrentCultureIgnoreCase) == 0)
+                            if (String.Equals(executableExtension, weakNameBaseExtension, StringComparison.CurrentCultureIgnoreCase))
                             {
                                 string fullPath = Path.Combine(directory, weakNameBase);
                                 var extensionlessAssemblyName = new AssemblyNameExtension(weakNameBaseFileName);
diff --git a/src/Tasks/AxReference.cs b/src/Tasks/AxReference.cs
index 95136153fbc..5cb6271b1fc 100644
--- a/src/Tasks/AxReference.cs
+++ b/src/Tasks/AxReference.cs
@@ -22,6 +22,7 @@ internal class AxReference : AxTlbBaseReference
         /// internal constructor
         /// </summary>
         /// <param name="taskLoggingHelper">task logger instance used for logging</param>
+        /// <param name="silent">true if this task should log only errors, no warnings or messages; false otherwise</param>
         /// <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
         /// <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
         /// <param name="itemName">reference name (for better logging experience)</param>
@@ -29,9 +30,10 @@ internal class AxReference : AxTlbBaseReference
         /// <param name="delaySign">delay sign wrappers?</param>
         /// <param name="keyFile">file containing public/private keys</param>
         /// <param name="keyContainer">container name for public/private keys</param>
-        /// <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using aximp.exe</param>
+        /// <param name="includeTypeLibVersionInName">True if the interop name should include the typelib's version</param>
         /// <param name="sdkToolsPath">Path to the SDK tools directory where aximp.exe can be found</param>
         /// <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
+        /// <param name="environmentVariables">Array of equals-separated pairs of environment variables that should be passed to the spawned executable, in addition to (or selectively overriding) the regular environment block.</param>
         internal AxReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, ComReferenceInfo referenceInfo, string itemName, string outputDirectory,
             bool delaySign, string keyFile, string keyContainer, bool includeTypeLibVersionInName, string sdkToolsPath, IBuildEngine buildEngine, string[] environmentVariables)
             : base(taskLoggingHelper, silent, resolverCallback, referenceInfo, itemName, outputDirectory, delaySign, keyFile, keyContainer, includeTypeLibVersionInName, true /* always execute as tool */, sdkToolsPath, buildEngine, environmentVariables)
diff --git a/src/Tasks/AxTlbBaseReference.cs b/src/Tasks/AxTlbBaseReference.cs
index 39f3871bcf1..f9072bc3401 100644
--- a/src/Tasks/AxTlbBaseReference.cs
+++ b/src/Tasks/AxTlbBaseReference.cs
@@ -24,6 +24,7 @@ internal abstract class AxTlbBaseReference : ComReference
         /// internal constructor
         /// </summary>
         /// <param name="taskLoggingHelper">task logger instance used for logging</param>
+        /// <param name="silent">true if this task should log only errors, no warnings or messages; false otherwise</param>
         /// <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
         /// <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
         /// <param name="itemName">reference name (for better logging experience)</param>
@@ -31,9 +32,11 @@ internal abstract class AxTlbBaseReference : ComReference
         /// <param name="delaySign">delay sign wrappers?</param>
         /// <param name="keyFile">file containing public/private keys</param>
         /// <param name="keyContainer">container name for public/private keys</param>
+        /// <param name="includeTypeLibVersionInName">True if the interop name should include the typelib's version</param>
         /// <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using aximp.exe or tlbimp.exe</param>
         /// <param name="toolPath">Path to the SDK tools directory where aximp.exe or tlbimp.exe can be found</param>
         /// <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
+        /// <param name="environmentVariables">Array of equals-separated pairs of environment variables that should be passed to the spawned executable, in addition to (or selectively overriding) the regular environment block.</param>
         internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool delaySign, string keyFile, string keyContainer, bool includeTypeLibVersionInName, bool executeAsTool, string toolPath, IBuildEngine buildEngine, string[] environmentVariables)
             : base(taskLoggingHelper, silent, referenceInfo, itemName)
         {
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index de8325f1fe4..97990245c1c 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -95,7 +95,7 @@ public string Path
             get => _path;
             set
             {
-                if (!_fInitialized || string.Compare(_path, value, StringComparison.OrdinalIgnoreCase) != 0)
+                if (!_fInitialized || !string.Equals(_path, value, StringComparison.OrdinalIgnoreCase))
                 {
                     _path = value;
                     Refresh();
@@ -597,7 +597,7 @@ private void RefreshProducts()
                         int nStartIndex = packagePath.Length;
                         if ((strSubDirectory.ToCharArray())[nStartIndex] == System.IO.Path.DirectorySeparatorChar)
                         {
-                            nStartIndex = nStartIndex + 1;
+                            nStartIndex += 1;
                         }
 
                         ExploreDirectory(strSubDirectory.Substring(nStartIndex), rootElement, packagePath);
@@ -1460,7 +1460,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                     }
 
                     if ((packageFileSource != null) && (packageFileDestination != null) &&
-                        ((packageFileCopy == null) || (String.Compare(packageFileCopy.Value, "False", StringComparison.InvariantCulture) != 0)))
+                        ((packageFileCopy == null) || (!String.Equals(packageFileCopy.Value, "False", StringComparison.InvariantCulture))))
                     {
                         // if this is the key for an external check, we will add it to the Resource Updater instead of copying the file
                         XmlNode subNode = null;
@@ -1612,7 +1612,7 @@ private static void ClearReadOnlyAttribute(string strFileName)
             FileAttributes attribs = File.GetAttributes(strFileName);
             if ((attribs & FileAttributes.ReadOnly) != 0)
             {
-                attribs = attribs & (~FileAttributes.ReadOnly);
+                attribs &= (~FileAttributes.ReadOnly);
                 File.SetAttributes(strFileName, attribs);
             }
         }
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 322979edfbb..990ee217fee 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -31,7 +31,7 @@ public class CodeTaskFactory : ITaskFactory
         /// This dictionary keeps track of custom references to compiled assemblies.  The in-memory assembly is loaded from a byte
         /// stream and as such its dependencies cannot be found unless they are in the MSBuild.exe directory or the GAC.  They
         /// cannot be found even if they are already loaded in the AppDomain.  This dictionary knows the FullName of the assembly
-        /// and a reference to the assembly itself.  In the <see cref="CurrentDomainOnAssemblyResolve"/> handler, the dictionary 
+        /// and a reference to the assembly itself.  In the <see cref="CurrentDomainOnAssemblyResolve"/> handler, the dictionary
         /// is used to return the loaded assemblies as a way to allow custom references that are not in the normal assembly Load
         /// context.
         /// </summary>
@@ -71,7 +71,7 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         private static readonly ConcurrentDictionary<FullTaskSpecification, Assembly> s_compiledTaskCache = new ConcurrentDictionary<FullTaskSpecification, Assembly>();
 
         /// <summary>
-        /// The default assemblies to reference when compiling inline code. 
+        /// The default assemblies to reference when compiling inline code.
         /// </summary>
         private static List<string> s_defaultReferencedAssemblies;
 
@@ -81,7 +81,7 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         private List<string> _referencedAssemblies;
 
         /// <summary>
-        /// Merged set of namespaces (default + specified) 
+        /// Merged set of namespaces (default + specified)
         /// </summary>
         private List<string> _usingNamespaces;
 
@@ -151,7 +151,7 @@ private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEve
         public Type TaskType { get; private set; }
 
         /// <summary>
-        /// The assemblies that the codetaskfactory should reference by default. 
+        /// The assemblies that the codetaskfactory should reference by default.
         /// </summary>
         private static List<string> DefaultReferencedAssemblies
         {
@@ -624,7 +624,7 @@ private bool HasInvalidChildNodes(XmlNode parentNode, XmlNodeType[] allowedNodeT
         }
 
         /// <summary>
-        /// Add a reference assembly to the list of references passed to the compiler. We will try and load the assembly to make sure it is found 
+        /// Add a reference assembly to the list of references passed to the compiler. We will try and load the assembly to make sure it is found
         /// before sending it to the compiler. The reason we load here is that we will be using it in this appdomin anyways as soon as we are going to compile, which should be right away.
         /// </summary>
         [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Reflection.Assembly.LoadWithPartialName", Justification = "Necessary since we don't have the full assembly name. ")]
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index a735ccbbb24..a57e12a0413 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -254,7 +254,7 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
 
                 // if returned namespace is null or its type is not System.String, fall back to the default 
                 // way of getting the type lib name (just to be safe)
-                if (data == null || string.Compare(data.GetType().ToString(), "system.string", StringComparison.OrdinalIgnoreCase) != 0)
+                if (data == null || !string.Equals(data.GetType().ToString(), "system.string", StringComparison.OrdinalIgnoreCase))
                 {
                     typeLibName = Marshal.GetTypeLibName(typeLib);
                     return true;
@@ -265,7 +265,7 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
 
                 if (typeLibName.Length >= 4)
                 {
-                    if (string.Compare(typeLibName.Substring(typeLibName.Length - 4), ".dll", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(typeLibName.Substring(typeLibName.Length - 4), ".dll", StringComparison.OrdinalIgnoreCase))
                     {
                         typeLibName = typeLibName.Substring(0, typeLibName.Length - 4);
                     }
@@ -328,6 +328,7 @@ internal static bool GetTypeLibNameForTypeLibAttrs(TaskLoggingHelper log, bool s
         /// Strips type library number from a type library path (for example, "ref.dll\2" becomes "ref.dll")
         /// </summary>
         /// <param name="typeLibPath">type library path with possible typelib number appended to it</param>
+        /// <param name="fileExists">Delegate to check whether the file exists</param>
         /// <returns>proper file path to the type library</returns>
         internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists fileExists)
         {
diff --git a/src/Tasks/ComReferenceTypes.cs b/src/Tasks/ComReferenceTypes.cs
index c6b553c19ee..764d4baeded 100644
--- a/src/Tasks/ComReferenceTypes.cs
+++ b/src/Tasks/ComReferenceTypes.cs
@@ -20,7 +20,7 @@ internal static class ComReferenceTypes
         /// </summary>
         internal static bool IsTlbImp(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.tlbimp, StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(refType, ComReferenceTypes.tlbimp, StringComparison.OrdinalIgnoreCase));
         }
 
         /// <summary>
@@ -28,7 +28,7 @@ internal static bool IsTlbImp(string refType)
         /// </summary>
         internal static bool IsAxImp(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.aximp, StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(refType, ComReferenceTypes.aximp, StringComparison.OrdinalIgnoreCase));
         }
 
         /// <summary>
@@ -36,7 +36,7 @@ internal static bool IsAxImp(string refType)
         /// </summary>
         internal static bool IsPia(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.primary, StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(refType, ComReferenceTypes.primary, StringComparison.OrdinalIgnoreCase));
         }
 
         /// <summary>
@@ -44,7 +44,7 @@ internal static bool IsPia(string refType)
         /// </summary>
         internal static bool IsPiaOrTlbImp(string refType)
         {
-            return (string.Compare(refType, ComReferenceTypes.primaryortlbimp, StringComparison.OrdinalIgnoreCase) == 0);
+            return (string.Equals(refType, ComReferenceTypes.primaryortlbimp, StringComparison.OrdinalIgnoreCase));
         }
     }
 }
diff --git a/src/Tasks/CommandLineBuilderExtension.cs b/src/Tasks/CommandLineBuilderExtension.cs
index d2b8ba10fc7..6550ca7a004 100644
--- a/src/Tasks/CommandLineBuilderExtension.cs
+++ b/src/Tasks/CommandLineBuilderExtension.cs
@@ -267,7 +267,7 @@ internal void AppendSwitchIfNotNull
                             if (!string.IsNullOrEmpty(metadataValue))
                             {
                                 // Treat attribute as a boolean flag?
-                                if (treatAsFlags == null || treatAsFlags[i] == false)
+                                if (treatAsFlags == null || !treatAsFlags[i])
                                 {
                                     // Not a boolean flag.
                                     CommandLine.Append(',');
@@ -286,7 +286,7 @@ internal void AppendSwitchIfNotNull
                             }
                             else
                             {
-                                if (treatAsFlags == null || treatAsFlags[i] == false)
+                                if (treatAsFlags == null || !treatAsFlags[i])
                                 {
                                     // If the caller of this method asked us to add metadata
                                     // A, B, and C, and metadata A doesn't exist on the item,
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index dd7906d532b..4a8d4297fc1 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -695,7 +695,7 @@ private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationF
                 // We only do the cheap check for identicalness here, we try the more expensive check
                 // of comparing the fullpaths of source and destination to see if they are identical,
                 // in the exception handler lower down.
-                else if (0 != String.Compare(
+                else if (!String.Equals(
                              sourceFileState.Name,
                              destinationFileState.Name,
                              StringComparison.OrdinalIgnoreCase))
@@ -892,7 +892,7 @@ private static bool PathsAreIdentical(string source, string destination)
             string fullSourcePath = Path.GetFullPath(source);
             string fullDestinationPath = Path.GetFullPath(destination);
             StringComparison filenameComparison = NativeMethodsShared.IsWindows ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal;
-            return (0 == String.Compare(fullSourcePath, fullDestinationPath, filenameComparison));
+            return (String.Equals(fullSourcePath, fullDestinationPath, filenameComparison));
         }
 
     	private static int GetParallelismFromEnvironment()
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index f4858c53010..af7321ea80e 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -12,7 +12,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Base class for task that determines the appropriate manifest resource name to 
+    /// Base class for task that determines the appropriate manifest resource name to
     /// assign to a given resx or other resource.
     /// </summary>
     public class CreateCSharpManifestResourceName : CreateManifestResourceName
@@ -20,8 +20,8 @@ public class CreateCSharpManifestResourceName : CreateManifestResourceName
         protected override string SourceFileExtension => ".cs";
 
         /// <summary>
-        /// Utility function for creating a C#-style manifest name from 
-        /// a resource name. 
+        /// Utility function for creating a C#-style manifest name from
+        /// a resource name.
         /// </summary>
         /// <param name="fileName">The file name of the dependent (usually a .resx)</param>
         /// <param name="linkFileName">The file name of the dependent (usually a .resx)</param>
@@ -64,7 +64,7 @@ The reason is that CreateManifestName can't be static because it is an
         }
 
         /// <summary>
-        /// Utility function for creating a C#-style manifest name from 
+        /// Utility function for creating a C#-style manifest name from
         /// a resource name. Note that this function attempts to emulate the
         /// Everret implementation of this code which can be found by searching for
         /// ComputeNonWFCResourceName() or ComputeWFCResourceName() in
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 568d4204343..4d656ba43ee 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -10,7 +10,7 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// Base class for task that determines the appropriate manifest resource name to 
+    /// Base class for task that determines the appropriate manifest resource name to
     /// assign to a given resx or other resource.
     /// </summary>
     public class CreateVisualBasicManifestResourceName : CreateManifestResourceName
@@ -18,8 +18,8 @@ public class CreateVisualBasicManifestResourceName : CreateManifestResourceName
         protected override string SourceFileExtension => ".vb";
 
         /// <summary>
-        /// Utility function for creating a VB-style manifest name from 
-        /// a resource name. 
+        /// Utility function for creating a VB-style manifest name from
+        /// a resource name.
         /// </summary>
         /// <param name="fileName">The file name of the dependent (usually a .resx)</param>
         /// <param name="linkFileName">The file name of the dependent (usually a .resx)</param>
@@ -62,7 +62,7 @@ The reason is that CreateManifestName can't be static because it is an
         }
 
         /// <summary>
-        /// Utility function for creating a VB-style manifest name from 
+        /// Utility function for creating a VB-style manifest name from
         /// a resource name. Note that this function attempts to emulate the
         /// Everret implementation of this code which can be found by searching for
         /// ComputeNonWFCResourceName() or ComputeWFCResourceName() in
diff --git a/src/Tasks/Culture.cs b/src/Tasks/Culture.cs
index 7c7e4722609..6dc32800ee3 100644
--- a/src/Tasks/Culture.cs
+++ b/src/Tasks/Culture.cs
@@ -36,7 +36,7 @@ string dependentUponFilename
             info.culture = null;
             string parentName = dependentUponFilename ?? String.Empty;
 
-            if (0 == String.Compare(Path.GetFileNameWithoutExtension(parentName),
+            if (String.Equals(Path.GetFileNameWithoutExtension(parentName),
                                    Path.GetFileNameWithoutExtension(name),
                                    StringComparison.OrdinalIgnoreCase))
             {
diff --git a/src/Tasks/Delegate.cs b/src/Tasks/Delegate.cs
index f9363684e4b..563f6c39e0e 100644
--- a/src/Tasks/Delegate.cs
+++ b/src/Tasks/Delegate.cs
@@ -22,6 +22,7 @@ namespace Microsoft.Build.Tasks
     /// File SetAttributes delegate
     /// </summary>
     /// <param name="path">The path to set attributes for.</param>
+    /// <param name="attributes">The actual file attributes.</param>
     internal delegate void SetAttributes(string path, FileAttributes attributes);
 
     /// <summary>
@@ -82,8 +83,10 @@ namespace Microsoft.Build.Tasks
     /// assemblies and  the list of scatter files.
     /// </summary>
     /// <param name="path">Path to the assembly.</param>
+    /// <param name="assemblyMetadataCache">Assembly metadata cache.</param>
     /// <param name="dependencies">Receives the list of dependencies.</param>
     /// <param name="scatterFiles">Receives the list of associated scatter files.</param>
+    /// <param name="frameworkNameAttribute">The framework name</param>
     internal delegate void GetAssemblyMetadata
     (
         string path,
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index f3cbccfde1d..1f9181ec72e 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -131,6 +131,7 @@ private async Task<bool> ExecuteAsync()
         /// Attempts to download the file.
         /// </summary>
         /// <param name="uri">The parsed <see cref="Uri"/> of the request.</param>
+        /// <param name="cancellationToken">The cancellation token for the task.</param>
         private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
         {
             // The main reason to use HttpClient vs WebClient is because we can pass a message handler for unit tests to mock
diff --git a/src/Tasks/ErrorFromResources.cs b/src/Tasks/ErrorFromResources.cs
index 596fc974f4c..83c5f106d6a 100644
--- a/src/Tasks/ErrorFromResources.cs
+++ b/src/Tasks/ErrorFromResources.cs
@@ -51,7 +51,7 @@ public override bool Execute()
                 string message = ResourceUtilities.ExtractMessageCode(false /* all codes */, Log.FormatResourceString(Resource, Arguments), out string errorCode);
 
                 // If the user specifies a code, that should override. 
-                Code = Code ?? errorCode;
+                Code ??= errorCode;
 
                 Log.LogError(null, Code, HelpKeyword, File, 0, 0, 0, 0, message);
             }
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index a9d62258cb3..7b9c1287d0a 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -251,12 +251,12 @@ private AssemblyIdentity CreateAssemblyIdentity(AssemblyIdentity baseIdentity, A
                     // Don't need publicKeyToken attribute for non-ClickOnce case
                     publicKeyToken = null;
                     // Language attribute should be omitted if neutral
-                    if (String.Compare(culture, "neutral", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(culture, "neutral", StringComparison.OrdinalIgnoreCase))
                     {
                         culture = null;
                     }
                     // WinXP loader doesn't understand "msil"
-                    if (String.Compare(_processorArchitecture, "msil", StringComparison.OrdinalIgnoreCase) == 0)
+                    if (String.Equals(_processorArchitecture, "msil", StringComparison.OrdinalIgnoreCase))
                     {
                         _processorArchitecture = null;
                     }
@@ -329,7 +329,7 @@ protected internal FileReference FindFileFromItem(ITaskItem item)
             }
             foreach (FileReference file in _manifest.FileReferences)
             {
-                if (String.Compare(targetPath, file.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(targetPath, file.TargetPath, StringComparison.OrdinalIgnoreCase))
                 {
                     return file;
                 }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 72b978c95c5..7a4f4c757b1 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -1139,7 +1139,8 @@ private bool GenerateResourcesUsingResGen(List<ITaskItem> inputsToProcess, List<
         /// Given an instance of the ResGen task with everything but the strongly typed
         /// resource-related parameters filled out, execute the task and return the result
         /// </summary>
-        /// <param name="resGen">The task to execute.</param>
+        /// <param name="inputsToProcess">Input files to give to resgen.exe.</param>
+        /// <param name="outputsToProcess">Output files to give to resgen.exe.</param>
         private bool TransformResourceFilesUsingResGen(List<ITaskItem> inputsToProcess, List<ITaskItem> outputsToProcess)
         {
             ErrorUtilities.VerifyThrow(inputsToProcess.Count != 0, "There should be resource files to process");
@@ -1262,7 +1263,8 @@ private int CalculateResourceBatchSize(List<ITaskItem> inputsToProcess, List<ITa
         /// Given an instance of the ResGen task with everything but the strongly typed
         /// resource-related parameters filled out, execute the task and return the result
         /// </summary>
-        /// <param name="resGen">The task to execute.</param>
+        /// <param name="inputsToProcess">Input files to give to resgen.exe.</param>
+        /// <param name="outputsToProcess">Output files to give to resgen.exe.</param>
         private bool GenerateStronglyTypedResourceUsingResGen(List<ITaskItem> inputsToProcess, List<ITaskItem> outputsToProcess)
         {
             ErrorUtilities.VerifyThrow(inputsToProcess.Count == 1 && outputsToProcess.Count == 1, "For STR, there should only be one input and one output.");
@@ -1299,7 +1301,6 @@ private bool GenerateStronglyTypedResourceUsingResGen(List<ITaskItem> inputsToPr
         /// Factoring out the setting of the default parameters to the
         /// ResGen task.
         /// </summary>
-        /// <param name="resGen"></param>
         private ResGen CreateResGenTaskWithDefaultParameters()
         {
             ResGen resGen = new ResGen();
@@ -1439,7 +1440,7 @@ private void GetResourcesToProcess(out List<ITaskItem> inputsToProcess, out List
         /// <summary>
         /// Given a cached portable library that is up to date, create ITaskItems to represent the output of the task, as if we did real work.
         /// </summary>
-        /// <param name="library">The portable library cache entry to extract output files & metadata from.</param>
+        /// <param name="library">The portable library cache entry to extract output files and metadata from.</param>
         /// <param name="cachedOutputFiles">List of output files produced from the cache.</param>
         private void AppendCachedOutputTaskItems(ResGenDependencies.PortableLibraryFile library, List<ITaskItem> cachedOutputFiles)
         {
@@ -1738,7 +1739,6 @@ private void UpdateNewestUncorrelatedInputWriteTime()
         /// needed, it should always err on the side of returning 'true'. This
         /// is because a separate AppDomain, while slow to create, is always safe.
         /// </summary>
-        /// <param name="sources">The list of .resx files.</param>
         /// <returns></returns>
         private bool NeedSeparateAppDomain()
         {
@@ -1752,15 +1752,15 @@ private bool NeedSeparateAppDomain()
             {
                 string extension = Path.GetExtension(source.ItemSpec);
 
-                if (String.Compare(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                    String.Compare(extension, ".dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                    String.Compare(extension, ".exe", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) ||
+                    String.Equals(extension, ".dll", StringComparison.OrdinalIgnoreCase) ||
+                    String.Equals(extension, ".exe", StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
 
-                if (String.Compare(extension, ".resx", StringComparison.OrdinalIgnoreCase) == 0 ||
-                    String.Compare(extension, ".resw", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(extension, ".resx", StringComparison.OrdinalIgnoreCase) ||
+                    String.Equals(extension, ".resw", StringComparison.OrdinalIgnoreCase))
                 {
                     XmlReader reader = null;
                     string name = null;
@@ -2506,7 +2506,7 @@ internal Assembly ResolveAssembly(object sender, ResolveEventArgs args)
 
                     if (candidateAssemblyName != null)
                     {
-                        if (String.Compare(requestedAssemblyName.Name, candidateAssemblyName.Name, StringComparison.CurrentCultureIgnoreCase) == 0)
+                        if (String.Equals(requestedAssemblyName.Name, candidateAssemblyName.Name, StringComparison.CurrentCultureIgnoreCase))
                         {
                             return Assembly.UnsafeLoadFrom(_assemblyFiles[i].ItemSpec);
                         }
@@ -2560,7 +2560,7 @@ private void PopulateAssemblyNames()
         /// </summary>
         /// <remarks>Uses the input and output file extensions to determine their format</remarks>
         /// <param name="inFile">Input resources file</param>
-        /// <param name="outFile">Output resources file</param>
+        /// <param name="outFileOrDir">Output resources file or directory</param>
         /// <returns>True if conversion was successful, otherwise false</returns>
         private bool ProcessFile(string inFile, string outFileOrDir)
         {
@@ -2779,7 +2779,7 @@ e is SerializationException ||
                 }
 
                 if (currentOutputDirectory != null &&
-                    currentOutputDirectoryAlreadyExisted == false)
+                    !currentOutputDirectoryAlreadyExisted)
                 {
                     // Do not annoy the user by removing an empty directory we did not create.
                     try
@@ -2929,23 +2929,23 @@ private Format GetFormat(string filename)
                 return Format.Error;
             }
 
-            if (String.Compare(extension, ".txt", StringComparison.OrdinalIgnoreCase) == 0 ||
-                String.Compare(extension, ".restext", StringComparison.OrdinalIgnoreCase) == 0)
+            if (String.Equals(extension, ".txt", StringComparison.OrdinalIgnoreCase) ||
+                String.Equals(extension, ".restext", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.Text;
             }
-            else if (String.Compare(extension, ".resx", StringComparison.OrdinalIgnoreCase) == 0 ||
-                     String.Compare(extension, ".resw", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(extension, ".resx", StringComparison.OrdinalIgnoreCase) ||
+                     String.Equals(extension, ".resw", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.XML;
             }
-            else if (String.Compare(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                     String.Compare(extension, ".dll", StringComparison.OrdinalIgnoreCase) == 0 ||
-                     String.Compare(extension, ".exe", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(extension, ".resources.dll", StringComparison.OrdinalIgnoreCase) ||
+                     String.Equals(extension, ".dll", StringComparison.OrdinalIgnoreCase) ||
+                     String.Equals(extension, ".exe", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.Assembly;
             }
-            else if (String.Compare(extension, ".resources", StringComparison.OrdinalIgnoreCase) == 0)
+            else if (String.Equals(extension, ".resources", StringComparison.OrdinalIgnoreCase))
             {
                 return Format.Binary;
             }
@@ -3252,6 +3252,8 @@ internal void ReadAssemblyResources(String name, String outFileOrDir)
         /// <param name="name">Assembly's file name</param>
         /// <param name="assemblyName">AssemblyName of this assembly</param>
         /// <param name="culture">Assembly's CultureInfo</param>
+        /// <param name="a">The actual Assembly</param>
+        /// <param name="mainAssembly">Whether this is the main assembly</param>
         private NeutralResourcesLanguageAttribute CheckAssemblyCultureInfo(String name, AssemblyName assemblyName, CultureInfo culture, Assembly a, bool mainAssembly)
         {
             NeutralResourcesLanguageAttribute neutralResourcesLanguageAttribute = null;
@@ -3300,6 +3302,7 @@ private static bool ContainsProperlyNamedResourcesFiles(Assembly a, bool mainAss
         /// <summary>
         /// Write resources from the resources ArrayList to the specified output file
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="filename">Output resources file</param>
         private void WriteResources(ReaderInfo reader, String filename)
         {
@@ -3407,8 +3410,10 @@ private bool HaveSystemResourcesExtensionsReference
         /// <summary>
         /// Create a strongly typed resource class
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="outFile">Output resource filename, for defaulting the class filename</param>
         /// <param name="inputFileName">Input resource filename, for error messages</param>
+        /// <param name="sourceFile">The generated strongly typed filename</param>
         private void CreateStronglyTypedResources(ReaderInfo reader, String outFile, String inputFileName, out String sourceFile)
         {
             CodeDomProvider provider = null;
@@ -3494,6 +3499,7 @@ public static string GenerateDefaultStronglyTypedFilename(CodeDomProvider provid
         /// Broken out here so it can be called from GenerateResource class.
         /// Not a true "TryXXX" method, as it still throws if it encounters an exception it doesn't expect.
         /// </comments>
+        /// <param name="logger">Logger helper.</param>
         /// <param name="stronglyTypedLanguage">The language to create a provider for.</param>
         /// <param name="provider">The provider in question, if one is successfully created.</param>
         /// <returns>True if the provider was successfully created, false otherwise.</returns>
@@ -3523,6 +3529,7 @@ public static bool TryCreateCodeDomProvider(TaskLoggingHelper logger, string str
         /// <summary>
         /// Read resources from an XML or binary format file
         /// </summary>
+        /// <param name="readerInfo">Reader info</param>
         /// <param name="reader">Appropriate IResourceReader</param>
         /// <param name="fileName">Filename, for error messages</param>
         private void ReadResources(ReaderInfo readerInfo, IResourceReader reader, String fileName)
@@ -3543,6 +3550,7 @@ private void ReadResources(ReaderInfo readerInfo, IResourceReader reader, String
         /// <summary>
         /// Read resources from a text format file
         /// </summary>
+        /// <param name="reader">Reader info</param>
         /// <param name="fileName">Input resources filename</param>
         private void ReadTextResources(ReaderInfo reader, String fileName)
         {
@@ -3608,7 +3616,7 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
                     // sign.  Deal with it.
                     if (name[name.Length - 1] == ' ')
                     {
-                        name.Length = name.Length - 1;
+                        name.Length -= 1;
                     }
                     ch = sr.Read(); // move past =
                     // If it exists, move past the first space after the equals sign.
@@ -3718,6 +3726,7 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
         /// Write resources to an XML or binary format resources file.
         /// </summary>
         /// <remarks>Closes writer automatically</remarks>
+        /// <param name="reader">Reader information</param>
         /// <param name="writer">Appropriate IResourceWriter</param>
         private void WriteResources(ReaderInfo reader,
             IResourceWriter writer)
@@ -3758,6 +3767,7 @@ private void WriteResources(ReaderInfo reader,
         /// <summary>
         /// Write resources to a text format resources file
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="fileName">Output resources file</param>
         private void WriteTextResources(ReaderInfo reader, String fileName)
         {
@@ -3791,6 +3801,7 @@ private void WriteTextResources(ReaderInfo reader, String fileName)
         /// <summary>
         /// Add a resource from a text file to the internal data structures
         /// </summary>
+        /// <param name="reader">Reader information</param>
         /// <param name="name">Resource name</param>
         /// <param name="value">Resource value</param>
         /// <param name="inputFileName">Input file for messages</param>
@@ -3818,6 +3829,7 @@ private void AddResource(ReaderInfo reader, IResource entry, String inputFileNam
         /// <summary>
         /// Add a resource from an XML or binary format file to the internal data structures
         /// </summary>
+        /// <param name="reader">Reader info</param>
         /// <param name="name">Resource name</param>
         /// <param name="value">Resource value</param>
         /// <param name="inputFileName">Input file for messages</param>
@@ -3928,7 +3940,7 @@ internal int LinePosition
         }
 
         /// <summary>
-        /// For flow of control & passing sufficient error context back
+        /// For flow of control and passing sufficient error context back
         /// from ReadTextResources
         /// </summary>
         [Serializable]
@@ -4008,6 +4020,7 @@ public Assembly GetAssembly(AssemblyName name)
         /// Not implemented.  Not called by the ResxResourceReader.
         /// </summary>
         /// <param name="name"></param>
+        /// <param name="throwOnError"></param>
         /// <returns></returns>
         public Assembly GetAssembly(AssemblyName name, bool throwOnError)
         {
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 3c34040841a..4e7bffa6f13 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -110,7 +110,7 @@ public ITaskItem[] ResolvedSDKReferences
         }
 
         /// <summary>
-        /// Extensions which should be considered reference files, we will look for 
+        /// Extensions which should be considered reference files, we will look for
         /// the files in the order they are specified in the array.
         /// </summary>
         public string[] ReferenceExtensions
@@ -1078,7 +1078,7 @@ private static void PopulateRedistDictionaryFromPaths(ConcurrentDictionary<strin
             }
 
             /// <summary>
-            /// Is the assembly list cache file up to date. 
+            /// Is the assembly list cache file up to date.
             /// This is done by comparing the last write time of the cache file to the last write time of the code.
             /// If our code is newer than the last write time of the cache file then there may be some different serialization used so we should say it is out of date and just regenerate it.
             /// </summary>
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index dbff4f3c52f..1f0e1cc3d6a 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -631,7 +631,7 @@ private void ValidateReferencesForClickOnceApplication()
                     {
                         targetPathList.Add(key, false);
                     }
-                    else if (targetPathList[key] == false)
+                    else if (!targetPathList[key])
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateTargetPath", assembly.ToString());
                         targetPathList[key] = true; // only warn once per path
@@ -674,7 +674,7 @@ private void ValidateReferencesForClickOnceApplication()
                     {
                         targetPathList.Add(key, false);
                     }
-                    else if (targetPathList[key] == false)
+                    else if (!targetPathList[key])
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateTargetPath", file.TargetPath);
                         targetPathList[key] = true; // only warn once per path
diff --git a/src/Tasks/ManifestUtil/AssemblyReference.cs b/src/Tasks/ManifestUtil/AssemblyReference.cs
index 9f523c33c19..81c741db55d 100644
--- a/src/Tasks/ManifestUtil/AssemblyReference.cs
+++ b/src/Tasks/ManifestUtil/AssemblyReference.cs
@@ -85,7 +85,7 @@ internal bool IsVirtual
             {
                 if (AssemblyIdentity == null)
                     return false;
-                if (String.Compare(AssemblyIdentity.Name, Constants.CLRPlatformAssemblyName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(AssemblyIdentity.Name, Constants.CLRPlatformAssemblyName, StringComparison.OrdinalIgnoreCase))
                     return true;
                 else
                     return false;
diff --git a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
index e09397b053a..2b81f70979d 100644
--- a/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
+++ b/src/Tasks/ManifestUtil/AssemblyReferenceCollection.cs
@@ -79,10 +79,10 @@ public AssemblyReference Find(string name)
             }
             foreach (AssemblyReference a in _list)
             {
-                if (a.AssemblyIdentity != null && String.Compare(
+                if (a.AssemblyIdentity != null && String.Equals(
                         name,
                         a.AssemblyIdentity.Name,
-                        StringComparison.OrdinalIgnoreCase) == 0)
+                        StringComparison.OrdinalIgnoreCase))
                 {
                     return a;
                 }
@@ -156,7 +156,7 @@ public AssemblyReference FindTargetPath(string targetPath)
             }
             foreach (AssemblyReference a in _list)
             {
-                if (String.Compare(targetPath, a.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(targetPath, a.TargetPath, StringComparison.OrdinalIgnoreCase))
                 {
                     return a;
                 }
diff --git a/src/Tasks/ManifestUtil/FileReference.cs b/src/Tasks/ManifestUtil/FileReference.cs
index 1b46df71c7b..69c418bb40a 100644
--- a/src/Tasks/ManifestUtil/FileReference.cs
+++ b/src/Tasks/ManifestUtil/FileReference.cs
@@ -83,7 +83,7 @@ internal bool ImportComComponent(string path, OutputMessageCollection outputMess
         [XmlIgnore]
         public bool IsDataFile
         {
-            get => String.Compare(_writeableType, "applicationData", StringComparison.OrdinalIgnoreCase) == 0;
+            get => String.Equals(_writeableType, "applicationData", StringComparison.OrdinalIgnoreCase);
             set => _writeableType = value ? "applicationData" : null;
         }
 
@@ -365,12 +365,12 @@ public bool Versioned
         {
             get
             {
-                if (String.Compare(_versioned, "yes", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(_versioned, "yes", StringComparison.OrdinalIgnoreCase))
                 {
                     return true;
                 }
 
-                if (String.Compare(_versioned, "no", StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(_versioned, "no", StringComparison.OrdinalIgnoreCase))
                 {
                     return false;
                 }
diff --git a/src/Tasks/ManifestUtil/FileReferenceCollection.cs b/src/Tasks/ManifestUtil/FileReferenceCollection.cs
index d044fba2cbc..25be81c3805 100644
--- a/src/Tasks/ManifestUtil/FileReferenceCollection.cs
+++ b/src/Tasks/ManifestUtil/FileReferenceCollection.cs
@@ -79,7 +79,7 @@ public FileReference FindTargetPath(string targetPath)
             }
             foreach (FileReference f in _list)
             {
-                if (String.Compare(targetPath, f.TargetPath, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(targetPath, f.TargetPath, StringComparison.OrdinalIgnoreCase))
                 {
                     return f;
                 }
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index d6c882667d7..533e4be9337 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -597,7 +597,7 @@ private void ValidateReferences()
                     {
                         identityList.Add(key, false);
                     }
-                    else if (identityList[key] == false)
+                    else if (!identityList[key])
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateAssemblyIdentity", identity);
                         identityList[key] = true; // only warn once per identity
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 2a08073279d..095f9e20de4 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -561,7 +561,7 @@ private static bool UseSha256Algorithm(X509Certificate2 cert)
         /// <param name="cert">The certificate to be used to sign the file.</param>
         /// <param name="timestampUrl">URL that specifies an address of a time stamping server.</param>
         /// <param name="path">Path of the file to sign with the certificate.</param>
-        /// <remarks>This function can only sign a PE file if the X509Certificate2 parameter represents a certificate in the 
+        /// <remarks>This function can only sign a PE file if the X509Certificate2 parameter represents a certificate in the
         /// current user's personal certificate store.</remarks>
         public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path)
         {
@@ -599,7 +599,7 @@ private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, st
             else
             {
                 using(RSA rsa = CngLightup.GetRSAPrivateKey(cert))
-                {                    
+                {
                     if (rsa == null)
                         throw new ApplicationException(resources.GetString("SecurityUtil.OnlyRSACertsAreAllowed"));
                     try
@@ -659,8 +659,8 @@ private static void SignPEFile(X509Certificate2 cert, Uri timestampUrl, string p
             }
         }
 
-        private static void SignPEFileInternal(X509Certificate2 cert, Uri timestampUrl, 
-                                               string path, System.Resources.ResourceManager resources, 
+        private static void SignPEFileInternal(X509Certificate2 cert, Uri timestampUrl,
+                                               string path, System.Resources.ResourceManager resources,
                                                bool useSha256, bool useRFC3161Timestamp)
         {
             var startInfo = new ProcessStartInfo(
@@ -721,9 +721,9 @@ internal static string GetCommandLineParameters(string certThumbprint, Uri times
 
             if (timestampUrl != null)
             {
-                commandLine.Append(String.Format(CultureInfo.InvariantCulture, 
-                                                "{0} {1} ", 
-                                                useRFC3161Timestamp ? "/tr" : "/t", 
+                commandLine.Append(String.Format(CultureInfo.InvariantCulture,
+                                                "{0} {1} ",
+                                                useRFC3161Timestamp ? "/tr" : "/t",
                                                 timestampUrl.ToString()));
             }
             commandLine.Append(string.Format(CultureInfo.InvariantCulture, "\"{0}\"", path));
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index db70c1a72b5..808dbf5d5af 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -129,7 +129,7 @@ private void FixupPermissionSetElement(XmlElement permissionSetElement)
                 defaultAssemblyRequestElement.Attributes.Append(idrefAttribute);
             }
 
-            if (String.Compare(idAttribute.Value, idrefAttribute.Value, StringComparison.Ordinal) != 0)
+            if (!String.Equals(idAttribute.Value, idrefAttribute.Value, StringComparison.Ordinal))
             {
                 idrefAttribute.Value = idAttribute.Value;
             }
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index 615f2bb6192..6e081717785 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -314,7 +314,7 @@ internal static bool IsValidFrameworkVersion(string value)
         public static string PlatformToProcessorArchitecture(string platform)
         {
             for (int i = 0; i < s_platforms.Length; ++i)
-                if (String.Compare(platform, s_platforms[i], StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(platform, s_platforms[i], StringComparison.OrdinalIgnoreCase))
                     return s_processorArchitectures[i];
             return null;
         }
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index d7fb13512ae..ee6b8014c57 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -464,6 +464,7 @@ private static void RemoveExistingSignature(XmlDocument manifestDom)
         /// As for official guidance – I’m not sure of any.    For workarounds though, if you’re using the Microsoft software CSPs, they share the underlying key store.  You can get the key container name from your RSA object, then open up a new RSA object with the same key container name but with PROV_RSA_AES.   At that point, you should be able to use SHA-2 algorithms.
         /// </summary>
         /// <param name="oldCsp"></param>
+        /// <param name="useSha256">Whether to use sha256</param>
         /// <returns></returns>
         [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Cryptographic.Standard", "CA5358:RSAProviderNeeds2048bitKey", Justification = "SHA1 is retained for compatibility reasons as an option in VisualStudio signing page and consequently in the trust manager, default is SHA2.")]
         internal static RSACryptoServiceProvider GetFixedRSACryptoServiceProvider(RSACryptoServiceProvider oldCsp, bool useSha256)
@@ -513,7 +514,7 @@ private static void ReplacePublicKeyToken(XmlDocument manifestDom, AsymmetricAlg
             byte[] cspPublicKeyBlob;
 
             if(snKey is RSACryptoServiceProvider){
-                cspPublicKeyBlob = (GetFixedRSACryptoServiceProvider((RSACryptoServiceProvider)snKey, useSha256)).ExportCspBlob(false);            
+                cspPublicKeyBlob = (GetFixedRSACryptoServiceProvider((RSACryptoServiceProvider)snKey, useSha256)).ExportCspBlob(false);
                 if (cspPublicKeyBlob == null || cspPublicKeyBlob.Length == 0)
                 {
                     throw new CryptographicException(Win32.NTE_BAD_KEY);
diff --git a/src/Tasks/Move.cs b/src/Tasks/Move.cs
index a9136d0a089..8e64b2f7038 100644
--- a/src/Tasks/Move.cs
+++ b/src/Tasks/Move.cs
@@ -180,7 +180,7 @@ private static void MakeWriteableIfReadOnly(string file)
             var info = new FileInfo(file);
             if ((info.Attributes & FileAttributes.ReadOnly) != 0)
             {
-                info.Attributes = info.Attributes & ~FileAttributes.ReadOnly;
+                info.Attributes &= ~FileAttributes.ReadOnly;
             }
         }
 
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 71d2fd91fa4..76065042e2a 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -1324,10 +1324,10 @@ internal enum AssemblyComparisonResult
         #region Methods
 #if FEATURE_HANDLEPROCESSCORRUPTEDSTATEEXCEPTIONS
         /// <summary>
-        /// Given a pointer to a metadata blob, read the string parameter from it.  Returns true if 
-        /// a valid string was constructed and false otherwise.  
-        /// 
-        /// Adapted from bizapps\server\designers\models\packagemodel\nativemethods.cs (TryReadStringArgument) and 
+        /// Given a pointer to a metadata blob, read the string parameter from it.  Returns true if
+        /// a valid string was constructed and false otherwise.
+        ///
+        /// Adapted from bizapps\server\designers\models\packagemodel\nativemethods.cs (TryReadStringArgument) and
         /// the original ARD implementation in vsproject\compsvcspkg\enumcomplus.cpp (GetStringCustomAttribute)
         /// This code was taken from the vsproject\ReferenceManager\Providers\NativeMethods.cs
         /// </summary>
@@ -1402,10 +1402,10 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
         }
 #endif
         /// <summary>
-        /// Returns the number of bytes that compressed data -- the length of the uncompressed 
-        /// data -- takes up, and has an out value of the length of the string.  
-        /// 
-        /// Decompression algorithm stolen from ndp\clr\src\toolbox\mdbg\corapi\metadata\cormetadata.cs, which 
+        /// Returns the number of bytes that compressed data -- the length of the uncompressed
+        /// data -- takes up, and has an out value of the length of the string.
+        ///
+        /// Decompression algorithm stolen from ndp\clr\src\toolbox\mdbg\corapi\metadata\cormetadata.cs, which
         /// was translated from the base implementation in ndp\clr\src\inc\cor.h
         /// This code was taken from the vsproject\ReferenceManager\Providers\NativeMethods.cs
         /// </summary>
diff --git a/src/Tasks/RCWForCurrentContext.cs b/src/Tasks/RCWForCurrentContext.cs
index 601bc5336f7..c8944fa05b1 100644
--- a/src/Tasks/RCWForCurrentContext.cs
+++ b/src/Tasks/RCWForCurrentContext.cs
@@ -74,7 +74,6 @@ public RCWForCurrentContext(T rcw)
         /// Call this helper if your managed object is really an RCW to a COM object
         /// and that COM object was created in a different apartment from where it is being accessed
         /// </summary>
-        /// <param name="rcw">An RCW object created in the original apartment context.</param>
         /// <returns>A new RCW created in the current apartment context</returns>
         public T RCW
         {
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index fa1578fa799..9da5c32a396 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -29,7 +29,7 @@ namespace Microsoft.Build.Tasks
     /// Framework version dependencies to the current Framework version.
     /// This list is also used by the deployment system to exclude Framework
     /// dependencies from customer deployment packages.
-    /// </summary>    
+    /// </summary>
     internal sealed class RedistList
     {
         // List of cached RedistList objects, the key is a semi-colon delimited list of data file paths
@@ -66,7 +66,7 @@ internal sealed class RedistList
 
         // List of cached BlackList RedistList objects, the key is a semi-colon delimited list of data file paths
         private readonly ConcurrentDictionary<string, Dictionary<string, string>> _cachedBlackList = new ConcurrentDictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
-        
+
         /***************Fields which are only set in the constructor and should not be modified by the class. **********************/
         // Array of errors encountered while reading files.
         private readonly ReadOnlyCollection<Exception> _errors;
@@ -169,8 +169,8 @@ public bool IsPrerequisiteAssembly(string assemblyName)
         }
 
         /// <summary>
-        /// If there was a remapping entry in the redist list then remap the passed in assemblynameextension 
-        /// if not just return the original one. 
+        /// If there was a remapping entry in the redist list then remap the passed in assemblynameextension
+        /// if not just return the original one.
         /// </summary>
         public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRemap)
         {
@@ -482,24 +482,26 @@ internal IEnumerable<AssemblyEntry> FindAssemblyNameFromSimpleName(string simple
         }
 
         /// <summary>
-        /// This method will take a list of AssemblyTableInfo and generate a black list by subtracting the 
-        /// assemblies listed in the WhiteList from the RedistList. 
-        /// 
+        /// This method will take a list of AssemblyTableInfo and generate a black list by subtracting the
+        /// assemblies listed in the WhiteList from the RedistList.
+        ///
         /// 1) If there are assemblies in the redist list and one or more client subset files are read in with matching names then
         ///    the subtraction will take place. If there were no matching redist lists read in the black list will be empty.
-        ///    
+        ///
         /// 2) If the subset has a matching name but there are no files inside of it then the black list will contain ALL files in the redist list.
-        /// 
+        ///
         /// 3) If the redist list assembly has a null or empty redist name or the subset list has a null or empty subset name they will not be used for black list generation.
         ///
         /// When generating the blacklist, we will first see if the black list is in the appdomain wide cache
         /// so that we do not regenerate one for multiple calls using the same whiteListAssemblyTableInfo.
-        /// 
+        ///
         /// </summary>
         /// <param name="whiteListAssemblyTableInfo">List of paths to white list xml files</param>
-        /// <returns>A dictionary containing the full assembly names of black listed assemblies as the key, and null as the value. 
+        /// <param name="whiteListErrors">List of white listed errors</param>
+        /// <param name="whiteListErrorFileNames">List of white listed error file names</param>
+        /// <returns>A dictionary containing the full assembly names of black listed assemblies as the key, and null as the value.
         ///          If there is no assemblies in the redist list null is returned.
-        /// </returns> 
+        /// </returns>
         internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteListAssemblyTableInfo, List<Exception> whiteListErrors, List<string> whiteListErrorFileNames)
         {
             // Return null if there are no assemblies in the redist list.
@@ -621,6 +623,10 @@ internal Dictionary<string, string> GenerateBlackList(AssemblyTableInfo[] whiteL
         /// XML formatting issues will recorded in the 'errors' collection.
         /// </summary>
         /// <param name="assemblyTableInfo">Information about the redistlist file.</param>
+        /// <param name="assembliesList">List of assembly from installed assembly table.</param>
+        /// <param name="errorsList">Error list.</param>
+        /// <param name="errorFilenamesList">Error filename list.</param>
+        /// <param name="remapEntries">Assembly remaping.</param>
         /// <returns>Redist name of the redist list just read in</returns>
         internal static string ReadFile(AssemblyTableInfo assemblyTableInfo, List<AssemblyEntry> assembliesList, List<Exception> errorsList, List<string> errorFilenamesList, List<AssemblyRemapping> remapEntries)
         {
@@ -833,7 +839,7 @@ private static AssemblyEntry ReadFileListEntry(AssemblyTableInfo assemblyTableIn
             }
 
             bool isValidEntry = !string.IsNullOrEmpty(name) && (!fullFusionNameRequired || (fullFusionNameRequired && !string.IsNullOrEmpty(version) && !string.IsNullOrEmpty(publicKeyToken) && !string.IsNullOrEmpty(culture)));
-            Debug.Assert(isValidEntry, string.Format(CultureInfo.InvariantCulture, "Missing attribute in redist file: {0}, line #{1}", path, 
+            Debug.Assert(isValidEntry, string.Format(CultureInfo.InvariantCulture, "Missing attribute in redist file: {0}, line #{1}", path,
                 reader is IXmlLineInfo ? ((IXmlLineInfo)reader).LineNumber : 0));
             AssemblyEntry newEntry = null;
             if (isValidEntry)
@@ -928,7 +934,7 @@ public int CompareTo(object obj)
     }
 
     /// <summary>
-    /// Provide a mechanism to determine where the subset white lists are located by searching the target framework folders 
+    /// Provide a mechanism to determine where the subset white lists are located by searching the target framework folders
     /// for a list of provided subset list names.
     /// </summary>
     internal class SubsetListFinder
@@ -958,7 +964,7 @@ internal class SubsetListFinder
         /// This class takes in a list of subset names to look for and provides a method to search the target framework directories to see if those
         /// files exist.
         /// </summary>
-        /// <param name="subsetToSearchFor">String array of subset names, ie  Client, Net, MySubset. This may be null or empty if no subsets were requested to be 
+        /// <param name="subsetToSearchFor">String array of subset names, ie  Client, Net, MySubset. This may be null or empty if no subsets were requested to be
         /// found in the target framework directories. This can happen if the subsets are instead passed in as InstalledDefaultSubsetTables</param>
         internal SubsetListFinder(string[] subsetToSearchFor)
         {
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 05271ec7b9d..5794aac4d9c 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -538,7 +538,7 @@ private string GenerateResGenFullPath()
             /// </summary>
             private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments, bool useForResponseFile)
             {
-                resGenArguments = resGenArguments ?? new CommandLineBuilderExtension();
+                resGenArguments ??= new CommandLineBuilderExtension();
 
                 if (IsNullOrEmpty(OutputFiles))
                 {
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index a0bf071da6d..236d8102924 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -61,7 +61,7 @@ internal string BaseLinkedFileDirectory
                 }
                 if ((value == null && baseLinkedFileDirectory != null) ||
                      (value != null && baseLinkedFileDirectory == null) ||
-                     (String.Compare(baseLinkedFileDirectory, value, StringComparison.OrdinalIgnoreCase) != 0))
+                     (!String.Equals(baseLinkedFileDirectory, value, StringComparison.OrdinalIgnoreCase)))
                 {
                     // Ok, this is slightly complicated.  Changing the base directory in any manner may
                     // result in changes to how we find .resx files.  Therefore, we must clear our out
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index d7a4bcebde9..1ba5c201f6b 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -1165,7 +1165,7 @@ bool IComReferenceResolver.ResolveNetAssemblyReference(string assemblyName, out
 
             for (int i = 0; i < ResolvedAssemblyReferences.GetLength(0); i++)
             {
-                if (String.Compare(Path.GetFileName(ResolvedAssemblyReferences[i].ItemSpec), assemblyName, StringComparison.OrdinalIgnoreCase) == 0)
+                if (String.Equals(Path.GetFileName(ResolvedAssemblyReferences[i].ItemSpec), assemblyName, StringComparison.OrdinalIgnoreCase))
                 {
                     assemblyPath = ResolvedAssemblyReferences[i].ItemSpec;
                     return true;
@@ -1308,6 +1308,7 @@ internal IEnumerable<string> GetResolvedAssemblyReferenceItemSpecs()
         /// <param name="outputDirectory">Directory the interop DLL should be written to</param>
         /// <param name="refName">Name of reference</param>
         /// <param name="topLevelRef">True if this is a top-level reference</param>
+        /// <param name="dependencyPaths">List of dependency paths for that reference</param>
         /// <param name="wrapperInfo">Information about wrapper locations</param>
         /// <returns>True if the reference was already found or successfully generated, false otherwise.</returns>
         internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outputDirectory, string refName, bool topLevelRef, List<string> dependencyPaths, out ComReferenceWrapperInfo wrapperInfo)
@@ -1333,7 +1334,7 @@ internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outp
                     {
                         // conflicting typelib names for different typelibs? generate a temporary wrapper
                         if (!ComReference.AreTypeLibAttrEqual(referenceInfo.attr, projectRefInfo.attr) &&
-                            String.Compare(referenceInfo.typeLibName, projectRefInfo.typeLibName, StringComparison.OrdinalIgnoreCase) == 0)
+                            String.Equals(referenceInfo.typeLibName, projectRefInfo.typeLibName, StringComparison.OrdinalIgnoreCase))
                         {
                             isTemporary = true;
                         }
@@ -1619,7 +1620,7 @@ internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List<ITaskItem> outputTa
                 if (_projectTargetFramework != null && (_projectTargetFramework >= s_targetFrameworkVersion_40))
                 {
                     if ((embedInteropTypesMetadata != null) &&
-                        (String.Compare(embedInteropTypesMetadata, "true", StringComparison.OrdinalIgnoreCase) == 0))
+                        (String.Equals(embedInteropTypesMetadata, "true", StringComparison.OrdinalIgnoreCase)))
                     {
                         // Embed Interop Types forces CopyLocal to false
                         taskItem.SetMetadata(ItemMetadataNames.copyLocal, "false");
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index afe188b2a7d..f6741aa36d2 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -101,7 +101,7 @@ private bool ResolveAssemblyKey()
                 }
                 if (pfxSuccess)
                 {
-                    if (0 != String.Compare(keyFileExtension, pfxFileExtension, StringComparison.OrdinalIgnoreCase))
+                    if (!String.Equals(keyFileExtension, pfxFileExtension, StringComparison.OrdinalIgnoreCase))
                     {
                         ResolvedKeyFile = KeyFile;
                     }
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 8c657f606dc..ab41808f881 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -17,7 +17,7 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// This task resolves items in the build process (built, dependencies, satellites,
     /// content, debug symbols, documentation, etc.) to files for manifest generation.
-    /// </Summary>
+    /// </summary>
     /// <comment>
     /// This task executes following steps:
     ///   (1) Filter out Framework assemblies
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 0170382a0a6..ade412a266b 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -144,7 +144,7 @@ public override bool Execute()
                     }
                     catch (Exception)
                     {
-                        Debug.Assert(false, "Unexpected exception in ResolveNativeReference.Execute. " + 
+                        Debug.Assert(false, "Unexpected exception in ResolveNativeReference.Execute. " +
                             "Please log a MSBuild bug specifying the steps to reproduce the problem.");
                         throw;
                     }
diff --git a/src/Tasks/ResolveNonMSBuildProjectOutput.cs b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
index 9c527a294b2..790fe7fab92 100644
--- a/src/Tasks/ResolveNonMSBuildProjectOutput.cs
+++ b/src/Tasks/ResolveNonMSBuildProjectOutput.cs
@@ -11,14 +11,14 @@
 namespace Microsoft.Build.Tasks
 {
     /// <remarks>
-    /// This task determines the output files for non-MSBuild project references. We look inside 
+    /// This task determines the output files for non-MSBuild project references. We look inside
     /// a special property set by the VS IDE for the list of project guids and their associated outputs.
     /// While there's nothing that would prevent resolution of MSBuild projects in this task, the IDE
     /// only pre-resolves non-MSBuild projects so that we can separate MSBuild project references from
     /// non-MSBuild ones and return the list of MSBuild projects as UnresolvedProjectReferences.
-    /// Then we can use more powerful MSBuild mechanisms to manipulate just the MSBuild project 
-    /// references (i.e. calling into specific targets of references to get the manifest file name) 
-    /// which would not be possible with a mixed list of MSBuild & non-MSBuild references.
+    /// Then we can use more powerful MSBuild mechanisms to manipulate just the MSBuild project
+    /// references (i.e. calling into specific targets of references to get the manifest file name)
+    /// which would not be possible with a mixed list of MSBuild and non-MSBuild references.
     /// </remarks>
     public class ResolveNonMSBuildProjectOutput : ResolveProjectBase
     {
@@ -155,9 +155,10 @@ public override bool Execute()
         #region Methods
 
         /// <summary>
-        /// Given a project reference task item and an XML document containing pre-resolved output paths, 
+        /// Given a project reference task item and an XML document containing pre-resolved output paths,
         /// find the output path for that task item.
         /// </summary>
+        /// <param name="projectRef">project reference to resolve</param>
         /// <param name="resolvedPath">resulting ITaskItem containing the resolved path</param>
         /// <returns>true if resolved successfully</returns>
         internal bool ResolveProject(ITaskItem projectRef, out ITaskItem resolvedPath)
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 63b25008500..51ddc6acde9 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -140,7 +140,7 @@ public string TargetPlatformIdentifier
         {
             get
             {
-                _targetPlatformIdentifier = _targetPlatformIdentifier ?? String.Empty;
+                _targetPlatformIdentifier ??= String.Empty;
                 return _targetPlatformIdentifier;
             }
 
@@ -155,7 +155,7 @@ public string ProjectName
         {
             get
             {
-                _projectName = _projectName ?? String.Empty;
+                _projectName ??= String.Empty;
                 return _projectName;
             }
 
@@ -241,7 +241,7 @@ private Version TargetPlatformAsVersion
         {
             get
             {
-                _targetPlatformVersion = _targetPlatformVersion ?? s_defaultTargetPlatformVersion;
+                _targetPlatformVersion ??= s_defaultTargetPlatformVersion;
                 return _targetPlatformVersion;
             }
 
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index 1ba945d1c76..06437e4493b 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -264,7 +264,7 @@ private static void AddLinkedResource(string resxFilename, bool pathsRelativeToB
         /// </summary>
         /// <remarks>
         /// We can't hard-code byte[] type name due to version number
-        /// updates & potential whitespace issues with ResX files.
+        /// updates and potential whitespace issues with ResX files.
         ///
         /// Comment and logic from https://github.com/dotnet/winforms/blob/16b192389b377c647ab3d280130781ab1a9d3385/src/System.Windows.Forms/src/System/Resources/ResXDataNode.cs#L411-L416
         /// </remarks>
diff --git a/src/Tasks/SdkToolsPathUtility.cs b/src/Tasks/SdkToolsPathUtility.cs
index cf37031dcda..d22e4f7138f 100644
--- a/src/Tasks/SdkToolsPathUtility.cs
+++ b/src/Tasks/SdkToolsPathUtility.cs
@@ -10,8 +10,8 @@
 namespace Microsoft.Build.Tasks
 {
     /// <summary>
-    /// This class will provide the ability for classes given an SdkToolsPath and their tool name to find that tool. 
-    /// The tool will be looked for either under the SDKToolPath passed into the task or as fallback to look for the toolname using the toolslocation helper. 
+    /// This class will provide the ability for classes given an SdkToolsPath and their tool name to find that tool.
+    /// The tool will be looked for either under the SDKToolPath passed into the task or as fallback to look for the toolname using the toolslocation helper.
     /// </summary>
     internal static class SdkToolsPathUtility
     {
@@ -38,10 +38,10 @@ internal static FileExists FileInfoExists
 
         /// <summary>
         /// This method will take a sdkToolsPath and a toolName and return the path to the tool if it is found and exists.
-        /// 
+        ///
         /// First the method will try and find the tool under the sdkToolsPath taking into account the current processor architecture
         /// If the tool could not be found the method will try and find the tool under the sdkToolsPath (which should point to the x86 sdk directory).
-        /// 
+        ///
         /// Finally if the method has not found the tool yet it will fallback and use the toolslocation helper method to try and find the tool.
         /// </summary>
         /// <returns>Path including the toolName of the tool if found, null if it is not found</returns>
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 08f4516bc67..f1f44758e60 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -255,8 +255,7 @@ internal SystemState(SerializationInfo info, StreamingContext context)
         /// This is used to optimize IO in the case of files requested from one 
         /// of the FX folders.
         /// </summary>
-        /// <param name="providedFrameworkPaths"></param>
-        /// <param name="installedAssemblyTables"></param>
+        /// <param name="installedAssemblyTableInfos"></param>
         internal void SetInstalledAssemblyInformation
         (
             AssemblyTableInfo[] installedAssemblyTableInfos
diff --git a/src/Tasks/TlbImp.cs b/src/Tasks/TlbImp.cs
index dbcd83aae6f..09ea0b232e0 100644
--- a/src/Tasks/TlbImp.cs
+++ b/src/Tasks/TlbImp.cs
@@ -12,7 +12,7 @@ public sealed partial class ResolveComReference
     {
         /// <summary>
         /// Passed to the "Transform" property on the TlbImp task to indicate
-        /// what transforms, if any, to apply to the type library during 
+        /// what transforms, if any, to apply to the type library during
         /// assembly generation
         /// </summary>
         internal enum TlbImpTransformFlags
@@ -35,7 +35,7 @@ internal enum TlbImpTransformFlags
         }
 
         /// <summary>
-        /// Defines the "TlbImp" MSBuild task, which enables using TlbImp.exe 
+        /// Defines the "TlbImp" MSBuild task, which enables using TlbImp.exe
         /// to generate assemblies from type libraries.
         /// </summary>
         internal class TlbImp : AxTlbBaseTask
@@ -296,7 +296,7 @@ private TlbImpTransformFlags GetTlbImpTransformFlagsParameterWithDefault(string
             }
 
             /// <summary>
-            /// Verifies that an allowed combination of TlbImpTransformFlags has been 
+            /// Verifies that an allowed combination of TlbImpTransformFlags has been
             /// passed to the Transform property.
             /// </summary>
             /// <returns>True if Transform is valid and false otherwise</returns>
@@ -318,7 +318,7 @@ private bool ValidateTransformFlags()
             }
 
             /// <summary>
-            /// Converts a given flag to the equivalent parameter passed to the /transform: 
+            /// Converts a given flag to the equivalent parameter passed to the /transform:
             /// option of tlbimp.exe
             /// </summary>
             /// <param name="flags">The TlbImpTransformFlags being converted</param>
diff --git a/src/Tasks/TlbReference.cs b/src/Tasks/TlbReference.cs
index 5cf76a06636..c6cc0e606b9 100644
--- a/src/Tasks/TlbReference.cs
+++ b/src/Tasks/TlbReference.cs
@@ -34,16 +34,23 @@ internal class TlbReference : AxTlbBaseReference, ITypeLibImporterNotifySink
         /// internal constructor
         /// </summary>
         /// <param name="taskLoggingHelper">task logger instance used for logging</param>
+        /// <param name="silent">true if this task should log only errors, no warnings or messages; false otherwise</param>
         /// <param name="resolverCallback">callback interface for resolving dependent COM refs/NET assemblies</param>
+        /// <param name="referenceFiles">List of referenc files</param>
         /// <param name="referenceInfo">cached reference information (typelib pointer, original task item, typelib name etc.)</param>
         /// <param name="itemName">reference name (for better logging experience)</param>
         /// <param name="outputDirectory">directory we should write the wrapper to</param>
+        /// <param name="hasTemporaryWrapper">Whether it has a temporary wrapper</param>
         /// <param name="delaySign">delay sign wrappers?</param>
         /// <param name="keyFile">file containing public/private keys</param>
         /// <param name="keyContainer">container name for public/private keys</param>
+        /// <param name="noClassMembers">Whether it has no class members</param>
+        /// <param name="targetProcessorArchitecture">Architecture to seek.</param>
+        /// <param name="includeTypeLibVersionInName">True if the interop name should include the typelib's version</param>
         /// <param name="executeAsTool">True if GenerateWrapper() should generate the wrapper out-of-proc using tlbimp.exe</param>
         /// <param name="sdkToolsPath">Path to the SDK tools directory where tlbimp.exe can be found</param>
         /// <param name="buildEngine">BuildEngine of parent task; needed for logging purposes when generating wrapper out-of-proc</param>
+        /// <param name="environmentVariables">Array of equals-separated pairs of environment variables that should be passed to the spawned executable, in addition to (or selectively overriding) the regular environment block.</param>
         internal TlbReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, IEnumerable<string> referenceFiles, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool hasTemporaryWrapper,
             bool delaySign, string keyFile, string keyContainer, bool noClassMembers, string targetProcessorArchitecture, bool includeTypeLibVersionInName, bool executeAsTool, string sdkToolsPath, IBuildEngine buildEngine, string[] environmentVariables)
             : base(taskLoggingHelper, silent, resolverCallback, referenceInfo, itemName, outputDirectory, delaySign, keyFile, keyContainer, includeTypeLibVersionInName, executeAsTool, sdkToolsPath, buildEngine, environmentVariables)
@@ -171,7 +178,7 @@ internal bool GenerateWrapper(out ComReferenceWrapperInfo wrapperInfo)
                     // that the set of references will also contain the file that is meant to be written here (when reference resolution
                     // found the file in the output folder). We need to filter out this case.
                     var fullPathToOutput = Path.GetFullPath(wrapperPath); // Current directory is the directory of the project file.
-                    tlbImp.ReferenceFiles = _referenceFiles.Where(rf => String.Compare(fullPathToOutput, rf, StringComparison.OrdinalIgnoreCase) != 0).ToArray();
+                    tlbImp.ReferenceFiles = _referenceFiles.Where(rf => !String.Equals(fullPathToOutput, rf, StringComparison.OrdinalIgnoreCase)).ToArray();
                 }
 
                 switch (_targetProcessorArchitecture)
diff --git a/src/Tasks/ToolTaskExtension.cs b/src/Tasks/ToolTaskExtension.cs
index d9c1238bb32..b421c0253a8 100644
--- a/src/Tasks/ToolTaskExtension.cs
+++ b/src/Tasks/ToolTaskExtension.cs
@@ -91,7 +91,6 @@ protected internal int GetIntParameterWithDefault(string parameterName, int defa
         /// Will only be called if the task returned a non empty string from GetResponseFileCommands
         /// Called after ValidateParameters, SkipTaskExecution and GetResponseFileCommands
         /// </summary>
-        /// <param name="responseFilePath">full path to the temporarily created response file</param>
         /// <returns></returns>
         protected override string GenerateResponseFileCommands()
         {
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index acaa9cb6dd3..71be097965b 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -102,7 +102,7 @@ public override bool Execute()
                     OutputFile = new TaskItem(Path.Combine(OutputDirectory.ItemSpec, OutputFile.ItemSpec));
                 }
 
-                OutputFile = OutputFile ?? new TaskItem(FileUtilities.GetTemporaryFile(OutputDirectory.ItemSpec, extension));
+                OutputFile ??= new TaskItem(FileUtilities.GetTemporaryFile(OutputDirectory.ItemSpec, extension));
 
                 File.WriteAllText(OutputFile.ItemSpec, code); // Overwrites file if it already exists (and can be overwritten)
             }
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index 2ca1d976b8d..41d74bb1934 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -327,8 +327,8 @@ internal bool HasSwitch(string propertyName)
         }
 
         /// <summary>
-        /// Returns true if the property exists (regardless of whether it is 
-        /// set or not) and false otherwise. 
+        /// Returns true if the property exists (regardless of whether it is
+        /// set or not) and false otherwise.
         /// </summary>
         internal bool PropertyExists(string propertyName)
         {
@@ -526,10 +526,10 @@ private string GatherArguments(string parentSwitch, ICollection<Tuple<string, bo
                     {
                         if (!String.IsNullOrEmpty(retVal))
                         {
-                            retVal = retVal + separator;
+                            retVal += separator;
                         }
 
-                        retVal = retVal + argSwitch.Value;
+                        retVal += argSwitch.Value;
                     }
                     else
                     {
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index f6a3506e981..1f7722260d3 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -109,7 +109,7 @@ internal class RelationsParser
         private const string switchAttribute = "SWITCH";
 
         #endregion
-        
+
         #region Properties
 
         /// <summary>
@@ -529,7 +529,7 @@ private static bool ParseSwitch(XmlNode node, Dictionary<string, SwitchRelations
         }
 
         /// <summary>
-        /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for 
+        /// Gets all the attributes assigned in the xml file for this parameter or all of the nested switches for
         /// this parameter group
         /// </summary>
         private static SwitchRelations ObtainAttributes(XmlNode node, SwitchRelations switchGroup)
@@ -572,7 +572,7 @@ private void LogError(string messageResourceName, params object[] messageArgs)
         }
 
         /// <summary>
-        /// An XML document can have many root nodes, but usually we want the single root 
+        /// An XML document can have many root nodes, but usually we want the single root
         /// element. Callers can test each root node in turn with this method, until it returns
         /// true.
         /// </summary>
diff --git a/src/Tasks/XamlTaskFactory/TaskGenerator.cs b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
index ad88b5c4039..b0aeb1c7198 100644
--- a/src/Tasks/XamlTaskFactory/TaskGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/TaskGenerator.cs
@@ -420,7 +420,7 @@ internal CodeCompileUnit GenerateCode()
         }
 
         /// <summary>
-        /// Generates a method called "AddDefaultsToActiveSwitchList" that takes all of the properties that have 
+        /// Generates a method called "AddDefaultsToActiveSwitchList" that takes all of the properties that have
         /// default values and adds them to the active switch list
         /// </summary>
         private void GenerateDefaultSetProperties(CodeTypeDeclaration taskClass)
@@ -469,7 +469,7 @@ private void GenerateDefaultSetProperties(CodeTypeDeclaration taskClass)
         }
 
         /// <summary>
-        /// Generates a method called "AddFallbacksToActiveSwitchList" that takes all of the properties that 
+        /// Generates a method called "AddFallbacksToActiveSwitchList" that takes all of the properties that
         /// are not set but have fallbacks and adds the fallbacks to the active list if they are set.
         /// </summary>
         private void GenerateFallbacks(CodeTypeDeclaration taskClass)
@@ -992,7 +992,7 @@ private bool ContainsCurrentPlatform(string SwitchValue)
         }
 
         /// <summary>
-        /// This method generates overrides array 
+        /// This method generates overrides array
         /// </summary>
         private void GenerateOverrides(Property property, CodeMemberProperty propertyName)
         {
@@ -1171,7 +1171,7 @@ private void GenerateRelations(CodeTypeDeclaration taskClass)
                     if (switchRelations.Value.Requires.Count > 0)
                     {
                         var checkRequired = new CodeConditionStatement { Condition = null };
-                        
+
                         foreach (string required in switchRelations.Value.Requires)
                         {
                             if (checkRequired.Condition != null)
diff --git a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
index bbd77b0b8a2..a6483ae584e 100644
--- a/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
+++ b/src/Tasks/XamlTaskFactory/XamlDataDrivenToolTask.cs
@@ -234,7 +234,7 @@ internal void ValidateOverrides()
             {
                 foreach (KeyValuePair<string, string> overridePair in overriddenSwitch.Value.Overrides)
                 {
-                    if (String.Equals(overridePair.Key, (overriddenSwitch.Value.Type == CommandLineToolSwitchType.Boolean && overriddenSwitch.Value.BooleanValue == false) ? overriddenSwitch.Value.ReverseSwitchValue.TrimStart('/') : overriddenSwitch.Value.SwitchValue.TrimStart('/'), StringComparison.OrdinalIgnoreCase))
+                    if (String.Equals(overridePair.Key, (overriddenSwitch.Value.Type == CommandLineToolSwitchType.Boolean && !overriddenSwitch.Value.BooleanValue) ? overriddenSwitch.Value.ReverseSwitchValue.TrimStart('/') : overriddenSwitch.Value.SwitchValue.TrimStart('/'), StringComparison.OrdinalIgnoreCase))
                     {
                         foreach (KeyValuePair<string, CommandLineToolSwitch> overrideTarget in ActiveToolSwitches)
                         {
@@ -245,7 +245,7 @@ internal void ValidateOverrides()
                                     overriddenSwitches.Add(overrideTarget.Key);
                                     break;
                                 }
-                                else if ((overrideTarget.Value.Type == CommandLineToolSwitchType.Boolean) && (overrideTarget.Value.BooleanValue == false) && String.Equals(overrideTarget.Value.ReverseSwitchValue.TrimStart('/'), overridePair.Value, StringComparison.OrdinalIgnoreCase))
+                                else if ((overrideTarget.Value.Type == CommandLineToolSwitchType.Boolean) && (!overrideTarget.Value.BooleanValue) && String.Equals(overrideTarget.Value.ReverseSwitchValue.TrimStart('/'), overridePair.Value, StringComparison.OrdinalIgnoreCase))
                                 {
                                     overriddenSwitches.Add(overrideTarget.Key);
                                     break;
diff --git a/src/Utilities.UnitTests/PlatformManifest_Tests.cs b/src/Utilities.UnitTests/PlatformManifest_Tests.cs
index 8e0e38be62d..79522881a6c 100644
--- a/src/Utilities.UnitTests/PlatformManifest_Tests.cs
+++ b/src/Utilities.UnitTests/PlatformManifest_Tests.cs
@@ -54,7 +54,7 @@ public void EmptyManifestLocation()
         }
 
         /// <summary>
-        /// Should get a read error when the manifest location is valid but doesn't have a 
+        /// Should get a read error when the manifest location is valid but doesn't have a
         /// file named Platform.xml
         /// </summary>
         [Fact]
@@ -80,7 +80,7 @@ public void ManifestLocationHasNoPlatformXml()
         }
 
         /// <summary>
-        /// Should get a read error when trying to read an invalid manifest file. 
+        /// Should get a read error when trying to read an invalid manifest file.
         /// </summary>
         [Fact]
         public void InvalidManifest()
@@ -94,7 +94,7 @@ public void InvalidManifest()
         }
 
         /// <summary>
-        /// Verify that a simple PlatformManifest can be successfully constructed. 
+        /// Verify that a simple PlatformManifest can be successfully constructed.
         /// </summary>
         [Fact]
         public void SimpleValidManifest()
@@ -114,8 +114,8 @@ public void SimpleValidManifest()
         }
 
         /// <summary>
-        /// Verify that a simple PlatformManifest can be successfully constructed, even if it's missing 
-        /// some fields. 
+        /// Verify that a simple PlatformManifest can be successfully constructed, even if it's missing
+        /// some fields.
         /// </summary>
         [Fact]
         public void SimpleValidManifestWithMissingFriendlyName()
@@ -135,8 +135,8 @@ public void SimpleValidManifestWithMissingFriendlyName()
         }
 
         /// <summary>
-        /// Platform manifest with a dependent platform missing some information. 
-        /// NOTE: probably ought to be an error. 
+        /// Platform manifest with a dependent platform missing some information.
+        /// NOTE: probably ought to be an error.
         /// </summary>
         [Fact]
         public void DependentPlatformMissingName()
@@ -188,8 +188,8 @@ public void MultipleDependentPlatforms()
         }
 
         /// <summary>
-        /// Platform manifest with a contract missing some information. 
-        /// NOTE: technically probably ought to be an error. 
+        /// Platform manifest with a contract missing some information.
+        /// NOTE: technically probably ought to be an error.
         /// </summary>
         [Fact]
         public void ContractMissingVersion()
@@ -218,7 +218,7 @@ public void ContractMissingVersion()
         }
 
         /// <summary>
-        /// Verify a platform manifest with API contracts. 
+        /// Verify a platform manifest with API contracts.
         /// </summary>
         [Fact]
         public void MultipleContracts()
@@ -301,8 +301,8 @@ public void VersionedContentTrueFlagReturnsTrue()
         }
 
         /// <summary>
-        /// Wrapper around PlatformManifest that creates one with the specified content in 
-        /// the temporary directory and deletes it on disposal. 
+        /// Wrapper around PlatformManifest that creates one with the specified content in
+        /// the temporary directory and deletes it on disposal.
         /// </summary>
         private sealed class TemporaryPlatformManifest : IDisposable
         {
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index 8d1d8b74063..d94dc519c00 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -4677,52 +4677,52 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "Windows", "MyPlatform" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "v1.0", "1.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "v1.1", "1.0", "2.0", "3.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "2.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "4.0", "5.0", "6.0", "9.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { string.Empty };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "1.0" };
                 }
@@ -4730,22 +4730,22 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "Windows" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "v2.0" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "MyAssembly" };
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly", StringComparison.OrdinalIgnoreCase))
                 {
                     return new[] { "3.0" };
                 }
@@ -4765,54 +4765,54 @@ private string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string subKey)
         {
             if (baseKey == Registry.CurrentUser)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\v1.0\\ExtensionSDKs\\MyAssembly\\1.0");
                 }
 
                 // This has a v in the sdk version and should not be found but we need a real path in case it is so it will show up in the returned list and fail the test.
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\v1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\v1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\v1.0\\ExtensionSDKs\\MyAssembly\\1.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly\2.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\1.0\ExtensionSDKs\MyAssembly\2.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\1.0\\ExtensionSDKs\\MyAssembly\\2.0");
                 }
 
                 // This has a set of bad char in the returned directory so it should not be allowed.
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return _fakeStructureRoot + @"\Windows\1.0\ExtensionSDKs\MyAssembly\<>?/";
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\5.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "MyPlatform\\5.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "SomeOtherPlace\\MyPlatformOtherLocation\\4.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\6.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\6.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows Kits\\6.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\9.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\9.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "MyPlatform\\9.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\MyPlatform\4.0\ExtensionSDKs\MyAssembly\1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "SomeOtherPlace\\MyPlatformOtherLocation\\4.0\\ExtensionSDKs\\MyAssembly\\1.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v1.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\1.0");
                 }
@@ -4820,12 +4820,12 @@ private string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string subKey)
 
             if (baseKey == Registry.LocalMachine)
             {
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0\ExtensionSDKs\MyAssembly\3.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\2.0\\ExtensionSDKs\\MyAssembly\\3.0");
                 }
 
-                if (string.Compare(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0", StringComparison.OrdinalIgnoreCase) == 0)
+                if (string.Equals(subKey, @"Software\Microsoft\MicrosoftSDKs\Windows\v2.0", StringComparison.OrdinalIgnoreCase))
                 {
                     return Path.Combine(_fakeStructureRoot, "Windows\\2.0");
                 }
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index 1ab61732c78..c71b51aaed0 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -1408,7 +1408,7 @@ public void InProcTrackingStartProcessFindStrNullCommandLine()
                 startInfo.hStdInput = BackEndNativeMethods.InvalidHandle;
                 startInfo.hStdOutput = BackEndNativeMethods.InvalidHandle;
                 startInfo.dwFlags = BackEndNativeMethods.STARTFUSESTDHANDLES;
-                dwCreationFlags = dwCreationFlags | BackEndNativeMethods.CREATENOWINDOW;
+                dwCreationFlags |= BackEndNativeMethods.CREATENOWINDOW;
 
                 BackEndNativeMethods.SECURITY_ATTRIBUTES pSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
                 BackEndNativeMethods.SECURITY_ATTRIBUTES tSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
@@ -2392,7 +2392,7 @@ private static void LaunchDuplicateToolsAndVerifyTlogExistsForEach(string tlogPa
                 startInfo.hStdInput = BackEndNativeMethods.InvalidHandle;
                 startInfo.hStdOutput = BackEndNativeMethods.InvalidHandle;
                 startInfo.dwFlags = BackEndNativeMethods.STARTFUSESTDHANDLES;
-                dwCreationFlags = dwCreationFlags | BackEndNativeMethods.CREATENOWINDOW;
+                dwCreationFlags |= BackEndNativeMethods.CREATENOWINDOW;
 
                 BackEndNativeMethods.SECURITY_ATTRIBUTES pSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
                 BackEndNativeMethods.SECURITY_ATTRIBUTES tSec = new BackEndNativeMethods.SECURITY_ATTRIBUTES();
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index da224e554e7..cb671c25576 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -1210,7 +1210,7 @@ public void MultipleCanonicalCLMissingOutputDependencyRemoved()
             compactOutputs.SaveTlog(delegate (string fullTrackedPath)
             {
                 // We need to answer the question "should fullTrackedPath be included in the TLog?"
-                return (string.Compare(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase) != 0);
+                return (!string.Equals(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase));
             });
 
             // Read the Tlogs back in..
@@ -1279,7 +1279,7 @@ public void MultipleCanonicalCLMissingInputDependencyRemoved()
             d.SaveTlog(delegate (string fullTrackedPath)
             {
                 // We need to answer the question "should fullTrackedPath be included in the TLog?"
-                return (string.Compare(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase) != 0);
+                return (!string.Equals(fullTrackedPath, missing, StringComparison.OrdinalIgnoreCase));
             });
 
             // read the tlog back in again
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index a7c19160911..429a215a58a 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -264,7 +264,7 @@ string metadataValue
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(metadataName),
                 "Shared.CannotChangeItemSpecModifiers", metadataName);
 
-            _metadata = _metadata ?? new CopyOnWriteDictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
+            _metadata ??= new CopyOnWriteDictionary<string, string>(MSBuildNameIgnoreCaseComparer.Default);
 
             _metadata[metadataName] = metadataValue ?? string.Empty;
         }
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 1be6fed6892..3d690398f9f 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -125,7 +125,7 @@ public enum TargetDotNetFrameworkVersion
     }
 
     /// <summary>
-    /// Used to specify the version of Visual Studio from which to select associated 
+    /// Used to specify the version of Visual Studio from which to select associated
     /// tools for some methods of ToolLocationHelper
     /// </summary>
     public enum VisualStudioVersion
@@ -168,7 +168,7 @@ public enum VisualStudioVersion
     public enum DotNetFrameworkArchitecture
     {
         /// <summary>
-        /// Indicates the .NET Framework that is currently being run under.  
+        /// Indicates the .NET Framework that is currently being run under.
         /// </summary>
         Current = 0,
 
@@ -208,7 +208,7 @@ public static class ToolLocationHelper
         private static Dictionary<string, IList<string>> s_cachedReferenceAssemblyPaths;
 
         /// <summary>
-        /// Cache the frameworkName of the highest version of a framework given its root path and identifier. 
+        /// Cache the frameworkName of the highest version of a framework given its root path and identifier.
         /// This is to optimize calls to GetHighestVersionOfTargetFramework
         /// </summary>
         private static Dictionary<string, FrameworkNameVersioning> s_cachedHighestFrameworkNameForTargetFrameworkIdentifier;
@@ -231,7 +231,7 @@ public static class ToolLocationHelper
         private static Dictionary<string, string> s_cachedTargetFrameworkDisplayNames;
 
         /// <summary>
-        /// Cache the set of target platform references for a particular combination of inputs.  For legacy 
+        /// Cache the set of target platform references for a particular combination of inputs.  For legacy
         /// target platforms, this is just grabbing all winmds from the References\CommonConfiguration\Neutral
         /// folder; for OneCore-based platforms, this involves reading the list from Platform.xml and synthesizing
         /// the locations.
@@ -279,14 +279,14 @@ public static class ToolLocationHelper
         #region Public methods
 
         /// <summary>
-        /// The current ToolsVersion. 
+        /// The current ToolsVersion.
         /// </summary>
         public static string CurrentToolsVersion => MSBuildConstants.CurrentToolsVersion;
 
 #if FEATURE_WIN32_REGISTRY
         /// <summary>
         /// Get a sorted list of AssemblyFoldersExInfo which contain information about what directories the 3rd party assemblies are registered under for use during build and design time.
-        /// 
+        ///
         /// This method will enumerate the AssemblyFoldersEx registry location and return a list of AssemblyFoldersExInfo in the same order in which
         /// they will be searched during both design and build time for reference assemblies.
         /// </summary>
@@ -807,7 +807,7 @@ public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, strin
         /// <param name="targetPlatformMinVersion">The min version of the targeted platform</param>
         /// <param name="targetPlatformVersion">The version of the targeted platform</param>
         /// <param name="diskRoots">List of disk roots to search for sdks within</param>
-        /// <param name="registryRoot">Registry root to look for sdks within</param> 
+        /// <param name="registryRoot">Registry root to look for sdks within</param>
         /// <returns>Location of the target platform SDK props file without .props filename</returns>
         public static string GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot)
         {
@@ -1007,7 +1007,7 @@ private static string GetPlatformVersion(TargetPlatformSDK targetSdk, string tar
         }
 
         /// <summary>
-        /// Gathers the set of platform winmds based on the assumption that they come from 
+        /// Gathers the set of platform winmds based on the assumption that they come from
         /// an SDK that is specified solely by TPI / TPV.
         /// </summary>
         private static string[] GetLegacyTargetPlatformReferences(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot)
@@ -1056,7 +1056,7 @@ private static string[] GetLegacyTargetPlatformReferences(string targetPlatformI
         }
 
         /// <summary>
-        /// Gathers the set of platform winmds for a particular {SDKI, SDKV, TPI, TPMinV, TPV} combination, 
+        /// Gathers the set of platform winmds for a particular {SDKI, SDKV, TPI, TPMinV, TPV} combination,
         /// based on the assumption that it is an SDK that has both {SDKI, SDKV} and TP* specifiers.
         /// </summary>
         private static string[] GetTargetPlatformReferencesFromManifest
@@ -1184,7 +1184,7 @@ private static bool TryGetPlatformManifest(TargetPlatformSDK matchingSdk, string
         /// <param name="sdkVersion">The verision of the SDK</param>
         /// <param name="targetPlatformIdentifier">The identifier of the targeted platform</param>
         /// <param name="targetPlatformMinVersion">The min version of the targeted platform</param>
-        /// <param name="targetPlatformVersion">The version of the targeted platform</param> 
+        /// <param name="targetPlatformVersion">The version of the targeted platform</param>
         /// <param name="folderName">The content folder name under SDK path</param>
         /// <param name="diskRoot">An optional disk root to search.  A value should only be passed from a unit test.</param>
         /// <returns>The SDK content folder path</returns>
@@ -1294,12 +1294,12 @@ public static string GetPlatformSDKLocation(string targetPlatformIdentifier, str
         }
 
         /// <summary>
-        /// Given a target platform identifier and version, get the display name for that platform SDK. 
+        /// Given a target platform identifier and version, get the display name for that platform SDK.
         /// </summary>
         public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion) => GetPlatformSDKDisplayName(targetPlatformIdentifier, targetPlatformVersion, null, null);
 
         /// <summary>
-        /// Given a target platform identifier and version, get the display name for that platform SDK. 
+        /// Given a target platform identifier and version, get the display name for that platform SDK.
         /// </summary>
         public static string GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot)
         {
@@ -1515,9 +1515,9 @@ public static string FindRootFolderWhereAllFilesExist(string possibleRoots, stri
 
             return string.Empty;
         }
-        
+
         /// <summary>
-        /// Tries to parse the "version" out of a platformMoniker. 
+        /// Tries to parse the "version" out of a platformMoniker.
         /// </summary>
         /// <param name="platformMoniker">PlatformMoniker, in the form "PlatformName, Version=version"</param>
         /// <param name="platformVersion">The version of the platform, if the parse was successful - Else set to null</param>
@@ -1547,8 +1547,8 @@ private static bool TryParsePlatformVersion(string platformMoniker, out Version
         }
 
         /// <summary>
-        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK 
-        /// object that matches.  
+        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK
+        /// object that matches.
         /// </summary>
         private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string multiPlatformDiskRoots, string registryRoot)
         {
@@ -1575,7 +1575,7 @@ private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIde
         }
 
         /// <summary>
-        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK 
+        /// Given a target platform identifier and version and locations in which to search, find the TargetPlatformSDK
         /// object that matches.
         /// </summary>
         private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIdentifier, Version targetPlatformVersion, string[] diskRoots, string[] multiPlatformDiskRoots, string registryRoot)
@@ -1602,7 +1602,7 @@ private static TargetPlatformSDK GetMatchingPlatformSDK(string targetPlatformIde
         }
 
         /// <summary>
-        /// Given a target platform identifier and version, generate a reasonable default display name. 
+        /// Given a target platform identifier and version, generate a reasonable default display name.
         /// </summary>
         /// <param name="targetPlatformIdentifier"></param>
         /// <param name="targetPlatformVersion"></param>
@@ -1636,9 +1636,9 @@ public static string PathToSystem
 
         /// <summary>
         /// Returns the full name of the .NET Framework SDK root registry key.  When targeting .NET 3.5 or
-        /// above, looks in the locations associated with Visual Studio 2010.  If you wish to target the 
-        /// .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
-        /// specifies a VisualStudioVersion. 
+        /// above, looks in the locations associated with Visual Studio 2010.  If you wish to target the
+        /// .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that
+        /// specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion version) => GetDotNetFrameworkSdkRootRegistryKey(version, VisualStudioVersion.VersionLatest);
@@ -1656,10 +1656,10 @@ public static string GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkV
         }
 
         /// <summary>
-        /// Name of the value of GetDotNetFrameworkRootRegistryKey that contains the SDK install root path. When 
-        /// targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish 
-        /// to target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
-        /// that specifies a VisualStudioVersion. 
+        /// Name of the value of GetDotNetFrameworkRootRegistryKey that contains the SDK install root path. When
+        /// targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish
+        /// to target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override
+        /// that specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkVersion version) => GetDotNetFrameworkSdkInstallKeyValue(version, VisualStudioVersion.VersionLatest);
@@ -1684,7 +1684,7 @@ public static string GetDotNetFrameworkSdkInstallKeyValue(TargetDotNetFrameworkV
         public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion version) => GetPathToDotNetFramework(version, UtilitiesDotNetFrameworkArchitecture.Current);
 
         /// <summary>
-        /// Get a fully qualified path to the framework's root directory. 
+        /// Get a fully qualified path to the framework's root directory.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         /// <param name="architecture">Desired architecture, or DotNetFrameworkArchitecture.Current for the architecture this process is currently running under.</param>
@@ -1697,19 +1697,19 @@ public static string GetPathToDotNetFramework(TargetDotNetFrameworkVersion versi
         }
 
         /// <summary>
-        /// Returns the path to the "bin" directory of the latest .NET Framework SDK. When targeting .NET 3.5 
-        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target 
-        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
-        /// that specifies a VisualStudioVersion. 
+        /// Returns the path to the "bin" directory of the latest .NET Framework SDK. When targeting .NET 3.5
+        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target
+        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override
+        /// that specifies a VisualStudioVersion.
         /// </summary>
         /// <returns>Path string.</returns>
         public static string GetPathToDotNetFrameworkSdk() => GetPathToDotNetFrameworkSdk(TargetDotNetFrameworkVersion.Latest);
 
         /// <summary>
-        /// Returns the path to the "bin" directory of the .NET Framework SDK. When targeting .NET 3.5 
-        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target 
-        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override 
-        /// that specifies a VisualStudioVersion. 
+        /// Returns the path to the "bin" directory of the .NET Framework SDK. When targeting .NET 3.5
+        /// or above, looks in the locations associated with Visual Studio 2010.  If you wish to target
+        /// the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override
+        /// that specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="version">Version of the targeted .NET Framework</param>
         /// <returns>Path string.</returns>
@@ -2263,7 +2263,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkR
         }
 
         /// <summary>
-        /// Figures out a display name given the target framework details. 
+        /// Figures out a display name given the target framework details.
         /// This is the equivalent of the target framework moniker, but for display.
         /// If one cannot be found from the redist list file, a synthesized one is returned, so there is always a display name.
         /// </summary>
@@ -2941,7 +2941,7 @@ private static void ExtractSdkDiskRootsFromEnvironment(List<string> diskRoots, s
         }
 
         /// <summary>
-        /// Get the disk roots to search for both platform and extension sdks in. The environment variable can 
+        /// Get the disk roots to search for both platform and extension sdks in. The environment variable can
         /// override the defaults.
         /// </summary>
         /// <returns></returns>
@@ -2969,7 +2969,7 @@ private static List<string> GetTargetPlatformMonikerDiskRoots(string[] diskRoots
         }
 
         /// <summary>
-        /// Get the disk roots to search for multi platform extension sdks in. The environment variable can 
+        /// Get the disk roots to search for multi platform extension sdks in. The environment variable can
         /// override the defaults.
         /// </summary>
         private static List<string> GetExtensionSdkDiskRoots(string[] diskRoots)
@@ -3020,7 +3020,7 @@ private static string GetTargetPlatformMonikerRegistryRoots(string registryRootL
         }
 
         /// <summary>
-        /// Given a platform SDK object, populate its supported platforms. 
+        /// Given a platform SDK object, populate its supported platforms.
         /// </summary>
         private static void GatherPlatformsForSdk(TargetPlatformSDK sdk)
         {
@@ -3086,7 +3086,7 @@ private static void GatherPlatformsForSdk(TargetPlatformSDK sdk)
         }
 
         /// <summary>
-        /// Take the path to a reference assembly directory which contains a RedistList folder which then contains a FrameworkList.xml file. 
+        /// Take the path to a reference assembly directory which contains a RedistList folder which then contains a FrameworkList.xml file.
         /// We will read in the xml file and determine if it has an IncludedFramework element in the redist list. If it does it will calculate
         /// the path where the next link in the chain should be and return that path.
         /// Also, when reading the redist list, if any display name is found it will be cached, keyed off the path passed in.
@@ -3099,8 +3099,8 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
             lock (s_locker)
             {
                 // Cache the results of the chain search so that we do not have to do an expensive read more than once per process per redist list.
-                s_chainedReferenceAssemblyPath = s_chainedReferenceAssemblyPath ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                s_cachedTargetFrameworkDisplayNames = s_cachedTargetFrameworkDisplayNames ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                s_chainedReferenceAssemblyPath ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
+                s_cachedTargetFrameworkDisplayNames ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
                 if (s_chainedReferenceAssemblyPath.TryGetValue(path, out string cachedPath))
                 {
@@ -3245,9 +3245,9 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
 
         /// <summary>
         /// Get a fully qualified path to a file in the latest .NET Framework SDK. Error if the .NET Framework SDK can't be found.
-        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to 
-        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
-        /// specifies a VisualStudioVersion. 
+        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to
+        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that
+        /// specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
         /// <returns>Path string.</returns>
@@ -3255,9 +3255,9 @@ internal static string ChainReferenceAssemblyPath(string targetFrameworkDirector
 
         /// <summary>
         /// Get a fully qualified path to a file in the .NET Framework SDK. Error if the .NET Framework SDK can't be found.
-        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to 
-        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that 
-        /// specifies a VisualStudioVersion. 
+        /// When targeting .NET 3.5 or above, looks in the locations associated with Visual Studio 2010.  If you wish to
+        /// target the .NET Framework SDK that ships with Visual Studio Dev11 or later, please use the override that
+        /// specifies a VisualStudioVersion.
         /// </summary>
         /// <param name="fileName">File name to locate in the .NET Framework SDK directory</param>
         /// <param name="version">Version of the targeted .NET Framework</param>
@@ -3313,8 +3313,8 @@ public static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotN
         /// <param name="version">Version of the targeted .NET Framework</param>
         /// <param name="visualStudioVersion">Version of Visual Studio</param>
         /// <param name="architecture">The required architecture of the requested file.</param>
-        /// <param name="canFallBackIfNecessary">If true, will follow the fallback pattern -- from requested architecture, to 
-        /// current architecture, to x86.  Otherwise, if the requested architecture path doesn't exist, that's it -- no path 
+        /// <param name="canFallBackIfNecessary">If true, will follow the fallback pattern -- from requested architecture, to
+        /// current architecture, to x86.  Otherwise, if the requested architecture path doesn't exist, that's it -- no path
         /// will be returned.</param>
         /// <returns></returns>
         private static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDotNetFrameworkVersion version, VisualStudioVersion visualStudioVersion, UtilitiesDotNetFrameworkArchitecture architecture, bool canFallBackIfNecessary)
@@ -3349,7 +3349,7 @@ private static string GetPathToDotNetFrameworkSdkFile(string fileName, TargetDot
         }
 
         /// <summary>
-        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path. 
+        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path.
         /// If the fileName cannot be found in the pathToSDK after the processor architecture has been taken into account a null is returned.
         /// </summary>
         internal static string GetPathToDotNetFrameworkSdkFile(string fileName, string pathToSdk, string processorArchitecture)
@@ -3429,8 +3429,8 @@ internal static string ConvertDotNetFrameworkArchitectureToProcessorArchitecture
         }
 
         /// <summary>
-        /// Returns the path to the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that 
-        /// this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that
+        /// this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="version">Target .NET Framework version</param>
         /// <param name="visualStudioVersion">Version of Visual Studio associated with the SDK.</param>
@@ -3440,8 +3440,8 @@ public static string GetPathToWindowsSdk(TargetDotNetFrameworkVersion version, V
             => FrameworkLocationHelper.GetPathToWindowsSdk(TargetDotNetFrameworkVersionToSystemVersion(version));
 
         /// <summary>
-        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that 
-        /// this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version.  Note that
+        /// this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="fileName">The name of the file being requested.</param>
         /// <param name="version">Target .NET Framework version.</param>
@@ -3458,8 +3458,8 @@ public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFramew
             );
 
         /// <summary>
-        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired 
-        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired
+        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="fileName">The name of the file being requested.</param>
         /// <param name="version">Target .NET Framework version.</param>
@@ -3477,8 +3477,8 @@ public static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFramew
             );
 
         /// <summary>
-        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired 
-        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above. 
+        /// Returns the path to a file in the Windows SDK for the desired .NET Framework and Visual Studio version and the desired
+        /// architecture.  Note that this is only supported for a targeted .NET Framework version of 4.5 and above.
         /// </summary>
         /// <param name="fileName">The name of the file being requested.</param>
         /// <param name="version">Target .NET Framework version.</param>
@@ -3521,7 +3521,7 @@ private static string GetPathToWindowsSdkFile(string fileName, TargetDotNetFrame
         }
 
         /// <summary>
-        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path. 
+        /// Gets the path to a sdk exe based on the processor architecture and the provided bin directory path.
         /// If the fileName cannot be found in the pathToSDK after the processor architecture has been taken into account a null is returned.
         /// </summary>
         [Obsolete("Consider using GetPlatformSDKLocationFile instead")]
@@ -3589,23 +3589,23 @@ public static string GetPathToBuildTools(string toolsVersion, UtilitiesDotNetFra
         }
 
         /// <summary>
-        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild 
+        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild
         /// tools path for that ToolsVersion
         /// </summary>
         /// <param name="fileName">The file to find the path to</param>
         /// <param name="toolsVersion">The ToolsVersion in which to find the file</param>
-        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it 
+        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it
         /// exists, otherwise null.</returns>
         public static string GetPathToBuildToolsFile(string fileName, string toolsVersion) => GetPathToBuildToolsFile(fileName, toolsVersion, UtilitiesDotNetFrameworkArchitecture.Current);
 
         /// <summary>
-        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild 
+        /// Given the name of a file and a ToolsVersion, return the path to that file in the MSBuild
         /// tools path for that ToolsVersion
         /// </summary>
         /// <param name="fileName">The file to find the path to</param>
         /// <param name="toolsVersion">The ToolsVersion in which to find the file</param>
         /// <param name="architecture">The architecture of the build tools file to get</param>
-        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it 
+        /// <returns>The path to the file in the tools path folder of the appropriate ToolsVersion if it
         /// exists, otherwise null.</returns>
         public static string GetPathToBuildToolsFile(string fileName, string toolsVersion, UtilitiesDotNetFrameworkArchitecture architecture)
         {
@@ -3686,7 +3686,7 @@ public static IList<string> GetSupportedTargetFrameworks()
         }
 
         /// <summary>
-        /// This method will return the highest version of a target framework moniker based on the identifier. This method will only 
+        /// This method will return the highest version of a target framework moniker based on the identifier. This method will only
         /// find full frameworks, this means no profiles will be returned.
         /// </summary>
         public static FrameworkNameVersioning HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier)
@@ -3736,8 +3736,8 @@ public static FrameworkNameVersioning HighestVersionOfTargetFrameworkIdentifier(
         #region private methods
 
         /// <summary>
-        /// Converts a member of the Microsoft.Build.Utilities.DotNetFrameworkArchitecture enum to the equivalent member of the 
-        /// Microsoft.Build.Shared.DotNetFrameworkArchitecture enum. 
+        /// Converts a member of the Microsoft.Build.Utilities.DotNetFrameworkArchitecture enum to the equivalent member of the
+        /// Microsoft.Build.Shared.DotNetFrameworkArchitecture enum.
         /// </summary>
         private static SharedDotNetFrameworkArchitecture ConvertToSharedDotNetFrameworkArchitecture(UtilitiesDotNetFrameworkArchitecture architecture)
         {
@@ -3806,8 +3806,8 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                 {
                     if (programFilesReferenceAssemblyLocationFound &&
                         (
-                            string.Compare(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV30, StringComparison.OrdinalIgnoreCase) == 0
-                            || string.Compare(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV35, StringComparison.OrdinalIgnoreCase) == 0
+                            string.Equals(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV30, StringComparison.OrdinalIgnoreCase)
+                            || string.Equals(folder.Name, FrameworkLocationHelper.dotNetFrameworkVersionFolderPrefixV35, StringComparison.OrdinalIgnoreCase)
                         )
                        )
                     {
@@ -3815,7 +3815,7 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                         continue;
                     }
 
-                    if (string.Compare(folder.Name, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase) == 0)
+                    if (string.Equals(folder.Name, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase))
                     {
                         bFoundDotNetFrameworkIdentifier = true;
                     }
@@ -3824,9 +3824,9 @@ internal static IList<string> GetFrameworkIdentifiers(string frameworkReferenceR
                 }
             }
 
-            if (programFilesReferenceAssemblyLocationFound && bFoundDotNetFrameworkIdentifier == false)
+            if (programFilesReferenceAssemblyLocationFound && !bFoundDotNetFrameworkIdentifier)
             {
-                if (bAddDotNetFrameworkIdentifier == false)
+                if (!bAddDotNetFrameworkIdentifier)
                 {
                     // special case for .NETFramework v2.0 - check also in the framework path because v20 does not have reference
                     // assembly folders
@@ -3869,7 +3869,7 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
             //backward compatibility with orcas
             //In case of orcas .NETFramework v3.0, v3.5 - the version folders are directly under the frameworkReferenceRoot
             //first check here
-            if (string.Compare(frameworkIdentifier, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(frameworkIdentifier, FrameworkLocationHelper.dotNetFrameworkIdentifier, StringComparison.OrdinalIgnoreCase))
             {
                 IList<string> versions = GetFx35AndEarlierVersions(frameworkReferenceRoot);
                 if (versions.Count > 0)
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
index 5351c673e7c..a52909af113 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
@@ -23,7 +23,7 @@ internal static class CanonicalTrackedFilesHelper
         internal static bool RootContainsAllSubRootComponents(string compositeRoot, string compositeSubRoot)
         {
             // If the two are identical, then clearly all keys are present
-            if (string.Compare(compositeRoot, compositeSubRoot, StringComparison.OrdinalIgnoreCase) == 0)
+            if (string.Equals(compositeRoot, compositeSubRoot, StringComparison.OrdinalIgnoreCase))
             {
                 return true;
             }
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index d850f3309bb..acf941fba96 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -292,7 +292,7 @@ public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] output
             ErrorUtilities.VerifyThrowArgumentNull(sources, "sources");
 
             // So we don't have to deal with null checks.
-            outputs = outputs ?? Array.Empty<ITaskItem>();
+            outputs ??= Array.Empty<ITaskItem>();
 
             var rootSources = new List<string>(sources.Length + outputs.Length);
 
@@ -641,7 +641,7 @@ public static string TrackerArguments(string command, string arguments, string d
         /// <returns>Process instance</returns>
         public static Process StartProcess(string command, string arguments, ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName)
         {
-            dllName = dllName ?? GetFileTrackerPath(toolType);
+            dllName ??= GetFileTrackerPath(toolType);
 
             string fullArguments = TrackerArguments(command, arguments, dllName, intermediateDirectory, rootFiles, cancelEventName);
             return Process.Start(GetTrackerPath(toolType), fullArguments);
