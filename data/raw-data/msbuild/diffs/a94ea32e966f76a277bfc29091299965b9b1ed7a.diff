diff --git a/.config/git-merge-flow-config.jsonc b/.config/git-merge-flow-config.jsonc
index ddbff8a9297..0f5474173b2 100644
--- a/.config/git-merge-flow-config.jsonc
+++ b/.config/git-merge-flow-config.jsonc
@@ -30,8 +30,12 @@
         "vs17.12": {
             "MergeToBranch": "vs17.13"
         },
-        // MSBuild latest release to main
+        // Automate opening PRs to merge msbuild's vs17.13 (SDK 9.0.2xx) into vs17.14 (SDK 9.0.3xx)
         "vs17.13": {
+            "MergeToBranch": "vs17.14"
+        },
+        // MSBuild latest release to main
+        "vs17.14": {
             "MergeToBranch": "main"
         }
     }
diff --git a/.config/tsaoptions.json b/.config/tsaoptions.json
index 53a4a691178..3f3b1eb1cde 100644
--- a/.config/tsaoptions.json
+++ b/.config/tsaoptions.json
@@ -6,5 +6,6 @@
     "iterationPath": "DevDiv",
     "notificationAliases": [ "msbtm@microsoft.com" ],
     "repositoryName": "MSBuild",
-    "codebaseName": "MSBuild"
+    "codebaseName": "MSBuild",
+    "serviceTreeId": "d0ebbe59-0779-4466-8280-a0ff9cab5550"
 }
diff --git a/.editorconfig b/.editorconfig
index e64a0519df7..2927cad5369 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -216,7 +216,7 @@ dotnet_analyzer_diagnostic.category-Style.severity = warning
 dotnet_diagnostic.IDE0004.severity = suggestion
 
 # IDE0005: Remove unnecessary usings/imports
-dotnet_diagnostic.IDE0005.severity = none
+dotnet_diagnostic.IDE0005.severity = warning
 
 # Use explicit type instead of 'var'
 dotnet_diagnostic.IDE0008.severity = suggestion
diff --git a/.exp-insertions.yml b/.exp-insertions.yml
deleted file mode 100644
index dac0bddd22a..00000000000
--- a/.exp-insertions.yml
+++ /dev/null
@@ -1,236 +0,0 @@
-# Pipeline creates experimental msbuild insertions.
-
-trigger: none # Prevents this pipeline from triggering on check-ins
-pr: none # don't run this on PR as well
-
-parameters:
-  # Dotnet installer channel from which to take the latest dotnet bits.
-  - name: DotnetInstallerChannel
-    displayName: Dotnet installer channel
-    type: string
-    default: 'none'
-  # VS version for which to take the latest Retail MSBuild bits.
-  - name: VSVersionName
-    displayName: VS Version
-    type: string
-    default: 'none'
-  # Branch from the MSBuild Build CI pipeline. Default: main
-  # Top run for the branch would be used to create an experimental insertion.
-  - name: MSBuildBranch
-    displayName: MSBuild Branch
-    type: string
-    default: 'refs/heads/main'
-  # BuildID from the MSBuild Build CI pipeline. Overrides the choice of MSBuildBranch parameter
-  - name: MSBuildBuildID
-    displayName: MSBuild CI Run Override
-    type: string
-    default: 'default'
-
-variables:
-  - name: _MsBuildCiPipelineId
-    value: 9434
-  - name: _MSBuildConfigFilePathRequestURL
-    value: 'https://dev.azure.com/cloudbuild/CloudBuild/_apis/git/repositories/CloudBuildConfig/items?versionDescriptor.version=main&path=config/batmon/Q-Prod-Co3/Coordinator/ToolsReleaseConfig-GeneralPublic.json&api-version=5.0'
-  - name: VSVersion
-    value: ${{parameters.VSVersionName}}
-
-pool:
-  vmImage: windows-latest
-
-jobs:
-- job: CreateExpDotnet
-  displayName: Create Experimental Dotnet
-  condition: ne('${{ parameters.DotnetInstallerChannel }}', 'none')
-  steps:
-  - powershell: |
-      mkdir '$(System.ArtifactsDirectory)/installer'
-
-      $dotnetChannel = '${{parameters.DotnetInstallerChannel}}'
-      $sdks = "dotnet-sdk-win-x64.zip", "dotnet-sdk-linux-x64.tar.gz"
-
-      foreach ($sdk in $sdks)
-      {
-        Write-Host "Downloading dotnet $sdk from channel $dotnetChannel"
-        Invoke-WebRequest `
-          -Uri "https://aka.ms/dotnet/$dotnetChannel/daily/$sdk" `
-          -OutFile "$(System.ArtifactsDirectory)/installer/$sdk"
-      }
-      mkdir '$(Pipeline.Workspace)/artifacts'
-    displayName: Download latest dotnet sdks
-
-  - task: DownloadBuildArtifacts@1
-    inputs:
-      buildType: specific
-      project: DevDiv
-      pipeline: $(_MsBuildCiPipelineId)
-      ${{ if eq(parameters.MSBuildBuildID, 'default') }}:
-        buildVersionToDownload: latestFromBranch
-        branchName: '${{parameters.MSBuildBranch}}'
-      ${{ else }}:
-        buildVersionToDownload: specific
-        buildId: ${{parameters.MSBuildBuildID}}
-      artifactName: bin
-      itemPattern: 'MSBuild.Bootstrap/**'
-      downloadPath: '$(System.ArtifactsDirectory)/msbuild/artifacts/bin'
-    displayName: Download msbuild artifacts
-
-  - powershell: |
-      $sdk = "dotnet-sdk-win-x64"
-
-      Write-Host "Extracting $(System.ArtifactsDirectory)/installer/$sdk.zip"
-      Expand-Archive "$(System.ArtifactsDirectory)/installer/$sdk.zip" -DestinationPath "$(Pipeline.Workspace)/exp-dotnet/$sdk"
-
-      $dotnetDirectory = Get-ChildItem -Directory -Path "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk"
-      $dotnetVersion = $dotnetDirectory.Name
-      Write-Host "Detected dotnet version: $dotnetVersion"
-
-      Write-Host "Updating MSBuild dlls."
-      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
-        -destination "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk/$dotnetVersion" `
-        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
-        -configuration Release `
-        -makeBackup $false
-
-      Write-Host "Compressing dotnet sdk files"
-      Get-ChildItem -Path "$(Pipeline.Workspace)/exp-dotnet/$sdk" | Compress-Archive -DestinationPath "$(Pipeline.Workspace)/artifacts/$sdk.zip"
-
-    displayName: Dogfood msbuild dlls to dotnet sdk win-x64
-
-  - powershell: |
-      $sdk = "dotnet-sdk-linux-x64"
-
-      mkdir "$(Pipeline.Workspace)/exp-dotnet/$sdk"
-
-      Write-Host "Extracting $(System.ArtifactsDirectory)/installer/$sdk.tar.gz"
-      tar -xzvf "$(System.ArtifactsDirectory)/installer/$sdk.tar.gz" -C "$(Pipeline.Workspace)/exp-dotnet/$sdk"
-
-      $dotnetDirectory = Get-ChildItem -Directory -Path $(Pipeline.Workspace)/exp-dotnet/$sdk/sdk
-      $dotnetVersion = $dotnetDirectory.Name
-      Write-Host "Detected dotnet version: $dotnetVersion"
-
-      Write-Host "Updating MSBuild dlls."
-      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
-        -destination "$(Pipeline.Workspace)/exp-dotnet/$sdk/sdk/$dotnetVersion" `
-        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
-        -configuration Release `
-        -makeBackup $false
-
-      Write-Host "Compressing dotnet sdk files"
-      tar -czvf "$(Pipeline.Workspace)/artifacts/$sdk.tar.gz" -C "$(Pipeline.Workspace)/exp-dotnet/$sdk" .
-    displayName: Dogfood msbuild dlls to dotnet sdk linux-x64
-
-  - task: PublishPipelineArtifact@1
-    inputs:
-      targetPath: '$(Pipeline.Workspace)/artifacts'
-      artifactName: ExperimentalDotnet
-      parallel: true
-    condition: always()
-    displayName: Publish crank assests artifacts
-
-
-- job: CreateExpMSBuild
-  displayName: "Create Experimental MSBuild"
-  condition: ne('${{ parameters.VSVersionName }}', 'none')
-  steps:
-  - powershell: |
-      $token = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes("PAT:$env:ACCESSTOKEN"))
-      $headers = @{ Authorization = "Basic $token" };
-      $response = Invoke-RestMethod -Uri "$(_MSBuildConfigFilePathRequestURL)" -Headers $headers -Method Get
-      $MSBuildDropPath = $response.Tools.MSBuild.Locations
-      Write-Host "##vso[task.setvariable variable=MSBuildDropPath]$MSBuildDropPath"
-      Write-Host "MSBuild Drop Path directory: $MSBuildDropPath"
-    displayName: Get Retail MSBuild Drop Path
-    env:
-      ACCESSTOKEN: $(cloudbuild-token)
-
-  - task: NuGetToolInstaller@1
-    displayName: 'Install NuGet.exe'
-
-  - task: NuGetCommand@2
-    displayName: Restore internal tools
-    inputs:
-      command: restore
-      feedsToUse: config
-      restoreSolution: '$(Build.SourcesDirectory)\eng\common\internal\Tools.csproj'
-      nugetConfigPath: '$(Build.SourcesDirectory)\eng\common\internal\NuGet.config'
-      restoreDirectory: '$(Build.SourcesDirectory)\.packages'
-
-  # https://eng.ms/docs/cloud-ai-platform/devdiv/one-engineering-system-1es/1es-docs/1es-security-configuration/configuration-guides/pat-burndown-guidance#authentication-from-pipelines
-  # Requires Azure client 2.x
-  - task: AzureCLI@2
-    displayName: 'Set AzDO.DotnetPerfStarToken'
-    enabled: true
-    inputs:
-      azureSubscription: 'dotnet-perfstar at app.vssps.visualstudio.com'   # Azure DevOps service connection
-      scriptType: 'pscore'
-      scriptLocation: 'inlineScript'
-      inlineScript: |
-        # '499b84ac-1321-427f-aa17-267ca6975798' for Azure DevOps
-        $token = az account get-access-token --query accessToken --resource 499b84ac-1321-427f-aa17-267ca6975798 -o tsv
-        Write-Host "Setting AzDO.DotnetPerfStarToken"
-        Write-Host "##vso[task.setvariable variable=AzDO.DotnetPerfStarToken]${token}"
-
-  - powershell: |
-      mkdir "$(Pipeline.Workspace)/artifacts"
-
-      $dropAppDirectory = Get-ChildItem -Directory -Path "$(Build.SourcesDirectory)/.packages/drop.app"
-      $dropAppVersion = $dropAppDirectory.Name
-      Write-Host "Detected drop.exe version: $dropAppVersion"
-
-      $dropExePath = "$(Build.SourcesDirectory)/.packages/drop.app/$dropAppVersion/lib/net45/drop.exe"
-      Write-Host "Detected drop.exe path: $dropExePath"
-
-      Write-Host "Downloading VS msbuild"
-      $patAuthEnvVar = "patVariable"
-      & "$dropExePath" get --patAuthEnvVar $patAuthEnvVar -u "$(MSBuildDropPath)\$(VSVersion)" -d "$(System.ArtifactsDirectory)/VSMSBuildDrop"
-      Write-Host "Download of VS msbuild finished"
-
-      Write-Host "Copying VS msbuild to $(Pipeline.Workspace)/VSMSBuild"
-      Copy-Item -Path "$(System.ArtifactsDirectory)/VSMSBuildDrop/*" -Destination "$(Pipeline.Workspace)/VSMSBuild" -Recurse
-      Write-Host "Copy of VS msbuild finished"
-    displayName: Download msbuild vs drop
-    env:
-      patVariable: $(AzDO.DotnetPerfStarToken)
-
-  - task: DownloadBuildArtifacts@1
-    inputs:
-      buildType: specific
-      project: DevDiv
-      pipeline: $(_MsBuildCiPipelineId)
-      ${{ if eq(parameters.MSBuildBuildID, 'default') }}:
-        buildVersionToDownload: latestFromBranch
-        branchName: '${{parameters.MSBuildBranch}}'
-      ${{ else }}:
-        buildVersionToDownload: specific
-        buildId: ${{parameters.MSBuildBuildID}}
-      artifactName: bin
-      itemPattern: |
-        MSBuild.Bootstrap/*/net472/**
-        Microsoft.Build.Conversion/*/net472/Microsoft.Build.Conversion.Core.dll
-        Microsoft.Build.Engine/*/net472/Microsoft.Build.Engine.dll
-        MSBuildTaskHost/**/MSBuildTaskHost.exe
-        MSBuildTaskHost/**/MSBuildTaskHost.pdb
-        MSBuild/*/*/net472/MSBuild.exe*
-      downloadPath: '$(System.ArtifactsDirectory)/msbuild/artifacts/bin'
-    displayName: Download msbuild artifacts
-
-  - powershell: |
-      Write-Host "Updating MSBuild dlls."
-      $(Build.SourcesDirectory)/scripts/Deploy-MSBuild.ps1 `
-        -destination "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)/MSBuild/Current/Bin" `
-        -binDirectory "$(System.ArtifactsDirectory)/msbuild/artifacts/bin" `
-        -configuration Release `
-        -makeBackup $false
-
-      ls "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)"
-      Write-Host "Compressing msbuild files"
-      Get-ChildItem -Path "$(Pipeline.Workspace)/VSMSBuild/$(VSVersion)" | Compress-Archive -DestinationPath "$(Pipeline.Workspace)/artifacts/MSBuild.zip"
-    displayName: Dogfood msbuild dlls
-
-  - task: PublishPipelineArtifact@1
-    inputs:
-      targetPath: '$(Pipeline.Workspace)/artifacts'
-      artifactName: ExperimentalMSBuild
-      parallel: true
-    condition: always()
-    displayName: Publish crank assests artifacts
diff --git a/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
index c97de85decf..d70b263742e 100644
--- a/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
+++ b/.github/workflows/SyncAnalyzerTemplateMSBuildVersion.yml
@@ -6,6 +6,10 @@ on:
     paths:
       - 'eng/Versions.props'
 
+permissions:
+  contents: write
+  pull-requests: write
+
 jobs:
   Sync-version:
     runs-on: ubuntu-latest
@@ -138,14 +142,19 @@ jobs:
             const { data: pullRequests } = await github.rest.pulls.list({
               owner: context.repo.owner,
               repo: context.repo.repo,
-              head: newBranch,
+              head: `${context.repo.owner}:${newBranch}`,
               base: baseBranch,
               state: 'open',
             });
 
             if (pullRequests.length === 0) {
+               console.log(`No open pull requests found for branch ${newBranch} against ${baseBranch}.`);
               return true;
             } else {
+              // Log pull request details
+              pullRequests.forEach(pr => {
+                console.log(`Pull request #${pr.number}: ${pr.title} (created by ${pr.user.login})`);
+              });
               return false;
             }
           }
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 624666c9360..3ea490a61af 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -14,40 +14,40 @@ variables:
   value: none
 
 jobs:
-- job: CheckVersionBumpOnReleaseBranches
-  displayName: "Check Version Bump On Release Branches"
-  steps:
-  - powershell: |
-      $versionsFile = "eng/Versions.props"
-      $changedFiles = git diff --name-only HEAD HEAD~1
-      $changedVersionsFile = $changedFiles | Where-Object { $_ -eq $versionsFile }
-      $isInitialCommit = $false
-      $isVersionBumped = $false
-      if ($changedVersionsFile -ne $null) {
-        $difference = git diff HEAD~1 $versionsFile
-        $changedContent = $difference -join "%"
-        # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
-        $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>%.*\+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix><DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
-        $isInitialCommit = $changedContent -match $initialCommitPattern
-        $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.*%\+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
-        if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
-          try {
-            $previousPatch = [Convert]::ToInt32($Matches.previous)
-            $currentPatch = [Convert]::ToInt32($Matches.current)
-            if ($currentPatch -gt $previousPatch) {
-              $isVersionBumped = $true
-            }
-          } catch {
-            Write-Host "An error occurred during conversion: $_"
-          }
-        }
-      }
+# - job: CheckVersionBumpOnReleaseBranches
+#   displayName: "Check Version Bump On Release Branches"
+#   steps:
+#   - powershell: |
+#       $versionsFile = "eng/Versions.props"
+#       $changedFiles = git diff --name-only HEAD HEAD~1
+#       $changedVersionsFile = $changedFiles | Where-Object { $_ -eq $versionsFile }
+#       $isInitialCommit = $false
+#       $isVersionBumped = $false
+#       if ($changedVersionsFile -ne $null) {
+#         $difference = git diff HEAD~1 $versionsFile
+#         $changedContent = $difference -join "%"
+#         # 'DotNetFinalVersionKind' is expected to be added only during the initial setup of the release branch
+#         $initialCommitPattern = '-\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix>%.*\+\s*<VersionPrefix>\d+\.\d+\.\d+<\/VersionPrefix><DotNetFinalVersionKind>release<\/DotNetFinalVersionKind>'
+#         $isInitialCommit = $changedContent -match $initialCommitPattern
+#         $pattern = '-\s*<VersionPrefix>\d+\.\d+\.(?<previous>\d+)<\/VersionPrefix>.*%\+\s*<VersionPrefix>\d+\.\d+\.(?<current>\d+)<\/VersionPrefix>'
+#         if (!($isInitialCommit) -and ($changedContent -match $pattern)) {
+#           try {
+#             $previousPatch = [Convert]::ToInt32($Matches.previous)
+#             $currentPatch = [Convert]::ToInt32($Matches.current)
+#             if ($currentPatch -gt $previousPatch) {
+#               $isVersionBumped = $true
+#             }
+#           } catch {
+#             Write-Host "An error occurred during conversion: $_"
+#           }
+#         }
+#       }
 
-      if (!($isInitialCommit -or $isVersionBumped)) {
-        throw "Hello! I noticed that you're targeting one of our servicing branches. You need to increase the revision version number (the last part) of 'VersionPrefix' in eng/Versions.props."
-      }
-    condition: startsWith(variables['System.PullRequest.TargetBranch'], 'vs')
-    displayName: "Check if patch version is bumped up"
+#       if (!($isInitialCommit -or $isVersionBumped)) {
+#         throw "Hello! I noticed that you're targeting one of our servicing branches. You need to increase the revision version number (the last part) of 'VersionPrefix' in eng/Versions.props."
+#       }
+#     condition: startsWith(variables['System.PullRequest.TargetBranch'], 'vs')
+#     displayName: "Check if patch version is bumped up"
 
 - job: IfOnlyDocumentionChanged
   displayName: "Check whether Test Results need to be executed"
@@ -276,23 +276,6 @@ jobs:
     continueOnError: true
     condition: eq(variables.onlyDocChanged, 0)
 
-# Unavailable in dnceng-public as of 9/1/2022; should be restored soon.
-# - job: RichCodeNavIndex
-#   displayName: "Windows Code Indexing"
-#   pool:
-#     vmImage: 'windows-2022'
-#   steps:
-#   - task: BatchScript@1
-#     displayName: build.cmd
-#     inputs:
-#       filename: 'build.cmd'
-#   - task: RichCodeNavIndexer@0
-#     displayName: RichCodeNav Upload
-#     inputs:
-#       languages: 'csharp'
-#     continueOnError: true
-#     condition: succeeded()
-
 - job: CoreBootstrappedOnLinux
   displayName: "Linux Core"
   dependsOn: IfOnlyDocumentionChanged
diff --git a/NuGet.config b/NuGet.config
index 81181590594..a11137a9563 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -13,6 +13,7 @@
     <add key="dotnet8" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet8/nuget/v3/index.json" />
     <add key="dotnet8-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet8-transport/nuget/v3/index.json" />
     <add key="dotnet9" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json" />
+    <add key="dotnet9-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet9-transport/nuget/v3/index.json" />
     <add key="vs-impl" value="https://pkgs.dev.azure.com/azure-public/vside/_packaging/vs-impl/nuget/v3/index.json" />
     <!-- We don't want other than VS OpenTelemetry libraries from vs-impl -->
     <packageSourceMapping>
diff --git a/azure-pipelines/vs-insertion-experimental.yml b/azure-pipelines/vs-insertion-experimental.yml
index ab2ce364131..965ceb7d478 100644
--- a/azure-pipelines/vs-insertion-experimental.yml
+++ b/azure-pipelines/vs-insertion-experimental.yml
@@ -2,6 +2,16 @@
 trigger: none
 name: $(Date:yyyyMMdd).$(Rev:r)
 
+# Since our release branch is the one flowing into main
+# we will keep our main experimental insertions to make sure everything is alright
+schedules:
+  - cron: '0 3 * * 1,3,5' # Runs every Monday, Wednesday and Friday at 3AM UTC
+    displayName: Experimental VS insertion main
+    branches:
+      include:
+        - main
+    always: false # Don't run if there are no code changes
+    
 resources:
   pipelines:
   - pipeline: 'MSBuild'
diff --git a/azure-pipelines/vs-insertion.yml b/azure-pipelines/vs-insertion.yml
index 2f8d8732f04..2f2046c4687 100644
--- a/azure-pipelines/vs-insertion.yml
+++ b/azure-pipelines/vs-insertion.yml
@@ -12,13 +12,13 @@ trigger: none
 pr: none
 name: $(Date:yyyyMMdd).$(Rev:r)
 
-schedules:
-  - cron: '0 3 * * 1-5' # Runs every weekday at 3AM UTC
-    displayName: Daily VS insertion main
-    branches:
-      include:
-        - main
-    always: false # Don't run if there are no code changes
+# schedules:
+#   - cron: '0 3 * * 1-5' # Runs every weekday at 3AM UTC
+#     displayName: Daily VS insertion main
+#     branches:
+#       include:
+#         - main
+#     always: false # Don't run if there are no code changes
 
 resources:
   pipelines:
@@ -66,7 +66,7 @@ variables:
   # `auto` should work every time and selecting a branch in parameters is likely to fail due to incompatible versions in MSBuild and VS
   - name: AutoInsertTargetBranch
     ${{ if eq(variables['Build.SourceBranchName'], 'vs17.14') }}:
-      value: 'rel/d17.14'
+      value: 'main'
     ${{ elseif eq(variables['Build.SourceBranchName'], 'vs17.13') }}:
       value: 'rel/d17.13'
     ${{ elseif eq(variables['Build.SourceBranchName'], 'vs17.12') }}:
diff --git a/documentation/specs/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
index 3557170f825..892e17a178a 100644
--- a/documentation/specs/BuildCheck/Codes.md
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -12,6 +12,7 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are
 | [BC0106](#bc0106---copytooutputdirectoryalways-should-be-avoided) | Warning | N/A | 9.0.200 | CopyToOutputDirectory='Always' should be avoided. |
 | [BC0107](#bc0107---targetframework-and-targetframeworks-specified-together) | Warning | N/A | 9.0.200 | TargetFramework and TargetFrameworks specified together. |
 | [BC0108](#bc0108---targetframework-or-targetframeworks-specified-in-non-sdk-style-project) | Warning | N/A | 9.0.300 | TargetFramework or TargetFrameworks specified in non-SDK style project. |
+| [BC0109](#bc0109---building-using-the-exec-task) | Warning | N/A | 9.0.300 | Building using the Exec task. |
 | [BC0201](#bc0201---usage-of-undefined-property) | Warning | Project | 9.0.100 | Usage of undefined property. |
 | [BC0202](#bc0202---property-first-declared-after-it-was-used) | Warning | Project | 9.0.100 | Property first declared after it was used. |
 | [BC0203](#bc0203----property-declared-but-never-used) | None | Project | 9.0.100 | Property declared but never used. |
@@ -21,7 +22,7 @@ Report codes are chosen to conform to suggested guidelines. Those guidelines are
 Notes: 
  * What does the 'N/A' scope mean? The scope of checks are only applicable and configurable in cases where evaluation-time data are being used and the source of the data is determinable and available. Otherwise the scope of whole build is always checked.
  * How can you alter the default configuration? [Please check the Configuration section of the BuildCheck documentation](./BuildCheck.md#sample-configuration)
- * To enable verbose logging in order to troubleshoot issue(s), enable [binary logging](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md#msbuild-binary-log-overview
+ * To enable verbose logging in order to troubleshoot issue(s), enable [binary logging](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Binary-Log.md#msbuild-binary-log-overview)
    _Cmd:_
    ```cmd
    dotnet build -bl -check
@@ -137,6 +138,13 @@ dotnet build my-multi-target.csproj /p:TargetFramework=net9.0
 
 Make sure the Target Framework is specified appropriately for your project.
 
+<a name="BC0109"></a>
+## BC0109 - Building using the Exec task.
+
+"The 'Exec' task should not be used to build projects."
+
+Building projects using the dotnet/msbuild/nuget CLI in the `Exec` task is not recommended, as it spawns a separate build process that the MSBuild engine cannot track. Please use the [MSBuild task](https://learn.microsoft.com/visualstudio/msbuild/msbuild-task) instead.
+
 
 <a name="BC0201"></a>
 ## BC0201 - Usage of undefined property.
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 198791bb356..dcaab9c9cba 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -3,6 +3,7 @@
 [EventSource](https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.tracing.eventsource?view=netframework-4.8) is the tool that allows Event Tracing for Windows (ETW) used in MSBuild. Among its useful features, functions with names ending in "start" and "stop" correlate between calls such that it can automatically record how long the event between the two calls took. It also provides an easy way to cheaply opt in or out, log auxiliary messages in addition to time, and add progress updates in the middle of an event as needed.
 
 ## EventSource in MSBuild
+
 EventSource is primarily used to profile code. For MSBuild specifically, a major goal is to reduce the time it takes to run, as measured (among other metrics) by the Regression Prevention System (RPS), i.e., running specific scenarios. To find which code segments were likely candidates for improvement, EventSources were added around a mix of code segments. Larger segments that encompass several steps within a build occur nearly every time MSBuild is run and take a long time. They generally run relatively few times. Smaller methods with well-defined purposes may occur numerous times. Profiling both types of events provides both broad strokes to identify large code segments that underperform and, more specifically, which parts of them. Profiled functions include:
 
 | Event | Description |
@@ -20,7 +21,7 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 | ExecuteTaskYield | Requests to yield the node, often while the task completes other work. |
 | ExpandGlob | Identifies a list of files that correspond to an item, potentially with a wildcard. |
 | GenerateResourceOverall | Uses resource APIs to transform resource files into strongly-typed resource classes. |
-| LoadDocument | Loads an XMLDocumentWithLocation from a path.
+| LoadDocument | Loads an XMLDocumentWithLocation from a path. |
 | MSBuildExe | Executes MSBuild from the command line. |
 | MSBuildServerBuild | Executes a build from the MSBuildServer node. |
 | PacketReadSize | Reports the size of a packet sent between nodes. Note that this does not include time information. |
diff --git a/documentation/specs/low-priority-switch.md b/documentation/specs/low-priority-switch.md
index ba33826a89e..bec5a72fc74 100644
--- a/documentation/specs/low-priority-switch.md
+++ b/documentation/specs/low-priority-switch.md
@@ -17,7 +17,6 @@ Visual Studio, on the other hand, should always run at normal priority. This ens
 4. Any reused nodes are at the priority they themselves specify. Normal priority nodes are actually at normal priority, and low priority nodes are actually at BelowNormal priority.
 5. All nodes are at the priority they should be when being used to build even if a normal priority process had connected to them as normal priority worker nodes, and they are now executing a low priority build.
 
-
 ## Non-goals
 
 Perfect parity between windows and mac or linux. Windows permits processes to raise their own priority or that of another process, whereas other operating systems do not. This is very efficient, so we should use it. As we expect this feature to be used in Visual Studio, we anticipate it being less used on mac and linux, hence not being as high priority to make it just as efficient.
@@ -27,6 +26,7 @@ Perfect parity between windows and mac or linux. Windows permits processes to ra
 Each node (including worker nodes) initially takes its priority from its parent process. Since we now need the priority to align with what it is passed instead of its parent, attempt to adjust priority afterwards if necessary as part of node startup.
 
 BuildManager.cs remembers the priority of the previous build it had executed. If that was set to a value that differs from the priority of the current build:
+
 1. On windows or when decreasing the priority: lowers the priority of all connected nodes
 2. On linux and mac when increasing the priority: disconnects from all nodes.
 
diff --git a/documentation/specs/project-cache.md b/documentation/specs/project-cache.md
index b0ce961313d..90d19466fdc 100644
--- a/documentation/specs/project-cache.md
+++ b/documentation/specs/project-cache.md
@@ -1,8 +1,10 @@
-# Summary
+# Project Cache
+
+## Summary
 
 Project cache is a new assembly-based plugin extension point in MSBuild which determines whether a build request (a project) can be skipped during build. The main expected benefit is reduced build times via [caching and/or distribution](static-graph.md#weakness-of-the-old-model-caching-and-distributability).
 
-# Motivation
+## Motivation
 
 As the introduction to [static graph](static-graph.md#what-is-static-graph-for) suggests, large and complex repos expose the weaknesses in MSBuild's scheduling and incrementality models as build times elongate. This project cache plugin lets MSBuild natively communicate with existing tools that enable build caching and/or distribution, enabling true scalability.
 
@@ -10,31 +12,33 @@ Visual Studio is one beneficiary. This plugin inverts dependencies among build s
 
 This change also simplifies and unifies user experiences. MSBuild works the same from Visual Studio or the command line without dramatically changing how it works.
 
-# Plugin requirements
+## Plugin requirements
 
 - The plugin should tell MSBuild whether a build request needs building. If a project is skipped, then the plugin needs to ensure that:
   - it makes the filesystem look as if the project built
   - it returns sufficient information back to MSBuild such that MSBuild can construct a valid [`BuildResult`](/src/Build/BackEnd/Shared/BuildResult.cs#L30-L33) for its internal scheduling logic, such that future requests to build a skipped project are served directly from MSBuild's internal caches.
 
-# High-level design
+## High-level design
 
 Conceptually, there are two parts of caching: "cache get" and "cache add". "Cache get" is MSBuild asking the plugin if it wants to handle a build request, ie by fetching from some cache. "Cache add" is, upon cache miss, MSBuild providing enough information to the plugin during the build of the build request for the plugin to add the results to its cache and safely be able to retrieve it for some future build.
 
 The "cache get" functionality was introduced in 16.9, while "cache add" was added in 17.8.
 
-## Plugin discovery
+### Plugin discovery
 
 - Plugin dlls are discovered by MSBuild via a new special purpose `ProjectCachePlugin` [items](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-items).
   - These items can get injected into a project's import graph by package managers via the [PackageReference](https://docs.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files) item.
   - MSBuild will discover the plugin by searching project evaluations for `ProjectCachePlugin` items.
-```xml
-<ItemGroup>
-  <ProjectCachePlugin Include="$(SomePath)\MyAmazingCachePlugin.dll" />
-</ItemGroup>
-```
+
+    ```xml
+    <ItemGroup>
+    <ProjectCachePlugin Include="$(SomePath)\MyAmazingCachePlugin.dll" />
+    </ItemGroup>
+    ```
+
 - Programmatic usage of `BuildManager` can also set `BuildParameters.ProjectCacheDescriptor` to apply a plugin to all requests.
 
-## Plugin lifetime
+### Plugin lifetime
 
 - Plugin instances reside only in the `BuildManager` node. Having it otherwise (plugin instances residing in all nodes) means forcing the plugins to either deal with distributed state or implement a long lived service. We consider this high complexity cost to not be worth it. We also want to avoid serializing the `ProjectInstance` between nodes, which is expensive.
 - `BuildManager.BeginBuild` calls `ProjectCacheBase.BeginBuildAsync` on all discovered plugins. This allows plugins to start any required initialization work. It does not wait for the plugins to fully initialize, ie it is a "fire-and-forget" call at this point. The first query on the plugin will wait for plugin initialization.
@@ -43,10 +47,10 @@ The "cache get" functionality was introduced in 16.9, while "cache add" was adde
 - The plugin instance will get called in reverse topological sort order (from referenced projects up towards referencing projects). This happens when performing a graph build (`/graph`), Visual Studio solution builds, and commonly in higher build engines.
 - Only the top-level build requests are checked against the cache. Build requests issued recursively from the top-level requests, for example a project building its dependencies, are not checked against the cache. However, because the build requests are assumed to be issued in reverse topological sort order, those requests should have already been built and present in MSBuild's internal result cache, provided either by the project cache plugin or real builds. A consequence of this is that projects which are not well-described in the graph (e.g. using `<MSBuild>` tasks directly) will not benefit from the cache.
 
-## Cache get scenario
+### Cache get scenario
 
 - For each [`BuildRequestData`](/src/Build/BackEnd/BuildManager/BuildRequestData.cs#L83) ([`ProjectInstance`](/src/Build/Instance/ProjectInstance.cs#L71), Global Properties, Targets) submitted to the [`BuildManager`](/src/Build/BackEnd/BuildManager/BuildManager.cs#L38), MSBuild asks the plugin whether to build the request or not.
-  
+
   - If the `BuildRequestData` is based on a project path instead of a `ProjectInstance`, the project is evaluated by the `BuildManager`.
 - If the plugin decides to build, then MSBuild proceeds building the project as usual.
 - If the plugin decides to skip the build, it needs to return back to MSBuild the target results that the build request would have produced. It can either provide the results directly, or instruct MSBuild to run a set of less expensive targets on the projects with the same effect as the expensive targets ("proxy targets").
@@ -62,7 +66,7 @@ The "cache get" functionality was introduced in 16.9, while "cache add" was adde
     - Best: A real `BuildResult` from a previous build is provided. This can either be done by serializing the `HandleProjectFinishedAsync`, or when the plugin's infrastructure (e.g. CloudBuild or AnyBuild builder nodes) runs and caches the build, it can tell MSBuild to serialize the BuildResult to a file via [BuildParameters.OutputResultsCacheFile](/src/Build/BackEnd/BuildManager/BuildParameters.cs#L767) or the `/outputResultsCache` command line argument. Then, on cache hits, the plugins deserialize the `BuildResult` and send it back to MSBuild. This is the most correct option, as it requires neither guessing nor proxy targets. Whatever a previous build did, that's exactly what's returned.
       - Potential Issue: serialization format may change between writing and reading the `BuildResult`, especially if binary serialization is used.
 
-## Cache add scenario
+### Cache add scenario
 
 - Upon a cache miss, MSBuild will generally handle a request as normal, ie by building it.
 - MSBuild uses [Detours](https://github.com/microsoft/Detours) to observe file accesses of the worker nodes. To facilitate the plugin being able to handle future builds, it forwards this information as well as the build result to the plugin for it to use as desired, for example to add to a cache.
@@ -72,9 +76,10 @@ The "cache get" functionality was introduced in 16.9, while "cache add" was adde
 - Due to the experimental nature of the feature, `/ReportFileAccesses` is only available with MSBuild.exe (ie. the Visual Studio install; not `dotnet`), only for the x64 flavor (not x86 or arm64), and only from the command-line. The Visual Studio IDE does not set `BuildParameters.ReportFileAccesses`.
 - As described above, it is recommended to serialize the `BuildResult` from `HandleProjectFinishedAsync` for later replay.
 
-# APIs and calling patterns
+## APIs and calling patterns
+
+### Plugin API
 
-## Plugin API
 [ProjectCachePluginBase](/src/Build/BackEnd/Components/ProjectCache/ProjectCachePluginBase.cs) is an abstract class which plugin implementors will subclass.
 
 See the [Plugin implementation guidance and simple example design](#plugin-implementation-guidance-and-simple-example-design) section for guidance for plugin implementations.
@@ -97,14 +102,14 @@ This can then be accessed by the plugin in `BeginBuildAsync` as a dictionary via
 
 Note: As it is likely that plugins will be distributed through NuGet packages and those packages would define the `ProjectCachePlugin` item in a props or targets file in the package, it's recommended for plugin authors to have settings backed by MSBuild properties as in the example above. This allows the user to easily configure a plugin simply by setting the properties and including the `PackageReference`.
 
-## Enabling from command line
+### Enabling from command line
 
 - Requires `/graph` to light up cache get scenarios.
 - Requires `/reportfileaccesses` to light up cache add scenarios.
 - The static graph has all the project instances in the same process, making it easy to find and keep plugin instances in one process.
 - MSBuild constructs the static graph and build bottom up, so by the time a project is considered, all of its references and their build results are already present in the Scheduler.
 
-## Enabling from Visual Studio, a temporary workaround
+### Enabling from Visual Studio, a temporary workaround
 
 - Ideally, Visual Studio would provide a `ProjectGraph` instance. Until that happens, a workaround is needed.
 - The workaround logic activates only when MSBuild detects that it's running under VS.
@@ -113,29 +118,30 @@ Note: As it is likely that plugins will be distributed through NuGet packages an
 - Plugins will be given the graph entry points instead of the entire graph in this scenario.
 - There is currently no way to enable cache add scenarios in Visual Studio.
 
-# Detours (cache add scenario)
+## Detours (cache add scenario)
 
 In order for MSBuild to observe the file accesses as part of the build, it uses Detours on the worker nodes. In this way the Scheduler node will emit events for all file accesses done by the worker nodes. As the Scheduler knows what build request a worker node is working on at any given moment, it is able to properly associate the file access with a build request and dispatch these augmented events to plugins via the plugins' `HandleFileAccess` and `HandleProcess` implementations.
 
 Note that the Scheduler node cannot use Detours on itself, so the in-proc node is disabled when repoting file accesses. Additionally task yielding is disabled since it would leave to improperly associated file accesses.
 
-## Pipe synchronization
+### Pipe synchronization
 
 Because the Detours implementation being used communicates over a pipe, and nodes communicate over a pipe as well, and pipes are async, there is some coordination required to ensure that file accesses are associated with the proper build request. For example, if a "project finished" signal comes through the node communication pipe, but the detours pipe still has a queue of file accesses which have not been processed yet, those file accesses might be processed after the worker node has moved onto some other project.
 
 To address this problem, when a worker node finishes a project it will emit a dummy file access with a specific format known to MSBuild. When the scheduler node receives as "project finished" event over the node communication pipe, it will wait to determine that the project is actually finished until it also receives the dummy file access. This ensures that the all file accesses associated with the project have fully flushed from the pipe before the scheduler determines the project is finished and schedules new work to the worker node (which would trigger new file accesses).
 
-# Plugin implementation guidance and simple example design
+## Plugin implementation guidance and simple example design
 
 The following will describe a very basic (and not very correct) plugin implementation.
 
 In practice, plugins will have to choose the specific level of correctness they're willing to trade off for the ability to get cache hits. Any machine state *could* impact build results, and the plugin implementation will need to determine what state matters and what doesn't. An obvious example to consider would be the content of the project file. An example which has trade-offs would be the processes' environment variables. Even the current time could possibly impact the build ("if Tuesday copy this file"), but if considered caching would be quite infeasible.
 
-## Fingerprinting
+### Fingerprinting
 
 A "fingerprint" describes each unique input which went into the building a build request. The more granular the fingerprint, the more "correct" the caching is, as described above.
 
 In this example, we will only consider the following as inputs, and thus part of the fingerprint:
+
 - The global properties of the build request (eg `Configuration=Debug`, `Platform=AnyCPU`)
 - The content hash of the project file
 - The content hash of files defined in specific items we know contribute to the build, like `<Compile>` and `<Content>`
@@ -147,13 +153,13 @@ It can make sense for a fingerprint to be a hash of its inputs, so effectively i
 
 At the beginning of the build, the plugin's `BeginBuildAsync` method will be called. As part of the `CacheContext`, the plugin is either given the graph or the entry points to the graph for which it can create a graph from. The plugin can use this graph to do some initial processing, like predicting various inputs which a project is likely to use. This information can then be stored to help construct a fingerprint for a build request later.
 
-## Cache storage
+### Cache storage
 
 Any storage mechanism can be used as a cache implementation, for example [Azure Blob Storage](https://azure.microsoft.com/products/storage/blobs/), or even just the local filesystem. At least in this example the only real requirement is that it can be used effectively as a key-value store. In many cases it can be useful for content to be keyed by its hash, and for the metadata file to be keyed by the fingerprint. In particular when content is keyed by hash, it is effectively deduplicated across multiple copies of the same file, which is common in builds.
 
 For illustration purposes, consider our cache implementation is based on a simple filesystem with a separate metadata and content directory inside it. Under the metadata dir, each file is a metadata file where the filename matches the fingerprint it's describing. Under the content dir, each file is a content file where the filename matches the hash of the content itself.
 
-## First build (cache population)
+### First build (cache population)
 
 In the very first build there will be no cache hits so the "cache add" scenario will be most relevant here.
 
@@ -168,22 +174,24 @@ In our example, we can use the read files to construct a fingerprint for the bui
 The plugin would then create some metadata describing the outputs (eg. the paths and hashes) and the serialized `BuildResult`, and associate it with the fingerprint and put that assocation in the cache.
 
 To illustrate this, consider a project with fingerprint `F` which wrote a single file `O` with hash `H` and had `BuildResult R`. The plugin could create a metadata file `M` which describes the outputs of the build (the path and hash of `O`) as well as the serialized `R`. Using the cache implementation described above, the plugin would write the following two files to the cache:
- - `metadata/F -> M:"{outputs: [{path: 'path/to/O', hash: H}], result: R}"`
- - `content/H -> O`
+
+- `metadata/F -> M:"{outputs: [{path: 'path/to/O', hash: H}], result: R}"`
+- `content/H -> O`
 
 This can then be used for future builds.
 
- ## Second Build (cache hits)
- 
- In the second build we have a populated cache and so it could be possible to get cache hits.
+### Second Build (cache hits)
 
- For a given project, `GetCacheResultAsync` will be invoked. The plugin can fingerprint the request and use that fingerprint to look up in its cache. If the cache entry exists, it can declare a cache hit.
+In the second build we have a populated cache and so it could be possible to get cache hits.
+
+For a given project, `GetCacheResultAsync` will be invoked. The plugin can fingerprint the request and use that fingerprint to look up in its cache. If the cache entry exists, it can declare a cache hit.
 
 In the example above, if all inputs are the same as in the first build, we should end up with a fingerprint `F`. We look up in the metadata part of the cache (file `metadata/F`) and find that it exists. This means we have a cache hit. We can fetch that metadata `M` from the cache and find that it describes the output with path `O` and hash `H`. The plugin would then copy `content/H` to `O` and return the deserialized `BuildResult R` contained in `M` to MSBuild.
 
 If the inputs were not the same as in the first build, for example if a `Compile` item (a .cs file) changed, the fingerprint would be something else besides `F` and so would not have corresponding cache entries for it, indicating a cache miss. This will then go through the "cache add" scenario described above to populate the cache with the new fingerprint.
 
-# Caveats
+## Caveats
+
 - Without the "cache add" scenario enabled, the content which powers "cache get" must be populated by some external entity, for example some higher-order build engine.
 - Absolute paths circulating through the saved build results
   - Absolute paths will likely break the build, since they'd be captured on the machine that writes to the cache.
@@ -193,6 +201,7 @@ If the inputs were not the same as in the first build, for example if a `Compile
   - Msbuild /graph requires that the [target inference protocol](static-graph.md#inferring-which-targets-to-run-for-a-project-within-the-graph) is good enough.
 - Small repos will probably be slower with plugin implementations that access the network. Remote distribution and caching will only be worth it for repos that are large enough.
 
-# Potential future work of dubious value
+## Potential future work of dubious value
+
 - Enable plugins to work with the just-in-time top down msbuild traversal that msbuild natively does when it's not using `/graph`.
 - Extend the project cache API to allow skipping individual targets or tasks instead of entire projects. This would allow for smaller specialized plugins, like plugins that only know to distribute, cache, and skip CSC.exe calls.
diff --git a/documentation/specs/question.md b/documentation/specs/question.md
index 84fac8ed9f3..f46aa910af8 100644
--- a/documentation/specs/question.md
+++ b/documentation/specs/question.md
@@ -8,15 +8,19 @@ Question switch ask if the next build is up-to-date. It will start a build, but
 [Fast Up-To-Date Check](https://github.com/dotnet/project-system/blob/cd275918ef9f181f6efab96715a91db7aabec832/docs/up-to-date-check.md) is a system that is implemented by the Project System, that decides, if it needs to run MSBuild.  MSBuild takes a non-trival amount of time to load, evaluate, and run through each target and task.  Fast Up-To-Date is faster, but can be less accurate, suitable for an IDE and a human interface.  It is not accurate enough for a CI.
 
 ## Usage
+
 Question mode is designed to be used on the command line.  Run your normal build, then run again with /question.
-```
+
+```cmd
 msbuild /p:Configuration=Debug Project1.csproj /bl:build.binlog
 msbuild /p:Configuration=Debug Project1.csproj /bl:incremental.binlog /question
 ```
+
 If there are no errors, then your build is up-to-date.
 If there are errors, then investigate the error.  See common errors below.  Keep both logs to help with your investigation.
 
 ## Custom Tasks
+
 Task author can implement the optional `IIncrementalTask` interface that will expose `FailIfNotIncremental`. `FailIfNotIncremental` is true when /question switch is used. The custom task will need to decide how it want to handle their behavior.  For example.  If there is already a message describing why the task cannot be skipped, then simply convert the message to a error. Remember to return false to stop the build.  For the best reproducibility, do not modify any files on disk.
 
 ```C#
@@ -32,6 +36,7 @@ else
 ```
 
 ## Shipping Tasks
+
 When question switch is used, it will modify the shipping task with these behavior.  Note: this is still experimental and can change.
 
 `Exec`
@@ -73,11 +78,11 @@ Error when SkipUnchangedFiles is true.
 `ZipDirectory`
 Error if the destination zip file doesn't exists.
 
-
 ## Common Error
+
 - **Typographical error**. Spelling, casing, or incorrect path.  Check if the target inputs and outputs real files.
 - Inputs and Outputs are sometimes used for Cross Product. Try to move all to Outputs. If not possible, use Returns instead of Inputs.
 - **Double Checks**.  Since target and task could be incremental, if both are implemented, then it can lead task skipping but not the task.  For example, a Target has inputs A and outputs B.  If A is newer, than B, then the target will start.  If the task compares the content of A and B and deems nothing has changed, then B is not updated.  If such case, this leads to target rerunning.
 - **Exec Task** are not Skipable, thus they should be wrapped with Target Inputs and Outputs or other systems.  For backwards compatibility, Question will not issue an error.
 - **FileWritten**.  The common clean system will remove files that aren't in the FileWritten itemgroup.  Sometimes task output won't be add to FileWritten itemgroup.
-- **Build, then Build**.  Sometimes, a 2nd build will break up to date.  Question after the 2nd build. 
\ No newline at end of file
+- **Build, then Build**.  Sometimes, a 2nd build will break up to date.  Question after the 2nd build.
diff --git a/documentation/specs/rar-core-scenarios.md b/documentation/specs/rar-core-scenarios.md
index 3fb19ad7846..48af2458d6d 100644
--- a/documentation/specs/rar-core-scenarios.md
+++ b/documentation/specs/rar-core-scenarios.md
@@ -139,6 +139,7 @@ effect. Be it eliminating allocations, simplifying tight loops, reordering cases
 address the elephant in the room: the file I/O resulting from scanning of assemblies, checking their timestamps, and reading/writing on-disk caches.
 
 For regular project references the system works as about as efficient as possible.
+
 - In a cold scenario, where there is no state in memory or on disk, the referenced assembly file has to be scanned for its name and dependencies.
 - In a warm scenario, where there is no state in memory but a disk cache exists, the assembly name and dependencies are read from the cache, together with the
 corresponding timestamp which is compared to the current timestamp of the assembly file. If they match the cached data is used.
@@ -188,6 +189,7 @@ enlistment - the system may prime by building the full solution and then the dev
 cache and get sub-optimal first-time build performance.
 
 Saving of the per-project disk cache may be further optimized by
+
 - Keeping the timestamp of the cache file in memory and skipping the save if the relevant cache items haven't become dirty (i.e. the dependencies have not changed)
 *and* the timestamp of the cache file hasn't changed since the last save. In hot inner loop scenarios this would reduce the save to a timestamp check.
 - Saving the file asynchronously, i.e. not blocking the build on completing the save operation.
diff --git a/documentation/specs/remote-host-object.md b/documentation/specs/remote-host-object.md
index 536535637d2..a64a8836ab4 100644
--- a/documentation/specs/remote-host-object.md
+++ b/documentation/specs/remote-host-object.md
@@ -4,8 +4,9 @@ A remote host object must be registered in the [Running Object Table (ROT)](http
 
 [The registration of interfaces](https://docs.microsoft.com/en-us/dotnet/framework/interop/how-to-register-primary-interop-assemblies) is the only thing interop with COM that need extra care. There are 3 interfaces involved in out-of-proc tasks work: `IVsMSBuildTaskFileManager`, `IPersistFileCheckSum` and `ITaskHost`. `IVsMSBuildTaskFileManager` and `IPersistFileCheckSum` are registered globally in Windows registry by VS existing setup. `ITaskHost` is also configured in VS using registration-free. So the only work is to configure it using registration-free in **MSBuild**. That results the change in msbuild.exe.manifest file and the change to generate tlb file for ITaskHost.
 
-## Annotated additions to the msbuild.exe.manifest file.
-```
+## Annotated additions to the msbuild.exe.manifest file
+
+```xml
 <file name="Microsoft.Build.Framework.tlb"> -- Location of the tlb, it should be in the same directory as msbuild.exe
     <typelib
         tlbid="{D8A9BA71-4724-481D-9CA7-0DA23A1D615C}" -- matches what is embedded in the tlb with ITaskHost
@@ -24,7 +25,7 @@ A remote host object must be registered in the [Running Object Table (ROT)](http
 
 If is part of the work for [allowing out-of-proc tasks to access unsaved changes](https://github.com/dotnet/project-system/issues/4406)
 
-## More reference:
+## More reference
 
 [RegFree COM Walkthrough](https://msdn.microsoft.com/library/ms973913.aspx)
 
diff --git a/documentation/specs/sdk-resolvers-algorithm.md b/documentation/specs/sdk-resolvers-algorithm.md
index e5cd05a0dd3..6cc8ce247c6 100644
--- a/documentation/specs/sdk-resolvers-algorithm.md
+++ b/documentation/specs/sdk-resolvers-algorithm.md
@@ -1,20 +1,26 @@
-## SDK Resolution Algorithm
+# SDK Resolution Algorithm
+
 In 17.3 under ChangeWave 17.4 the sdk resolution algorithm is changed.
 
-### Reason for change
+## Reason for change
+
 Previously (before ChangeWave 17.4) all SDK resolvers were loaded and then ordered by priority. The resolvers are tried one after one until one of them succeeds. In order to decrease the number of assemblies to be load we change the behavior in 17.3 under ChangeWave 17.4.
 
-### New SDK Resolution Algorithm
+## New SDK Resolution Algorithm
+
 Under ChangeWave 17.4 all the resolvers divides into two groups:
+
 - Specific resolvers, i.e. resolvers with specified sdk name pattern `ResolvableSdkPattern`
 - General resolvers, i.e. resolvers without specified sdk name pattern `ResolvableSdkPattern`
 
-The resolving algorithm works in two passes. 
-- On the first pass all the specific resolvers that match the given sdk name would be loaded, ordered by priority and tried one after one. 
+The resolving algorithm works in two passes.
+
+- On the first pass all the specific resolvers that match the given sdk name would be loaded, ordered by priority and tried one after one.
 - If the sdk is not found, on the second pass all general resolvers would be loaded, ordered by priority and tried one after one.
 
 By default the resolvers are general. To make all the resolvers from some dll specific, in the corresponding manifest (xml file) one need to specify the `ResolvableSdkPattern` using C# regex format:
-```
+
+```xml
 <SdkResolver>
   <Path>MySdkResolver.dll</Path>
   <ResolvableSdkPattern>MySdk.*</ResolvableSdkPattern>
@@ -23,11 +29,12 @@ By default the resolvers are general. To make all the resolvers from some dll sp
 
 Note, that the manifest file, if exists, from ChangeWave 17.4 would have preference over the dll.
 The sdk discovery works according to the following algorithm:
-- First try locate the manifest file and use it. 
-- If it is not found, we try to locate the dll in the resolver's folder. 
+
+- First try locate the manifest file and use it.
+- If it is not found, we try to locate the dll in the resolver's folder.
 Both xml and dll name should match the following name pattern `...\SdkResolvers\(ResolverName)\(ResolverName).(xml/dll)`.
 
-### Failed SDK Resolution
+## Failed SDK Resolution
 
 > 🚧 Note
 >
@@ -35,15 +42,15 @@ Both xml and dll name should match the following name pattern `...\SdkResolvers\
 
 SDK resolvers previously attempted to continue when one critically fails (throws an unhandled exception). This lead to misleading error messages such as:
 
-```
+```text
 warning MSB4242: The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed to run. 's' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8.
 error MSB4236: The SDK 'Microsoft.NET.SDK.WorkloadAutoImportPropsLocator' specified could not be found. [C:\foo\bar.csproj]
 ```
 
 `MSB4236` is a red herring while `MSB4242` is the real error despite being logged as a warning. Because of this, SDK resolvers now fail the build _immediately_ upon unhandled exceptions. These exceptions are propogated as `SdkResolverException`s, and `MSB4242` has been promoted to an error code. The new error message appears like so:
 
-```
-C:\src\temp\8-18>"C:\foo\dotnet-sdk-6.0.100-preview.7.21379.14-win-x64\dotnet.exe" build    
+```text
+C:\src\temp\8-18>"C:\foo\dotnet-sdk-6.0.100-preview.7.21379.14-win-x64\dotnet.exe" build
 Microsoft (R) Build Engine version 17.0.0-dev-21420-01+5df152759 for .NET
 Copyright (C) Microsoft Corporation. All rights reserved.
 
@@ -56,4 +63,4 @@ C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Micr
     1 Error(s)
 
 Time Elapsed 00:00:00.15
-```
\ No newline at end of file
+```
diff --git a/documentation/specs/single-project-isolated-builds.md b/documentation/specs/single-project-isolated-builds.md
index 75b15fc5b82..8a8f9e68413 100644
--- a/documentation/specs/single-project-isolated-builds.md
+++ b/documentation/specs/single-project-isolated-builds.md
@@ -19,25 +19,27 @@ In a build, the input and output cache files have the same lifetime as the `Conf
 <!-- constraints -->
 
 When loading input cache files, MSBuild merges incoming instances of `ConfigCache`s and `ResultsCache`s into one instance of each with the help of the [`CacheAggregator`](https://github.com/dotnet/msbuild/blob/51df47643a8ee2715ac67fab8d652b25be070cd2/src/Build/BackEnd/BuildManager/CacheAggregator.cs#L15), which enforces the following constraints:
+
 - No duplicate cache entries
 - Bijection:
-   - `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
-   - `BuildResult.ConfigurationId` == `BuildRequestConfiguration.ConfigurationId`
+  - `ConfigCache.Entries.Size == ResultsCache.Entries.Size`
+  - `BuildResult.ConfigurationId == BuildRequestConfiguration.ConfigurationId`
 
 Note that the output cache file contains a single `BuildResult` with the `TargetResult`s from the project specified to be built in the `BeginBuild` / `EndBuild` session, as any `BuildResult`s obtained through isolation exemption are excluded to prevent potential duplicate input cache entries; Entries from input caches are not transferred to the output cache.
 
 <!-- How input / output cache entries are separated with the override caches -->
-Input cache entries are separated from output cache entries with the composite caches [`ConfigCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [`ResultsCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). Each composite cache contains two underlying caches: a cache where input caches files are loaded into (the override cache), and a cache where new results are written into (the current cache).* In the `ConfigCacheWithOverride`, these caches are instances of `ConfigCache`s and, in the `ResultsCacheWithOverride`, these caches are instances of `ResultsCache`s. A query for a cache entry is first attempted from the override cache and, if unsatisfied, a second attempt is made from the current cache. Writes are only written to the current cache, never into the override cache.* It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache query.
+Input cache entries are separated from output cache entries with the composite caches [`ConfigCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ConfigCacheWithOverride.cs) and [`ResultsCacheWithOverride`](https://github.com/dotnet/msbuild/blob/main/src/Build/BackEnd/Components/Caching/ResultsCacheWithOverride.cs). Each composite cache contains two underlying caches: a cache where input caches files are loaded into (the override cache), and a cache where new results are written into (the current cache). *In the `ConfigCacheWithOverride`, these caches are instances of `ConfigCache`s and, in the `ResultsCacheWithOverride`, these caches are instances of `ResultsCache`s. A query for a cache entry is first attempted from the override cache and, if unsatisfied, a second attempt is made from the current cache. Writes are only written to the current cache, never into the override cache.* It is illegal for both the current cache and override cache to contain entries for the same project configuration, a constraint that is checked by the two override caches on each cache query.
 
 ## Isolation Implementation
 
 [Isolation constraints](static-graph.md##single-project-isolated-builds) are implemented in the `Scheduler` and  `TaskBuilder`. [`TaskBuilder.ExecuteInstantiatedTask`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs#L743) ensures that the `MSBuild` task is only called on projects declared in a `ProjectReference` item. [`Scheduler.CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot`](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/Components/Scheduler/Scheduler.cs#L1818) ensures that all `MSBuild` tasks are cache hits.
 
 ### Isolation Exemption
+
 The `Scheduler` [skips isolation constraints](static-graph.md#exempting-references-from-isolation-constraints) on project references via the:
 
-* `GraphIsolationExemptReference` item. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of a `BuildRequest` to `true` if the `RequestBuilder` matches it against a `GraphIsolationExemptReference` item defined in the calling project. Additionally, the `RequestBuilder` marks the `BuildRequest`'s corresponding `BuildRequestConfiguration` as exempt to allow the `TaskBuilder` to verify exemption from isolation constraints.
+- `GraphIsolationExemptReference` item. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of a `BuildRequest` to `true` if the `RequestBuilder` matches it against a `GraphIsolationExemptReference` item defined in the calling project. Additionally, the `RequestBuilder` marks the `BuildRequest`'s corresponding `BuildRequestConfiguration` as exempt to allow the `TaskBuilder` to verify exemption from isolation constraints.
 
-* `isolate:MessageUponIsolationViolation` switch. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of _every_ `BuildRequest` to `true`. The `TaskBuilder` verifies exemption from isolation constraints just by the switch value.
+- `isolate:MessageUponIsolationViolation` switch. The `RequestBuilder` sets the `SkipStaticGraphIsolationConstraints` property of _every_ `BuildRequest` to `true`. The `TaskBuilder` verifies exemption from isolation constraints just by the switch value.
 
-\* Except in the following scenario when a `ProjectReference` is exempted from isolation constraints: a dependency project A outputs a cache file F containing a `BuildResult` with `TargetResult`s T<sub>cached</sub> for targets t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>m</sub> and a dependent project B uses F as an input cache file but builds and obtains the `TargetResult`s T<sub>new</sub> for targets t<sub>m + 1</sub>, t<sub>m + 2</sub>, ..., t<sub>n</sub> such that 0 < m < n. In this case, T<sub>new</sub> will be placed into the `ResultsCache` containing T<sub>cached</sub> to enforce no overlap between the override and current caches in the `ConfigCacheWithOverride`.
\ No newline at end of file
+\* Except in the following scenario when a `ProjectReference` is exempted from isolation constraints: a dependency project A outputs a cache file F containing a `BuildResult` with `TargetResult`s T<sub>cached</sub> for targets t<sub>1</sub>, t<sub>2</sub>, ..., t<sub>m</sub> and a dependent project B uses F as an input cache file but builds and obtains the `TargetResult`s T<sub>new</sub> for targets t<sub>m + 1</sub>, t<sub>m + 2</sub>, ..., t<sub>n</sub> such that 0 < m < n. In this case, T<sub>new</sub> will be placed into the `ResultsCache` containing T<sub>cached</sub> to enforce no overlap between the override and current caches in the `ConfigCacheWithOverride`.
diff --git a/documentation/specs/static-graph.md b/documentation/specs/static-graph.md
index 49acebe57fe..6112072349a 100644
--- a/documentation/specs/static-graph.md
+++ b/documentation/specs/static-graph.md
@@ -85,6 +85,7 @@ Static graph functionality can be used in three ways:
 ## Project Graph
 
 ### Constructing the project graph
+
 Calculating the project graph will be very similar to the MS internal build engine's existing Traversal logic. For a given evaluated project, all project references will be identified and recursively evaluated (with deduping).
 Project references are identified via the `ProjectReference` item.
 
@@ -112,14 +113,16 @@ Multitargeting refers to projects that specify multiple build dimensions applica
 
 <!-- how it works: outer builds and inner builds -->
 Multitargeting is implemented by having a project reference itself multiple times, once for each combination of multitargeting global properties. This leads to multiple evaluations of the same project, with different global properties. These evaluations can be classified in two groups
-1.  Multiple inner builds. Each inner build is evaluated with one set of multitargeting global properties (e.g. the `TargetFramework=net472` inner build, or the `TargetFramework=netcoreapp2.2` inner build).
-2.  One outer build. This evaluation does not have any multitargeting global properties set. It can be viewed as a proxy for the inner builds. Other projects query the outer build in order to learn the set of valid multitargeting global properties (the set of valid inner builds). When the outer build is also the root of the project to project graph, the outer build multicasts the entry target (i.e. `Build`, `Clean`, etc) to all inner builds.
+
+1. Multiple inner builds. Each inner build is evaluated with one set of multitargeting global properties (e.g. the `TargetFramework=net472` inner build, or the `TargetFramework=netcoreapp2.2` inner build).
+2. One outer build. This evaluation does not have any multitargeting global properties set. It can be viewed as a proxy for the inner builds. Other projects query the outer build in order to learn the set of valid multitargeting global properties (the set of valid inner builds). When the outer build is also the root of the project to project graph, the outer build multicasts the entry target (i.e. `Build`, `Clean`, etc) to all inner builds.
 
 <!-- contract with the graph -->
 
 In order for the graph to represent inner and outer builds as nodes, it imposes a contract on what multitargeting means, and requires the multitargeting supporting SDKs to implement this contract.
 
 Multitargeting supporting SDKs MUST implement the following properties and semantics:
+
 - `InnerBuildProperty`. It contains the property name that defines the multitargeting build dimension.
 - `InnerBuildPropertyValues`. It contains the property name that holds the possible values for the `InnerBuildProperty`.
 - Project classification:
@@ -136,6 +139,7 @@ These specific rules represent the minimal rules required to represent multitarg
 For example, `InnerBuildProperty` could become `InnerBuildProperties` for SDKs where there's multiple multitargeting global properties.
 
 For example, here is a trimmed down `Microsoft.Net.Sdk` multitargeting project:
+
 ```xml
 <Project Sdk="Microsoft.Net.Sdk">
   <!-- This property group is defined in the sdk -->
@@ -152,14 +156,17 @@ For example, here is a trimmed down `Microsoft.Net.Sdk` multitargeting project:
 ```
 
 To summarize, there are two main patterns for specifying build dimensions:
+
 1. Multitargeting based. A multitargeting project self describes supported build dimensions. In this case the SDK needs to specify the multitargeting build dimensions. The graph then extracts innerbuilds from a given outer build. For example, the `TargetFramework` build dimension gets specified this way.
 2. Global Property based: A top level set of global properties get applied to the graph entrypoints and get propagated downward through the graph. For example, the `Configuration` and `Platform` build dimensions get specified this way.
 
 Why does an outerbuild need to generate speculative edges to all of its innerbuilds? Why can't it use nuget to prune the speculative edges down to the compatible set?
+
 - One big design constraint we imposed on static graph was to keep it agnostic of SDK implementation details. So the graph must not know about particular details of one language's SDK. We wanted a generic design that all language SDKs can leverage. We considered that calling nuget to get the compatible TargetFramework values breaks this rule, as both the concept of "nuget" and the concept of "TargetFramework" are implementation details of the .net SDK. If someone were to write a Java SDK, would "calling nuget to get the compatible TargetFramework" still be relevant? A solution to this is to allow SDKs to configure the graph with an extension point on "how to collapse multiple speculative innerbuild edges into a smaller compatible set", but we didn't have the time to design it yet.
 - There is a conflicting need between build everything or just building a "TF slice" through the graph. Outer loop builds (CI builds) that publish binaries need to build all the packages for all the supported TFs, so they need the graph to express all possible combinations. Inner loop builds (dev-at-work) can be sliced down to only the TF that the dev is working on in order to reduce build times. Again, we didn't have time to design how to express these two things so we went with "express everything" because that allows both scenarios to work.
 
 ### Executing targets on a graph
+
 When building a graph, project references should be built before the projects that reference them, as opposed to the existing msbuild scheduler which builds projects just in time.
 
 For example if project A depends on project B, then project B should build first, then project A. Existing msbuild scheduling would start building project A, reach an MSBuild task for project B, yield project A, build project B, then resume project A once unblocked.
@@ -169,6 +176,7 @@ Building in this way should make better use of parallelism as all CPU cores can
 Note that graph cycles are disallowed, even if they're using disconnected targets. This is a breaking change, as today you can have two projects where each project depends on a target from the other project, but that target doesn't depend on the default target or anything in its target graph.
 
 #### Command line
+
 `msbuild /graph` - msbuild will create a static graph from the entry point project and build it in topological order with the specified targets. Targets to call on each node are inferred via the rules in [this section](#inferring-which-targets-to-run-for-a-project-within-the-graph).
 
 #### APIs
@@ -176,11 +184,12 @@ Note that graph cycles are disallowed, even if they're using disconnected target
 [BuildManager.PendBuildRequest(GraphBuildRequestData requestData)](https://github.com/dotnet/msbuild/blob/37c5a9fec416b403212a63f95f15b03dbd5e8b5d/src/Build/BackEnd/BuildManager/BuildManager.cs#L676)
 
 ### Inferring which targets to run for a project within the graph
+
 In the classic MSBuild build (i.e. execution of targets), the referencing project chooses which targets to call on the referenced projects and may call into a project multiple times with different target lists and global properties (examples in [project reference protocol](../ProjectReference-Protocol.md)). This is a top-down traversal of dependencies. These calls are made via the [MSBuild task](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-task?view=vs-2019). When building a graph, projects are built before the projects that reference them. This is a bottom-up traversal. Therefore the graph needs to determine the list of targets to execute on a specific project `B` **before** building the referencing projects that reference `B`.
 
 The static graph contains the structural information on which reference projects a referencing project depends on. But it does not contain information on what "depends" means. At build time "depends" means that a referencing evaluated project will call a subset of reference evaluations with some targets. Subset because the static graph is an inferred graph, therefore there are ambiguities during graph construction, and thus it needs to be conservative and represent a superset of the "runtime graph". The "runtime graph" is the actual graph that gets executed during a real build. We cannot know the runtime graph because that would require us to analyze msbuild xml code inside of targets in order to find the `MSBuild task` invocations. This means doing heavy program analysis, like symbolic execution. That would make things very complicated, slower, and would probably introduce even more ambiguity, so a larger superset conservative graph. So we kept it simple and only looked at evaluation time msbuild xml code (i.e. msbuild xml code outside of `<Target>` elements).
 To summarize, the static graph does not have insights into the `MSBuild task` callsites. It does not know callsite specific information such as the `Targets="Foo;Bar"` or `Properties="Foo=Bar"` `MSBuild task` attributes.
-Since the graph does not have access to MSBuild task callsites, it does not know what targets will get called for a given graph edge. 
+Since the graph does not have access to MSBuild task callsites, it does not know what targets will get called for a given graph edge.
 
 To infer target information we use a flow analysis to propagate target information down the graph. The flow analysis uses the `ProjectReferenceTargets` protocol (described further down) to infer how one incoming target on a graph node (e.g. `Build`) generates multiple outgoing targets to its referenced nodes (e.g. `GetTargetFrameworks`, `GetNativeManifest`, `Build`).
 SDKs **must** explicitly describe the project-to-project calling patterns via the `ProjectReferenceTargets` protocol in such a way that a graph based build can correctly infer the entry targets for a graph node.
@@ -189,7 +198,7 @@ Each project needs to specify the project reference protocol targets it supports
 
 For example, a simple recursive rule would be `A -> A`, which says that a project called with target `A` will call target `A` on its referenced projects. Here's an example execution with two nodes:
 
-```
+```text
 Execute target A+-->Proj1   A->A
                     +
                     |
@@ -202,11 +211,12 @@ Execute target A+-->Proj1   A->A
 Proj1 depends on Proj2, and we want to build the graph with target `A`. Proj1 gets inspected for the project reference protocol for target `A` (represented to the right of Proj1). The protocol says the referenced projects will be called with `A`. Therefore Proj2 gets called with target `A`. After Proj2 builds, Proj1 then also builds with `A` because Proj1 is an entry point and `A` is what was requested by the user.
 
 A project reference protocol may contain multiple targets, for example `A -> B, A`. This means that building `A` on the referencing project will lead to `B` and `A` getting called on the referenced projects. If all nodes in the graph repeat the same rule, then the rule is repeated recursively on all nodes. However, a project can choose to implement the protocol differently. In the following example, the entry targets are:
+
 - Proj4 is called with targets `B, A, C, D`. On multiple references, the incoming targets get concatenated. The order of these target lists does not matter, as MSBuild has non-deterministic p2p ordering, however the order within the target lists does. IE. `B, A, C, D` and `C, D, B, A` are valid, while `A, B, C, D` is not.
 - Proj3 and Proj2 get called with `B, A`, as specified by the rule in Proj1.
 - Proj1 builds with `A`, because it's the root of the graph.
 
-```
+```text
             A+-->Proj1   A->B, A
                  /    \
            B, A /      \ B, A
@@ -238,6 +248,7 @@ Here are the rules for the common protocols:
 `Rebuild` actually calls `Clean` and `Build`, which in turn uses the concatenation of the `Clean` and `Build` mappings. `GetTargetFrameworks` is repeated so only the first call to it remains in the final target list.
 
 Restore is a composition of two rules:
+
 - `Restore -> _IsProjectRestoreSupported, _GenerateRestoreProjectPathWalk, _GenerateRestoreGraphProjectEntry`
 - `_GenerateRestoreProjectPathWalk -> _IsProjectRestoreSupported, _GenerateRestoreProjectPathWalk, _GenerateRestoreGraphProjectEntry`
 
@@ -258,22 +269,24 @@ We'll represent the project reference protocols as `ProjectReferenceTargets` ite
 #### Multitargeting details
 
 A multitargeting project can get called with different targets for the outer build and the inner builds. In this case, the `ProjectReferenceTargets` items containing targets for the outer build are marked with the `OuterBuild=true` metadata. Here are the rules for how targets from `ProjectReferenceTargets` get assigned to different project types:
-  - *Outer build*: targets with `OuterBuild=true` metadata
-  - *Dependent inner build*: targets without `OuterBuild=true` metadata
-  - *Standalone inner build*: the same as non multitargeting builds.
-  - *Non multitargeting build*: concatenation of targets with `OuterBuild=true` metadata and targets without `OuterBuild=true` metadata
+
+- *Outer build*: targets with `OuterBuild=true` metadata
+- *Dependent inner build*: targets without `OuterBuild=true` metadata
+- *Standalone inner build*: the same as non multitargeting builds.
+- *Non multitargeting build*: concatenation of targets with `OuterBuild=true` metadata and targets without `OuterBuild=true` metadata
 
 **OPEN ISSUE:** Current implementation does not disambiguate between the two types of inner builds, leading to overbuilding certain targets by conservatively treating both inner build types as standalone inner builds.
 
 For example, consider the graph of `A (non multitargeting) -> B (multitargeting with 2 innerbuilds) -> C (standalone inner build)`, with the following target propagation rules:
-```
+
+```text
 A -> Ao when OuterBuild=true
 A -> Ai, A
 ```
 
 According to the graph construction rules defined in the [multitargeting section](#multitargeting), we get the following graph, annotated with the target propagation for target `A`.
 
-```
+```text
                    A+-->ProjA
                       /   |   \
                      /    |    \
@@ -294,6 +307,7 @@ According to the graph construction rules defined in the [multitargeting section
 ```
 
 ### Underspecified graphs
+
 The intention is that the project graph and the target lists for each node be exactly correct, however MSBuild is quite flexible and particular projects or project types may not adequately describe these for the project graph.
 
 If a project calls into another project which either isn't represented in the graph or with a target list which isn't represented by the graph, it will fall back to classical MSBuild behavior and execute that target on the project reference just-in-time. This has the consequence of still requiring all project state be kept in memory in case any arbitrary project wants to execute targets on any other arbitrary project.
@@ -301,6 +315,7 @@ If a project calls into another project which either isn't represented in the gr
 To enable further optimizations (and strictness), graph builds can run [isolated](#isolated-builds) which enforces that the graph be entirely accurate.
 
 ### Public API
+
 This is a proposal for what the public API for ProjectGraph may look like:
 
 ```csharp
@@ -360,6 +375,7 @@ namespace Microsoft.Build.Experimental.Graph
 ```
 
 ## Isolated builds
+
 Building a project in isolation means enforcing the constraint that whenever a graph node is built, all the target calls that it does on its references **do not execute** because their results are already available. This means that any `BuildResult` objects for project references must be precomputed and somehow provided as inputs to the referencing project.
 
 If a project uses the MSBuild task, the build result must be in MSBuild's build result cache instead of just-in-time executing targets on that referenced project. If it is not in the build result cache, an error will be logged and the build will fail. If the project is calling into itself either via `CallTarget` or the MSBuild task with a different set of global properties, this will be allowed to support multitargeting and other build dimensions implemented in a similar way.
@@ -367,6 +383,7 @@ If a project uses the MSBuild task, the build result must be in MSBuild's build
 Because referenced projects and their entry targets are guaranteed to be in the cache, they will not build again. Therefore we do not need to set `/p:BuildProjectReferences=false` or any other gesture that tells SDKs to not do recursive operations.
 
 ### Isolated graph builds
+
 When building a graph in isolated mode, the graph is used to traverse and build the projects in the right order, but each individual project is built in isolation. The build result cache will just be in memory exactly as it is today, but on cache miss it will error. This enforces that both the graph and target mappings are complete and correct.
 
 Furthermore, running in this mode enforces that each `(project, global properties)` pair is executed only once and must execute all targets needed by all projects which reference that node. This gives it a concrete start and end time, which leads to some potential perf optimizations, like garbage collecting all project state (except the build results) once it finishes building. This can greatly reduce the memory overhead for large builds.
@@ -374,9 +391,11 @@ Furthermore, running in this mode enforces that each `(project, global propertie
 This discrete start and end time also allows for easy integration with [I/O Tracking](#io-tracking) to observe all inputs and outputs for a project. Note however that I/O during target execution, particular target execution which may not normally happen as part of a project's individual build execution, would be attributed to the project reference project rather the project with the project reference. This differs from today's behavior, but seems like a desirable difference anyway.
 
 ### Single project isolated builds
+
 When building a single project in isolation, all project references' build results must be provided to the project externally. Specifically, the results will need to be [deserialized](#deserialization) from files and loaded into the build result cache in memory.
 
 When MSBuild runs in isolation mode, it fails the build when it detects:
+
 1. `MSBuild` task calls which cannot be served from the cache. Cache misses are illegal.
 2. `MSBuild` task calls to project files which were not defined in the `ProjectReference` item.
 
@@ -389,16 +408,20 @@ These incremental builds could be extended to the entire graph by keeping a proj
 Details on how isolation and cache files are implemented in MSBuild can be found [here](./static-graph-implementation-details.md).
 
 #### APIs
+
 Cache file information is provided via [`BuildParameters`](https://github.com/dotnet/msbuild/blob/2d4dc592a638b809944af10ad1e48e7169e40808/src/Build/BackEnd/BuildManager/BuildParameters.cs#L746-L764). Input caches are applied in `BuildManager.BeginBuild`. Output cache files are written in `BuildManager.EndBuild`. Thus, the scope of the caches are one `BuildManager` `BeginBuild`/`EndBuild` session.
 
 Isolation constraints are turned on via [`BuildParameters.IsolateProjects`](https://github.com/dotnet/msbuild/blob/b111470ae61eba02c6102374c2b7d62aebe45f5b/src/Build/BackEnd/BuildManager/BuildParameters.cs#L742). Isolation constraints are also automatically turned on if either input or output cache files are used, except when the `isolate:MessageUponIsolationViolation` switch is used.
 
 #### Command line
+
 Caches are provided to MSBuild.exe via the multi value `/inputResultsCaches` and the single value `/outputResultsCache`.
 Isolation constraints are turned on via `/isolate` (they are also implicitly activated when either input or output caches are used).
 
 #### Exempting references from isolation constraints
+
 In certain situations one may want to exempt a reference from isolation constraints. A few potential cases:
+
 - debugging / onboarding to isolation constraints
 - exempting references whose project files are generated at build times with random names (for example, each WPF project, before the Build target, generates and builds a helper .csproj with a random file name)
 - relaxing constraints for MSBuild task calling patterns that static graph cannot express (for exemple, if a project is calculating references, or the targets to call on references, at runtime via an arbitrary algorithm)
@@ -422,6 +445,7 @@ If multiple projects need to exempt the same reference, all of them need to add
 For now, self-builds (a project building itself with different global properties) are also exempt from isolation constraints, but this behaviour is of dubious value and might be changed in the future.
 
 ## I/O Tracking
+
 To help facilitate caching of build outputs by a higher-order build engine, MSBuild needs to track all I/O that happens as part of a build.
 
 **OPEN ISSUE:** This isn't actually true in most scenarios. Today the MS internal build engine can wrap any arbitrary process to track the I/O that happens as part of its execution as well as its children. That's sufficient for all scenarios except compiler servers or an MSBuild server (see below). Additionally, if the MS internal build engine supports any other build type besides MSBuild (or older versions of MSBuild), it will still need to be able to detour the process itself anyway.
@@ -429,6 +453,7 @@ To help facilitate caching of build outputs by a higher-order build engine, MSBu
 **NOTE**: Based on the complexity and challenges involved, the feature of I/O tracking in MSBuild is currently on hold and not scheduled to be implemented. This section intends to describe these challenges and be a dump of the current thinking on the subject.
 
 ### Detours
+
 [Detours](https://github.com/microsoft/detours) will be used to intercept Windows API calls to track I/O. This is the same technology that [FileTracker](../../src/Utilities/TrackedDependencies/FileTracker.cs) and [FullTracking](../../src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs) use as well as what the MS internal build engine ("BuildXL Tracker") uses to track I/O.
 
 Today FileTracker and FullTracking are currently a bit specific to generating tlogs, and do not collect all the I/O operations we would want to collect like directory enumerations and probes. Additionally, the BuildXL Tracker implementation does not currently have the ability to attach to the currently running process.
@@ -438,11 +463,13 @@ Either existing implementation would require some work to fit this scenario. Bec
 Elsewhere in this spec the final Detours-based file tracking implementation will simply be referred to as "Tracker".
 
 ### Isolation requirement
+
 I/O Tracking will only be available when running isolated builds, as the current implementation of project yielding in MSBuild makes it exceedingly difficult to attribute any observed I/O to the correct project. Isolated builds make this feasible since each MSBuild node will be building exactly one project configuration at any given moment and each project configuration has a concrete start and stop time. This allows us to turn on I/O tracking for the MSBuild process and start and stop tracking with the project start and stop.
 
 **OPEN ISSUE:** For graph-based isolated builds, project evaluation happens in parallel on the main node. Any I/O that happens as part of evaluation should be reported for that specific project, but there's no good way to do that here.
 
 ### Tool servers
+
 Tool servers are long-lived processes which can be reused multiple times across builds. This causes problems for Tracker, as that long-lived process is not a child process of MSBuild, so many I/O operations would be missed.
 
 For example, when `SharedCompilation=true`, the Roslyn compiler (csc.exe) will launch in server mode. This causes the `Csc` task to connect to any existing csc.exe process and pass the compilation request over a named pipe.
diff --git a/documentation/specs/task-isolation-and-dependencies.md b/documentation/specs/task-isolation-and-dependencies.md
index 2ec96c8eb18..2994335dfc8 100644
--- a/documentation/specs/task-isolation-and-dependencies.md
+++ b/documentation/specs/task-isolation-and-dependencies.md
@@ -1,39 +1,50 @@
 # Task isolation
+
 ## Problem definition
+
 Tasks in MSBuild are dynamically loaded assemblies with potentially separate and colliding dependency trees. Currently MSBuild on .NET Core has no isolation between tasks and as such only one version of any given assembly can be loaded. Prime example of this is Newtonsoft.Json which has multiple versions, but all the tasks must agree on it to work.
 This problem is also described in #1754.
 
 ## Solution
+
 Use [`AssemblyLoadContext`](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-2.2) (ALC) to provide binding isolation for task assemblies. Each task assembly would be loaded into its own ALC instance.
-* The ALC would resolve all dependencies of the task assemblies (see dependency resolution below)
-* ALC would fallback to the Default for dependencies which the assembly doesn't carry with itself (frameworks and so on)
-* ALC would probably have to forcefully fallback for MSBuild assemblies since it's possible that tasks will carry these, but the system requires for the MSBuild assemblies to be shared.
+
+- The ALC would resolve all dependencies of the task assemblies (see dependency resolution below)
+- ALC would fallback to the Default for dependencies which the assembly doesn't carry with itself (frameworks and so on)
+- ALC would probably have to forcefully fallback for MSBuild assemblies since it's possible that tasks will carry these, but the system requires for the MSBuild assemblies to be shared.
 
 We also want to load groups of tasks which belong together into the same ALC (for example based on their location on disk) to improve performance. This will need some care as there's no guarantee that two random tasks have compatible dependency trees. As implemented, each task assembly is loaded into its own ALC.
 
 ## Potential risks
-* Has some small probability of causing breaks. Currently all assemblies from all tasks are loaded into the default context and thus are "visible" to everybody. Tasks with following properties might not work:
-  * Task has a dependency on an assembly, but it doesn't declare this dependency in its .deps.json and this dependency gets loaded through some other task. This is mostly fixable by implementing probing similar to today's behavior.
-  * Two tasks from different assemblies which somehow rely on sharing certain types. If the new system decides to load these in isolation they won't share types anymore and might not work.
-* Performance - task isolation inherently (and by design) leads to loading certain assemblies multiple times. This increases memory pressure and causes additional JITing and other related work.
+
+- Has some small probability of causing breaks. Currently all assemblies from all tasks are loaded into the default context and thus are "visible" to everybody. Tasks with following properties might not work:
+  - Task has a dependency on an assembly, but it doesn't declare this dependency in its .deps.json and this dependency gets loaded through some other task. This is mostly fixable by implementing probing similar to today's behavior.
+  - Two tasks from different assemblies which somehow rely on sharing certain types. If the new system decides to load these in isolation they won't share types anymore and might not work.
+- Performance - task isolation inherently (and by design) leads to loading certain assemblies multiple times. This increases memory pressure and causes additional JITing and other related work.
 
 ## Additional consideration
-* None of these changes would have any effect on MSBuild on .NET Framework
-* Task isolation alone could be achieved on existing MSBuild
+
+- None of these changes would have any effect on MSBuild on .NET Framework
+- Task isolation alone could be achieved on existing MSBuild
 
 # Task dependency resolution
+
 ## Problem definition
+
 Tasks with complex and specifically platform specific dependencies don't work out of the box. For example if a task uses [`LibGit2Sharp`](https://www.nuget.org/packages/LibGit2Sharp) package it will not work as is. `LibGit2Sharp` has native dependencies which are platform specific. While the package carries all of them, there's no built in support for the task to load the right ones. For example [source link](https://github.com/dotnet/sourcelink/blob/29b3197e824c05d03427c05d56700e4c704233e4/src/Microsoft.Build.Tasks.Git/GitLoaderContext.cs) runs into this problem.
 
 ## Solution
+
 .NET Core uses `.deps.json` files to describe dependencies of components. It would be natural to treat task assemblies as components and use associated .deps.json file to determine their dependencies. This would make the system work nicely end to end with the .NET Core CLI/SDK and VS integration.
 In .NET Core 3 there's a new type [`AssemblyDependencyResolver`](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Runtime/Loader/AssemblyDependencyResolver.cs) which implements parsing and processing of a `.deps.json` for a component (or assembly). The usage is to create an instance of the resolver pointing to the assembly (in MSBuild case the task assembly). The resolver parses the `.deps.json` and stores the information. It exposes two methods to resolve managed and native dependencies.
 It was designed to be used as the underlying piece to implement custom ALC. So it would work nicely with task isolation above.
 
 ## Potential risks
-* Small probability of breaking tasks which have `.deps.json` with them and those are not correct. With this change the file would suddenly be used and could cause either load failures or different versions of assemblies to get loaded.
+
+- Small probability of breaking tasks which have `.deps.json` with them and those are not correct. With this change the file would suddenly be used and could cause either load failures or different versions of assemblies to get loaded.
 
 ## Additional consideration
-* Task dependency resolution requires APIs which are only available in .NET Core 3.0 (no plan to backport), as such MSBuild will have to target netcoreapp3.0 to use these APIs.
+
+- Task dependency resolution requires APIs which are only available in .NET Core 3.0 (no plan to backport), as such MSBuild will have to target netcoreapp3.0 to use these APIs.
 
 We decided not to implement `AssemblyDependencyResolver` in the .NET Core 3.x timeframe because of the uncertain impact of the change. We should reconsider in the .NET 5 timeframe.
diff --git a/documentation/specs/test-target.md b/documentation/specs/test-target.md
index 7726f1f6971..e5818eb6c81 100644
--- a/documentation/specs/test-target.md
+++ b/documentation/specs/test-target.md
@@ -1,62 +1,77 @@
-## MSBuild Test Target and Task 
+# MSBuild Test Target and Task
+
 See: [MSBuild Test Target](https://github.com/dotnet/msbuild/pull/9193)
 
-### Motivation
+## Motivation
+
 The primary motivation of the MSBuild Test Target is to offer a convienent and standardardized way for executing tests within the msbuild environment. This is inspired by the simplicity of the `dotnet test` command. The proposed command for initiating test within MSBuild would be `msbuild /t:Test`
 
 Another significatnt benefit of integrating this target is to faciliatet the caching of test executions, using MSBuild project caching capabilities. This enhancement will optimize the testing process by reducing test runs which could significantly reduce time spent building and testing, as tests would only execute, (after the initial run) if there are changes to those tests. As an example running with [MSBuildCache](https://github.com/microsoft/MSBuildCache) we can cache both build and test executions. Functionally, this means skipping test executions that have been determined to have not changed.
 Example usage:
 `msbuild /graph /restore:false /m /nr:false /reportfileaccesses /t:"Build;Test"`
 
-### Design Overview
+## Design Overview
+
 The 'Microsoft.Common.Test.targets' file contains a stub test target.
-```
+
+```xml
 <Project>
     <Target Name="Test"></Target>
 </Project>
 ```
+
 This target serves a placeholder and entry point for test target implementations.
 
-#### Conditional Import
-* This stub target is conditionally imported, determined by a condition named 
+### Conditional Import
+
+- This stub target is conditionally imported, determined by a condition named
 `$(UseMSBuildTestInfrastructure)`.
-* This condition allows for users to opt-in to this test target, which helps to prevent breaking changes, with respect the the target name, since there are likely 'Test' targets that exist in the wild already.
+- This condition allows for users to opt-in to this test target, which helps to prevent breaking changes, with respect the the target name, since there are likely 'Test' targets that exist in the wild already.
 
 The 'Microsoft.Common.CurrentVersion.targets' file contains.
-```
+
+```xml
   <PropertyGroup>
     <UseMSBuildTestInfrastructure Condition="'$(UseMSBuildTestInfrastructure)' == ''">false</UseMSBuildTestInfrastructure>
   </PropertyGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.Common.Test.targets" Condition="'$(UseMSBuildTestInfrastructure)' == 'true'"/>
 
 ```
-#### Extensibility for Test Runners
-* Test runner implemenations can hook into the provided stub using the `AfterTargets` property.
-* This approach enables different test runners to extend the basic funcionarlity of the test target.
+
+### Extensibility for Test Runners
+
+- Test runner implemenations can hook into the provided stub using the `AfterTargets` property.
+- This approach enables different test runners to extend the basic funcionarlity of the test target.
 
 For instance, an implementation for running VSTest would look like:
-```
+
+```xml
 <Target Name="RunVSTest" AfterTargets="Test">
   <!-- Implementation details here -->
 </Target>
 ```
 
-#### Usage Scenario
-* Users who wish to utilize this target will set the `$(UseMSBuildTestInfrastructure)` condition in their project file, rsp or via the command line.
-* By executing `msbuild /t:Test`, the MSBuild engine will envoke the `Test` taget, which in turn triggers any test runner targets defined to run after it.
+### Usage Scenario
+
+- Users who wish to utilize this target will set the `$(UseMSBuildTestInfrastructure)` condition in their project file, rsp or via the command line.
+- By executing `msbuild /t:Test`, the MSBuild engine will envoke the `Test` taget, which in turn triggers any test runner targets defined to run after it.
+
+## Default Task Implementation
 
-### Default Task Implementation
 See: [MSBuild Test Task](https://github.com/microsoft/MSBuildSdks/pull/473)
 
-#### Nuget package for default implementaion
-* The default implementation will be provided through a nuget package.
-* This package will contain an MSBuild Task deigned to execute `vstest.console.exe`.
+### Nuget package for default implementaion
+
+- The default implementation will be provided through a nuget package.
+- This package will contain an MSBuild Task deigned to execute `vstest.console.exe`.
+
+### MSBuild Task Functionality
+
+- The core of this implemenation is an MSBuild task that interfaces with `vstest.console.exe`.
+- This task will accept arguments as properties and pass them directly into the command line test runner.
 
-#### MSBuild Task Functionality
-* The core of this implemenation is an MSBuild task that interfaces with `vstest.console.exe`.
-* This task will accept arguments as properties and pass them directly into the command line test runner.
+### Using The Default Implementation
 
-#### Using The Default Implementation
-* Users would install the provided Nuget Package to incorporate it into their projects.
-* Add the package to their GlobalPackageReferences or specific projects.
-* Once integrated, executing `msbuild /t:Test` would trigger the MSBuild Task, ultimately executing `vstest.console.exe`.
+- Users would install the provided Nuget Package to incorporate it into their projects.
+- Add the package to their GlobalPackageReferences or specific projects.
+- Once integrated, executing `msbuild /t:Test` would trigger the MSBuild Task, ultimately executing `vstest.console.exe`.
diff --git a/eng/BootStrapMsBuild.targets b/eng/BootStrapMsBuild.targets
index dcff8617638..d4330ba658d 100644
--- a/eng/BootStrapMsBuild.targets
+++ b/eng/BootStrapMsBuild.targets
@@ -35,7 +35,8 @@
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Newtonsoft.Json'))' == 'true'" />
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('NuGetSdkResolver'))' == 'true'" />
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Microsoft.Extensions.'))' == 'true'" />
-
+        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Microsoft.VisualStudio.SolutionPersistence'))' == 'true'" />
+      
         <!-- NuGet.targets and NuGet.RestoreEx.targets will be in the RuntimeTargetsCopyLocalItems ItemGroup -->
         <_NuGetRuntimeDependencies Include="%(RuntimeTargetsCopyLocalItems.Identity)" Condition="'@(RuntimeTargetsCopyLocalItems->Contains('NuGet.'))' == 'true'" />
 
@@ -48,7 +49,7 @@
 
   <Target Name="RemoveExtraAssemblyReferences" BeforeTargets="ResolveAssemblyReferences">
     <!-- This is really hacky, but these references will cause issues when trying to 'build' this project.
-         To acquire the NuGet binaries we depend on for local run-time ('bootstrap'), we we are using a PackageReference (to
+         To acquire the NuGet binaries we depend on for local run-time ('bootstrap'), we are using a PackageReference (to
          'NuGet.Build.Tasks' and 'Microsoft.Build.NuGetSdkResolver'). This has the advantage of using NuGets compatibility
          check to ensure we choose the right version of those assemblies. But, at 'bootstrap' time these runtime dependencies
          need to be in a specific location that does not mesh with NuGet. To resolve this, we include the default
diff --git a/eng/Packages.props b/eng/Packages.props
index a677edd736e..456f037819e 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -19,22 +19,33 @@
     <PackageVersion Include="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
     <PackageVersion Include="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
     <PackageVersion Include="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
+    <PackageVersion Include="System.Diagnostics.DiagnosticSource" Version="$(SystemDiagnosticsDiagnosticSourceVersion)" />
+    <PackageVersion Include="System.Diagnostics.EventLog" Version="$(SystemDiagnosticsEventLogVersion)" />
     <PackageVersion Include="System.Formats.Asn1" Version="$(SystemFormatsAsn1Version)" />
+    <PackageVersion Include="System.Formats.Nrbf" Version="$(SystemFormatsNrbfVersion)" />
     <PackageVersion Include="System.Memory" Version="$(SystemMemoryVersion)" />
-    <PackageVersion Include="System.Net.Http" Version="$(SystemNetHttpVersion)" />
     <PackageVersion Include="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
     <PackageVersion Include="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
     <PackageVersion Include="System.Resources.Extensions" Version="$(SystemResourcesExtensionsVersion)" />
     <PackageVersion Include="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
+    <PackageVersion Include="System.Security.Cryptography.ProtectedData" Version="$(SystemSecurityCryptographyProtectedDataVersion)" />
     <PackageVersion Include="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
     <PackageVersion Include="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
     <PackageVersion Include="System.Text.Json" Version="$(SystemTextJsonVersion)" />
-    <PackageVersion Include="System.Text.RegularExpressions" Version="$(SystemTextRegularExpressionsVersion)" />
     <PackageVersion Include="System.Threading.Channels" Version="$(SystemThreadingChannelsVersion)" />
     <PackageVersion Include="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
+    <PackageVersion Include="System.Threading.Tasks.Extensions" Version="$(SystemThreadingTasksExtensionsVersion)" />
     <PackageVersion Include="xunit.console" Version="$(XUnitVersion)" />
     <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.Collector" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
     <PackageVersion Include="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions" Version="$(MicrosoftVisualStudioOpenTelemetryVersion)" />
-    <PackageVersion Include="System.Diagnostics.DiagnosticSource" Version="$(SystemDiagnosticsDiagnosticSourceVersion)" />
+
+    <!-- maintained in eng/dependabot/Packages.props -->
+    <!--
+      System.CodeDom
+      System.Security.Cryptography.Pkcs
+      System.Security.Cryptography.Xml
+      Microsoft.Bcl.Cryptography
+      Microsoft.VisualStudio.SolutionPersistence
+    -->
   </ItemGroup>
 </Project>
diff --git a/eng/SourceBuildPrebuiltBaseline.xml b/eng/SourceBuildPrebuiltBaseline.xml
index 15779fde2b2..6bf7dfcbf3a 100644
--- a/eng/SourceBuildPrebuiltBaseline.xml
+++ b/eng/SourceBuildPrebuiltBaseline.xml
@@ -3,24 +3,29 @@
 
 <UsageData>
   <IgnorePatterns>
-    <!-- 8.0 packages are not allowed in the 8.0 build, because they're not "current", so baseline them. -->
-    <UsagePattern IdentityGlob="System.CodeDom/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Collections.Immutable/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.1*" />
-    <UsagePattern IdentityGlob="System.Reflection.Metadata/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Resources.Extensions/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Text.Json/*8.0.5*" />
-    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*8.0.0*" />
-    <UsagePattern IdentityGlob="System.Formats.Asn1/*8.0.1*" />
-    <UsagePattern IdentityGlob="Microsoft.VisualStudio.SolutionPersistence/*1.0.*" />
-    <!-- Defined in Version.Details.xml - live version used in SB. -->
-    <UsagePattern IdentityGlob="System.Diagnostics.DiagnosticSource/*8.0.1*" />
+    <!-- 9.0 packages are not allowed in the 9.0 build, because they're not "current", so baseline them. -->
+    <UsagePattern IdentityGlob="System.CodeDom/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Collections.Immutable/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Configuration.ConfigurationManager/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Diagnostics.DiagnosticSource/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Formats.Asn1/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.Metadata/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Reflection.MetadataLoadContext/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Resources.Extensions/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Pkcs/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.ProtectedData/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Security.Cryptography.Xml/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Encoding.CodePages/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Text.Json/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Threading.Channels/*9.0.0*" />
+    <UsagePattern IdentityGlob="System.Threading.Tasks.Dataflow/*9.0.0*" />
+
+    <!-- dependency of System.Configuration.ConfigurationManager -->
+    <UsagePattern IdentityGlob="System.Diagnostics.EventLog/*9.0.0*" />
+    <!-- dependency of System.Resources.Extensions -->
+    <UsagePattern IdentityGlob="System.Formats.Nrbf/*9.0.0*" />
+    <!-- dependency of System.Security.Cryptography.Pkcs -->
+    <UsagePattern IdentityGlob="Microsoft.Bcl.Cryptography/*9.0.0*" />
   </IgnorePatterns>
   <Usages>
   </Usages>
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 5c896bf1713..6e1e643d391 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -2,109 +2,157 @@
 <Dependencies>
   <ProductDependencies>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="9.0.0-alpha.1.25081.6">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="9.0.0-alpha.1.25170.3">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>1cec3b4a8fb07138136a1ca1e04763bfcf7841db</Sha>
+      <Sha>6968f7059f4418e985febe704a3b1320f9e5887d</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
+    <!-- Intermediate is necessary for source build. -->
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-externals" Version="9.0.0-alpha.1.25160.2">
+      <Uri>https://github.com/dotnet/source-build-externals</Uri>
+      <Sha>e2c3c1329ea432b36e4570d977271454e8abb0a0</Sha>
+      <SourceBuild RepoName="source-build-externals" ManagedOnly="true" />
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="Microsoft.Bcl.Cryptography" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.CodeDom" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Collections.Immutable" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Configuration.ConfigurationManager" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
+    </Dependency>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Diagnostics.DiagnosticSource" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
+    </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.CodeDom" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <Dependency Name="System.Diagnostics.EventLog" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <!-- Necessary for source-build due to being a transitive dependency of System.Reflection.MetadataLoadContext.
-      This allows the package to be retrieved from previously-source-built artifacts and flow in as dependencies
-      of the packages produced by msbuild. -->
-    <Dependency Name="System.Collections.Immutable" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Formats.Asn1" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Configuration.ConfigurationManager" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Formats.Nrbf" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Reflection.Metadata" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Reflection.Metadata" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Reflection.MetadataLoadContext" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Reflection.MetadataLoadContext" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Resources.Extensions" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <Dependency Name="System.Resources.Extensions" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <!-- Necessary for source-build. This allows the package to be retrieved from previously-source-built artifacts
-      and flow in as dependencies of the packages produced by msbuild. -->
-    <Dependency Name="System.Security.Cryptography.Pkcs" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Security.Cryptography.ProtectedData" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
-    <Dependency Name="System.Security.Cryptography.Xml" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <Dependency Name="System.Security.Cryptography.Pkcs" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <Dependency Name="System.Text.Json" Version="8.0.5">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>81cabf2857a01351e5ab578947c7403a5b128ad1</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Security.Cryptography.Xml" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <Dependency Name="System.Threading.Tasks.Dataflow" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Text.Encoding.CodePages" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <Dependency Name="System.Threading.Channels" Version="8.0.0">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>5535e31a712343a63f5d7d796cd874e563e5ac14</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Text.Json" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <Dependency Name="System.Formats.Asn1" Version="8.0.1">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>2aade6beb02ea367fd97c4070a4198802fe61c03</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Threading.Channels" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
-    <Dependency Name="System.Diagnostics.DiagnosticSource" Version="8.0.1">
-      <Uri>https://dev.azure.com/dnceng/internal/_git/dotnet-runtime</Uri>
-      <Sha>2d7eea252964e69be94cb9c847b371b23e4dd470</Sha>
+    <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
+    <Dependency Name="System.Threading.Tasks.Dataflow" Version="9.0.0">
+      <Uri>https://github.com/dotnet/runtime</Uri>
+      <Sha>
+      </Sha>
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25111.5">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25164.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
+      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.25111.5">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="9.0.0-beta.25164.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
+      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.25111.5">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="9.0.0-beta.25164.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
+      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.14.0-preview.1.39">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.14.0-preview.1.97">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>68db83a99814547864e09170f6c3179b33933a27</Sha>
+      <Sha>8f6362aea4972acab1454de411cfe835619e4e41</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-2.25111.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-3.25179.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>19c9b9eb00ae9afa7bedb10bd6be06bb41a880f6</Sha>
+      <Sha>304768b76e90f5d224b745e3a03cfc5e9509baf6</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.14.0-2.25111.1">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.roslyn" Version="4.14.0-3.25179.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>19c9b9eb00ae9afa7bedb10bd6be06bb41a880f6</Sha>
+      <Sha>304768b76e90f5d224b745e3a03cfc5e9509baf6</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25111.5">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25164.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>5da211e1c42254cb35e7ef3d5a8428fb24853169</Sha>
+      <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index d6c1fba412d..1e4ef0a7a5f 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,11 +2,16 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.14.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.13.0-preview-24611-01</PackageValidationBaselineVersion>
+    <VersionPrefix>17.15.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.14.0-preview-25161-14</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
-    <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
+    <!--
+      Don't use shipping versions when building in the VMR unless the VMR directs the build to use shipping versions.
+      This can cause issues when building downstream repos in the orchestrated build if the time MSBuild
+      is built crosses a UTC date boundary.
+    -->
+    <DotNetUseShippingVersions Condition="'$(DotNetBuildOrchestrator)' != 'true'">true</DotNetUseShippingVersions>
     <!-- Workaround for https://github.com/dotnet/roslyn/issues/35793 -->
     <SemanticVersioningV1>true</SemanticVersioningV1>
     <MicroBuildPluginsSwixBuildVersion>1.1.87</MicroBuildPluginsSwixBuildVersion>
@@ -20,42 +25,46 @@
     <UsingToolVSSDK>true</UsingToolVSSDK>
   </PropertyGroup>
   <!-- Production Dependencies -->
-  <!-- Condition consumption of maintenance-packages dependencies based on source build.
-       This is to prevent "package downgrade" errors coming from other packages that are
-       already consuming the newest version of these same dependencies. -->
-  <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' == 'true'">
-    <!-- Use newest package versions. -->
-    <SystemMemoryVersion>4.6.0</SystemMemoryVersion>
-    <SystemRuntimeCompilerServicesUnsafeVersion>6.1.0</SystemRuntimeCompilerServicesUnsafeVersion>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(DotNetBuildSourceOnly)' != 'true'">
-    <!-- Keep using older versions. Upgrade carefully. -->
+  <PropertyGroup>
+    <!-- manually maintained versions -->
     <!--
         Modifying the version of System.Memory is very high impact and causes downstream breaks in third-party tooling that uses the MSBuild API.
         When updating the version of System.Memory file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+
         and follow the guidelines written here (internal-link): https://dev.azure.com/devdiv/DevDiv/_wiki/wikis/DevDiv.wiki/1796/How-to-add-a-Known-Issue
     -->
-    <SystemMemoryVersion>4.5.5</SystemMemoryVersion>
-    <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
+    <SystemMemoryVersion>4.6.0</SystemMemoryVersion>
+    <SystemThreadingTasksExtensionsVersion>4.6.0</SystemThreadingTasksExtensionsVersion>
+    <MicrosoftIORedistVersion>6.1.0</MicrosoftIORedistVersion>
+    <MicrosoftVisualStudioOpenTelemetryVersion>0.2.104-beta</MicrosoftVisualStudioOpenTelemetryVersion>
+    <SystemRuntimeCompilerServicesUnsafeVersion>6.1.0</SystemRuntimeCompilerServicesUnsafeVersion>
+    <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
   </PropertyGroup>
   <PropertyGroup>
-    <MicrosoftIORedistVersion>6.0.1</MicrosoftIORedistVersion>
-    <MicrosoftVisualStudioSolutionPersistenceVersion>1.0.28</MicrosoftVisualStudioSolutionPersistenceVersion>
-    <SystemCollectionsImmutableVersion>8.0.0</SystemCollectionsImmutableVersion>
-    <SystemConfigurationConfigurationManagerVersion>8.0.0</SystemConfigurationConfigurationManagerVersion>
-    <SystemFormatsAsn1Version>8.0.1</SystemFormatsAsn1Version>
-    <SystemNetHttpVersion>4.3.4</SystemNetHttpVersion>
-    <SystemReflectionMetadataLoadContextVersion>8.0.0</SystemReflectionMetadataLoadContextVersion>
-    <SystemReflectionMetadataVersion>8.0.0</SystemReflectionMetadataVersion>
-    <SystemResourcesExtensionsVersion>8.0.0</SystemResourcesExtensionsVersion>
-    <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
-    <SystemTextEncodingCodePagesVersion>7.0.0</SystemTextEncodingCodePagesVersion>
-    <SystemTextRegularExpressionsVersion>4.3.1</SystemTextRegularExpressionsVersion>
-    <SystemTextJsonVersion>8.0.5</SystemTextJsonVersion>
-    <SystemThreadingChannelsVersion>8.0.0</SystemThreadingChannelsVersion>
-    <SystemThreadingTasksDataflowVersion>8.0.0</SystemThreadingTasksDataflowVersion>
-    <SystemDiagnosticsDiagnosticSourceVersion>8.0.1</SystemDiagnosticsDiagnosticSourceVersion>
-    <MicrosoftVisualStudioOpenTelemetryVersion>0.2.104-beta</MicrosoftVisualStudioOpenTelemetryVersion>
+    <!-- dotnet/runtime packages -->
+    <SystemCollectionsImmutableVersion>9.0.0</SystemCollectionsImmutableVersion>
+    <SystemConfigurationConfigurationManagerVersion>9.0.0</SystemConfigurationConfigurationManagerVersion>
+    <SystemDiagnosticsDiagnosticSourceVersion>9.0.0</SystemDiagnosticsDiagnosticSourceVersion>
+    <SystemDiagnosticsEventLogVersion>9.0.0</SystemDiagnosticsEventLogVersion>
+    <SystemFormatsAsn1Version>9.0.0</SystemFormatsAsn1Version>
+    <SystemFormatsNrbfVersion>9.0.0</SystemFormatsNrbfVersion>
+    <SystemReflectionMetadataVersion>9.0.0</SystemReflectionMetadataVersion>
+    <SystemReflectionMetadataLoadContextVersion>9.0.0</SystemReflectionMetadataLoadContextVersion>
+    <SystemResourcesExtensionsVersion>9.0.0</SystemResourcesExtensionsVersion>
+    <SystemSecurityCryptographyProtectedDataVersion>9.0.0</SystemSecurityCryptographyProtectedDataVersion>
+    <SystemTextEncodingCodePagesVersion>9.0.0</SystemTextEncodingCodePagesVersion>
+    <SystemTextJsonVersion>9.0.0</SystemTextJsonVersion>
+    <SystemThreadingChannelsVersion>9.0.0</SystemThreadingChannelsVersion>
+    <SystemThreadingTasksDataflowVersion>9.0.0</SystemThreadingTasksDataflowVersion>
+  </PropertyGroup>
+  <PropertyGroup>
+    <!-- maintained in eng/dependabot/Packages.props -->
+    <!--
+    <SystemCodeDomVersion></SystemCodeDomVersion>
+    <SystemSecurityCryptographyPkcsVersion></SystemSecurityCryptographyPkcsVersion>
+    <SystemSecurityCryptographyXmlVersion></SystemSecurityCryptographyXmlVersion>
+    <MicrosoftBclCryptographyVersion></MicrosoftBclCryptographyVersion>
+    <MicrosoftVisualStudioSolutionPersistenceVersion></MicrosoftVisualStudioSolutionPersistenceVersion>
+    -->
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
@@ -63,9 +72,9 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25111.5</MicrosoftDotNetXUnitExtensionsVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.14.0-2.25111.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.14.0-preview.1.39</NuGetBuildTasksVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25164.2</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.14.0-3.25179.1</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.14.0-preview.1.97</NuGetBuildTasksVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
     <BootstrapSdkVersion>9.0.200-preview.0.24603.3</BootstrapSdkVersion>
diff --git a/eng/common/core-templates/steps/generate-sbom.yml b/eng/common/core-templates/steps/generate-sbom.yml
index d938b60e1bb..56a09009482 100644
--- a/eng/common/core-templates/steps/generate-sbom.yml
+++ b/eng/common/core-templates/steps/generate-sbom.yml
@@ -38,7 +38,7 @@ steps:
       PackageName: ${{ parameters.packageName }}
       BuildDropPath: ${{ parameters.buildDropPath }}
       PackageVersion: ${{ parameters.packageVersion }}
-      ManifestDirPath: ${{ parameters.manifestDirPath }}
+      ManifestDirPath: ${{ parameters.manifestDirPath }}/$(ARTIFACT_NAME)
       ${{ if ne(parameters.IgnoreDirectories, '') }}:
         AdditionalComponentDetectorArgs: '--IgnoreDirectories ${{ parameters.IgnoreDirectories }}'
 
diff --git a/eng/common/generate-sbom-prep.ps1 b/eng/common/generate-sbom-prep.ps1
index 3e5c1c74a1c..a0c7d792a76 100644
--- a/eng/common/generate-sbom-prep.ps1
+++ b/eng/common/generate-sbom-prep.ps1
@@ -4,18 +4,26 @@ Param(
 
 . $PSScriptRoot\pipeline-logging-functions.ps1
 
+# Normally - we'd listen to the manifest path given, but 1ES templates will overwrite if this level gets uploaded directly
+# with their own overwriting ours. So we create it as a sub directory of the requested manifest path.
+$ArtifactName = "${env:SYSTEM_STAGENAME}_${env:AGENT_JOBNAME}_SBOM"
+$SafeArtifactName = $ArtifactName -replace '["/:<>\\|?@*"() ]', '_'
+$SbomGenerationDir = Join-Path $ManifestDirPath $SafeArtifactName
+
+Write-Host "Artifact name before : $ArtifactName"
+Write-Host "Artifact name after : $SafeArtifactName"
+
 Write-Host "Creating dir $ManifestDirPath"
+
 # create directory for sbom manifest to be placed
-if (!(Test-Path -path $ManifestDirPath))
+if (!(Test-Path -path $SbomGenerationDir))
 {
-  New-Item -ItemType Directory -path $ManifestDirPath
-  Write-Host "Successfully created directory $ManifestDirPath"
+  New-Item -ItemType Directory -path $SbomGenerationDir
+  Write-Host "Successfully created directory $SbomGenerationDir"
 }
 else{
   Write-PipelineTelemetryError -category 'Build'  "Unable to create sbom folder."
 }
 
 Write-Host "Updating artifact name"
-$artifact_name = "${env:SYSTEM_STAGENAME}_${env:AGENT_JOBNAME}_SBOM" -replace '["/:<>\\|?@*"() ]', '_'
-Write-Host "Artifact name $artifact_name"
-Write-Host "##vso[task.setvariable variable=ARTIFACT_NAME]$artifact_name"
+Write-Host "##vso[task.setvariable variable=ARTIFACT_NAME]$SafeArtifactName"
diff --git a/eng/common/generate-sbom-prep.sh b/eng/common/generate-sbom-prep.sh
index d5c76dc827b..b8ecca72bbf 100644
--- a/eng/common/generate-sbom-prep.sh
+++ b/eng/common/generate-sbom-prep.sh
@@ -14,19 +14,24 @@ done
 scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
 . $scriptroot/pipeline-logging-functions.sh
 
+
+# replace all special characters with _, some builds use special characters like : in Agent.Jobname, that is not a permissible name while uploading artifacts.
+artifact_name=$SYSTEM_STAGENAME"_"$AGENT_JOBNAME"_SBOM"
+safe_artifact_name="${artifact_name//["/:<>\\|?@*$" ]/_}"
 manifest_dir=$1
 
-if [ ! -d "$manifest_dir" ] ; then
-  mkdir -p "$manifest_dir"
-  echo "Sbom directory created." $manifest_dir
+# Normally - we'd listen to the manifest path given, but 1ES templates will overwrite if this level gets uploaded directly
+# with their own overwriting ours. So we create it as a sub directory of the requested manifest path.
+sbom_generation_dir="$manifest_dir/$safe_artifact_name"
+
+if [ ! -d "$sbom_generation_dir" ] ; then
+  mkdir -p "$sbom_generation_dir"
+  echo "Sbom directory created." $sbom_generation_dir
 else
   Write-PipelineTelemetryError -category 'Build'  "Unable to create sbom folder."
 fi
 
-artifact_name=$SYSTEM_STAGENAME"_"$AGENT_JOBNAME"_SBOM"
 echo "Artifact name before : "$artifact_name
-# replace all special characters with _, some builds use special characters like : in Agent.Jobname, that is not a permissible name while uploading artifacts.
-safe_artifact_name="${artifact_name//["/:<>\\|?@*$" ]/_}"
 echo "Artifact name after : "$safe_artifact_name
 export ARTIFACT_NAME=$safe_artifact_name
 echo "##vso[task.setvariable variable=ARTIFACT_NAME]$safe_artifact_name"
diff --git a/eng/common/templates-official/job/job.yml b/eng/common/templates-official/job/job.yml
index 605692d2fb7..817555505aa 100644
--- a/eng/common/templates-official/job/job.yml
+++ b/eng/common/templates-official/job/job.yml
@@ -16,6 +16,7 @@ jobs:
         parameters:
           PackageVersion: ${{ parameters.packageVersion }}
           BuildDropPath: ${{ parameters.buildDropPath }}
+          ManifestDirPath: $(Build.ArtifactStagingDirectory)/sbom
           publishArtifacts: false
 
     # publish artifacts
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index a46b6deb759..22b49e09d09 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -42,7 +42,7 @@
 [bool]$useInstalledDotNetCli = if (Test-Path variable:useInstalledDotNetCli) { $useInstalledDotNetCli } else { $true }
 
 # Enable repos to use a particular version of the on-line dotnet-install scripts.
-#    default URL: https://dotnet.microsoft.com/download/dotnet/scripts/v1/dotnet-install.ps1
+#    default URL: https://builds.dotnet.microsoft.com/dotnet/scripts/v1/dotnet-install.ps1
 [string]$dotnetInstallScriptVersion = if (Test-Path variable:dotnetInstallScriptVersion) { $dotnetInstallScriptVersion } else { 'v1' }
 
 # True to use global NuGet cache instead of restoring packages to repository-local directory.
@@ -262,7 +262,7 @@ function GetDotNetInstallScript([string] $dotnetRoot) {
   if (!(Test-Path $installScript)) {
     Create-Directory $dotnetRoot
     $ProgressPreference = 'SilentlyContinue' # Don't display the console progress UI - it's a huge perf hit
-    $uri = "https://dotnet.microsoft.com/download/dotnet/scripts/$dotnetInstallScriptVersion/dotnet-install.ps1"
+    $uri = "https://builds.dotnet.microsoft.com/dotnet/scripts/$dotnetInstallScriptVersion/dotnet-install.ps1"
 
     Retry({
       Write-Host "GET $uri"
diff --git a/eng/common/tools.sh b/eng/common/tools.sh
index 1159726a10f..01b09b65796 100755
--- a/eng/common/tools.sh
+++ b/eng/common/tools.sh
@@ -54,7 +54,7 @@ warn_as_error=${warn_as_error:-true}
 use_installed_dotnet_cli=${use_installed_dotnet_cli:-true}
 
 # Enable repos to use a particular version of the on-line dotnet-install scripts.
-#    default URL: https://dotnet.microsoft.com/download/dotnet/scripts/v1/dotnet-install.sh
+#    default URL: https://builds.dotnet.microsoft.com/dotnet/scripts/v1/dotnet-install.sh
 dotnetInstallScriptVersion=${dotnetInstallScriptVersion:-'v1'}
 
 # True to use global NuGet cache instead of restoring packages to repository-local directory.
@@ -295,7 +295,7 @@ function with_retries {
 function GetDotNetInstallScript {
   local root=$1
   local install_script="$root/dotnet-install.sh"
-  local install_script_url="https://dotnet.microsoft.com/download/dotnet/scripts/$dotnetInstallScriptVersion/dotnet-install.sh"
+  local install_script_url="https://builds.dotnet.microsoft.com/dotnet/scripts/$dotnetInstallScriptVersion/dotnet-install.sh"
 
   if [[ ! -a "$install_script" ]]; then
     mkdir -p "$root"
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 9760c0c6bc3..2c9a1ee8d64 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -13,8 +13,8 @@
     <PackageVersion Include="BenchmarkDotNet" Version="0.13.10" />
     <PackageVersion Update="BenchmarkDotNet" Condition="'$(BenchmarkDotNetVersion)' != ''" Version="$(BenchmarkDotNetVersion)" />
 
-    <PackageVersion Include="FluentAssertions" Version="6.12.0" />
-    <PackageVersion Update="FluentAssertions" Condition="'$(FluentAssertionsVersion)' != ''" Version="$(FluentAssertionsVersion)" />
+    <PackageVersion Include="AwesomeAssertions" Version="8.0.2" />
+    <PackageVersion Update="AwesomeAssertions" Condition="'$(AwesomeAssertionsVersion)' != ''" Version="$(AwesomeAssertionsVersion)" />
 
     <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
     <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
@@ -40,28 +40,25 @@
     <PackageVersion Include="FakeItEasy" Version="8.1.0" />
     <PackageVersion Update="FakeItEasy" Condition="'$(FakeItEasyVersion)' != ''" Version="$(FakeItEasyVersion)" />
 
-    <PackageVersion Include="System.CodeDom" Version="8.0.0" />
+    <PackageVersion Include="System.CodeDom" Version="9.0.0" />
     <PackageVersion Update="System.CodeDom" Condition="'$(SystemCodeDomVersion)' != ''" Version="$(SystemCodeDomVersion)" />
 
-    <PackageVersion Include="System.Private.Uri" Version="4.3.2" />
-    <PackageVersion Update="System.Private.Uri" Condition="'$(SystemPrivateUriVersion)' != ''" Version="$(SystemPrivateUriVersion)" />
-
-    <PackageVersion Include="System.Runtime" Version="4.3.1" />
-    <PackageVersion Update="System.Runtime" Condition="'$(SystemRuntimeVersion)' != ''" Version="$(SystemRuntimeVersion)" />
-
-    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="8.0.0" />
+    <PackageVersion Include="System.Security.Cryptography.Pkcs" Version="9.0.0" />
     <PackageVersion Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
 
-    <PackageVersion Include="System.Security.Cryptography.Xml" Version="8.0.0" />
+    <PackageVersion Include="System.Security.Cryptography.Xml" Version="9.0.0" />
     <PackageVersion Update="System.Security.Cryptography.Xml" Condition="'$(SystemSecurityCryptographyXmlVersion)' != ''" Version="$(SystemSecurityCryptographyXmlVersion)" />
 
-    <PackageVersion Include="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
-    <PackageVersion Update="System.Security.Cryptography.X509Certificates" Condition="'$(SystemSecurityCryptographyX509CertificatesVersion)' != ''" Version="$(SystemSecurityCryptographyX509CertificatesVersion)" />
+    <PackageVersion Include="Microsoft.Bcl.Cryptography.Xml" Version="9.0.0" />
+    <PackageVersion Update="Microsoft.Bcl.Cryptography.Xml" Condition="'$(MicrosoftBclCryptographyVersion)' != ''" Version="$(MicrosoftBclCryptographyVersion)" />
+
+    <!-- when this is bumped the submodule in https://github.com/dotnet/source-build-externals needs to be bumped in sync -->
+    <PackageVersion Include="Microsoft.VisualStudio.SolutionPersistence" Version="1.0.52" />
+    <PackageVersion Update="Microsoft.VisualStudio.SolutionPersistence" Condition="'$(MicrosoftVisualStudioSolutionPersistenceVersion)' != ''" Version="$(MicrosoftVisualStudioSolutionPersistenceVersion)" />
 
     <PackageVersion Include="Verify.Xunit" Version="19.14.1" />
     <PackageVersion Update="Verify.XUnit" Condition="'$(VerifyXUnitVersion)' != ''" Version="$(VerifyXUnitVersion)" />
-	
-	<PackageVersion Include="Microsoft.VisualStudio.SolutionPersistence" Version="$(MicrosoftVisualStudioSolutionPersistenceVersion)" />
+
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildSourceOnly)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
diff --git a/global.json b/global.json
index ee7246df20f..e2e3c22ae34 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "9.0.103",
+    "dotnet": "9.0.104",
     "vs": {
       "version": "17.12.0"
     },
     "xcopy-msbuild": "17.12.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25111.5"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25164.2"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
index 6cd24d2c366..aaa2c454210 100644
--- a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
@@ -6,7 +6,6 @@
 using System.IO;
 using System.Linq;
 using System.Text;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
diff --git a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
index f7567f061ac..cc0562f9752 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
@@ -6,7 +6,6 @@
 using System.IO;
 using System.Linq;
 using System.Text;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
index 5be0d1fe5dc..706fb7d2b79 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
@@ -1,9 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.IO;
-using System.Xml;
-
 using Microsoft.Build.Construction;
 using Xunit;
 
diff --git a/src/Build.OM.UnitTests/Construction/ProjectPropertyGroupElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectPropertyGroupElement_Tests.cs
index 10b21f0a8ad..35cad10fae7 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectPropertyGroupElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectPropertyGroupElement_Tests.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.IO;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Xunit;
 
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 271bbd11e8e..95256f674d9 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -9,7 +9,6 @@
 using System.Security.AccessControl;
 using System.Security.Principal;
 #endif
-using System.Reflection;
 using System.Text;
 using System.Threading;
 using System.Xml;
@@ -19,10 +18,7 @@
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using ProjectCollection = Microsoft.Build.Evaluation.ProjectCollection;
-using Shouldly;
 using Xunit;
-using Microsoft.Build.Framework;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
index 2cb88649b35..41f835cf229 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
 
diff --git a/src/Build.OM.UnitTests/Construction/ProjectTaskElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectTaskElement_Tests.cs
index 353d2031a3d..679d410d8de 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectTaskElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectTaskElement_Tests.cs
@@ -2,8 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.IO;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Xunit;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index d6abd900521..836d884c5f1 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -1,11 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
-using System.IO;
 using System.Linq;
-using System.Text;
 using System.Threading;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Exceptions;
@@ -28,46 +25,50 @@ public class SolutionFile_Tests
         /// <summary>
         /// Test that a project with the C++ project guid and an extension of vcproj is seen as invalid.
         /// </summary>
-        [Fact]
-        public void ParseSolution_VC()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolution_VC(bool isOptInSlnParsingWithNewParser)
         {
+            string solutionFileContents =
+            """
+            Microsoft Visual Studio Solution File, Format Version 9.00
+            # Visual Studio 2005
+            Project('{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}') = 'Project name.vcproj', 'Relative path\to\Project name.vcproj', '{0ABED153-9451-483C-8140-9E8D7306B216}'
+            EndProject
+            Global
+                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                    Debug|AnyCPU = Debug|AnyCPU
+                    Release|AnyCPU = Release|AnyCPU
+                EndGlobalSection
+                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
+                EndGlobalSection
+                GlobalSection(SolutionProperties) = preSolution
+                    HideSolutionNode = FALSE
+                EndGlobalSection
+            EndGlobalf
+            """;
+
             Assert.Throws<InvalidProjectFileException>(() =>
             {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}') = 'Project name.vcproj', 'Relative path\to\Project name.vcproj', '{0ABED153-9451-483C-8140-9E8D7306B216}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|AnyCPU = Debug|AnyCPU
-                        Release|AnyCPU = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
+                ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser);
                 Assert.Fail("Should not get here");
             });
         }
+
         /// <summary>
         /// Test that a project with the C++ project guid and an arbitrary extension is seen as valid --
         /// we assume that all C++ projects except .vcproj are MSBuild format.
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseSolution_VC2(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseSolution_VC2(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -92,11 +93,11 @@ public void ParseSolution_VC2(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             string expectedProjectName = convertToSlnx ? "Project name" : "Project name.myvctype";
             Assert.Equal(expectedProjectName, solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal(ConvertToUnixPathIfNeeded("Relative path\\to\\Project name.myvctype", convertToSlnx), solution.ProjectsInOrder[0].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("Relative path\\to\\Project name.myvctype", convertToSlnx || isOptInSlnParsingWithNewParser), solution.ProjectsInOrder[0].RelativePath);
             if (!convertToSlnx)
             {
                 // When converting to SLNX, the project GUID is not preserved.
@@ -105,187 +106,51 @@ public void ParseSolution_VC2(bool convertToSlnx)
         }
 
         /// <summary>
-        /// A slightly more complicated test where there is some different whitespace.
-        /// </summary>
-        [Fact]
-        public void ParseSolutionWithDifferentSpacing()
-        {
-            string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project(' { Project GUID} ')  = ' Project name ',  ' Relative path to project file '    , ' {0ABED153-9451-483C-8140-9E8D7306B216} '
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|AnyCPU = Debug|AnyCPU
-                        Release|AnyCPU = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            Assert.Equal("Project name", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal("Relative path to project file", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
-        }
-
-        /// <summary>
-        /// Solution with an empty project name.  This is somewhat malformed, but we should
-        /// still behave reasonably instead of crashing.
-        /// </summary>
-        [Fact]
-        public void ParseSolution_EmptyProjectName()
-        {
-            string solutionFileContents =
-                           @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{Project GUID}') = '', 'src\.proj', '{0ABED153-9451-483C-8140-9E8D7306B216}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|AnyCPU = Debug|AnyCPU
-                        Release|AnyCPU = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            Assert.StartsWith("EmptyProjectName", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal("src\\.proj", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
-        }
-
-        /// <summary>
-        /// Test some characters that are valid in a file name but that also could be
-        /// considered a delimiter by a parser. Does quoting work for special characters?
-        /// </summary>
-        [Fact]
-        public void ParseSolutionWhereProjectNameHasSpecialCharacters()
-        {
-            string solutionFileContents =
-                           @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{Project GUID}')  = 'MyProject,(=IsGreat)',  'Relative path to project file'    , '{0ABED153-9451-483C-8140-9E8D7306B216}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|AnyCPU = Debug|AnyCPU
-                        Release|AnyCPU = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
-                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            Assert.Equal("MyProject,(=IsGreat)", solution.ProjectsInOrder[0].ProjectName);
-            Assert.Equal("Relative path to project file", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
-        }
-
-        /// <summary>
-        /// Ensure that a bogus version stamp in the .SLN file results in an
-        /// InvalidProjectFileException.
-        /// </summary>
-        [Fact]
-        public void BadVersionStamp()
-        {
-            Assert.Throws<InvalidProjectFileException>(() =>
-            {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version a.b
-                # Visual Studio 2005
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
-            });
-        }
-        /// <summary>
-        /// Expected version numbers less than 7 to cause an invalid project file exception.
-        /// </summary>
-        [Fact]
-        public void VersionTooLow()
-        {
-            Assert.Throws<InvalidProjectFileException>(() =>
-            {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version 6.0
-                # Visual Studio 2005
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
-            });
-        }
-        /// <summary>
-        /// Test to parse a very basic .sln file to validate that description property in a solution file
-        /// is properly handled.
+        /// Solution with an empty project name.  
+        // This is somewhat malformed, but with old parser we should still behave reasonably instead of crashing.
+        // The new parser throws an exception.
         /// </summary>
-        [Fact]
-        public void ParseSolutionFileWithDescriptionInformation()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ParseSolution_EmptyProjectName(bool isOptInSlnParsingWithNewParser)
         {
             string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'AnyProject', 'AnyProject\AnyProject.csproj', '{2CAB0FBD-15D8-458B-8E63-1B5B840E9798}'
-                EndProject
-                Global
-	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                Debug|Any CPU = Debug|Any CPU
-		                Release|Any CPU = Release|Any CPU
-		                Description = Some description of this solution
-	                EndGlobalSection
-	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                {2CAB0FBD-15D8-458B-8E63-1B5B840E9798}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                {2CAB0FBD-15D8-458B-8E63-1B5B840E9798}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                {2CAB0FBD-15D8-458B-8E63-1B5B840E9798}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                {2CAB0FBD-15D8-458B-8E63-1B5B840E9798}.Release|Any CPU.Build.0 = Release|Any CPU
-	                EndGlobalSection
-	                GlobalSection(SolutionProperties) = preSolution
-		                HideSolutionNode = FALSE
-	                EndGlobalSection
-                EndGlobal
-                ";
-            try
+            """
+            Microsoft Visual Studio Solution File, Format Version 9.00
+            # Visual Studio 2005
+            Project('{Project GUID}') = '', 'src\.proj', '{0ABED153-9451-483C-8140-9E8D7306B216}'
+            EndProject
+            Global
+                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                    Debug|AnyCPU = Debug|AnyCPU
+                    Release|AnyCPU = Release|AnyCPU
+                EndGlobalSection
+                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
+                    {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
+                EndGlobalSection
+                GlobalSection(SolutionProperties) = preSolution
+                    HideSolutionNode = FALSE
+                EndGlobalSection
+            EndGlobal
+            """;
+
+            if (isOptInSlnParsingWithNewParser)
             {
-                ParseSolutionHelper(solutionFileContents);
+                Assert.Throws<InvalidProjectFileException>(() =>
+                {
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser);
+                });
             }
-            catch (Exception ex)
+            else
             {
-                Assert.Fail("Failed to parse solution containing description information. Error: " + ex.Message);
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser);
+                Assert.StartsWith("EmptyProjectName", solution.ProjectsInOrder[0].ProjectName);
+                Assert.Equal("src\\.proj", solution.ProjectsInOrder[0].RelativePath);
+                Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
             }
         }
 
@@ -293,9 +158,10 @@ public void ParseSolutionFileWithDescriptionInformation()
         /// Tests the parsing of a very basic .SLN file with three independent projects.
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void BasicSolution(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void BasicSolution(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -332,23 +198,24 @@ public void BasicSolution(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
             // When converting to slnx, the order of the projects is not preserved.
+            bool usesNewParser = convertToSlnx || isOptInSlnParsingWithNewParser;
             ProjectInSolution consoleApplication1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ConsoleApplication1");
-            Assert.Equal(ConvertToUnixPathIfNeeded("ConsoleApplication1\\ConsoleApplication1.vbproj", convertToSlnx), consoleApplication1.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ConsoleApplication1\\ConsoleApplication1.vbproj", usesNewParser), consoleApplication1.RelativePath);
             Assert.Empty(consoleApplication1.Dependencies);
             Assert.Null(consoleApplication1.ParentProjectGuid);
 
             ProjectInSolution vbClassLibrary = solution.ProjectsInOrder.First(p => p.ProjectName == "vbClassLibrary");
-            Assert.Equal(ConvertToUnixPathIfNeeded("vbClassLibrary\\vbClassLibrary.vbproj", convertToSlnx), vbClassLibrary.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("vbClassLibrary\\vbClassLibrary.vbproj", usesNewParser), vbClassLibrary.RelativePath);
             Assert.Empty(vbClassLibrary.Dependencies);
             Assert.Null(vbClassLibrary.ParentProjectGuid);
 
             ProjectInSolution classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", convertToSlnx), classLibrary1.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", usesNewParser), classLibrary1.RelativePath);
             Assert.Empty(classLibrary1.Dependencies);
             Assert.Null(classLibrary1.ParentProjectGuid);
 
@@ -364,89 +231,12 @@ public void BasicSolution(bool convertToSlnx)
         /// Exercises solution folders, and makes sure that samely named projects in different
         /// solution folders will get correctly uniquified.
         /// For the new parser, solution folders are not included to ProjectsInOrder or ProjectsByGuid.
+        /// See the test with the same name in SolutionFile_Tests_OldParser.
         /// </summary>
-        [Fact]
-        public void SolutionFolders()
-        {
-            string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{34E0D07D-CF8F-459D-9449-C4188D8C5564}'
-                EndProject
-                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySlnFolder', 'MySlnFolder', '{E0F97730-25D2-418A-A7BD-02CAFDC6E470}'
-                EndProject
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'MyPhysicalFolder\ClassLibrary1\ClassLibrary1.csproj', '{A5EE8128-B08E-4533-86C5-E46714981680}'
-                EndProject
-                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySubSlnFolder', 'MySubSlnFolder', '{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}'
-                EndProject
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary2', 'ClassLibrary2\ClassLibrary2.csproj', '{6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|Any CPU = Debug|Any CPU
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.Build.0 = Release|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.Build.0 = Release|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.Build.0 = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(NestedProjects) = preSolution
-                        {A5EE8128-B08E-4533-86C5-E46714981680} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
-                        {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4} = {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            Assert.Equal(5, solution.ProjectsInOrder.Count);
-
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", false), solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{34E0D07D-CF8F-459D-9449-C4188D8C5564}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[0].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
-
-            Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[1].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
-
-            Assert.Equal(ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj", false), solution.ProjectsInOrder[2].RelativePath);
-            Assert.Equal("{A5EE8128-B08E-4533-86C5-E46714981680}", solution.ProjectsInOrder[2].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
-            Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[2].ParentProjectGuid);
-
-            Assert.Equal("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", solution.ProjectsInOrder[3].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[3].Dependencies);
-            Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", solution.ProjectsInOrder[3].ParentProjectGuid);
-
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", false), solution.ProjectsInOrder[4].RelativePath);
-            Assert.Equal("{6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}", solution.ProjectsInOrder[4].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[4].Dependencies);
-            Assert.Equal("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", solution.ProjectsInOrder[4].ParentProjectGuid);
-        }
-
-        /// <summary>
-        /// Exercises solution folders, and makes sure that samely named projects in different
-        /// solution folders will get correctly uniquified.
-        /// For the new parser, solution folders are not included to ProjectsInOrder or ProjectsByGuid.
-        /// </summary>
-        [Fact]
-        public void SolutionFoldersSlnx()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionFolders(bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -492,164 +282,40 @@ public void SolutionFoldersSlnx()
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, true);
+            bool isOptInSlnParsingWithNewParser = !convertToSlnx;
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
+            bool usesNewParser = convertToSlnx || isOptInSlnParsingWithNewParser;
             var classLibrary1 = solution.ProjectsInOrder
-                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", true));
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", usesNewParser));
             Assert.NotNull(classLibrary1);
             Assert.Empty(classLibrary1.Dependencies);
             Assert.Null(classLibrary1.ParentProjectGuid);
 
             var myPhysicalFolderClassLibrary1 = solution.ProjectsInOrder
-                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj", true));
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("MyPhysicalFolder\\ClassLibrary1\\ClassLibrary1.csproj", usesNewParser));
             Assert.NotNull(myPhysicalFolderClassLibrary1);
             Assert.Empty(myPhysicalFolderClassLibrary1.Dependencies);
 
             var classLibrary2 = solution.ProjectsInOrder
-                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", true));
+                .FirstOrDefault(p => p.RelativePath == ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", usesNewParser));
             Assert.NotNull(classLibrary2);
             Assert.Empty(classLibrary2.Dependencies);
 
             // When converting to slnx, the guids are not preserved.
-            // try at list assert not null
-            Assert.NotNull(myPhysicalFolderClassLibrary1.ParentProjectGuid);
-            Assert.NotNull(classLibrary2.ParentProjectGuid);
-        }
-
-        /// <summary>
-        /// Exercises shared projects.
-        /// </summary>
-        [Fact]
-        public void SharedProjects()
-        {
-            string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 12.00
-                # Visual Studio 15
-                VisualStudioVersion = 15.0.27610.1
-                MinimumVisualStudioVersion = 10.0.40219.1
-                Project('{D954291E-2A0B-460D-934E-DC6B0785DB48}') = 'SharedProject1', 'SharedProject1\SharedProject1.shproj', '{14686F51-D0C2-4832-BBAA-6FBAEC676995}'
-                EndProject
-                Project('{D954291E-2A0B-460D-934E-DC6B0785DB48}') = 'SharedProject2', 'SharedProject2\SharedProject2.shproj', '{BAE750E8-4656-4947-B06B-3961E1051DF7}'
-                EndProject
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{3A0EC360-A42A-417F-BDEF-619682CF6119}'
-                EndProject
-                Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ClassLibrary2', 'ClassLibrary2\ClassLibrary2.vbproj', '{6DEF6DE8-FBF0-4240-B469-282DEE87899C}'
-                EndProject
-                Global
-                    GlobalSection(SharedMSBuildProjectFiles) = preSolution
-                        SharedProject1\SharedProject1.projitems*{14686f51-d0c2-4832-bbaa-6fbaec676995}*SharedItemsImports = 13
-                        SharedProject1\SharedProject1.projitems*{3a0ec360-a42a-417f-bdef-619682cf6119}*SharedItemsImports = 4
-                        SharedProject2\SharedProject2.projitems*{6def6de8-fbf0-4240-b469-282dee87899c}*SharedItemsImports = 4
-                        SharedProject2\SharedProject2.projitems*{bae750e8-4656-4947-b06b-3961e1051df7}*SharedItemsImports = 13
-                    EndGlobalSection
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|Any CPU = Debug|Any CPU
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {3A0EC360-A42A-417F-BDEF-619682CF6119}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {3A0EC360-A42A-417F-BDEF-619682CF6119}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {3A0EC360-A42A-417F-BDEF-619682CF6119}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {3A0EC360-A42A-417F-BDEF-619682CF6119}.Release|Any CPU.Build.0 = Release|Any CPU
-                        {6DEF6DE8-FBF0-4240-B469-282DEE87899C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {6DEF6DE8-FBF0-4240-B469-282DEE87899C}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {6DEF6DE8-FBF0-4240-B469-282DEE87899C}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {6DEF6DE8-FBF0-4240-B469-282DEE87899C}.Release|Any CPU.Build.0 = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(ExtensibilityGlobals) = postSolution
-                        SolutionGuid = {1B671EF6-A62A-4497-8351-3EE8679CA86F}
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            Assert.Equal(4, solution.ProjectsInOrder.Count);
-
-            Assert.Equal(@"SharedProject1\SharedProject1.shproj", solution.ProjectsInOrder[0].RelativePath);
-            Assert.Equal("{14686F51-D0C2-4832-BBAA-6FBAEC676995}", solution.ProjectsInOrder[0].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[0].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
-
-            Assert.Equal(@"SharedProject2\SharedProject2.shproj", solution.ProjectsInOrder[1].RelativePath);
-            Assert.Equal("{BAE750E8-4656-4947-B06B-3961E1051DF7}", solution.ProjectsInOrder[1].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[1].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
-
-            Assert.Equal(@"ClassLibrary1\ClassLibrary1.csproj", solution.ProjectsInOrder[2].RelativePath);
-            Assert.Equal("{3A0EC360-A42A-417F-BDEF-619682CF6119}", solution.ProjectsInOrder[2].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
-
-            Assert.Equal(@"ClassLibrary2\ClassLibrary2.vbproj", solution.ProjectsInOrder[3].RelativePath);
-            Assert.Equal("{6DEF6DE8-FBF0-4240-B469-282DEE87899C}", solution.ProjectsInOrder[3].ProjectGuid);
-            Assert.Empty(solution.ProjectsInOrder[3].Dependencies);
-            Assert.Null(solution.ProjectsInOrder[3].ParentProjectGuid);
-        }
-
-        /// <summary>
-        /// Tests situation where there's a nonexistent project listed in the solution folders.  We should
-        /// error with a useful message.
-        /// </summary>
-        [Fact]
-        public void MissingNestedProject()
-        {
-            string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'MySlnFolder', 'MySlnFolder', '{E0F97730-25D2-418A-A7BD-02CAFDC6E470}'
-                EndProject
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'MyPhysicalFolder\ClassLibrary1\ClassLibrary1.csproj', '{A5EE8128-B08E-4533-86C5-E46714981680}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|Any CPU = Debug|Any CPU
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {34E0D07D-CF8F-459D-9449-C4188D8C5564}.Release|Any CPU.Build.0 = Release|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {A5EE8128-B08E-4533-86C5-E46714981680}.Release|Any CPU.Build.0 = Release|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Debug|Any CPU.Build.0 = Debug|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.ActiveCfg = Release|Any CPU
-                        {6DB98C35-FDCC-4818-B5D4-1F0A385FDFD4}.Release|Any CPU.Build.0 = Release|Any CPU
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(NestedProjects) = preSolution
-                        {A5EE8128-B08E-4533-86C5-E46714981680} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
-                        {2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B} = {E0F97730-25D2-418A-A7BD-02CAFDC6E470}
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            try
+            if (!convertToSlnx)
             {
-                ParseSolutionHelper(solutionFileContents);
+                Assert.Equal("{E0F97730-25D2-418A-A7BD-02CAFDC6E470}", myPhysicalFolderClassLibrary1.ParentProjectGuid);
+                Assert.Equal("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", classLibrary2.ParentProjectGuid);
             }
-            catch (InvalidProjectFileException e)
+            else
             {
-                Assert.Equal("MSB5023", e.ErrorCode);
-                Assert.Contains("{2AE8D6C4-FB43-430C-8AEB-15E5EEDAAE4B}", e.Message);
-                return;
+                // try at least assert not null
+                Assert.NotNull(myPhysicalFolderClassLibrary1.ParentProjectGuid);
+                Assert.NotNull(classLibrary2.ParentProjectGuid);
             }
-
-            // Should not get here
-            Assert.Fail();
         }
 
         /// <summary>
@@ -657,9 +323,10 @@ public void MissingNestedProject()
         /// are correctly recognized by the solution parser.
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void SolutionDependencies(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void SolutionDependencies(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -703,7 +370,7 @@ public void SolutionDependencies(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(3, solution.ProjectsInOrder.Count);
 
@@ -711,19 +378,20 @@ public void SolutionDependencies(bool convertToSlnx)
             var classLibrary2 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary2");
             var classLibrary3 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary3");
 
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", convertToSlnx), classLibrary1.RelativePath);
+            bool usesNewParser = convertToSlnx || isOptInSlnParsingWithNewParser;
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary1\\ClassLibrary1.csproj", usesNewParser), classLibrary1.RelativePath);
             Assert.Single(classLibrary1.Dependencies);
             Assert.Equal(classLibrary3.ProjectGuid, classLibrary1.Dependencies[0]);
             Assert.Null(solution.ProjectsInOrder[0].ParentProjectGuid);
 
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", convertToSlnx), classLibrary2.RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary2\\ClassLibrary2.csproj", usesNewParser), classLibrary2.RelativePath);
             Assert.Equal(2, classLibrary2.Dependencies.Count);
             // When converting to SLNX, the projects dependencies order is not preserved.
             Assert.Contains(classLibrary3.ProjectGuid, classLibrary2.Dependencies);
             Assert.Contains(classLibrary1.ProjectGuid, classLibrary2.Dependencies);
             Assert.Null(solution.ProjectsInOrder[1].ParentProjectGuid);
 
-            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary3\\ClassLibrary3.csproj", convertToSlnx), solution.ProjectsInOrder[2].RelativePath);
+            Assert.Equal(ConvertToUnixPathIfNeeded("ClassLibrary3\\ClassLibrary3.csproj", usesNewParser), solution.ProjectsInOrder[2].RelativePath);
             Assert.Empty(solution.ProjectsInOrder[2].Dependencies);
             Assert.Null(solution.ProjectsInOrder[2].ParentProjectGuid);
         }
@@ -732,9 +400,10 @@ public void SolutionDependencies(bool convertToSlnx)
         /// Make sure the solution configurations get parsed correctly for a simple mixed C#/VC solution
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseSolutionConfigurations(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseSolutionConfigurations(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -784,7 +453,7 @@ public void ParseSolutionConfigurations(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(7, solution.SolutionConfigurations.Count);
 
@@ -809,9 +478,10 @@ public void ParseSolutionConfigurations(bool convertToSlnx)
         /// Make sure the solution configurations get parsed correctly for a simple C# application
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseSolutionConfigurationsNoMixedPlatform(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseSolutionConfigurationsNoMixedPlatform(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -846,7 +516,7 @@ public void ParseSolutionConfigurationsNoMixedPlatform(bool convertToSlnx)
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             Assert.Equal(6, solution.SolutionConfigurations.Count);
 
@@ -867,93 +537,15 @@ public void ParseSolutionConfigurationsNoMixedPlatform(bool convertToSlnx)
             Assert.Equal("Any CPU", solution.GetDefaultPlatformName()); // "Default solution platform"
         }
 
-        /// <summary>
-        /// Test some invalid cases for solution configuration parsing.
-        /// There can be only one '=' character in a sln cfg entry, separating two identical names
-        /// </summary>
-        [Fact]
-        public void ParseInvalidSolutionConfigurations1()
-        {
-            Assert.Throws<InvalidProjectFileException>(() =>
-            {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|Any=CPU = Debug|Any=CPU
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
-            });
-        }
-        /// <summary>
-        /// Test some invalid cases for solution configuration parsing
-        /// There can be only one '=' character in a sln cfg entry, separating two identical names
-        /// </summary>
-        [Fact]
-        public void ParseInvalidSolutionConfigurations2()
-        {
-            Assert.Throws<InvalidProjectFileException>(() =>
-            {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|Any CPU = Something|Else
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
-            });
-        }
-        /// <summary>
-        /// Test some invalid cases for solution configuration parsing
-        /// Solution configurations must include the platform part
-        /// </summary>
-        [Fact]
-        public void ParseInvalidSolutionConfigurations3()
-        {
-            Assert.Throws<InvalidProjectFileException>(() =>
-            {
-                string solutionFileContents =
-                    @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug = Debug
-                        Release|Any CPU = Release|Any CPU
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-                ParseSolutionHelper(solutionFileContents);
-            });
-        }
-
         /// <summary>
         /// Make sure the project configurations in solution configurations get parsed correctly
         /// for a simple mixed C#/VC solution
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void ParseProjectConfigurationsInSolutionConfigurations1(bool convertToSlnx)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseProjectConfigurationsInSolutionConfigurations1(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -1000,7 +592,7 @@ public void ParseProjectConfigurationsInSolutionConfigurations1(bool convertToSl
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, convertToSlnx);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             ProjectInSolution csharpProject = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
             ProjectInSolution vcProject = solution.ProjectsInOrder.First(p => p.ProjectName == "MainApp");
@@ -1046,69 +638,11 @@ public void ParseProjectConfigurationsInSolutionConfigurations1(bool convertToSl
             Assert.True(vcProject.ProjectConfigurations["Release|Win32"].IncludeInBuild);
         }
 
-        /// <summary>
-        /// Make sure the project configurations in solution configurations get parsed correctly
-        /// for a more tricky solution
-        /// </summary>
-        [Fact]
-        public void ParseProjectConfigurationsInSolutionConfigurations2()
-        {
-            string solutionFileContents =
-                @"
-                Microsoft Visual Studio Solution File, Format Version 9.00
-                # Visual Studio 2005
-                Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'C:\solutions\WebSite1\', '..\WebSite1\', '{E8E75132-67E4-4D6F-9CAE-8DA4C883F418}'
-                EndProject
-                Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'C:\solutions\WebSite2\', '..\WebSite2\', '{E8E75132-67E4-4D6F-9CAE-8DA4C883F419}'
-                EndProject
-                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'NewFolder1', 'NewFolder1', '{54D20FFE-84BE-4066-A51E-B25D040A4235}'
-                EndProject
-                Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'NewFolder2', 'NewFolder2', '{D2633E4D-46FF-4C4E-8340-4BC7CDF78615}'
-                EndProject
-                Project('{8BC9CEB9-8B4A-11D0-8D11-00A0C91BC942}') = 'MSBuild.exe', '..\..\dd\binaries.x86dbg\bin\i386\MSBuild.exe', '{25FD9E7C-F37E-48E0-9A7C-607FE4AACCC0}'
-                EndProject
-                Global
-                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-                        Debug|.NET = Debug|.NET
-                    EndGlobalSection
-                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-                        {E8E75132-67E4-4D6F-9CAE-8DA4C883F418}.Debug|.NET.ActiveCfg = Debug|.NET
-                        {E8E75132-67E4-4D6F-9CAE-8DA4C883F418}.Debug|.NET.Build.0 = Debug|.NET
-                        {25FD9E7C-F37E-48E0-9A7C-607FE4AACCC0}.Debug|.NET.ActiveCfg = Debug
-                    EndGlobalSection
-                    GlobalSection(SolutionProperties) = preSolution
-                        HideSolutionNode = FALSE
-                    EndGlobalSection
-                    GlobalSection(NestedProjects) = preSolution
-                        {25FD9E7C-F37E-48E0-9A7C-607FE4AACCC0} = {D2633E4D-46FF-4C4E-8340-4BC7CDF78615}
-                    EndGlobalSection
-                EndGlobal
-                ";
-
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
-
-            ProjectInSolution webProject = (ProjectInSolution)solution.ProjectsByGuid["{E8E75132-67E4-4D6F-9CAE-8DA4C883F418}"];
-            ProjectInSolution exeProject = (ProjectInSolution)solution.ProjectsByGuid["{25FD9E7C-F37E-48E0-9A7C-607FE4AACCC0}"];
-            ProjectInSolution missingWebProject = (ProjectInSolution)solution.ProjectsByGuid["{E8E75132-67E4-4D6F-9CAE-8DA4C883F419}"];
-
-            Assert.Single(webProject.ProjectConfigurations);
-
-            Assert.Equal("Debug|.NET", webProject.ProjectConfigurations["Debug|.NET"].FullName);
-            Assert.True(webProject.ProjectConfigurations["Debug|.NET"].IncludeInBuild);
-
-            Assert.Single(exeProject.ProjectConfigurations);
-
-            Assert.Equal("Debug", exeProject.ProjectConfigurations["Debug|.NET"].FullName);
-            Assert.False(exeProject.ProjectConfigurations["Debug|.NET"].IncludeInBuild);
-
-            Assert.Empty(missingWebProject.ProjectConfigurations);
-
-            Assert.Equal("Debug", solution.GetDefaultConfigurationName()); // "Default solution configuration"
-            Assert.Equal(".NET", solution.GetDefaultPlatformName()); // "Default solution platform"
-        }
-
-        [Fact]
-        public void ParseProjectConfigurationsInSolutionConfigurationsSlnx()
+        [Theory]
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        public void ParseProjectConfigurationsInSolutionConfigurations2(bool isOptInSlnParsingWithNewParser, bool convertToSlnx)
         {
             string solutionFileContents =
                 """
@@ -1116,9 +650,9 @@ public void ParseProjectConfigurationsInSolutionConfigurationsSlnx()
                 # Visual Studio Version 17
                 VisualStudioVersion = 17.11.35111.106
                 MinimumVisualStudioVersion = 10.0.40219.1
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""WinFormsApp1"", ""WinFormsApp1\WinFormsApp1.csproj"", ""{3B592A6A-6215-4675-9237-7FEB36BDB4F1}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "WinFormsApp1", "WinFormsApp1\WinFormsApp1.csproj", "{3B592A6A-6215-4675-9237-7FEB36BDB4F1}"
                 EndProject
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1\ClassLibrary1.csproj"", ""{C25056E0-405C-4476-9B22-839264A8530C}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1\ClassLibrary1.csproj", "{C25056E0-405C-4476-9B22-839264A8530C}"
                 EndProject
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -1144,7 +678,7 @@ public void ParseProjectConfigurationsInSolutionConfigurationsSlnx()
                 EndGlobal
                 """;
 
-            SolutionFile solution = ParseSolutionHelper(solutionFileContents, true);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, convertToSlnx);
 
             ProjectInSolution winFormsApp1 = solution.ProjectsInOrder.First(p => p.ProjectName == "WinFormsApp1");
             ProjectInSolution classLibrary1 = solution.ProjectsInOrder.First(p => p.ProjectName == "ClassLibrary1");
@@ -1166,73 +700,21 @@ public void ParseProjectConfigurationsInSolutionConfigurationsSlnx()
             Assert.False(classLibrary1.ProjectConfigurations["Release|Any CPU"].IncludeInBuild);
         }
 
-        /// <summary>
-        /// Parse solution file with comments
-        /// </summary>
-        [Fact]
-        public void ParseSolutionWithComments()
-        {
-            const string solutionFileContent = @"
-                    Microsoft Visual Studio Solution File, Format Version 12.00
-                    # Visual Studio Version 16
-                    VisualStudioVersion = 16.0.29123.89
-                    MinimumVisualStudioVersion = 10.0.40219.1
-                    Project('{9A19103F-16F7-4668-BE54-9A1E7A4F7556}') = 'SlnCommentTest', 'SlnCommentTest.csproj', '{00000000-0000-0000-FFFF-FFFFFFFFFFFF}'
-                    EndProject
-                    Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'Solution Items', 'Solution Items', '{054DED3B-B890-4652-B449-839F581E5D86}'
-	                    ProjectSection(SolutionItems) = preProject
-		                    SlnFile.txt = SlnFile.txt
-	                    EndProjectSection
-                    EndProject
-                    Global
-	                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                    Debug|Any CPU = Debug|Any CPU
-		                    Release|Any CPU = Release|Any CPU
-	                    EndGlobalSection
-	                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.Build.0 = Release|Any CPU
-	                    EndGlobalSection
-	                    GlobalSection(SolutionProperties) = preSolution
-		                    HideSolutionNode = FALSE
-	                    EndGlobalSection
-	                    GlobalSection(ExtensibilityGlobals) = postSolution
-		                    SolutionGuid = {FFFFFFFF-FFFF-FFFF-0000-000000000000}
-	                    EndGlobalSection
-                    EndGlobal
-                    ";
-
-            StringBuilder stringBuilder = new StringBuilder();
-
-            // Put comment between all lines
-            const string comment = "\t# comment";
-            string[] lines = solutionFileContent.Split(new string[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
-            for (int i = 0; i < lines.Length; i++)
-            {
-                stringBuilder.AppendLine(comment);
-                stringBuilder.AppendLine(lines[i]);
-            }
-            stringBuilder.AppendLine(comment);
-
-            Should.NotThrow(() => ParseSolutionHelper(stringBuilder.ToString()));
-        }
-
         /// <summary>
         /// Helper method to create a SolutionFile object, and call it to parse the SLN file
         /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.
         /// </summary>
-        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool isOptInSlnParsingWithNewParser, bool convertToSlnx = false)
         {
             solutionFileContents = solutionFileContents.Replace('\'', '"');
-
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
+                if (isOptInSlnParsingWithNewParser)
+                {
+                    testEnvironment.SetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE", "1");
+                }
                 TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
-
                 string solutionPath = convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path;
-
                 return SolutionFile.Parse(solutionPath);
             }
         }
@@ -1246,11 +728,10 @@ private static string ConvertToSlnx(string slnPath)
             return slnxPath;
         }
 
-        private static string ConvertToUnixPathIfNeeded(string path, bool isConvertedToSlnx)
+        private static string ConvertToUnixPathIfNeeded(string path, bool usesNewParser)
         {
             // In the new parser, ProjectModel.FilePath is converted to Unix-style.
-            // we are using the new parser only for slnx files.
-            return !NativeMethodsShared.IsWindows && isConvertedToSlnx ? path.Replace('\\', '/') : path;
+            return usesNewParser && !NativeMethodsShared.IsWindows ? path.Replace('\\', '/') : path;
         }
     }
 }
diff --git a/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs b/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
index 3e85948675a..6708096bd7e 100644
--- a/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/DefinitionEditing_Tests.cs
@@ -5,12 +5,10 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using System.Xml;
 
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Shared;
 using Xunit;
 
 #nullable disable
diff --git a/src/Build.OM.UnitTests/Definition/EditingElementsReferencedByOrReferences_Tests.cs b/src/Build.OM.UnitTests/Definition/EditingElementsReferencedByOrReferences_Tests.cs
index 018dc9dca91..3c7e530d9d3 100644
--- a/src/Build.OM.UnitTests/Definition/EditingElementsReferencedByOrReferences_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/EditingElementsReferencedByOrReferences_Tests.cs
@@ -3,9 +3,7 @@
 
 using System;
 using System.Collections.Generic;
-using System.IO;
 using System.Linq;
-using System.Xml;
 using Microsoft.Build.Evaluation;
 using Xunit;
 
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
index 9d795ecaa6f..dcce4d61853 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItemDefinition_Tests.cs
@@ -10,7 +10,6 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Xunit;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 490cc3cce47..75b2e82319d 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
 using Microsoft.Build.Engine.UnitTests.Globbing;
@@ -16,7 +15,6 @@
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 
 #nullable disable
diff --git a/src/Build.OM.UnitTests/Definition/ProjectMetadata_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectMetadata_Tests.cs
index c0807e37e68..f7bae907db1 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectMetadata_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectMetadata_Tests.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Shared;
diff --git a/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
index 3ecc456a3cb..c028fd294cd 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
@@ -4,11 +4,9 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Xml;
 
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Shared;
 using Xunit;
 
 #nullable disable
diff --git a/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs b/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
index b22c8bf0ab9..6a337e3bbc9 100644
--- a/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using System.Xml;
 
 using Microsoft.Build.Evaluation;
 using Xunit;
diff --git a/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
index b8845cd6244..c7278144dae 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectInstance_Tests.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index e8259bd3120..0e060a450d7 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -3,19 +3,13 @@
 
 using System;
 using System.Collections.Generic;
-using System.IO;
 using System.Linq;
-using System.Xml;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.Shared;
-using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 
 #nullable disable
diff --git a/src/Build.OM.UnitTests/Instance/ProjectOnErrorInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectOnErrorInstance_Tests.cs
index 14346060f12..457e4bb27fb 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectOnErrorInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectOnErrorInstance_Tests.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.IO;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
diff --git a/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
index 3e9ab10b3df..fb41c9da8a1 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
@@ -3,7 +3,6 @@
 
 using System.Collections.Generic;
 using System.IO;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
diff --git a/src/Build.OM.UnitTests/Instance/ProjectTaskInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectTaskInstance_Tests.cs
index 2acc85a6995..c2e0a60ae10 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectTaskInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectTaskInstance_Tests.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.IO;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
diff --git a/src/Build.OM.UnitTests/Instance/ProjectTaskOutputItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectTaskOutputItemInstance_Tests.cs
index 716c675982d..31d85a9e608 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectTaskOutputItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectTaskOutputItemInstance_Tests.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.IO;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
diff --git a/src/Build.OM.UnitTests/Instance/ProjectTaskOutputPropertyInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectTaskOutputPropertyInstance_Tests.cs
index 8c9e4770842..fb17c3b113b 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectTaskOutputPropertyInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectTaskOutputPropertyInstance_Tests.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.IO;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index df1c15ea5e6..c5433f3112c 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -20,10 +20,11 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
 
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+
     <PackageDownload Include="NuGet.CommandLine" Version="[$(NuGetCommandLinePackageVersion)]" />
   </ItemGroup>
 
@@ -64,6 +65,7 @@
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
     <ProjectReference Include="..\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj" />
+    <PackageReference Include="Microsoft.VisualStudio.SolutionPersistence" PrivateAssets="all"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
index ee35a83c93a..d5b4b8bbf38 100644
--- a/src/Build.OM.UnitTests/NugetRestoreTests.cs
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -1,13 +1,12 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.IO;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
-using System.IO;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 namespace Microsoft.Build.Engine.OM.UnitTests
 {
diff --git a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
index 05112a6ed62..d21ca7a50d6 100644
--- a/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
+++ b/src/Build.OM.UnitTests/ObjectModelRemoting/RemoteProjectsProviderMock/ExporterMock.cs
@@ -7,9 +7,7 @@ namespace Microsoft.Build.UnitTests.OM.ObjectModelRemoting
 {
     using System;
     using System.Collections.Generic;
-    using System.IO;
     using System.Threading;
-    using System.Xml;
     using Microsoft.Build.Construction;
     using Microsoft.Build.Evaluation;
     using Microsoft.Build.ObjectModelRemoting;
diff --git a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
index 55834d7d650..9a0bb05138a 100644
--- a/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BinaryTranslator_Tests.cs
@@ -8,7 +8,6 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
-using System.Runtime.CompilerServices;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
diff --git a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
index 2a2e8822ba1..d36e9d716a3 100644
--- a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
@@ -5,9 +5,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
index 99f6603f61c..d588c980ab4 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Logging_Tests.cs
@@ -15,7 +15,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 using static Microsoft.Build.UnitTests.ObjectModelHelpers;
 
 #nullable disable
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 2111a5ee369..35bf1f4cc3a 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -10,7 +10,6 @@
 using System.Linq;
 using System.Reflection;
 using System.Threading;
-using System.Xml;
 
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
index b4efa7ea860..b7ea019500a 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestEngine_Tests.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Threading;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestEntry_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestEntry_Tests.cs
index b994f4ceb2c..9e84a022a90 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestEntry_Tests.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Unittest;
 using Xunit;
 
diff --git a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
index 2090f4c4807..5e103b5ef66 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequest_Tests.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Framework;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
index dec50951300..1b94ac3357f 100644
--- a/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildResult_Tests.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Unittest;
 using Xunit;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
diff --git a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
index bbe0f749387..db1dcd72cb4 100644
--- a/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CacheAggregator_Tests.cs
@@ -6,8 +6,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Unittest;
 using Shouldly;
 using Xunit;
@@ -33,10 +31,10 @@ public void NoCachesProducesEmptyCaches()
             var aggregation = aggregator.Aggregate();
 
             aggregation.ConfigCache.ShouldNotBeNull();
-            aggregation.ConfigCache.GetEnumerator().ToEnumerable().ShouldBeEmpty();
+            aggregation.ConfigCache.ShouldBeEmpty();
 
             aggregation.ResultsCache.ShouldNotBeNull();
-            aggregation.ResultsCache.GetEnumerator().ToEnumerable().ShouldBeEmpty();
+            aggregation.ResultsCache.ShouldBeEmpty();
 
             aggregation.LastConfigurationId.ShouldBe(0);
         }
@@ -246,9 +244,9 @@ private void AssertAggregation((ConfigCache configCache, ResultsCache resultsCac
             var currentConfigurationIndex = 0;
             var currentBuildResultIndex = 0;
 
-            var aggregatedConfigs = aggregation.ConfigCache.GetEnumerator().ToArray();
+            var aggregatedConfigs = aggregation.ConfigCache.ToArray();
 
-            var aggregatedResults = aggregation.ResultsCache.GetEnumerator().ToArray();
+            var aggregatedResults = aggregation.ResultsCache.ToArray();
 
             foreach (var (configCache, resultsCache) in inputCaches)
             {
diff --git a/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs b/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
index da450fb9228..64f34e78d8f 100644
--- a/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/CentralForwardingLogger_Tests.cs
@@ -3,7 +3,6 @@
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Xunit;
 
 #nullable disable
diff --git a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
index 3ca18bc9832..bf40853c4e8 100644
--- a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
@@ -101,8 +101,8 @@ public void ConfigCacheShouldBeTranslatable(object obj)
             TranslationHelpers.GetReadTranslator().Translate(ref copy);
 
             // test _configurations
-            var initialConfigurations = initial.GetEnumerator().ToArray();
-            var copiedConfigurations = copy.GetEnumerator().ToArray();
+            var initialConfigurations = initial.ToArray();
+            var copiedConfigurations = copy.ToArray();
 
             Assert.Equal(copiedConfigurations, initialConfigurations, EqualityComparer<BuildRequestConfiguration>.Default);
 
diff --git a/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs b/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs
index 7900e9564cb..859e5507f68 100644
--- a/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ConfigurationMetadata_Tests.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.IO;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
diff --git a/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs b/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs
index 6f5fd31c934..2a48fe4d81a 100644
--- a/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs
+++ b/src/Build.UnitTests/BackEnd/DebugUtils_tests.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
-using Xunit.Abstractions;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs b/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
index d36c7ee0667..1971cca0763 100644
--- a/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/EventRedirectorToSink_Tests.cs
@@ -3,7 +3,6 @@
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Xunit;
 
 #nullable disable
diff --git a/src/Build.UnitTests/BackEnd/EventSourceTestHelper.cs b/src/Build.UnitTests/BackEnd/EventSourceTestHelper.cs
index 8d3929afaba..e2ed8378c07 100644
--- a/src/Build.UnitTests/BackEnd/EventSourceTestHelper.cs
+++ b/src/Build.UnitTests/BackEnd/EventSourceTestHelper.cs
@@ -1,12 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics.Tracing;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Engine.UnitTests.BackEnd
 {
diff --git a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
index 7f0ccecd569..3d65794eb1f 100644
--- a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
diff --git a/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
index d6e66cc6ecd..56ec028ddf1 100644
--- a/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
@@ -2,8 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 #nullable disable
-using System;
-using System.Globalization;
 using System.Linq;
 using Microsoft.Build.Framework.Telemetry;
 using Shouldly;
diff --git a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
index 7ccbcc227b7..020d527ab3f 100644
--- a/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingContext_Tests.cs
@@ -3,7 +3,6 @@
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index eea8d075466..4d42f596bcb 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -14,7 +14,6 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
 using Shouldly;
 using Xunit;
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index fb932fb70d5..3fe5fcd8e6e 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -7,7 +7,6 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Construction;
diff --git a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
index 9ee0264517d..90c0c170a0d 100644
--- a/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Lookup_Tests.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Xunit;
 
 #nullable disable
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index 1f08b92bf79..3326ddfd49e 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -5,10 +5,10 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Engine.UnitTests.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.TelemetryInfra;
 using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 
diff --git a/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
index bb0c19a4415..bd3b9855abf 100644
--- a/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeConfiguration_Tests.cs
@@ -2,10 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Logging;
diff --git a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
index 5a1eb10715b..5d0ae210a56 100644
--- a/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodeEndpointInProc_Tests.cs
@@ -8,9 +8,8 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 using Xunit;
+using LegacyThreadingData = Microsoft.Build.Execution.LegacyThreadingData;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 48a375147d6..8ca50416de7 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -332,12 +332,12 @@ public void TestTranslation()
                     LogMessagePacket deserializedPacket = tempPacket as LogMessagePacket;
 
                     packet.Should().BeEquivalentTo(deserializedPacket, options => options
-                        .RespectingRuntimeTypes());
+                        .PreferringRuntimeMemberTypes());
 
                     BuildEventArgs args = packet.NodeBuildEvent?.Value;
                     BuildEventArgs desArgs = deserializedPacket?.NodeBuildEvent?.Value;
                     desArgs.Should().BeEquivalentTo(args, options => options
-                        .RespectingRuntimeTypes()
+                        .PreferringRuntimeMemberTypes()
                         // Since we use struct DictionaryEntry of class TaskItemData, generated DictionaryEntry.Equals compare TaskItemData by references.
                         // Bellow will instruct equivalency test to not use DictionaryEntry.Equals but its public members for equivalency tests.
                         .ComparingByMembers<DictionaryEntry>()
diff --git a/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs b/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
index 81caa63af47..b8adb10c2a2 100644
--- a/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.IO;
 using System.Text;
 using System.Threading.Tasks;
 using Microsoft.Build.Experimental;
diff --git a/src/Build.UnitTests/BackEnd/RequestedProjectState_Tests.cs b/src/Build.UnitTests/BackEnd/RequestedProjectState_Tests.cs
index 034b3d1594a..166fd5750bc 100644
--- a/src/Build.UnitTests/BackEnd/RequestedProjectState_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/RequestedProjectState_Tests.cs
@@ -4,9 +4,7 @@
 using System.Collections.Generic;
 using FluentAssertions;
 using Microsoft.Build.Execution;
-using Shouldly;
 using Xunit;
-using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
diff --git a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
index 7fc43eccc59..77f6dc04be6 100644
--- a/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ResultsCache_Tests.cs
@@ -8,11 +8,8 @@
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Unittest;
 using Shouldly;
 using Xunit;
@@ -80,7 +77,7 @@ public void CacheCanBeEnumerated()
             result2.AddResultsForTarget("result2target1", BuildResultUtilities.GetEmptyFailingTargetResult());
             cache.AddResult(result2);
 
-            var results = cache.GetEnumerator().ToArray();
+            var results = cache.ToArray();
 
             results.Length.ShouldBe(2);
 
diff --git a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
index 7b0cd8745c6..e470f6be153 100644
--- a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index 4a891408cc9..10a1c5dcd6c 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Configuration;
-using System.Diagnostics.Tracing;
 using System.Linq;
 using System.Text.RegularExpressions;
 using System.Threading;
diff --git a/src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs
index 6af6e6616b5..a1f051339fa 100644
--- a/src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResultItemComparison_Tests.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Shouldly;
diff --git a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
index 11d5207ec9b..b39a91f56cb 100644
--- a/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetBuilder_Tests.cs
@@ -7,7 +7,6 @@
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index b2cb7cd17bd..259b3f530dc 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -7,7 +7,6 @@
 using System.IO;
 using System.Threading;
 using System.Threading.Tasks;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 743e165ca0a..d54a77ac90a 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -7,7 +7,6 @@
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
 using System.Threading;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
index 64ffc8fba5c..c66854b0206 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
@@ -2,9 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Linq;
 using System.Reflection;
 using Microsoft.Build.Framework;
 
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 68a8dea7eb0..f0155787682 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -7,7 +7,6 @@
 using System.Reflection;
 using System.Threading;
 using System.Threading.Tasks;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index 61b1551576c..b1a2a334e8d 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -8,7 +8,6 @@
 using System.Linq;
 using System.Reflection;
 using System.Threading;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
diff --git a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
index dcf1f45727d..959142d4a67 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
@@ -6,13 +6,11 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using System.Text;
 using System.Threading;
 
 
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index ebb24ca82e6..401b0f9ea49 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -6,7 +6,6 @@
 using System.Globalization;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.BackEnd;
 
diff --git a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
index b6b6025441b..c475da6dcac 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostTaskComplete_Tests.cs
@@ -4,8 +4,8 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Xunit;
diff --git a/src/Build.UnitTests/BackEnd/TaskThatThrows.cs b/src/Build.UnitTests/BackEnd/TaskThatThrows.cs
index b837e225740..f62541256cc 100644
--- a/src/Build.UnitTests/BackEnd/TaskThatThrows.cs
+++ b/src/Build.UnitTests/BackEnd/TaskThatThrows.cs
@@ -2,11 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
 using System.Reflection;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Engine.UnitTests;
 
diff --git a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
index 7d4736837ce..bdcad9d36bb 100644
--- a/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
+++ b/src/Build.UnitTests/BackEnd/TranslationHelpers.cs
@@ -9,7 +9,6 @@
 using System.Text;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
-using Xunit;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 3ff827e24aa..9334bcf5314 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -6,7 +6,6 @@
 using System.IO;
 using System.IO.Compression;
 using System.Linq;
-using System.Reflection;
 using System.Text;
 using FakeItEasy;
 using FluentAssertions;
diff --git a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
index d987efa0fab..f500c937ab9 100644
--- a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
+++ b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/BuildEventArgsDataEnumeration.cs b/src/Build.UnitTests/BuildEventArgsDataEnumeration.cs
index 0f760d002c5..83042fcf5f5 100644
--- a/src/Build.UnitTests/BuildEventArgsDataEnumeration.cs
+++ b/src/Build.UnitTests/BuildEventArgsDataEnumeration.cs
@@ -1,7 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
diff --git a/src/Build.UnitTests/ChangeWaves_Tests.cs b/src/Build.UnitTests/ChangeWaves_Tests.cs
index 9bfa098ee0d..d81e765c3ab 100644
--- a/src/Build.UnitTests/ChangeWaves_Tests.cs
+++ b/src/Build.UnitTests/ChangeWaves_Tests.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
-using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
diff --git a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
index be97777e5e3..dfc4482a09f 100644
--- a/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
+++ b/src/Build.UnitTests/Collections/MSBuildNameIgnoreCaseComparer_Tests.cs
@@ -5,7 +5,6 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Xunit;
 
 #nullable disable
diff --git a/src/Build.UnitTests/Collections/OMcollections_tests.cs b/src/Build.UnitTests/Collections/OMcollections_tests.cs
index 354a6bc9464..56273244f51 100644
--- a/src/Build.UnitTests/Collections/OMcollections_tests.cs
+++ b/src/Build.UnitTests/Collections/OMcollections_tests.cs
@@ -10,7 +10,6 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
 using Shouldly;
 using Xunit;
diff --git a/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
index 7f56b600dca..a15fffd391d 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_NewParser_Tests.cs
@@ -1,13 +1,10 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.IO;
 using System.Threading;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Shared;
 using Microsoft.VisualStudio.SolutionPersistence;
 using Microsoft.VisualStudio.SolutionPersistence.Model;
@@ -129,23 +126,22 @@ public void ProjectWithWebsiteProperties(bool convertToSlnx)
         /// Helper method to create a SolutionFile object, and call it to parse the SLN file
         /// represented by the string contents passed in. Optionally can convert the SLN to SLNX and then parse the solution.
         /// </summary>
-        internal static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool convertToSlnx = false)
         {
             solutionFileContents = solutionFileContents.Replace('\'', '"');
-
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
+                solutionFileContents = solutionFileContents.Replace('\'', '"');
+                testEnvironment.SetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE", "1");
                 TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
-
                 string solutionPath = convertToSlnx ? ConvertToSlnx(sln.Path) : sln.Path;
-
                 SolutionFile solutionFile = new SolutionFile { FullPath = solutionPath };
                 solutionFile.ParseUsingNewParser();
                 return solutionFile;
             }
         }
 
-        private static string ConvertToSlnx(string slnPath)
+        internal static string ConvertToSlnx(string slnPath)
         {
             string slnxPath = slnPath + "x";
             ISolutionSerializer serializer = SolutionSerializers.GetSerializerByMoniker(slnPath).ShouldNotBeNull();
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_OldParser_Tests.cs
similarity index 95%
rename from src/Build.UnitTests/Construction/SolutionFile_Tests.cs
rename to src/Build.UnitTests/Construction/SolutionFile_OldParser_Tests.cs
index 79bb93a4703..ab51906b222 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_OldParser_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
+using System.Text;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Shared;
@@ -16,11 +17,11 @@
 
 namespace Microsoft.Build.UnitTests.Construction
 {
-    public class SolutionFile_Tests
+    public class SolutionFile_OldParser_Tests
     {
         public ITestOutputHelper TestOutputHelper { get; }
 
-        public SolutionFile_Tests(ITestOutputHelper testOutputHelper)
+        public SolutionFile_OldParser_Tests(ITestOutputHelper testOutputHelper)
         {
             TestOutputHelper = testOutputHelper;
         }
@@ -104,6 +105,42 @@ public void ParseFirstProjectLineWithDifferentSpacing()
             proj.ProjectGuid.ShouldBe("Unique name-GUID");
         }
 
+        /// <summary>
+        /// A slightly more complicated test where there is some different whitespace.
+        /// </summary>
+        [Fact]
+        public void ParseSolutionWithDifferentSpacing()
+        {
+            string solutionFileContents =
+                @"
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project(' { Project GUID} ')  = ' Project name ',  ' Relative path to project file '    , ' {0ABED153-9451-483C-8140-9E8D7306B216} '
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|AnyCPU = Debug|AnyCPU
+                        Release|AnyCPU = Release|AnyCPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                ";
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+
+            Assert.Equal("Project name", solution.ProjectsInOrder[0].ProjectName);
+            Assert.Equal("Relative path to project file", solution.ProjectsInOrder[0].RelativePath);
+            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
+        }
+
         /// <summary>
         /// First project line with an empty project name.  This is somewhat malformed, but we should
         /// still behave reasonably instead of crashing.
@@ -687,6 +724,43 @@ public void ParseFirstProjectLineWhereProjectNameHasSpecialCharacters()
             proj.ProjectGuid.ShouldBe("Unique name-GUID");
         }
 
+        /// <summary>
+        /// Test some characters that are valid in a file name but that also could be
+        /// considered a delimiter by a parser. Does quoting work for special characters?
+        /// </summary>
+        [Fact]
+        public void ParseSolutionWhereProjectNameHasSpecialCharacters()
+        {
+            string solutionFileContents =
+                           @"
+                Microsoft Visual Studio Solution File, Format Version 9.00
+                # Visual Studio 2005
+                Project('{Project GUID}')  = 'MyProject,(=IsGreat)',  'Relative path to project file'    , '{0ABED153-9451-483C-8140-9E8D7306B216}'
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|AnyCPU = Debug|AnyCPU
+                        Release|AnyCPU = Release|AnyCPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.ActiveCfg = Debug|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Debug|AnyCPU.Build.0 = Debug|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.ActiveCfg = Release|AnyCPU
+                        {0ABED153-9451-483C-8140-9E8D7306B216}.Release|AnyCPU.Build.0 = Release|AnyCPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                ";
+
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents);
+
+            Assert.Equal("MyProject,(=IsGreat)", solution.ProjectsInOrder[0].ProjectName);
+            Assert.Equal("Relative path to project file", solution.ProjectsInOrder[0].RelativePath);
+            Assert.Equal("{0ABED153-9451-483C-8140-9E8D7306B216}", solution.ProjectsInOrder[0].ProjectGuid);
+        }
+
         /// <summary>
         /// Test some characters that are valid in a file name but that also could be
         /// considered a delimiter by a parser. Does quoting work for special characters?
@@ -2355,5 +2429,58 @@ public void ParseSolutionWithParentedPaths()
             solution.ProjectsInOrder[0].AbsolutePath.ShouldBe(Path.GetFullPath(Path.Combine(Path.GetDirectoryName(solution.FullPath)!, expectedRelativePath)));
             solution.ProjectsInOrder[0].ProjectGuid.ShouldBe("{0ABED153-9451-483C-8140-9E8D7306B216}");
         }
+
+        /// <summary>
+        /// Parse solution file with comments
+        /// </summary>
+        [Fact]
+        public void ParseSolutionWithComments()
+        {
+            const string solutionFileContent = @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.0.29123.89
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project('{9A19103F-16F7-4668-BE54-9A1E7A4F7556}') = 'SlnCommentTest', 'SlnCommentTest.csproj', '{00000000-0000-0000-FFFF-FFFFFFFFFFFF}'
+                    EndProject
+                    Project('{2150E333-8FDC-42A3-9474-1A3956D46DE8}') = 'Solution Items', 'Solution Items', '{054DED3B-B890-4652-B449-839F581E5D86}'
+	                    ProjectSection(SolutionItems) = preProject
+		                    SlnFile.txt = SlnFile.txt
+	                    EndProjectSection
+                    EndProject
+                    Global
+	                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		                    Debug|Any CPU = Debug|Any CPU
+		                    Release|Any CPU = Release|Any CPU
+	                    EndGlobalSection
+	                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		                    {00000000-0000-0000-FFFF-FFFFFFFFFFFF}.Release|Any CPU.Build.0 = Release|Any CPU
+	                    EndGlobalSection
+	                    GlobalSection(SolutionProperties) = preSolution
+		                    HideSolutionNode = FALSE
+	                    EndGlobalSection
+	                    GlobalSection(ExtensibilityGlobals) = postSolution
+		                    SolutionGuid = {FFFFFFFF-FFFF-FFFF-0000-000000000000}
+	                    EndGlobalSection
+                    EndGlobal
+                    ";
+
+            StringBuilder stringBuilder = new StringBuilder();
+
+            // Put comment between all lines
+            const string comment = "\t# comment";
+            string[] lines = solutionFileContent.Split(new string[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
+            for (int i = 0; i < lines.Length; i++)
+            {
+                stringBuilder.AppendLine(comment);
+                stringBuilder.AppendLine(lines[i]);
+            }
+            stringBuilder.AppendLine(comment);
+
+            Should.NotThrow(() => ParseSolutionHelper(stringBuilder.ToString()));
+        }
     }
 }
diff --git a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
index 98f25d366cc..facbeff5386 100644
--- a/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFilter_Tests.cs
@@ -15,9 +15,9 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
 using Microsoft.Build.UnitTests;
+using Microsoft.VisualStudio.SolutionPersistence;
 using Microsoft.VisualStudio.SolutionPersistence.Model;
 using Microsoft.VisualStudio.SolutionPersistence.Serializer;
-using Microsoft.VisualStudio.SolutionPersistence;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -72,14 +72,14 @@ public void SolutionFilterFiltersProjects(bool graphBuild)
                     ");
                 // Slashes here (and in the .slnf) are hardcoded as backslashes intentionally to support the common case.
                 TransientTestFile solutionFile = testEnvironment.CreateFile(simpleProjectFolder, "SimpleProject.sln",
-                    @"
+                    """
                     Microsoft Visual Studio Solution File, Format Version 12.00
                     # Visual Studio Version 16
                     VisualStudioVersion = 16.0.29326.124
                     MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", ""SimpleProject\SimpleProject.csproj"", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
+                    Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "SimpleProject", "SimpleProject\SimpleProject.csproj", "{79B5EBA6-5D27-4976-BC31-14422245A59A}"
                     EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", ""..\ClassLibrary\ClassLibrary\ClassLibrary.csproj"", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
+                    Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ClassLibrary", "..\ClassLibrary\ClassLibrary\ClassLibrary.csproj", "{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}"
                     EndProject
                     Global
                         GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -107,7 +107,7 @@ public void SolutionFilterFiltersProjects(bool graphBuild)
                             SolutionGuid = {DE7234EC-0C4D-4070-B66A-DCF1B4F0CFEF}
                         EndGlobalSection
                     EndGlobal
-                ");
+                    """);
                 TransientTestFile filterFile = testEnvironment.CreateFile(folder, "solutionFilter.slnf",
                     /*lang=json*/
                                   """
@@ -284,6 +284,56 @@ public void ParseSolutionFilter(bool convertToSlnx)
             }
         }
 
+        [Fact]
+        public void SolutionFilterWithSpecialSymbolInThePath()
+        {
+            using TestEnvironment testEnvironment = TestEnvironment.Create();
+            TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+            // Create folder with special symbols in the name
+            folder = testEnvironment.CreateFolder(Path.Combine(folder.Path, $"test@folder%special$symbols"), createFolder: true);
+            // Create simple solution and simple solution filter
+            TransientTestFile sln = testEnvironment.CreateFile(folder, "SimpleSolution.sln",
+            """
+            Microsoft Visual Studio Solution File, Format Version 12.00
+            # Visual Studio Version 17
+            VisualStudioVersion = 17.0.31903.59
+            MinimumVisualStudioVersion = 10.0.40219.1
+            Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "SolutionTest", "SolutionTest.csproj", "{767AA460-C33F-41C3-A8B6-4DA283263A51}"
+            EndProject
+            Global
+                GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                    Debug|Any CPU = Debug|Any CPU
+                    Release|Any CPU = Release|Any CPU
+                EndGlobalSection
+                GlobalSection(SolutionProperties) = preSolution
+                    HideSolutionNode = FALSE
+                EndGlobalSection
+                GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                    {767AA460-C33F-41C3-A8B6-4DA283263A51}.Release|Any CPU.Build.0 = Release|Any CPU
+                EndGlobalSection
+            EndGlobal
+            """);
+            TransientTestFile slnf = testEnvironment.CreateFile(folder, "SimpleSolution.slnf",
+            """
+            {
+                "solution": {
+                    "path": "SimpleSolution.sln",
+                    "projects": [
+                        "SolutionTest.csproj"
+                    ]
+                }
+            }
+            """);
+
+            SolutionFile sp = SolutionFile.Parse(slnf.Path);
+
+            // just assert that no error is thrown
+            Assert.True(sp.ProjectShouldBuild("SolutionTest.csproj"));
+        }
+
         private static string ConvertToSlnx(string slnPath)
         {
             string slnxPath = slnPath + "x";
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 8e28604557b..11179b170c6 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -38,6 +38,8 @@ public class SolutionProjectGenerator_Tests : IDisposable
 
         private static readonly BuildEventContext _buildEventContext = new BuildEventContext(0, 0, BuildEventContext.InvalidProjectContextId, 0);
 
+        private const string _longLineString = "a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-";
+
         public SolutionProjectGenerator_Tests(ITestOutputHelper output)
         {
             this.output = output;
@@ -65,12 +67,14 @@ public void SolutionProjectIgnoresDuplicateDefaultTargets(string name)
             using (TestEnvironment testEnvironment = TestEnvironment.Create())
             {
                 TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
-                TransientTestFile sln = testEnvironment.CreateFile(folder, "MySln.sln", @"Microsoft Visual Studio Solution File, Format Version 16.00");
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "MySln.sln", "Microsoft Visual Studio Solution File, Format Version 12.00");
                 TransientTestFile targetsFile = testEnvironment.CreateFile(folder, name,
-                    @"<Project>
-                        <Target Name=""Build"" AfterTargets=""NonsenseTarget"">
+                      """
+                      <Project>
+                        <Target Name="Build" AfterTargets="NonsenseTarget">
                         </Target>
-                      </Project>");
+                      </Project>
+                      """);
                 ProjectInstance[] instances = SolutionProjectGenerator.Generate(SolutionFile.Parse(sln.Path), null, null, _buildEventContext, CreateMockLoggingService());
                 instances.ShouldHaveSingleItem();
                 instances[0].Targets["Build"].AfterTargets.ShouldBe(string.Empty);
@@ -79,6 +83,36 @@ public void SolutionProjectIgnoresDuplicateDefaultTargets(string name)
             }
         }
 
+        /// <summary>
+        /// Test that targets in before.{sln}.targets and after.{sln}.targets files are included in the project.
+        /// </summary>
+        [Theory]
+        [InlineData("before.MySln.sln.targets", false)]
+        [InlineData("before.MySln.sln.targets", true)]
+        [InlineData("after.MySln.sln.targets", false)]
+        [InlineData("after.MySln.sln.targets", true)]
+        public void SolutionProjectIncludesBeforeAndAfterTargets(string name, bool convertToSlnx)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                string solutionFileContents = "Microsoft Visual Studio Solution File, Format Version 12.00";
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "MySln.sln", solutionFileContents);
+                string solutionPath = convertToSlnx ? SolutionFile_NewParser_Tests.ConvertToSlnx(sln.Path) : sln.Path;
+                testEnvironment.CreateFile(folder, name,
+                      """
+                      <Project>
+                          <Target Name="TestTarget" />
+                      </Project>
+                      """);
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(SolutionFile.Parse(solutionPath), null, null, _buildEventContext, CreateMockLoggingService());
+                instances.ShouldHaveSingleItem();
+                instances[0].Targets.ShouldContainKey("TestTarget");
+                MockLogger logger = new MockLogger(output);
+                instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
+            }
+        }
+
         [Fact]
         public void BuildProjectAsTarget()
         {
@@ -87,33 +121,35 @@ public void BuildProjectAsTarget()
                 TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
                 TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "classlib"), createFolder: true);
                 TransientTestFile classLibrary = testEnvironment.CreateFile(classLibFolder, "classlib.csproj",
-                    @"<Project>
-                  <Target Name=""ClassLibraryTarget"">
-                      <Message Text=""ClassLibraryBuilt""/>
+                  """
+                  <Project>
+                  <Target Name="ClassLibraryTarget">
+                      <Message Text="ClassLibraryBuilt"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "simpleProject"), createFolder: true);
                 TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectFolder, "simpleProject.csproj",
-                    @"<Project>
-                  <Target Name=""SimpleProjectTarget"">
-                      <Message Text=""SimpleProjectBuilt""/>
+                  """
+                  <Project>
+                  <Target Name="SimpleProjectTarget">
+                      <Message Text="SimpleProjectBuilt"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "testFolder.sln",
-                    @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio Version 16
-VisualStudioVersion = 16.6.30114.105
-MinimumVisualStudioVersion = 10.0.40219.1
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""simpleProject"", ""simpleProject\simpleProject.csproj"", ""{AA52A05F-A9C0-4C89-9933-BF976A304C91}""
-EndProject
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""classlib"", ""classlib\classlib.csproj"", ""{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}""
-EndProject
-                ");
+                    """
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.6.30114.105
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "simpleProject", "simpleProject\simpleProject.csproj", "{AA52A05F-A9C0-4C89-9933-BF976A304C91}"
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "classlib", "classlib\classlib.csproj", "{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}"
+                    EndProject
+                    """);
                 RunnerUtilities.ExecMSBuild(solutionFile.Path + " /t:classlib", out bool success);
                 success.ShouldBeTrue();
             }
@@ -130,56 +166,58 @@ public void BuildProjectWithMultipleTargets()
                 TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
                 TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "classlib"), createFolder: true);
                 TransientTestFile classLibrary = testEnvironment.CreateFile(classLibFolder, "classlib.csproj",
-                    @"<Project>
-                  <Target Name=""Build"">
-                      <Message Text=""classlib.Build""/>
+                  """
+                  <Project>
+                  <Target Name="Build">
+                      <Message Text="classlib.Build"/>
                   </Target>
-                  <Target Name=""Clean"">
-                      <Message Text=""classlib.Clean""/>
+                  <Target Name="Clean">
+                      <Message Text="classlib.Clean"/>
                   </Target>
-                  <Target Name=""Custom"">
-                      <Message Text=""classlib.Custom""/>
+                  <Target Name="Custom">
+                      <Message Text="classlib.Custom"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "simpleProject"), createFolder: true);
                 TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectFolder, "simpleProject.csproj",
-                    @"<Project>
-                  <Target Name=""Build"">
-                      <Message Text=""simpleProject.Build""/>
+                  """
+                  <Project>
+                  <Target Name="Build">
+                      <Message Text="simpleProject.Build"/>
                   </Target>
-                  <Target Name=""Clean"">
-                      <Message Text=""simpleProject.Clean""/>
+                  <Target Name="Clean">
+                      <Message Text="simpleProject.Clean"/>
                   </Target>
-                  <Target Name=""Custom"">
-                      <Message Text=""simpleProject.Custom""/>
+                  <Target Name="Custom">
+                      <Message Text="simpleProject.Custom"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "testFolder.sln",
-                    @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio Version 16
-VisualStudioVersion = 16.6.30114.105
-MinimumVisualStudioVersion = 10.0.40219.1
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""simpleProject"", ""simpleProject\simpleProject.csproj"", ""{AA52A05F-A9C0-4C89-9933-BF976A304C91}""
-EndProject
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""classlib"", ""classlib\classlib.csproj"", ""{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}""
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|x86 = Debug|x86
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.ActiveCfg = Debug|x86
-		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.Build.0 = Debug|x86
-		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.ActiveCfg = Debug|x86
-		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.Build.0 = Debug|x86
-	EndGlobalSection
-EndGlobal
-                ");
+                    """
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.6.30114.105
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "simpleProject", "simpleProject\simpleProject.csproj", "{AA52A05F-A9C0-4C89-9933-BF976A304C91}"
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "classlib", "classlib\classlib.csproj", "{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|x86 = Debug|x86
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.ActiveCfg = Debug|x86
+                            {AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.Build.0 = Debug|x86
+                            {80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.ActiveCfg = Debug|x86
+                            {80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.Build.0 = Debug|x86
+                        EndGlobalSection
+                        EndGlobal
+                    """);
 
                 string output = RunnerUtilities.ExecMSBuild(solutionFile.Path + " /t:Clean;Build;Custom", out bool success);
                 success.ShouldBeTrue();
@@ -192,7 +230,6 @@ public void BuildProjectWithMultipleTargets()
             }
         }
 
-
         /// <summary>
         /// Build Solution with Multiple Targets (ex. Clean;Build;Custom).
         /// </summary>
@@ -204,56 +241,58 @@ public void BuildProjectWithMultipleTargetsInParallel()
                 TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
                 TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "classlib"), createFolder: true);
                 TransientTestFile classLibrary = testEnvironment.CreateFile(classLibFolder, "classlib.csproj",
-                    @"<Project>
-                  <Target Name=""Build"">
-                      <Message Text=""classlib.Build""/>
+                  """
+                  <Project>
+                  <Target Name="Build">
+                      <Message Text="classlib.Build"/>
                   </Target>
-                  <Target Name=""Clean"">
-                      <Message Text=""classlib.Clean""/>
+                  <Target Name="Clean">
+                      <Message Text="classlib.Clean"/>
                   </Target>
-                  <Target Name=""Custom"">
-                      <Message Text=""classlib.Custom""/>
+                  <Target Name="Custom">
+                      <Message Text="classlib.Custom"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "simpleProject"), createFolder: true);
                 TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectFolder, "simpleProject.csproj",
-                    @"<Project>
-                  <Target Name=""Build"">
-                      <Message Text=""simpleProject.Build""/>
+                  """
+                  <Project>
+                  <Target Name="Build">
+                      <Message Text="simpleProject.Build"/>
                   </Target>
-                  <Target Name=""Clean"">
-                      <Message Text=""simpleProject.Clean""/>
+                  <Target Name="Clean">
+                      <Message Text="simpleProject.Clean"/>
                   </Target>
-                  <Target Name=""Custom"">
-                      <Message Text=""simpleProject.Custom""/>
+                  <Target Name="Custom">
+                      <Message Text="simpleProject.Custom"/>
                   </Target>
                   </Project>
-                    ");
+                  """);
 
                 TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "testFolder.sln",
-                    @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio Version 16
-VisualStudioVersion = 16.6.30114.105
-MinimumVisualStudioVersion = 10.0.40219.1
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""simpleProject"", ""simpleProject\simpleProject.csproj"", ""{AA52A05F-A9C0-4C89-9933-BF976A304C91}""
-EndProject
-Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""classlib"", ""classlib\classlib.csproj"", ""{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}""
-EndProject
-Global
-	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|x86 = Debug|x86
-	EndGlobalSection
-	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.ActiveCfg = Debug|x86
-		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.Build.0 = Debug|x86
-		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.ActiveCfg = Debug|x86
-		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.Build.0 = Debug|x86
-	EndGlobalSection
-EndGlobal
-                ");
+                    """
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.6.30114.105
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "simpleProject", "simpleProject\simpleProject.csproj", "{AA52A05F-A9C0-4C89-9933-BF976A304C91}"
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "classlib", "classlib\classlib.csproj", "{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}"
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|x86 = Debug|x86
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.ActiveCfg = Debug|x86
+                            {AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.Build.0 = Debug|x86
+                            {80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.ActiveCfg = Debug|x86
+                            {80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.Build.0 = Debug|x86
+                        EndGlobalSection
+                    EndGlobal
+                    """);
 
                 try
                 {
@@ -331,10 +370,12 @@ public void AddNewErrorWarningMessageElement()
         /// Test to make sure we properly set the ToolsVersion attribute on the in-memory project based
         /// on the Solution File Format Version.
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void EmitToolsVersionAttributeToInMemoryProject9()
+        public void EmitToolsVersionAttributeToInMemoryProject9(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV35 == null)
             {
@@ -343,7 +384,7 @@ public void EmitToolsVersionAttributeToInMemoryProject9()
             }
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -353,23 +394,29 @@ public void EmitToolsVersionAttributeToInMemoryProject9()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal("3.5", instances[0].ToolsVersion);
+                Assert.Equal("3.5", instances[0].ToolsVersion);
+            }
         }
 
         /// <summary>
         /// Test to make sure we properly set the ToolsVersion attribute on the in-memory project based
         /// on the Solution File Format Version.
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void EmitToolsVersionAttributeToInMemoryProject10()
+        public void EmitToolsVersionAttributeToInMemoryProject10(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV35 == null)
             {
@@ -378,7 +425,7 @@ public void EmitToolsVersionAttributeToInMemoryProject10()
             }
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 10.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -388,13 +435,17 @@ public void EmitToolsVersionAttributeToInMemoryProject10()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, "3.5", _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal("3.5", instances[0].ToolsVersion);
+                Assert.Equal("3.5", instances[0].ToolsVersion);
+            }
         }
 
         /// <summary>
@@ -407,7 +458,7 @@ public void DefaultSubToolsetIfSolutionVersionSubToolsetDoesntExist()
             Environment.SetEnvironmentVariable("VisualStudioVersion", null);
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 10.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -417,9 +468,9 @@ public void DefaultSubToolsetIfSolutionVersionSubToolsetDoesntExist()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = SolutionFile_OldParser_Tests.ParseSolutionHelper(solutionFileContents);
 
             ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
 
@@ -443,13 +494,15 @@ public void DefaultSubToolsetIfSolutionVersionSubToolsetDoesntExist()
         /// Test to make sure that if the solution version corresponds to an existing sub-toolset version,
         /// barring other factors that might override, the sub-toolset will be based on the solution version.
         /// </summary>
-        [Fact]
-        public void SubToolsetSetBySolutionVersion()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SubToolsetSetBySolutionVersion(bool useNewParser)
         {
             Environment.SetEnvironmentVariable("VisualStudioVersion", null);
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 12.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -459,32 +512,38 @@ public void SubToolsetSetBySolutionVersion()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
+                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
 
-            // being cautious -- we can't expect the sub-toolset to be picked if it doesn't exist in the first place
-            if (instances[0].Toolset.SubToolsets.ContainsKey("11.0"))
-            {
-                Assert.Equal("11.0", instances[0].SubToolsetVersion);
-                Assert.Equal("11.0", instances[0].GetPropertyValue("VisualStudioVersion"));
+                // being cautious -- we can't expect the sub-toolset to be picked if it doesn't exist in the first place
+                if (instances[0].Toolset.SubToolsets.ContainsKey("11.0"))
+                {
+                    Assert.Equal("11.0", instances[0].SubToolsetVersion);
+                    Assert.Equal("11.0", instances[0].GetPropertyValue("VisualStudioVersion"));
+                }
             }
         }
 
         /// <summary>
         /// Test to make sure that even if the solution version corresponds to an existing sub-toolset version,
         /// </summary>
-        [Fact]
-        public void SolutionBasedSubToolsetVersionOverriddenByEnvironment()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionBasedSubToolsetVersionOverriddenByEnvironment(bool useNewParser)
         {
             Environment.SetEnvironmentVariable("VisualStudioVersion", "ABC");
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 12.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -494,15 +553,19 @@ public void SolutionBasedSubToolsetVersionOverriddenByEnvironment()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, CreateMockLoggingService());
 
-            Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
-            Assert.Equal("ABC", instances[0].SubToolsetVersion);
-            Assert.Equal("ABC", instances[0].GetPropertyValue("VisualStudioVersion"));
+                Assert.Equal(ObjectModelHelpers.MSBuildDefaultToolsVersion, instances[0].ToolsVersion);
+                Assert.Equal("ABC", instances[0].SubToolsetVersion);
+                Assert.Equal("ABC", instances[0].GetPropertyValue("VisualStudioVersion"));
+            }
         }
 
         /// <summary>
@@ -719,44 +782,45 @@ public void SolutionDoesntPassSubToolsetToChildProjects()
         /// Verify that we throw the appropriate error if the solution declares a dependency
         /// on a project that doesn't exist.
         /// </summary>
+        /// <remarks>This test would only work for the old parser. In the new parser the dependency is not added if it was not in the solution file.</remarks>
         [Fact]
         public void SolutionWithMissingDependencies()
         {
             Assert.Throws<InvalidProjectFileException>(() =>
             {
                 string solutionFileContents =
-                    @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 11
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `B`, `Project2\B.csproj`, `{881C1674-4ECA-451D-85B6-D7C59B7F16FA}`
-    ProjectSection(ProjectDependencies) = postProject
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
-    EndProjectSection
-EndProject
-Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Any CPU = Debug|Any CPU
-        Debug|x64 = Debug|x64
-        Release|Any CPU = Release|Any CPU
-        Release|x64 = Release|x64
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = preSolution
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.ActiveCfg = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.Build.0 = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.Build.0 = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.ActiveCfg = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.Build.0 = Release|Any CPU
-    EndGlobalSection
-    GlobalSection(SolutionProperties) = preSolution
-        HideSolutionNode = FALSE
-    EndGlobalSection
-EndGlobal
-".Replace("`", "\"");
+                    """
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio 11
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "B", "Project2\B.csproj", "{881C1674-4ECA-451D-85B6-D7C59B7F16FA}"
+                        ProjectSection(ProjectDependencies) = postProject
+                            {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
+                        EndProjectSection
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|Any CPU = Debug|Any CPU
+                            Debug|x64 = Debug|x64
+                            Release|Any CPU = Release|Any CPU
+                            Release|x64 = Release|x64
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = preSolution
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.ActiveCfg = Debug|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.Build.0 = Debug|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.Build.0 = Release|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.ActiveCfg = Release|Any CPU
+                            {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.Build.0 = Release|Any CPU
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                    EndGlobal
+                    """;
 
-                SolutionFile sp = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+                SolutionFile sp = SolutionFile_OldParser_Tests.ParseSolutionHelper(solutionFileContents);
                 ProjectInstance[] instances = SolutionProjectGenerator.Generate(sp, null, null, _buildEventContext, CreateMockLoggingService());
             });
         }
@@ -764,62 +828,64 @@ public void SolutionWithMissingDependencies()
         /// Blob should contain dependency info
         /// Here B depends on C
         /// </summary>
-        [Fact]
-        public void SolutionConfigurationWithDependencies()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionConfigurationWithDependencies(bool useNewParser)
         {
             string solutionFileContents =
-                @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 11
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `A`, `Project1\A.csproj`, `{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}`
-EndProject
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `B`, `Project2\B.csproj`, `{881C1674-4ECA-451D-85B6-D7C59B7F16FA}`
-    ProjectSection(ProjectDependencies) = postProject
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
-    EndProjectSection
-EndProject
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `C`, `Project3\C.csproj`, `{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}`
-EndProject
-Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Any CPU = Debug|Any CPU
-        Debug|x64 = Debug|x64
-        Release|Any CPU = Release|Any CPU
-        Release|x64 = Release|x64
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = preSolution
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|x64.ActiveCfg = Debug|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|x64.Build.0 = Debug|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|Any CPU.Build.0 = Release|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|x64.ActiveCfg = Release|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|x64.Build.0 = Release|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|x64.ActiveCfg = Debug|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|x64.Build.0 = Debug|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|Any CPU.Build.0 = Release|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|x64.ActiveCfg = Release|Any CPU
-        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|x64.Build.0 = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.ActiveCfg = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.Build.0 = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.Build.0 = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.ActiveCfg = Release|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.Build.0 = Release|Any CPU
-    EndGlobalSection
-    GlobalSection(SolutionProperties) = preSolution
-        HideSolutionNode = FALSE
-    EndGlobalSection
-EndGlobal
-".Replace("`", "\"");
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 11
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "A", "Project1\A.csproj", "{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}"
+                EndProject
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "B", "Project2\B.csproj", "{881C1674-4ECA-451D-85B6-D7C59B7F16FA}"
+                    ProjectSection(ProjectDependencies) = postProject
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
+                    EndProjectSection
+                EndProject
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "C", "Project3\C.csproj", "{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Debug|x64 = Debug|x64
+                        Release|Any CPU = Release|Any CPU
+                        Release|x64 = Release|x64
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = preSolution
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|x64.ActiveCfg = Debug|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|x64.Build.0 = Debug|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|x64.ActiveCfg = Release|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Release|x64.Build.0 = Release|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|x64.ActiveCfg = Debug|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Debug|x64.Build.0 = Debug|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|x64.ActiveCfg = Release|Any CPU
+                        {786E302A-96CE-43DC-B640-D6B6CC9BF6C0}.Release|x64.Build.0 = Release|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.ActiveCfg = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|x64.Build.0 = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.ActiveCfg = Release|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Release|x64.Build.0 = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
 
             ProjectRootElement projectXml = ProjectRootElement.Create();
 
@@ -838,11 +904,14 @@ public void SolutionConfigurationWithDependencies()
             string solutionConfigurationContents = msbuildProject.GetPropertyValue("CurrentSolutionConfigurationContents");
 
             // Only the specified solution configuration is represented in THE BLOB: nothing for x64 in this case
-            string expected = $@"<SolutionConfiguration>
-  <ProjectConfiguration Project=`{{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}}` AbsolutePath=`##temp##{Path.Combine("Project1", "A.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU</ProjectConfiguration>
-  <ProjectConfiguration Project=`{{881C1674-4ECA-451D-85B6-D7C59B7F16FA}}` AbsolutePath=`##temp##{Path.Combine("Project2", "B.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU<ProjectDependency Project=`{{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}}` /></ProjectConfiguration>
-  <ProjectConfiguration Project=`{{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}}` AbsolutePath=`##temp##{Path.Combine("Project3", "C.csproj")}` BuildProjectInSolution=`True`>Debug|AnyCPU</ProjectConfiguration>
-</SolutionConfiguration>".Replace("`", "\"").Replace("##temp##", FileUtilities.TempFileDirectory);
+            string expected =
+                $$"""
+                <SolutionConfiguration>
+                  <ProjectConfiguration Project="{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}" AbsolutePath="##temp##{{Path.Combine("Project1", "A.csproj")}}" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
+                  <ProjectConfiguration Project="{881C1674-4ECA-451D-85B6-D7C59B7F16FA}" AbsolutePath="##temp##{{Path.Combine("Project2", "B.csproj")}}" BuildProjectInSolution="True">Debug|AnyCPU<ProjectDependency Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" /></ProjectConfiguration>
+                  <ProjectConfiguration Project="{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}" AbsolutePath="##temp##{{Path.Combine("Project3", "C.csproj")}}" BuildProjectInSolution="True">Debug|AnyCPU</ProjectConfiguration>
+                </SolutionConfiguration>
+                """.Replace("##temp##", FileUtilities.TempFileDirectory);
 
             Helpers.VerifyAssertLineByLine(expected, solutionConfigurationContents);
         }
@@ -860,19 +929,19 @@ public void SolutionGeneratingMetaproj()
                 TransientTestFile proj2 = env.CreateFile("B.csproj", @"<Project><Target Name=""Printer""><Message Importance=""high"" Text=""print string"" /></Target></Project>");
                 TransientTestFile proj3 = env.CreateFile("C.csproj", @"<Project><Target Name=""Printer""><Message Importance=""high"" Text=""print string"" /></Target></Project>");
                 TransientTestFile proj = env.CreateFile("mysln.sln",
-                @$"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 11
-Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `A`, `{proj1.Path}`, `{"{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}"}`
-EndProject
-Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `B`, `{proj2.Path}`, `{"{881C1674-4ECA-451D-85B6-D7C59B7F16FA}"}`
-    ProjectSection(ProjectDependencies) = postProject
-        {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"} = {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"}
-    EndProjectSection
-EndProject
-Project(`{"{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"}`) = `C`, `{proj3.Path}`, `{"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"}`
-EndProject
-".Replace("`", "\""));
+                    $$"""
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio 11
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "A", "{{proj1.Path}}", "{786E302A-96CE-43DC-B640-D6B6CC9BF6C0}"
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "B", "{{proj2.Path}}", "{881C1674-4ECA-451D-85B6-D7C59B7F16FA}"
+                        ProjectSection(ProjectDependencies) = postProject
+                            {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"} = {"{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"}
+                        EndProjectSection
+                    EndProject
+                    Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "C", "{{proj3.Path}}", "{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}"
+                    EndProject
+                    """);
                 RunnerUtilities.ExecMSBuild("\"" + proj.Path + "\"", out bool successfulExit);
                 successfulExit.ShouldBeTrue();
             }
@@ -890,37 +959,37 @@ public void SolutionConfigurationWithDependenciesRelaysItsOutputs()
         {
             #region Large strings representing solution & projects
             const string solutionFileContents =
-                @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio 11
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `B`, `B.csproj`, `{881C1674-4ECA-451D-85B6-D7C59B7F16FA}`
-    ProjectSection(ProjectDependencies) = postProject
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
-    EndProjectSection
-EndProject
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `C`, `C.csproj`, `{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}`
-EndProject
-Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `D`, `D.csproj`, `{B6E7E06F-FC0B-48F1-911A-55E0E1566F00}`
-EndProject
-Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Any CPU = Debug|Any CPU
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = preSolution
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {B6E7E06F-FC0B-48F1-911A-55E0E1566F00}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {B6E7E06F-FC0B-48F1-911A-55E0E1566F00}.Debug|Any CPU.Build.0 = Debug|Any CPU
-    EndGlobalSection
-    GlobalSection(SolutionProperties) = preSolution
-        HideSolutionNode = FALSE
-    EndGlobalSection
-EndGlobal
-";
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio 11
+                Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `B`, `B.csproj`, `{881C1674-4ECA-451D-85B6-D7C59B7F16FA}`
+                    ProjectSection(ProjectDependencies) = postProject
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167} = {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}
+                    EndProjectSection
+                EndProject
+                Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `C`, `C.csproj`, `{4A727FF8-65F2-401E-95AD-7C8BBFBE3167}`
+                EndProject
+                Project(`{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}`) = `D`, `D.csproj`, `{B6E7E06F-FC0B-48F1-911A-55E0E1566F00}`
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = preSolution
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {4A727FF8-65F2-401E-95AD-7C8BBFBE3167}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {881C1674-4ECA-451D-85B6-D7C59B7F16FA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {B6E7E06F-FC0B-48F1-911A-55E0E1566F00}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {B6E7E06F-FC0B-48F1-911A-55E0E1566F00}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                """;
             const string projectBravoFileContents =
-                    @"
+                    """
                         <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
                             <Target Name='Build' Outputs='@(ComputedQuestion)'>
                                 <ItemGroup>
@@ -934,9 +1003,9 @@ public void SolutionConfigurationWithDependenciesRelaysItsOutputs()
                                 </ProjectReference>
                             </ItemGroup>
                         </Project>
-                    ";
+                    """;
             const string projectCharlieFileContents =
-                    @"
+                    """
                         <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
                             <Target Name='Build' Outputs='@(ComputedAnswer)'>
                                 <ItemGroup>
@@ -944,9 +1013,9 @@ public void SolutionConfigurationWithDependenciesRelaysItsOutputs()
                                 </ItemGroup>
                             </Target>
                         </Project>
-                    ";
+                    """;
             const string projectDeltaFileContents =
-                    @"
+                    """
                         <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='msbuildnamespace'>
                             <PropertyGroup>
                                 <ProjectGuid>{B6E7E06F-FC0B-48F1-911A-55E0E1566F00}</ProjectGuid>
@@ -957,60 +1026,62 @@ public void SolutionConfigurationWithDependenciesRelaysItsOutputs()
                                 </ItemGroup>
                             </Target>
                         </Project>
-                    ";
-            const string automaticProjectFileContents = @"
-<Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='compile' xmlns='msbuildnamespace'>
-    <Target Name='compile'>
-        <!-- Build projects to get a baseline for their output -->
-        <MSBuild Projects='B.csproj' Targets='Build'>
-            <Output
-                TaskParameter='TargetOutputs'
-                ItemName='BravoProjectOutputs' />
-        </MSBuild>
-        <Message Importance='high' Text='BravoProjectOutputs: @(BravoProjectOutputs)' />
-
-        <MSBuild Projects='C.csproj' Targets='Build'>
-            <Output
-                TaskParameter='TargetOutputs'
-                ItemName='CharlieProjectOutputs' />
-        </MSBuild>
-        <Message Importance='high' Text='CharlieProjectOutputs: @(CharlieProjectOutputs)' />
-
-        <MSBuild Projects='D.csproj' Targets='Build'>
-            <Output
-                TaskParameter='TargetOutputs'
-                ItemName='DeltaProjectOutputs' />
-        </MSBuild>
-        <Message Importance='high' Text='DeltaProjectOutputs: @(DeltaProjectOutputs)' />
-
-        <PropertyGroup>
-            <StringifiedBravoProjectOutputs>@(BravoProjectOutputs)</StringifiedBravoProjectOutputs>
-            <StringifiedCharlieProjectOutputs>@(CharlieProjectOutputs)</StringifiedCharlieProjectOutputs>
-            <StringifiedDeltaProjectOutputs>@(DeltaProjectOutputs)</StringifiedDeltaProjectOutputs>
-        </PropertyGroup>
-
-        <!-- Explicitly build the metaproject generated for B -->
-        <MSBuild Projects='B.csproj.metaproj' Targets='Build'>
-            <Output
-                TaskParameter='TargetOutputs'
-                ItemName='BravoMetaProjectOutputs' />
-        </MSBuild>
-        <Message Importance='high' Text='BravoMetaProjectOutputs: @(BravoMetaProjectOutputs)' />
-        <Error Condition=` '@(BravoProjectOutputs)' != '@(BravoMetaProjectOutputs)' ` Text='Metaproj outputs must match outputs of normal project build.' />
-
-        <!-- Build the solution as a whole (which will build the metaproj and return overall outputs) -->
-        <MSBuild Projects='MSBuildIssue.sln'>
-            <Output
-                TaskParameter='TargetOutputs'
-                ItemName='SolutionProjectOutputs' />
-        </MSBuild>
-        <Message Importance='high' Text='SolutionProjectOutputs: @(SolutionProjectOutputs)' />
-        <Error Condition=` '@(SolutionProjectOutputs->Count())' != '3' ` Text='Overall sln outputs must include outputs of each referenced project (there should be 3).' />
-        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedBravoProjectOutputs)'))' != 'true'` Text='Overall sln outputs must include outputs of normal project build of project B.' />
-        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedCharlieProjectOutputs)'))' != 'true' ` Text='Overall sln outputs must include outputs of normal project build of project C.' />
-        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedDeltaProjectOutputs)'))' != 'true' ` Text='Overall sln outputs must include outputs of normal project build of project D.' />
-    </Target>
-</Project>";
+                    """;
+            const string automaticProjectFileContents =
+                """
+                <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='compile' xmlns='msbuildnamespace'>
+                    <Target Name='compile'>
+                        <!-- Build projects to get a baseline for their output -->
+                        <MSBuild Projects='B.csproj' Targets='Build'>
+                            <Output
+                                TaskParameter='TargetOutputs'
+                                ItemName='BravoProjectOutputs' />
+                        </MSBuild>
+                        <Message Importance='high' Text='BravoProjectOutputs: @(BravoProjectOutputs)' />
+
+                        <MSBuild Projects='C.csproj' Targets='Build'>
+                            <Output
+                                TaskParameter='TargetOutputs'
+                                ItemName='CharlieProjectOutputs' />
+                        </MSBuild>
+                        <Message Importance='high' Text='CharlieProjectOutputs: @(CharlieProjectOutputs)' />
+
+                        <MSBuild Projects='D.csproj' Targets='Build'>
+                            <Output
+                                TaskParameter='TargetOutputs'
+                                ItemName='DeltaProjectOutputs' />
+                        </MSBuild>
+                        <Message Importance='high' Text='DeltaProjectOutputs: @(DeltaProjectOutputs)' />
+
+                        <PropertyGroup>
+                            <StringifiedBravoProjectOutputs>@(BravoProjectOutputs)</StringifiedBravoProjectOutputs>
+                            <StringifiedCharlieProjectOutputs>@(CharlieProjectOutputs)</StringifiedCharlieProjectOutputs>
+                            <StringifiedDeltaProjectOutputs>@(DeltaProjectOutputs)</StringifiedDeltaProjectOutputs>
+                        </PropertyGroup>
+
+                        <!-- Explicitly build the metaproject generated for B -->
+                        <MSBuild Projects='B.csproj.metaproj' Targets='Build'>
+                            <Output
+                                TaskParameter='TargetOutputs'
+                                ItemName='BravoMetaProjectOutputs' />
+                        </MSBuild>
+                        <Message Importance='high' Text='BravoMetaProjectOutputs: @(BravoMetaProjectOutputs)' />
+                        <Error Condition=` '@(BravoProjectOutputs)' != '@(BravoMetaProjectOutputs)' ` Text='Metaproj outputs must match outputs of normal project build.' />
+
+                        <!-- Build the solution as a whole (which will build the metaproj and return overall outputs) -->
+                        <MSBuild Projects='MSBuildIssue.sln'>
+                            <Output
+                                TaskParameter='TargetOutputs'
+                                ItemName='SolutionProjectOutputs' />
+                        </MSBuild>
+                        <Message Importance='high' Text='SolutionProjectOutputs: @(SolutionProjectOutputs)' />
+                        <Error Condition=` '@(SolutionProjectOutputs->Count())' != '3' ` Text='Overall sln outputs must include outputs of each referenced project (there should be 3).' />
+                        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedBravoProjectOutputs)'))' != 'true'` Text='Overall sln outputs must include outputs of normal project build of project B.' />
+                        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedCharlieProjectOutputs)'))' != 'true' ` Text='Overall sln outputs must include outputs of normal project build of project C.' />
+                        <Error Condition=` '@(SolutionProjectOutputs->AnyHaveMetadataValue('Identity', '$(StringifiedDeltaProjectOutputs)'))' != 'true' ` Text='Overall sln outputs must include outputs of normal project build of project D.' />
+                    </Target>
+                </Project>
+                """;
             #endregion
 
             var logger = new MockLogger(output);
@@ -1039,11 +1110,13 @@ public void SolutionConfigurationWithDependenciesRelaysItsOutputs()
         /// <summary>
         /// Test the SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration method
         /// </summary>
-        [Fact]
-        public void TestAddPropertyGroupForSolutionConfiguration()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void TestAddPropertyGroupForSolutionConfiguration(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1063,9 +1136,9 @@ public void TestAddPropertyGroupForSolutionConfiguration()
                         {A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Debug|Mixed Platforms.Build.0 = VCConfig1|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
 
             ProjectRootElement projectXml = ProjectRootElement.Create();
 
@@ -1112,11 +1185,13 @@ public void TestAddPropertyGroupForSolutionConfiguration()
         /// <summary>
         /// Make sure that BuildProjectInSolution is set to true of the Build.0 entry is in the solution configuration.
         /// </summary>
-        [Fact]
-        public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionSet()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionSet(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1131,9 +1206,9 @@ public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionSe
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.Build.0 = CSConfig1|Any CPU
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
 
             ProjectRootElement projectXml = ProjectRootElement.Create();
 
@@ -1156,11 +1231,13 @@ public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionSe
         /// <summary>
         /// Make sure that BuildProjectInSolution is set to false of the Build.0 entry is in the solution configuration.
         /// </summary>
-        [Fact]
-        public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionNotSet()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionNotSet(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1174,9 +1251,9 @@ public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionNo
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.ActiveCfg = CSConfig1|Any CPU
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
 
             ProjectRootElement projectXml = ProjectRootElement.Create();
 
@@ -1200,10 +1277,12 @@ public void TestAddPropertyGroupForSolutionConfigurationBuildProjectInSolutionNo
         /// In this bug, SkipNonexistentProjects was always set to 'Build'. It should be 'Build' for metaprojects and 'True' for everything else.
         /// The repro below has one of each case. WebProjects can't build so they are set as SkipNonexistentProjects='Build'
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void Regress751742_SkipNonexistentProjects()
+        public void Regress751742_SkipNonexistentProjects(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
             {
@@ -1212,7 +1291,7 @@ public void Regress751742_SkipNonexistentProjects()
             }
 
             var solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1232,39 +1311,43 @@ public void Regress751742_SkipNonexistentProjects()
                         {A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Debug|Mixed Platforms.Build.0 = VCConfig1|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
-            var solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            var instance = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService())[0];
+                var instance = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService())[0];
 
-            foreach (ITaskItem item in instance.Items)
-            {
-                string skipNonexistentProjects = item.GetMetadata("SkipNonexistentProjects");
-                if (item.ItemSpec.EndsWith("ClassLibrary1.csproj"))
-                {
-                    Assert.Equal("False", skipNonexistentProjects);
-                }
-                else if (item.ItemSpec.EndsWith("MainApp.metaproj"))
-                {
-                    Assert.Equal("Build", skipNonexistentProjects);
-                }
-                else if (item.ItemSpec == "Debug|Mixed Platforms")
-                {
-                    Assert.Equal("Debug", item.GetMetadata("Configuration"));
-                    Assert.Equal("Mixed Platforms", item.GetMetadata("Platform"));
-                    Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
-                }
-                else if (item.ItemSpec == "Release|Any CPU")
-                {
-                    Assert.Equal("Release", item.GetMetadata("Configuration"));
-                    Assert.Equal("Any CPU", item.GetMetadata("Platform"));
-                    Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
-                }
-                else
+                foreach (ITaskItem item in instance.Items)
                 {
-                    Assert.Fail("Unexpected project seen:" + item.ItemSpec);
+                    string skipNonexistentProjects = item.GetMetadata("SkipNonexistentProjects");
+                    if (item.ItemSpec.EndsWith("ClassLibrary1.csproj"))
+                    {
+                        Assert.Equal("False", skipNonexistentProjects);
+                    }
+                    else if (item.ItemSpec.EndsWith("MainApp.metaproj"))
+                    {
+                        Assert.Equal("Build", skipNonexistentProjects);
+                    }
+                    else if (item.ItemSpec == "Debug|Mixed Platforms")
+                    {
+                        Assert.Equal("Debug", item.GetMetadata("Configuration"));
+                        Assert.Equal("Mixed Platforms", item.GetMetadata("Platform"));
+                        Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
+                    }
+                    else if (item.ItemSpec == "Release|Any CPU")
+                    {
+                        Assert.Equal("Release", item.GetMetadata("Configuration"));
+                        Assert.Equal("Any CPU", item.GetMetadata("Platform"));
+                        Assert.Contains("<SolutionConfiguration>", item.GetMetadata("Content"));
+                    }
+                    else
+                    {
+                        Assert.Fail("Unexpected project seen:" + item.ItemSpec);
+                    }
                 }
             }
         }
@@ -1274,11 +1357,13 @@ public void Regress751742_SkipNonexistentProjects()
         /// if set when building a solution, will be specified as the ToolsVersion on the MSBuild task when
         /// building the projects contained within the solution.
         /// </summary>
-        [Fact]
-        public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1298,41 +1383,45 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
                         {A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Debug|Mixed Platforms.Build.0 = VCConfig1|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, ObjectModelHelpers.MSBuildDefaultToolsVersion, _buildEventContext, CreateMockLoggingService());
 
-            int i = 0;
-            foreach (ProjectInstance instance in instances)
-            {
-                if (i == 0)
+                int i = 0;
+                foreach (ProjectInstance instance in instances)
                 {
-                    continue;
-                }
+                    if (i == 0)
+                    {
+                        continue;
+                    }
 
-                foreach (ProjectTargetInstance target in instance.Targets.Values)
-                {
-                    foreach (ProjectTaskInstance childNode in target.Tasks)
+                    foreach (ProjectTargetInstance target in instance.Targets.Values)
                     {
-                        if (String.Equals(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                        foreach (ProjectTaskInstance childNode in target.Tasks)
                         {
-                            string projectsParameter = childNode.GetParameter("Projects");
-                            if (projectsParameter != "@(ProjectReference)")
+                            if (String.Equals(childNode.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
                             {
-                                // we found an MSBuild task invocation, now let's verify that it has the correct
-                                // ToolsVersion parameter set
-                                string toolsVersionParameter = childNode.GetParameter("ToolsVersion");
-
-                                Assert.Equal(toolsVersionParameter, instances[0].GetPropertyValue("ProjectToolsVersion"));
+                                string projectsParameter = childNode.GetParameter("Projects");
+                                if (projectsParameter != "@(ProjectReference)")
+                                {
+                                    // we found an MSBuild task invocation, now let's verify that it has the correct
+                                    // ToolsVersion parameter set
+                                    string toolsVersionParameter = childNode.GetParameter("ToolsVersion");
+
+                                    Assert.Equal(toolsVersionParameter, instances[0].GetPropertyValue("ProjectToolsVersion"));
+                                }
                             }
                         }
                     }
-                }
 
-                i++;
+                    i++;
+                }
             }
         }
 
@@ -1340,68 +1429,74 @@ public void ToolsVersionOverrideShouldBeSpecifiedOnMSBuildTaskInvocations()
         /// <summary>
         /// Make sure that whatever the solution ToolsVersion is, it gets mapped to all its metaprojs, too.
         /// </summary>
-        [Fact]
-        public void SolutionWithDependenciesHasCorrectToolsVersionInMetaprojs()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionWithDependenciesHasCorrectToolsVersionInMetaprojs(bool useNewParser)
         {
             string solutionFileContents =
-                @"
-Microsoft Visual Studio Solution File, Format Version 12.00
-Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ConsoleApplication2', 'ConsoleApplication2\ConsoleApplication2.csproj', '{5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}'
-    ProjectSection(ProjectDependencies) = postProject
-        {E0D295A1-CAFA-4E68-9929-468657DAAC6C} = {E0D295A1-CAFA-4E68-9929-468657DAAC6C}
-    EndProjectSection
-EndProject
-Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ConsoleApplication1', 'ConsoleApplication1\ConsoleApplication1.vbproj', '{E0D295A1-CAFA-4E68-9929-468657DAAC6C}'
-EndProject
-Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Any CPU = Debug|Any CPU
-        Release|Any CPU = Release|Any CPU
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Release|Any CPU.Build.0 = Release|Any CPU
-        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Debug|Any CPU.Build.0 = Debug|Any CPU
-        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Release|Any CPU.ActiveCfg = Release|Any CPU
-        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Release|Any CPU.Build.0 = Release|Any CPU
-    EndGlobalSection
-    GlobalSection(SolutionProperties) = preSolution
-        HideSolutionNode = FALSE
-    EndGlobalSection
-EndGlobal
-                ";
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ConsoleApplication2', 'ConsoleApplication2\ConsoleApplication2.csproj', '{5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}'
+                    ProjectSection(ProjectDependencies) = postProject
+                        {E0D295A1-CAFA-4E68-9929-468657DAAC6C} = {E0D295A1-CAFA-4E68-9929-468657DAAC6C}
+                    EndProjectSection
+                EndProject
+                Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ConsoleApplication1', 'ConsoleApplication1\ConsoleApplication1.vbproj', '{E0D295A1-CAFA-4E68-9929-468657DAAC6C}'
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {5B97A3C7-3DEE-47A4-870F-5CB6384FE6A4}.Release|Any CPU.Build.0 = Release|Any CPU
+                        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {E0D295A1-CAFA-4E68-9929-468657DAAC6C}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                """;
 
-            // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                // We're not passing in a /tv:xx switch, so the solution project will have tools version 2.0
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            string[] solutionToolsVersions = { "4.0", ObjectModelHelpers.MSBuildDefaultToolsVersion };
+                string[] solutionToolsVersions = { "4.0", ObjectModelHelpers.MSBuildDefaultToolsVersion };
 
-            foreach (string solutionToolsVersion in solutionToolsVersions)
-            {
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, solutionToolsVersion, _buildEventContext, CreateMockLoggingService());
+                foreach (string solutionToolsVersion in solutionToolsVersions)
+                {
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, solutionToolsVersion, _buildEventContext, CreateMockLoggingService());
 
-                Assert.Equal(2, instances.Length);
+                    Assert.Equal(2, instances.Length);
 
-                // Solution metaproj
-                Assert.Equal(solutionToolsVersion, instances[0].ToolsVersion);
+                    // Solution metaproj
+                    Assert.Equal(solutionToolsVersion, instances[0].ToolsVersion);
 
-                ICollection<ProjectItemInstance> projectReferences = instances[0].GetItems("ProjectReference");
+                    ICollection<ProjectItemInstance> projectReferences = instances[0].GetItems("ProjectReference");
 
-                foreach (ProjectItemInstance projectReference in projectReferences)
-                {
-                    // If this is the reference to the metaproj, its ToolsVersion metadata needs to match
-                    // the solution ToolsVersion -- that's how the build knows which ToolsVersion to use.
-                    if (projectReference.EvaluatedInclude.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase))
+                    foreach (ProjectItemInstance projectReference in projectReferences)
                     {
-                        Assert.Equal(solutionToolsVersion, projectReference.GetMetadataValue("ToolsVersion"));
+                        // If this is the reference to the metaproj, its ToolsVersion metadata needs to match
+                        // the solution ToolsVersion -- that's how the build knows which ToolsVersion to use.
+                        if (projectReference.EvaluatedInclude.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase))
+                        {
+                            Assert.Equal(solutionToolsVersion, projectReference.GetMetadataValue("ToolsVersion"));
+                        }
                     }
-                }
 
-                // Project metaproj for project with dependencies
-                Assert.Equal(solutionToolsVersion, instances[1].ToolsVersion);
+                    // Project metaproj for project with dependencies
+                    Assert.Equal(solutionToolsVersion, instances[1].ToolsVersion);
+                }
             }
         }
 #endif
@@ -1409,11 +1504,13 @@ public void SolutionWithDependenciesHasCorrectToolsVersionInMetaprojs()
         /// <summary>
         /// Test the SolutionProjectGenerator.Generate method has its toolset redirected correctly.
         /// </summary>
-        [Fact]
-        public void ToolsVersionOverrideCausesToolsetRedirect()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void ToolsVersionOverrideCausesToolsetRedirect(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'ClassLibrary1', 'ClassLibrary1\ClassLibrary1.csproj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
@@ -1433,8 +1530,10 @@ public void ToolsVersionOverrideCausesToolsetRedirect()
                         {A6F99D27-47B9-4EA4-BFC9-25157CBDC281}.Debug|Mixed Platforms.Build.0 = VCConfig1|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+                """;
+
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
             bool caughtException = false;
 
             try
@@ -1454,11 +1553,13 @@ public void ToolsVersionOverrideCausesToolsetRedirect()
         /// <summary>
         /// Test the SolutionProjectGenerator.AddPropertyGroupForSolutionConfiguration method
         /// </summary>
-        [Fact]
-        public void TestDisambiguateProjectTargetName()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void TestDisambiguateProjectTargetName(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'Build', 'Build\Build.csproj', '{21397922-C38F-4A0E-B950-77B3FBD51881}'
@@ -1478,55 +1579,59 @@ public void TestDisambiguateProjectTargetName()
                                 HideSolutionNode = FALSE
                         EndGlobalSection
                 EndGlobal
-                ";
-
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
-
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
-
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)));
-
-            ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)).First().Value;
-            ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)).First().Value;
-            ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)).First().Value;
-            ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)).First().Value;
-
-            // Check that the appropriate target is being passed to the child projects
-            Assert.Null(buildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
+                """;
 
-            Assert.Equal("Clean", cleanTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
-
-            Assert.Equal("Rebuild", rebuildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
-
-            Assert.Equal("Publish", publishTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Targets"));
-
-            // Check that the child projects in question are the members of the "ProjectReference" item group
-            Assert.Equal("@(ProjectReference)", buildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
-
-            Assert.Equal("@(ProjectReference->Reverse())", cleanTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            Assert.Equal("@(ProjectReference)", rebuildTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            Assert.Equal("@(ProjectReference)", publishTarget.Tasks.Where(
-                task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
-                .First().GetParameter("Projects"));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)));
+
+                ProjectTargetInstance buildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)).First().Value;
+                ProjectTargetInstance cleanTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Clean", StringComparison.OrdinalIgnoreCase)).First().Value;
+                ProjectTargetInstance rebuildTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)).First().Value;
+                ProjectTargetInstance publishTarget = instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Publish", StringComparison.OrdinalIgnoreCase)).First().Value;
+
+                // Check that the appropriate target is being passed to the child projects
+                Assert.Null(buildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                Assert.Equal("Clean", cleanTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                Assert.Equal("Rebuild", rebuildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                Assert.Equal("Publish", publishTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Targets"));
+
+                // Check that the child projects in question are the members of the "ProjectReference" item group
+                Assert.Equal("@(ProjectReference)", buildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+
+                Assert.Equal("@(ProjectReference->Reverse())", cleanTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+
+                Assert.Equal("@(ProjectReference)", rebuildTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+
+                Assert.Equal("@(ProjectReference)", publishTarget.Tasks.Where(
+                    task => String.Equals(task.Name, "MSBuild", StringComparison.OrdinalIgnoreCase))
+                    .First().GetParameter("Projects"));
+            }
 
             // We should have only the four standard targets plus the two validation targets (ValidateSolutionConfiguration and ValidateToolsVersions).
         }
@@ -1534,11 +1639,13 @@ public void TestDisambiguateProjectTargetName()
         /// <summary>
         /// Tests the algorithm for choosing default configuration/platform values for solutions
         /// </summary>
+        /// <remarks>This test would only work for the old parser. In the new parser SolutionConfigurations are not available,
+        /// and constructed from projects configurations.</remarks>
         [Fact]
         public void TestConfigurationPlatformDefaults1()
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -1550,9 +1657,9 @@ public void TestConfigurationPlatformDefaults1()
                         Release|Win32 = Release|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = SolutionFile_OldParser_Tests.ParseSolutionHelper(solutionFileContents);
 
             // These used to exist on the engine, but now need to be passed in explicitly
             IDictionary<string, string> globalProperties = new Dictionary<string, string>();
@@ -1572,11 +1679,13 @@ public void TestConfigurationPlatformDefaults1()
         /// <summary>
         /// Tests the algorithm for choosing default configuration/platform values for solutions
         /// </summary>
+        /// <remarks>This test would only work for the old parser. In the new parser SolutionConfigurations are not available,
+        /// and constructed from projects configurations.</remarks>
         [Fact]
         public void TestConfigurationPlatformDefaults2()
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -1586,9 +1695,9 @@ public void TestConfigurationPlatformDefaults2()
                         Other|Win32 = Other|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = SolutionFile_OldParser_Tests.ParseSolutionHelper(solutionFileContents);
 
             ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
 
@@ -1602,10 +1711,12 @@ public void TestConfigurationPlatformDefaults2()
         /// <summary>
         /// Tests the algorithm for choosing default Venus configuration values for solutions
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void TestVenusConfigurationDefaults()
+        public void TestVenusConfigurationDefaults(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
             {
@@ -1615,13 +1726,13 @@ public void TestVenusConfigurationDefaults()
 
             Dictionary<string, string> globalProperties = new Dictionary<string, string>();
             globalProperties["Configuration"] = "Debug";
-            ProjectInstance msbuildProject = CreateVenusSolutionProject(globalProperties);
+            ProjectInstance msbuildProject = CreateVenusSolutionProject(globalProperties, useNewParser);
 
             // ASP.NET configuration should match the selected solution configuration
             Assert.Equal("Debug", msbuildProject.GetPropertyValue("AspNetConfiguration"));
 
             globalProperties["Configuration"] = "Release";
-            msbuildProject = CreateVenusSolutionProject(globalProperties);
+            msbuildProject = CreateVenusSolutionProject(globalProperties, useNewParser);
             Assert.Equal("Release", msbuildProject.GetPropertyValue("AspNetConfiguration"));
 
             // Check that the two standard Asp.net configurations are represented on the targets
@@ -1632,10 +1743,12 @@ public void TestVenusConfigurationDefaults()
         /// <summary>
         /// Tests that the correct value for TargetFrameworkVersion gets set when creating Venus solutions
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void VenusSolutionDefaultTargetFrameworkVersion()
+        public void VenusSolutionDefaultTargetFrameworkVersion(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
             {
@@ -1644,7 +1757,7 @@ public void VenusSolutionDefaultTargetFrameworkVersion()
             }
 
             // v4.0 by default
-            ProjectInstance msbuildProject = CreateVenusSolutionProject();
+            ProjectInstance msbuildProject = CreateVenusSolutionProject(useNewParser);
             Assert.Equal("v4.0", msbuildProject.GetPropertyValue("TargetFrameworkVersion"));
 
             if (FrameworkLocationHelper.PathToDotNetFrameworkV35 == null)
@@ -1654,34 +1767,36 @@ public void VenusSolutionDefaultTargetFrameworkVersion()
             }
 
             // v3.5 if MSBuildToolsVersion is 3.5
-            msbuildProject = CreateVenusSolutionProject("3.5");
+            msbuildProject = CreateVenusSolutionProject("3.5", useNewParser);
             Assert.Equal("v3.5", msbuildProject.GetPropertyValue("TargetFrameworkVersion"));
 
             // v2.0 if MSBuildToolsVersion is 2.0
-            msbuildProject = CreateVenusSolutionProject("2.0");
+            msbuildProject = CreateVenusSolutionProject("2.0", useNewParser);
             Assert.Equal("v2.0", msbuildProject.GetPropertyValue("TargetFrameworkVersion"));
 
             // may be user defined
             IDictionary<string, string> globalProperties = new Dictionary<string, string>();
             globalProperties.Add("TargetFrameworkVersion", "userdefined");
-            msbuildProject = CreateVenusSolutionProject(globalProperties);
+            msbuildProject = CreateVenusSolutionProject(globalProperties, useNewParser);
             Assert.Equal("userdefined", msbuildProject.GetPropertyValue("TargetFrameworkVersion"));
         }
 
         /// <summary>
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void TestTargetFrameworkPaths0()
+        public void TestTargetFrameworkPaths0(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkSdkV20 != null)
             {
                 IDictionary<string, string> globalProperties = new Dictionary<string, string>();
                 globalProperties.Add("TargetFrameworkVersion", "v2.0");
 
-                ProjectInstance msbuildProject = CreateVenusSolutionProject("2.0");
+                ProjectInstance msbuildProject = CreateVenusSolutionProject("2.0", useNewParser);
 
                 // ToolsVersion is 2.0, TargetFrameworkVersion is v2.0 --> one item pointing to v2.0
                 Assert.Equal("2.0", msbuildProject.ToolsVersion);
@@ -1696,10 +1811,12 @@ public void TestTargetFrameworkPaths0()
         /// <summary>
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void TestTargetFrameworkPaths1()
+        public void TestTargetFrameworkPaths1(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
             {
@@ -1707,7 +1824,7 @@ public void TestTargetFrameworkPaths1()
                 return;
             }
 
-            ProjectInstance msbuildProject = CreateVenusSolutionProject();
+            ProjectInstance msbuildProject = CreateVenusSolutionProject(useNewParser);
 
             // ToolsVersion is 4.0, TargetFrameworkVersion is v2.0 --> one item pointing to v2.0
             msbuildProject.SetProperty("TargetFrameworkVersion", "v2.0");
@@ -1722,10 +1839,12 @@ public void TestTargetFrameworkPaths1()
         /// <summary>
         /// Tests the algorithm for choosing target framework paths for ResolveAssemblyReferences for Venus
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void TestTargetFrameworkPaths2()
+        public void TestTargetFrameworkPaths2(bool useNewParser)
         {
             if (FrameworkLocationHelper.PathToDotNetFrameworkV20 == null)
             {
@@ -1733,7 +1852,7 @@ public void TestTargetFrameworkPaths2()
                 return;
             }
 
-            ProjectInstance msbuildProject = CreateVenusSolutionProject();
+            ProjectInstance msbuildProject = CreateVenusSolutionProject(useNewParser);
 
             // ToolsVersion is 4.0, TargetFrameworkVersion is v4.0 --> items for v2.0 and v4.0
             msbuildProject.SetProperty("TargetFrameworkVersion", "v4.0");
@@ -1771,11 +1890,13 @@ public void TestTargetFrameworkPaths2()
         /// <summary>
         /// Test the PredictActiveSolutionConfigurationName method
         /// </summary>
+        /// <remarks>This test would only work for the old parser.
+        /// In the new parser SolutionConfigurations are not available, and constructed from projects configurations.</remarks>
         [Fact]
         public void TestPredictSolutionConfigurationName()
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -1785,9 +1906,9 @@ public void TestPredictSolutionConfigurationName()
                         Debug|Win32 = Debug|Win32
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = SolutionFile_OldParser_Tests.ParseSolutionHelper(solutionFileContents);
 
             IDictionary<string, string> globalProperties = new Dictionary<string, string>();
 
@@ -1806,11 +1927,13 @@ public void TestPredictSolutionConfigurationName()
         /// <summary>
         /// Verifies that the SolutionProjectGenerator will correctly escape project file paths
         /// </summary>
-        [Fact]
-        public void SolutionGeneratorEscapingProjectFilePaths()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionGeneratorEscapingProjectFilePaths(bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ConsoleApplication1', '%abtest\ConsoleApplication1.vbproj', '{AB3413A6-D689-486D-B7F0-A095371B3F13}'
@@ -1830,27 +1953,33 @@ public void SolutionGeneratorEscapingProjectFilePaths()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
-            Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
+                // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
+                Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
+                Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
 
-            // Ensure that the value has been correctly stored in the ProjectReference item list
-            // Since there is only one project in the solution, there will be only one project reference
-            Assert.Contains("%abtest", instances[0].GetItems("ProjectReference").ElementAt(0).EvaluatedInclude);
+                // Ensure that the value has been correctly stored in the ProjectReference item list
+                // Since there is only one project in the solution, there will be only one project reference
+                Assert.Contains("%abtest", instances[0].GetItems("ProjectReference").ElementAt(0).EvaluatedInclude);
+            }
         }
 
         /// <summary>
         /// Verifies that the SolutionProjectGenerator will emit a solution file.
         /// </summary>
-        [Fact]
-        public void SolutionGeneratorCanEmitSolutions()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void SolutionGeneratorCanEmitSolutions(bool useNewParser)
         {
             string oldValueForMSBuildEmitSolution = Environment.GetEnvironmentVariable("MSBuildEmitSolution");
 
@@ -1858,7 +1987,7 @@ public void SolutionGeneratorCanEmitSolutions()
             ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
 
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{F184B08F-C81C-45F6-A57F-5ABD9991F28F}') = 'ConsoleApplication1', 'ConsoleApplication1\ConsoleApplication1.vbproj', '{AB3413A6-D689-486D-B7F0-A095371B3F13}'
@@ -1878,7 +2007,7 @@ public void SolutionGeneratorCanEmitSolutions()
                         HideSolutionNode = FALSE
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
             SolutionFile solution = null;
             using ProjectCollection collection = new ProjectCollection();
@@ -1887,12 +2016,16 @@ public void SolutionGeneratorCanEmitSolutions()
             {
                 Environment.SetEnvironmentVariable("MSBuildEmitSolution", "1");
 
-                solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
+                {
+                    solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-                // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
-                Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
+                    // Creating a ProjectRootElement shouldn't affect the ProjectCollection at all
+                    Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
 
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                }
 
                 // Instantiating the
                 Assert.Empty(ProjectCollection.GlobalProjectCollection.LoadedProjects);
@@ -1919,16 +2052,18 @@ public void SolutionGeneratorCanEmitSolutions()
         /// Make sure that we output a warning and don't build anything when we're given an invalid
         /// solution configuration and SkipInvalidConfigurations is set to true.
         /// </summary>
-        [Fact]
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
-        public void TestSkipInvalidConfigurationsCase()
+        public void TestSkipInvalidConfigurationsCase(bool useNewParser)
         {
             string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
-            string solutionContents =
-                @"
+            string solutionFileContents =
+                """
                 Microsoft Visual Studio Solution File, Format Version 11.00
                 # Visual Studio 2005
                 Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'C:\solutions\WebSite2\', '..\..\solutions\WebSite2\', '{F90528C4-6989-4D33-AFE8-F53173597CC2}'
@@ -1959,7 +2094,8 @@ public void TestSkipInvalidConfigurationsCase()
                         {F90528C4-6989-4D33-AFE8-F53173597CC2}.Debug|Any CPU.ActiveCfg = Debug|.NET
                         {F90528C4-6989-4D33-AFE8-F53173597CC2}.Debug|Any CPU.Build.0 = Debug|.NET
                     EndGlobalSection
-                EndGlobal";
+                EndGlobal
+                """;
 
             try
             {
@@ -1969,12 +2105,16 @@ public void TestSkipInvalidConfigurationsCase()
                 globalProperties["Configuration"] = "Nonexistent";
                 globalProperties["SkipInvalidConfigurations"] = "true";
 
-                SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionContents.Replace('\'', '"'));
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService());
-                ProjectInstance msbuildProject = instances[0];
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
+                {
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService());
+                    ProjectInstance msbuildProject = instances[0];
 
-                // Build should complete successfully even with an invalid solution config if SkipInvalidConfigurations is true
-                Assert.True(msbuildProject.Build(new ILogger[] { logger }));
+                    // Build should complete successfully even with an invalid solution config if SkipInvalidConfigurations is true
+                    Assert.True(msbuildProject.Build(new ILogger[] { logger }));
+                }
 
                 // We should get the invalid solution configuration warning
                 Assert.Single(logger.Warnings);
@@ -2173,50 +2313,52 @@ public void BadFrameworkMonkierExpectBuildToFail2()
         /// Bug indicated that when a target framework version greater than 4.0 was used then the solution project generator would crash.
         /// this test is to make sure the fix is not regressed.
         /// </summary>
-        [Fact]
-        public void TestTargetFrameworkVersionGreaterThan4()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void TestTargetFrameworkVersionGreaterThan4(bool useNewParser)
         {
             string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
             string solutionFileContents =
-               @"
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual Studio 2010
-Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'WebSite1', '..\WebSite1\', '{6B8F98F2-C976-4029-9321-5CCD73A174DA}'
-    ProjectSection(WebsiteProperties) = preProject
-        TargetFrameworkMoniker = '.NETFramework,Version=v4.34'
-        Debug.AspNetCompiler.VirtualPath = '/WebSite1'
-        Debug.AspNetCompiler.PhysicalPath = '..\WebSite1\'
-        Debug.AspNetCompiler.TargetPath = 'PrecompiledWeb\WebSite1\'
-        Debug.AspNetCompiler.Updateable = 'true'
-        Debug.AspNetCompiler.ForceOverwrite = 'true'
-        Debug.AspNetCompiler.FixedNames = 'false'
-        Debug.AspNetCompiler.Debug = 'True'
-        Release.AspNetCompiler.VirtualPath = '/WebSite1'
-        Release.AspNetCompiler.PhysicalPath = '..\WebSite1\'
-        Release.AspNetCompiler.TargetPath = 'PrecompiledWeb\WebSite1\'
-        Release.AspNetCompiler.Updateable = 'true'
-        Release.AspNetCompiler.ForceOverwrite = 'true'
-        Release.AspNetCompiler.FixedNames = 'false'
-        Release.AspNetCompiler.Debug = 'False'
-        VWDPort = '45602'
-        DefaultWebSiteLanguage = 'Visual Basic'
-    EndProjectSection
-EndProject
-Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Any CPU = Debug|Any CPU
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-        {6B8F98F2-C976-4029-9321-5CCD73A174DA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-        {6B8F98F2-C976-4029-9321-5CCD73A174DA}.Debug|Any CPU.Build.0 = Debug|Any CPU
-    EndGlobalSection
-    GlobalSection(SolutionProperties) = preSolution
-        HideSolutionNode = FALSE
-    EndGlobalSection
-EndGlobal
-                ";
+               """
+                Microsoft Visual Studio Solution File, Format Version 11.00
+                # Visual Studio 2010
+                Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'WebSite1', '..\WebSite1\', '{6B8F98F2-C976-4029-9321-5CCD73A174DA}'
+                    ProjectSection(WebsiteProperties) = preProject
+                        TargetFrameworkMoniker = '.NETFramework,Version=v4.34'
+                        Debug.AspNetCompiler.VirtualPath = '/WebSite1'
+                        Debug.AspNetCompiler.PhysicalPath = '..\WebSite1\'
+                        Debug.AspNetCompiler.TargetPath = 'PrecompiledWeb\WebSite1\'
+                        Debug.AspNetCompiler.Updateable = 'true'
+                        Debug.AspNetCompiler.ForceOverwrite = 'true'
+                        Debug.AspNetCompiler.FixedNames = 'false'
+                        Debug.AspNetCompiler.Debug = 'True'
+                        Release.AspNetCompiler.VirtualPath = '/WebSite1'
+                        Release.AspNetCompiler.PhysicalPath = '..\WebSite1\'
+                        Release.AspNetCompiler.TargetPath = 'PrecompiledWeb\WebSite1\'
+                        Release.AspNetCompiler.Updateable = 'true'
+                        Release.AspNetCompiler.ForceOverwrite = 'true'
+                        Release.AspNetCompiler.FixedNames = 'false'
+                        Release.AspNetCompiler.Debug = 'False'
+                        VWDPort = '45602'
+                        DefaultWebSiteLanguage = 'Visual Basic'
+                    EndProjectSection
+                EndProject
+                Global
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {6B8F98F2-C976-4029-9321-5CCD73A174DA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6B8F98F2-C976-4029-9321-5CCD73A174DA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                EndGlobal
+                """;
 
             try
             {
@@ -2226,18 +2368,22 @@ public void TestTargetFrameworkVersionGreaterThan4()
                 globalProperties["Configuration"] = "Release";
                 globalProperties["SkipInvalidConfigurations"] = "true";
 
-                SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents.Replace('\'', '"'));
-                using ProjectCollection collection = new ProjectCollection();
-                collection.RegisterLogger(logger);
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
+                {
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
+
+                    using ProjectCollection collection = new ProjectCollection();
+                    collection.RegisterLogger(logger);
 
 #pragma warning disable format
 #if !FEATURE_ASPNET_COMPILER
-                Assert.Throws<InvalidProjectFileException>(() =>
-                {
+                    Assert.Throws<InvalidProjectFileException>(() =>
+                    {
 #endif
-                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, collection.LoggingService);
+                        ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, collection.LoggingService);
 #if !FEATURE_ASPNET_COMPILER
-                });
+                    });
 #endif
 #pragma warning restore format
 
@@ -2246,6 +2392,7 @@ public void TestTargetFrameworkVersionGreaterThan4()
                 string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("AspNetCompiler.TargetingHigherFrameworksDefaultsTo40", solution.ProjectsInOrder[0].ProjectName, ver.ToString());
                 logger.AssertLogContains(message);
 #endif
+                }
             }
             finally
             {
@@ -2256,14 +2403,16 @@ public void TestTargetFrameworkVersionGreaterThan4()
         /// <summary>
         /// Verifies that when target names are specified they end up in the metaproj.
         /// </summary>
-        [Fact]
-        public void CustomTargetNamesAreInInMetaproj()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void CustomTargetNamesAreInInMetaproj(bool useNewParser)
         {
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(
-            @"
-                Microsoft Visual Studio Solution File, Format Version 14.00
+            string solutionFileContents =
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
                 # Visual Studio 2015
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1.csproj"", ""{6185CC21-BE89-448A-B3C0-D1C27112E595}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                 EndProject
                 Global
                     GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -2275,43 +2424,51 @@ public void CustomTargetNamesAreInInMetaproj()
                         {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = CSConfig2|Any CPU
                     EndGlobalSection
                 EndGlobal
-            ");
+                """;
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "One" });
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase)));
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "One" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Two", "Three", "Four" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "One", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Two", "Three", "Four" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Build" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Two", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Three", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Four", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Build" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Five", "Rebuild" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Build", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase)));
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "Five", "Rebuild" });
 
-            instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "My_Project:Six" });
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Five", StringComparison.OrdinalIgnoreCase)));
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Rebuild", StringComparison.OrdinalIgnoreCase)));
 
-            Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
+                instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), new List<string> { "My_Project:Six" });
+        
+                Assert.Single(instances[0].Targets.Where(target => String.Equals(target.Value.Name, "Six", StringComparison.OrdinalIgnoreCase)));
+            }
         }
 
         /// <summary>
         /// Verifies that disambiguated target names are used when a project name matches a standard solution entry point.
         /// </summary>
-        [Fact]
-        public void DisambiguatedTargetNamesAreInInMetaproj()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void DisambiguatedTargetNamesAreInMetaproj(bool useNewParser)
         {
-            foreach(string projectName in ProjectInSolution.projectNamesToDisambiguate)
+            foreach (string projectName in ProjectInSolution.projectNamesToDisambiguate)
             {
-                SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(
-                $$"""
-                    Microsoft Visual Studio Solution File, Format Version 14.00
+                string solutionFileContents =
+                    $$"""
+                    Microsoft Visual Studio Solution File, Format Version 12.00
                     # Visual Studio 2015
                     Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "{{projectName}}", "{{projectName}}.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                     EndProject
@@ -2326,21 +2483,27 @@ public void DisambiguatedTargetNamesAreInInMetaproj()
                             {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
                         EndGlobalSection
                     EndGlobal
-                """);
+                    """;
 
-                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), null);
-
-                foreach (string targetName in ProjectInSolution.projectNamesToDisambiguate)
+                // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+                using (TestEnvironment testEnvironment = TestEnvironment.Create())
                 {
-                    // The entry point still exists normally.
-                    Assert.True(instances[0].Targets.ContainsKey(targetName));
-
-                    // The traversal target should be disambiguated with a "Solution:" prefix.
-                    // Note: The default targets are used instead of "Build".
-                    string traversalTargetName = targetName.Equals("Build", StringComparison.OrdinalIgnoreCase)
-                        ? $"Solution:{projectName}"
-                        : $"Solution:{projectName}:{targetName}";
-                    Assert.True(instances[0].Targets.ContainsKey(traversalTargetName));
+                    SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
+
+                    ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, BuildEventContext.Invalid, CreateMockLoggingService(), null);
+
+                    foreach (string targetName in ProjectInSolution.projectNamesToDisambiguate)
+                    {
+                        // The entry point still exists normally.
+                        Assert.True(instances[0].Targets.ContainsKey(targetName));
+
+                        // The traversal target should be disambiguated with a "Solution:" prefix.
+                        // Note: The default targets are used instead of "Build".
+                        string traversalTargetName = targetName.Equals("Build", StringComparison.OrdinalIgnoreCase)
+                            ? $"Solution:{projectName}"
+                            : $"Solution:{projectName}:{targetName}";
+                        Assert.True(instances[0].Targets.ContainsKey(traversalTargetName));
+                    }
                 }
             }
         }
@@ -2349,73 +2512,81 @@ public void DisambiguatedTargetNamesAreInInMetaproj()
         /// Verifies that illegal user target names (the ones already used internally) don't crash the SolutionProjectGenerator
         /// </summary>
         [Theory]
-        [InlineData(false)]
-        [InlineData(true)]
-        public void IllegalUserTargetNamesDoNotThrow(bool forceCaseDifference)
+        [InlineData(false, false)]
+        [InlineData(true, false)]
+        [InlineData(false, true)]
+        [InlineData(true, true)]
+        public void IllegalUserTargetNamesDoNotThrow(bool forceCaseDifference, bool useNewParser)
         {
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(
-            @"
-                Microsoft Visual Studio Solution File, Format Version 14.00
+            string solutionFileContents =
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
                 # Visual Studio 2015
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1.csproj"", ""{6185CC21-BE89-448A-B3C0-D1C27112E595}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                 EndProject
                 Global
-	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                Debug|Any CPU = Debug|Any CPU
-		                Release|Any CPU = Release|Any CPU
-	                EndGlobalSection
-	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
-	                EndGlobalSection
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
                 EndGlobal
-            ");
+                """;
 
-            ProjectInstance[] instances;
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            // Avoid any unexpected targets getting pulled in
-            var globalProperties = new Dictionary<string, string> { { "ImportByWildcardBeforeSolution", "false" } };
+                ProjectInstance[] instances;
 
-            foreach (string builtInTargetName in new[]
-            {
-                null,
-                "Build",
-                "Rebuild",
-                "Clean",
-                "Publish",
-                "ClassLibrary1",
-                "ClassLibrary1:Clean",
-                "ClassLibrary1:Rebuild",
-                "GetSolutionConfigurationContents",
-                "ValidateProjects",
-            })
-            {
-                string[] targetNames;
+                // Avoid any unexpected targets getting pulled in
+                var globalProperties = new Dictionary<string, string> { { "ImportByWildcardBeforeSolution", "false" } };
 
-                if (builtInTargetName == null)
+                foreach (string builtInTargetName in new[]
                 {
-                    targetNames = null;
-                }
-                else
+                    null,
+                    "Build",
+                    "Rebuild",
+                    "Clean",
+                    "Publish",
+                    "ClassLibrary1",
+                    "ClassLibrary1:Clean",
+                    "ClassLibrary1:Rebuild",
+                    "GetSolutionConfigurationContents",
+                    "ValidateProjects",
+                })
                 {
-                    string targetName = forceCaseDifference ? builtInTargetName.ToUpperInvariant() : builtInTargetName;
-                    targetNames = new[] { targetName };
-                }
+                    string[] targetNames;
 
-                instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), targetNames);
+                    if (builtInTargetName == null)
+                    {
+                        targetNames = null;
+                    }
+                    else
+                    {
+                        string targetName = forceCaseDifference ? builtInTargetName.ToUpperInvariant() : builtInTargetName;
+                        targetNames = new[] { targetName };
+                    }
 
-                Assert.Single(instances);
+                    instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), targetNames);
 
-                Assert.Equal(12, instances[0].TargetsCount);
-            }
+                    Assert.Single(instances);
 
-            instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), new[] { "Foo" });
+                    Assert.Equal(12, instances[0].TargetsCount);
+                }
+
+                instances = SolutionProjectGenerator.Generate(solution, globalProperties, null, BuildEventContext.Invalid, CreateMockLoggingService(), new[] { "Foo" });
 
-            Assert.Single(instances);
+                Assert.Single(instances);
 
-            Assert.Equal(14, instances[0].TargetsCount);
+                Assert.Equal(14, instances[0].TargetsCount);
+            }
         }
 
         /// <summary>
@@ -2426,31 +2597,34 @@ public void AfterTargetsComeFromImport()
         {
             string baseDirectory = Guid.NewGuid().ToString("N");
 
-            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"), @"
-                Microsoft Visual Studio Solution File, Format Version 14.00
+            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"),
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
                 # Visual Studio 2015
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1.csproj"", ""{6185CC21-BE89-448A-B3C0-D1C27112E595}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                 EndProject
                 Global
-	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                Debug|Any CPU = Debug|Any CPU
-		                Release|Any CPU = Release|Any CPU
-	                EndGlobalSection
-	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
-	                EndGlobalSection
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
                 EndGlobal
-            ");
+                """);
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"after.{Path.GetFileName(solutionFilePath)}.targets"), @"
-                <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""msbuildnamespace"">
-                    <Target Name=""MyTarget"">
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"after.{Path.GetFileName(solutionFilePath)}.targets"),
+                """
+                <Project ToolsVersion="msbuilddefaulttoolsversion" xmlns="msbuildnamespace">
+                    <Target Name="MyTarget">
                         <MyTask />
                     </Target>
-                </Project>");
+                </Project>
+                """);
 
             try
             {
@@ -2482,31 +2656,34 @@ public void BeforeTargetsFromImportCanHookDynamicTarget()
         {
             string baseDirectory = Guid.NewGuid().ToString("N");
 
-            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"), @"
-                Microsoft Visual Studio Solution File, Format Version 14.00
+            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"),
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
                 # Visual Studio 2015
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1.csproj"", ""{6185CC21-BE89-448A-B3C0-D1C27112E595}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                 EndProject
                 Global
-	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                Debug|Any CPU = Debug|Any CPU
-		                Release|Any CPU = Release|Any CPU
-	                EndGlobalSection
-	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
-	                EndGlobalSection
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
                 EndGlobal
-            ");
+                """);
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"after.{Path.GetFileName(solutionFilePath)}.targets"), @"
-                <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""msbuildnamespace"">
-                    <Target Name=""MyTarget"" BeforeTargets=""DynamicTraversalTarget"">
-                        <Warning Text=""Message from MyTarget"" />
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"after.{Path.GetFileName(solutionFilePath)}.targets"),
+                """
+                <Project ToolsVersion="msbuilddefaulttoolsversion" xmlns="msbuildnamespace">
+                    <Target Name="MyTarget" BeforeTargets="DynamicTraversalTarget">
+                        <Warning Text="Message from MyTarget" />
                     </Target>
-                </Project>");
+                </Project>
+                """);
 
             try
             {
@@ -2557,48 +2734,55 @@ public void DirectorySolutionPropsTest(string projectName, bool enable)
 
             string baseDirectory = Guid.NewGuid().ToString("N");
 
-            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"), @"
-                Microsoft Visual Studio Solution File, Format Version 14.00
+            string solutionFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, $"{Guid.NewGuid():N}.sln"),
+                """
+                Microsoft Visual Studio Solution File, Format Version 12.00
                 # Visual Studio 2015
-                Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""ClassLibrary1"", ""ClassLibrary1.csproj"", ""{6185CC21-BE89-448A-B3C0-D1C27112E595}""
+                Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1.csproj", "{6185CC21-BE89-448A-B3C0-D1C27112E595}"
                 EndProject
                 Global
-	                GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		                Debug|Any CPU = Debug|Any CPU
-		                Release|Any CPU = Release|Any CPU
-	                EndGlobalSection
-	                GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		                {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
-	                EndGlobalSection
+                    GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        Debug|Any CPU = Debug|Any CPU
+                        Release|Any CPU = Release|Any CPU
+                    EndGlobalSection
+                    GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Release|Any CPU.Build.0 = Release|Any CPU
+                    EndGlobalSection
                 EndGlobal
-            ");
+                """);
 
-            string projectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, projectName), $@"
-                <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""msbuildnamespace"">
+            string projectPath = ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, projectName),
+                $$"""
+                <Project ToolsVersion="msbuilddefaulttoolsversion" xmlns="msbuildnamespace">
                     <PropertyGroup>
-                        <PropertyA>{expectedPropertyValue}</PropertyA>
+                        <PropertyA>{{expectedPropertyValue}}</PropertyA>
                     </PropertyGroup>
-                </Project>");
+                </Project>
+                """);
 
             if (projectPath.StartsWith("Custom", StringComparison.OrdinalIgnoreCase))
             {
                 // If a custom file name was given, create a Directory.Solution.props and Directory.Build.targets to ensure that they aren't imported
-                ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, "Directory.Solution.props"), $@"
-                <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""msbuildnamespace"">
-                    <PropertyGroup>
-                        <PropertyA>This file should not be imported</PropertyA>
-                    </PropertyGroup>
-                </Project>");
-
-                ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, "Directory.Solution.targets"), $@"
-                <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""msbuildnamespace"">
-                    <PropertyGroup>
-                        <PropertyA>This file should not be imported</PropertyA>
-                    </PropertyGroup>
-                </Project>");
+                ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, "Directory.Solution.props"),
+                    """
+                    <Project ToolsVersion="msbuilddefaulttoolsversion" xmlns="msbuildnamespace">
+                        <PropertyGroup>
+                            <PropertyA>This file should not be imported</PropertyA>
+                        </PropertyGroup>
+                    </Project>
+                    """);
+
+                ObjectModelHelpers.CreateFileInTempProjectDirectory(Path.Combine(baseDirectory, "Directory.Solution.targets"),
+                    """
+                    <Project ToolsVersion="msbuilddefaulttoolsversion" xmlns="msbuildnamespace">
+                        <PropertyGroup>
+                            <PropertyA>This file should not be imported</PropertyA>
+                        </PropertyGroup>
+                    </Project>
+                    """);
             }
 
             try
@@ -2640,20 +2824,23 @@ public void DirectorySolutionPropsTest(string projectName, bool enable)
         /// Regression test for https://github.com/dotnet/msbuild/issues/6236
         /// </summary>
         [Theory]
-        [InlineData("http://localhost:8080")]
-        [InlineData("a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-a-really-long-string-")]
-        public void AbsolutePathWorksForUnsupportedPaths(string relativePath)
+        [InlineData("http://localhost:8080", false)]
+        [InlineData("http://localhost:8080", true)]
+        [InlineData(_longLineString, false)]
+        [InlineData(_longLineString, true)]
+        public void AbsolutePathWorksForUnsupportedPaths(string relativePath, bool useNewParser)
         {
             string solutionFileContents =
-                $@"
-Microsoft Visual Studio Solution File, Format Version 12.00
-# Visual Studio Version 16
-VisualStudioVersion = 16.0.31025.194
-MinimumVisualStudioVersion = 10.0.40219.1
-Project(""{{E24C65DC-7377-472B-9ABA-BC803B73C61A}}"") = ""WebSite1"", ""{relativePath}"", ""{{{{96E0707C-2E9C-4704-946F-FA583147737F}}}}""
-EndProject";
+                $$"""
+                Microsoft Visual Studio Solution File, Format Version 12.00
+                # Visual Studio Version 16
+                VisualStudioVersion = 16.0.31025.194
+                MinimumVisualStudioVersion = 10.0.40219.1
+                Project("{E24C65DC-7377-472B-9ABA-BC803B73C61A}") = "WebSite1", "{{relativePath}}", "{96E0707C-2E9C-4704-946F-FA583147737F}"
+                EndProject
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser);
 
             ProjectInSolution projectInSolution = solution.ProjectsInOrder.ShouldHaveSingleItem();
 
@@ -2665,25 +2852,25 @@ public void AbsolutePathWorksForUnsupportedPaths(string relativePath)
         /// <summary>
         /// Create a Project derived from a Venus solution
         /// </summary>
-        private ProjectInstance CreateVenusSolutionProject()
+        private ProjectInstance CreateVenusSolutionProject(bool useNewParser)
         {
-            return CreateVenusSolutionProject(null, null);
+            return CreateVenusSolutionProject(null, null, useNewParser);
         }
 
         /// <summary>
         /// Create a Project derived from a Venus solution
         /// </summary>
-        private ProjectInstance CreateVenusSolutionProject(IDictionary<string, string> globalProperties)
+        private ProjectInstance CreateVenusSolutionProject(IDictionary<string, string> globalProperties, bool useNewParser)
         {
-            return CreateVenusSolutionProject(globalProperties, null);
+            return CreateVenusSolutionProject(globalProperties, null, useNewParser);
         }
 
         /// <summary>
         /// Create a Project derived from a Venus solution
         /// </summary>
-        private ProjectInstance CreateVenusSolutionProject(string toolsVersion)
+        private ProjectInstance CreateVenusSolutionProject(string toolsVersion, bool useNewParser)
         {
-            return CreateVenusSolutionProject(null, toolsVersion);
+            return CreateVenusSolutionProject(null, toolsVersion, useNewParser);
         }
 
         /// <summary>
@@ -2692,10 +2879,10 @@ private ProjectInstance CreateVenusSolutionProject(string toolsVersion)
         /// </summary>
         /// <param name="globalProperties">The dictionary of global properties.  May be null.</param>
         /// <param name="toolsVersion">The ToolsVersion override value.  May be null.</param>
-        private ProjectInstance CreateVenusSolutionProject(IDictionary<string, string> globalProperties, string toolsVersion)
+        private ProjectInstance CreateVenusSolutionProject(IDictionary<string, string> globalProperties, string toolsVersion, bool useNewParser)
         {
             string solutionFileContents =
-                @"
+                """
                 Microsoft Visual Studio Solution File, Format Version 9.00
                 # Visual Studio 2005
                 Project('{E24C65DC-7377-472B-9ABA-BC803B73C61A}') = 'C:\solutions\WebSite2\', '..\..\solutions\WebSite2\', '{F90528C4-6989-4D33-AFE8-F53173597CC2}'
@@ -2727,14 +2914,18 @@ private ProjectInstance CreateVenusSolutionProject(IDictionary<string, string> g
                         {F90528C4-6989-4D33-AFE8-F53173597CC2}.Debug|Any CPU.Build.0 = Debug|.NET
                     EndGlobalSection
                 EndGlobal
-                ";
+                """;
 
-            SolutionFile solution = SolutionFile_Tests.ParseSolutionHelper(solutionFileContents);
+            // SolutionProjectGenerator.Generate calls SolutionFile.UseNewParser, so we need TestEnvironment with the environment variable available.
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                SolutionFile solution = ParseSolutionHelper(solutionFileContents, useNewParser, testEnvironment);
 
-            ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, toolsVersion, BuildEventContext.Invalid, CreateMockLoggingService());
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, globalProperties, toolsVersion, BuildEventContext.Invalid, CreateMockLoggingService());
 
-            // Index 0 is the traversal project, which will reference the sole Venus project.
-            return instances[1];
+                // Index 0 is the traversal project, which will reference the sole Venus project.
+                return instances[1];
+            }
         }
 
         private ILoggingService CreateMockLoggingService()
@@ -2776,6 +2967,25 @@ private void AssertProjectItemNameCount(ProjectInstance msbuildProject, string i
             Assert.Equal(count, itemGroup.Count());
         }
 
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool isOptInSlnParsingWithNewParser)
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                return ParseSolutionHelper(solutionFileContents, isOptInSlnParsingWithNewParser, testEnvironment);
+            }
+        }
+
+        private static SolutionFile ParseSolutionHelper(string solutionFileContents, bool isOptInSlnParsingWithNewParser, TestEnvironment testEnvironment)
+        {
+            solutionFileContents = solutionFileContents.Replace('\'', '"');
+            if (isOptInSlnParsingWithNewParser)
+            {
+                testEnvironment.SetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE", "1");
+            }
+            TransientTestFile sln = testEnvironment.CreateFile(FileUtilities.GetTemporaryFileName(".sln"), solutionFileContents);
+            return SolutionFile.Parse(sln.Path);
+        }
+
         #endregion // Helper Functions
     }
 }
diff --git a/src/Build.UnitTests/Definition/ProjectHelpers.cs b/src/Build.UnitTests/Definition/ProjectHelpers.cs
index b3be8049606..2f0ccf65fe7 100644
--- a/src/Build.UnitTests/Definition/ProjectHelpers.cs
+++ b/src/Build.UnitTests/Definition/ProjectHelpers.cs
@@ -1,8 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.IO;
-using System.Xml;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 
diff --git a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
index ce86f880e14..bb33b9a9733 100644
--- a/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectItem_Tests.cs
@@ -3,9 +3,7 @@
 
 using System;
 using System.Collections.Generic;
-using System.IO;
 using System.Linq;
-using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Xunit;
diff --git a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
index 8255424b6a7..fbdc08a9dee 100644
--- a/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
+++ b/src/Build.UnitTests/Definition/Project_Internal_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.IO;
 using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
diff --git a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
index 7ca7b24910b..115f418e3c3 100644
--- a/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsVersion_Tests.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Text.RegularExpressions;
-using System.Xml;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -15,7 +14,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
-using Xunit.NetCore.Extensions;
 using InternalUtilities = Microsoft.Build.Internal.Utilities;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using LoggerMode = Microsoft.Build.BackEnd.Logging.LoggerMode;
diff --git a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
index 50aadc89522..f894d193999 100644
--- a/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetConfigurationReader_Tests.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Shared;
 using Xunit;
 using ToolsetConfigurationSection = Microsoft.Build.Evaluation.ToolsetConfigurationSection;
 
diff --git a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
index 833ac2561a1..846be328f53 100644
--- a/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
+++ b/src/Build.UnitTests/Definition/ToolsetReader_Tests.cs
@@ -20,7 +20,6 @@
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 using InternalUtilities = Microsoft.Build.Internal.Utilities;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/Definition/Toolset_Tests.cs b/src/Build.UnitTests/Definition/Toolset_Tests.cs
index 9c76a26954e..929513584ac 100644
--- a/src/Build.UnitTests/Definition/Toolset_Tests.cs
+++ b/src/Build.UnitTests/Definition/Toolset_Tests.cs
@@ -9,10 +9,8 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
index 5cc7e4309cc..fe0acc1db0d 100644
--- a/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpanderFunction_Tests.cs
@@ -2,11 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Globalization;
-using System.Runtime.InteropServices;
 using System.Threading;
 
-using Microsoft.Build.Evaluation;
-
 using Shouldly;
 
 using Xunit;
diff --git a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
index c354a5b26e0..53ca81fcccb 100644
--- a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
@@ -10,7 +10,6 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
index c34473dd335..4501f10688c 100644
--- a/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
@@ -1,13 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.IO;
-using System.Xml;
-
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 
 using Shouldly;
diff --git a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
index 915e38582d5..0709ee7be41 100644
--- a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 
 
diff --git a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
index a5041d55fd6..e596bc05e8a 100644
--- a/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SdkResultEvaluation_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using System.Xml;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
@@ -137,6 +138,40 @@ public void SdkResolverCanReturnNoPaths(bool includePropertiesAndItems)
             _logger.WarningCount.ShouldBe(0);
         }
 
+        [Fact]
+        public void SuccessfullyEvaluatesSdkResultWithPropertiesForNullProjectRootElement()
+        {
+            Dictionary<string, string> propertiesToAdd = null;
+            Dictionary<string, SdkResultItem> itemsToAdd = null;
+
+            CreateMockSdkResultPropertiesAndItems(out propertiesToAdd, out itemsToAdd);
+
+            var projectOptions = SdkUtilities.CreateProjectOptionsWithResolver(new SdkUtilities.ConfigurableMockSdkResolver(
+                new Build.BackEnd.SdkResolution.SdkResult(
+                        new SdkReference("TestPropsAndItemsFromResolverSdk", null, null),
+                        Enumerable.Empty<string>(),
+                        version: null,
+                        propertiesToAdd,
+                        itemsToAdd,
+                        warnings: null)));
+
+            string projectContent = @"
+                    <Project>
+                        <Import Project=""Sdk.props"" Sdk=""TestPropsAndItemsFromResolverSdk""/>
+                    </Project>";
+
+            string projectPath = Path.Combine(_testFolder, "project.proj");
+            File.WriteAllText(projectPath, projectContent);
+
+            using XmlReader xmlReader = XmlReader.Create(projectPath);
+
+            projectOptions.ProjectCollection = _projectCollection;
+
+            // Creating project from XmlReader results in null ProjectRootElement on Evaluation phase.
+            // In that case project created for SdkResult properties and items is given a unique file name {Guid}.SdkResolver.{propertiesAndItemsHash}.proj in the current directory
+            Project.FromXmlReader(xmlReader, projectOptions);
+        }
+
         [Theory]
         [InlineData(true, true)]
         [InlineData(true, false)]
diff --git a/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
index e082039d337..947d1dc22c6 100644
--- a/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SimpleProjectRootElementCache_Tests.cs
@@ -5,7 +5,6 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
 
diff --git a/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs b/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
index 85abd3297a2..6a3ad2f17bd 100644
--- a/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ToolsetConfigurationNet5_Tests.cs
@@ -5,12 +5,11 @@
 /*  This test is designed especially to test Configuration parsing in net5.0
  *  which means it WON'T work in net472 and thus we don't run it in net472 */
 
+using System.Collections.Generic;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
-
-using Xunit;
-using System.Collections.Generic;
 using Shouldly;
+using Xunit;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/EvaluationProfiler_Tests.cs b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
index ff450b8a77b..ba4945a0bde 100644
--- a/src/Build.UnitTests/EvaluationProfiler_Tests.cs
+++ b/src/Build.UnitTests/EvaluationProfiler_Tests.cs
@@ -5,7 +5,6 @@
 using System.Collections.Immutable;
 using System.IO;
 using System.Linq;
-using System.Xml;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
diff --git a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
index 72a46b6d23b..80781a43671 100644
--- a/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
+++ b/src/Build.UnitTests/FileUtilitiesRegex_Tests.cs
@@ -532,7 +532,6 @@ public void PatternEmptyString_LegacyRegex()
         {
             UncPattern.IsMatch(string.Empty).ShouldBeFalse();
             StartsWithUncPattern.IsMatch(string.Empty).ShouldBeFalse();
-            StartsWithUncPattern.Match(string.Empty).Success.ShouldBeFalse();
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/FixPathOnUnix_Tests.cs b/src/Build.UnitTests/FixPathOnUnix_Tests.cs
index 757c2ccde2c..bd5ac2b4224 100644
--- a/src/Build.UnitTests/FixPathOnUnix_Tests.cs
+++ b/src/Build.UnitTests/FixPathOnUnix_Tests.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
index cc551762e11..d6295254e32 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
@@ -70,9 +70,12 @@ public void GlobFromRelativeGlobRootNormalizesRootAgainstCurrentDirectory()
         [Fact]
         public void GlobFromRootWithInvalidPathThrows()
         {
-            foreach (var invalidPathChar in FileUtilities.InvalidPathChars)
+            for (int i = 0; i < 128; i++)
             {
-                Assert.Throws<ArgumentException>(() => MSBuildGlob.Parse(invalidPathChar.ToString(), "*"));
+                if (FileUtilities.InvalidPathChars.Contains((char)i))
+                {
+                    Assert.Throws<ArgumentException>(() => MSBuildGlob.Parse(((char)i).ToString(), "*"));
+                }
             }
         }
 
@@ -182,12 +185,15 @@ public void GlobMatchShouldReturnFalseIfArgumentContainsInvalidPathOrFileCharact
         {
             var glob = MSBuildGlob.Parse("*");
 
-            foreach (var invalidPathChar in FileUtilities.InvalidPathChars)
+            for (int i = 0; i < 128; i++)
             {
-                Assert.False(glob.IsMatch(invalidPathChar.ToString()));
+                if (FileUtilities.InvalidPathChars.Contains((char)i))
+                {
+                    Assert.False(glob.IsMatch(((char)i).ToString()));
+                }
             }
 
-            foreach (var invalidFileChar in FileUtilities.InvalidFileNameChars)
+            foreach (var invalidFileChar in FileUtilities.InvalidFileNameCharsArray)
             {
                 if (invalidFileChar == '\\' || invalidFileChar == '/')
                 {
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
index b941649ad74..d2e63cd06f8 100644
--- a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -1,24 +1,13 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
-using System.Collections.Immutable;
-using System.Diagnostics;
 using System.IO;
-using System.Linq;
-using System.Text.RegularExpressions;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Exceptions;
-using Microsoft.Build.Execution;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using Xunit;
-using Xunit.Abstractions;
 using static Microsoft.Build.Graph.UnitTests.GraphTestingUtilities;
-using static Microsoft.Build.Graph.UnitTests.ProjectGraphTests;
 
 #nullable disable
 
@@ -402,14 +391,14 @@ public void SolutionWithoutAllConfigurations()
 
                 // Slashes here (and in the .slnf) are hardcoded as backslashes intentionally to support the common case.
                 TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "SimpleProject.sln",
-                    @"
+                    """
                     Microsoft Visual Studio Solution File, Format Version 12.00
                     # Visual Studio Version 16
                     VisualStudioVersion = 16.0.29326.124
                     MinimumVisualStudioVersion = 10.0.40219.1
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Project1"", ""1\1\1.csproj"", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
+                    Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Project1", "1\1\1.csproj", "{79B5EBA6-5D27-4976-BC31-14422245A59A}"
                     EndProject
-                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""2"", ""2\2\2.proj"", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
+                    Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "2", "2\2\2.proj", "{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}"
                     EndProject
                     Global
                         GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -434,7 +423,7 @@ public void SolutionWithoutAllConfigurations()
                             SolutionGuid = {DE7234EC-0C4D-4070-B66A-DCF1B4F0CFEF}
                         EndGlobalSection
                     EndGlobal
-                ");
+                    """);
 
                 ProjectCollection projectCollection = testEnvironment.CreateProjectCollection().Collection;
                 MockLogger logger = new();
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 431ea412875..bcf72ce632a 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.Linq;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Engine.UnitTests;
 using Microsoft.Build.Exceptions;
@@ -59,7 +58,8 @@ public void GraphConstructionFailsOnNonExistentSolution()
                     new ProjectGraph("nonExistent.sln");
                 });
 
-            exception.Message.ShouldContain("The project file could not be loaded. Could not find file");
+            exception.Message.ShouldContain("The project file could not be loaded.");
+            exception.Message.ShouldContain("Could not find file");
         }
 
         [Fact]
@@ -646,28 +646,6 @@ IEnumerable<ProjectItemInstance> GetIncomingEdgeItemsToNode(ProjectGraphNode nod
             }
         }
 
-        [Fact]
-        public void GraphConstructionShouldThrowOnMissingSolutionDependencies()
-        {
-            var solutionContents = SolutionFileBuilder.FromGraphEdges(
-                _env,
-                new Dictionary<int, int[]> { { 1, null }, { 2, null } },
-                new[] { ("1", new[] { Guid.NewGuid().ToString("B") }) }).BuildSolution();
-
-            var solutionFile = _env.CreateFile(
-                "solution.sln",
-                solutionContents)
-                .Path;
-
-            var exception = Should.Throw<InvalidProjectFileException>(
-                () =>
-                {
-                    new ProjectGraph(solutionFile);
-                });
-
-            exception.Message.ShouldContain("but a project with this GUID was not found in the .SLN file");
-        }
-
         private static bool IsSolutionItemReference(ProjectItemInstance edgeItem)
         {
             return edgeItem.ItemType == GraphBuilder.SolutionItemReference;
diff --git a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
index 063df0be739..13bb4275c65 100644
--- a/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
+++ b/src/Build.UnitTests/Graph/IsolateProjects_Tests.cs
@@ -7,7 +7,6 @@
 using System.Linq;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Shouldly;
@@ -338,8 +337,8 @@ public void UndeclaredReferenceBuildResultNotPresentInOutputCache()
             var deserializedOutputCacheRoot = CacheSerialization.DeserializeCaches(outputCaches[topoSortedProjectGraphNodes[1]]);
             deserializedOutputCacheDeclaredReference.exception.ShouldBeNull();
             deserializedOutputCacheRoot.exception.ShouldBeNull();
-            BuildResult[] declaredReferenceBuildResults = deserializedOutputCacheDeclaredReference.ResultsCache.GetEnumerator().ToArray();
-            BuildResult[] rootBuildResults = deserializedOutputCacheRoot.ResultsCache.GetEnumerator().ToArray();
+            BuildResult[] declaredReferenceBuildResults = deserializedOutputCacheDeclaredReference.ResultsCache.ToArray();
+            BuildResult[] rootBuildResults = deserializedOutputCacheRoot.ResultsCache.ToArray();
 
             // Both the root and declared reference projects should only have one build result.
             declaredReferenceBuildResults.Length.ShouldBe(1);
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index b1a0b664c80..f9dd9bf05d4 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -11,7 +11,6 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using Xunit;
@@ -356,13 +355,13 @@ public void OutputCacheShouldNotContainInformationFromInputCaches()
 
             deserializationInfo.exception.ShouldBeNull();
 
-            var buildResults = deserializationInfo.ResultsCache.GetEnumerator().ToArray();
+            var buildResults = deserializationInfo.ResultsCache.ToArray();
             buildResults.ShouldHaveSingleItem();
 
             var rootNodeBuildResult = buildResults.First();
             rootNodeBuildResult.ResultsByTarget["Build"].Items.Select(i => i.ItemSpec).ToArray().ShouldBe(expectedOutput[rootNode]);
 
-            var configEntries = deserializationInfo.ConfigCache.GetEnumerator().ToArray();
+            var configEntries = deserializationInfo.ConfigCache.ToArray();
             configEntries.ShouldHaveSingleItem();
 
             configEntries.First().ConfigurationId.ShouldBe(rootNodeBuildResult.ConfigurationId);
diff --git a/src/Build.UnitTests/Instance/HostServices_Tests.cs b/src/Build.UnitTests/Instance/HostServices_Tests.cs
index ed18f318540..e05239f9528 100644
--- a/src/Build.UnitTests/Instance/HostServices_Tests.cs
+++ b/src/Build.UnitTests/Instance/HostServices_Tests.cs
@@ -13,7 +13,6 @@
 using Microsoft.Build.UnitTests.BackEnd;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
index cb3ceade820..49fc0f9bfad 100644
--- a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 7699a66b623..af1e84b2397 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -2,9 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Collections.Generic;
-using System.IO;
 using System.Linq;
-using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
diff --git a/src/Build.UnitTests/InvalidProjectFileException_Tests.cs b/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
index 0987c3e9d6a..7a1d62aab19 100644
--- a/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
+++ b/src/Build.UnitTests/InvalidProjectFileException_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Exceptions;
 
 using Xunit;
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 7653366ce4c..854159dc86d 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -16,20 +16,22 @@
 
   <ItemGroup>
     <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
-    <PackageReference Include="FluentAssertions" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
+    <PackageReference Include="AwesomeAssertions" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="FakeItEasy" />
-    <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
     <PackageReference Include="Verify.Xunit" />
+    <PackageReference Include="Microsoft.VisualStudio.SolutionPersistence" />
     <PackageReference Include="NuGet.Frameworks">
       <PrivateAssets>all</PrivateAssets>
     </PackageReference>
 
     <PackageReference Include="Microsoft.VisualStudio.OpenTelemetry.ClientExtensions" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Microsoft.VisualStudio.OpenTelemetry.Collector" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
-    
+
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\MSBuild\MSBuild.csproj" />
@@ -38,7 +40,7 @@
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
     <ProjectReference Include="..\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj" />
-    
+
     <ProjectReference Include="..\Samples\TaskWithDependency\TaskWithDependency.csproj" Private="false" ReferenceOutputAssembly="false" OutputItemType="TaskWithDependencyResolvedProjectReferencePath">
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=$(LatestDotNetCoreForMSBuild)</SetTargetFramework>
@@ -49,7 +51,7 @@
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">TargetFramework=$(FullFrameworkTFM)</SetTargetFramework>
       <SetTargetFramework Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">TargetFramework=$(LatestDotNetCoreForMSBuild)</SetTargetFramework>
     </ProjectReference>
-    
+
     <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' " />
   </ItemGroup>
 
diff --git a/src/Build.UnitTests/NodeStatus_SizeChange_Tests.cs b/src/Build.UnitTests/NodeStatus_SizeChange_Tests.cs
index 458eb4edb27..bbe391ce360 100644
--- a/src/Build.UnitTests/NodeStatus_SizeChange_Tests.cs
+++ b/src/Build.UnitTests/NodeStatus_SizeChange_Tests.cs
@@ -2,15 +2,10 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.Globalization;
-using System.Linq;
-using System.Text;
 using System.Threading.Tasks;
 
 using Microsoft.Build.Logging;
-
-using VerifyTests;
 using VerifyXunit;
 using Xunit;
 
diff --git a/src/Build.UnitTests/NodeStatus_Transition_Tests.cs b/src/Build.UnitTests/NodeStatus_Transition_Tests.cs
index d811c2e4988..62cc3557215 100644
--- a/src/Build.UnitTests/NodeStatus_Transition_Tests.cs
+++ b/src/Build.UnitTests/NodeStatus_Transition_Tests.cs
@@ -2,16 +2,12 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
 using System.Text;
-using System.Text.RegularExpressions;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework.Logging;
 using Microsoft.Build.Logging;
 using Shouldly;
-using VerifyTests;
 using VerifyXunit;
 using Xunit;
 
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index 449bdf1401d..e5ec5d49edd 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -10,7 +10,6 @@
 using System.Text.RegularExpressions;
 using System.Threading;
 using System.Threading.Tasks;
-using Microsoft.Build.CommandLine;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.ProjectCache;
@@ -24,7 +23,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.Sdk;
 using Task = System.Threading.Tasks.Task;
 
 namespace Microsoft.Build.Engine.UnitTests.ProjectCache
diff --git a/src/Build.UnitTests/Scanner_Tests.cs b/src/Build.UnitTests/Scanner_Tests.cs
index b2b705d2c22..da75fd75436 100644
--- a/src/Build.UnitTests/Scanner_Tests.cs
+++ b/src/Build.UnitTests/Scanner_Tests.cs
@@ -4,9 +4,6 @@
 using System;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Exceptions;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
 
diff --git a/src/Build.UnitTests/StaticStopwatch.cs b/src/Build.UnitTests/StaticStopwatch.cs
index 63d1bf7bcbd..8846e440b20 100644
--- a/src/Build.UnitTests/StaticStopwatch.cs
+++ b/src/Build.UnitTests/StaticStopwatch.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Net.Http.Headers;
 using Microsoft.Build.Logging;
 
 namespace Microsoft.Build.CommandLine.UnitTests;
diff --git a/src/Build.UnitTests/Telemetry/OpenTelemetryActivities_Tests.cs b/src/Build.UnitTests/Telemetry/OpenTelemetryActivities_Tests.cs
index 5616f614530..7a567e79495 100644
--- a/src/Build.UnitTests/Telemetry/OpenTelemetryActivities_Tests.cs
+++ b/src/Build.UnitTests/Telemetry/OpenTelemetryActivities_Tests.cs
@@ -4,11 +4,9 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
-using System.Text;
-using Xunit;
-using Shouldly;
 using Microsoft.Build.Framework.Telemetry;
+using Shouldly;
+using Xunit;
 
 namespace Microsoft.Build.Engine.UnitTests.Telemetry
 {
@@ -18,7 +16,7 @@ public class ActivityExtensionsTests
         public void WithTag_ShouldSetUnhashedValue()
         {
             var activity = new Activity("TestActivity");
-            activity.Start(); 
+            activity.Start();
 
             var telemetryItem = new TelemetryItem(
                 Name: "TestItem",
@@ -121,7 +119,7 @@ public void WithStartTime_NullDateTime_ShouldNotSetStartTime()
     }
 
     /// <summary>
-    /// A simple mock for testing IActivityTelemetryDataHolder. 
+    /// A simple mock for testing IActivityTelemetryDataHolder.
     /// Returns two items: one hashed, one not hashed.
     /// </summary>
     internal sealed class MockTelemetryDataHolder : IActivityTelemetryDataHolder
diff --git a/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs b/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
index 4003cc2fbba..7a7b015f485 100644
--- a/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
+++ b/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
@@ -3,22 +3,14 @@
 
 using System;
 using System.Reflection;
-using Xunit;
-using Shouldly;
-using Xunit.Abstractions;
-using Microsoft.Build.UnitTests.Shared;
-using Microsoft.Build.UnitTests;
 using Microsoft.Build.Framework.Telemetry;
-using Microsoft.Build.Execution;
-using Microsoft.Build.Framework;
-using System.Collections.Generic;
-using System.Linq;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
 
 namespace Microsoft.Build.Engine.UnitTests.Telemetry
 {
-    /// <summary>
-    /// Ensures tests run serially so environment variables and the singleton do not interfere with parallel test runs.
-    /// </summary>
+    // Putting the tests to a collection ensures tests run serially by default, that's needed to isolate the manager singleton state and env vars in some telemetry tests.
     [Collection("OpenTelemetryManagerTests")]
     public class OpenTelemetryManagerTests : IDisposable
     {
diff --git a/src/Build.UnitTests/TerminalLogger_Tests.cs b/src/Build.UnitTests/TerminalLogger_Tests.cs
index 2c04241a604..f63f35e386f 100644
--- a/src/Build.UnitTests/TerminalLogger_Tests.cs
+++ b/src/Build.UnitTests/TerminalLogger_Tests.cs
@@ -6,13 +6,9 @@
 using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
-using System.Text;
-using System.Text.RegularExpressions;
 using System.Threading;
 using System.Threading.Tasks;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.CommandLine.UnitTests;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
 using Microsoft.Build.UnitTests.Shared;
diff --git a/src/Build.UnitTests/TestLoggingContext.cs b/src/Build.UnitTests/TestLoggingContext.cs
index 756f61b8284..cc532c44d08 100644
--- a/src/Build.UnitTests/TestLoggingContext.cs
+++ b/src/Build.UnitTests/TestLoggingContext.cs
@@ -1,11 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index db2d9eab3ad..5f05b945e94 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -527,5 +527,33 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_False()
                 logger.AssertLogContains("MSB4181");
             }
         }
+
+        /// <summary>
+        /// MSBuildWarningsAsMessages should allow comma separation.
+        /// </summary>
+        [Fact]
+        public void MSBuildWarningsAsMessagesWithCommaSeparation()
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                var content = """
+                <Project>
+                    <PropertyGroup>
+                       <MSBuildWarningsAsMessages>NAT011,NAT012</MSBuildWarningsAsMessages>
+                    </PropertyGroup>
+
+                    <Target Name='Build'>
+                        <Warning Code="NAT011" Text="You fail" />
+                        <Warning Code="NAT012" Text="Other Fail" />
+                    </Target>
+                </Project>
+                """;
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles(content);
+
+                MockLogger logger = proj.BuildProjectExpectSuccess();
+                logger.WarningCount.ShouldBe(0);
+                logger.ErrorCount.ShouldBe(0);
+            }
+        }
     }
 }
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 1c922ef9fdd..facf5c948e8 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2821,12 +2821,11 @@ private NodeConfiguration GetNodeConfiguration()
             {
                 // Get the remote loggers
                 ILoggingService loggingService = ((IBuildComponentHost)this).GetComponent<ILoggingService>(BuildComponentType.LoggingService);
-                var remoteLoggers = new List<LoggerDescription>(loggingService.LoggerDescriptions);
 
                 _nodeConfiguration = new NodeConfiguration(
                 -1, /* must be assigned by the NodeManager */
                 _buildParameters,
-                remoteLoggers.ToArray()
+                loggingService.LoggerDescriptions.ToArray()
 #if FEATURE_APPDOMAIN
                 , AppDomain.CurrentDomain.SetupInformation
 #endif
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 38eca66834b..1bfab1b0e52 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -10,8 +10,6 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Experimental;
-using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
diff --git a/src/Build/BackEnd/BuildManager/BuildRequestData.cs b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
index 11f54ffbade..ab64b422770 100644
--- a/src/Build/BackEnd/BuildManager/BuildRequestData.cs
+++ b/src/Build/BackEnd/BuildManager/BuildRequestData.cs
@@ -1,16 +1,9 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Collections.Immutable;
-using System.Linq;
-using System.Runtime.CompilerServices;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Execution
diff --git a/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs b/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs
index 719625f43d9..8195c79aa0e 100644
--- a/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs
+++ b/src/Build/BackEnd/BuildManager/BuildSubmissionBase.cs
@@ -2,11 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using System.Threading;
-using System.Threading.Tasks;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Execution
diff --git a/src/Build/BackEnd/BuildManager/CacheAggregator.cs b/src/Build/BackEnd/BuildManager/CacheAggregator.cs
index aca3b8ef9c7..694e9ef4af1 100644
--- a/src/Build/BackEnd/BuildManager/CacheAggregator.cs
+++ b/src/Build/BackEnd/BuildManager/CacheAggregator.cs
@@ -3,9 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -55,8 +55,8 @@ public CacheAggregation Aggregate()
 
         private void InsertCaches(IConfigCache configCache, IResultsCache resultsCache)
         {
-            var configs = configCache.GetEnumerator().ToArray();
-            var results = resultsCache.GetEnumerator().ToArray();
+            var configs = configCache.ToArray();
+            var results = resultsCache.ToArray();
 
             ErrorUtilities.VerifyThrow(configs.Length == results.Length, "Assuming 1-to-1 mapping between configs and results. Otherwise it means the caches are either not minimal or incomplete");
 
diff --git a/src/Build/BackEnd/BuildManager/GlobalPropertiesLookup.cs b/src/Build/BackEnd/BuildManager/GlobalPropertiesLookup.cs
index 1cf11aa2068..a440de531f9 100644
--- a/src/Build/BackEnd/BuildManager/GlobalPropertiesLookup.cs
+++ b/src/Build/BackEnd/BuildManager/GlobalPropertiesLookup.cs
@@ -1,13 +1,10 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Collections;
 
 namespace Microsoft.Build.Execution
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index 65a7b72a4dd..0219982e43e 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -6,12 +6,14 @@
 using System.Collections.Concurrent;
 using System.IO;
 using System.Threading;
-using Microsoft.Build.Internal;
-using Microsoft.Build.Shared;
-#if !FEATURE_APM
+
+#if NET
 using System.Threading.Tasks;
 #endif
 
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+
 namespace Microsoft.Build.BackEnd.Client
 {
     internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable
@@ -195,7 +197,7 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
 #if FEATURE_APM
                 IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);
 #else
-                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);
+                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length).AsTask();
 #endif
 
                 bool continueReading = true;
@@ -294,7 +296,7 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
 #if FEATURE_APM
                                     result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);
 #else
-                                    readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);
+                                    readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length).AsTask();
 #endif
                                 }
                             }
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index c48b89ef797..5e255466d52 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -5,7 +5,9 @@
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+#if FEATURE_REPORTFILEACCESSES
 using Microsoft.Build.FileAccesses;
+#endif
 using Microsoft.Build.Shared;
 using Microsoft.Build.TelemetryInfra;
 
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index e3b0a6d069e..d892518e9ea 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -3,15 +3,14 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
 using System.Threading;
 using System.Threading.Tasks.Dataflow;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
@@ -1433,7 +1432,7 @@ private void TraceEngine(string format, params object[] stuff)
                     using (StreamWriter file = FileUtilities.OpenWrite(string.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, @"EngineTrace_{0}.txt"), EnvironmentUtilities.CurrentProcessId), append: true))
                     {
                         string message = String.Format(CultureInfo.CurrentCulture, format, stuff);
-                        file.WriteLine("{0}({1})-{2}: {3}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, DateTime.UtcNow.Ticks, message);
+                        file.WriteLine("{0}({1})-{2}: {3}", Thread.CurrentThread.Name, Environment.CurrentManagedThreadId, DateTime.UtcNow.Ticks, message);
                         file.Flush();
                     }
                 }
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 28466f039ca..f3e860cb6c7 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -6,8 +6,8 @@
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Shared;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 
 #nullable disable
@@ -511,12 +511,13 @@ private void WaitForResult(BuildRequest newRequest, bool addToIssueList)
                     ErrorUtilities.VerifyThrow(addToIssueList, "Requests with unresolved configurations should always be added to the issue list.");
                     _unresolvedConfigurations ??= new Dictionary<int, List<BuildRequest>>();
 
-                    if (!_unresolvedConfigurations.ContainsKey(newRequest.ConfigurationId))
+                    if (!_unresolvedConfigurations.TryGetValue(newRequest.ConfigurationId, out List<BuildRequest> value))
                     {
-                        _unresolvedConfigurations.Add(newRequest.ConfigurationId, new List<BuildRequest>());
+                        value = new List<BuildRequest>();
+                        _unresolvedConfigurations.Add(newRequest.ConfigurationId, value);
                     }
 
-                    _unresolvedConfigurations[newRequest.ConfigurationId].Add(newRequest);
+                    value.Add(newRequest);
                 }
 
                 if (addToIssueList)
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs b/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
index 03e123f9141..012ae7af269 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCacheResponse.cs
@@ -1,9 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
-
 using BuildResult = Microsoft.Build.Execution.BuildResult;
 
 #nullable disable
diff --git a/src/Build/BackEnd/Components/Communications/CurrentHost.cs b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
index a9c8336b837..6e08f93e955 100644
--- a/src/Build/BackEnd/Components/Communications/CurrentHost.cs
+++ b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 #if RUNTIME_TYPE_NETCORE
-using System.Diagnostics;
 using System.IO;
 using Microsoft.Build.Shared;
 #endif
diff --git a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
index 3defd87986c..7df245c49a5 100644
--- a/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/DetouredNodeLauncher.cs
@@ -6,11 +6,9 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
 using BuildXL.Processes;
 using BuildXL.Utilities.Core;
 using Microsoft.Build.Exceptions;
-using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index 6fdad8b8128..2c90dda389c 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -29,7 +29,7 @@ internal class NodeEndpointInProc : INodeEndpoint
         /// <summary>
         /// An object for the two inproc endpoints to synchronize on.
         /// </summary>
-        private static Object s_locker = new Object();
+        private static readonly Object s_locker = new Object();
 
         /// <summary>
         /// The current communication status of the node.
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 15c815fb9cf..45334ce6752 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -4,13 +4,14 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Globalization;
 using System.Threading;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
 #if FEATURE_THREAD_CULTURE
 using BuildParameters = Microsoft.Build.Execution.BuildParameters;
+#else
+using System.Globalization;
 #endif
 using NodeEngineShutdownReason = Microsoft.Build.Execution.NodeEngineShutdownReason;
 
@@ -382,7 +383,7 @@ private bool InstantiateNode(INodePacketFactory factory)
                 InProcNodeThreadProc();
             });
 #endif
-            _inProcNodeThread.Name = String.Format(CultureInfo.CurrentCulture, "In-proc Node ({0})", _componentHost.Name);
+            _inProcNodeThread.Name = $"In-proc Node ({_componentHost.Name})";
             _inProcNodeThread.IsBackground = true;
 #if FEATURE_THREAD_CULTURE
             _inProcNodeThread.CurrentCulture = _componentHost.BuildParameters.Culture;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index c506179bcd6..4e6a7b77970 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -3,27 +3,25 @@
 
 using System;
 using System.Buffers.Binary;
-using System.Collections.Generic;
 using System.Collections.Concurrent;
+using System.Collections.Generic;
+using System.Diagnostics;
 using System.Globalization;
 using System.IO;
 using System.IO.Pipes;
-using System.Diagnostics;
 using System.Linq;
 using System.Threading;
 using System.Threading.Tasks;
-#if FEATURE_PIPE_SECURITY
-using System.Security.Principal;
-#endif
+using Microsoft.Build.BackEnd.Logging;
 
-#if FEATURE_APM
+#if NETFRAMEWORK
 using Microsoft.Build.Eventing;
+using System.Security.Principal;
 #endif
+
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Task = System.Threading.Tasks.Task;
-using Microsoft.Build.Framework;
-using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -416,7 +414,11 @@ void CreateNodeContext(int nodeId, Process nodeToReuse, Stream nodeStream)
         /// </summary>
         private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessId)
         {
-            return hostHandshake.ToString() + "|" + nodeProcessId.ToString(CultureInfo.InvariantCulture);
+#if NET
+            return string.Create(CultureInfo.InvariantCulture, $"{hostHandshake}|{nodeProcessId}");
+#else
+            return $"{hostHandshake}|{nodeProcessId.ToString(CultureInfo.InvariantCulture)}";
+#endif
         }
 
 #if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
@@ -833,8 +835,17 @@ public async Task WaitForExitAsync(ILoggingService loggingService)
                 {
                     // Wait up to 100ms until all remaining packets are sent.
                     // We don't need to wait long, just long enough for the Task to start running on the ThreadPool.
-                    await Task.WhenAny(_packetWriteDrainTask, Task.Delay(100));
+#if NET
+                    await _packetWriteDrainTask.WaitAsync(TimeSpan.FromMilliseconds(100)).ConfigureAwait(ConfigureAwaitOptions.SuppressThrowing);
+#else
+                    using (var cts = new CancellationTokenSource(100))
+                    {
+                        await Task.WhenAny(_packetWriteDrainTask, Task.Delay(100, cts.Token));
+                        cts.Cancel();
+                    }
+#endif
                 }
+
                 if (_exitPacketState == ExitPacketState.ExitPacketSent)
                 {
                     CommunicationsUtilities.Trace("Waiting for node with pid = {0} to exit", _process.Id);
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index 912c37ee0ca..ab2b1bb2da0 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -20,7 +20,7 @@ namespace Microsoft.Build.BackEnd
     /// </summary>
     internal static class TranslatorExtensions
     {
-        private static Lazy<ConcurrentDictionary<Type, ConstructorInfo>> parameterlessConstructorCache = new Lazy<ConcurrentDictionary<Type, ConstructorInfo>>(() => new ConcurrentDictionary<Type, ConstructorInfo>());
+        private static readonly Lazy<ConcurrentDictionary<Type, ConstructorInfo>> parameterlessConstructorCache = new Lazy<ConcurrentDictionary<Type, ConstructorInfo>>(() => new ConcurrentDictionary<Type, ConstructorInfo>());
 
         /// <summary>
         /// Translates a PropertyDictionary of ProjectPropertyInstances.
diff --git a/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
index de28c100d1d..5936bf90ac5 100644
--- a/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
+++ b/src/Build/BackEnd/Components/FileAccesses/FileAccessManager.cs
@@ -22,7 +22,7 @@ private record Handlers(Action<BuildRequest, FileAccessData> FileAccessHander, A
         // is used to mark when the file accesses should be considered complete. Only after both this special file access is seen
         // and the build result is reported can plugins be notified about project completion.
         // NOTE! This is currently Windows-specific and will need to change once this feature is opened up to more scenarios.
-        private static readonly string FileAccessCompletionPrefix = BuildParameters.StartupDirectory[0] + @":\{MSBuildFileAccessCompletion}\";
+        private static readonly string FileAccessCompletionPrefix = $@"{BuildParameters.StartupDirectory[0]}:\{{MSBuildFileAccessCompletion}}\";
 
         private IScheduler? _scheduler;
         private IConfigCache? _configCache;
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 995370003eb..bda1135b030 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index c08622d49eb..1e4121594e2 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -94,7 +94,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler
         /// We use a BindingFlags.Public flag here because the getter is public, so although the setter is internal,
         /// it is only discoverable with Reflection using the Public flag (go figure!)
         /// </remarks>
-        private static Lazy<PropertyInfo> s_projectStartedEventArgsGlobalProperties = new Lazy<PropertyInfo>(() => typeof(ProjectStartedEventArgs).GetProperty("GlobalProperties", BindingFlags.Public | BindingFlags.Instance), LazyThreadSafetyMode.PublicationOnly);
+        private static readonly Lazy<PropertyInfo> s_projectStartedEventArgsGlobalProperties = new Lazy<PropertyInfo>(() => typeof(ProjectStartedEventArgs).GetProperty("GlobalProperties", BindingFlags.Public | BindingFlags.Instance), LazyThreadSafetyMode.PublicationOnly);
 
         /// <summary>
         /// A cached reflection accessor for an internal member.
@@ -103,7 +103,7 @@ internal partial class LoggingService : ILoggingService, INodePacketHandler
         /// We use a BindingFlags.Public flag here because the getter is public, so although the setter is internal,
         /// it is only discoverable with Reflection using the Public flag (go figure!)
         /// </remarks>
-        private static Lazy<PropertyInfo> s_projectStartedEventArgsToolsVersion = new Lazy<PropertyInfo>(() => typeof(ProjectStartedEventArgs).GetProperty("ToolsVersion", BindingFlags.Public | BindingFlags.Instance), LazyThreadSafetyMode.PublicationOnly);
+        private static readonly Lazy<PropertyInfo> s_projectStartedEventArgsToolsVersion = new Lazy<PropertyInfo>(() => typeof(ProjectStartedEventArgs).GetProperty("ToolsVersion", BindingFlags.Public | BindingFlags.Instance), LazyThreadSafetyMode.PublicationOnly);
 
         #region Data
 
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 22687557135..2bda5a2e93f 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -3,7 +3,6 @@
 
 using System.Collections;
 using System.Collections.Generic;
-using System.Configuration;
 using System.Linq;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
diff --git a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
index d68f04e2bfa..d79a052c5d9 100644
--- a/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/TargetLoggingContext.cs
@@ -6,7 +6,6 @@
 using System.Collections.Generic;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 #nullable disable
diff --git a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
index 5f3ff599c99..6a5eb2daaa9 100644
--- a/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/CacheContext.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Graph;
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index bd1cb0fd8d7..e89f7d9fed8 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -16,7 +16,9 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
+#if FEATURE_REPORTFILEACCESSES
 using Microsoft.Build.FileAccesses;
+#endif
 using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
@@ -32,7 +34,7 @@ internal sealed class ProjectCacheService : IAsyncDisposable
     {
         private static readonly ParallelOptions s_parallelOptions = new() { MaxDegreeOfParallelism = Environment.ProcessorCount };
 
-        private static HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { "TargetFramework", "Configuration", "Platform", "TargetPlatform", "OutputType" };
+        private static readonly HashSet<string> s_projectSpecificPropertyNames = new(StringComparer.OrdinalIgnoreCase) { "TargetFramework", "Configuration", "Platform", "TargetPlatform", "OutputType" };
 
         private readonly BuildManager _buildManager;
         private readonly IBuildComponentHost _componentHost;
@@ -115,8 +117,7 @@ public void InitializePluginsForGraph(
                             foreach (ProjectCacheDescriptor projectCacheDescriptor in GetProjectCacheDescriptors(node.ProjectInstance))
                             {
                                 // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, requestedTargets, cancellationToken)
-                                    .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                                _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph, buildRequestConfiguration: null, requestedTargets, cancellationToken);
                             }
                         });
                 },
@@ -149,8 +150,7 @@ public void InitializePluginsForVsScenario(
                         projectCacheDescriptor =>
                         {
                             // Intentionally fire-and-forget to asynchronously initialize the plugin. Any exceptions will bubble up later when querying.
-                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, requestedTargets, cancellationToken)
-                                .ContinueWith(t => { }, TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnFaulted);
+                            _ = GetProjectCachePluginAsync(projectCacheDescriptor, projectGraph: null, buildRequestConfiguration, requestedTargets, cancellationToken);
                         });
                 },
                 cancellationToken);
@@ -449,7 +449,7 @@ public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancel
                 },
                 cancellationToken);
 
-            async Task<(CacheResult Result, int ProjectContextId)> ProcessCacheRequestAsync()
+            async ValueTask<(CacheResult Result, int ProjectContextId)> ProcessCacheRequestAsync()
             {
                 EvaluateProjectIfNecessary(cacheRequest.Submission, cacheRequest.Configuration);
 
@@ -499,7 +499,7 @@ void EvaluateProjectIfNecessary(BuildSubmission submission, BuildRequestConfigur
             }
         }
 
-        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildRequestConfiguration buildRequestConfiguration, BuildEventContext buildEventContext, CancellationToken cancellationToken)
+        private async ValueTask<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildRequestConfiguration buildRequestConfiguration, BuildEventContext buildEventContext, CancellationToken cancellationToken)
         {
             ErrorUtilities.VerifyThrowInternalNull(buildRequest.ProjectInstance, nameof(buildRequest.ProjectInstance));
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 423679a1f6e..c33c0ab6563 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -186,7 +186,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     if (// If multiple buckets were expanded - we do not want to repeat same error for same metadatum on a same line
                         bucket.BucketSequenceNumber == 0 &&
                         // Referring to unqualified metadata of other item (transform) is fine.
-                        child.Include.IndexOf("@(", StringComparison.Ordinal) == -1)
+                        !child.Include.Contains("@("))
                     {
                         expanderOptions |= ExpanderOptions.LogOnItemMetadataSelfReference;
                     }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
index deae62102f0..23f3d96c1f6 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupLoggingHelper.cs
@@ -10,7 +10,6 @@
 #endif
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index 73f84dd94a0..ac3e5aab535 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
 using System.IO;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
@@ -259,7 +258,7 @@ public async Task<bool> ExecuteInternal()
                 undefinePropertiesArray = RemoveProperties.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries);
                 foreach (string property in undefinePropertiesArray)
                 {
-                    Log.LogMessageFromText(String.Format(CultureInfo.InvariantCulture, "  {0}", property), MessageImportance.Low);
+                    Log.LogMessageFromText($"  {property}", MessageImportance.Low);
                 }
             }
 
@@ -296,10 +295,7 @@ public async Task<bool> ExecuteInternal()
             if (BuildInParallel)
             {
                 skipProjects = new bool[Projects.Length];
-                for (int i = 0; i < skipProjects.Length; i++)
-                {
-                    skipProjects[i] = true;
-                }
+                skipProjects.AsSpan().Fill(true);
             }
             else
             {
@@ -594,7 +590,7 @@ internal static async Task<bool> ExecuteTargets(
                             foreach (string property in propertiesToUndefine)
                             {
                                 undefinePropertiesPerProject[i].Add(property);
-                                log.LogMessageFromText(String.Format(CultureInfo.InvariantCulture, "  {0}", property), MessageImportance.Low);
+                                log.LogMessageFromText($"  {property}", MessageImportance.Low);
                             }
                         }
                     }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
index 950b2848a68..7f5ebcbf243 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Collections.ObjectModel;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index 6a882eb87f0..596555819ca 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -5,7 +5,6 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
-using System.Threading;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
@@ -1373,7 +1372,7 @@ internal Scope(Lookup lookup, string description, IItemDictionary<ProjectItemIns
                 _modifies = null;
                 _properties = properties;
                 _propertySets = null;
-                _threadIdThatEnteredScope = Thread.CurrentThread.ManagedThreadId;
+                _threadIdThatEnteredScope = Environment.CurrentManagedThreadId;
                 _truncateLookupsAtThisScope = false;
             }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index caf38096dba..4be12ea2854 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Globalization;
 using System.IO;
 using System.Linq;
@@ -242,7 +241,7 @@ public void ContinueRequestWithResources(ResourceResponse response)
         {
             ErrorUtilities.VerifyThrow(HasActiveBuildRequest, "Request not building");
             ErrorUtilities.VerifyThrow(!_terminateEvent.WaitOne(0), "Request already terminated");
-            ErrorUtilities.VerifyThrow(_pendingResourceRequests.Any(), "No pending resource requests");
+            ErrorUtilities.VerifyThrow(!_pendingResourceRequests.IsEmpty, "No pending resource requests");
             VerifyEntryInActiveOrWaitingState();
 
             _pendingResourceRequests.Dequeue()(response);
@@ -1032,22 +1031,9 @@ private BuildResult[] GetResultsForContinuation(FullyQualifiedBuildRequest[] req
 
             // The build results will have node request IDs in the same order as the requests were issued,
             // which is in the array order above.
-            List<BuildResult> resultsList = new List<BuildResult>(results.Values);
-            resultsList.Sort(delegate (BuildResult left, BuildResult right)
-            {
-                if (left.NodeRequestId < right.NodeRequestId)
-                {
-                    return -1;
-                }
-                else if (left.NodeRequestId == right.NodeRequestId)
-                {
-                    return 0;
-                }
-
-                return 1;
-            });
-
-            return resultsList.ToArray();
+            BuildResult[] resultsArray = results.Values.ToArray();
+            Array.Sort(resultsArray, (left, right) => left.NodeRequestId.CompareTo(right.NodeRequestId));
+            return resultsArray;
         }
 
         /// <summary>
@@ -1520,7 +1506,9 @@ private static ISet<string> ParseWarningCodes(string warnings)
                 return null;
             }
 
-            return new HashSet<string>(ExpressionShredder.SplitSemiColonSeparatedList(warnings), StringComparer.OrdinalIgnoreCase);
+            return new HashSet<string>(ExpressionShredder.SplitSemiColonSeparatedList(warnings)
+            .SelectMany(w => w.Split([','], StringSplitOptions.RemoveEmptyEntries))
+            .Select(w => w.Trim()), StringComparer.OrdinalIgnoreCase);
         }
 
         private sealed class DedicatedThreadsTaskScheduler : TaskScheduler
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
index aab4fb6d344..65b6903876a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetBuilder.cs
@@ -412,7 +412,7 @@ private async Task ProcessTargetStack(ITaskBuilder taskBuilder)
                 (
                 !_cancellationToken.IsCancellationRequested &&
                 !stopProcessingStack &&
-                _targetsToBuild.Any())
+                !_targetsToBuild.IsEmpty)
             {
                 TargetEntry currentTargetEntry = _targetsToBuild.Peek();
                 switch (currentTargetEntry.State)
@@ -621,7 +621,7 @@ private void PopDependencyTargetsOnTargetFailure(TargetEntry topEntry, TargetRes
                 // Pop down to our parent, since any other dependencies our parent had should no longer
                 // execute.  If we encounter an error target on the way down, also stop since the failure
                 // of one error target in a set declared in OnError should not cause the others to stop running.
-                while ((_targetsToBuild.Any()) && (_targetsToBuild.Peek() != topEntry.ParentEntry) && !_targetsToBuild.Peek().ErrorTarget)
+                while ((!_targetsToBuild.IsEmpty) && (_targetsToBuild.Peek() != topEntry.ParentEntry) && !_targetsToBuild.Peek().ErrorTarget)
                 {
                     TargetEntry entry = _targetsToBuild.Pop();
                     entry.LeaveLegacyCallTargetScopes();
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index c85b4f41f54..30179f2e7a9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -810,7 +810,7 @@ internal void LeaveLegacyCallTargetScopes()
         /// <returns>
         /// The result of the tasks, based on the last task which ran.
         /// </returns>
-        private async Task<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder, TargetLoggingContext targetLoggingContext, TaskExecutionMode mode, Lookup lookupForInference, Lookup lookupForExecution)
+        private async ValueTask<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder, TargetLoggingContext targetLoggingContext, TaskExecutionMode mode, Lookup lookupForInference, Lookup lookupForExecution)
         {
             WorkUnitResultCode aggregatedTaskResult = WorkUnitResultCode.Success;
             WorkUnitActionCode finalActionCode = WorkUnitActionCode.Continue;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index a75c73a91ae..58e250f6c97 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
@@ -838,15 +839,14 @@ private void SeparateItemVectorsFromDiscreteItems(
                         }
 
                         // Do we already have a partition for this?
-                        if (!itemVectorCollection.ContainsKey(itemVectorType))
+                        if (!itemVectorCollection.TryGetValue(itemVectorType, out ItemVectorPartition itemVectorPartition))
                         {
                             // Nope, create one.
-                            itemVectorCollection[itemVectorType] = new ItemVectorPartition(MSBuildNameIgnoreCaseComparer.Default);
+                            itemVectorPartition = new ItemVectorPartition(MSBuildNameIgnoreCaseComparer.Default);
+                            itemVectorCollection[itemVectorType] = itemVectorPartition;
                         }
 
-                        ItemVectorPartition itemVectorPartition = itemVectorCollection[itemVectorType];
-
-                        ErrorUtilities.VerifyThrow(!itemVectorCollection[itemVectorType].ContainsKey(item), "ItemVectorPartition already contains a vector for items with the expression '{0}'", item);
+                        ErrorUtilities.VerifyThrow(!itemVectorPartition.ContainsKey(item), "ItemVectorPartition already contains a vector for items with the expression '{0}'", item);
                         itemVectorPartition[item] = itemVectorContents;
 
                         ErrorUtilities.VerifyThrow((itemVectorTransforms == null) || (itemVectorCollection.Equals(itemVectorTransforms)) || (itemVectorPartition.Count == 1),
@@ -1129,8 +1129,8 @@ private bool IsOutOfDate(string input, string output, string inputItemName, stri
         {
             input = EscapingUtilities.UnescapeAll(FileUtilities.FixFilePath(input));
             output = EscapingUtilities.UnescapeAll(FileUtilities.FixFilePath(output));
-            ProjectErrorUtilities.VerifyThrowInvalidProject(input.IndexOfAny(Path.GetInvalidPathChars()) == -1, _project.ProjectFileLocation, "IllegalCharactersInFileOrDirectory", input, inputItemName);
-            ProjectErrorUtilities.VerifyThrowInvalidProject(output.IndexOfAny(Path.GetInvalidPathChars()) == -1, _project.ProjectFileLocation, "IllegalCharactersInFileOrDirectory", output, outputItemName);
+            ProjectErrorUtilities.VerifyThrowInvalidProject(input.AsSpan().IndexOfAny(MSBuildConstants.InvalidPathChars) < 0, _project.ProjectFileLocation, "IllegalCharactersInFileOrDirectory", input, inputItemName);
+            ProjectErrorUtilities.VerifyThrowInvalidProject(output.AsSpan().IndexOfAny(MSBuildConstants.InvalidPathChars) < 0, _project.ProjectFileLocation, "IllegalCharactersInFileOrDirectory", output, outputItemName);
             bool outOfDate = (CompareLastWriteTimes(input, output, out bool inputDoesNotExist, out bool outputDoesNotExist) == 1) || inputDoesNotExist;
 
             // Only if we are not logging just critical events should we be gathering full details
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 3a406115fce..36b4af7301f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -291,7 +291,7 @@ private List<string> CreateListOfParameterValues()
         /// Called to execute a task within a target. This method instantiates the task, sets its parameters, and executes it.
         /// </summary>
         /// <returns>true, if successful</returns>
-        private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lookup)
+        private async ValueTask<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lookup)
         {
             ErrorUtilities.VerifyThrowArgumentNull(lookup);
 
@@ -366,7 +366,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
         /// Execute a single bucket
         /// </summary>
         /// <returns>true if execution succeeded</returns>
-        private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask, Dictionary<string, string> lookupHash)
+        private async ValueTask<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask, Dictionary<string, string> lookupHash)
         {
             // On Intrinsic tasks, we do not allow batchable params, therefore metadata is excluded.
             ParserOptions parserOptions = (_taskNode == null) ? ParserOptions.AllowPropertiesAndItemLists : ParserOptions.AllowAll;
@@ -738,7 +738,7 @@ private void UpdateContinueOnError(ItemBucket bucket, TaskHost taskHost)
         /// <param name="bucket">The batching bucket</param>
         /// <param name="howToExecuteTask">The task execution mode</param>
         /// <returns>The result of running the task.</returns>
-        private async Task<WorkUnitResult> ExecuteInstantiatedTask(TaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask)
+        private async ValueTask<WorkUnitResult> ExecuteInstantiatedTask(TaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask)
         {
             UpdateContinueOnError(bucket, taskHost);
 
@@ -859,7 +859,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(TaskExecutionHost tas
                     }
                     else if (type == typeof(ThreadAbortException))
                     {
-#if !NET6_0_OR_GREATER && !NET6_0 // This is redundant but works around https://github.com/dotnet/sdk/issues/20700
+#if !NET
                         Thread.ResetAbort();
 #endif
                         _continueOnError = ContinueOnError.ErrorAndStop;
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 45414d7cf5c..a262028f9f9 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -11,19 +11,20 @@
 #endif
 using System.Diagnostics;
 using System.Reflection;
-using System.Threading;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
-using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Shared;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskLoggingContext = Microsoft.Build.BackEnd.Logging.TaskLoggingContext;
+#if FEATURE_REPORTFILEACCESSES
+using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.FileAccesses;
+#endif
 
 #nullable disable
 
@@ -42,7 +43,7 @@ internal class TaskHost :
         /// <summary>
         /// Help diagnose tasks that log after they return.
         /// </summary>
-        private static bool s_breakOnLogAfterTaskReturns = Environment.GetEnvironmentVariable("MSBUILDBREAKONLOGAFTERTASKRETURNS") == "1";
+        private static readonly bool s_breakOnLogAfterTaskReturns = Environment.GetEnvironmentVariable("MSBUILDBREAKONLOGAFTERTASKRETURNS") == "1";
 
         /// <summary>
         /// The build component host
@@ -357,7 +358,7 @@ public void Yield()
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
                 ErrorUtilities.VerifyThrow(_yieldThreadId == -1, "Cannot call Yield() while yielding.");
-                _yieldThreadId = Thread.CurrentThread.ManagedThreadId;
+                _yieldThreadId = Environment.CurrentManagedThreadId;
                 MSBuildEventSource.Log.ExecuteTaskYieldStart(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);
                 builderCallback.Yield();
             }
@@ -386,7 +387,7 @@ public void Reacquire()
             {
                 IRequestBuilderCallback builderCallback = _requestEntry.Builder as IRequestBuilderCallback;
                 ErrorUtilities.VerifyThrow(_yieldThreadId != -1, "Cannot call Reacquire() before Yield().");
-                ErrorUtilities.VerifyThrow(_yieldThreadId == Thread.CurrentThread.ManagedThreadId, "Cannot call Reacquire() on thread {0} when Yield() was called on thread {1}", Thread.CurrentThread.ManagedThreadId, _yieldThreadId);
+                ErrorUtilities.VerifyThrow(_yieldThreadId == Environment.CurrentManagedThreadId, "Cannot call Reacquire() on thread {0} when Yield() was called on thread {1}", Environment.CurrentManagedThreadId, _yieldThreadId);
                 MSBuildEventSource.Log.ExecuteTaskYieldStop(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);
                 MSBuildEventSource.Log.ExecuteTaskReacquireStart(_taskLoggingContext.TaskName, _taskLoggingContext.BuildEventContext.TaskId);
                 builderCallback.Reacquire();
diff --git a/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs b/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
index bc5e8f86256..a7b6ddd743e 100644
--- a/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
+++ b/src/Build/BackEnd/Components/Scheduler/ScheduleResponse.cs
@@ -1,8 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Globalization;
 using Microsoft.Build.Execution;
 
 #nullable disable
@@ -237,26 +235,26 @@ public override string ToString()
             {
                 case ScheduleActionType.ReportResults:
                 case ScheduleActionType.ResumeExecution:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Node: {1} Request: {2}", Action, NodeId, Unblocker.BlockedRequestId);
+                    return $"Act: {Action} Node: {NodeId} Request: {Unblocker.BlockedRequestId}";
 
                 case ScheduleActionType.Schedule:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Node: {1} Request: {2} Parent {3}", Action, NodeId, BuildRequest.GlobalRequestId, BuildRequest.ParentGlobalRequestId);
+                    return $"Act: {Action} Node: {NodeId} Request: {BuildRequest.GlobalRequestId} Parent {BuildRequest.ParentGlobalRequestId}";
 
                 case ScheduleActionType.ScheduleWithConfiguration:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Node: {1} Request: {2} Parent {3} Configuration: {4}", Action, NodeId, BuildRequest.GlobalRequestId, BuildRequest.ParentGlobalRequestId, BuildRequest.ConfigurationId);
+                    return $"Act: {Action} Node: {NodeId} Request: {BuildRequest.GlobalRequestId} Parent {BuildRequest.ParentGlobalRequestId} Configuration: {BuildRequest.ConfigurationId}";
 
                 case ScheduleActionType.CircularDependency:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Node: {1} Request: {2} Parent {3} Configuration: {4}", Action, NodeId, BuildRequest.GlobalRequestId, BuildRequest.ParentGlobalRequestId, BuildRequest.ConfigurationId);
+                    return $"Act: {Action} Node: {NodeId} Request: {BuildRequest.GlobalRequestId} Parent {BuildRequest.ParentGlobalRequestId} Configuration: {BuildRequest.ConfigurationId}";
 
                 case ScheduleActionType.SubmissionComplete:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Submission: {1}", Action, BuildResult.SubmissionId);
+                    return $"Act: {Action} Submission: {BuildResult.SubmissionId}";
 
                 case ScheduleActionType.CreateNode:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0} Count: {1}", Action, NumberOfNodesToCreate);
+                    return $"Act: {Action} Count: {NumberOfNodesToCreate}";
 
                 case ScheduleActionType.NoAction:
                 default:
-                    return String.Format(CultureInfo.CurrentCulture, "Act: {0}", Action);
+                    return $"Act: {Action}";
             }
         }
     }
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 0e8b74863be..e0390e978f0 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Globalization;
 using System.IO;
 using System.Linq;
@@ -2431,7 +2430,7 @@ private void WriteNodeUtilizationGraphLine(ILoggingService loggingService, Build
 
             bool haveNonIdleNode = false;
             StringBuilder stringBuilder = new StringBuilder(64);
-            stringBuilder.AppendFormat("{0}:   ", previousEventTime.Ticks);
+            stringBuilder.Append(previousEventTime.Ticks).Append(":   ");
             for (int i = 0; i < currentWork.Length; i++)
             {
                 if (currentWork[i] == invalidWorkId)
@@ -2567,7 +2566,7 @@ private void TraceScheduler(string format, params object[] stuff)
                     FileUtilities.EnsureDirectoryExists(_debugDumpPath);
 
                     using StreamWriter file = FileUtilities.OpenWrite(string.Format(CultureInfo.CurrentCulture, Path.Combine(_debugDumpPath, "SchedulerTrace_{0}.txt"), EnvironmentUtilities.CurrentProcessId), append: true);
-                    file.Write("{0}({1})-{2}: ", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, _schedulingData.EventTime.Ticks);
+                    file.Write("{0}({1})-{2}: ", Thread.CurrentThread.Name, Environment.CurrentManagedThreadId, _schedulingData.EventTime.Ticks);
                     file.WriteLine(format, stuff);
                     file.Flush();
                 }
@@ -2814,7 +2813,7 @@ private void DumpRequestSpec(StreamWriter file, SchedulableRequest request, int
                 request.State,
                 buildRequest.ConfigurationId,
                 _configCache[buildRequest.ConfigurationId].ProjectFullPath,
-                string.Join(", ", buildRequest.Targets.ToArray()));
+                string.Join(", ", buildRequest.Targets));
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index c15b5a25063..19a63a6eb5f 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -363,9 +363,8 @@ private void DetermineExpensiveConfigs()
         /// </summary>
         private void ReadHierarchy(StreamReader file)
         {
-            while (!file.EndOfStream)
+            while (file.ReadLine() is string line)
             {
-                string line = file.ReadLine();
                 if (line.Length == 0)
                 {
                     return;
@@ -394,9 +393,8 @@ private void ReadHierarchy(StreamReader file)
         /// </summary>
         private void ReadTimes(StreamReader file)
         {
-            while (!file.EndOfStream)
+            while (file.ReadLine() is string line)
             {
-                string line = file.ReadLine();
                 if (line.Length == 0)
                 {
                     return;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index 2d5341cf215..c9876d8a9bc 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -7,7 +7,6 @@
 using System.Linq;
 using System.Reflection;
 using System.Xml;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index a9ea6b37548..1d6ec92f64c 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -136,7 +136,7 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
             //
             // Overall, while Sdk resolvers look like a general plug-in system, there are good reasons why some of the logic is hard-coded.
             // It's not really meant to be modified outside of very special/internal scenarios.
-#if NETCOREAPP
+#if NET
             if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
             {
                 if (TryResolveSdkUsingSpecifiedResolvers(
@@ -479,7 +479,7 @@ private void RegisterResolversManifests(ElementLocation location)
                 _manifestToResolvers = new Dictionary<SdkResolverManifest, IReadOnlyList<SdkResolver>>();
 
                 SdkResolverManifest sdkDefaultResolversManifest = null;
-#if NETCOREAPP
+#if NET
                 if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10))
 #endif
                 {
diff --git a/src/Build/BackEnd/Node/NodeConfiguration.cs b/src/Build/BackEnd/Node/NodeConfiguration.cs
index 99ab53e2e70..cd57d5b74df 100644
--- a/src/Build/BackEnd/Node/NodeConfiguration.cs
+++ b/src/Build/BackEnd/Node/NodeConfiguration.cs
@@ -7,7 +7,6 @@
 using System.Diagnostics;
 
 using Microsoft.Build.Execution;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
 #nullable disable
 
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index f092add506b..0adad41674c 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -14,10 +14,12 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+#if FEATURE_REPORTFILEACCESSES
+using Microsoft.Build.FileAccesses;
+#endif
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 
 #nullable disable
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index bda79d588cd..aefae5aceab 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Concurrent;
 using System.IO;
-using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
 using System.Text;
 using System.Threading;
 using System.Threading.Tasks;
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index f90f99d14d3..d2c22d49f76 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -869,7 +869,7 @@ public override int GetHashCode()
         /// <returns>String representation of the object</returns>
         public override string ToString()
         {
-            return String.Format(CultureInfo.CurrentCulture, "{0} {1} {2} {3}", _configId, _projectFullPath, _toolsVersion, _globalProperties);
+            return $"{_configId} {_projectFullPath} {_toolsVersion} {_globalProperties}";
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index f433ffc25ad..1ef8455bdf1 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -5,12 +5,12 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Diagnostics.CodeAnalysis;
 using System.Linq;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Framework;
-using System.Diagnostics.CodeAnalysis;
 
 namespace Microsoft.Build.Execution
 {
diff --git a/src/Build/BackEnd/Shared/EventsCreatorHelper.cs b/src/Build/BackEnd/Shared/EventsCreatorHelper.cs
index 1dad22fc1cf..6b6500c467a 100644
--- a/src/Build/BackEnd/Shared/EventsCreatorHelper.cs
+++ b/src/Build/BackEnd/Shared/EventsCreatorHelper.cs
@@ -2,10 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index ccedf3bab7f..286e1bf9073 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -40,8 +40,8 @@ public List<CheckFactory> CreateCheckFactories(
             assembly = Assembly.LoadFrom(checkAcquisitionData.AssemblyPath);
 #endif
 
-            IList<Type> availableTypes = assembly.GetExportedTypes();
-            IList<Type> checkTypes = availableTypes.Where(t => typeof(Check).IsAssignableFrom(t)).ToArray();
+            Type[] availableTypes = assembly.GetExportedTypes();
+            Type[] checkTypes = availableTypes.Where(t => typeof(Check).IsAssignableFrom(t)).ToArray();
 
             foreach (Type checkCandidate in checkTypes)
             {
@@ -49,7 +49,7 @@ public List<CheckFactory> CreateCheckFactories(
                 checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckRegistered", checkCandidate.Name, checkCandidate.Assembly);
             }
 
-            if (availableTypes.Count != checkTypes.Count)
+            if (availableTypes.Length != checkTypes.Length)
             {
                 availableTypes.Except(checkTypes).ToList()
                     .ForEach(t => checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckBaseTypeNotAssignable", t.Name, t.Assembly));
diff --git a/src/Build/BuildCheck/Checks/EmbeddedResourceCheck.cs b/src/Build/BuildCheck/Checks/EmbeddedResourceCheck.cs
index aaeda56eaa6..6feb8874470 100644
--- a/src/Build/BuildCheck/Checks/EmbeddedResourceCheck.cs
+++ b/src/Build/BuildCheck/Checks/EmbeddedResourceCheck.cs
@@ -1,8 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.IO;
 using System.Collections.Generic;
+using System.IO;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
diff --git a/src/Build/BuildCheck/Checks/ExecCliBuildCheck.cs b/src/Build/BuildCheck/Checks/ExecCliBuildCheck.cs
new file mode 100644
index 00000000000..868827b24cc
--- /dev/null
+++ b/src/Build/BuildCheck/Checks/ExecCliBuildCheck.cs
@@ -0,0 +1,150 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+#if !FEATURE_MSIOREDIST
+using System.IO;
+#endif
+using Microsoft.Build.Shared;
+
+#if FEATURE_MSIOREDIST
+using Path = Microsoft.IO.Path;
+#endif
+
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
+
+internal sealed class ExecCliBuildCheck : Check
+{
+    public static CheckRule SupportedRule = new CheckRule(
+        "BC0109",
+        "ExecCliBuild",
+        ResourceUtilities.GetResourceString("BuildCheck_BC0109_Title")!,
+        ResourceUtilities.GetResourceString("BuildCheck_BC0109_MessageFmt")!,
+        new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
+
+    private const string ExecTaskName = "Exec";
+    private const string CommandParameterName = "Command";
+
+    private static readonly char[] s_knownCommandSeparators = ['&', ';', '|'];
+
+    private static readonly string[] s_knownBuildCommands =
+    [
+        "dotnet build",
+        "dotnet clean",
+        "dotnet msbuild",
+        "dotnet restore",
+        "dotnet publish",
+        "dotnet pack",
+        "dotnet vstest",
+        "nuget restore",
+        "msbuild",
+        "dotnet test",
+        "dotnet run",
+    ];
+
+    public override string FriendlyName => "MSBuild.ExecCliBuildCheck";
+
+    internal override bool IsBuiltIn => true;
+
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
+
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        /* This is it - no custom configuration */
+    }
+
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+    {
+        registrationContext.RegisterTaskInvocationAction(TaskInvocationAction);
+    }
+
+    private static void TaskInvocationAction(BuildCheckDataContext<TaskInvocationCheckData> context)
+    {
+        if (context.Data.TaskName == ExecTaskName
+            && context.Data.Parameters.TryGetValue(CommandParameterName, out TaskInvocationCheckData.TaskParameter? commandArgument))
+        {
+            var execCommandValue = commandArgument.Value?.ToString() ?? string.Empty;
+
+            var commandSpan = execCommandValue.AsSpan();
+            int start = 0;
+
+            while (start < commandSpan.Length)
+            {
+                var nextSeparatorIndex = commandSpan.Slice(start, commandSpan.Length - start).IndexOfAny(s_knownCommandSeparators);
+
+                if (nextSeparatorIndex == -1)
+                {
+                    if (TryGetMatchingKnownBuildCommand(commandSpan.Slice(start), out var knownBuildCommand))
+                    {
+                        context.ReportResult(BuildCheckResult.CreateBuiltIn(
+                            SupportedRule,
+                            context.Data.TaskInvocationLocation,
+                            context.Data.TaskName,
+                            Path.GetFileName(context.Data.ProjectFilePath),
+                            GetToolName(knownBuildCommand)));
+                    }
+
+                    break;
+                }
+                else
+                {
+                    var command = commandSpan.Slice(start, nextSeparatorIndex);
+
+                    if (TryGetMatchingKnownBuildCommand(command, out var knownBuildCommand))
+                    {
+                        context.ReportResult(BuildCheckResult.CreateBuiltIn(
+                            SupportedRule,
+                            context.Data.TaskInvocationLocation,
+                            context.Data.TaskName,
+                            Path.GetFileName(context.Data.ProjectFilePath),
+                            GetToolName(knownBuildCommand)));
+
+                        break;
+                    }
+
+                    start += nextSeparatorIndex + 1;
+                }
+            }
+        }
+    }
+
+    private static bool TryGetMatchingKnownBuildCommand(ReadOnlySpan<char> command, out string knownBuildCommand)
+    {
+        const int maxStackLimit = 1024;
+
+        Span<char> normalizedBuildCommand = command.Length <= maxStackLimit ? stackalloc char[command.Length] : new char[command.Length];
+        int normalizedCommandIndex = 0;
+
+        foreach (var c in command)
+        {
+            if (char.IsWhiteSpace(c) && (normalizedCommandIndex == 0 || char.IsWhiteSpace(normalizedBuildCommand[normalizedCommandIndex - 1])))
+            {
+                continue;
+            }
+
+            normalizedBuildCommand[normalizedCommandIndex++] = c;
+        }
+
+        foreach (var buildCommand in s_knownBuildCommands)
+        {
+            if (normalizedBuildCommand.StartsWith(buildCommand.AsSpan()))
+            {
+                knownBuildCommand = buildCommand;
+                return true;
+            }
+        }
+
+        knownBuildCommand = string.Empty;
+        return false;
+    }
+
+    private static string GetToolName(string knownBuildCommand)
+    {
+        int nextSpaceIndex = knownBuildCommand.IndexOf(' ');
+
+        return nextSpaceIndex == -1
+            ? knownBuildCommand
+            : knownBuildCommand.AsSpan().Slice(0, nextSpaceIndex).ToString();
+    }
+}
diff --git a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
index fe80a4ded80..635fc4ff1a6 100644
--- a/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
+++ b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
@@ -3,9 +3,9 @@
 
 using System.Collections.Generic;
 using System.IO;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Collections;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 7100095f1b4..89998bad255 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -149,6 +149,7 @@ internal readonly record struct BuiltInCheckFactory(
                 new BuiltInCheckFactory([PreferProjectReferenceCheck.SupportedRule.Id], PreferProjectReferenceCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<PreferProjectReferenceCheck>),
                 new BuiltInCheckFactory([CopyAlwaysCheck.SupportedRule.Id], CopyAlwaysCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<CopyAlwaysCheck>),
                 new BuiltInCheckFactory([DoubleWritesCheck.SupportedRule.Id], DoubleWritesCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesCheck>),
+                new BuiltInCheckFactory([ExecCliBuildCheck.SupportedRule.Id], ExecCliBuildCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<ExecCliBuildCheck>),
                 new BuiltInCheckFactory([NoEnvironmentVariablePropertyCheck.SupportedRule.Id], NoEnvironmentVariablePropertyCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyCheck>),
                 new BuiltInCheckFactory([EmbeddedResourceCheck.SupportedRule.Id], EmbeddedResourceCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<EmbeddedResourceCheck>),
                 new BuiltInCheckFactory([TargetFrameworkConfusionCheck.SupportedRule.Id], TargetFrameworkConfusionCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<TargetFrameworkConfusionCheck>),
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index e0179b29c5d..0030a1574cc 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -2,12 +2,12 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Linq;
+using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure.EditorConfig;
-using System.Collections.Concurrent;
 using Microsoft.Build.Experimental.BuildCheck.Utilities;
-using Microsoft.Build.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
index e40d33efb34..1039bfa67cc 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -23,23 +23,16 @@ internal partial class EditorConfigFile
     // Matches EditorConfig property such as "indent_style = space", see https://editorconfig.org for details
     private const string s_propertyMatcherPattern = @"^\s*([\w\.\-_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$";
 
-#if NETCOREAPP
-
+#if NET
     [GeneratedRegex(s_sectionMatcherPattern)]
-    private static partial Regex GetSectionMatcherRegex();
+    private static partial Regex SectionMatcherRegex { get; }
 
     [GeneratedRegex(s_propertyMatcherPattern)]
-    private static partial Regex GetPropertyMatcherRegex();
-
+    private static partial Regex PropertyMatcherRegex { get; }
 #else
-    private static readonly Regex s_sectionMatcher = new Regex(s_sectionMatcherPattern, RegexOptions.Compiled);
-
-    private static readonly Regex s_propertyMatcher = new Regex(s_propertyMatcherPattern, RegexOptions.Compiled);
-
-    private static Regex GetSectionMatcherRegex() => s_sectionMatcher;
-
-    private static Regex GetPropertyMatcherRegex() => s_propertyMatcher;
+    private static Regex SectionMatcherRegex { get; } = new Regex(s_sectionMatcherPattern, RegexOptions.Compiled);
 
+    private static Regex PropertyMatcherRegex { get; } = new Regex(s_propertyMatcherPattern, RegexOptions.Compiled);
 #endif
 
     internal Section GlobalSection { get; }
@@ -90,12 +83,12 @@ internal static EditorConfigFile Parse(string text)
                 continue;
             }
 
-            var sectionMatches = GetSectionMatcherRegex().Matches(line);
-            if (sectionMatches.Count > 0 && sectionMatches[0].Groups.Count > 0)
+            var sectionMatch = SectionMatcherRegex.Match(line);
+            if (sectionMatch.Success && sectionMatch.Groups.Count > 0)
             {
                 addNewSection();
 
-                var sectionName = sectionMatches[0].Groups[1].Value;
+                var sectionName = sectionMatch.Groups[1].Value;
                 Debug.Assert(!string.IsNullOrEmpty(sectionName));
 
                 activeSectionName = sectionName;
@@ -103,11 +96,11 @@ internal static EditorConfigFile Parse(string text)
                 continue;
             }
 
-            var propMatches = GetPropertyMatcherRegex().Matches(line);
-            if (propMatches.Count > 0 && propMatches[0].Groups.Count > 1)
+            var propMatch = PropertyMatcherRegex.Match(line);
+            if (propMatch.Success && propMatch.Groups.Count > 1)
             {
-                var key = propMatches[0].Groups[1].Value.ToLower();
-                var value = propMatches[0].Groups[2].Value;
+                var key = propMatch.Groups[1].Value.ToLower();
+                var value = propMatch.Groups[2].Value;
 
                 Debug.Assert(!string.IsNullOrEmpty(key));
                 Debug.Assert(key == key.Trim());
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
index 56b0842acf7..393a9f7612c 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
@@ -41,12 +41,7 @@ internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
         {
             var editorConfig = _editorConfigFileCache.GetOrAdd(editorConfigFilePath, (key) =>
             {
-                using (FileStream stream = new FileStream(editorConfigFilePath, FileMode.Open, System.IO.FileAccess.Read, FileShare.Read))
-                {
-                    using StreamReader sr = new StreamReader(editorConfigFilePath);
-                    var editorConfigfileContent = sr.ReadToEnd();
-                    return EditorConfigFile.Parse(editorConfigfileContent);
-                }
+                return EditorConfigFile.Parse(File.ReadAllText(editorConfigFilePath));
             });
 
             editorConfigDataFromFilesList.Add(editorConfig);
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index b4ead9bb81b..6f77454eaaf 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -2,8 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using System.IO;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
diff --git a/src/Build/BuildCheck/OM/PropertyReadData.cs b/src/Build/BuildCheck/OM/PropertyReadData.cs
index 531f9fdc4a4..d4198c8385f 100644
--- a/src/Build/BuildCheck/OM/PropertyReadData.cs
+++ b/src/Build/BuildCheck/OM/PropertyReadData.cs
@@ -1,8 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
diff --git a/src/Build/Collections/CopyOnReadEnumerable.cs b/src/Build/Collections/CopyOnReadEnumerable.cs
index 6ed48e0eed1..056f5804cfd 100644
--- a/src/Build/Collections/CopyOnReadEnumerable.cs
+++ b/src/Build/Collections/CopyOnReadEnumerable.cs
@@ -62,7 +62,7 @@ public IEnumerator<TResult> GetEnumerator()
         {
             List<TResult> list;
 
-#if NETCOREAPP
+#if NET
             if (_backingEnumerable.TryGetNonEnumeratedCount(out int count))
             {
 #else
diff --git a/src/Build/Collections/ICopyOnWritePropertyDictionary.cs b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
index 310476fa83b..f7c0589e7f5 100644
--- a/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
@@ -2,11 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Collections.Immutable;
-using System.Diagnostics;
-using Microsoft.Build.Shared;
 
 #nullable disable
 
diff --git a/src/Build/Collections/IItemDictionary.cs b/src/Build/Collections/IItemDictionary.cs
index 1555c1de814..cca36bf088d 100644
--- a/src/Build/Collections/IItemDictionary.cs
+++ b/src/Build/Collections/IItemDictionary.cs
@@ -2,13 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Collections
 {
diff --git a/src/Build/Collections/IMultiDictionary.cs b/src/Build/Collections/IMultiDictionary.cs
index 1fece50dc23..f78a2cf768e 100644
--- a/src/Build/Collections/IMultiDictionary.cs
+++ b/src/Build/Collections/IMultiDictionary.cs
@@ -1,11 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Collections
 {
diff --git a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs
index e3b10556772..798512d22ad 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/IRetrievableValuedEntryHashSet.cs
@@ -1,9 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Collections.Generic;
-using System.Runtime.Serialization;
-
 #nullable disable
 
 namespace Microsoft.Build.Collections
diff --git a/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs
index c45da4e12b6..9b3ffdefa0f 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/RetrievableValuedEntryHashSet.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index c8fabf3559e..6c6584e52c7 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -584,7 +584,7 @@ private static string GetElementIndentation(XmlElementWithLocation xmlElement)
 
             var leadingWhiteSpace = xmlElement.PreviousSibling.Value;
 
-            var lastIndexOfNewLine = leadingWhiteSpace.LastIndexOf("\n", StringComparison.Ordinal);
+            var lastIndexOfNewLine = leadingWhiteSpace.LastIndexOf('\n');
 
             if (lastIndexOfNewLine == -1)
             {
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index eee48e9f667..903de887aac 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -43,7 +43,7 @@ namespace Microsoft.Build.Construction
     /// to control its lifetime and not be surprised by edits via another project collection.
     /// </summary>
     [DebuggerDisplay("{FullPath} #Children={Count} DefaultTargets={DefaultTargets} ToolsVersion={ToolsVersion} InitialTargets={InitialTargets} ExplicitlyLoaded={IsExplicitlyLoaded}")]
-    public class ProjectRootElement : ProjectElementContainer
+    public partial class ProjectRootElement : ProjectElementContainer
     {
         // Constants for default (empty) project file.
         private const string EmptyProjectFileContent = "{0}<Project{1}{2}>\r\n</Project>";
@@ -58,10 +58,18 @@ public class ProjectRootElement : ProjectElementContainer
 
         private static readonly ProjectRootElementCacheBase.OpenProjectRootElement s_openLoaderPreserveFormattingDelegate = OpenLoaderPreserveFormatting;
 
+        private const string XmlDeclarationPattern = @"\A\s*\<\?\s*xml.*\?\>\s*\Z";
+
         /// <summary>
         /// Used to determine if a file is an empty XML file if it ONLY contains an XML declaration like &lt;?xml version="1.0" encoding="utf-8"?&gt;.
         /// </summary>
-        private static readonly Lazy<Regex> XmlDeclarationRegEx = new Lazy<Regex>(() => new Regex(@"\A\s*\<\?\s*xml.*\?\>\s*\Z"), isThreadSafe: true);
+#if NET
+        [GeneratedRegex(XmlDeclarationPattern)]
+        private static partial Regex XmlDeclarationRegex { get; }
+#else
+        private static Regex XmlDeclarationRegex => s_xmlDeclarationRegex ??= new Regex(XmlDeclarationPattern);
+        private static Regex s_xmlDeclarationRegex;
+#endif
 
         /// <summary>
         /// The default encoding to use / assume for a new project.
@@ -1988,9 +1996,9 @@ internal static bool IsEmptyXmlFile(string path)
 
                 string contents = File.ReadAllText(path);
 
-                // If the file is only whitespace or the XML declaration then it empty
+                // If the file is only whitespace or the XML declaration then it is empty
                 //
-                return String.IsNullOrEmpty(contents) || XmlDeclarationRegEx.Value.IsMatch(contents);
+                return String.IsNullOrEmpty(contents) || XmlDeclarationRegex.IsMatch(contents);
             }
             catch (Exception)
             {
diff --git a/src/Build/Construction/ProjectTargetElement.cs b/src/Build/Construction/ProjectTargetElement.cs
index db079f86773..4fdf9c21495 100644
--- a/src/Build/Construction/ProjectTargetElement.cs
+++ b/src/Build/Construction/ProjectTargetElement.cs
@@ -106,7 +106,7 @@ public string Name
 
                 string unescapedValue = EscapingUtilities.UnescapeAll(value);
 
-                int indexOfSpecialCharacter = unescapedValue.IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
+                int indexOfSpecialCharacter = unescapedValue.AsSpan().IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
                 if (indexOfSpecialCharacter >= 0)
                 {
                     ErrorUtilities.ThrowArgument("OM_NameInvalid", unescapedValue, unescapedValue[indexOfSpecialCharacter]);
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 60f69b97b54..106b21221ac 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -2,13 +2,18 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+
 using System.Collections;
 using System.Collections.Generic;
+using System.Collections.ObjectModel;
 using System.IO;
+using System.Linq;
 using System.Security;
-using System.Text;
 using System.Xml;
-#if !NETFRAMEWORK
+#if NETFRAMEWORK
+using System.Text;
+#else
+using System.Buffers;
 using Microsoft.Build.Shared;
 #endif
 
@@ -16,8 +21,8 @@
 using ProjectFileErrorUtilities = Microsoft.Build.Shared.ProjectFileErrorUtilities;
 using BuildEventFileInfo = Microsoft.Build.Shared.BuildEventFileInfo;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
-using System.Collections.ObjectModel;
-using System.Linq;
+
+
 
 #nullable disable
 
@@ -83,7 +88,12 @@ public sealed class ProjectInSolution
         /// <summary>
         /// Characters that need to be cleansed from a project name.
         /// </summary>
-        private static readonly char[] s_charsToCleanse = { '%', '$', '@', ';', '.', '(', ')', '\'' };
+#if NET
+        private static readonly SearchValues<char> s_charsToCleanse = SearchValues.Create(
+#else
+        private static readonly char[] s_charsToCleanse = (
+#endif
+             ['%', '$', '@', ';', '.', '(', ')', '\'']);
 
         /// <summary>
         /// Project names that need to be disambiguated when forming a target name
@@ -501,12 +511,25 @@ private static string CleanseProjectName(string projectName)
 
             // If there are no special chars, just return the original string immediately.
             // Don't even instantiate the StringBuilder.
-            int indexOfChar = projectName.IndexOfAny(s_charsToCleanse);
+            int indexOfChar = projectName.AsSpan().IndexOfAny(s_charsToCleanse);
             if (indexOfChar == -1)
             {
                 return projectName;
             }
 
+#if NET
+            return string.Create(projectName.Length, (projectName, indexOfChar), static (dest, state) =>
+            {
+                state.projectName.AsSpan().CopyTo(dest);
+                int pos = state.indexOfChar;
+                do
+                {
+                    dest[pos] = cleanCharacter;
+                    dest = dest.Slice(pos + 1);
+                }
+                while ((pos = dest.IndexOfAny(s_charsToCleanse)) >= 0);
+            });
+#else
             // This is where we're going to work on the final string to return to the caller.
             var cleanProjectName = new StringBuilder(projectName);
 
@@ -517,6 +540,7 @@ private static string CleanseProjectName(string projectName)
             }
 
             return cleanProjectName.ToString();
+#endif
         }
 
         /// <summary>
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index b549e97da5a..a424caca2b6 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Collections.ObjectModel;
-using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
@@ -35,38 +34,47 @@ namespace Microsoft.Build.Construction
     /// This class contains the functionality to parse a solution file and return a corresponding
     /// MSBuild project file containing the projects and dependencies defined in the solution.
     /// </remarks>
-    public sealed class SolutionFile
+    public sealed partial class SolutionFile
     {
         #region Solution specific constants
 
         // An example of a project line looks like this:
         //  Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ClassLibrary1", "ClassLibrary1\ClassLibrary1.csproj", "{05A5AD00-71B5-4612-AF2F-9EA9121C4111}"
-        private static readonly Lazy<Regex> s_crackProjectLine = new Lazy<Regex>(
-            () => new Regex(
-                "^" // Beginning of line
-                + "Project\\(\"(?<PROJECTTYPEGUID>.*)\"\\)"
-                + "\\s*=\\s*" // Any amount of whitespace plus "=" plus any amount of whitespace
-                + "\"(?<PROJECTNAME>.*)\""
-                + "\\s*,\\s*" // Any amount of whitespace plus "," plus any amount of whitespace
-                + "\"(?<RELATIVEPATH>.*)\""
-                + "\\s*,\\s*" // Any amount of whitespace plus "," plus any amount of whitespace
-                + "\"(?<PROJECTGUID>.*)\""
-                + "$", // End-of-line
-                RegexOptions.Compiled));
+        private const string CrackProjectLinePattern =
+            "^" // Beginning of line
+            + "Project\\(\"(?<PROJECTTYPEGUID>.*)\"\\)"
+            + "\\s*=\\s*" // Any amount of whitespace plus "=" plus any amount of whitespace
+            + "\"(?<PROJECTNAME>.*)\""
+            + "\\s*,\\s*" // Any amount of whitespace plus "," plus any amount of whitespace
+            + "\"(?<RELATIVEPATH>.*)\""
+            + "\\s*,\\s*" // Any amount of whitespace plus "," plus any amount of whitespace
+            + "\"(?<PROJECTGUID>.*)\""
+            + "$"; // End-of-line
 
         // An example of a property line looks like this:
         //      AspNetCompiler.VirtualPath = "/webprecompile"
         // Because website projects now include the target framework moniker as
         // one of their properties, <PROPERTYVALUE> may now have '=' in it.
-
-        private static readonly Lazy<Regex> s_crackPropertyLine = new Lazy<Regex>(
-            () => new Regex(
-                "^" // Beginning of line
-                + "(?<PROPERTYNAME>[^=]*)"
-                + "\\s*=\\s*" // Any amount of whitespace plus "=" plus any amount of whitespace
-                + "(?<PROPERTYVALUE>.*)"
-                + "$", // End-of-line
-                RegexOptions.Compiled));
+        private const string CrackPropertyLinePattern =
+            "^" // Beginning of line
+            + "(?<PROPERTYNAME>[^=]*)"
+            + "\\s*=\\s*" // Any amount of whitespace plus "=" plus any amount of whitespace
+            + "(?<PROPERTYVALUE>.*)"
+            + "$"; // End-of-line
+
+#if NET
+        [GeneratedRegex(CrackProjectLinePattern)]
+        private static partial Regex CrackProjectLineRegex { get; }
+
+        [GeneratedRegex(CrackPropertyLinePattern)]
+        private static partial Regex CrackPropertyLineRegex { get; }
+#else
+        private static Regex CrackProjectLineRegex => s_crackProjectLineRegex ??= new Regex(CrackProjectLinePattern, RegexOptions.Compiled);
+        private static Regex CrackPropertyLineRegex => s_crackPropertyLineRegex ??= new Regex(CrackPropertyLinePattern, RegexOptions.Compiled);
+
+        private static Regex s_crackProjectLineRegex;
+        private static Regex s_crackPropertyLineRegex;
+#endif
 
         internal const int slnFileMinUpgradableVersion = 7; // Minimum version for MSBuild to give a nice message
         internal const int slnFileMinVersion = 9; // Minimum version for MSBuild to actually do anything useful
@@ -89,7 +97,7 @@ public sealed class SolutionFile
         private const string sharedProjectGuid = "{D954291E-2A0B-460D-934E-DC6B0785DB48}";
 
         private const char CommentStartChar = '#';
-        #endregion
+#endregion
         #region Member data
         private string _solutionFile;                 // Could be absolute or relative path to the .SLN file.
         private string _solutionFilterFile;          // Could be absolute or relative path to the .SLNF file.
@@ -121,7 +129,7 @@ public sealed class SolutionFile
 
         // TODO: Unify to NativeMethodsShared.OSUsesCaseSensitive paths
         // when possible.
-        private static StringComparer _pathComparer = RuntimeInformation.IsOSPlatform(OSPlatform.Linux)
+        private static readonly StringComparer _pathComparer = RuntimeInformation.IsOSPlatform(OSPlatform.Linux)
             ? StringComparer.Ordinal
             : StringComparer.OrdinalIgnoreCase;
 
@@ -193,7 +201,7 @@ internal int VisualStudioVersion
 
         internal bool UseNewParser => ShouldUseNewParser(_solutionFile);
 
-        internal static bool ShouldUseNewParser(string solutionFile) => FileUtilities.IsSolutionXFilename(solutionFile);
+        internal static bool ShouldUseNewParser(string solutionFile) => Traits.Instance.SlnParsingWithSolutionPersistenceOptIn || FileUtilities.IsSolutionXFilename(solutionFile);
 
         /// <summary>
         /// All projects in this solution, in the order they appeared in the solution file
@@ -221,6 +229,10 @@ internal string FullPath
 
             set
             {
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_14) && string.IsNullOrEmpty(value))
+                {
+                    throw new ArgumentNullException(nameof(FullPath));
+                }
                 // Should already be canonicalized to a full path
                 ErrorUtilities.VerifyThrowInternalRooted(value);
                 // To reduce code duplication, this should be
@@ -557,7 +569,12 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
                     if (line.Trim().StartsWith(slnFileHeaderNoVersion, StringComparison.Ordinal))
                     {
                         // Found it.  Validate the version.
-                        string fileVersionFromHeader = line.Substring(slnFileHeaderNoVersion.Length);
+                        var fileVersionFromHeader =
+#if NET
+                            line.AsSpan(slnFileHeaderNoVersion.Length);
+#else
+                            line.Substring(slnFileHeaderNoVersion.Length);
+#endif
 
                         if (!System.Version.TryParse(fileVersionFromHeader, out Version version))
                         {
@@ -654,7 +671,8 @@ internal static string ParseSolutionFromSolutionFilter(string solutionFilterFile
                 JsonDocumentOptions options = new JsonDocumentOptions() { AllowTrailingCommas = true, CommentHandling = JsonCommentHandling.Skip };
                 JsonDocument text = JsonDocument.Parse(File.ReadAllText(solutionFilterFile), options);
                 solution = text.RootElement.GetProperty("solution");
-                return FileUtilities.GetFullPath(solution.GetProperty("path").GetString(), Path.GetDirectoryName(solutionFilterFile));
+                // We do NOT want to escape in order to preserve symbols like @, %, $ etc.
+                return FileUtilities.GetFullPath(solution.GetProperty("path").GetString(), Path.GetDirectoryName(solutionFilterFile), escape: false);
             }
             catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
             {
@@ -1056,7 +1074,7 @@ private void ParseProject(string firstLine)
                     {
                         // This should be a dependency.  The GUID identifying the parent project should
                         // be both the property name and the property value.
-                        Match match = s_crackPropertyLine.Value.Match(line);
+                        Match match = CrackPropertyLineRegex.Match(line);
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
                             new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseProjectDepGuidError", proj.ProjectName);
 
@@ -1074,7 +1092,7 @@ private void ParseProject(string firstLine)
                     line = ReadLine();
                     while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
-                        Match match = s_crackPropertyLine.Value.Match(line);
+                        Match match = CrackPropertyLineRegex.Match(line);
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
                             new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseWebProjectPropertiesError", proj.ProjectName);
 
@@ -1285,7 +1303,7 @@ private void ValidateProjectRelativePath(ProjectInSolution proj)
             ErrorUtilities.VerifyThrow(proj.RelativePath != null, "Project relative path cannot be null.");
 
             // Verify the relative path does not contain invalid characters
-            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj.RelativePath.IndexOfAny(Path.GetInvalidPathChars()) == -1,
+            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(proj.RelativePath.AsSpan().IndexOfAny(MSBuildConstants.InvalidPathChars) < 0,
               "SubCategoryForSolutionParsingErrors",
               new BuildEventFileInfo(FullPath, _currentLineNumber, 0),
               "SolutionParseInvalidProjectFileNameCharacters",
@@ -1352,7 +1370,13 @@ private static void ParseAspNetCompilerProperty(
                 string configurationName = propertyName.Substring(0, indexOfFirstDot);
 
                 // The rest of it is the actual property name.
-                string aspNetPropertyName = ((propertyName.Length - indexOfFirstDot) > 0) ? propertyName.Substring(indexOfFirstDot + 1, propertyName.Length - indexOfFirstDot - 1) : "";
+                var aspNetPropertyName = ((propertyName.Length - indexOfFirstDot) > 0) ?
+#if NET
+                    propertyName.AsSpan(indexOfFirstDot + 1) :
+#else
+                    propertyName.Substring(indexOfFirstDot + 1) :
+#endif
+                    "";
 
                 // And the part after the <equals> sign is the property value (which was parsed out for us prior
                 // to calling this method).
@@ -1387,49 +1411,19 @@ private static void ParseAspNetCompilerProperty(
                 }
 
                 // Update the appropriate field within the parameters struct.
-                if (aspNetPropertyName == "AspNetCompiler.VirtualPath")
-                {
-                    aspNetCompilerParameters.aspNetVirtualPath = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.PhysicalPath")
-                {
-                    aspNetCompilerParameters.aspNetPhysicalPath = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.TargetPath")
-                {
-                    aspNetCompilerParameters.aspNetTargetPath = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.ForceOverwrite")
-                {
-                    aspNetCompilerParameters.aspNetForce = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.Updateable")
-                {
-                    aspNetCompilerParameters.aspNetUpdateable = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.Debug")
-                {
-                    aspNetCompilerParameters.aspNetDebug = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.KeyFile")
-                {
-                    aspNetCompilerParameters.aspNetKeyFile = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.KeyContainer")
-                {
-                    aspNetCompilerParameters.aspNetKeyContainer = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.DelaySign")
-                {
-                    aspNetCompilerParameters.aspNetDelaySign = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.AllowPartiallyTrustedCallers")
-                {
-                    aspNetCompilerParameters.aspNetAPTCA = propertyValue;
-                }
-                else if (aspNetPropertyName == "AspNetCompiler.FixedNames")
-                {
-                    aspNetCompilerParameters.aspNetFixedNames = propertyValue;
+                switch (aspNetPropertyName)
+                {
+                    case "AspNetCompiler.VirtualPath": aspNetCompilerParameters.aspNetVirtualPath = propertyValue; break;
+                    case "AspNetCompiler.PhysicalPath": aspNetCompilerParameters.aspNetPhysicalPath = propertyValue; break;
+                    case "AspNetCompiler.TargetPath": aspNetCompilerParameters.aspNetTargetPath = propertyValue; break;
+                    case "AspNetCompiler.ForceOverwrite": aspNetCompilerParameters.aspNetForce = propertyValue; break;
+                    case "AspNetCompiler.Updateable": aspNetCompilerParameters.aspNetUpdateable = propertyValue; break;
+                    case "AspNetCompiler.Debug": aspNetCompilerParameters.aspNetDebug = propertyValue; break;
+                    case "AspNetCompiler.KeyFile": aspNetCompilerParameters.aspNetKeyFile = propertyValue; break;
+                    case "AspNetCompiler.KeyContainer": aspNetCompilerParameters.aspNetKeyContainer = propertyValue; break;
+                    case "AspNetCompiler.DelaySign": aspNetCompilerParameters.aspNetDelaySign = propertyValue; break;
+                    case "AspNetCompiler.AllowPartiallyTrustedCallers": aspNetCompilerParameters.aspNetAPTCA = propertyValue; break;
+                    case "AspNetCompiler.FixedNames": aspNetCompilerParameters.aspNetFixedNames = propertyValue; break;
                 }
 
                 // Store the updated parameters struct back into the hashtable by configuration name.
@@ -1506,7 +1500,7 @@ internal void ParseFirstProjectLine(
             string firstLine,
             ProjectInSolution proj)
         {
-            Match match = s_crackProjectLine.Value.Match(firstLine);
+            Match match = CrackProjectLineRegex.Match(firstLine);
             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
                 new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseProjectError");
 
@@ -1519,7 +1513,7 @@ internal void ParseFirstProjectLine(
             // This allows us to at least generate reasonable target names etc. instead of crashing.
             if (String.IsNullOrEmpty(proj.ProjectName))
             {
-                proj.ProjectName = "EmptyProjectName." + Guid.NewGuid();
+                proj.ProjectName = $"EmptyProjectName.{Guid.NewGuid()}";
             }
 
             // Validate project relative path
@@ -1606,7 +1600,7 @@ internal void ParseNestedProjects()
                     continue;
                 }
 
-                Match match = s_crackPropertyLine.Value.Match(str);
+                Match match = CrackPropertyLineRegex.Match(str);
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(FullPath, _currentLineNumber, 0), "SolutionParseNestedProjectError");
 
@@ -1765,16 +1759,14 @@ internal void ProcessProjectConfigurationSection(Dictionary<string, string> rawP
                     {
                         // The "ActiveCfg" entry defines the active project configuration in the given solution configuration
                         // This entry must be present for every possible solution configuration/project combination.
-                        string entryNameActiveConfig = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.ActiveCfg",
-                            project.ProjectGuid, solutionConfiguration.FullName);
+                        string entryNameActiveConfig = $"{project.ProjectGuid}.{solutionConfiguration.FullName}.ActiveCfg";
 
                         // The "Build.0" entry tells us whether to build the project configuration in the given solution configuration.
                         // Technically, it specifies a configuration name of its own which seems to be a remnant of an initial,
                         // more flexible design of solution configurations (as well as the '.0' suffix - no higher values are ever used).
                         // The configuration name is not used, and the whole entry means "build the project configuration"
                         // if it's present in the solution file, and "don't build" if it's not.
-                        string entryNameBuild = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.Build.0",
-                            project.ProjectGuid, solutionConfiguration.FullName);
+                        string entryNameBuild = $"{project.ProjectGuid}.{solutionConfiguration.FullName}.Build.0";
 
                         if (rawProjectConfigurationsEntries.TryGetValue(entryNameActiveConfig, out string configurationPlatform))
                         {
@@ -1900,6 +1892,6 @@ internal string GetProjectRelativePathByGuid(string projectGuid)
             return null;
         }
 
-        #endregion
+#endregion
     } // class SolutionFile
 } // namespace Microsoft.Build.Construction
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 760fcb390f3..e51789bbb38 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -860,7 +860,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             traversalProject.ToolsVersion = wrapperProjectToolsVersion;
             traversalProject.DefaultTargets = "Build";
             traversalProject.InitialTargets = "ValidateSolutionConfiguration;ValidateToolsVersions;ValidateProjects";
-            traversalProject.FullPath = _solutionFile.FullPath + ".metaproj";
+            traversalProject.FullPath = $"{_solutionFile.FullPath}.metaproj";
 
             // Add default solution configuration/platform names in case the user doesn't specify them on the command line
             AddConfigurationPlatformDefaults(traversalProject);
@@ -948,15 +948,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             // Add our local extensibility points to the project representing the solution
             // Imported at the top: before.mysolution.sln.targets
             // Imported at the bottom: after.mysolution.sln.targets
-            string escapedSolutionFile = EscapingUtilities.Escape(Path.GetFileName(_solutionFile.FullPath));
-            string escapedSolutionDirectory = EscapingUtilities.Escape(_solutionFile.SolutionFileDirectory);
-            string localFile = Path.Combine(escapedSolutionDirectory, "before." + escapedSolutionFile + ".targets");
-            ProjectImportElement importBeforeLocal = traversalProject.CreateImportElement(localFile);
-            importBeforeLocal.Condition = @"exists('" + localFile + "')";
-
-            localFile = Path.Combine(escapedSolutionDirectory, "after." + escapedSolutionFile + ".targets");
-            ProjectImportElement importAfterLocal = traversalProject.CreateImportElement(localFile);
-            importAfterLocal.Condition = @"exists('" + localFile + "')";
+            (ProjectImportElement importBeforeLocal, ProjectImportElement importAfterLocal) = CreateBeforeAndAfterSolutionImports(traversalProject);
 
             // Put locals second so they can override globals if they want
             traversalProject.PrependChild(importBeforeLocal);
@@ -990,7 +982,7 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             // For debugging purposes: some information is lost when evaluating into a project instance,
             // so make it possible to see what we have at this point.
             string path = traversalProject.FullPath;
-            string metaprojectPath = _solutionFile.FullPath + ".metaproj.tmp";
+            string metaprojectPath = $"{_solutionFile.FullPath}.metaproj.tmp";
             EmitMetaproject(traversalProject, metaprojectPath);
             traversalProject.FullPath = path;
 
@@ -1025,6 +1017,27 @@ private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersio
             return traversalInstance;
         }
 
+        private (ProjectImportElement ImportBeforeSln, ProjectImportElement ImportAfterSln) CreateBeforeAndAfterSolutionImports(ProjectRootElement traversalProject)
+        {
+            string escapedSolutionFileName = EscapingUtilities.Escape(Path.GetFileName(_solutionFile.FullPath));
+            if (escapedSolutionFileName.EndsWith(".slnx"))
+            {
+                // We want to load only after.{solutionFileName}.sln.targets for solution files with .slnx extension
+                escapedSolutionFileName = escapedSolutionFileName.Substring(0, escapedSolutionFileName.Length - 1);
+            }
+
+            string escapedSolutionDirectory = EscapingUtilities.Escape(_solutionFile.SolutionFileDirectory);
+            string localFile = Path.Combine(escapedSolutionDirectory, $"before.{escapedSolutionFileName}.targets");
+            ProjectImportElement importBeforeLocal = traversalProject.CreateImportElement(localFile);
+            importBeforeLocal.Condition = $"exists('{localFile}')";
+
+            localFile = Path.Combine(escapedSolutionDirectory, $"after.{escapedSolutionFileName}.targets");
+            ProjectImportElement importAfterLocal = traversalProject.CreateImportElement(localFile);
+            importAfterLocal.Condition = $"exists('{localFile}')";
+
+            return (importBeforeLocal, importAfterLocal);
+        }
+
         private void EmitMetaproject(ProjectRootElement metaproject, string path)
         {
             if (Traits.Instance.EmitSolutionMetaproj)
@@ -1336,7 +1349,7 @@ private static void AddMetaprojectTargetForManagedProject(ProjectInstance traver
             string outputItemAsItem = null;
             if (!String.IsNullOrEmpty(outputItem))
             {
-                outputItemAsItem = "@(" + outputItem + ")";
+                outputItemAsItem = $"@({outputItem})";
             }
 
             ProjectTargetInstance target = metaprojectInstance.AddTarget(targetName ?? "Build", String.Empty, String.Empty, outputItemAsItem, null, String.Empty, String.Empty, String.Empty, String.Empty, false /* legacy target returns behaviour */);
@@ -1383,7 +1396,7 @@ private static void AddProjectBuildTask(ProjectInstance traversalProject, Projec
         /// </summary>
         private void AddMetaprojectBuildTask(ProjectInSolution project, ProjectTargetInstance target, string targetToBuild, string outputItem)
         {
-            ProjectTaskInstance task = target.AddTask("MSBuild", Strings.WeakIntern("'%(ProjectReference.Identity)' == '" + GetMetaprojectName(project) + "'"), String.Empty);
+            ProjectTaskInstance task = target.AddTask("MSBuild", Strings.WeakIntern($"'%(ProjectReference.Identity)' == '{GetMetaprojectName(project)}'"), String.Empty);
             task.SetParameter("Projects", "@(ProjectReference)");
 
             if (targetToBuild != null)
@@ -1966,7 +1979,7 @@ private static void AddTraversalReferencesTarget(ProjectInstance traversalProjec
             string outputItemAsItem = null;
             if (!String.IsNullOrEmpty(outputItem))
             {
-                outputItemAsItem = "@(" + outputItem + ")";
+                outputItemAsItem = $"@({outputItem})";
             }
 
             string correctedTargetName = targetName ?? "Build";
@@ -2039,13 +2052,13 @@ private void AddTraversalTargetForProject(ProjectInstance traversalProject, Proj
             if (!String.IsNullOrEmpty(outputItem))
             {
                 outputItemName = MakeIntoSafeItemName(baseProjectName) + outputItem;
-                outputItemAsItem = "@(" + outputItemName + ")";
+                outputItemAsItem = $"@({outputItemName})";
             }
 
             ProjectTargetInstance targetElement = traversalProject.AddTarget(actualTargetName, null, null, outputItemAsItem, null, null, null, null, null, false /* legacy target returns behaviour */);
             if (canBuildDirectly)
             {
-                AddProjectBuildTask(traversalProject, projectConfiguration, targetElement, targetToBuild, "@(ProjectReference)", "'%(ProjectReference.Identity)' == '" + EscapingUtilities.Escape(project.AbsolutePath) + "'", outputItemName);
+                AddProjectBuildTask(traversalProject, projectConfiguration, targetElement, targetToBuild, "@(ProjectReference)", $"'%(ProjectReference.Identity)' == '{EscapingUtilities.Escape(project.AbsolutePath)}'", outputItemName);
             }
             else
             {
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 2401d4935a1..23b235e5ad0 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Buffers;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Diagnostics;
@@ -56,7 +57,12 @@ public class Project : ILinkableObject
         /// <summary>
         /// * and ? are invalid file name characters, but they occur in globs as wild cards.
         /// </summary>
-        private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c != '/' && c != '\\' && c != ':').ToArray();
+#if NET
+        private static readonly SearchValues<char> s_invalidGlobChars = SearchValues.Create(
+#else
+        private static readonly char[] s_invalidGlobChars = (
+#endif
+            FileUtilities.InvalidFileNameCharsArray.Where(c => c is not ('*' or '?' or '/' or '\\' or ':')).ToArray());
 
         /// <summary>
         /// Context to log messages and events in.
@@ -2618,7 +2624,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
             {
                 var includeItemspec = new EvaluationItemSpec(itemElement.Include, _data.Expander, itemElement.IncludeLocation, itemElement.ContainingProject.DirectoryPath);
 
-                ImmutableArray<ItemSpecFragment> includeGlobFragments = includeItemspec.Fragments.Where(f => f is GlobFragment && f.TextFragment.IndexOfAny(s_invalidGlobChars) == -1).ToImmutableArray();
+                ItemSpecFragment[] includeGlobFragments = includeItemspec.Fragments.Where(f => f is GlobFragment && f.TextFragment.AsSpan().IndexOfAny(s_invalidGlobChars) < 0).ToArray();
                 if (includeGlobFragments.Length == 0)
                 {
                     return null;
diff --git a/src/Build/Definition/ProjectItemDefinition.cs b/src/Build/Definition/ProjectItemDefinition.cs
index 5e79cf18d51..8fa69153f7e 100644
--- a/src/Build/Definition/ProjectItemDefinition.cs
+++ b/src/Build/Definition/ProjectItemDefinition.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
-using System.Linq;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.ObjectModelRemoting;
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index bd84fed6708..9e2444e5bc1 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -13,14 +13,15 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
+#if NET
 using Microsoft.Build.Framework;
+#endif
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 #if FEATURE_WIN32_REGISTRY
 using Microsoft.Win32;
 #endif
-using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
 using ObjectModel = System.Collections.ObjectModel;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index eb461785d00..204de4952f8 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -207,7 +207,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetSubToolsetPropertyD
         protected override Dictionary<string, ProjectImportPathMatch> GetProjectImportSearchPathsTable(string toolsVersion, string os)
         {
             Dictionary<string, ProjectImportPathMatch> kindToPathsCache;
-            var key = toolsVersion + ":" + os;
+            var key = $"{toolsVersion}:{os}";
             if (_projectImportSearchPathsCache.TryGetValue(key, out kindToPathsCache))
             {
                 return kindToPathsCache;
diff --git a/src/Build/Definition/ToolsetLocalReader.cs b/src/Build/Definition/ToolsetLocalReader.cs
index dacbbb6e8b0..68fcb2a5d51 100644
--- a/src/Build/Definition/ToolsetLocalReader.cs
+++ b/src/Build/Definition/ToolsetLocalReader.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Collections.Generic;
-using System.Linq;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index fdc817b930c..2f3ca882084 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -686,22 +686,26 @@ private MSBuildExtensionsPathReferenceKind(string value)
         /// </summary>
         public static MSBuildExtensionsPathReferenceKind FindIn(string expression)
         {
-            if (expression.IndexOf("$(MSBuildExtensionsPath)") >= 0)
+            const string PathBase = "$(MSBuildExtensionsPath";
+            int pos = expression.IndexOf(PathBase, StringComparison.Ordinal);
+            if (pos >= 0)
             {
-                return MSBuildExtensionsPathReferenceKind.Default;
-            }
-
-            if (expression.IndexOf("$(MSBuildExtensionsPath32)") >= 0)
-            {
-                return MSBuildExtensionsPathReferenceKind.Path32;
-            }
-
-            if (expression.IndexOf("$(MSBuildExtensionsPath64)") >= 0)
-            {
-                return MSBuildExtensionsPathReferenceKind.Path64;
+                ReadOnlySpan<char> remainder = expression.AsSpan(pos + PathBase.Length);
+                if (remainder.StartsWith(")".AsSpan()))
+                {
+                    return Default;
+                }
+                else if (remainder.StartsWith("32)".AsSpan()))
+                {
+                    return Path32;
+                }
+                else if (remainder.StartsWith("64)".AsSpan()))
+                {
+                    return Path64;
+                }
             }
 
-            return MSBuildExtensionsPathReferenceKind.None;
+            return None;
         }
     }
 }
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index 8e272113322..33ec20b8e26 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -3,7 +3,6 @@
 
 #if FEATURE_WIN32_REGISTRY
 
-using System;
 using System.Collections.Generic;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
diff --git a/src/Build/ElementLocation/ElementLocation.cs b/src/Build/ElementLocation/ElementLocation.cs
index 8ca5594c946..29879ac6180 100644
--- a/src/Build/ElementLocation/ElementLocation.cs
+++ b/src/Build/ElementLocation/ElementLocation.cs
@@ -25,7 +25,7 @@ public abstract class ElementLocation : IElementLocation, ITranslatable, IImmuta
         /// <summary>
         /// The singleton empty element location.
         /// </summary>
-        private static ElementLocation s_emptyElementLocation = new SmallElementLocation(null, 0, 0);
+        private static readonly ElementLocation s_emptyElementLocation = new SmallElementLocation(null, 0, 0);
 
         /// <summary>
         /// The file from which this particular element originated.  It may
@@ -214,7 +214,7 @@ private static string GetLocationString(string file, int line, int column)
             }
             else if (line != 0)
             {
-                locationString = file + " (" + line + ")";
+                locationString = $"{file} ({line})";
             }
             else
             {
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index cfa910da6a8..eb8c3356873 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -27,7 +27,7 @@ internal class XmlDocumentWithLocation : XmlDocument
         /// <summary>
         /// Used to cache tag names in loaded files.
         /// </summary>
-        private static NameTable s_nameTable = new XmlNameTableThreadSafe();
+        private static readonly NameTable s_nameTable = new XmlNameTableThreadSafe();
 
         /// <summary>
         /// Whether we can selectively load as read-only (eg just when in program files directory)
diff --git a/src/Build/Errors/InvalidToolsetDefinitionException.cs b/src/Build/Errors/InvalidToolsetDefinitionException.cs
index 8dbae22aa4a..b5c1d724240 100644
--- a/src/Build/Errors/InvalidToolsetDefinitionException.cs
+++ b/src/Build/Errors/InvalidToolsetDefinitionException.cs
@@ -1,11 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.Build.Framework.BuildException;
-using Microsoft.Build.Shared;
 using System;
-using System.Runtime.Serialization;
 using System.Collections.Generic;
+using System.Runtime.Serialization;
+using Microsoft.Build.Framework.BuildException;
+using Microsoft.Build.Shared;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 67455f8b4c4..cbe29768a60 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -11,7 +11,6 @@
 using Microsoft.Build.Shared.FileSystem;
 using BuildEventContext = Microsoft.Build.Framework.BuildEventContext;
 using ElementLocation = Microsoft.Build.Construction.ElementLocation;
-using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 namespace Microsoft.Build.Evaluation
@@ -166,7 +165,7 @@ public ConcurrentStack<GenericExpressionNode> GetOrAdd(string condition, Func<st
         }
 
         // Cached expression trees for all the combinations of condition strings and parser options
-        private static volatile ConcurrentDictionary<int, ExpressionTreeForCurrentOptionsWithSize> s_cachedExpressionTrees = new ConcurrentDictionary<int, ExpressionTreeForCurrentOptionsWithSize>();
+        private static readonly ConcurrentDictionary<int, ExpressionTreeForCurrentOptionsWithSize> s_cachedExpressionTrees = new ConcurrentDictionary<int, ExpressionTreeForCurrentOptionsWithSize>();
 
         /// <summary>
         /// For debugging leaks, a way to disable caching expression trees, to reduce noise
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index 1303731a2f6..f460c40142f 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Build/Evaluation/Conditionals/CharacterUtilities.cs b/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
index 06e7345b1b0..ed5502e91ca 100644
--- a/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
+++ b/src/Build/Evaluation/Conditionals/CharacterUtilities.cs
@@ -22,15 +22,9 @@ internal static bool IsSimpleStringChar(char candidate)
             return IsSimpleStringStart(candidate) || char.IsDigit(candidate);
         }
 
-        internal static bool IsHexAlphabetic(char candidate)
-        {
-            return candidate == 'a' || candidate == 'b' || candidate == 'c' || candidate == 'd' || candidate == 'e' || candidate == 'f' ||
-                candidate == 'A' || candidate == 'B' || candidate == 'C' || candidate == 'D' || candidate == 'E' || candidate == 'F';
-        }
-
         internal static bool IsHexDigit(char candidate)
         {
-            return char.IsDigit(candidate) || IsHexAlphabetic(candidate);
+            return char.IsDigit(candidate) || ((uint)((candidate | 0x20) - 'a') <= 'f' - 'a');
         }
     }
 }
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index 6d7b27eb243..61769eb3da9 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index e8a7858d415..a701cade16d 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index f398e8d740a..57685a74ba9 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index 66bfc64c1c2..093599928cd 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index fb6cc3b3a71..ecc9cb4995c 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 55cf768c60b..9d3e1ee1193 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -2,8 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Collections;
 
 #nullable disable
 
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index dae691252e2..03852261ebe 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index a9d31698a28..718ae73d23d 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -692,11 +692,11 @@ private bool ParseRemaining()
         private bool ParseSimpleStringOrFunction(int start)
         {
             SkipSimpleStringChars();
-            if (string.Equals(_expression.Substring(start, _parsePoint - start), "and", StringComparison.OrdinalIgnoreCase))
+            if (_expression.AsSpan(start, _parsePoint - start).Equals("and".AsSpan(), StringComparison.OrdinalIgnoreCase))
             {
                 _lookahead = Token.And;
             }
-            else if (string.Equals(_expression.Substring(start, _parsePoint - start), "or", StringComparison.OrdinalIgnoreCase))
+            else if (_expression.AsSpan(start, _parsePoint - start).Equals("or".AsSpan(), StringComparison.OrdinalIgnoreCase))
             {
                 _lookahead = Token.Or;
             }
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 9e528acc5f4..9e4264af604 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index cba4152a3fc..b061b4db88a 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -809,7 +809,7 @@ private void Evaluate()
                             {
                                 if (!String.Equals(entry.Name, "currentsolutionconfigurationcontents", StringComparison.OrdinalIgnoreCase))
                                 {
-                                    propertyDump += entry.Name + "=" + entry.EvaluatedValue + "\n";
+                                    propertyDump += $"{entry.Name}={entry.EvaluatedValue}\n";
                                 }
                             }
 
@@ -1886,19 +1886,17 @@ static string EvaluateProperty(string value, IElementLocation location,
         // Creates a project to set the properties and include the items from an SdkResult
         private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
         {
-            int propertiesAndItemsHash;
-
-#if NETCOREAPP
-            HashCode hash = new HashCode();
+#if NET
+            HashCode hash = default;
 #else
-            propertiesAndItemsHash = -849885975;
+            int propertiesAndItemsHash = -849885975;
 #endif
 
             if (sdkResult.PropertiesToAdd != null)
             {
                 foreach (var property in sdkResult.PropertiesToAdd)
                 {
-#if NETCOREAPP
+#if NET
                     hash.Add(property.Key);
                     hash.Add(property.Value);
 #else
@@ -1911,7 +1909,7 @@ private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
             {
                 foreach (var item in sdkResult.ItemsToAdd)
                 {
-#if NETCOREAPP
+#if NET
                     hash.Add(item.Key);
                     hash.Add(item.Value);
 #else
@@ -1922,12 +1920,17 @@ private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult)
                 }
             }
 
-#if NETCOREAPP
-            propertiesAndItemsHash = hash.ToHashCode();
+#if NET
+            int propertiesAndItemsHash = hash.ToHashCode();
 #endif
 
-            // Generate a unique filename for the generated project for each unique set of properties and items.
-            string projectPath = _projectRootElement.FullPath + ".SdkResolver." + propertiesAndItemsHash + ".proj";
+            // Generate a unique filename for the generated project for each unique set of properties and items that ends like ".SdkResolver.{propertiesAndItemsHash}.proj".
+            // _projectRootElement.FullPath can be null. This can be in the case when Project is created from XmlReader. For that case we generate filename like "{Guid}.SdkResolver.{propertiesAndItemsHash}.proj in the current directory.
+            // Otherwise the project is in the same directory as _projectRootElement and has a name of the same project and ends like ".SdkResolver.{propertiesAndItemsHash}.proj".
+            string projectNameEnding = $".SdkResolver.{propertiesAndItemsHash}.proj";
+            string projectPath = _projectRootElement.FullPath != null ?
+             _projectRootElement.FullPath + projectNameEnding :
+             FileUtilities.NormalizePath(Guid.NewGuid() + projectNameEnding);
 
             ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
             {
@@ -2136,7 +2139,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                         // If neither file involved is the project itself, append its path in square brackets
                         if (previouslyImportedAt.ContainingProject != _projectRootElement && importElement.ContainingProject != _projectRootElement)
                         {
-                            parenthesizedProjectLocation = "[" + _projectRootElement.FullPath + "]";
+                            parenthesizedProjectLocation = $"[{_projectRootElement.FullPath}]";
                         }
                         // TODO: Detect if the duplicate import came from an SDK attribute
                         _evaluationLoggingContext.LogWarning(null, new BuildEventFileInfo(importLocationInProject), "DuplicateImport", importFileUnescaped, previouslyImportedAt.Location.LocationString, parenthesizedProjectLocation);
@@ -2577,7 +2580,7 @@ private void SetAllProjectsProperty()
             if (_lastModifiedProject != null)
             {
                 P oldValue = _data.GetProperty(Constants.MSBuildAllProjectsPropertyName);
-                string streamImports = string.Join(";", _streamImports.ToArray());
+                string streamImports = string.Join(";", _streamImports);
                 _data.SetProperty(
                     Constants.MSBuildAllProjectsPropertyName,
                     oldValue == null
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 84b34d5c67a..8e8f26a1233 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -24,8 +24,8 @@
 using Microsoft.NET.StringTools;
 using Microsoft.Win32;
 using AvailableStaticMethods = Microsoft.Build.Internal.AvailableStaticMethods;
-using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using ParseArgs = Microsoft.Build.Evaluation.Expander.ArgumentParser;
+using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using TaskItemFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory;
 
@@ -279,17 +279,11 @@ private void FlushFirstValueIfNeeded()
         private static readonly char[] s_backtickChar = { '`' };
         private static readonly char[] s_doubleQuoteChar = { '"' };
 
-        /// <summary>
-        /// Those characters which indicate that an expression may contain expandable
-        /// expressions.
-        /// </summary>
-        private static char[] s_expandableChars = { '$', '%', '@' };
-
         /// <summary>
         /// The CultureInfo from the invariant culture. Used to avoid allocations for
         /// performing IndexOf etc.
         /// </summary>
-        private static CompareInfo s_invariantCompareInfo = CultureInfo.InvariantCulture.CompareInfo;
+        private static readonly CompareInfo s_invariantCompareInfo = CultureInfo.InvariantCulture.CompareInfo;
 
         /// <summary>
         /// Properties to draw on for expansion.
@@ -454,7 +448,7 @@ internal PropertiesUseTracker PropertiesUseTracker
         /// </summary>
         internal static bool ExpressionMayContainExpandableExpressions(string expression)
         {
-            return expression.IndexOfAny(s_expandableChars) > -1;
+            return expression.AsSpan().IndexOfAny('$', '%', '@') >= 0;
         }
 
         /// <summary>
@@ -1110,7 +1104,12 @@ _metadata is IItemTypeDefinition itemMetadata &&
 
                         if (IsTruncationEnabled(_options) && metadataValue.Length > CharacterLimitPerExpansion)
                         {
-                            metadataValue = metadataValue.Substring(0, CharacterLimitPerExpansion - 3) + "...";
+                            metadataValue =
+#if NET
+                                $"{metadataValue.AsSpan(0, CharacterLimitPerExpansion - 3)}...";
+#else
+                                $"{metadataValue.Substring(0, CharacterLimitPerExpansion - 3)}...";
+#endif
                         }
                     }
 
@@ -1313,7 +1312,12 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                                 var value = propertyValue.ToString();
                                 if (value.Length > CharacterLimitPerExpansion)
                                 {
-                                    propertyValue = value.Substring(0, CharacterLimitPerExpansion - 3) + "...";
+                                    propertyValue =
+#if NET
+                                        $"{value.AsSpan(0, CharacterLimitPerExpansion - 3)}...";
+#else
+                                        $"{value.Substring(0, CharacterLimitPerExpansion - 3)}...";
+#endif
                                 }
                             }
 
@@ -1730,7 +1734,7 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
                     }
                     catch (Exception ex) when (!ExceptionHandling.NotExpectedRegistryException(ex))
                     {
-                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidRegistryPropertyExpression", "$(" + registryExpression + ")", ex.Message);
+                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidRegistryPropertyExpression", $"$({registryExpression})", ex.Message);
                     }
                 }
 
@@ -1858,7 +1862,7 @@ internal static ExpressionShredder.ItemExpressionCapture ExpandSingleItemVectorE
                 }
 
                 List<ExpressionShredder.ItemExpressionCapture> matches;
-                if (expression.IndexOf('@') == -1)
+                if (!expression.Contains('@'))
                 {
                     return null;
                 }
@@ -2239,7 +2243,7 @@ internal static class IntrinsicItemFunctions<S>
                 /// <summary>
                 /// A cache of previously created item function delegates.
                 /// </summary>
-                private static ConcurrentDictionary<string, ItemTransformFunction> s_transformFunctionDelegateCache = new ConcurrentDictionary<string, ItemTransformFunction>(StringComparer.OrdinalIgnoreCase);
+                private static readonly ConcurrentDictionary<string, ItemTransformFunction> s_transformFunctionDelegateCache = new ConcurrentDictionary<string, ItemTransformFunction>(StringComparer.OrdinalIgnoreCase);
 
                 /// <summary>
                 /// Delegate that represents the signature of all item transformation functions
@@ -2254,7 +2258,7 @@ internal static class IntrinsicItemFunctions<S>
                 internal static ItemTransformFunction GetItemTransformFunction(IElementLocation elementLocation, string functionName, Type itemType)
                 {
                     ItemTransformFunction transformFunction = null;
-                    string qualifiedFunctionName = itemType.FullName + "::" + functionName;
+                    string qualifiedFunctionName = $"{itemType.FullName}::{functionName}";
 
                     // We may have seen this delegate before, if so grab the one we already created
                     if (!s_transformFunctionDelegateCache.TryGetValue(qualifiedFunctionName, out transformFunction))
@@ -2631,7 +2635,7 @@ internal static IEnumerable<KeyValuePair<string, S>> Metadata(Expander<P, I> exp
                             {
                                 // It may be that the itemspec has unescaped ';'s in it so we need to split here to handle
                                 // that case.
-                                if (metadataValue.IndexOf(';') >= 0)
+                                if (metadataValue.Contains(';'))
                                 {
                                     var splits = ExpressionShredder.SplitSemiColonSeparatedList(metadataValue);
 
@@ -3095,36 +3099,23 @@ private static partial class RegularExpressions
             * description of an item vector changes, the expressions must be updated in both places.
             *************************************************************************************************************************/
 
-
-
-#if NET7_0_OR_GREATER
+#if NET
             [GeneratedRegex(ItemMetadataSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture)]
-            internal static partial Regex ItemMetadataPattern();
+            internal static partial Regex ItemMetadataRegex { get; }
 #else
             /// <summary>
             /// Regular expression used to match item metadata references embedded in strings.
             /// For example, %(Compile.DependsOn) or %(DependsOn).
             /// </summary>
-            internal static readonly Lazy<Regex> ItemMetadataPattern = new Lazy<Regex>(
-                () => new Regex(ItemMetadataSpecification,
-                    RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled));
-#endif
+            internal static Regex ItemMetadataRegex => s_itemMetadataRegex ??=
+                new Regex(ItemMetadataSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled);
 
-            internal static Regex ItemMetadataRegex
-            {
-                get
-                {
-#if NET7_0_OR_GREATER
-                    return ItemMetadataPattern();
-#else
-                    return ItemMetadataPattern.Value;
+            internal static Regex s_itemMetadataRegex;
 #endif
-                }
-            }
 
-                /// <summary>
-                /// Name of the group matching the "name" of a metadatum.
-                /// </summary>
+            /// <summary>
+            /// Name of the group matching the "name" of a metadatum.
+            /// </summary>
             internal const string NameGroup = "NAME";
 
             /// <summary>
@@ -3143,29 +3134,19 @@ internal static Regex ItemMetadataRegex
                                                                 ItemVectorWithTransformLHS + @")" + ItemMetadataSpecification + @"(?!" +
                                                                 ItemVectorWithTransformRHS + @"))";
 
-#if NET7_0_OR_GREATER
+#if NET
             [GeneratedRegex(NonTransformItemMetadataSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture)]
-            internal static partial Regex NonTransformItemMetadataPattern();
+            internal static partial Regex NonTransformItemMetadataRegex { get; }
 #else
             /// <summary>
             /// regular expression used to match item metadata references outside of item vector transforms.
             /// </summary>
             /// <remarks>PERF WARNING: this Regex is complex and tends to run slowly.</remarks>
-            internal static readonly Lazy<Regex> NonTransformItemMetadataPattern = new Lazy<Regex>(
-                () => new Regex(NonTransformItemMetadataSpecification,
-                                RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled));
-#endif
-            internal static Regex NonTransformItemMetadataRegex
-            {
-                get
-                {
-#if NET7_0_OR_GREATER
-                    return NonTransformItemMetadataPattern();
-#else
-                    return NonTransformItemMetadataPattern.Value;
+            private static Regex s_nonTransformItemMetadataPattern;
+
+            internal static Regex NonTransformItemMetadataRegex => s_nonTransformItemMetadataPattern ??=
+                new Regex(NonTransformItemMetadataSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled);
 #endif
-                }
-            }
 
             /// <summary>
             /// Complete description of an item metadata reference, including the optional qualifying item type.
@@ -4114,8 +4095,8 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                         else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains("."))
                         {
                             Type enumType = parameters[n].ParameterType;
-                            string typeLeafName = enumType.Name + ".";
-                            string typeFullName = enumType.FullName + ".";
+                            string typeLeafName = $"{enumType.Name}.";
+                            string typeFullName = $"{enumType.FullName}.";
 
                             // Enum.parse expects commas between enum components
                             // We'll support the C# type | syntax too
@@ -4200,11 +4181,11 @@ private string GenerateStringOfMethodExecuted(string expression, object objectIn
                     }
                     if ((_bindingFlags & BindingFlags.InvokeMethod) == BindingFlags.InvokeMethod)
                     {
-                        return "[" + typeName + "]::" + name + "(" + parameters + ")";
+                        return $"[{typeName}]::{name}({parameters})";
                     }
                     else
                     {
-                        return "[" + typeName + "]::" + name;
+                        return $"[{typeName}]::{name}";
                     }
                 }
                 else
@@ -4213,11 +4194,11 @@ private string GenerateStringOfMethodExecuted(string expression, object objectIn
 
                     if ((_bindingFlags & BindingFlags.InvokeMethod) == BindingFlags.InvokeMethod)
                     {
-                        return propertyValue + "." + name + "(" + parameters + ")";
+                        return $"{propertyValue}.{name}({parameters})";
                     }
                     else
                     {
-                        return propertyValue + "." + name;
+                        return $"{propertyValue}.{name}";
                     }
                 }
             }
diff --git a/src/Build/Evaluation/Expander/ArgumentParser.cs b/src/Build/Evaluation/Expander/ArgumentParser.cs
index ca4039aae5d..c2dd113d5ff 100644
--- a/src/Build/Evaluation/Expander/ArgumentParser.cs
+++ b/src/Build/Evaluation/Expander/ArgumentParser.cs
@@ -2,11 +2,10 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.Globalization;
+#if NETFRAMEWORK
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+#endif
 
 namespace Microsoft.Build.Evaluation.Expander
 {
diff --git a/src/Build/Evaluation/Expander/WellKnownFunctions.cs b/src/Build/Evaluation/Expander/WellKnownFunctions.cs
index 72f8b247933..d6bd9de96d3 100644
--- a/src/Build/Evaluation/Expander/WellKnownFunctions.cs
+++ b/src/Build/Evaluation/Expander/WellKnownFunctions.cs
@@ -2,16 +2,11 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using System.Reflection;
 using System.Runtime.CompilerServices;
-using System.Text;
 using System.Text.RegularExpressions;
-using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
@@ -236,7 +231,7 @@ internal static bool TryExecuteStringFunction(string methodName, out object? ret
             {
                 if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
                 {
-                    returnVal = text.IndexOfAny(arg0.ToCharArray());
+                    returnVal = text.AsSpan().IndexOfAny(arg0.AsSpan());
                     return true;
                 }
             }
@@ -262,7 +257,7 @@ internal static bool TryExecuteStringFunction(string methodName, out object? ret
             {
                 if (ParseArgs.TryGetArg(args, out string? arg0) && arg0 != null)
                 {
-                    returnVal = text.LastIndexOfAny(arg0.ToCharArray());
+                    returnVal = text.AsSpan().LastIndexOfAny(arg0.AsSpan());
                     return true;
                 }
             }
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index fd102dff143..a7d9e48b9a5 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -428,7 +428,7 @@ private static void GetReferencedItemNamesAndMetadata(string expression, int sta
 
                         itemName = firstPart;
                         metadataName = expression.Substring(startOfText, i - startOfText);
-                        qualifiedMetadataName = itemName + "." + metadataName;
+                        qualifiedMetadataName = $"{itemName}.{metadataName}";
                     }
                     else
                     {
diff --git a/src/Build/Evaluation/IItemFactory.cs b/src/Build/Evaluation/IItemFactory.cs
index 9624d90a562..d0f26ffd63b 100644
--- a/src/Build/Evaluation/IItemFactory.cs
+++ b/src/Build/Evaluation/IItemFactory.cs
@@ -3,7 +3,6 @@
 
 using System.Collections.Generic;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
 
 #nullable disable
 
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 032f95a251c..fc86d54e613 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -4,9 +4,13 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+#if NETFRAMEWORK
+using System.Linq;
+#endif
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
+using System.Security.Cryptography;
 using System.Text;
 using System.Text.RegularExpressions;
 using Microsoft.Build.BackEnd.Logging;
@@ -18,8 +22,6 @@
 using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
 using Microsoft.Win32;
-using System.Linq;
-
 // Needed for DoesTaskHostExistForParameters
 using NodeProviderOutOfProcTaskHost = Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost;
 
@@ -40,24 +42,13 @@ internal static partial class IntrinsicFunctions
         private static readonly object[] DefaultRegistryViews = [RegistryView.Default];
 #pragma warning restore CA1416
 
-#if NET7_0_OR_GREATER
+#if NET
         [GeneratedRegex(RegistrySdkSpecification, RegexOptions.IgnoreCase)]
-        private static partial Regex RegistrySdkPattern();
-#else
-        private static readonly Lazy<Regex> RegistrySdkPattern = new Lazy<Regex>(() => new Regex(RegistrySdkSpecification, RegexOptions.IgnoreCase));
-#endif
-
-        private static Regex RegistrySdkRegex
-        {
-            get
-            {
-#if NET7_0_OR_GREATER
-                return RegistrySdkPattern();
+        private static partial Regex RegistrySdkRegex { get; }
 #else
-                return RegistrySdkPattern.Value;
+        private static Regex s_registrySdkRegex;
+        private static Regex RegistrySdkRegex => s_registrySdkRegex ??= new Regex(RegistrySdkSpecification, RegexOptions.IgnoreCase);
 #endif
-            }
-        }
 
         private static readonly Lazy<NuGetFrameworkWrapper> NuGetFramework = new Lazy<NuGetFrameworkWrapper>(() => NuGetFrameworkWrapper.CreateInstance());
 
@@ -284,8 +275,8 @@ internal static object GetRegistryValueFromView(string keyName, string valueName
             {
                 if (viewObject is string viewAsString)
                 {
-                    string typeLeafName = typeof(RegistryView).Name + ".";
-                    string typeFullName = typeof(RegistryView).FullName + ".";
+                    string typeLeafName = $"{typeof(RegistryView).Name}.";
+                    string typeFullName = $"{typeof(RegistryView).FullName}.";
 
                     // We'll allow the user to specify the leaf or full type name on the RegistryView enum
                     viewAsString = viewAsString.Replace(typeFullName, "").Replace(typeLeafName, "");
@@ -466,7 +457,12 @@ internal static object StableStringHash(string toHash, StringHashingAlgorithm al
 
         private static string CalculateSha256(string toHash)
         {
-            using var sha = System.Security.Cryptography.SHA256.Create();
+#if NET
+            Span<byte> hash = stackalloc byte[SHA256.HashSizeInBytes];
+            SHA256.HashData(Encoding.UTF8.GetBytes(toHash), hash);
+            return Convert.ToHexStringLower(hash);
+#else
+            using var sha = SHA256.Create();
             var hashResult = new StringBuilder();
             foreach (byte theByte in sha.ComputeHash(Encoding.UTF8.GetBytes(toHash)))
             {
@@ -474,6 +470,7 @@ private static string CalculateSha256(string toHash)
             }
 
             return hashResult.ToString();
+#endif
         }
 
         /// <summary>
@@ -651,14 +648,15 @@ internal static string SubstringByAsciiChars(string input, int start, int length
             {
                 return string.Empty;
             }
+
             if (start + length > input.Length)
             {
                 length = input.Length - start;
             }
+
             StringBuilder sb = new StringBuilder();
-            for (int i = start; i < start + length; i++)
+            foreach (char c in input.AsSpan(start, length))
             {
-                char c = input[i];
                 if (c >= 32 && c <= 126 && !FileUtilities.InvalidFileNameChars.Contains(c))
                 {
                     sb.Append(c);
@@ -668,6 +666,7 @@ internal static string SubstringByAsciiChars(string input, int start, int length
                     sb.Append('_');
                 }
             }
+
             return sb.ToString();
         }
 
@@ -804,7 +803,7 @@ private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView vi
             }
             else
             {
-                subKeyName = keyName.Substring(i + 1, keyName.Length - i - 1);
+                subKeyName = keyName.Substring(i + 1);
             }
 
             return basekey;
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index 30400c410f6..26138e50b92 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs b/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
index 99c7166189b..f83ef9635c8 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.ItemFactoryWrapper.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
 
 #nullable disable
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index 771b0e6ce40..51d91cce6d7 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -29,7 +29,7 @@ public RemoveOperation(RemoveOperationBuilder builder, LazyItemEvaluator<P, I, M
                     new BuildEventFileInfo(string.Empty),
                     "OM_MatchOnMetadataIsRestrictedToReferencedItems");
 
-                if (_matchOnMetadata.Any())
+                if (!_matchOnMetadata.IsEmpty)
                 {
                     _metadataSet = new MetadataTrie<P, I>(builder.MatchOnMetadataOptions, _matchOnMetadata, _itemSpec);
                 }
@@ -48,7 +48,7 @@ protected override void ApplyImpl(OrderedItemDataCollection.Builder listBuilder,
                     return;
                 }
 
-                bool matchingOnMetadata = _matchOnMetadata.Any();
+                bool matchingOnMetadata = !_matchOnMetadata.IsEmpty;
                 if (!matchingOnMetadata)
                 {
                     if (ItemspecContainsASingleBareItemReference(_itemSpec, _itemElement.ItemType))
diff --git a/src/Build/Evaluation/Preprocessor.cs b/src/Build/Evaluation/Preprocessor.cs
index 0d38472e450..d70e8327285 100644
--- a/src/Build/Evaluation/Preprocessor.cs
+++ b/src/Build/Evaluation/Preprocessor.cs
@@ -26,6 +26,9 @@ namespace Microsoft.Build.Evaluation
     /// </remarks>
     internal class Preprocessor
     {
+        /// <summary>140 equal signs.</summary>
+        private const string Equals140 = "============================================================================================================================================";
+
         /// <summary>
         /// Project to preprocess
         /// </summary>
@@ -99,7 +102,7 @@ private XmlDocument Preprocess()
 
             if (!String.IsNullOrEmpty(_project.FullPath)) // Ignore in-memory projects
             {
-                destinationDocument.AppendChild(destinationDocument.CreateComment("\r\n" + new String('=', 140) + "\r\n" + _project.FullPath.Replace("--", "__") + "\r\n" + new String('=', 140) + "\r\n"));
+                destinationDocument.AppendChild(destinationDocument.CreateComment($"\r\n{Equals140}\r\n{_project.FullPath.Replace("--", "__")}\r\n{Equals140}\r\n"));
             }
 
             CloneChildrenResolvingImports(outerDocument, destinationDocument);
@@ -310,7 +313,7 @@ private void CloneChildrenResolvingImports(XmlNode source, XmlNode destination)
                         }
 
                         destination.AppendChild(destinationDocument.CreateComment(
-                            $"\r\n{new String('=', 140)}\r\n{importTag}\r\n\r\n{resolved.FullPath.Replace("--", "__")}\r\n{new String('=', 140)}\r\n"));
+                            $"\r\n{Equals140}\r\n{importTag}\r\n\r\n{resolved.FullPath.Replace("--", "__")}\r\n{Equals140}\r\n"));
 
                         _filePaths.Push(resolved.FullPath);
                         CloneChildrenResolvingImports(innerDocument, destination);
@@ -318,11 +321,11 @@ private void CloneChildrenResolvingImports(XmlNode source, XmlNode destination)
 
                         if (i < resolvedList.Count - 1)
                         {
-                            destination.AppendChild(destinationDocument.CreateComment("\r\n" + new String('=', 140) + "\r\n  </Import>\r\n" + new String('=', 140) + "\r\n"));
+                            destination.AppendChild(destinationDocument.CreateComment($"\r\n{Equals140}\r\n  </Import>\r\n{Equals140}\r\n"));
                         }
                         else
                         {
-                            destination.AppendChild(destinationDocument.CreateComment("\r\n" + new String('=', 140) + "\r\n  </Import>\r\n\r\n" + _filePaths.Peek()?.Replace("--", "__") + "\r\n" + new String('=', 140) + "\r\n"));
+                            destination.AppendChild(destinationDocument.CreateComment($"\r\n{Equals140}\r\n  </Import>\r\n\r\n{_filePaths.Peek()?.Replace("--", "__")}\r\n{Equals140}\r\n"));
                         }
                     }
 
@@ -339,7 +342,7 @@ private void CloneChildrenResolvingImports(XmlNode source, XmlNode destination)
 
                     CloneChildrenResolvingImports(child, destination);
 
-                    destination.AppendChild(destinationDocument.CreateComment("</" + XMakeElements.importGroup + ">"));
+                    destination.AppendChild(destinationDocument.CreateComment($"</{XMakeElements.importGroup}>"));
 
                     continue;
                 }
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs b/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs
index 065f756fede..99f4bfdf8c6 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationMarkdownPrettyPrinter.cs
@@ -38,14 +38,19 @@ protected override string NormalizeExpression(string description, EvaluationLoca
                 return null;
             }
 
-            text = text.Replace(Separator, "\\" + Separator);
+            text = text.Replace(Separator, $"\\{Separator}");
 
             if (text.Length > 100)
             {
-                text = text.Remove(100) + "...";
+                text =
+#if NET
+                    $"{text.AsSpan(0, 100)}...";
+#else
+                    $"{text.Remove(100)}...";
+#endif
             }
 
-            return '`' + text + '`';
+            return $"`{text}`";
         }
     }
 }
diff --git a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
index a1e8dc7f30d..ea8876e874f 100644
--- a/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
+++ b/src/Build/Evaluation/Profiler/EvaluationLocationPrettyPrinterBase.cs
@@ -65,7 +65,7 @@ protected static string GetElementOrConditionText(string description, Evaluation
             var outerXml = description;
             outerXml = outerXml.Replace(@"xmlns=""http://schemas.microsoft.com/developer/msbuild/2003""", "");
 
-            var newLineIndex = outerXml.IndexOfAny(['\r', '\n']);
+            var newLineIndex = outerXml.AsSpan().IndexOfAny('\r', '\n');
             return newLineIndex == -1 ? outerXml : outerXml.Remove(newLineIndex);
         }
 
@@ -74,9 +74,19 @@ protected static string GetElementOrConditionText(string description, Evaluation
         /// </summary>
         protected void AppendDefaultHeaderWithSeparator(StringBuilder stringBuilder, string separator)
         {
-            stringBuilder.AppendLine(
-                string.Join(separator, "Id", "ParentId", "Pass", "File", "Line #", "Expression", "Inc (ms)", "Inc (%)", "Exc (ms)",
-                        "Exc (%)", "#", "Kind", "Bug"));
+            stringBuilder.Append("Id").Append(separator)
+                         .Append("ParentId").Append(separator)
+                         .Append("Pass").Append(separator)
+                         .Append("File").Append(separator)
+                         .Append("Line #").Append(separator)
+                         .Append("Expression").Append(separator)
+                         .Append("Inc (ms)").Append(separator)
+                         .Append("Inc (%)").Append(separator)
+                         .Append("Exc (ms)").Append(separator)
+                         .Append("Exc (%)").Append(separator)
+                         .Append('#').Append(separator)
+                         .Append("Kind").Append(separator)
+                         .Append("Bug").AppendLine();
         }
 
         /// <summary>
@@ -92,9 +102,9 @@ protected void AppendDefaultLocationWithSeparator(StringBuilder stringBuilder, T
                 evaluationLocation.Line?.ToString() ?? string.Empty,
                 NormalizeExpression(evaluationLocation.ElementDescription, evaluationLocation.Kind) ?? string.Empty,
                 GetMilliseconds(profiledLocation.InclusiveTime),
-                GetPercentage(totalTime, profiledLocation.InclusiveTime) + "%",
+                $"{GetPercentage(totalTime, profiledLocation.InclusiveTime)}%",
                 GetMilliseconds(profiledLocation.ExclusiveTime),
-                GetPercentage(totalTime, profiledLocation.ExclusiveTime) + "%",
+                $"{GetPercentage(totalTime, profiledLocation.ExclusiveTime)}%",
                 profiledLocation.NumberOfHits,
                 evaluationLocation.Kind + separator));
         }
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 3427a49260d..a71a572677d 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -577,7 +577,7 @@ private ProjectTargetElement ParseProjectTargetElement(XmlElementWithLocation el
             // Orcas compat: all target names are automatically unescaped
             string targetName = EscapingUtilities.UnescapeAll(ProjectXmlUtilities.GetAttributeValue(element, XMakeAttributes.name));
 
-            int indexOfSpecialCharacter = targetName.IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
+            int indexOfSpecialCharacter = targetName.AsSpan().IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
             if (indexOfSpecialCharacter >= 0)
             {
                 ProjectErrorUtilities.ThrowInvalidProject(element.GetAttributeLocation(XMakeAttributes.name), "NameInvalid", targetName, targetName[indexOfSpecialCharacter]);
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index d70e5648f3e..c97ebad4bff 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -7,7 +7,6 @@
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
-using System.Linq;
 using System.Xml;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -79,7 +78,7 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
         /// <summary>
         /// Whether the cache should log activity to the Debug.Out stream
         /// </summary>
-        private static bool s_debugLogCacheActivity = Environment.GetEnvironmentVariable("MSBUILDDEBUGXMLCACHE") == "1";
+        private static readonly bool s_debugLogCacheActivity = Environment.GetEnvironmentVariable("MSBUILDDEBUGXMLCACHE") == "1";
 
         /// <summary>
         /// Whether the cache should check file content for cache entry invalidation.
@@ -87,7 +86,7 @@ internal class ProjectRootElementCache : ProjectRootElementCacheBase
         /// <remarks>
         /// Value shall be true only in case of testing. Outside QA tests it shall be false.
         /// </remarks>
-        private static bool s_сheckFileContent = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDCACHECHECKFILECONTENT"));
+        private static readonly bool s_сheckFileContent = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDCACHECHECKFILECONTENT"));
 
 #if DEBUG
         /// <summary>
@@ -100,7 +99,7 @@ private struct ReentrancyGuard : IDisposable
             /// Shall be always 0 or 1. Reentrance to the Get function (value > 1) could lead to race condition.
             /// </summary>
             [ThreadStatic]
-            private static int s_getEntriesNumber = 0;
+            private static int s_getEntriesNumber;
 
             public ReentrancyGuard()
             {
@@ -674,7 +673,7 @@ private void DebugTraceCache(string message, string param1)
             if (s_debugLogCacheActivity)
             {
                 string prefix = OutOfProcNode.IsOutOfProcNode ? "C" : "P";
-                Trace.WriteLine(prefix + " " + EnvironmentUtilities.CurrentProcessId + " | " + message + param1);
+                Trace.WriteLine($"{prefix} {Process.GetCurrentProcess().Id} | {message}{param1}");
             }
         }
     }
diff --git a/src/Build/Evaluation/StringMetadataTable.cs b/src/Build/Evaluation/StringMetadataTable.cs
index 5e920a99c23..277c5d829d9 100644
--- a/src/Build/Evaluation/StringMetadataTable.cs
+++ b/src/Build/Evaluation/StringMetadataTable.cs
@@ -69,7 +69,7 @@ public string GetEscapedValueIfPresent(string itemType, string name)
             }
             else
             {
-                key = itemType + "." + name;
+                key = $"{itemType}.{name}";
             }
 
             string value;
diff --git a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
index 9d259bda8c6..992e89967f0 100644
--- a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
+++ b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
@@ -1,12 +1,12 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 using System;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 #if FEATURE_MSIOREDIST
 using Path = Microsoft.IO.Path;
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index e6cb8ab1ac5..38915e44cd3 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -47,7 +47,7 @@ public GlobState(string globRoot, string fileSpec, bool isLegal, string fixedDir
         }
 
         // Cache of Regex objects that we have created and are still alive.
-        private static WeakValueDictionary<string, Regex> s_regexCache = new WeakValueDictionary<string, Regex>();
+        private static readonly WeakValueDictionary<string, Regex> s_regexCache = new WeakValueDictionary<string, Regex>();
 
         private readonly Lazy<GlobState> _state;
 
diff --git a/src/Build/Graph/GraphBuildRequestData.cs b/src/Build/Graph/GraphBuildRequestData.cs
index 4d95ec0afe7..3d67ecf9eb2 100644
--- a/src/Build/Graph/GraphBuildRequestData.cs
+++ b/src/Build/Graph/GraphBuildRequestData.cs
@@ -5,8 +5,9 @@
 using System.Collections.Immutable;
 using System.Linq;
 using Microsoft.Build.Execution;
+#if NETFRAMEWORK
 using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.Framework;
+#endif
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Graph
diff --git a/src/Build/Graph/GraphBuildSubmission.cs b/src/Build/Graph/GraphBuildSubmission.cs
index 164cfc8e377..a7280646e08 100644
--- a/src/Build/Graph/GraphBuildSubmission.cs
+++ b/src/Build/Graph/GraphBuildSubmission.cs
@@ -2,9 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Globalization;
 using System.Threading;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 311392df81f..09c7709e062 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -205,9 +205,9 @@ private static void AddEdgesFromSolution(IReadOnlyDictionary<ConfigurationMetada
             {
                 var projectPath = project.Value.GraphNode.ProjectInstance.FullPath;
 
-                if (projectsByPath.ContainsKey(projectPath))
+                if (projectsByPath.TryGetValue(projectPath, out List<ProjectGraphNode> value))
                 {
-                    projectsByPath[projectPath].Add(project.Value.GraphNode);
+                    value.Add(project.Value.GraphNode);
                 }
                 else
                 {
diff --git a/src/Build/Graph/ParallelWorkSet.cs b/src/Build/Graph/ParallelWorkSet.cs
index ed4ecb41537..8474968ed2c 100644
--- a/src/Build/Graph/ParallelWorkSet.cs
+++ b/src/Build/Graph/ParallelWorkSet.cs
@@ -145,7 +145,12 @@ internal void WaitForAllWorkAndComplete()
 
             // Release one thread that will release all the threads when all the elements are processed.
             _semaphore.Release();
-            Task.WaitAll(_tasks.ToArray());
+            Task.WaitAll(
+#if NET
+                _tasks);
+#else
+                _tasks.ToArray());
+#endif
 
             if (_exceptions.Count > 0)
             {
diff --git a/src/Build/Graph/ProjectGraphNode.cs b/src/Build/Graph/ProjectGraphNode.cs
index dcc2a2a24b1..4c43b1e1061 100644
--- a/src/Build/Graph/ProjectGraphNode.cs
+++ b/src/Build/Graph/ProjectGraphNode.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.BackEnd;
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index d927eaa7e8c..12ae373485d 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -64,7 +64,7 @@ public TargetSpecification(string target, bool skipIfNonexistent)
                 ErrorUtilities.VerifyThrow(
                     !skipIfNonexistent || (!target.Equals(MSBuildConstants.DefaultTargetsMarker)
                     && !target.Equals(MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker)),
-                    target + " cannot be marked as SkipNonexistentTargets");
+                    $"{target} cannot be marked as SkipNonexistentTargets");
                 Target = target;
                 SkipIfNonexistent = skipIfNonexistent;
             }
diff --git a/src/Build/Instance/HostObjectException.cs b/src/Build/Instance/HostObjectException.cs
index ee4613d1b14..47ba77e5d17 100644
--- a/src/Build/Instance/HostObjectException.cs
+++ b/src/Build/Instance/HostObjectException.cs
@@ -40,7 +40,7 @@ internal HostObjectException(
             Exception innerException) :
             base(ErrorMessagePrefix
                 + string.Format(ErrorMessageProjectTargetTask, projectFile, targetName, taskName)
-                + (innerException == null ? string.Empty : ("\n=============\n" + innerException.ToString() + "\n\n")),
+                + (innerException == null ? string.Empty : ($"\n=============\n{innerException}\n\n")),
                 innerException)
         {
         }
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs
index b5579adf088..47e51a66e3f 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableGlobalPropertiesCollectionConverter.cs
@@ -2,13 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.CodeDom;
 using System.Collections;
 using System.Collections.Generic;
-using System.Linq;
 using System.Runtime.Serialization;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs
index 245d42583b5..67243d66e62 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDefinitionsListConverter.cs
@@ -4,9 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
index de2d06522ae..b92e762eba9 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableItemDictionary.cs
@@ -5,11 +5,8 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Instance
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs
index 1b11db2341a..ecf078d2567 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutableLinkedMultiDictionaryConverter.cs
@@ -3,11 +3,7 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Execution;
 
 namespace Microsoft.Build.Instance.ImmutableProjectCollections
 {
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 938fcc5cba9..f77da95817b 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -2640,7 +2640,12 @@ private static ProjectInstance[] CalculateToolsVersionAndGenerateSolutionWrapper
                 }
                 else /* Dev 12 and above */
                 {
-                    toolsVersion = visualStudioVersion.ToString(CultureInfo.InvariantCulture) + ".0";
+                    toolsVersion =
+#if NET
+                        string.Create(CultureInfo.InvariantCulture, $"{visualStudioVersion}.0");
+#else
+                        $"{visualStudioVersion.ToString(CultureInfo.InvariantCulture)}.0";
+#endif
                 }
 
                 string toolsVersionToUse = Utilities.GenerateToolsVersionToUse(
@@ -3161,7 +3166,7 @@ private void Initialize(
 
             if (Traits.Instance.EscapeHatches.DebugEvaluation)
             {
-                Trace.WriteLine(String.Format(CultureInfo.InvariantCulture, "MSBUILD: Creating a ProjectInstance from an unevaluated state [{0}]", FullPath));
+                Trace.WriteLine($"MSBUILD: Creating a ProjectInstance from an unevaluated state [{FullPath}]");
             }
 
             ErrorUtilities.VerifyThrow(EvaluationId == BuildEventContext.InvalidEvaluationId, "Evaluation ID is invalid prior to evaluation");
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 4e886bd134a..2bfb6750f50 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -10,7 +10,6 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Instance;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 8dd5127eba5..36f280f88bb 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -2112,7 +2112,7 @@ internal class TaskItemFactory : IItemFactory<ProjectItem, TaskItem>, IItemFacto
                 /// <summary>
                 /// The singleton instance.
                 /// </summary>
-                private static TaskItemFactory s_instance = new TaskItemFactory();
+                private static readonly TaskItemFactory s_instance = new TaskItemFactory();
 
                 /// <summary>
                 /// Private constructor for singleton creation.
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index ec764cbbbb3..15136b19c1d 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -164,7 +164,7 @@ internal string EvaluatedValueEscaped
         /// </summary>
         public override string ToString()
         {
-            return _name + "=" + _escapedValue;
+            return $"{_name}={_escapedValue}";
         }
 
         #region INodePacketTranslatable Members
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index dc7cb2b6624..2d0de613ea9 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -186,7 +186,7 @@ void ITranslatable.Translate(ITranslator translator)
         /// </summary>
         public override string ToString()
         {
-            return _name + "=" + _escapedValue;
+            return $"{_name}={_escapedValue}";
         }
 
         /// <summary>
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index 784b67b200c..fd169167a9c 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -9,11 +9,13 @@
 using System.Threading;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Exceptions;
-using Microsoft.Build.FileAccesses;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Experimental.FileAccess;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+#if FEATURE_REPORTFILEACCESSES
+using Microsoft.Build.Experimental.FileAccess;
+using Microsoft.Build.FileAccesses;
+#endif
 
 #nullable disable
 
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index a71dad69e15..508cb7483b6 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -11,7 +11,6 @@
 using System.Reflection;
 using System.Threading;
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.BackEnd.Components.RequestBuilder;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
@@ -20,7 +19,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.NET.StringTools;
-using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
@@ -68,64 +66,64 @@ internal sealed class TaskRegistry : ITranslatable
         /// callbacks; as forcing those out of proc would be just setting them up for
         /// known failure.
         /// </summary>
-        private static bool s_forceTaskHostLaunch = (Environment.GetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC") == "1");
+        private static readonly bool s_forceTaskHostLaunch = (Environment.GetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC") == "1");
 
         /// <summary>
         /// Simple name for the MSBuild tasks (v4), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksV4SimpleName = "Microsoft.Build.Tasks.v4.0";
+        private const string s_tasksV4SimpleName = "Microsoft.Build.Tasks.v4.0";
 
         /// <summary>
         /// Filename for the MSBuild tasks (v4), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksV4Filename = s_tasksV4SimpleName + ".dll";
+        private const string s_tasksV4Filename = $"{s_tasksV4SimpleName}.dll";
 
         /// <summary>
         /// Expected location that MSBuild tasks (v4) is picked up from if the user
         /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_potentialTasksV4Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV4Filename);
+        private static readonly string s_potentialTasksV4Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV4Filename);
 
         /// <summary>
         /// Simple name for the MSBuild tasks (v12), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksV12SimpleName = "Microsoft.Build.Tasks.v12.0";
+        private const string s_tasksV12SimpleName = "Microsoft.Build.Tasks.v12.0";
 
         /// <summary>
         /// Filename for the MSBuild tasks (v12), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksV12Filename = s_tasksV12SimpleName + ".dll";
+        private const string s_tasksV12Filename = $"{s_tasksV12SimpleName}.dll";
 
         /// <summary>
         /// Expected location that MSBuild tasks (v12) is picked up from if the user
         /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_potentialTasksV12Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV12Filename);
+        private static readonly string s_potentialTasksV12Location = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksV12Filename);
 
         /// <summary>
         /// Simple name for the MSBuild tasks (v14+), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksCoreSimpleName = "Microsoft.Build.Tasks.Core";
+        private const string s_tasksCoreSimpleName = "Microsoft.Build.Tasks.Core";
 
         /// <summary>
         /// Filename for the MSBuild tasks (v14+), used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_tasksCoreFilename = s_tasksCoreSimpleName + ".dll";
+        private const string s_tasksCoreFilename = $"{s_tasksCoreSimpleName}.dll";
 
         /// <summary>
         /// Expected location that MSBuild tasks (v14+) is picked up from if the user
         /// references it with just a simple name, used for shimming in loading
         /// task factory UsingTasks
         /// </summary>
-        private static string s_potentialTasksCoreLocation = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksCoreFilename);
+        private static readonly string s_potentialTasksCoreLocation = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, s_tasksCoreFilename);
 
         /// <summary>
         /// Monotonically increasing counter for registered tasks.
@@ -853,13 +851,13 @@ internal class RegisteredTaskIdentityComparer : IEqualityComparer<RegisteredTask
                 /// <summary>
                 /// The singleton comparer to use when an exact match is desired
                 /// </summary>
-                private static RegisteredTaskIdentityComparer s_exact = new RegisteredTaskIdentityComparer(true /* exact match */);
+                private static readonly RegisteredTaskIdentityComparer s_exact = new RegisteredTaskIdentityComparer(true /* exact match */);
 
                 /// <summary>
                 /// The singleton comparer to use when a fuzzy match is desired.  Note that this still does an exact match on the
                 /// name, but does a fuzzy match on the task identity parameters.
                 /// </summary>
-                private static RegisteredTaskIdentityComparer s_fuzzy = new RegisteredTaskIdentityComparer(false /* fuzzy match */);
+                private static readonly RegisteredTaskIdentityComparer s_fuzzy = new RegisteredTaskIdentityComparer(false /* fuzzy match */);
 
                 /// <summary>
                 /// Keeps track of whether we're doing exact or fuzzy equivalency
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 508223e628b..364487c1e72 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -518,7 +518,7 @@ internal virtual void OutputEnvironment(IDictionary<string, string> environment)
                 foreach (KeyValuePair<string, string> entry in environment)
                 {
                     setColor(ConsoleColor.Gray);
-                    WritePretty(String.Format(CultureInfo.CurrentCulture, "{0,-30} = ", entry.Key));
+                    WritePretty($"{entry.Key,-30} = ");
                     setColor(ConsoleColor.DarkGray);
                     WriteLinePretty(entry.Value);
                 }
@@ -536,7 +536,7 @@ internal virtual void OutputProperties(List<DictionaryEntry> list)
             foreach (DictionaryEntry prop in list)
             {
                 setColor(ConsoleColor.Gray);
-                WritePretty(String.Format(CultureInfo.CurrentCulture, "{0,-30} = ", prop.Key));
+                WritePretty($"{prop.Key,-30} = ");
                 setColor(ConsoleColor.DarkGray);
                 WriteLinePretty(EscapingUtilities.UnescapeAll((string)prop.Value));
             }
@@ -656,12 +656,12 @@ protected virtual void WriteItemType(string itemType)
 
         protected virtual void WriteItemSpec(string itemSpec)
         {
-            WriteLinePretty("    " + itemSpec);
+            WriteLinePretty($"    {itemSpec}");
         }
 
         protected virtual void WriteMetadata(string name, string value)
         {
-            WriteLinePretty("        " + name + " = " + value);
+            WriteLinePretty($"        {name} = {value}");
         }
 
         /// <summary>
@@ -821,8 +821,8 @@ internal virtual void PrintCounterMessage(WriteLinePrettyFromResourceDelegate wr
                     2,
                     "PerformanceLine",
                     time,
-                    String.Format(CultureInfo.CurrentCulture, "{0,-40}" /* pad to 40 align left */, scopeName),
-                    String.Format(CultureInfo.CurrentCulture, "{0,3}", calls));
+                    $"{scopeName,-40}", // pad to 40 align left
+                    $"{calls,3}");
             }
 
             /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 9c3fda8fec3..10286b512eb 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 
 #nullable disable
 
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 4b48d9a8592..69afeee1674 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -56,9 +56,9 @@ public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposa
 
         // reflection is needed to set these three fields because public constructors don't provide
         // a way to set these from the outside
-        private static FieldInfo? buildEventArgsFieldThreadId =
+        private static readonly FieldInfo? buildEventArgsFieldThreadId =
             typeof(BuildEventArgs).GetField("threadId", BindingFlags.Instance | BindingFlags.NonPublic);
-        private static FieldInfo? buildEventArgsFieldSenderName =
+        private static readonly FieldInfo? buildEventArgsFieldSenderName =
             typeof(BuildEventArgs).GetField("senderName", BindingFlags.Instance | BindingFlags.NonPublic);
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs
index ec8ba12c8b1..6239d90f453 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs
@@ -4,8 +4,6 @@
 using System;
 using System.IO;
 using System.IO.Compression;
-using System.Text;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
 {
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
index 8a0cc2ed489..3e85d2bb02b 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
@@ -3,9 +3,7 @@
 
 using System;
 using System.Buffers;
-using System.Diagnostics;
 using System.IO;
-using System.Text;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
index 8c6e0c6e2b8..af92788d62a 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
@@ -70,9 +70,13 @@ public override int ReadByte()
         public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
         {
             count = Math.Min((int)Math.Max(Length - _position, 0), count);
-#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-            int read = await _stream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(false);
-#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            int read = await _stream.ReadAsync(
+#if NET
+                buffer.AsMemory(offset, count),
+#else
+                buffer, offset, count,
+#endif
+                cancellationToken).ConfigureAwait(false);
             _position += read;
             return read;
         }
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
index ea3fcb3c9c7..bd427fbb3bc 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
@@ -116,9 +116,13 @@ public override async Task<int> ReadAsync(byte[] buffer, int offset, int count,
                 count = (int)(_maxAllowedPosition - _position);
             }
 
-#pragma warning disable CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
-            int cnt = await _stream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(false);
-#pragma warning restore CA1835 // Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'
+            int cnt = await _stream.ReadAsync(
+#if NET
+                buffer.AsMemory(offset, count),
+#else
+                buffer, offset, count,
+#endif
+                cancellationToken).ConfigureAwait(false);
             _position += cnt;
             return cnt;
         }
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index dc365d45387..41bfaf94f50 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -2,10 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Diagnostics.CodeAnalysis;
-using System.Linq;
-using System.Reflection;
-using System.Runtime.CompilerServices;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Logging;
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index 591df6df9f3..bfd1d41a51f 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -113,7 +113,7 @@ public void Initialize(IEventSource eventSource)
                 // but avoids confusion by being consistent with the Engine and any error messages it may produce.
                 fileName = _logFile.Replace(extension, _nodeId + extension);
                 _nodeFileLogger.Verbosity = LoggerVerbosity.Detailed;
-                _nodeFileLogger.Parameters = "ShowEventId;ShowCommandLine;logfile=" + fileName + ";" + _parameters;
+                _nodeFileLogger.Parameters = $"ShowEventId;ShowCommandLine;logfile={fileName};{_parameters}";
             }
             catch (ArgumentException e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
diff --git a/src/Build/Logging/LogFormatter.cs b/src/Build/Logging/LogFormatter.cs
index b03391a34a1..22c0ab05658 100644
--- a/src/Build/Logging/LogFormatter.cs
+++ b/src/Build/Logging/LogFormatter.cs
@@ -51,7 +51,7 @@ internal static string FormatTimeSpan(TimeSpan t)
             string rawTime = t.ToString(); // Timespan is a value type and can't be null.
             int rawTimeLength = rawTime.Length;
             int prettyLength = System.Math.Min(11, rawTimeLength);
-            return t.ToString().Substring(0, prettyLength);
+            return rawTime.Substring(0, prettyLength);
         }
     }
 }
diff --git a/src/Build/Logging/LoggerDescription.cs b/src/Build/Logging/LoggerDescription.cs
index 8f949afb9ad..9b4e34e5c34 100644
--- a/src/Build/Logging/LoggerDescription.cs
+++ b/src/Build/Logging/LoggerDescription.cs
@@ -96,7 +96,7 @@ public string Name
                 if (!string.IsNullOrEmpty(_loggerClassName) &&
                     !string.IsNullOrEmpty(_loggerAssembly.AssemblyFile))
                 {
-                    return _loggerClassName + ":" + _loggerAssembly.AssemblyFile;
+                    return $"{_loggerClassName}:{_loggerAssembly.AssemblyFile}";
                 }
                 else if (!string.IsNullOrEmpty(_loggerClassName))
                 {
diff --git a/src/Build/Logging/OptimizedStringIndenter.cs b/src/Build/Logging/OptimizedStringIndenter.cs
index d98f1d62094..ed28c80e8fd 100644
--- a/src/Build/Logging/OptimizedStringIndenter.cs
+++ b/src/Build/Logging/OptimizedStringIndenter.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Buffers;
 
-#if NET7_0_OR_GREATER
+#if NET
 using System.Runtime.CompilerServices;
 #else
 using System.Text;
@@ -49,7 +49,7 @@ namespace Microsoft.Build.BackEnd.Logging;
 internal static class OptimizedStringIndenter
 {
 #nullable enable
-#if NET7_0_OR_GREATER
+#if NET
     [SkipLocalsInit]
 #endif
     internal static unsafe string IndentString(string? s, int indent, IStringBuilderProvider stringBuilderProvider)
@@ -67,7 +67,7 @@ internal static unsafe string IndentString(string? s, int indent, IStringBuilder
             indentedStringLength += segment.Length;
         }
 
-#if NET7_0_OR_GREATER
+#if NET
 #pragma warning disable CS8500
         string result = string.Create(indentedStringLength, (s, (IntPtr)(&segments), indent), static (output, state) =>
         {
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index d59bbb81e46..9e2368df650 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -760,7 +760,7 @@ internal override void OutputProperties(List<DictionaryEntry> list)
             foreach (DictionaryEntry prop in list)
             {
                 setColor(ConsoleColor.Gray);
-                string propertyString = String.Format(CultureInfo.CurrentCulture, "{0} = {1}", prop.Key, EscapingUtilities.UnescapeAll((string)(prop.Value)));
+                string propertyString = $"{prop.Key} = {EscapingUtilities.UnescapeAll((string)(prop.Value))}";
                 WriteMessageAligned(propertyString, false);
             }
             resetColor();
@@ -781,7 +781,7 @@ internal override void OutputEnvironment(IDictionary<string, string> environment
                 foreach (KeyValuePair<string, string> entry in environment)
                 {
                     setColor(ConsoleColor.Gray);
-                    string environmentMessage = String.Format(CultureInfo.CurrentCulture, "{0} = {1}", entry.Key, entry.Value);
+                    string environmentMessage = $"{entry.Key} = {entry.Value}";
                     WriteMessageAligned(environmentMessage, false);
                 }
             }
@@ -897,7 +897,7 @@ public override void TargetFinishedHandler(object sender, TargetFinishedEventArg
 
                                 foreach (DictionaryEntry metadatum in metadata)
                                 {
-                                    WriteMessageAligned(new String(' ', 4 * tabWidth) + metadatum.Key + " = " + item.GetMetadata(metadatum.Key as string), false);
+                                    WriteMessageAligned($"{new String(' ', 4 * tabWidth)}{metadatum.Key} = {item.GetMetadata(metadatum.Key as string)}", false);
                                 }
                             }
                         }
@@ -1343,7 +1343,7 @@ private void PrintTargetNamePerMessage(BuildMessageEventArgs e, bool lightenText
                     }
                     else
                     {
-                        WriteMessageAligned(targetName + ":", prefixAlreadyWritten);
+                        WriteMessageAligned($"{targetName}:", prefixAlreadyWritten);
                     }
 
                     if (lightenText)
@@ -1618,11 +1618,11 @@ private void WriteLinePrefix(string key, DateTime eventTimeStamp, bool isMessage
 
             if (!isMessagePrefix || IsVerbosityAtLeast(LoggerVerbosity.Detailed))
             {
-                prefixString = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildEventContext", context, key) + ">";
+                prefixString = $"{ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildEventContext", context, key)}>";
             }
             else
             {
-                prefixString = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildEventContext", context, string.Empty) + " ";
+                prefixString = $"{ResourceUtilities.FormatResourceStringStripCodeAndKeyword("BuildEventContext", context, string.Empty)} ";
             }
 
             WritePretty(prefixString);
@@ -1763,8 +1763,8 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
                     MessageIndentLevel,
                     "PerformanceLine",
                     time,
-                    String.Format(CultureInfo.CurrentCulture, "{0,-40}" /* pad to 40 align left */, scopeName),
-                    String.Format(CultureInfo.CurrentCulture, "{0,3}", calls));
+                    $"{scopeName,-40}", // pad to 40 align left
+                    $"{calls,3}");
 
                 if (_internalPerformanceCounters?.Count > 0)
                 {
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index dd73599bec2..b066b31fea4 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -140,7 +140,6 @@ internal string[] ProjectCallStackFromProject(BuildEventContext e)
 
             ProjectStartedEventMinimumFields startedEvent = GetProjectStartedEvent(currentKey);
 
-            List<string> stackTrace = new List<string>();
             // If there is no started event then there should be no stack trace
             // this is a valid situation if the event occures in the engine or outside the context of a project
             // or the event is raised before the project started event
@@ -150,19 +149,18 @@ internal string[] ProjectCallStackFromProject(BuildEventContext e)
             }
 
             List<ProjectStartedEventMinimumFields> projectStackTrace = GetProjectCallStack(e);
-            foreach (ProjectStartedEventMinimumFields projectStartedEvent in projectStackTrace)
+
+            string[] stackTrace = new string[projectStackTrace.Count];
+            for (int i = 0; i < stackTrace.Length; i++)
             {
-                if (!string.IsNullOrEmpty(projectStartedEvent.TargetNames))
-                {
-                    stackTrace.Add(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStackWithTargetNames", projectStartedEvent.ProjectFile, projectStartedEvent.TargetNames, projectStartedEvent.FullProjectKey));
-                }
-                else
-                {
-                    stackTrace.Add(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStackWithDefaultTargets", projectStartedEvent.ProjectFile, projectStartedEvent.FullProjectKey));
-                }
+                ProjectStartedEventMinimumFields projectStartedEvent = projectStackTrace[i];
+
+                stackTrace[stackTrace.Length - i - 1] = !string.IsNullOrEmpty(projectStartedEvent.TargetNames) ?
+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStackWithTargetNames", projectStartedEvent.ProjectFile, projectStartedEvent.TargetNames, projectStartedEvent.FullProjectKey) :
+                    ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStackWithDefaultTargets", projectStartedEvent.ProjectFile, projectStartedEvent.FullProjectKey);
             }
-            stackTrace.Reverse();
-            return stackTrace.ToArray();
+
+            return stackTrace;
         }
 
         /// <summary>
diff --git a/src/Build/Logging/ProfilerLogger.cs b/src/Build/Logging/ProfilerLogger.cs
index b80dcf8cf0e..85f659336d8 100644
--- a/src/Build/Logging/ProfilerLogger.cs
+++ b/src/Build/Logging/ProfilerLogger.cs
@@ -134,7 +134,7 @@ internal ProfilerResult GetAggregatedResult(bool pruneSmallItems = true)
             // So keeping that map here
             var originalLocations = new Dictionary<EvaluationLocation, EvaluationLocation>(EvaluationLocationIdAgnosticComparer.Singleton);
 
-            while (_profiledResults.Any())
+            while (!_profiledResults.IsEmpty)
             {
                 ProfilerResult profiledResult;
                 var result = _profiledResults.TryDequeue(out profiledResult);
diff --git a/src/Build/Logging/SimpleErrorLogger.cs b/src/Build/Logging/SimpleErrorLogger.cs
index 5b248afd5e7..fafc01e340d 100644
--- a/src/Build/Logging/SimpleErrorLogger.cs
+++ b/src/Build/Logging/SimpleErrorLogger.cs
@@ -4,7 +4,6 @@
 using System;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Logging;
-using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging.SimpleErrorLogger
diff --git a/src/Build/Logging/TerminalLogger/TerminalLogger.cs b/src/Build/Logging/TerminalLogger/TerminalLogger.cs
index 33696ada520..eca3e0749a3 100644
--- a/src/Build/Logging/TerminalLogger/TerminalLogger.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalLogger.cs
@@ -12,8 +12,8 @@
 using Microsoft.Build.Framework.Logging;
 using Microsoft.Build.Shared;
 
-#if NET7_0_OR_GREATER
-using System.Diagnostics.CodeAnalysis;
+#if NET
+using System.Buffers;
 #endif
 
 #if NETFRAMEWORK
@@ -34,15 +34,10 @@ public sealed partial class TerminalLogger : INodeLogger
 {
     private const string FilePathPattern = " -> ";
 
-#if NET7_0_OR_GREATER
-    [StringSyntax(StringSyntaxAttribute.Regex)]
-    private const string ImmediateMessagePattern = @"\[CredentialProvider\]|--interactive";
-    private const RegexOptions Options = RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.ExplicitCapture;
-
-    [GeneratedRegex(ImmediateMessagePattern, Options)]
-    private static partial Regex ImmediateMessageRegex();
+#if NET
+    private static readonly SearchValues<string> _immediateMessageKeywords = SearchValues.Create(["[CredentialProvider]", "--interactive"], StringComparison.OrdinalIgnoreCase);
 #else
-    private static readonly string[] _immediateMessageKeywords = { "[CredentialProvider]", "--interactive" };
+    private static readonly string[] _immediateMessageKeywords = ["[CredentialProvider]", "--interactive"];
 #endif
 
     private static readonly string[] newLineStrings = { "\r\n", "\n" };
@@ -165,11 +160,6 @@ public ProjectContext(BuildEventContext context)
     /// </summary>
     private bool _loggedPreviewMessage;
 
-    /// <summary>
-    /// The two directory separator characters to be passed to methods like <see cref="String.IndexOfAny(char[])"/>.
-    /// </summary>
-    private static readonly char[] PathSeparators = { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar };
-
     /// <summary>
     /// One summary per finished project test run.
     /// </summary>
@@ -816,15 +806,17 @@ private void TargetFinished(object sender, TargetFinishedEventArgs e)
         // For cache plugin projects which result in a cache hit, ensure the output path is set
         // to the item spec corresponding to the GetTargetPath target upon completion.
         var buildEventContext = e.BuildEventContext;
+        var targetOutputs = e.TargetOutputs;
         if (_restoreContext is null
             && buildEventContext is not null
+            && targetOutputs is not null
             && _hasUsedCache
             && e.TargetName == "GetTargetPath"
             && _projects.TryGetValue(new ProjectContext(buildEventContext), out TerminalProjectInfo? project))
         {
-            if (project.IsCachePluginProject)
+            if (project is not null && project.IsCachePluginProject)
             {
-                foreach (ITaskItem output in e.TargetOutputs)
+                foreach (ITaskItem output in targetOutputs)
                 {
                     project.OutputPath = output.ItemSpec.AsMemory();
                     break;
@@ -1018,8 +1010,8 @@ private void WarningRaised(object sender, BuildWarningEventArgs e)
     /// <param name="message">Raised event.</param>
     /// <returns>true if marker is detected.</returns>
     private bool IsImmediateMessage(string message) =>
-#if NET7_0_OR_GREATER
-        ImmediateMessageRegex().IsMatch(message);
+#if NET
+        message.AsSpan().ContainsAny(_immediateMessageKeywords);
 #else
         _immediateMessageKeywords.Any(imk => message.IndexOf(imk, StringComparison.OrdinalIgnoreCase) >= 0);
 #endif
@@ -1058,11 +1050,22 @@ private void ErrorRaised(object sender, BuildErrorEventArgs e)
     private void ThreadProc()
     {
         // 1_000 / 30 is a poor approx of 30Hz
+        var count = 0;
         while (!_cts.Token.WaitHandle.WaitOne(1_000 / 30))
         {
+            count++;
             lock (_lock)
             {
-                DisplayNodes();
+                // Querying the terminal for it's dimensions is expensive, so we only do it every 30 frames e.g. once a second.
+                if (count >= 30)
+                {
+                    count = 0;
+                    DisplayNodes();
+                }
+                else
+                {
+                    DisplayNodes(false);
+                }
             }
         }
 
@@ -1073,9 +1076,11 @@ private void ThreadProc()
     /// Render Nodes section.
     /// It shows what all build nodes do.
     /// </summary>
-    internal void DisplayNodes()
+    internal void DisplayNodes(bool updateSize = true)
     {
-        TerminalNodesFrame newFrame = new TerminalNodesFrame(_nodes, width: Terminal.Width, height: Terminal.Height);
+        var width = updateSize ? Terminal.Width : _currentFrame.Width;
+        var height = updateSize ? Terminal.Height : _currentFrame.Height;
+        TerminalNodesFrame newFrame = new TerminalNodesFrame(_nodes, width: width, height: height);
 
         // Do not render delta but clear everything if Terminal width or height have changed.
         if (newFrame.Width != _currentFrame.Width || newFrame.Height != _currentFrame.Height)
@@ -1182,7 +1187,7 @@ private int NodeIndexForContext(BuildEventContext context)
             return null;
         }
 
-        int index = path.LastIndexOfAny(PathSeparators);
+        int index = path.AsSpan().LastIndexOfAny(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
         return index >= 0
             ? $"{path.Substring(0, index + 1)}{AnsiCodes.MakeBold(path.Substring(index + 1))}"
             : path;
@@ -1280,7 +1285,7 @@ private string FormatEventMessage(
         builder.Append($"{category} {code}: ");
 
         // render multi-line message in a special way
-        if (message.IndexOf('\n') >= 0)
+        if (message.Contains('\n'))
         {
             // Place the multiline message under the project in case of minimal and higher verbosity.
             string[] lines = message.Split(newLineStrings, StringSplitOptions.None);
diff --git a/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs b/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
index 4634040bdf7..22eb0157257 100644
--- a/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalNodeStatus.cs
@@ -1,10 +1,10 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+#if DEBUG
 using System;
-using System.Diagnostics;
+#endif
 using Microsoft.Build.Framework.Logging;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging;
 
@@ -68,23 +68,10 @@ obj is TerminalNodeStatus status &&
         TargetPrefixColor == status.TargetPrefixColor &&
         TargetPrefix == status.TargetPrefix;
 
-    public override string ToString()
-    {
-        string duration = Stopwatch.ElapsedSeconds.ToString("F1");
-
-        return string.IsNullOrEmpty(TargetFramework)
-            ? string.Format("{0}{1} {2} ({3}s)",
-                TerminalLogger.Indentation,
-                Project,
-                Target,
-                duration)
-            : string.Format("{0}{1} {2} {3} ({4}s)",
-                TerminalLogger.Indentation,
-                Project,
-                AnsiCodes.Colorize(TargetFramework, TerminalLogger.TargetFrameworkColor),
-                Target,
-                duration);
-    }
+    public override string ToString() =>
+        string.IsNullOrEmpty(TargetFramework) ?
+            $"{TerminalLogger.Indentation}{Project} {Target} ({Stopwatch.ElapsedSeconds:F1}s)" :
+            $"{TerminalLogger.Indentation}{Project} {AnsiCodes.Colorize(TargetFramework, TerminalLogger.TargetFrameworkColor)} {Target} ({Stopwatch.ElapsedSeconds:F1}s)";
 
     public override int GetHashCode()
     {
diff --git a/src/Build/Logging/TerminalLogger/TerminalProjectInfo.cs b/src/Build/Logging/TerminalLogger/TerminalProjectInfo.cs
index 8e4f98fe688..8c64b0978f5 100644
--- a/src/Build/Logging/TerminalLogger/TerminalProjectInfo.cs
+++ b/src/Build/Logging/TerminalLogger/TerminalProjectInfo.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Linq;
 
 namespace Microsoft.Build.Logging;
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 1ae5b029b43..b28ac113cd2 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -31,7 +31,7 @@
   <ItemGroup>
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
-    <PackageReference Include="Microsoft.VisualStudio.SolutionPersistence" />
+    <PackageReference Include="Microsoft.VisualStudio.SolutionPersistence" PrivateAssets="all"/>
     <PackageReference Include="System.Configuration.ConfigurationManager" />
 
     <PackageReference Include="System.Reflection.MetadataLoadContext" />
@@ -39,6 +39,9 @@
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
 
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
+    <!-- Remove the direct NETStandard.Library dependency when Microsoft.BuildXL.Processes stops bringing in netstandard1.x dependencies
+         or when a .NET 10 SDK is used (NuGet Package Pruning eliminates netstandard1.x dependencies). -->
+    <PackageReference Include="NETStandard.Library" VersionOverride="2.0.3" PrivateAssets="all" Condition="'$(FeatureReportFileAccesses)' == 'true'" />
   </ItemGroup>
   
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(DotNetBuildSourceOnly)' != 'true'">
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index f6c7a968081..68a6ab4f4bc 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -178,7 +178,7 @@ internal static class AvailableStaticMethods
         /// <summary>
         /// Locker to protect initialization
         /// </summary>
-        private static Object s_locker = new Object();
+        private static readonly Object s_locker = new Object();
 
         static AvailableStaticMethods()
         {
@@ -365,7 +365,7 @@ private static void InitializeAvailableMethods()
                         availableStaticMethods.TryAdd("Microsoft.Build.Utilities.ToolLocationHelper", new Tuple<string, Type>("Microsoft.Build.Utilities.ToolLocationHelper, Microsoft.Build.Utilities.Core, Version=" + MSBuildConstants.CurrentAssemblyVersion + ", Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", null));
                         availableStaticMethods.TryAdd("System.Runtime.InteropServices.RuntimeInformation", runtimeInformationType);
                         availableStaticMethods.TryAdd("System.Runtime.InteropServices.OSPlatform", osPlatformType);
-#if NET5_0_OR_GREATER
+#if NET
                         var operatingSystemType = new Tuple<string, Type>(null, typeof(OperatingSystem));
                         availableStaticMethods.TryAdd("System.OperatingSystem", operatingSystemType);
 #else
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 5c1da33c2e6..f982a2c84e5 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -2206,6 +2206,12 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Project {0} specifies 'TargetFramework(s)' property '{1}', which does not use the .NET SDK. Those properties are not understood by projects that import C# targets directly.</value>
     <comment>Terms in quotes are not to be translated.</comment>
   </data>
+  <data name="BuildCheck_BC0109_Title" xml:space="preserve">
+    <value>The 'Exec' task should not be used to build a project.</value>
+  </data>
+  <data name="BuildCheck_BC0109_MessageFmt" xml:space="preserve">
+    <value>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</value>
+  </data>
   <data name="BuildCheck_BC0201_Title" xml:space="preserve">
     <value>A property that is accessed should be declared first.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 23718d3e688..fdc0d9224ef 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Vlastnosti TargetFramework a TargetFrameworks se nedodržují a neměly by se zadává v projektech, které nepoužívají sadu .NET SDK.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">K vlastnosti: {0} bylo přistupováno, ale nebyla nikdy inicializována.</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">Obnovení dokončeno ({0}s)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">Obnoví se {0} za {1}s</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 52ede81e06e..fa64d002e08 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Die Eigenschaften "TargetFramework" und "TargetFrameworks" werden nicht berücksichtigt und sollten nicht in Projekten angegeben werden, die nicht das .NET SDK verwenden.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Auf die Eigenschaft „{0}“ wurde zugegriffen, sie wurde jedoch nie initialisiert.</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">Wiederherstellung abgeschlossen ({0}s)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">Wiederherstellen von {0} in {1}s</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 5db148126f2..1c2e01f49fb 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Las propiedades "TargetFramework" y "TargetFrameworks" no se respetan y no deben especificarse en proyectos que no usen el SDK de .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Propiedad: se obtuvo acceso a "{0}", pero nunca se inicializó.</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">Restauración completada ({0}s)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">Restaurar {0} en {1}s</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index e1c2d281686..37cfcf09db4 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Les propriétés 'TargetFramework' et 'TargetFrameworks' ne sont pas respectées et ne doivent pas être spécifiées dans les projets qui n’utilisent pas le SDK .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Propriété : « {0} » a été consultée, mais elle n'a jamais été initialisée.</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">Restauration terminée ({0}s)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">Restaurer {0} en {1}s</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index a56135cf0ca..ba73ca5de64 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Le proprietà 'TargetFramework' e 'TargetFrameworks' non vengono rispettate e non devono essere specificate nei progetti che non usano .NET SDK.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">È stato eseguito l'accesso alla proprietà '{0}', ma non è mai stata inizializzata.</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">Ripristino completato ({0})</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">Ripristinare {0} in {1}s</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index b786b578fb1..653325c229e 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -221,6 +221,16 @@
         <target state="translated">'TargetFramework' プロパティと 'TargetFrameworks' プロパティは優先されないため、.NET SDK を使用しないプロジェクトでは指定しないでください。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">プロパティ: '{0}' にアクセスしましたが、初期化されませんでした。</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">復元が完了しました ({0} 秒)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">{1} 秒後に {0} を復元する</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 55f46f6ed21..36d3619b3c4 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -221,6 +221,16 @@
         <target state="translated">'TargetFramework' 및 'TargetFrameworks' 속성은 사용되지 않으며 .NET SDK를 사용하지 않는 프로젝트에서 지정해서는 안 됩니다.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">속성: '{0}'에 액세스했지만 초기화되지 않았습니다.</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">복원 완료({0}초)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">{0} 복원({1}초)</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 0737170e872..ce4f069806d 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Właściwości "TargetFramework" i "TargetFrameworks" nie są respektowane i nie należy ich określać w projektach, w których nie jest używany zestaw .NET SDK.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Właściwość: uzyskano dostęp do „{0}”, ale nigdy nie dokonano inicjacji.</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">Zakończono przywracanie ({0}s)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">Przywróć {0} w {1}s</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 0de19d5395a..e8c8c169c30 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -221,6 +221,16 @@
         <target state="translated">As propriedades 'TargetFramework' e 'TargetFrameworks' não são respeitadas e não devem ser especificadas em projetos que não usam o SDK do .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Propriedade: "{0}" foi acessada, mas nunca foi inicializada.</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">Restauração concluída ({0}s)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">Restaurar {0} em {1}s</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index d78406dc81a..112294b9c8d 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -221,6 +221,16 @@
         <target state="translated">Свойства TargetFramework и TargetFrameworks не учитываются и не должны указываться в проектах, не использующих пакет SDK для .NET.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">Свойство: к "{0}" получен доступ, но он не инициализирован.</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">Восстановление завершено ({0} с)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">Восстановление {0} через {1} с</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 799888b8944..5350541f5aa 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -221,6 +221,16 @@
         <target state="translated">'TargetFramework' ve 'TargetFrameworks' özellikleri dikkate alınmaz ve .NET SDK kullanmayan projelerde belirtilmeli.</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">'{0}' özelliğine erişildi, ancak hiç başlatılmadı.</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">Geri yükleme tamamlandı ({0}sn)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">{1}sn içinde {0} geri yükle</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 205edeafd1f..2a29f9c1660 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -221,6 +221,16 @@
         <target state="translated">不考虑 “TargetFramework” 和 “TargetFrameworks” 属性，不应在不使用 .NET SDK 的项目中指定这些属性。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">已访问属性“{0}”，但从未将其初始化过。</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">还原完成({0})</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">在 {1} 秒内还原 {0}</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 3ce2e7ec18a..1e76b329584 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -221,6 +221,16 @@
         <target state="translated">未遵守 『TargetFramework』 和 『TargetFrameworks』 屬性，且不應在未使用 .NET SDK 的專案中指定。</target>
         <note>Terms in quotes are not to be translated.</note>
       </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_MessageFmt">
+        <source>Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</source>
+        <target state="new">Task {0} from project {1} builds a project using the {2} CLI. The MSBuild task should be used instead.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="BuildCheck_BC0109_Title">
+        <source>The 'Exec' task should not be used to build a project.</source>
+        <target state="new">The 'Exec' task should not be used to build a project.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="BuildCheck_BC0201_MessageFmt">
         <source>Property: '{0}' was accessed, but it was never initialized.</source>
         <target state="translated">已存取屬性: '{0}'，但從未初始化。</target>
@@ -801,7 +811,7 @@
       </trans-unit>
       <trans-unit id="RestoreComplete">
         <source>Restore complete ({0}s)</source>
-        <target state="new">Restore complete ({0}s)</target>
+        <target state="translated">還原完成 ({0} 秒)</target>
         <note>
       {0}: duration in seconds with 1 decimal point
       's' should reflect the localized abbreviation for seconds
@@ -809,7 +819,7 @@
       </trans-unit>
       <trans-unit id="RestoreCompleteWithMessage">
         <source>Restore {0} in {1}s</source>
-        <target state="new">Restore {0} in {1}s</target>
+        <target state="translated">在 {1} 秒內還原 {0}</target>
         <note>
       Restore summary when finished with warning or error
       {0}: BuildResult_X (below)
diff --git a/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs b/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs
index 8d4832cd374..b028dd4b7fa 100644
--- a/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs
+++ b/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs
@@ -3,10 +3,8 @@
 
 using System;
 using System.Linq;
-using System.Text.Json;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
-using System.IO;
 
 namespace Microsoft.Build.TelemetryInfra;
 
diff --git a/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs b/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs
index 58ea242088b..717846204eb 100644
--- a/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs
+++ b/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs
@@ -4,7 +4,6 @@
 using System;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 
@@ -75,7 +74,7 @@ private static TaskOrTargetTelemetryKey GetKey(string name, bool isCustom, bool
         public void FinalizeProcessing(LoggingContext loggingContext)
         {
             WorkerNodeTelemetryEventArgs telemetryArgs = new(_workerNodeTelemetryData)
-                { BuildEventContext = loggingContext.BuildEventContext };
+            { BuildEventContext = loggingContext.BuildEventContext };
             loggingContext.LogBuildEvent(telemetryArgs);
         }
     }
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 4dbd13ede6f..270938a073a 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
@@ -12,8 +13,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Internal
 {
     internal static class EngineFileUtilities
@@ -22,7 +21,7 @@ internal static class EngineFileUtilities
 
         // Regexes for wildcard filespecs that should not get expanded
         // By default all wildcards are expanded.
-        private static List<Regex> s_lazyWildCardExpansionRegexes;
+        private static List<Regex>? s_lazyWildCardExpansionRegexes;
 
         static EngineFileUtilities()
         {
@@ -59,8 +58,8 @@ internal static void CaptureLazyWildcardRegexes()
         internal static string[] GetFileListUnescaped(
             string directoryEscaped,
             string filespecEscaped,
-            object loggingMechanism = null,
-            IElementLocation excludeLocation = null)
+            object? loggingMechanism = null,
+            IElementLocation? excludeLocation = null)
         {
             return GetFileList(
                 directoryEscaped,
@@ -100,17 +99,17 @@ internal static string[] GetFileListUnescaped(
         /// for the Exclude attribute after detecting a drive enumerating wildcard.</param>
         /// <returns>Array of file paths, escaped.</returns>
         internal static string[] GetFileListEscaped(
-            string directoryEscaped,
+            string? directoryEscaped,
             string filespecEscaped,
-            IEnumerable<string> excludeSpecsEscaped = null,
+            IEnumerable<string>? excludeSpecsEscaped = null,
             bool forceEvaluate = false,
-            FileMatcher fileMatcher = null,
-            object loggingMechanism = null,
-            IElementLocation includeLocation = null,
-            IElementLocation excludeLocation = null,
-            IElementLocation importLocation = null,
-            BuildEventContext buildEventContext = null,
-            string buildEventFileInfoFullPath = null,
+            FileMatcher? fileMatcher = null,
+            object? loggingMechanism = null,
+            IElementLocation? includeLocation = null,
+            IElementLocation? excludeLocation = null,
+            IElementLocation? importLocation = null,
+            BuildEventContext? buildEventContext = null,
+            string? buildEventFileInfoFullPath = null,
             bool disableExcludeDriveEnumerationWarning = false)
         {
             return GetFileList(
@@ -171,18 +170,18 @@ internal static bool FilespecHasWildcards(string filespecEscaped)
         /// for the Exclude attribute after detecting a drive enumerating wildcard.</param>
         /// <returns>Array of file paths.</returns>
         private static string[] GetFileList(
-            string directoryEscaped,
-            string filespecEscaped,
+            string? directoryEscaped,
+            string? filespecEscaped,
             bool returnEscaped,
             bool forceEvaluateWildCards,
-            IEnumerable<string> excludeSpecsEscaped,
+            IEnumerable<string>? excludeSpecsEscaped,
             FileMatcher fileMatcher,
-            object loggingMechanism = null,
-            IElementLocation includeLocation = null,
-            IElementLocation excludeLocation = null,
-            IElementLocation importLocation = null,
-            BuildEventContext buildEventContext = null,
-            string buildEventFileInfoFullPath = null,
+            object? loggingMechanism = null,
+            IElementLocation? includeLocation = null,
+            IElementLocation? excludeLocation = null,
+            IElementLocation? importLocation = null,
+            BuildEventContext? buildEventContext = null,
+            string? buildEventFileInfoFullPath = null,
             bool disableExcludeDriveEnumerationWarning = false)
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
@@ -286,7 +285,7 @@ private static string[] GetFileList(
                         default:
                             throw new InternalErrorException(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                                 "UnknownLoggingType",
-                                loggingMechanism.GetType(),
+                                loggingMechanism?.GetType(),
                                 nameof(GetFileList)));
                     }
                 }
@@ -327,7 +326,7 @@ private static string[] GetFileList(
                         default:
                             throw new InternalErrorException(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                                 "UnknownLoggingType",
-                                loggingMechanism.GetType(),
+                                loggingMechanism?.GetType(),
                                 nameof(GetFileList)));
                     }
                 }
@@ -338,10 +337,10 @@ private static string[] GetFileList(
                     // as a relative path, we will get back a bunch of relative paths.
                     // If the filespec started out as an absolute path, we will get
                     // back a bunch of absolute paths
-                    (fileList, _, _, string globFailure) = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
+                    (fileList, _, _, string? globFailure) = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
 
-                    // log globing failure with the present logging mechanism
-                    if (globFailure != null)
+                    // log globing failure with the present logging mechanism, skip if there is no logging mechanism
+                    if (globFailure != null && loggingMechanism != null)
                     {
                         switch (loggingMechanism)
                         {
@@ -388,7 +387,7 @@ private static string[] GetFileList(
             return fileList;
         }
 
-        private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLoggingContext targetLoggingContext, IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, bool disableExcludeDriveEnumerationWarning, string fileSpec)
+        private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLoggingContext targetLoggingContext, IElementLocation? includeLocation, IElementLocation? excludeLocation, bool excludeFileSpecIsEmpty, bool disableExcludeDriveEnumerationWarning, string fileSpec)
         {
             // Both condition lines are necessary to skip for the first GetFileListEscaped call
             // and reach for the GetFileListUnescaped call when the wildcarded Exclude attribute results
@@ -404,7 +403,7 @@ private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLog
                         fileSpec,
                         XMakeAttributes.exclude,
                         XMakeElements.itemGroup,
-                        excludeLocation.LocationString);
+                        excludeLocation?.LocationString ?? "");
             }
 
             // Both conditions are necessary to reach for both GetFileListEscaped calls
@@ -421,7 +420,7 @@ private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLog
             }
         }
 
-        private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService loggingService, IElementLocation includeLocation, BuildEventContext buildEventContext, string buildEventFileInfoFullPath, string filespecUnescaped)
+        private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService loggingService, IElementLocation? includeLocation, BuildEventContext? buildEventContext, string? buildEventFileInfoFullPath, string filespecUnescaped)
         {
             if (buildEventContext != null && includeLocation != null)
             {
@@ -437,7 +436,7 @@ private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService
             }
         }
 
-        private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(EvaluationLoggingContext evaluationLoggingContext, IElementLocation importLocation, IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
+        private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(EvaluationLoggingContext evaluationLoggingContext, IElementLocation? importLocation, IElementLocation? includeLocation, IElementLocation? excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
         {
             if (importLocation != null)
             {
@@ -468,7 +467,7 @@ private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(Evalu
             }
         }
 
-        private static void ThrowDriveEnumerationExceptionWithTargetLoggingContext(IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
+        private static void ThrowDriveEnumerationExceptionWithTargetLoggingContext(IElementLocation? includeLocation, IElementLocation? excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
         {
             // The first condition is necessary to reach for both GetFileListEscaped calls
             // whenever the wildcarded Include attribute results in drive enumeration, and
@@ -501,7 +500,7 @@ private static void ThrowDriveEnumerationExceptionWithTargetLoggingContext(IElem
             }
         }
 
-        private static void ThrowDriveEnumerationExceptionWithLoggingService(IElementLocation includeLocation, string filespecUnescaped)
+        private static void ThrowDriveEnumerationExceptionWithLoggingService(IElementLocation? includeLocation, string filespecUnescaped)
         {
             ProjectErrorUtilities.ThrowInvalidProject(
                 includeLocation,
@@ -509,10 +508,10 @@ private static void ThrowDriveEnumerationExceptionWithLoggingService(IElementLoc
                 filespecUnescaped,
                 XMakeAttributes.include,
                 XMakeElements.itemGroup,
-                includeLocation.LocationString);
+                includeLocation?.LocationString ?? "");
         }
 
-        private static void ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(IElementLocation importLocation, IElementLocation includeLocation, IElementLocation excludeLocation, string filespecUnescaped, string fileSpec, bool excludeFileSpecIsEmpty)
+        private static void ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(IElementLocation? importLocation, IElementLocation? includeLocation, IElementLocation? excludeLocation, string filespecUnescaped, string fileSpec, bool excludeFileSpecIsEmpty)
         {
             if (importLocation != null)
             {
@@ -565,7 +564,7 @@ private static bool IsValidExclude(string exclude)
 
         private static List<Regex> PopulateRegexFromEnvironment()
         {
-            string wildCards = Environment.GetEnvironmentVariable("MsBuildSkipEagerWildCardEvaluationRegexes");
+            string? wildCards = Environment.GetEnvironmentVariable("MsBuildSkipEagerWildCardEvaluationRegexes");
             if (string.IsNullOrEmpty(wildCards))
             {
                 return new List<Regex>(0);
@@ -590,6 +589,8 @@ private static List<Regex> PopulateRegexFromEnvironment()
 
         private static bool MatchesLazyWildcard(string fileSpec)
         {
+            Debug.Assert(s_lazyWildCardExpansionRegexes is not null, $"If the user provided lazy wildcard regexes, {nameof(s_lazyWildCardExpansionRegexes)} should be populated");
+
             return _regexMatchCache.Value.GetOrAdd(fileSpec, file => s_lazyWildCardExpansionRegexes.Any(regex => regex.IsMatch(fileSpec)));
         }
 
@@ -601,7 +602,7 @@ private static bool MatchesLazyWildcard(string fileSpec)
         /// <param name="filespecsEscaped"></param>
         /// <param name="currentDirectory"></param>
         /// <returns>A Func that will return true IFF its argument matches any of the specified filespecs.</returns>
-        internal static Func<string, bool> GetFileSpecMatchTester(IList<string> filespecsEscaped, string currentDirectory)
+        internal static Func<string, bool> GetFileSpecMatchTester(IList<string> filespecsEscaped, string? currentDirectory)
         {
             var matchers = filespecsEscaped
                 .Select(fs => new Lazy<FileSpecMatcherTester>(() => FileSpecMatcherTester.Parse(currentDirectory, fs)))
diff --git a/src/Build/Utilities/NuGetFrameworkWrapper.cs b/src/Build/Utilities/NuGetFrameworkWrapper.cs
index 4e1f865bbae..0332e0f7b61 100644
--- a/src/Build/Utilities/NuGetFrameworkWrapper.cs
+++ b/src/Build/Utilities/NuGetFrameworkWrapper.cs
@@ -3,12 +3,13 @@
 
 using System;
 using System.Collections.Generic;
+#if FEATURE_APPDOMAIN
 using System.Globalization;
+#endif
 using System.IO;
 using System.Linq;
 using System.Reflection;
 using System.Text;
-
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index b12e865dfd1..ba17560035f 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -125,21 +125,19 @@ public static SimpleVersion Parse(string input)
             return new SimpleVersion(major, minor, build, revision);
         }
 
-        private static readonly char[] s_semverSeparators = ['-', '+'];
-
         private static ReadOnlySpan<char> RemoveTrivia(string input)
         {
             // Ignore leading/trailing whitespace in input.
             ReadOnlySpan<char> span = input.AsSpan().Trim();
 
             // Ignore a leading "v".
-            if (span.Length > 0 && (span[0] == 'v' || span[0] == 'V'))
+            if (span.Length > 0 && (span[0] is 'v' or 'V'))
             {
                 span = span.Slice(1);
             }
 
             // Ignore semver separator and anything after.
-            int separatorIndex = span.IndexOfAny(s_semverSeparators);
+            int separatorIndex = span.IndexOfAny('-', '+');
             if (separatorIndex >= 0)
             {
                 span = span.Slice(0, separatorIndex);
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index 3e032c61c9c..cf5b6ae383e 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -7,14 +7,13 @@
 using System.Diagnostics;
 using System.IO;
 using System.Linq;
+using System.Text;
 using System.Text.RegularExpressions;
 using System.Xml;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Toolset = Microsoft.Build.Evaluation.Toolset;
 using XmlElementWithLocation = Microsoft.Build.Construction.XmlElementWithLocation;
@@ -26,7 +25,7 @@ namespace Microsoft.Build.Internal
     /// <summary>
     /// This class contains utility methods for the MSBuild engine.
     /// </summary>
-    internal static class Utilities
+    internal static partial class Utilities
     {
         /// <summary>
         /// Save off the contents of the environment variable that specifies whether we should treat higher toolsversions as the current
@@ -81,7 +80,7 @@ internal static void SetXmlNodeInnerContents(XmlElementWithLocation node, string
         {
             ErrorUtilities.VerifyThrow(s != null, "Need value to set.");
 
-            if (s.IndexOf('<') != -1)
+            if (s.Contains('<'))
             {
                 // If the value looks like it probably contains XML markup ...
                 try
@@ -295,7 +294,12 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
         }
 
         // used to find the xmlns attribute
-        private static readonly Regex s_xmlnsPattern = new Regex("xmlns=\"[^\"]*\"\\s*");
+#if NET
+        [GeneratedRegex("xmlns=\"[^\"]*\"\\s*")]
+        private static partial Regex XmlnsPattern { get; }
+#else
+        private static Regex XmlnsPattern { get; } = new Regex("xmlns=\"[^\"]*\"\\s*");
+#endif
 
         /// <summary>
         /// Removes the xmlns attribute from an XML string.
@@ -304,7 +308,7 @@ private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLe
         /// <returns>The modified XML string.</returns>
         internal static string RemoveXmlNamespace(string xml)
         {
-            return s_xmlnsPattern.Replace(xml, String.Empty);
+            return XmlnsPattern.Replace(xml, String.Empty);
         }
 
         /// <summary>
@@ -312,19 +316,19 @@ internal static string RemoveXmlNamespace(string xml)
         /// </summary>
         internal static string CreateToolsVersionListString(IEnumerable<Toolset> toolsets)
         {
-            string toolsVersionList = String.Empty;
+            StringBuilder sb = StringBuilderCache.Acquire();
+
             foreach (Toolset toolset in toolsets)
             {
-                toolsVersionList += "\"" + toolset.ToolsVersion + "\", ";
-            }
+                if (sb.Length != 0)
+                {
+                    sb.Append(", ");
+                }
 
-            // Remove trailing comma and space
-            if (toolsVersionList.Length > 0)
-            {
-                toolsVersionList = toolsVersionList.Substring(0, toolsVersionList.Length - 2);
+                sb.Append('"').Append(toolset.ToolsVersion).Append('"');
             }
 
-            return toolsVersionList;
+            return StringBuilderCache.GetStringAndRelease(sb);
         }
 
         /// <summary>
@@ -613,19 +617,6 @@ public static IEnumerable<T> Values<T>(this IEnumerable<KeyValuePair<string, T>>
             }
         }
 
-        public static IEnumerable<T> ToEnumerable<T>(this IEnumerator<T> enumerator)
-        {
-            while (enumerator.MoveNext())
-            {
-                yield return enumerator.Current;
-            }
-        }
-
-        public static T[] ToArray<T>(this IEnumerator<T> enumerator)
-        {
-            return enumerator.ToEnumerable().ToArray();
-        }
-
         /// <summary>
         /// Iterates through the nongeneric enumeration and provides generic strong-typed enumeration of properties.
         /// </summary>
diff --git a/src/Build/Xml/ProjectXmlUtilities.cs b/src/Build/Xml/ProjectXmlUtilities.cs
index e555da0aae3..43672a07329 100644
--- a/src/Build/Xml/ProjectXmlUtilities.cs
+++ b/src/Build/Xml/ProjectXmlUtilities.cs
@@ -6,7 +6,6 @@
 using System.IO;
 using System.Xml;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.BuildException;
 using Microsoft.Build.Shared;
 
diff --git a/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs b/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
index a02eb1847c7..8315825e862 100644
--- a/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
+++ b/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
@@ -1,11 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Xunit;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using System;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Shouldly;
-using System;
+using Xunit;
 
 namespace Microsoft.Build.BuildCheck.UnitTests;
 
diff --git a/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs b/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
index 8033a91064b..6de3c3f6432 100644
--- a/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
+++ b/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
@@ -2,8 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Collections.Generic;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Shouldly;
 using Xunit;
 
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
index 53b7ba1b7b3..776109be948 100644
--- a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -5,8 +5,8 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using Xunit;
diff --git a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
index 7e7953b6006..29880b5a7f2 100644
--- a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
+++ b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
@@ -1,13 +1,10 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.BuildCheck.Checks;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Shouldly;
 using Xunit;
 
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 4b5a516e649..08e3fccb43f 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -12,7 +12,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
-using Microsoft.VisualStudio.TestPlatform.Utilities;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
diff --git a/src/BuildCheck.UnitTests/ExecCliBuildCheck_Tests.cs b/src/BuildCheck.UnitTests/ExecCliBuildCheck_Tests.cs
new file mode 100644
index 00000000000..edbb0e6bdc9
--- /dev/null
+++ b/src/BuildCheck.UnitTests/ExecCliBuildCheck_Tests.cs
@@ -0,0 +1,104 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using System.Runtime.InteropServices;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests
+{
+    public sealed class ExecCliBuildCheck_Tests
+    {
+        private const int MaxStackSizeWindows = 1024 * 1024; // 1 MB
+        private const int MaxStackSizeLinux = 1024 * 1024 * 8; // 8 MB
+
+        private readonly ExecCliBuildCheck _check;
+
+        private readonly MockBuildCheckRegistrationContext _registrationContext;
+
+        public static TheoryData<string?> BuildCommandTestData => new TheoryData<string?>(
+            "dotnet build",
+            "dotnet build&dotnet build",
+            "dotnet     build",
+            "dotnet clean",
+            "dotnet msbuild",
+            "dotnet restore",
+            "dotnet publish",
+            "dotnet pack",
+            "dotnet test",
+            "dotnet vstest",
+            "dotnet build -p:Configuration=Release",
+            "dotnet build /t:Restore;Clean",
+            "dotnet build&some command",
+            "some command&dotnet build&some other command",
+            "some command&dotnet build",
+            "some command&amp;dotnet build&amp;some other command",
+            "msbuild",
+            "msbuild /t:Build",
+            "msbuild --t:Restore;Clean",
+            "nuget restore",
+            "dotnet run --project project.SLN",
+            "dotnet run project.csproj",
+            "dotnet run project.proj",
+            "dotnet run",
+            string.Join(";", new string('a', 1025), "dotnet build", new string('a', 1025)),
+            string.Join(";", new string('a', RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? MaxStackSizeWindows * 2 : MaxStackSizeLinux * 2), "dotnet build"));
+
+        public static TheoryData<string?> NonBuildCommandTestData => new TheoryData<string?>(
+            "dotnet help",
+            "where dotnet",
+            "where msbuild",
+            "where nuget",
+            "dotnet bin/net472/project.dll",
+            string.Empty,
+            null,
+            new string('a', RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? MaxStackSizeWindows * 2 : MaxStackSizeLinux * 2));
+
+        public ExecCliBuildCheck_Tests()
+        {
+            _check = new ExecCliBuildCheck();
+            _registrationContext = new MockBuildCheckRegistrationContext();
+            _check.RegisterActions(_registrationContext);
+        }
+
+        [Theory]
+        [MemberData(nameof(BuildCommandTestData))]
+        public void ExecTask_WithCommandExecutingBuild_ShouldShowWarning(string? command)
+        {
+            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Exec", new Dictionary<string, TaskInvocationCheckData.TaskParameter>
+            {
+                { "Command", new TaskInvocationCheckData.TaskParameter(command, IsOutput: false) },
+            }));
+
+            _registrationContext.Results.Count.ShouldBe(1);
+            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0109");
+        }
+
+        [Theory]
+        [MemberData(nameof(NonBuildCommandTestData))]
+        public void ExecTask_WithCommandNotExecutingBuild_ShouldNotShowWarning(string? command)
+        {
+            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Exec", new Dictionary<string, TaskInvocationCheckData.TaskParameter>
+            {
+                { "Command", new TaskInvocationCheckData.TaskParameter(command, IsOutput: false) },
+            }));
+
+            _registrationContext.Results.Count.ShouldBe(0);
+        }
+
+        private TaskInvocationCheckData MakeTaskInvocationData(string taskName, Dictionary<string, TaskInvocationCheckData.TaskParameter> parameters)
+        {
+            string projectFile = Framework.NativeMethods.IsWindows ? @"C:\fake\project.proj" : "/fake/project.proj";
+            return new TaskInvocationCheckData(
+                projectFile,
+                null,
+                Construction.ElementLocation.EmptyLocation,
+                taskName,
+                projectFile,
+                parameters);
+        }
+    }
+}
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 7cb6452f124..440a60cc86e 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -26,7 +26,8 @@
   <ItemGroup>
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorOnRegisteredAction.cs b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorOnRegisteredAction.cs
index 3dc02bb7cca..ad031e74bfd 100644
--- a/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorOnRegisteredAction.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/ErrorCustomCheck/ErrorOnRegisteredAction.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 
 namespace ErrorCustomCheck
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs
index e2bcfb57a88..1cd1db13df9 100644
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs
@@ -1,8 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Collections.Generic;
-
 namespace InvalidCustomCheck
 {
     public sealed class InvalidCheck
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 10f4321b686..73b91fe6c96 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -98,6 +98,7 @@
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(GenerateReferenceAssemblySource)' != 'true'">
+    <NoWarn>$(NoWarn);IDE0005</NoWarn>
     <GenerateDocumentationFile>false</GenerateDocumentationFile>
     <DocumentationFile/>
   </PropertyGroup>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index fc6affaa7d2..91e186d7fe3 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -47,10 +47,6 @@
   </PropertyGroup>
 
   <ItemGroup Condition="'$(IsUnitTestProject)' == 'true'">
-    <!-- Force updated reference to this package because xunit and shouldly
-         are netstandard1.6 and transitively bring in an old reference -->
-    <PackageReference Include="System.Security.Cryptography.X509Certificates" />
-
     <!-- As of 17.3, one TF of Microsoft.NET.Test.Sdk depends on Newtonsoft.Json
          9.0.1, causing it to be downloaded and flagged by component governance -->
     <PackageReference Include="Newtonsoft.Json" />
diff --git a/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs b/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs
index 9448bfbb743..4fa0d615019 100644
--- a/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildCanceledEventArgs_Tests.cs
@@ -2,11 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Shouldly;
 using Xunit;
 
diff --git a/src/Framework.UnitTests/BuildCheckTracingEventArgs_Tests.cs b/src/Framework.UnitTests/BuildCheckTracingEventArgs_Tests.cs
index b180fe6f631..9e59a4b575e 100644
--- a/src/Framework.UnitTests/BuildCheckTracingEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildCheckTracingEventArgs_Tests.cs
@@ -4,9 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Experimental.BuildCheck;
 using Shouldly;
 using Xunit;
diff --git a/src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs b/src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
index 4e9c9dea78e..8efe355f891 100644
--- a/src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildSubmissionStartedEventArgs_Tests.cs
@@ -4,9 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Shouldly;
 using Xunit;
 
diff --git a/src/Framework.UnitTests/EventArgs_Tests.cs b/src/Framework.UnitTests/EventArgs_Tests.cs
index 04a1c9e61ea..451ec654a16 100644
--- a/src/Framework.UnitTests/EventArgs_Tests.cs
+++ b/src/Framework.UnitTests/EventArgs_Tests.cs
@@ -2,8 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.IO;
-using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Framework;
 using Shouldly;
 using Xunit;
diff --git a/src/Framework.UnitTests/FileClassifier_Tests.cs b/src/Framework.UnitTests/FileClassifier_Tests.cs
index b0441062a44..492655cae93 100644
--- a/src/Framework.UnitTests/FileClassifier_Tests.cs
+++ b/src/Framework.UnitTests/FileClassifier_Tests.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.IO;
-using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
 
diff --git a/src/Framework.UnitTests/GeneratedFileUsedEventArgs_Tests.cs b/src/Framework.UnitTests/GeneratedFileUsedEventArgs_Tests.cs
index 576c37e265f..5cf9cda8110 100644
--- a/src/Framework.UnitTests/GeneratedFileUsedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/GeneratedFileUsedEventArgs_Tests.cs
@@ -2,11 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Shouldly;
 using Xunit;
 
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index f5931d3d9af..aba4ae6c2d2 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -8,11 +8,12 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="FluentAssertions" />
+    <PackageReference Include="AwesomeAssertions" />
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" PrivateAssets="all" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Framework.UnitTests/OperatingSystem_Tests.cs b/src/Framework.UnitTests/OperatingSystem_Tests.cs
index 4fbaf7af615..d001351b14b 100644
--- a/src/Framework.UnitTests/OperatingSystem_Tests.cs
+++ b/src/Framework.UnitTests/OperatingSystem_Tests.cs
@@ -4,7 +4,6 @@
 using Shouldly;
 
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 namespace Microsoft.Build.Framework.UnitTests
 {
diff --git a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
index 7eb7895b2df..4968243235a 100644
--- a/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/ProjectStartedEventArgs_Tests.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections;
 
 using Microsoft.Build.Framework;
 using Shouldly;
diff --git a/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs b/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs
index bf5303e2c09..d6d0800ca60 100644
--- a/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs
@@ -1,12 +1,10 @@
-﻿﻿// Licensed to the .NET Foundation under one or more agreements.
+﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
+using Microsoft.Build.Framework.Telemetry;
 using Shouldly;
 using Xunit;
 using Microsoft.Build.Framework.Telemetry;
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index c302b537038..ecf16907307 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -6,7 +6,6 @@
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
-using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.BuildException;
 
diff --git a/src/Framework/BuildCanceledEventArgs.cs b/src/Framework/BuildCanceledEventArgs.cs
index 6209b398156..89ea2f79ccf 100644
--- a/src/Framework/BuildCanceledEventArgs.cs
+++ b/src/Framework/BuildCanceledEventArgs.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.IO;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/BuildCheck/BuildCheckTracingData.cs b/src/Framework/BuildCheck/BuildCheckTracingData.cs
index dc3ef3cb227..27716da0960 100644
--- a/src/Framework/BuildCheck/BuildCheckTracingData.cs
+++ b/src/Framework/BuildCheck/BuildCheckTracingData.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
diff --git a/src/Framework/BuildCheck/EnumerableExtensions.cs b/src/Framework/BuildCheck/EnumerableExtensions.cs
index d74136269d9..025c2edfb98 100644
--- a/src/Framework/BuildCheck/EnumerableExtensions.cs
+++ b/src/Framework/BuildCheck/EnumerableExtensions.cs
@@ -3,7 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+#if !NET
 using System.Collections.ObjectModel;
+#endif
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
diff --git a/src/Framework/BuildErrorEventArgs.cs b/src/Framework/BuildErrorEventArgs.cs
index 97cb5b1f1df..052d602f63d 100644
--- a/src/Framework/BuildErrorEventArgs.cs
+++ b/src/Framework/BuildErrorEventArgs.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 using System.IO;
 using Microsoft.Build.Shared;
 
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index e7d5868c1d8..1e1264246ec 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
diff --git a/src/Framework/BuildMessageEventArgs.cs b/src/Framework/BuildMessageEventArgs.cs
index 20a1898bea2..cab1d21892b 100644
--- a/src/Framework/BuildMessageEventArgs.cs
+++ b/src/Framework/BuildMessageEventArgs.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 using System.IO;
 using System.Runtime.Serialization;
 using Microsoft.Build.Shared;
diff --git a/src/Framework/BuildRequestDataFlags.cs b/src/Framework/BuildRequestDataFlags.cs
index 8a0c1f585f2..f125dc5f10b 100644
--- a/src/Framework/BuildRequestDataFlags.cs
+++ b/src/Framework/BuildRequestDataFlags.cs
@@ -2,10 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 // Note: Namespace is within Build.Execution for type forwarding to work correctly
 namespace Microsoft.Build.Execution
diff --git a/src/Framework/BuildSubmissionStartedEventArgs.cs b/src/Framework/BuildSubmissionStartedEventArgs.cs
index 385d3d342c5..6a1712abf83 100644
--- a/src/Framework/BuildSubmissionStartedEventArgs.cs
+++ b/src/Framework/BuildSubmissionStartedEventArgs.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
diff --git a/src/Framework/BuildWarningEventArgs.cs b/src/Framework/BuildWarningEventArgs.cs
index 543281e8c26..5e4d11acd39 100644
--- a/src/Framework/BuildWarningEventArgs.cs
+++ b/src/Framework/BuildWarningEventArgs.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 using System.IO;
 using Microsoft.Build.Shared;
 
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 8e58f93835c..3bbcfe6f6f2 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using System.Linq;
 
 #nullable disable
diff --git a/src/Framework/CriticalBuildMessageEventArgs.cs b/src/Framework/CriticalBuildMessageEventArgs.cs
index 613240347c4..07488b90833 100644
--- a/src/Framework/CriticalBuildMessageEventArgs.cs
+++ b/src/Framework/CriticalBuildMessageEventArgs.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 
 #nullable disable
 
diff --git a/src/Framework/CriticalTaskException.cs b/src/Framework/CriticalTaskException.cs
index 6bd36d576f6..e9509888655 100644
--- a/src/Framework/CriticalTaskException.cs
+++ b/src/Framework/CriticalTaskException.cs
@@ -2,10 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Framework.BuildException;
 
 namespace Microsoft.Build.Framework
diff --git a/src/Framework/CustomBuildEventArgs.cs b/src/Framework/CustomBuildEventArgs.cs
index 85d59389d3f..19f3f844776 100644
--- a/src/Framework/CustomBuildEventArgs.cs
+++ b/src/Framework/CustomBuildEventArgs.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 
 #nullable disable
 
diff --git a/src/Framework/EnvironmentVariableReadEventArgs.cs b/src/Framework/EnvironmentVariableReadEventArgs.cs
index ef5bb651404..d0bdf9f6250 100644
--- a/src/Framework/EnvironmentVariableReadEventArgs.cs
+++ b/src/Framework/EnvironmentVariableReadEventArgs.cs
@@ -1,8 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Diagnostics;
 using System.IO;
 using Microsoft.Build.Shared;
 
diff --git a/src/Framework/ExtendedBuildErrorEventArgs.cs b/src/Framework/ExtendedBuildErrorEventArgs.cs
index 54f558432b1..2ce76e0bf53 100644
--- a/src/Framework/ExtendedBuildErrorEventArgs.cs
+++ b/src/Framework/ExtendedBuildErrorEventArgs.cs
@@ -3,7 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 using System.IO;
 using Microsoft.Build.Shared;
 
diff --git a/src/Framework/ExtendedBuildWarningEventArgs.cs b/src/Framework/ExtendedBuildWarningEventArgs.cs
index 2d9a163eb15..598526c40a8 100644
--- a/src/Framework/ExtendedBuildWarningEventArgs.cs
+++ b/src/Framework/ExtendedBuildWarningEventArgs.cs
@@ -3,7 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 using System.IO;
 using Microsoft.Build.Shared;
 
diff --git a/src/Framework/Features.cs b/src/Framework/Features.cs
index ec1183c94f5..3e7518b473d 100644
--- a/src/Framework/Features.cs
+++ b/src/Framework/Features.cs
@@ -1,11 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/FileClassifier.cs b/src/Framework/FileClassifier.cs
index 648605cc33e..f6f79baafb1 100644
--- a/src/Framework/FileClassifier.cs
+++ b/src/Framework/FileClassifier.cs
@@ -9,7 +9,6 @@
 using System.Runtime.InteropServices;
 using Microsoft.Build.Shared;
 #if !RUNTIME_TYPE_NETCORE
-using System.Diagnostics;
 using System.Text.RegularExpressions;
 #endif
 
diff --git a/src/Framework/GeneratedFileUsedEventArgs.cs b/src/Framework/GeneratedFileUsedEventArgs.cs
index f64ba9521ff..9cc327831e2 100644
--- a/src/Framework/GeneratedFileUsedEventArgs.cs
+++ b/src/Framework/GeneratedFileUsedEventArgs.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.IO;
 
 namespace Microsoft.Build.Framework
diff --git a/src/Framework/InternalErrorException.cs b/src/Framework/InternalErrorException.cs
index e024e3f67a5..73180f14fb8 100644
--- a/src/Framework/InternalErrorException.cs
+++ b/src/Framework/InternalErrorException.cs
@@ -60,7 +60,7 @@ private InternalErrorException(string message, Exception innerException, bool ca
                     ? message
                     : "MSB0001: Internal MSBuild Error: " + message + (innerException == null
                         ? String.Empty
-                        : ("\n=============\n" + innerException.ToString() + "\n\n")),
+                        : $"\n=============\n{innerException}\n\n"),
                 innerException)
         {
             if (!calledFromDeserialization)
diff --git a/src/Framework/LazyFormattedBuildEventArgs.cs b/src/Framework/LazyFormattedBuildEventArgs.cs
index 209c30536d4..28598b2f1b6 100644
--- a/src/Framework/LazyFormattedBuildEventArgs.cs
+++ b/src/Framework/LazyFormattedBuildEventArgs.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 using System.Globalization;
 using System.IO;
 
@@ -193,7 +195,7 @@ private static string FormatString([StringSyntax(StringSyntaxAttribute.Composite
                     // another one, add it here.
                     if (param != null && param.ToString() == param.GetType().FullName)
                     {
-                        throw new InvalidOperationException(string.Format("Invalid type for message formatting argument, was {0}", param.GetType().FullName));
+                        throw new InvalidOperationException($"Invalid type for message formatting argument, was {param.GetType().FullName}");
                     }
                 }
 #endif
@@ -218,7 +220,7 @@ private static string FormatString([StringSyntax(StringSyntaxAttribute.Composite
                     //          Done executing task "Crash".
                     //
                     // T
-                    formatted = string.Format("\"{0}\"\n{1}", unformatted, ex.ToString());
+                    formatted = $"\"{unformatted}\"\n{ex}";
                 }
             }
 
diff --git a/src/Framework/Logging/AnsiDetector.cs b/src/Framework/Logging/AnsiDetector.cs
index 2b0c0e8b38a..6c2b09bd7a0 100644
--- a/src/Framework/Logging/AnsiDetector.cs
+++ b/src/Framework/Logging/AnsiDetector.cs
@@ -6,7 +6,6 @@
 // and from the supports-ansi project by Qingrong Ke
 // https://github.com/keqingrong/supports-ansi/blob/master/index.js
 
-using System;
 using System.Linq;
 using System.Text.RegularExpressions;
 
diff --git a/src/Framework/Logging/LoggerParametersHelper.cs b/src/Framework/Logging/LoggerParametersHelper.cs
index b4f7a843d4f..fdc615f19d4 100644
--- a/src/Framework/Logging/LoggerParametersHelper.cs
+++ b/src/Framework/Logging/LoggerParametersHelper.cs
@@ -4,9 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Framework.Logging
diff --git a/src/Framework/MetaProjectGeneratedEventArgs.cs b/src/Framework/MetaProjectGeneratedEventArgs.cs
index 1a529ed7171..79e0a68ad09 100644
--- a/src/Framework/MetaProjectGeneratedEventArgs.cs
+++ b/src/Framework/MetaProjectGeneratedEventArgs.cs
@@ -2,8 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using Microsoft.Build.Shared;
 using System.IO;
+using Microsoft.Build.Shared;
 
 #nullable disable
 
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index bbc62463b1e..352723a6e53 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -10,11 +10,14 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-using Microsoft.Build.Framework.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
 using Microsoft.Win32.SafeHandles;
 
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Framework.Logging;
+#endif
+
 using FILETIME = System.Runtime.InteropServices.ComTypes.FILETIME;
 
 #nullable disable
@@ -461,7 +464,7 @@ public SystemInformationData()
             {
                 ProcessorArchitectures processorArchitecture = ProcessorArchitectures.Unknown;
 
-#if NETCOREAPP || NETSTANDARD1_1_OR_GREATER
+#if NET || NETSTANDARD1_1_OR_GREATER
                 // Get the architecture from the runtime.
                 processorArchitecture = RuntimeInformation.OSArchitecture switch
                 {
@@ -469,13 +472,9 @@ public SystemInformationData()
                     Architecture.Arm64 => ProcessorArchitectures.ARM64,
                     Architecture.X64 => ProcessorArchitectures.X64,
                     Architecture.X86 => ProcessorArchitectures.X86,
-#if NET5_0_OR_GREATER
+#if NET
                     Architecture.Wasm => ProcessorArchitectures.WASM,
-#endif
-#if NET6_0_OR_GREATER
                     Architecture.S390x => ProcessorArchitectures.S390X,
-#endif
-#if NET7_0_OR_GREATER
                     Architecture.LoongArch64 => ProcessorArchitectures.LOONGARCH64,
                     Architecture.Armv6 => ProcessorArchitectures.ARMV6,
                     Architecture.Ppc64le => ProcessorArchitectures.PPC64LE,
@@ -1394,7 +1393,7 @@ internal static int GetParentProcessId(int processId)
                 // using (var r = FileUtilities.OpenRead("/proc/" + processId + "/stat"))
                 // and could be again when FileUtilities moves to Framework
 
-                using var fileStream = new FileStream("/proc/" + processId + "/stat", FileMode.Open, System.IO.FileAccess.Read);
+                using var fileStream = new FileStream($"/proc/{processId}/stat", FileMode.Open, System.IO.FileAccess.Read);
                 using StreamReader r = new(fileStream);
 
                 line = r.ReadLine();
@@ -1522,9 +1521,18 @@ private static unsafe int GetCurrentDirectoryWin32(int nBufferLength, char* lpBu
     [SupportedOSPlatform("windows")]
     internal static unsafe string GetFullPath(string path)
     {
-        int bufferSize = GetFullPathWin32(path, 0, null, IntPtr.Zero);
-        char* buffer = stackalloc char[bufferSize];
-        int fullPathLength = GetFullPathWin32(path, bufferSize, buffer, IntPtr.Zero);
+        char* buffer = stackalloc char[MAX_PATH];
+        int fullPathLength = GetFullPathWin32(path, MAX_PATH, buffer, IntPtr.Zero);
+
+        // if user is using long paths we could need to allocate a larger buffer
+        if (fullPathLength > MAX_PATH)
+        {
+            char* newBuffer = stackalloc char[fullPathLength];
+            fullPathLength = GetFullPathWin32(path, fullPathLength, newBuffer, IntPtr.Zero);
+
+            buffer = newBuffer;
+        }
+
         // Avoid creating new strings unnecessarily
         return AreStringsEqual(buffer, fullPathLength, path) ? path : new string(buffer, startIndex: 0, length: fullPathLength);
     }
@@ -1562,7 +1570,7 @@ private static unsafe bool AreStringsEqual(char* buffer, int len, string s)
 
         return true;
 #else
-        return MemoryExtensions.SequenceEqual(new ReadOnlySpan<char>(buffer, len), s.AsSpan());
+        return s.AsSpan().SequenceEqual(new ReadOnlySpan<char>(buffer, len));
 #endif
     }
 
diff --git a/src/Framework/OperatingSystem.cs b/src/Framework/OperatingSystem.cs
index 883ec55b924..51756afe1da 100644
--- a/src/Framework/OperatingSystem.cs
+++ b/src/Framework/OperatingSystem.cs
@@ -1,7 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-#if !NET5_0_OR_GREATER
+#if !NET
 
 using System;
 
diff --git a/src/Framework/Profiler/EvaluationIdProvider.cs b/src/Framework/Profiler/EvaluationIdProvider.cs
index 573204e1e15..76fc1b0266e 100644
--- a/src/Framework/Profiler/EvaluationIdProvider.cs
+++ b/src/Framework/Profiler/EvaluationIdProvider.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Diagnostics;
 using System.Threading;
 using Microsoft.Build.Shared;
 
diff --git a/src/Framework/ProjectImportedEventArgs.cs b/src/Framework/ProjectImportedEventArgs.cs
index 4884d1bcf23..2df59de35f3 100644
--- a/src/Framework/ProjectImportedEventArgs.cs
+++ b/src/Framework/ProjectImportedEventArgs.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 using System.IO;
 using Microsoft.Build.Shared;
 
diff --git a/src/Framework/TargetSkippedEventArgs.cs b/src/Framework/TargetSkippedEventArgs.cs
index 8536d2bec8a..6e636b4f61b 100644
--- a/src/Framework/TargetSkippedEventArgs.cs
+++ b/src/Framework/TargetSkippedEventArgs.cs
@@ -2,7 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 using System.IO;
 using Microsoft.Build.Shared;
 
diff --git a/src/Framework/Telemetry/ActivityExtensions.cs b/src/Framework/Telemetry/ActivityExtensions.cs
index aa10b1a6615..9b4e05f7c02 100644
--- a/src/Framework/Telemetry/ActivityExtensions.cs
+++ b/src/Framework/Telemetry/ActivityExtensions.cs
@@ -1,11 +1,11 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Security.Cryptography;
-using System.Text;
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+using System.Security.Cryptography;
+using System.Text;
 
 namespace Microsoft.Build.Framework.Telemetry
 {
diff --git a/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs b/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs
index 2208f4f2f5b..c0645634435 100644
--- a/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs
+++ b/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs
@@ -22,7 +22,7 @@ public void Initialize(IEventSource eventSource)
     {
         if (BuildEventRedirector != null && eventSource is IEventSource5 eventSource5)
         {
-            eventSource5.WorkerNodeTelemetryLogged += (o,e) => BuildEventRedirector.ForwardEvent(e);
+            eventSource5.WorkerNodeTelemetryLogged += (o, e) => BuildEventRedirector.ForwardEvent(e);
         }
     }
 
diff --git a/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
index 493a945a526..9c721301747 100644
--- a/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
+++ b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Collections.Generic;
 using System.Globalization;
 
diff --git a/src/Framework/Telemetry/OpenTelemetryManager.cs b/src/Framework/Telemetry/OpenTelemetryManager.cs
index bb94f630611..785c90edb42 100644
--- a/src/Framework/Telemetry/OpenTelemetryManager.cs
+++ b/src/Framework/Telemetry/OpenTelemetryManager.cs
@@ -9,10 +9,8 @@
 using OpenTelemetry.Trace;
 #endif
 using System;
-using System.Diagnostics;
-using System.Threading;
-using System.Globalization;
 using System.Runtime.CompilerServices;
+using System.Threading;
 
 namespace Microsoft.Build.Framework.Telemetry
 {
diff --git a/src/Framework/Telemetry/TaskOrTargetTelemetryKey.cs b/src/Framework/Telemetry/TaskOrTargetTelemetryKey.cs
index cc46591dc2d..5647f2fdadd 100644
--- a/src/Framework/Telemetry/TaskOrTargetTelemetryKey.cs
+++ b/src/Framework/Telemetry/TaskOrTargetTelemetryKey.cs
@@ -65,18 +65,20 @@ public TaskOrTargetTelemetryKey(string name) : this(name, false, false, false) {
     public string Name { get; }
 
     /// <summary>
-    /// Gets a value indicating whether this task/target is custom.
+    /// Indicates whether the task/target is custom.
     /// </summary>
     public bool IsCustom { get; }
 
     /// <summary>
-    /// Indicate targets/tasks sourced from NuGet cache - those can be custom or MSFT provided ones.
+    /// Indicates whether the task/target is from NuGet cache.
     /// </summary>
+    /// <remarks>Those can be custom or MSFT provided ones.</remarks>
     public bool IsNuget { get; }
 
     /// <summary>
-    /// Indicate targets/tasks generated during build - those must be hashed (as they contain paths).
+    /// Indicates whether the task/target is generated during build from a metaproject.
     /// </summary>
+    /// <remarks>Those must be hashed (as they contain paths).</remarks>
     public bool IsMetaProj { get; }
 
     public override bool Equals(object? obj)
diff --git a/src/Framework/Telemetry/WorkerNodeTelemetryEventArgs.cs b/src/Framework/Telemetry/WorkerNodeTelemetryEventArgs.cs
index a2a11f16e82..4eef343b196 100644
--- a/src/Framework/Telemetry/WorkerNodeTelemetryEventArgs.cs
+++ b/src/Framework/Telemetry/WorkerNodeTelemetryEventArgs.cs
@@ -4,7 +4,9 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+#if NETFRAMEWORK
 using Microsoft.Build.Shared;
+#endif
 
 namespace Microsoft.Build.Framework.Telemetry;
 
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 32557ee22d7..f2447e47031 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -146,6 +146,7 @@ public Traits()
 
         // for VS17.14
         public readonly bool TelemetryOptIn = IsEnvVarOneOrTrue("MSBUILD_TELEMETRY_OPTIN");
+        public readonly bool SlnParsingWithSolutionPersistenceOptIn = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILD_PARSE_SLN_WITH_SOLUTIONPERSISTENCE"));
 
         public static void UpdateFromEnvironment()
         {
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 1d116d117d2..0876e2b8eec 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -35,6 +35,9 @@
 
     <!-- Add this explicitly since it's marked as Private in MSBuild.csproj, but we need these at runtime to be like VS. -->
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
+    <!-- Remove the direct NETStandard.Library dependency when Microsoft.BuildXL.Processes stops bringing in netstandard1.x dependencies
+         or when a .NET 10 SDK is used (NuGet Package Pruning eliminates netstandard1.x dependencies). -->
+    <PackageReference Include="NETStandard.Library" VersionOverride="2.0.3" PrivateAssets="all" Condition="'$(FeatureReportFileAccesses)' == 'true'" />
   </ItemGroup>
 
   <!-- Use deps file from this project with additional dependencies listed instead of the one generated in the MSBuild project -->
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 47e9361022d..e233f7fc509 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -13,11 +13,9 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Graph;
-using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index a749bd7145f..adc194cf98e 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -11,7 +11,6 @@
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 #if NETFRAMEWORK
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index 35fa1dbb627..b54e07f48fe 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -7,8 +7,9 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Verify.Xunit" />
   </ItemGroup>
 
diff --git a/src/MSBuild.UnitTests/ValidateAssemblyLoadContext.cs b/src/MSBuild.UnitTests/ValidateAssemblyLoadContext.cs
index 7a802d191e4..ea5394f0be4 100644
--- a/src/MSBuild.UnitTests/ValidateAssemblyLoadContext.cs
+++ b/src/MSBuild.UnitTests/ValidateAssemblyLoadContext.cs
@@ -3,10 +3,10 @@
 
 #if FEATURE_ASSEMBLYLOADCONTEXT
 
+using System.Runtime.Loader;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
-using System.Runtime.Loader;
 
 #nullable disable
 
diff --git a/src/MSBuild/AutomaticEncodingRestorer.cs b/src/MSBuild/AutomaticEncodingRestorer.cs
index b5696d62ab8..b9a9c046453 100644
--- a/src/MSBuild/AutomaticEncodingRestorer.cs
+++ b/src/MSBuild/AutomaticEncodingRestorer.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using System.Runtime.InteropServices;
 using System.Security;
 using System.Text;
 
@@ -24,7 +23,7 @@ public AutomaticEncodingRestorer()
         {
             try
             {
-#if NET7_0_OR_GREATER
+#if NET
                 if (OperatingSystem.IsIOS() || OperatingSystem.IsAndroid() || OperatingSystem.IsTvOS()) // Output + Input Encoding are unavailable on these platforms per docs, and they're only available past net 5.
                 {
                     return;
@@ -32,7 +31,7 @@ public AutomaticEncodingRestorer()
 #endif
                 _originalOutputEncoding = Console.OutputEncoding;
 
-#if NET7_0_OR_GREATER
+#if NET
                 if (OperatingSystem.IsBrowser()) // Input Encoding is also unavailable in this platform. (No concern for net472 as browser is unavailable.)
                 {
                     return;
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 982999ec30f..154f1920aa5 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -5,7 +5,6 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Linq;
 using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 1f01a9043de..2edca8c339b 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -173,6 +173,10 @@
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Microsoft.BuildXL.Processes" Condition="'$(FeatureReportFileAccesses)' == 'true'" PrivateAssets="all" />
+    <!-- Remove the direct NETStandard.Library dependency when Microsoft.BuildXL.Processes stops bringing in netstandard1.x dependencies
+         or when a .NET 10 SDK is used (NuGet Package Pruning eliminates netstandard1.x dependencies). -->
+    <PackageReference Include="NETStandard.Library" VersionOverride="2.0.3" PrivateAssets="all" Condition="'$(FeatureReportFileAccesses)' == 'true'" />
+
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="System.Diagnostics.DiagnosticSource" /><!-- for consistency with Framework via transitives -->
@@ -191,10 +195,7 @@
     <Reference Include="System.Xml" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework' AND '$(DotNetBuildSourceOnly)' != 'true'">
-    <!-- Bump these to the latest version despite transitive references to older -->
-    <PackageReference Include="System.Private.Uri" PrivateAssets="all" />
-  </ItemGroup>
+
   <ItemGroup>
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" PrivateAssets="All" />
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index f862ae2adca..fbd97f6e083 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Globalization;
 using System.IO;
 using System.Reflection;
diff --git a/src/MSBuild/PerformanceLogEventListener.cs b/src/MSBuild/PerformanceLogEventListener.cs
index 6772a6aeefc..a42f05194bc 100644
--- a/src/MSBuild/PerformanceLogEventListener.cs
+++ b/src/MSBuild/PerformanceLogEventListener.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Diagnostics;
 using System.Diagnostics.Tracing;
 using System.IO;
 using System.Text;
@@ -22,7 +21,7 @@ internal struct ProviderConfiguration
             internal EventLevel Level { get; set; }
         }
 
-        private static ProviderConfiguration[] s_config =
+        private static readonly ProviderConfiguration[] s_config =
         [
             new ProviderConfiguration()
             {
@@ -82,7 +81,7 @@ internal void Initialize(string logDirectory)
             _processIDStr = EnvironmentUtilities.CurrentProcessId.ToString();
 
             // Use a GUID disambiguator to make sure that we have a unique file name.
-            string logFilePath = Path.Combine(logDirectory, $"perf-{_processIDStr}-{Guid.NewGuid().ToString("N")}.log");
+            string logFilePath = Path.Combine(logDirectory, $"perf-{_processIDStr}-{Guid.NewGuid():N}.log");
 
             Stream outputStream = new FileStream(
                 logFilePath,
@@ -143,7 +142,7 @@ protected override void OnEventWritten(EventWrittenEventArgs eventData)
                     s_builder.Clear();
                 }
 
-                s_builder.Append($"[{DateTime.UtcNow.ToString("o")}] Event={eventData.EventSource.Name}/{eventData.EventName} ProcessID={_processIDStr} ThreadID={System.Threading.Thread.CurrentThread.ManagedThreadId}\t ");
+                s_builder.Append($"[{DateTime.UtcNow:o}] Event={eventData.EventSource.Name}/{eventData.EventName} ProcessID={_processIDStr} ThreadID={Environment.CurrentManagedThreadId}\t ");
                 for (int i = 0; i < eventData.PayloadNames.Count; i++)
                 {
                     s_builder.Append($"{eventData.PayloadNames[i]}=\"{eventData.Payload[i]}\" ");
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 8bf202edc41..357cb767e84 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1777,7 +1777,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
                         ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                             "LongPaths",
                             ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
-                                "LongPaths_" + longPaths.ToString())),
+                                $"LongPaths_{longPaths}")),
                         MessageImportance.Low));
             }
 
@@ -1789,7 +1789,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
                         ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                             "SAC",
                             ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
-                                "SAC_" + SAC_State.ToString())),
+                                $"SAC_{SAC_State}")),
                         MessageImportance.Low));
             }
 
@@ -3094,7 +3094,7 @@ private static bool WarningsAsErrorsSwitchIsEmpty(CommandLineSwitches commandLin
                 return false;
             }
 
-            int indexOfColon = val.IndexOf(":");
+            int indexOfColon = val.IndexOf(':');
             return indexOfColon < 0 || indexOfColon == val.Length - 1;
         }
 
@@ -3663,13 +3663,13 @@ private static void ValidateExtensions(string[] projectExtensionsToIgnore)
                     InitializationException.VerifyThrow(extension?.Length >= 2, "InvalidExtensionToIgnore", extension);
 
                     // There is an invalid char in the extensionToIgnore.
-                    InitializationException.VerifyThrow(extension.IndexOfAny(Path.GetInvalidPathChars()) == -1, "InvalidExtensionToIgnore", extension, null, false);
+                    InitializationException.VerifyThrow(extension.AsSpan().IndexOfAny(MSBuildConstants.InvalidPathChars) < 0, "InvalidExtensionToIgnore", extension, null, false);
 
                     // There were characters before the extension.
                     InitializationException.VerifyThrow(string.Equals(extension, Path.GetExtension(extension), StringComparison.OrdinalIgnoreCase), "InvalidExtensionToIgnore", extension, null, false);
 
                     // Make sure that no wild cards are in the string because for now we don't allow wild card extensions.
-                    InitializationException.VerifyThrow(extension.IndexOfAny(s_wildcards) == -1, "InvalidExtensionToIgnore", extension, null, false);
+                    InitializationException.VerifyThrow(extension.IndexOfAny(MSBuildConstants.WildcardChars) == -1, "InvalidExtensionToIgnore", extension, null, false);
                 }
             }
         }
@@ -3723,7 +3723,7 @@ private static string[] ProcessTargetSwitch(string[] parameters)
         {
             foreach (string parameter in parameters)
             {
-                int indexOfSpecialCharacter = parameter.IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
+                int indexOfSpecialCharacter = parameter.AsSpan().IndexOfAny(XMakeElements.InvalidTargetNameCharacters);
                 if (indexOfSpecialCharacter >= 0)
                 {
                     CommandLineSwitchException.Throw("NameInvalid", nameof(XMakeElements.target), parameter, parameter[indexOfSpecialCharacter].ToString());
@@ -3737,11 +3737,6 @@ private static string[] ProcessTargetSwitch(string[] parameters)
         /// </summary>
         private static readonly char[] s_propertyValueSeparator = MSBuildConstants.EqualsChar;
 
-        /// <summary>
-        /// This is a set of wildcard chars which can cause a file extension to be invalid
-        /// </summary>
-        private static readonly char[] s_wildcards = MSBuildConstants.WildcardChars;
-
         /// <summary>
         /// Determines which ToolsVersion was specified on the command line.  If more than
         /// one ToolsVersion was specified, we honor only the final ToolsVersion.
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 96d2e3dbc1d..dea6d8dbc9c 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -39,8 +39,8 @@
 
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
-          <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="6.0.0.1" />
-          <codeBase version="6.0.0.1" href="..\Microsoft.IO.Redist.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-6.1.0.0" newVersion="6.1.0.0" />
+          <codeBase version="6.1.0.0" href="..\Microsoft.IO.Redist.dll"/>
         </dependentAssembly>
 
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
@@ -70,8 +70,13 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Bcl.HashCode" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+          <codeBase version="1.0.0.0" href="..\Microsoft.Bcl.HashCode.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -89,20 +94,30 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
-          <codeBase version="4.0.3.0" href="..\System.Buffers.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.0.4.0" newVersion="4.0.4.0" />
+          <codeBase version="4.0.4.0" href="..\System.Buffers.dll"/>
         </dependentAssembly>
 
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Collections.Immutable.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Collections.Immutable.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.1" />
-          <codeBase version="8.0.0.1" href="..\System.Diagnostics.DiagnosticSource.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Diagnostics.DiagnosticSource.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Formats.Nrbf" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Formats.Nrbf.dll"/>
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.IO.Pipelines" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.IO.Pipelines.dll"/>
         </dependentAssembly>
 
         <dependentAssembly>
@@ -175,58 +190,58 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.1.2" newVersion="4.0.1.2" />
-          <codeBase version="4.0.1.2" href="..\System.Memory.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.0.1.2" newVersion="4.0.2.0" />
+          <codeBase version="4.0.2.0" href="..\System.Memory.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
-          <codeBase version="4.1.4.0" href="..\System.Numerics.Vectors.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.1.5.0" newVersion="4.1.5.0" />
+          <codeBase version="4.1.5.0" href="..\System.Numerics.Vectors.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Reflection.Metadata.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Reflection.Metadata.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Resources.Extensions.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Resources.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
-          <codeBase version="6.0.0.0" href="..\System.Runtime.CompilerServices.Unsafe.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-6.0.1.0" newVersion="6.0.1.0" />
+          <codeBase version="6.0.1.0" href="..\System.Runtime.CompilerServices.Unsafe.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Text.Encodings.Web.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Text.Encodings.Web.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.5" newVersion="8.0.0.5" />
-          <codeBase version="8.0.0.5" href="..\System.Text.Json.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Text.Json.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Channels" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Threading.Channels.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Threading.Channels.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
-          <codeBase version="8.0.0.0" href="..\System.Threading.Tasks.Dataflow.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+          <codeBase version="9.0.0.0" href="..\System.Threading.Tasks.Dataflow.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
-          <codeBase version="4.2.0.1" href="..\System.Threading.Tasks.Extensions.dll"/>
+          <bindingRedirect oldVersion="0.0.0.0-4.2.1.0" newVersion="4.2.1.0" />
+          <codeBase version="4.2.1.0" href="..\System.Threading.Tasks.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index d63a1782ca4..cd0059bd3db 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -33,7 +33,11 @@
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.Bcl.HashCode" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Extensions.Primitives" publicKeyToken="adb9793829ddae60" culture="neutral" />
@@ -41,7 +45,7 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
-          <bindingRedirect oldVersion="0.0.0.0-6.0.0.1" newVersion="6.0.0.1" />
+          <bindingRedirect oldVersion="0.0.0.0-6.1.0.0" newVersion="6.1.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
@@ -53,56 +57,64 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.4.0" newVersion="4.0.4.0" />
         </dependentAssembly>
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Formats.Nrbf" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.IO.Pipelines" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.1" newVersion="8.0.0.1" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.0.1.2" newVersion="4.0.1.2" />
+          <bindingRedirect oldVersion="0.0.0.0-4.0.2.0" newVersion="4.0.2.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
+          <bindingRedirect oldVersion="0.0.0.0-4.1.5.0" newVersion="4.1.5.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.1.0" newVersion="6.0.1.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.5" newVersion="8.0.0.5" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-8.0.0.0" newVersion="8.0.0.0" />
+          <bindingRedirect oldVersion="0.0.0.0-9.0.0.0" newVersion="9.0.0.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
-          <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
+          <bindingRedirect oldVersion="0.0.0.0-4.2.1.0" newVersion="4.2.1.0" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 8df9f8d8d90..ee8123a3994 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -39,13 +39,15 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)BuildXL.Native.dll
   file source=$(X86BinPath)BuildXL.Processes.dll
   file source=$(X86BinPath)BuildXL.Utilities.Core.dll
-  file source=$(X86BinPath)Microsoft.VisualStudio.SolutionPersistence.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.VisualStudio.SolutionPersistence.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
   file source=$(X86BinPath)RuntimeContracts.dll
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)System.Diagnostics.DiagnosticSource.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Diagnostics.DiagnosticSource.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)System.Formats.Nrbf.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Threading.Channels.dll
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -53,12 +55,13 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.ValueTuple.dll
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.Bcl.HashCode.dll
   file source=$(X86BinPath)Microsoft.NET.StringTools.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)Microsoft.NET.StringTools.net35.dll vs.file.ngenArchitecture=all
+  file source=$(TaskHostBinPath)Microsoft.NET.StringTools.net35.dll
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.Common.overridetasks
@@ -87,24 +90,24 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.ServiceModel.targets
   file source=$(X86BinPath)Microsoft.WinFx.targets
   file source=$(X86BinPath)Microsoft.WorkflowBuildExtensions.targets
-  file source=$(X86BinPath)Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.VisualStudio.OpenTelemetry.Collector.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.VisualStudio.Utilities.Internal.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)OpenTelemetry.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)OpenTelemetry.Api.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)OpenTelemetry.Api.ProviderBuilderExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Configuration.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Configuration.Binder.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Configuration.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.DependencyInjection.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.DependencyInjection.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Logging.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Logging.Configuration.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Logging.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Options.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Options.ConfigurationExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Primitives.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
-  file source=$(X86BinPath)Microsoft.Extensions.Diagnostics.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.VisualStudio.OpenTelemetry.ClientExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.VisualStudio.OpenTelemetry.Collector.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.VisualStudio.Utilities.Internal.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)OpenTelemetry.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)OpenTelemetry.Api.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)OpenTelemetry.Api.ProviderBuilderExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Configuration.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Configuration.Binder.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Configuration.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.DependencyInjection.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.DependencyInjection.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Logging.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Logging.Configuration.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Logging.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Options.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Options.ConfigurationExtensions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Primitives.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
+  file source=$(X86BinPath)Microsoft.Extensions.Diagnostics.Abstractions.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=3
   file source=$(X86BinPath)Newtonsoft.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\amd64\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
 
 folder InstallDir:\MSBuild\Current\Bin\MSBuild
@@ -209,6 +212,8 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Formats.Nrbf.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.IO.Pipelines.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenArchitecture=all
@@ -219,12 +224,13 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.ValueTuple.dll
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Resources.Extensions.dll
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Dataflow.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Collections.Immutable.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.Bcl.HashCode.dll
   file source=$(X86BinPath)Microsoft.NET.StringTools.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)Microsoft.NET.StringTools.net35.dll vs.file.ngenArchitecture=all
+  file source=$(TaskHostBinPath)Microsoft.NET.StringTools.net35.dll
   file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
   file source=$(X86BinPath)Microsoft.Common.overridetasks
diff --git a/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj b/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj
index 6282c3a2134..0d02925d4e9 100644
--- a/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj
+++ b/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj
@@ -24,6 +24,6 @@
     <SwrProperty Include="Version=$(VsixVersion)" />
 
     <!-- our swr file must be picked up, this is how we set that. -->
-    <SwrFile Include="exe.swr" Condition=" '$(MSBuildRuntimeType)' == 'Full' " />
+    <SwrFile Include="exe.swr" />
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
index 5ba08499c68..684e80213ae 100644
--- a/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
+++ b/src/Samples/ProjectCachePlugin/ProjectCachePlugin.csproj
@@ -8,11 +8,16 @@
     <TargetFrameworks Condition="$([MSBuild]::IsOSPlatform('windows'))">$(FullFrameworkTFM);$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
   </PropertyGroup>
   <ItemGroup>
-    <ProjectReference Include="..\..\Build\Microsoft.Build.csproj" />
-    <ProjectReference Include="..\..\Framework\Microsoft.Build.Framework.csproj" />
+    <PackageReference Include="Microsoft.Build" Version="16.11.0" PrivateAssets="all" />
+
+    <!-- Bump versions of transitive dependencies to vulnerable packages,
+         but don't reference them so the plugin doesn't carry higher references
+         than its targeted MSBuild. NOT NECESSARY for public plugins; use higher MSBuild. -->
+    <PackageReference Include="System.Drawing.Common" Version="4.7.2" ExcludeAssets="all" />
+    <PackageReference Include="System.Text.Encodings.Web" Version="4.7.2" ExcludeAssets="all" />
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="Shouldly" Version="4.2.1" />
-    <PackageReference Include="System.Net.Http" Version="4.3.4" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 </Project>
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index 6820a134454..a15f6e62113 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -82,7 +82,7 @@ internal AssemblyFoldersEx(
                 return;
             }
 
-            bool is64bitOS = EnvironmentUtilities.Is64BitOperatingSystem;
+            bool is64bitOS = Environment.Is64BitOperatingSystem;
             bool targeting64bit = targetProcessorArchitecture == ProcessorArchitecture.Amd64 || targetProcessorArchitecture == ProcessorArchitecture.IA64;
 
             // The registry lookup should be as follows:
@@ -367,7 +367,7 @@ internal static List<ExtensionFoldersRegistryKey> GatherVersionStrings(string ta
             // Loop over versions from registry.
             foreach (string version in versions)
             {
-                if ((version.Length > 0) && (String.Equals(version.Substring(0, 1), "v", StringComparison.OrdinalIgnoreCase)))
+                if ((version.Length > 0) && version[0] is 'v' or 'V')
                 {
                     Version candidateVersion = VersionUtilities.ConvertToVersion(version);
 
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs b/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
index b546b28ccb9..4f79794879d 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersFromConfig.cs
@@ -41,7 +41,7 @@ internal AssemblyFoldersFromConfig(string configFile, string targetRuntimeVersio
             // Platform-agnostic folders first.
             FindDirectories(assemblyTargets, target => string.IsNullOrEmpty(target.Platform));
 
-            if (EnvironmentUtilities.Is64BitOperatingSystem)
+            if (Environment.Is64BitOperatingSystem)
             {
                 if (targeting64Bit)
                 {
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index f29b9e8e443..12017934f1f 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -577,6 +577,11 @@ private static int CompareBaseNamesStringWise(string asString1, string asString2
                 baseLenThat = asString2.Length;
             }
 
+#if NET
+            ReadOnlySpan<char> nameThis = asString1.AsSpan(0, baseLenThis);
+            ReadOnlySpan<char> nameThat = asString2.AsSpan(0, baseLenThat);
+            return nameThis.CompareTo(nameThat, StringComparison.OrdinalIgnoreCase);
+#else
             // If the lengths are the same then we can compare without copying.
             if (baseLenThis == baseLenThat)
             {
@@ -587,6 +592,7 @@ private static int CompareBaseNamesStringWise(string asString1, string asString2
             string nameThis = asString1.Substring(0, baseLenThis);
             string nameThat = asString2.Substring(0, baseLenThat);
             return string.Compare(nameThis, nameThat, StringComparison.OrdinalIgnoreCase);
+#endif
         }
 
         /// <summary>
@@ -778,24 +784,18 @@ internal bool ComparePublicKeyToken(AssemblyNameExtension that)
         /// </summary>
         internal static bool ComparePublicKeyTokens(byte[] aPKT, byte[] bPKT)
         {
+#if NET
+            return aPKT.AsSpan().SequenceEqual(bPKT.AsSpan());
+#else
             // Some assemblies (real case was interop assembly) may have null PKTs.
-            if (aPKT == null)
-            {
-#pragma warning disable CA1825 // Avoid zero-length array allocations
-                aPKT = new byte[0];
-#pragma warning restore CA1825 // Avoid zero-length array allocations
-            }
-            if (bPKT == null)
-            {
-#pragma warning disable CA1825 // Avoid zero-length array allocations
-                bPKT = new byte[0];
-#pragma warning restore CA1825 // Avoid zero-length array allocations
-            }
+            aPKT ??= [];
+            bPKT ??= [];
 
             if (aPKT.Length != bPKT.Length)
             {
                 return false;
             }
+
             for (int i = 0; i < aPKT.Length; ++i)
             {
                 if (aPKT[i] != bPKT[i])
@@ -803,7 +803,9 @@ internal static bool ComparePublicKeyTokens(byte[] aPKT, byte[] bPKT)
                     return false;
                 }
             }
+
             return true;
+#endif
         }
 
         /// <summary>
diff --git a/src/Shared/AwaitExtensions.cs b/src/Shared/AwaitExtensions.cs
index 711d2dde947..f864c62bb23 100644
--- a/src/Shared/AwaitExtensions.cs
+++ b/src/Shared/AwaitExtensions.cs
@@ -19,7 +19,7 @@ internal static class AwaitExtensions
         /// <summary>
         /// Synchronizes access to the staScheduler field.
         /// </summary>
-        private static Object s_staSchedulerSync = new Object();
+        private static readonly Object s_staSchedulerSync = new Object();
 
         /// <summary>
         /// The singleton STA scheduler object.
@@ -155,7 +155,7 @@ private class OneSTAThreadPerTaskScheduler : TaskScheduler
             /// <summary>
             /// The current queue of tasks.
             /// </summary>
-            private ConcurrentQueue<Task> _queuedTasks = new ConcurrentQueue<Task>();
+            private readonly ConcurrentQueue<Task> _queuedTasks = new ConcurrentQueue<Task>();
 
             /// <summary>
             /// Returns the list of queued tasks.
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index c3615e4acf6..f93696c6aba 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
diff --git a/src/Shared/CanonicalError.cs b/src/Shared/CanonicalError.cs
index 011818c3f1c..4da40e7054f 100644
--- a/src/Shared/CanonicalError.cs
+++ b/src/Shared/CanonicalError.cs
@@ -2,6 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NET
+using System.Buffers;
+#endif
 using System.Globalization;
 using System.Text.RegularExpressions;
 
@@ -49,99 +52,141 @@ namespace Microsoft.Build.Shared
     ///
     ///          &lt;text&gt; : warning [num]: &lt;msg&gt;
     /// </remarks>
-    internal static class CanonicalError
+    internal static partial class CanonicalError
     {
         // Defines the main pattern for matching messages.
-        private static readonly Lazy<Regex> s_originCategoryCodeTextExpression = new Lazy<Regex>(
-            () => new Regex(
-                // Beginning of line and any amount of whitespace.
-                @"^\s*"
-                // Match a [optional project number prefix 'ddd>'], single letter + colon + remaining filename, or
-                // string with no colon followed by a colon.
-                + @"(((?<ORIGIN>(((\d+>)?[a-zA-Z]?:[^:]*)|([^:]*))):)"
-                // Origin may also be empty. In this case there's no trailing colon.
-                + "|())"
-                // Match the empty string or a string without a colon that ends with a space
-                + "(?<SUBCATEGORY>(()|([^:]*? )))"
-                // Match 'error' or 'warning'.
-                + @"(?<CATEGORY>(error|warning))"
-                // Match anything starting with a space that's not a colon/space, followed by a colon.
-                // Error code is optional in which case "error"/"warning" can be followed immediately by a colon.
-                + @"( \s*(?<CODE>[^: ]*))?\s*:"
-                // Whatever's left on this line, including colons.
-                + "(?<TEXT>.*)$",
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
-
-        private static readonly Lazy<Regex> s_originCategoryCodeTextExpression2 = new Lazy<Regex>(
-            () => new Regex(
-                @"^\s*(?<ORIGIN>(?<FILENAME>.*):(?<LOCATION>(?<LINE>[0-9]*):(?<COLUMN>[0-9]*))):(?<CATEGORY> error| warning):(?<TEXT>.*)",
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string OriginCategoryCodeTextExpressionPattern =
+            // Beginning of line and any amount of whitespace.
+            @"^\s*"
+            // Match a [optional project number prefix 'ddd>'], single letter + colon + remaining filename, or
+            // string with no colon followed by a colon.
+            + @"(((?<ORIGIN>(((\d+>)?[a-zA-Z]?:[^:]*)|([^:]*))):)"
+            // Origin may also be empty. In this case there's no trailing colon.
+            + "|())"
+            // Match the empty string or a string without a colon that ends with a space
+            + "(?<SUBCATEGORY>(()|([^:]*? )))"
+            // Match 'error' or 'warning'.
+            + @"(?<CATEGORY>(error|warning))"
+            // Match anything starting with a space that's not a colon/space, followed by a colon.
+            // Error code is optional in which case "error"/"warning" can be followed immediately by a colon.
+            + @"( \s*(?<CODE>[^: ]*))?\s*:"
+            // Whatever's left on this line, including colons.
+            + "(?<TEXT>.*)$";
+
+        private const string OriginCategoryCodeTextExpression2Pattern =
+            @"^\s*(?<ORIGIN>(?<FILENAME>.*):(?<LOCATION>(?<LINE>[0-9]*):(?<COLUMN>[0-9]*))):(?<CATEGORY> error| warning):(?<TEXT>.*)";
 
         // Matches and extracts filename and location from an 'origin' element.
-        private static readonly Lazy<Regex> s_filenameLocationFromOrigin = new Lazy<Regex>(
-            () => new Regex(
-                "^" // Beginning of line
-                + @"(\d+>)?" // Optional ddd> project number prefix
-                + "(?<FILENAME>.*)" // Match anything.
-                + @"\(" // Find a parenthesis.
-                + @"(?<LOCATION>[\,,0-9,-]*)" // Match any combination of numbers and ',' and '-'
-                + @"\)\s*" // Find the closing paren then any amount of spaces.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string FilenameLocationFromOriginPattern =
+            "^" // Beginning of line
+            + @"(\d+>)?" // Optional ddd> project number prefix
+            + "(?<FILENAME>.*)" // Match anything.
+            + @"\(" // Find a parenthesis.
+            + @"(?<LOCATION>[\,,0-9,-]*)" // Match any combination of numbers and ',' and '-'
+            + @"\)\s*" // Find the closing paren then any amount of spaces.
+            + "$"; // End-of-line
 
         // Matches location that is a simple number.
-        private static readonly Lazy<Regex> s_lineFromLocation = new Lazy<Regex>(
-            () => new Regex( // Example: line
-                "^" // Beginning of line
-                + "(?<LINE>[0-9]*)" // Match any number.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string LineFromLocationPattern = // Example: line
+            "^" // Beginning of line
+            + "(?<LINE>[0-9]*)" // Match any number.
+            + "$"; // End-of-line
 
         // Matches location that is a range of lines.
-        private static readonly Lazy<Regex> s_lineLineFromLocation = new Lazy<Regex>(
-            () => new Regex( // Example: line-line
-                "^" // Beginning of line
-                + "(?<LINE>[0-9]*)" // Match any number.
-                + "-" // Dash
-                + "(?<ENDLINE>[0-9]*)" // Match any number.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string LineLineFromLocationPattern = // Example: line-line
+            "^" // Beginning of line
+            + "(?<LINE>[0-9]*)" // Match any number.
+            + "-" // Dash
+            + "(?<ENDLINE>[0-9]*)" // Match any number.
+            + "$"; // End-of-line
 
         // Matches location that is a line and column
-        private static readonly Lazy<Regex> s_lineColFromLocation = new Lazy<Regex>(
-            () => new Regex( // Example: line,col
-                "^" // Beginning of line
-                + "(?<LINE>[0-9]*)" // Match any number.
-                + "," // Comma
-                + "(?<COLUMN>[0-9]*)" // Match any number.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string LineColFromLocationPattern = // Example: line,col
+            "^" // Beginning of line
+            + "(?<LINE>[0-9]*)" // Match any number.
+            + "," // Comma
+            + "(?<COLUMN>[0-9]*)" // Match any number.
+            + "$"; // End-of-line
 
         // Matches location that is a line and column-range
-        private static readonly Lazy<Regex> s_lineColColFromLocation = new Lazy<Regex>(
-            () => new Regex( // Example: line,col-col
-                "^" // Beginning of line
-                + "(?<LINE>[0-9]*)" // Match any number.
-                + "," // Comma
-                + "(?<COLUMN>[0-9]*)" // Match any number.
-                + "-" // Dash
-                + "(?<ENDCOLUMN>[0-9]*)" // Match any number.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string LineColColFromLocationPattern = // Example: line,col-col
+            "^" // Beginning of line
+            + "(?<LINE>[0-9]*)" // Match any number.
+            + "," // Comma
+            + "(?<COLUMN>[0-9]*)" // Match any number.
+            + "-" // Dash
+            + "(?<ENDCOLUMN>[0-9]*)" // Match any number.
+            + "$"; // End-of-line
 
         // Matches location that is line,col,line,col
-        private static readonly Lazy<Regex> s_lineColLineColFromLocation = new Lazy<Regex>(
-            () => new Regex( // Example: line,col,line,col
-                "^" // Beginning of line
-                + "(?<LINE>[0-9]*)" // Match any number.
-                + "," // Comma
-                + "(?<COLUMN>[0-9]*)" // Match any number.
-                + "," // Dash
-                + "(?<ENDLINE>[0-9]*)" // Match any number.
-                + "," // Dash
-                + "(?<ENDCOLUMN>[0-9]*)" // Match any number.
-                + "$", // End-of-line
-                RegexOptions.IgnoreCase | RegexOptions.Compiled));
+        private const string LineColLineColFromLocationPattern = // Example: line,col,line,col
+            "^" // Beginning of line
+            + "(?<LINE>[0-9]*)" // Match any number.
+            + "," // Comma
+            + "(?<COLUMN>[0-9]*)" // Match any number.
+            + "," // Dash
+            + "(?<ENDLINE>[0-9]*)" // Match any number.
+            + "," // Dash
+            + "(?<ENDCOLUMN>[0-9]*)" // Match any number.
+            + "$"; // End-of-line
+
+#if NET
+        [GeneratedRegex(OriginCategoryCodeTextExpressionPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex OriginCategoryCodeTextExpression { get; }
+
+        [GeneratedRegex(OriginCategoryCodeTextExpression2Pattern, RegexOptions.IgnoreCase)]
+        private static partial Regex OriginCategoryCodeTextExpression2 { get; }
+
+        [GeneratedRegex(FilenameLocationFromOriginPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex FilenameLocationFromOrigin { get; }
+
+        [GeneratedRegex(LineFromLocationPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex LineFromLocation { get; }
+
+        [GeneratedRegex(LineLineFromLocationPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex LineLineFromLocation { get; }
+
+        [GeneratedRegex(LineColFromLocationPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex LineColFromLocation { get; }
+
+        [GeneratedRegex(LineColColFromLocationPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex LineColColFromLocation { get; }
+
+        [GeneratedRegex(LineColLineColFromLocationPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex LineColLineColFromLocation { get; }
+#else
+        private static Regex s_originCategoryCodeTextExpression;
+        private static Regex OriginCategoryCodeTextExpression => s_originCategoryCodeTextExpression ??=
+            new Regex(OriginCategoryCodeTextExpressionPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_originCategoryCodeTextExpression2;
+        private static Regex OriginCategoryCodeTextExpression2 => s_originCategoryCodeTextExpression2 ??=
+            new Regex(OriginCategoryCodeTextExpression2Pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_filenameLocationFromOrigin;
+        private static Regex FilenameLocationFromOrigin => s_filenameLocationFromOrigin ??=
+            new Regex(FilenameLocationFromOriginPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_lineFromLocation;
+        private static Regex LineFromLocation => s_lineFromLocation ??=
+            new Regex(LineFromLocationPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_lineLineFromLocation;
+        private static Regex LineLineFromLocation => s_lineLineFromLocation ??=
+            new Regex(LineLineFromLocationPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_lineColFromLocation;
+        private static Regex LineColFromLocation => s_lineColFromLocation ??=
+            new Regex(LineColFromLocationPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_lineColColFromLocation;
+        private static Regex LineColColFromLocation => s_lineColColFromLocation ??=
+            new Regex(LineColColFromLocationPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+
+        private static Regex s_lineColLineColFromLocation;
+        private static Regex LineColLineColFromLocation => s_lineColLineColFromLocation ??=
+            new Regex(LineColLineColFromLocationPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
+#endif
 
         /// <summary>
         /// Represents the parts of a decomposed canonical message.
@@ -234,6 +279,10 @@ private static int ConvertToIntWithDefault(string value)
             return result;
         }
 
+#if NET
+        private static readonly SearchValues<string> s_warningOrError = SearchValues.Create(["warning", "error"], StringComparison.OrdinalIgnoreCase);
+#endif
+
         /// <summary>
         /// Decompose an error or warning message into constituent parts. If the message isn't in the canonical form, return null.
         /// </summary>
@@ -256,8 +305,12 @@ internal static Parts Parse(string message)
             // If a tool has a large amount of output that isn't an error or warning (eg., "dir /s %hugetree%")
             // the regex below is slow. It's faster to pre-scan for "warning" and "error"
             // and bail out if neither are present.
-            if (message.IndexOf("warning", StringComparison.OrdinalIgnoreCase) == -1 &&
-                message.IndexOf("error", StringComparison.OrdinalIgnoreCase) == -1)
+#if NET
+            if (message.AsSpan().IndexOfAny(s_warningOrError) < 0)
+#else
+            if (message.IndexOf("warning", StringComparison.OrdinalIgnoreCase) < 0 &&
+                message.IndexOf("error", StringComparison.OrdinalIgnoreCase) < 0)
+#endif
             {
                 return null;
             }
@@ -283,7 +336,7 @@ internal static Parts Parse(string message)
             //  Here's an example from the Japanese version of LINK.EXE:
             //   AssemblyInfo.cpp : fatal error LNK1106: ???????????? ??????????????: 0x6580 ??????????
             //
-            Match match = s_originCategoryCodeTextExpression.Value.Match(message);
+            Match match = OriginCategoryCodeTextExpression.Match(message);
             string category;
             if (!match.Success)
             {
@@ -292,7 +345,7 @@ internal static Parts Parse(string message)
                 //       err.cpp:6:3: error: use of undeclared identifier 'force_an_error'
                 //       -----------  -----  ---------------------------------------------
                 //       Origin       Cat.   Text
-                match = s_originCategoryCodeTextExpression2.Value.Match(message);
+                match = OriginCategoryCodeTextExpression2.Match(message);
                 if (!match.Success)
                 {
                     return null;
@@ -320,7 +373,7 @@ internal static Parts Parse(string message)
                 string[] explodedText = parsedMessage.text.Split(MSBuildConstants.SingleQuoteChar, StringSplitOptions.RemoveEmptyEntries);
                 if (explodedText.Length > 0)
                 {
-                    parsedMessage.code = "G" + explodedText[0].GetHashCode().ToString("X8");
+                    parsedMessage.code = $"G{explodedText[0].GetHashCode():X8}";
                 }
                 else
                 {
@@ -353,7 +406,7 @@ internal static Parts Parse(string message)
 
             // Origin is not a simple file, but it still could be of the form,
             //  foo.cpp(location)
-            match = s_filenameLocationFromOrigin.Value.Match(origin);
+            match = FilenameLocationFromOrigin.Match(origin);
 
             if (match.Success)
             {
@@ -373,14 +426,14 @@ internal static Parts Parse(string message)
                 //      (line,col,line,col)
                 if (location.Length > 0)
                 {
-                    match = s_lineFromLocation.Value.Match(location);
+                    match = LineFromLocation.Match(location);
                     if (match.Success)
                     {
                         parsedMessage.line = ConvertToIntWithDefault(match.Groups["LINE"].Value.Trim());
                     }
                     else
                     {
-                        match = s_lineLineFromLocation.Value.Match(location);
+                        match = LineLineFromLocation.Match(location);
                         if (match.Success)
                         {
                             parsedMessage.line = ConvertToIntWithDefault(match.Groups["LINE"].Value.Trim());
@@ -388,7 +441,7 @@ internal static Parts Parse(string message)
                         }
                         else
                         {
-                            match = s_lineColFromLocation.Value.Match(location);
+                            match = LineColFromLocation.Match(location);
                             if (match.Success)
                             {
                                 parsedMessage.line = ConvertToIntWithDefault(match.Groups["LINE"].Value.Trim());
@@ -396,7 +449,7 @@ internal static Parts Parse(string message)
                             }
                             else
                             {
-                                match = s_lineColColFromLocation.Value.Match(location);
+                                match = LineColColFromLocation.Match(location);
                                 if (match.Success)
                                 {
                                     parsedMessage.line = ConvertToIntWithDefault(match.Groups["LINE"].Value.Trim());
@@ -405,7 +458,7 @@ internal static Parts Parse(string message)
                                 }
                                 else
                                 {
-                                    match = s_lineColLineColFromLocation.Value.Match(location);
+                                    match = LineColLineColFromLocation.Match(location);
                                     if (match.Success)
                                     {
                                         parsedMessage.line = ConvertToIntWithDefault(match.Groups["LINE"].Value.Trim());
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 12061206c4d..fe93672dee4 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -7,7 +7,9 @@
 using System.Globalization;
 using System.IO;
 using System.IO.Pipes;
+#if NETFRAMEWORK
 using System.Runtime.InteropServices;
+#endif
 #if FEATURE_SECURITY_PRINCIPAL_WINDOWS
 using System.Security.Principal;
 #endif
@@ -99,10 +101,10 @@ protected internal Handshake(HandshakeOptions nodeType)
             CommunicationsUtilities.Trace("Building handshake for node type {0}, (version {1}): options {2}.", nodeType, handshakeVersion, options);
 
             string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
-            CommunicationsUtilities.Trace("Handshake salt is " + handshakeSalt);
+            CommunicationsUtilities.Trace("Handshake salt is {0}", handshakeSalt);
             string toolsDirectory = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;
-            CommunicationsUtilities.Trace("Tools directory root is " + toolsDirectory);
-            salt = CommunicationsUtilities.GetHashCode(handshakeSalt + toolsDirectory);
+            CommunicationsUtilities.Trace("Tools directory root is {0}", toolsDirectory);
+            salt = CommunicationsUtilities.GetHashCode($"{handshakeSalt}{toolsDirectory}");
             Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion);
             fileVersionMajor = fileVersion.Major;
             fileVersionMinor = fileVersion.Minor;
@@ -115,7 +117,7 @@ protected internal Handshake(HandshakeOptions nodeType)
         // This is used as a key, so it does not need to be human readable.
         public override string ToString()
         {
-            return String.Format("{0} {1} {2} {3} {4} {5} {6}", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);
+            return $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}";
         }
 
         public virtual int[] RetrieveHandshakeComponents()
@@ -178,8 +180,14 @@ public string ComputeHash()
             if (_computedHash == null)
             {
                 var input = GetKey();
+                byte[] utf8 = Encoding.UTF8.GetBytes(input);
+#if NET
+                Span<byte> bytes = stackalloc byte[SHA256.HashSizeInBytes];
+                SHA256.HashData(utf8, bytes);
+#else
                 using var sha = SHA256.Create();
-                var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(input));
+                var bytes = sha.ComputeHash(utf8);
+#endif
                 _computedHash = Convert.ToBase64String(bytes)
                     .Replace("/", "_")
                     .Replace("=", string.Empty);
@@ -211,7 +219,7 @@ internal static class CommunicationsUtilities
         /// <summary>
         /// Whether to trace communications
         /// </summary>
-        private static bool s_trace = Traits.Instance.DebugNodeCommunication;
+        private static readonly bool s_trace = Traits.Instance.DebugNodeCommunication;
 
         /// <summary>
         /// Lock trace to ensure we are logging in serial fashion.
@@ -581,7 +589,7 @@ internal static int ReadIntForHandshake(this PipeStream stream, byte? byteToAcce
 #nullable disable
 
 #if !FEATURE_APM
-        internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int bytesToRead)
+        internal static async ValueTask<int> ReadAsync(Stream stream, byte[] buffer, int bytesToRead)
         {
             int totalBytesRead = 0;
             while (totalBytesRead < bytesToRead)
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index e435d354935..4aa800ef2d2 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -2,6 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+#if NET
+using System.Buffers;
+#endif
 using System.IO;
 
 #nullable disable
@@ -112,25 +115,31 @@ internal static class MSBuildConstants
         internal const string ProjectReferenceTargetsOrDefaultTargetsMarker = ".projectReferenceTargetsOrDefaultTargets";
 
         // One-time allocations to avoid implicit allocations for Split(), Trim().
-        internal static readonly char[] SemicolonChar = { ';' };
-        internal static readonly char[] SpaceChar = { ' ' };
-        internal static readonly char[] SingleQuoteChar = { '\'' };
-        internal static readonly char[] EqualsChar = { '=' };
-        internal static readonly char[] ColonChar = { ':' };
-        internal static readonly char[] BackslashChar = { '\\' };
-        internal static readonly char[] NewlineChar = { '\n' };
-        internal static readonly char[] CrLf = { '\r', '\n' };
-        internal static readonly char[] ForwardSlash = { '/' };
-        internal static readonly char[] ForwardSlashBackslash = { '/', '\\' };
-        internal static readonly char[] WildcardChars = { '*', '?' };
-        internal static readonly string[] CharactersForExpansion = { "*", "?", "$(", "@(", "%" };
-        internal static readonly char[] CommaChar = { ',' };
-        internal static readonly char[] HyphenChar = { '-' };
-        internal static readonly char[] DirectorySeparatorChar = { Path.DirectorySeparatorChar };
-        internal static readonly char[] DotChar = { '.' };
-        internal static readonly string[] EnvironmentNewLine = { Environment.NewLine };
-        internal static readonly char[] PipeChar = { '|' };
-        internal static readonly char[] PathSeparatorChar = { Path.PathSeparator };
+        internal static readonly char[] SemicolonChar = [';'];
+        internal static readonly char[] SpaceChar = [' '];
+        internal static readonly char[] SingleQuoteChar = ['\''];
+        internal static readonly char[] EqualsChar = ['='];
+        internal static readonly char[] ColonChar = [':'];
+        internal static readonly char[] BackslashChar = ['\\'];
+        internal static readonly char[] NewlineChar = ['\n'];
+        internal static readonly char[] CrLf = ['\r', '\n'];
+        internal static readonly char[] ForwardSlash = ['/'];
+        internal static readonly char[] ForwardSlashBackslash = ['/', '\\'];
+        internal static readonly char[] WildcardChars = ['*', '?'];
+        internal static readonly string[] CharactersForExpansion = ["*", "?", "$(", "@(", "%"];
+        internal static readonly char[] CommaChar = [','];
+        internal static readonly char[] HyphenChar = ['-'];
+        internal static readonly char[] DirectorySeparatorChar = [Path.DirectorySeparatorChar];
+        internal static readonly char[] DotChar = ['.'];
+        internal static readonly string[] EnvironmentNewLine = [Environment.NewLine];
+        internal static readonly char[] PipeChar = ['|'];
+        internal static readonly char[] PathSeparatorChar = [Path.PathSeparator];
+
+#if NET
+        internal static readonly SearchValues<char> InvalidPathChars = SearchValues.Create(Path.GetInvalidPathChars());
+#else
+        internal static readonly char[] InvalidPathChars = Path.GetInvalidPathChars();
+#endif
     }
 
     internal static class PropertyNames
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index 10bdc82790e..d04a52db675 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -3,7 +3,9 @@
 
 using System;
 using System.Globalization;
+#if !NET
 using System.Text;
+#endif
 using Error = Microsoft.Build.Shared.ErrorUtilities;
 
 #nullable disable
@@ -57,6 +59,9 @@ internal static bool ConvertStringToBool(string parameterValue, bool nullOrWhite
         /// <returns>A string byte types formated as X2.</returns>
         internal static string ConvertByteArrayToHex(byte[] bytes)
         {
+#if NET
+            return Convert.ToHexString(bytes);
+#else
             var sb = new StringBuilder();
             foreach (var b in bytes)
             {
@@ -64,6 +69,7 @@ internal static string ConvertByteArrayToHex(byte[] bytes)
             }
 
             return sb.ToString();
+#endif
         }
 
         internal static bool TryConvertStringToBool(string parameterValue, out bool boolValue)
@@ -131,7 +137,13 @@ internal static double ConvertDecimalToDouble(string number)
         /// </summary>
         internal static double ConvertHexToDouble(string number)
         {
-            return (double)Int32.Parse(number.Substring(2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat);
+            return (double)Int32.Parse(
+#if NET
+                number.AsSpan(2),
+#else
+                number.Substring(2),
+#endif
+                NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat);
         }
 
         /// <summary>
@@ -172,9 +184,15 @@ private static bool ValidHexNumber(string number, out int value)
         {
             bool canConvert = false;
             value = 0;
-            if (number.Length >= 3 && number[0] == '0' && (number[1] == 'x' || number[1] == 'X'))
+            if (number.Length >= 3 && number[0] is '0' && number[1] is 'x' or 'X')
             {
-                canConvert = Int32.TryParse(number.Substring(2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat, out value);
+                canConvert = Int32.TryParse(
+#if NET
+                    number.AsSpan(2),
+#else
+                    number.Substring(2),
+#endif
+                    NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat, out value);
             }
             return canConvert;
         }
diff --git a/src/Shared/Debugging/PrintLineDebuggerWriters.cs b/src/Shared/Debugging/PrintLineDebuggerWriters.cs
index e0dc425c320..bcdadc22a24 100644
--- a/src/Shared/Debugging/PrintLineDebuggerWriters.cs
+++ b/src/Shared/Debugging/PrintLineDebuggerWriters.cs
@@ -68,7 +68,7 @@ public CompositeWriter(IEnumerable<CommonWriterType> writers)
 
         public static CommonWriterType StdOutWriter = (id, callsite, args) => Console.WriteLine(SimpleFormat(id, callsite, args));
 
-        private static Lazy<string> _artifactsLogs = new Lazy<string>(
+        private static readonly Lazy<string> _artifactsLogs = new Lazy<string>(
             () =>
             {
                 var executingAssembly = FileUtilities.ExecutingAssemblyPath;
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index f84ddf86632..8bde0027840 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -26,7 +26,7 @@ internal static class EscapingUtilities
         /// Optional cache of escaped strings for use when needing to escape in performance-critical scenarios with significant
         /// expected string reuse.
         /// </summary>
-        private static Dictionary<string, string> s_unescapedToEscapedStrings = new Dictionary<string, string>(StringComparer.Ordinal);
+        private static readonly Dictionary<string, string> s_unescapedToEscapedStrings = new Dictionary<string, string>(StringComparer.Ordinal);
 
         private static bool TryDecodeHexDigit(char character, out int value)
         {
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index 16a19dcadc2..a802379a8e4 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -8,7 +8,6 @@ namespace Microsoft.Build.AppxPackage.Shared
 #else
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index d6cd177e8ad..9d97c12de8d 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -26,14 +26,19 @@ internal class FileMatcher
         private readonly IFileSystem _fileSystem;
         private const string recursiveDirectoryMatch = "**";
 
-        private static readonly string s_directorySeparator = new string(Path.DirectorySeparatorChar, 1);
+        private static readonly string s_directorySeparatorString = Path.DirectorySeparatorChar.ToString();
+        private static readonly string s_twoDirectorySeparators = s_directorySeparatorString + s_directorySeparatorString;
 
-        private static readonly string s_thisDirectory = "." + s_directorySeparator;
+        private static readonly string s_thisDirectory = $".{s_directorySeparatorString}";
 
         private static readonly char[] s_wildcardCharacters = { '*', '?' };
         private static readonly char[] s_wildcardAndSemicolonCharacters = { '*', '?', ';' };
 
-        private static readonly string[] s_propertyAndItemReferences = { "$(", "@(" };
+#if NET
+        private static readonly SearchValues<string> s_propertyAndItemReferences = SearchValues.Create(["$(", "@("], StringComparison.Ordinal);
+#else
+        private static readonly string[] s_propertyAndItemReferences = ["$(", "@("];
+#endif
 
         // on OSX both System.IO.Path separators are '/', so we have to use the literals
         internal static readonly char[] directorySeparatorCharacters = FileUtilities.Slashes;
@@ -45,12 +50,6 @@ internal class FileMatcher
         private readonly ConcurrentDictionary<string, IReadOnlyList<string>> _cachedGlobExpansions;
         private readonly Lazy<ConcurrentDictionary<string, object>> _cachedGlobExpansionsLock = new Lazy<ConcurrentDictionary<string, object>>(() => new ConcurrentDictionary<string, object>(StringComparer.OrdinalIgnoreCase));
 
-        /// <summary>
-        /// Cache of the list of invalid path characters, because this method returns a clone (for security reasons)
-        /// which can cause significant transient allocations
-        /// </summary>
-        private static readonly char[] s_invalidPathChars = Path.GetInvalidPathChars();
-
         public const RegexOptions DefaultRegexOptions = RegexOptions.IgnoreCase;
 
         private readonly GetFileSystemEntries _getFileSystemEntries;
@@ -186,7 +185,7 @@ internal static bool HasWildcards(string filespec)
             // Choose LastIndexOfAny instead of IndexOfAny because it seems more likely
             // that wildcards will tend to be towards the right side.
 
-            return -1 != filespec.LastIndexOfAny(s_wildcardCharacters);
+            return filespec.LastIndexOfAny(s_wildcardCharacters) >= 0;
         }
 
         /// <summary>
@@ -195,10 +194,8 @@ internal static bool HasWildcards(string filespec)
         internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec)
         {
             return
-
-                (-1 != filespec.IndexOfAny(s_wildcardAndSemicolonCharacters)) ||
-                HasPropertyOrItemReferences(filespec)
-                ;
+                (filespec.IndexOfAny(s_wildcardAndSemicolonCharacters) >= 0) ||
+                HasPropertyOrItemReferences(filespec);
         }
 
         /// <summary>
@@ -206,7 +203,12 @@ internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filesp
         /// </summary>
         internal static bool HasPropertyOrItemReferences(string filespec)
         {
-            return s_propertyAndItemReferences.Any(filespec.Contains);
+            return
+#if NET
+                filespec.AsSpan().ContainsAny(s_propertyAndItemReferences);
+#else
+                s_propertyAndItemReferences.Any(filespec.Contains);
+#endif
         }
 
         /// <summary>
@@ -288,10 +290,10 @@ private static bool ShouldEnforceMatching(string searchPattern)
             //    extensions that start with the same three characters e.g. "*.htm" would match both "file.htm" and "file.html"
             // 3) if the ? wildcard is to the left of a period, it matches files with shorter name e.g. ???.txt would match
             //    foo.txt, fo.txt and also f.txt
-            return searchPattern.IndexOf("?.", StringComparison.Ordinal) != -1 ||
+            return searchPattern.Contains("?.") ||
                    (
                        Path.GetExtension(searchPattern).Length == (3 + 1 /* +1 for the period */) &&
-                       searchPattern.IndexOf('*') != -1) ||
+                       searchPattern.Contains('*')) ||
                    searchPattern.EndsWith("?", StringComparison.Ordinal);
         }
 
@@ -440,7 +442,7 @@ internal static string GetLongPathName(
             string path,
             GetFileSystemEntries getFileSystemEntries)
         {
-            if (path.IndexOf("~", StringComparison.Ordinal) == -1)
+            if (!path.Contains('~'))
             {
                 // A path with no '~' must not be a short name.
                 return path;
@@ -451,15 +453,11 @@ internal static string GetLongPathName(
 
             string[] parts = path.Split(directorySeparatorCharacters);
             string pathRoot;
-            bool isUnc = path.StartsWith(s_directorySeparator + s_directorySeparator, StringComparison.Ordinal);
+            bool isUnc = path.StartsWith(s_twoDirectorySeparators, StringComparison.Ordinal);
             int startingElement;
             if (isUnc)
             {
-                pathRoot = s_directorySeparator + s_directorySeparator;
-                pathRoot += parts[2];
-                pathRoot += s_directorySeparator;
-                pathRoot += parts[3];
-                pathRoot += s_directorySeparator;
+                pathRoot = $"{s_twoDirectorySeparators}{parts[2]}{s_directorySeparatorString}{parts[3]}{s_directorySeparatorString}";
                 startingElement = 4;
             }
             else
@@ -468,7 +466,7 @@ internal static string GetLongPathName(
                 if (path.Length > 2 && path[1] == ':')
                 {
                     // Not relative
-                    pathRoot = parts[0] + s_directorySeparator;
+                    pathRoot = parts[0] + s_directorySeparatorString;
                     startingElement = 1;
                 }
                 else
@@ -493,7 +491,7 @@ internal static string GetLongPathName(
                 }
                 else
                 {
-                    if (parts[i].IndexOf("~", StringComparison.Ordinal) == -1)
+                    if (!parts[i].Contains('~'))
                     {
                         // If there's no ~, don't hit the disk.
                         longParts[i - startingElement] = parts[i];
@@ -529,7 +527,7 @@ internal static string GetLongPathName(
                 }
             }
 
-            return pathRoot + string.Join(s_directorySeparator, longParts);
+            return pathRoot + string.Join(s_directorySeparatorString, longParts);
         }
 
         /// <summary>
@@ -562,8 +560,7 @@ internal void SplitFileSpec(
              */
             if (recursiveDirectoryMatch == filenamePart)
             {
-                wildcardDirectoryPart += recursiveDirectoryMatch;
-                wildcardDirectoryPart += s_directorySeparator;
+                wildcardDirectoryPart = $"{wildcardDirectoryPart}{recursiveDirectoryMatch}{s_directorySeparatorString}";
                 filenamePart = "*.*";
             }
 
@@ -1107,7 +1104,7 @@ private static RecursiveStepResult GetFilesRecursiveStep(
                 // or we've reached the end of the wildcard directory elements,
                 considerFiles = true;
             }
-            else if (recursionState.RemainingWildcardDirectory.IndexOf(recursiveDirectoryMatch, StringComparison.Ordinal) == 0)
+            else if (recursionState.RemainingWildcardDirectory.StartsWith(recursiveDirectoryMatch, StringComparison.Ordinal))
             {
                 // or, we've reached a "**" so everything else is matched recursively.
                 considerFiles = true;
@@ -1211,22 +1208,10 @@ internal static string RegularExpressionFromFileSpec(
         /// </summary>
         /// <returns>True if both parts meet all conditions for a legal filespec.</returns>
         private static bool IsLegalFileSpec(string wildcardDirectoryPart, string filenamePart) =>
-            !HasDotDot(wildcardDirectoryPart)
+            !wildcardDirectoryPart.Contains("..")
             && !HasMisplacedRecursiveOperator(wildcardDirectoryPart)
             && !HasMisplacedRecursiveOperator(filenamePart);
 
-        private static bool HasDotDot(string str)
-        {
-            for (int i = 0; i < str.Length - 1; i++)
-            {
-                if (str[i] == '.' && str[i + 1] == '.')
-                {
-                    return true;
-                }
-            }
-            return false;
-        }
-
         private static bool HasMisplacedRecursiveOperator(string str)
         {
             for (int i = 0; i < str.Length - 1; i++)
@@ -1585,7 +1570,7 @@ internal void GetFileSpecInfo(
         internal static bool RawFileSpecIsValid(string filespec)
         {
             // filespec cannot contain illegal characters
-            if (-1 != filespec.IndexOfAny(s_invalidPathChars))
+            if (filespec.AsSpan().IndexOfAny(MSBuildConstants.InvalidPathChars) >= 0)
             {
                 return false;
             }
@@ -1595,7 +1580,7 @@ internal static bool RawFileSpecIsValid(string filespec)
              *
              * Any path with "..." in it is illegal.
              */
-            if (-1 != filespec.IndexOf("...", StringComparison.Ordinal))
+            if (filespec.Contains("..."))
             {
                 return false;
             }
@@ -1607,12 +1592,12 @@ internal static bool RawFileSpecIsValid(string filespec)
              *        http://www.website.com
              *
              */
-            int rightmostColon = filespec.LastIndexOf(":", StringComparison.Ordinal);
+            int rightmostColon = filespec.LastIndexOf(':');
 
             if
             (
-                -1 != rightmostColon
-                && 1 != rightmostColon)
+                rightmostColon >= 0
+                && rightmostColon != 1)
             {
                 return false;
             }
@@ -2229,7 +2214,7 @@ internal static string Normalize(string aString)
                 // replace multiple slashes with the OS separator
                 else if (afterSlashesIndex > index)
                 {
-                    sb.Append(s_directorySeparator);
+                    sb.Append(s_directorySeparatorString);
                 }
 
                 // skip non-slashes
@@ -2526,7 +2511,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
                                 Debug.Assert(excludeState.SearchData.RegexFileMatch != null || excludeState.SearchData.DirectoryPattern != null,
                                     "Expected Regex or directory pattern to be used for exclude file matching");
                                 excludeState.BaseDirectory = state.BaseDirectory;
-                                excludeState.RemainingWildcardDirectory = recursiveDirectoryMatch + s_directorySeparator;
+                                excludeState.RemainingWildcardDirectory = recursiveDirectoryMatch + s_directorySeparatorString;
                                 searchesToExclude.Add(excludeState);
                             }
                         }
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index e8fbff8e6e3..911439a8bb0 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -7,6 +7,9 @@
 #else
 using Microsoft.Build.Shared.Concurrent;
 #endif
+#if NET
+using System.Buffers;
+#endif
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
@@ -71,7 +74,7 @@ public static bool GetIsFileSystemCaseSensitive()
         {
             try
             {
-                string pathWithUpperCase = Path.Combine(Path.GetTempPath(), "CASESENSITIVETEST" + Guid.NewGuid().ToString("N"));
+                string pathWithUpperCase = Path.Combine(Path.GetTempPath(), $"CASESENSITIVETEST{Guid.NewGuid():N}");
                 using (new FileStream(pathWithUpperCase, FileMode.CreateNew, FileAccess.ReadWrite, FileShare.None, 0x1000, FileOptions.DeleteOnClose))
                 {
                     string lowerCased = pathWithUpperCase.ToLowerInvariant();
@@ -91,20 +94,24 @@ public static bool GetIsFileSystemCaseSensitive()
         /// Copied from https://github.com/dotnet/corefx/blob/056715ff70e14712419d82d51c8c50c54b9ea795/src/Common/src/System/IO/PathInternal.Windows.cs#L61
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/dotnet/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-        internal static readonly char[] InvalidPathChars =
+#if NET
+        internal static readonly SearchValues<char> InvalidPathChars = SearchValues.Create(
+#else
+        internal static readonly char[] InvalidPathChars = (
+#endif
         [
             '|', '\0',
             (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10,
             (char)11, (char)12, (char)13, (char)14, (char)15, (char)16, (char)17, (char)18, (char)19, (char)20,
             (char)21, (char)22, (char)23, (char)24, (char)25, (char)26, (char)27, (char)28, (char)29, (char)30,
             (char)31
-        ];
+        ]);
 
         /// <summary>
         /// Copied from https://github.com/dotnet/corefx/blob/387cf98c410bdca8fd195b28cbe53af578698f94/src/System.Runtime.Extensions/src/System/IO/Path.Windows.cs#L18
         /// MSBuild should support the union of invalid path chars across the supported OSes, so builds can have the same behaviour crossplatform: https://github.com/dotnet/msbuild/issues/781#issuecomment-243942514
         /// </summary>
-        internal static readonly char[] InvalidFileNameChars =
+        internal static readonly char[] InvalidFileNameCharsArray =
         [
             '\"', '<', '>', '|', '\0',
             (char)1, (char)2, (char)3, (char)4, (char)5, (char)6, (char)7, (char)8, (char)9, (char)10,
@@ -113,6 +120,12 @@ public static bool GetIsFileSystemCaseSensitive()
             (char)31, ':', '*', '?', '\\', '/'
         ];
 
+#if NET
+        internal static readonly SearchValues<char> InvalidFileNameChars = SearchValues.Create(InvalidFileNameCharsArray);
+#else
+        internal static char[] InvalidFileNameChars => InvalidFileNameCharsArray;
+#endif
+
         internal static readonly char[] Slashes = { '/', '\\' };
 
         internal static readonly string DirectorySeparatorString = Path.DirectorySeparatorChar.ToString();
@@ -179,7 +192,7 @@ internal static bool CanWriteToDirectory(string directory)
         {
             try
             {
-                string testFilePath = Path.Combine(directory, $"MSBuild_{Guid.NewGuid().ToString("N")}_testFile.txt");
+                string testFilePath = Path.Combine(directory, $"MSBuild_{Guid.NewGuid():N}_testFile.txt");
                 FileInfo file = new(testFilePath);
                 file.Directory.Create(); // If the directory already exists, this method does nothing.
                 File.WriteAllText(testFilePath, $"MSBuild process {EnvironmentUtilities.CurrentProcessId} successfully wrote to file.");
@@ -258,7 +271,11 @@ internal static string EnsureTrailingNoLeadingSlash(string path, int start)
 
             return FixFilePath(start < stop && IsSlash(path[stop - 1]) ?
                 path.Substring(start) :
+#if NET
+                string.Concat(path.AsSpan(start), new(in Path.DirectorySeparatorChar)));
+#else
                 path.Substring(start) + Path.DirectorySeparatorChar);
+#endif
         }
 
         /// <summary>
@@ -315,7 +332,11 @@ internal static string EnsureQuotes(string path, bool isSingleQuote = true)
                 // Special case: convert the quotes.
                 if (path.Length > 1 && path[0] == convertQuote && path[path.Length - 1] == convertQuote)
                 {
+#if NET
+                    path = $"{targetQuote}{path.AsSpan(1, path.Length - 2)}{targetQuote}";
+#else
                     path = $"{targetQuote}{path.Substring(1, path.Length - 2)}{targetQuote}";
+#endif
                 }
                 // Enclose the path in a set of the 'target' quote unless the string is already quoted with the 'target' quotes.
                 else if (path.Length == 1 || path[0] != targetQuote || path[path.Length - 1] != targetQuote)
@@ -752,14 +773,20 @@ internal static bool HasExtension(string fileName, string[] allowedExtensions)
         /// </summary>
         /// <param name="fileSpec">The file spec to get the full path of.</param>
         /// <param name="currentDirectory"></param>
-        /// <returns>full path</returns>
-        internal static string GetFullPath(string fileSpec, string currentDirectory)
+        /// <param name="escape">Whether to escape the path after getting the full path.</param>
+        /// <returns>Full path to the file, escaped if not specified otherwise.</returns>
+        internal static string GetFullPath(string fileSpec, string currentDirectory, bool escape = true)
         {
             // Sending data out of the engine into the filesystem, so time to unescape.
             fileSpec = FixFilePath(EscapingUtilities.UnescapeAll(fileSpec));
 
-            // Data coming back from the filesystem into the engine, so time to escape it back.
-            string fullPath = EscapingUtilities.Escape(NormalizePath(Path.Combine(currentDirectory, fileSpec)));
+            string fullPath = NormalizePath(Path.Combine(currentDirectory, fileSpec));
+            // In some cases we might want to NOT escape in order to preserve symbols like @, %, $ etc.
+            if (escape)
+            {
+                // Data coming back from the filesystem into the engine, so time to escape it back.
+                fullPath = EscapingUtilities.Escape(fullPath);
+            }
 
             if (NativeMethodsShared.IsWindows && !EndsWithSlash(fullPath))
             {
@@ -838,17 +865,23 @@ internal static string NormalizePathForComparisonNoThrow(string path, string cur
 
         internal static bool PathIsInvalid(string path)
         {
-            if (path.IndexOfAny(InvalidPathChars) >= 0)
-            {
-                return true;
-            }
-
             // Path.GetFileName does not react well to malformed filenames.
             // For example, Path.GetFileName("a/b/foo:bar") returns bar instead of foo:bar
             // It also throws exceptions on illegal path characters
-            var lastDirectorySeparator = path.LastIndexOfAny(Slashes);
-
-            return path.IndexOfAny(InvalidFileNameChars, lastDirectorySeparator >= 0 ? lastDirectorySeparator + 1 : 0) >= 0;
+#if NET
+            if (!path.AsSpan().ContainsAny(InvalidPathChars))
+            {
+                int lastDirectorySeparator = path.LastIndexOfAny(Slashes);
+                return path.AsSpan(lastDirectorySeparator >= 0 ? lastDirectorySeparator + 1 : 0).ContainsAny(InvalidFileNameChars);
+            }
+#else
+            if (path.IndexOfAny(InvalidPathChars) < 0)
+            {
+                int lastDirectorySeparator = path.LastIndexOfAny(Slashes);
+                return path.IndexOfAny(InvalidFileNameChars, lastDirectorySeparator >= 0 ? lastDirectorySeparator + 1 : 0) >= 0;
+            }
+#endif
+            return true;
         }
 
         /// <summary>
@@ -1532,12 +1565,20 @@ internal static void ClearFileExistenceCache()
 
         internal static void ReadFromStream(this Stream stream, byte[] content, int startIndex, int length)
         {
-#if NET7_0_OR_GREATER
+#if NET
             stream.ReadExactly(content, startIndex, length);
 #else
-#pragma warning disable CA2022 // Avoid inexact read with 'Stream.Read'
-            stream.Read(content, 0, length);
-#pragma warning restore CA2022 // Avoid inexact read with 'Stream.Read'
+            int bytesRead = 0;
+            while (bytesRead < length)
+            {
+                int read = stream.Read(content, startIndex + bytesRead, length - bytesRead);
+                if (read == 0)
+                {
+                    throw new EndOfStreamException();
+                }
+
+                bytesRead += read;
+            }
 #endif
         }
     }
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index 76e283a1a2a..c35f1f9ed5f 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -52,7 +52,11 @@ internal static bool StartsWithDrivePattern(string pattern)
             // first character must be a letter,
             // second character must be a ":"
             return pattern.Length >= 2 &&
+#if NET
+                char.IsAsciiLetter(pattern[0]) &&
+#else
                 ((pattern[0] >= 'A' && pattern[0] <= 'Z') || (pattern[0] >= 'a' && pattern[0] <= 'z')) &&
+#endif
                 pattern[1] == ':';
         }
 
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 2bc28819c6e..458272bcc30 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -97,7 +97,7 @@ internal static class FrameworkLocationHelper
         private const string dotNetFrameworkRegistryKeyV20 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionV20;
 
         internal static string dotNetFrameworkVersionFolderPrefixV30 = NativeMethodsShared.IsWindows ? "v3.0" : "3.0"; // v3.0 is for WinFx.
-        private static string s_dotNetFrameworkRegistryKeyV30 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV30 + "\\Setup";
+        private static readonly string s_dotNetFrameworkRegistryKeyV30 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV30 + "\\Setup";
 
 #if FEATURE_WIN32_REGISTRY
         private const string fallbackDotNetFrameworkSdkRegistryInstallPath = "SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows";
@@ -111,7 +111,7 @@ internal static class FrameworkLocationHelper
         private const string fullDotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A = "HKEY_LOCAL_MACHINE\\" + dotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
 
         internal static string dotNetFrameworkVersionFolderPrefixV35 = NativeMethodsShared.IsWindows ? "v3.5" : "3.5"; // v3.5 is for Orcas.
-        private static string s_dotNetFrameworkRegistryKeyV35 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV35;
+        private static readonly string s_dotNetFrameworkRegistryKeyV35 = dotNetFrameworkSetupRegistryPath + "\\" + dotNetFrameworkVersionFolderPrefixV35;
 
         internal const string fullDotNetFrameworkSdkRegistryKeyV35OnVS10 = fullDotNetFrameworkSdkRegistryPathForV35ToolsOnWinSDK70A;
         internal const string fullDotNetFrameworkSdkRegistryKeyV35OnVS11 = fullDotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
@@ -512,7 +512,7 @@ private static string FallbackDotNetFrameworkSdkInstallPath
                                 fallbackDotNetFrameworkSdkRegistryInstallPath,
                                 fallbackDotNetFrameworkSdkInstallKeyValue);
 
-                        if (EnvironmentUtilities.Is64BitProcess && s_fallbackDotNetFrameworkSdkInstallPath == null)
+                        if (Environment.Is64BitProcess && s_fallbackDotNetFrameworkSdkInstallPath == null)
                         {
                             // Since we're 64-bit, what we just checked was the 64-bit fallback key -- so now let's
                             // check the 32-bit one too, just in case.
@@ -773,8 +773,7 @@ internal static string FindDotNetFrameworkPath(
         {
             if (!NativeMethodsShared.IsWindows)
             {
-                if (!string.IsNullOrEmpty(prefix)
-                    && prefix.Substring(0, 1).Equals("v", StringComparison.OrdinalIgnoreCase))
+                if (!string.IsNullOrEmpty(prefix) && prefix[0] is 'v' or 'V')
                 {
                     prefix = prefix.Substring(1);
                 }
@@ -813,8 +812,12 @@ internal static string FindDotNetFrameworkPath(
                 // the path is something like 'C:\MyPath\64\Framework64'.  9 = length of 'Framework', to make the index match
                 // the location of the '64'.
                 int indexOf64 = indexOfFramework64 + 9;
-                string tempLocation = baseLocation;
-                baseLocation = tempLocation.Substring(0, indexOf64) + tempLocation.Substring(indexOf64 + 2, tempLocation.Length - indexOf64 - 2);
+                baseLocation =
+#if NET
+                    string.Concat(baseLocation.AsSpan(0, indexOf64), baseLocation.AsSpan(indexOf64 + 2));
+#else
+                    baseLocation.Substring(0, indexOf64) + baseLocation.Substring(indexOf64 + 2);
+#endif
             }
             else if (indexOfFramework64 == -1 && architecture == DotNetFrameworkArchitecture.Bitness64)
             {
diff --git a/src/Shared/IElementLocation.cs b/src/Shared/IElementLocation.cs
index 4824e758d86..57fb254271c 100644
--- a/src/Shared/IElementLocation.cs
+++ b/src/Shared/IElementLocation.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Framework;
 
 #nullable disable
 
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 123d102440d..cb7123038f0 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -18,11 +18,6 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Framework.Profiler;
 using System.Collections;
-using System.Linq;
-#endif
-
-#if FEATURE_APPDOMAIN
-using TaskEngineAssemblyResolver = Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver;
 #endif
 
 #nullable disable
@@ -271,15 +266,17 @@ internal abstract class LogMessagePacketBase : INodePacket
         /// </summary>
         private static readonly int s_defaultPacketVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
 
+#if TASKHOST
         /// <summary>
         /// Dictionary of methods used to read BuildEventArgs.
         /// </summary>
-        private static Dictionary<LoggingEventType, MethodInfo> s_readMethodCache = new Dictionary<LoggingEventType, MethodInfo>();
+        private static readonly Dictionary<LoggingEventType, MethodInfo> s_readMethodCache = new Dictionary<LoggingEventType, MethodInfo>();
 
+#endif
         /// <summary>
         /// Dictionary of methods used to write BuildEventArgs.
         /// </summary>
-        private static Dictionary<LoggingEventType, MethodInfo> s_writeMethodCache = new Dictionary<LoggingEventType, MethodInfo>();
+        private static readonly Dictionary<LoggingEventType, MethodInfo> s_writeMethodCache = new Dictionary<LoggingEventType, MethodInfo>();
 
         /// <summary>
         /// Delegate for translating targetfinished events.
@@ -431,14 +428,14 @@ internal void WriteToStream(ITranslator translator)
             bool eventCanSerializeItself = methodInfo != null;
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
-                if (_buildEvent is ProjectEvaluationStartedEventArgs
-                    or ProjectEvaluationFinishedEventArgs
-                    or ResponseFileUsedEventArgs)
-                {
-                    // switch to serialization methods that we provide in this file
-                    // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
-                    eventCanSerializeItself = false;
-                }
+            if (_buildEvent is ProjectEvaluationStartedEventArgs
+                or ProjectEvaluationFinishedEventArgs
+                or ResponseFileUsedEventArgs)
+            {
+                // switch to serialization methods that we provide in this file
+                // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
+                eventCanSerializeItself = false;
+            }
 #endif
 
             translator.Translate(ref eventCanSerializeItself);
@@ -479,6 +476,8 @@ internal void ReadFromStream(ITranslator translator)
 
             if (eventCanSerializeItself)
             {
+
+#if TASKHOST
                 MethodInfo methodInfo = null;
                 lock (s_readMethodCache)
                 {
@@ -493,6 +492,11 @@ internal void ReadFromStream(ITranslator translator)
                 ArgsReaderDelegate readerMethod = (ArgsReaderDelegate)CreateDelegateRobust(typeof(ArgsReaderDelegate), _buildEvent, methodInfo);
 
                 readerMethod(translator.Reader, packetVersion);
+
+#else
+                _buildEvent.CreateFromStream(translator.Reader, packetVersion);
+#endif
+
                 if (_eventType == LoggingEventType.TargetFinishedEvent && _targetFinishedTranslator != null)
                 {
                     _targetFinishedTranslator(translator, (TargetFinishedEventArgs)_buildEvent);
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index 7427c5ed735..b5396133c08 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -6,7 +6,6 @@
 using System.IO;
 using System.Reflection;
 using System.Runtime.Loader;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
diff --git a/src/Shared/MSBuildNameIgnoreCaseComparer.cs b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
index 9517b5f2646..e8e9a65b9eb 100644
--- a/src/Shared/MSBuildNameIgnoreCaseComparer.cs
+++ b/src/Shared/MSBuildNameIgnoreCaseComparer.cs
@@ -64,6 +64,9 @@ public bool Equals(string compareToString, string constrainedString, int start,
                 return false;
             }
 
+#if NET
+            return compareToString.AsSpan().Equals(constrainedString.AsSpan(start, lengthToCompare), StringComparison.OrdinalIgnoreCase);
+#else
             if (lengthToCompare != compareToString.Length)
             {
                 return false;
@@ -104,6 +107,7 @@ public bool Equals(string compareToString, string constrainedString, int start,
             }
 
             return true;
+#endif
         }
 
         /// <summary>
diff --git a/src/Shared/Modifiers.cs b/src/Shared/Modifiers.cs
index a6c203525d2..d7e77955644 100644
--- a/src/Shared/Modifiers.cs
+++ b/src/Shared/Modifiers.cs
@@ -69,7 +69,7 @@ internal static class ItemSpecModifiers
                     DefiningProjectExtension
                 };
 
-            private static HashSet<string> s_tableOfItemSpecModifiers = new HashSet<string>(All, StringComparer.OrdinalIgnoreCase);
+            private static readonly HashSet<string> s_tableOfItemSpecModifiers = new HashSet<string>(All, StringComparer.OrdinalIgnoreCase);
 
             /// <summary>
             /// Indicates if the given name is reserved for an item-spec modifier.
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index bf31c0193f6..25094e59035 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -1,7 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Diagnostics;
 using System.IO;
 
 namespace Microsoft.Build.Shared
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 70629ecf2d8..fbaeb4dbde2 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -8,16 +8,18 @@
 #else
 using System.Collections.Concurrent;
 #endif
-using System.IO;
-using System.IO.Pipes;
 using System.Threading;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
+using System.IO.Pipes;
+using System.IO;
+
 #if FEATURE_SECURITY_PERMISSIONS || FEATURE_PIPE_SECURITY
 using System.Security.AccessControl;
 #endif
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
 using System.Security.Principal;
+
 #endif
 #if NET451_OR_GREATER || NETCOREAPP
 using System.Threading.Tasks;
@@ -494,7 +496,7 @@ private void PacketPumpProc()
             {
                 if (localPipeServer.IsConnected)
                 {
-#if NETCOREAPP // OperatingSystem.IsWindows() is new in .NET 5.0
+#if NET // OperatingSystem.IsWindows() is new in .NET 5.0
                     if (OperatingSystem.IsWindows())
 #endif
                     {
@@ -522,7 +524,7 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
 #if NET451_OR_GREATER
             Task<int> readTask = localReadPipe.ReadAsync(headerByte, 0, headerByte.Length, CancellationToken.None);
 #elif NETCOREAPP
-            Task<int> readTask = CommunicationsUtilities.ReadAsync(localReadPipe, headerByte, headerByte.Length);
+            Task<int> readTask = CommunicationsUtilities.ReadAsync(localReadPipe, headerByte, headerByte.Length).AsTask();
 #else
             IAsyncResult result = localReadPipe.BeginRead(headerByte, 0, headerByte.Length, null, null);
 #endif
@@ -614,7 +616,7 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
 #if NET451_OR_GREATER
                             readTask = localReadPipe.ReadAsync(headerByte, 0, headerByte.Length, CancellationToken.None);
 #elif NETCOREAPP
-                            readTask = CommunicationsUtilities.ReadAsync(localReadPipe, headerByte, headerByte.Length);
+                            readTask = CommunicationsUtilities.ReadAsync(localReadPipe, headerByte, headerByte.Length).AsTask();
 #else
                             result = localReadPipe.BeginRead(headerByte, 0, headerByte.Length, null, null);
 #endif
diff --git a/src/Shared/NodePipeBase.cs b/src/Shared/NodePipeBase.cs
new file mode 100644
index 00000000000..fd1d08efe9c
--- /dev/null
+++ b/src/Shared/NodePipeBase.cs
@@ -0,0 +1,271 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.IO.Pipes;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
+
+#if !TASKHOST
+using System.Buffers.Binary;
+using System.Threading.Tasks;
+using Microsoft.Build.Eventing;
+#endif
+
+namespace Microsoft.Build.Internal
+{
+    internal abstract class NodePipeBase : IDisposable
+    {
+        /// <summary>
+        /// A packet header consists of 1 byte (enum) for the packet type + 4 bytes (int32) for the packet length.
+        /// </summary>
+        private const int HeaderLength = 5;
+
+        /// <summary>
+        /// The size of the intermediate in-memory buffers.
+        /// </summary>
+        private const int InitialBufferSize = 131_072;
+
+        /// <summary>
+        /// The maximum number of bytes to write in a single operation.
+        /// </summary>
+        private const int MaxPacketWriteSize = 104_8576;
+
+        /// <summary>
+        /// A reusable buffer for reading the packet header.
+        /// </summary>
+        private readonly byte[] _headerData = new byte[HeaderLength];
+
+        /// <summary>
+        /// A buffer typically big enough to handle a packet body.
+        /// We use this as a convenient way to manage and cache a byte[] that's resized
+        /// automatically to fit our payload.
+        /// </summary>
+        private readonly MemoryStream _readBuffer = new(InitialBufferSize);
+
+        /// <summary>
+        /// A buffer typically big enough to handle a packet body.
+        /// We use this as a convenient way to manage and cache a byte[] that's resized
+        /// automatically to fit our payload.
+        /// </summary>
+        private readonly MemoryStream _writeBuffer = new(InitialBufferSize);
+
+        private readonly ITranslator _readTranslator;
+
+        private readonly ITranslator _writeTranslator;
+
+        /// <summary>
+        /// The packet factory to be used for deserialization, as packet types may have custom factory logic.
+        /// </summary>
+        private INodePacketFactory? _packetFactory;
+
+        protected NodePipeBase(string pipeName, Handshake handshake)
+        {
+            PipeName = pipeName;
+            HandshakeComponents = handshake.RetrieveHandshakeComponents();
+            _readTranslator = BinaryTranslator.GetReadTranslator(_readBuffer, InterningBinaryReader.CreateSharedBuffer());
+            _writeTranslator = BinaryTranslator.GetWriteTranslator(_writeBuffer);
+        }
+
+        protected abstract PipeStream NodeStream { get; }
+
+        protected string PipeName { get; }
+
+        protected int[] HandshakeComponents { get; }
+
+        public void Dispose()
+        {
+            _readBuffer.Dispose();
+            _writeBuffer.Dispose();
+            _readTranslator.Dispose();
+            _writeTranslator.Dispose();
+            NodeStream.Dispose();
+        }
+
+        internal void RegisterPacketFactory(INodePacketFactory packetFactory) => _packetFactory = packetFactory;
+
+        internal void WritePacket(INodePacket packet)
+        {
+            int messageLength = WritePacketToBuffer(packet);
+            byte[] buffer = _writeBuffer.GetBuffer();
+
+            for (int i = 0; i < messageLength; i += MaxPacketWriteSize)
+            {
+                int lengthToWrite = Math.Min(messageLength - i, MaxPacketWriteSize);
+                NodeStream.Write(buffer, i, lengthToWrite);
+            }
+        }
+
+        internal INodePacket ReadPacket()
+        {
+            // Read the header.
+            int headerBytesRead = Read(_headerData, HeaderLength);
+
+            // When an active connection is broken, any pending read will return 0 bytes before the pipe transitions to
+            // the broken state. As this is expected behavior, don't throw an exception if no packet is pending, A node
+            // may disconnect without waiting on the other end to gracefully cancel, and the caller can decide whether
+            // this was intentional.
+            if (headerBytesRead == 0)
+            {
+                return new NodeShutdown(NodeShutdownReason.ConnectionFailed);
+            }
+            else if (headerBytesRead != HeaderLength)
+            {
+                throw new IOException($"Incomplete header read.  {headerBytesRead} of {HeaderLength} bytes read.");
+            }
+
+#if TASKHOST
+            int packetLength = BitConverter.ToInt32(_headerData, 1);
+#else
+            int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerData, 1, 4));
+            MSBuildEventSource.Log.PacketReadSize(packetLength);
+#endif
+
+            // Read the packet. Set the buffer length now to avoid additional resizing during the read.
+            _readBuffer.Position = 0;
+            _readBuffer.SetLength(packetLength);
+            int packetBytesRead = Read(_readBuffer.GetBuffer(), packetLength);
+
+            if (packetBytesRead < packetLength)
+            {
+                throw new IOException($"Incomplete packet read. {packetBytesRead} of {packetLength} bytes read.");
+            }
+
+            return DeserializePacket();
+        }
+
+#if !TASKHOST
+        internal async Task WritePacketAsync(INodePacket packet, CancellationToken cancellationToken = default)
+        {
+            int messageLength = WritePacketToBuffer(packet);
+            byte[] buffer = _writeBuffer.GetBuffer();
+
+            for (int i = 0; i < messageLength; i += MaxPacketWriteSize)
+            {
+                int lengthToWrite = Math.Min(messageLength - i, MaxPacketWriteSize);
+#if NET
+                await NodeStream.WriteAsync(buffer.AsMemory(i, lengthToWrite), cancellationToken).ConfigureAwait(false);
+#else
+                await NodeStream.WriteAsync(buffer, i, lengthToWrite, cancellationToken).ConfigureAwait(false);
+#endif
+            }
+        }
+
+        internal async Task<INodePacket> ReadPacketAsync(CancellationToken cancellationToken = default)
+        {
+            // Read the header.
+            int headerBytesRead = await ReadAsync(_headerData, HeaderLength, cancellationToken).ConfigureAwait(false);
+
+            // When an active connection is broken, any pending read will return 0 bytes before the pipe transitions to
+            // the broken state. As this is expected behavior, don't throw an exception if no packet is pending, A node
+            // may disconnect without waiting on the other end to gracefully cancel, and the caller can decide whether
+            // this was intentional.
+            if (headerBytesRead == 0)
+            {
+                return new NodeShutdown(NodeShutdownReason.ConnectionFailed);
+            }
+            else if (headerBytesRead != HeaderLength)
+            {
+                throw new IOException($"Incomplete header read.  {headerBytesRead} of {HeaderLength} bytes read.");
+            }
+
+            int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(_headerData, 1, 4));
+            MSBuildEventSource.Log.PacketReadSize(packetLength);
+
+            // Read the packet. Set the buffer length now to avoid additional resizing during the read.
+            _readBuffer.Position = 0;
+            _readBuffer.SetLength(packetLength);
+            int packetBytesRead = await ReadAsync(_readBuffer.GetBuffer(), packetLength, cancellationToken).ConfigureAwait(false);
+
+            if (packetBytesRead < packetLength)
+            {
+                throw new IOException($"Incomplete packet read. {packetBytesRead} of {packetLength} bytes read.");
+            }
+
+            return DeserializePacket();
+        }
+#endif
+
+        private int WritePacketToBuffer(INodePacket packet)
+        {
+            // Clear the buffer but keep the underlying capacity to avoid reallocations.
+            _writeBuffer.SetLength(HeaderLength);
+            _writeBuffer.Position = HeaderLength;
+
+            // Serialize and write the packet to the buffer.
+            packet.Translate(_writeTranslator);
+
+            // Write the header to the buffer.
+            _writeBuffer.Position = 0;
+            _writeBuffer.WriteByte((byte)packet.Type);
+            int messageLength = (int)_writeBuffer.Length;
+            _writeTranslator.Writer.Write(messageLength - HeaderLength);
+
+            return messageLength;
+        }
+
+        private int Read(byte[] buffer, int bytesToRead)
+        {
+            int totalBytesRead = 0;
+            while (totalBytesRead < bytesToRead)
+            {
+                int bytesRead = NodeStream.Read(buffer, totalBytesRead, bytesToRead - totalBytesRead);
+
+                // 0 byte read will occur if the pipe disconnects.
+                if (bytesRead == 0)
+                {
+                    break;
+                }
+
+                totalBytesRead += bytesRead;
+            }
+
+            return totalBytesRead;
+        }
+
+#if !TASKHOST
+        private async ValueTask<int> ReadAsync(byte[] buffer, int bytesToRead, CancellationToken cancellationToken)
+        {
+            int totalBytesRead = 0;
+            while (totalBytesRead < bytesToRead)
+            {
+#if NET
+                int bytesRead = await NodeStream.ReadAsync(buffer.AsMemory(totalBytesRead, bytesToRead - totalBytesRead), cancellationToken).ConfigureAwait(false);
+#else
+                int bytesRead = await NodeStream.ReadAsync(buffer, totalBytesRead, bytesToRead - totalBytesRead, cancellationToken).ConfigureAwait(false);
+#endif
+
+                // 0 byte read will occur if the pipe disconnects.
+                if (bytesRead == 0)
+                {
+                    break;
+                }
+
+                totalBytesRead += bytesRead;
+            }
+
+            return totalBytesRead;
+        }
+#endif
+
+        private INodePacket DeserializePacket()
+        {
+            if (_packetFactory == null)
+            {
+                throw new InternalErrorException("No packet factory is registered for deserialization.");
+            }
+
+            NodePacketType packetType = (NodePacketType)_headerData[0];
+            try
+            {
+                return _packetFactory.DeserializePacket(packetType, _readTranslator);
+            }
+            catch (Exception e) when (e is not InternalErrorException)
+            {
+                throw new InternalErrorException($"Exception while deserializing packet {packetType}: {e}");
+            }
+        }
+    }
+}
diff --git a/src/Shared/NodePipeClient.cs b/src/Shared/NodePipeClient.cs
new file mode 100644
index 00000000000..6585a2558e7
--- /dev/null
+++ b/src/Shared/NodePipeClient.cs
@@ -0,0 +1,90 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.IO.Pipes;
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+using System;
+using System.Security.Principal;
+#endif
+
+namespace Microsoft.Build.Internal
+{
+    internal sealed class NodePipeClient : NodePipeBase
+    {
+        /// <summary>
+        /// If true, sets a timeout for the handshake. This is only used on Unix-like socket implementations, because the
+        /// timeout on the PipeStream connection is ignore.
+        /// </summary>
+        private static readonly bool s_useHandhakeTimeout = !NativeMethodsShared.IsWindows;
+
+        private readonly NamedPipeClientStream _pipeClient;
+
+        internal NodePipeClient(string pipeName, Handshake handshake)
+            : base(pipeName, handshake) =>
+#pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+            _pipeClient = new(
+                serverName: ".",
+                pipeName,
+                PipeDirection.InOut,
+                PipeOptions.Asynchronous
+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+                | PipeOptions.CurrentUserOnly
+#endif
+            );
+#pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
+
+        protected override PipeStream NodeStream => _pipeClient;
+
+        internal void ConnectToServer(int timeout)
+        {
+            CommunicationsUtilities.Trace("Attempting connect to pipe {0} with timeout {1} ms", PipeName, timeout);
+            _pipeClient.Connect(timeout);
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+            // Verify that the owner of the pipe is us.  This prevents a security hole where a remote node has
+            // been faked up with ACLs that would let us attach to it.  It could then issue fake build requests back to
+            // us, potentially causing us to execute builds that do harmful or unexpected things.  The pipe owner can
+            // only be set to the user's own SID by a normal, unprivileged process.  The conditions where a faked up
+            // remote node could set the owner to something else would also let it change owners on other objects, so
+            // this would be a security flaw upstream of us.
+            ValidateRemotePipeOwner();
+#endif
+            PerformHandshake(s_useHandhakeTimeout ? timeout : 0);
+            CommunicationsUtilities.Trace("Successfully connected to pipe {0}...!", PipeName);
+        }
+
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+        // This code needs to be in a separate method so that we don't try (and fail) to load the Windows-only APIs when JIT-ing the code
+        //  on non-Windows operating systems
+        private void ValidateRemotePipeOwner()
+        {
+            SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
+            PipeSecurity remoteSecurity = _pipeClient.GetAccessControl();
+            IdentityReference remoteOwner = remoteSecurity.GetOwner(typeof(SecurityIdentifier));
+
+            if (remoteOwner != identifier)
+            {
+                CommunicationsUtilities.Trace("The remote pipe owner {0} does not match {1}", remoteOwner.Value, identifier.Value);
+                throw new UnauthorizedAccessException();
+            }
+        }
+#endif
+
+        /// <summary>
+        /// Connect to named pipe stream and ensure validate handshake and security.
+        /// </summary>
+        private void PerformHandshake(int timeout)
+        {
+            for (int i = 0; i < HandshakeComponents.Length; i++)
+            {
+                CommunicationsUtilities.Trace("Writing handshake part {0} ({1}) to pipe {2}", i, HandshakeComponents[i], PipeName);
+                _pipeClient.WriteIntForHandshake(HandshakeComponents[i]);
+            }
+
+            // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.
+            _pipeClient.WriteEndOfHandshakeSignal();
+
+            CommunicationsUtilities.Trace("Reading handshake from pipe {0}", PipeName);
+            _pipeClient.ReadEndOfHandshakeSignal(true, timeout);
+        }
+    }
+}
diff --git a/src/Shared/NodePipeServer.cs b/src/Shared/NodePipeServer.cs
new file mode 100644
index 00000000000..dde8e2ee371
--- /dev/null
+++ b/src/Shared/NodePipeServer.cs
@@ -0,0 +1,222 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.IO.Pipes;
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+using System.Security.AccessControl;
+using System.Security.Principal;
+#endif
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Shared;
+
+#if !TASKHOST
+using System.Threading.Tasks;
+#endif
+
+namespace Microsoft.Build.Internal
+{
+    internal sealed class NodePipeServer : NodePipeBase
+    {
+        /// <summary>
+        /// The size of kernel-level buffers used by the named pipe. If the total size of pending reads or write requests exceed
+        /// this amount (known as the quota), IO will block until either pending operations complete, or the OS increases the quota.
+        /// </summary>
+        private const int PipeBufferSize = 131_072;
+
+        /// <summary>
+        /// A timeout for the handshake. This is only used on Unix-like socket implementations, because the
+        /// timeout on the PipeStream connection is ignore.
+        /// </summary>
+        private static readonly int s_handshakeTimeout = NativeMethodsShared.IsWindows ? 0 : 60_000;
+
+        private readonly NamedPipeServerStream _pipeServer;
+
+        internal NodePipeServer(string pipeName, Handshake handshake, int maxNumberOfServerInstances = 1)
+            : base(pipeName, handshake)
+        {
+            PipeOptions pipeOptions = PipeOptions.Asynchronous;
+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+            pipeOptions |= PipeOptions.CurrentUserOnly;
+#else
+            // Restrict access to just this account.  We set the owner specifically here, and on the
+            // pipe client side they will check the owner against this one - they must have identical
+            // SIDs or the client will reject this server.  This is used to avoid attacks where a
+            // hacked server creates a less restricted pipe in an attempt to lure us into using it and
+            // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
+            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite, AccessControlType.Allow);
+            PipeSecurity security = new();
+            security.AddAccessRule(rule);
+            security.SetOwner(rule.IdentityReference);
+#endif
+
+            _pipeServer = new NamedPipeServerStream(
+                pipeName,
+                PipeDirection.InOut,
+                maxNumberOfServerInstances,
+                PipeTransmissionMode.Byte,
+                pipeOptions,
+                inBufferSize: PipeBufferSize,
+                outBufferSize: PipeBufferSize
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+                , security,
+                HandleInheritability.None
+#endif
+#pragma warning disable SA1111 // Closing parenthesis should be on line of last parameter
+                );
+#pragma warning restore SA1111 // Closing parenthesis should be on line of last parameter
+        }
+
+        protected override PipeStream NodeStream => _pipeServer;
+
+        internal LinkStatus WaitForConnection()
+        {
+            DateTime originalWaitStartTime = DateTime.UtcNow;
+            bool gotValidConnection = false;
+
+            while (!gotValidConnection)
+            {
+                gotValidConnection = true;
+                DateTime restartWaitTime = DateTime.UtcNow;
+
+                // We only wait to wait the difference between now and the last original start time, in case we have multiple hosts attempting
+                // to attach.  This prevents each attempt from resetting the timer.
+                TimeSpan usedWaitTime = restartWaitTime - originalWaitStartTime;
+                int waitTimeRemaining = Math.Max(0, CommunicationsUtilities.NodeConnectionTimeout - (int)usedWaitTime.TotalMilliseconds);
+
+                try
+                {
+                    // Wait for a connection
+#if TASKHOST
+                    IAsyncResult resultForConnection = _pipeServer.BeginWaitForConnection(null, null);
+                    CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
+                    bool connected = resultForConnection.AsyncWaitHandle.WaitOne(waitTimeRemaining, false);
+                    _pipeServer.EndWaitForConnection(resultForConnection);
+#else
+                    Task connectionTask = _pipeServer.WaitForConnectionAsync();
+                    CommunicationsUtilities.Trace("Waiting for connection {0} ms...", waitTimeRemaining);
+                    bool connected = connectionTask.Wait(waitTimeRemaining);
+#endif
+                    if (!connected)
+                    {
+                        CommunicationsUtilities.Trace("Connection timed out waiting a host to contact us.  Exiting comm thread.");
+                        return LinkStatus.ConnectionFailed;
+                    }
+
+                    CommunicationsUtilities.Trace("Parent started connecting. Reading handshake from parent");
+
+                    // The handshake protocol is a series of int exchanges.  The host sends us a each component, and we
+                    // verify it. Afterwards, the host sends an "End of Handshake" signal, to which we respond in kind.
+                    // Once the handshake is complete, both sides can be assured the other is ready to accept data.
+                    try
+                    {
+                        gotValidConnection = ValidateHandshake();
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+                        gotValidConnection &= ValidateClientIdentity();
+#endif
+                    }
+                    catch (IOException e)
+                    {
+                        // We will get here when:
+                        // 1. The host (OOP main node) connects to us, it immediately checks for user privileges
+                        //    and if they don't match it disconnects immediately leaving us still trying to read the blank handshake
+                        // 2. The host is too old sending us bits we automatically reject in the handshake
+                        // 3. We expected to read the EndOfHandshake signal, but we received something else
+                        CommunicationsUtilities.Trace("Client connection failed but we will wait for another connection. Exception: {0}", e.Message);
+                        gotValidConnection = false;
+                    }
+                    catch (InvalidOperationException)
+                    {
+                        gotValidConnection = false;
+                    }
+
+                    if (!gotValidConnection && _pipeServer.IsConnected)
+                    {
+                        _pipeServer.Disconnect();
+                    }
+                }
+                catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
+                {
+                    CommunicationsUtilities.Trace("Client connection failed.  Exiting comm thread. {0}", e);
+                    if (_pipeServer.IsConnected)
+                    {
+                        _pipeServer.Disconnect();
+                    }
+
+                    ExceptionHandling.DumpExceptionToFile(e);
+                    return LinkStatus.Failed;
+                }
+            }
+
+            return LinkStatus.Active;
+        }
+
+        internal void Disconnect()
+        {
+            try
+            {
+                if (_pipeServer.IsConnected)
+                {
+#if NET // OperatingSystem.IsWindows() is new in .NET 5.0
+                    if (OperatingSystem.IsWindows())
+#endif
+                    {
+                        _pipeServer.WaitForPipeDrain();
+                    }
+
+                    _pipeServer.Disconnect();
+                }
+            }
+            catch (Exception)
+            {
+                // We don't really care if Disconnect somehow fails, but it gives us a chance to do the right thing.
+            }
+        }
+
+        private bool ValidateHandshake()
+        {
+            for (int i = 0; i < HandshakeComponents.Length; i++)
+            {
+                // This will disconnect a < 16.8 host; it expects leading 00 or F5 or 06. 0x00 is a wildcard.
+                int handshakePart = _pipeServer.ReadIntForHandshake(byteToAccept: i == 0 ? CommunicationsUtilities.handshakeVersion : null, s_handshakeTimeout);
+
+                if (handshakePart != HandshakeComponents[i])
+                {
+                    CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshakePart, HandshakeComponents[i]);
+                    _pipeServer.WriteIntForHandshake(i + 1);
+                    return false;
+                }
+            }
+
+            // To ensure that our handshake and theirs have the same number of bytes, receive and send a magic number indicating EOS.
+            _pipeServer.ReadEndOfHandshakeSignal(false, s_handshakeTimeout);
+
+            CommunicationsUtilities.Trace("Successfully connected to parent.");
+            _pipeServer.WriteEndOfHandshakeSignal();
+
+            return true;
+        }
+
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+        private bool ValidateClientIdentity()
+        {
+            // We will only talk to a host that was started by the same user as us.  Even though the pipe access is set to only allow this user, we want to ensure they
+            // haven't attempted to change those permissions out from under us.  This ensures that the only way they can truly gain access is to be impersonating the
+            // user we were started by.
+            WindowsIdentity currentIdentity = WindowsIdentity.GetCurrent();
+            WindowsIdentity? clientIdentity = null;
+            _pipeServer.RunAsClient(() => { clientIdentity = WindowsIdentity.GetCurrent(true); });
+
+            if (clientIdentity == null || !string.Equals(clientIdentity.Name, currentIdentity.Name, StringComparison.OrdinalIgnoreCase))
+            {
+                CommunicationsUtilities.Trace("Handshake failed. Host user is {0} but we were created by {1}.", (clientIdentity == null) ? "<unknown>" : clientIdentity.Name, currentIdentity.Name);
+                return false;
+            }
+
+            return true;
+        }
+#endif
+
+    }
+}
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index 18b9b361e3b..c21db16aa0e 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -61,18 +61,18 @@ internal static string GetNearestPlatform(string overridePlatformValue, string r
             // Prioritize platformLookupTable **metadata** attached to the ProjectReference item
             // before the current project's table. We do this to allow per-ProjectReference fine tuning.
             else if (projectReferenceLookupTable != null &&
-                    projectReferenceLookupTable.ContainsKey(currentProjectPlatform) &&
-                    projectReferencePlatforms.Contains(projectReferenceLookupTable[currentProjectPlatform]))
+                    projectReferenceLookupTable.TryGetValue(currentProjectPlatform, out string? value) &&
+                    projectReferencePlatforms.Contains(value))
             {
-                buildProjectReferenceAs = projectReferenceLookupTable[currentProjectPlatform];
+                buildProjectReferenceAs = value;
                 log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, projectReferenceLookupTableMetadata);
             }
             // Current project's translation table follows
             else if (currentProjectLookupTable != null &&
-                    currentProjectLookupTable.ContainsKey(currentProjectPlatform) &&
-                    projectReferencePlatforms.Contains(currentProjectLookupTable[currentProjectPlatform]))
+                    currentProjectLookupTable.TryGetValue(currentProjectPlatform, out value) &&
+                    projectReferencePlatforms.Contains(value))
             {
-                buildProjectReferenceAs = currentProjectLookupTable[currentProjectPlatform];
+                buildProjectReferenceAs = value;
                 log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.FoundMappingInTable", currentProjectPlatform, buildProjectReferenceAs, platformLookupTable);
             }
             // AnyCPU if possible
diff --git a/src/Shared/ProcessExtensions.cs b/src/Shared/ProcessExtensions.cs
index 362a8b0a8c1..d13ebbac5fe 100644
--- a/src/Shared/ProcessExtensions.cs
+++ b/src/Shared/ProcessExtensions.cs
@@ -11,7 +11,7 @@ internal static class ProcessExtensions
     {
         public static void KillTree(this Process process, int timeoutMilliseconds)
         {
-#if NETCOREAPP
+#if NET
             process.Kill(entireProcessTree: true);
 #else
             if (NativeMethodsShared.IsWindows)
diff --git a/src/Shared/ProjectWriter.cs b/src/Shared/ProjectWriter.cs
index fa2e6f76a1c..d0b57944440 100644
--- a/src/Shared/ProjectWriter.cs
+++ b/src/Shared/ProjectWriter.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.IO;
 using System.Text;
 using System.Text.RegularExpressions;
@@ -15,7 +14,7 @@ namespace Microsoft.Build.Shared
     /// This class is used to save MSBuild project files. It contains special handling for MSBuild notations that are not saved
     /// correctly by the XML DOM's default save mechanism.
     /// </summary>
-    internal sealed class ProjectWriter : XmlTextWriter
+    internal sealed partial class ProjectWriter : XmlTextWriter
     {
         #region Regular expressions for item vector transforms
 
@@ -28,9 +27,7 @@ internal sealed class ProjectWriter : XmlTextWriter
         // Note that the pattern is more strict than the rules for valid XML element names.
         internal const string itemTypeOrMetadataNameSpecification = @"[A-Za-z_][A-Za-z_0-9\-]*";
 
-        // the portion of an item transform that is the function that we wish to execute on the item
-        internal const string itemFunctionNameSpecification = @"[A-Za-z]*";
-
+        // regular expression used to match item vector transforms
         // description of an item vector transform, including the optional separator specification
         private const string itemVectorTransformSpecification =
             @"(?<PREFIX>@\(\s*)
@@ -40,15 +37,9 @@ internal sealed class ProjectWriter : XmlTextWriter
               (?<SUFFIX>\s*\))";
         // )
 
-        // regular expression used to match item vector transforms
-        // internal for unit testing only
-        internal static readonly Lazy<Regex> itemVectorTransformPattern = new Lazy<Regex>(
-            () =>
-                new Regex(itemVectorTransformSpecification,
-                    RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled));
-
         // description of an item vector transform, including the optional separator specification, but with no (named) capturing
         // groups -- see the WriteString() method for details
+        // regular expression used to match item vector transforms, with no (named) capturing groups
         private const string itemVectorTransformRawSpecification =
             @"@\(\s*
                 (" + itemTypeOrMetadataNameSpecification + @")
@@ -56,12 +47,21 @@ internal sealed class ProjectWriter : XmlTextWriter
                 (\s*,\s*'[^']*')?
               \s*\)";
 
-        // regular expression used to match item vector transforms, with no (named) capturing groups
-        // internal for unit testing only
-        internal static readonly Lazy<Regex> itemVectorTransformRawPattern = new Lazy<Regex>(
-            () =>
-                new Regex(itemVectorTransformRawSpecification,
-                    RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled));
+#if NET
+        [GeneratedRegex(itemVectorTransformSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture)]
+        private static partial Regex ItemVectorTransformRegex { get; }
+
+        [GeneratedRegex(itemVectorTransformRawSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture)]
+        private static partial Regex ItemVectorTransformRawRegex { get; }
+#else
+        private static Regex ItemVectorTransformRegex => itemVectorTransformPattern ??=
+            new Regex(itemVectorTransformSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled);
+        private static Regex itemVectorTransformPattern;
+
+        private static Regex ItemVectorTransformRawRegex => itemVectorTransformRawPattern ??=
+            new Regex(itemVectorTransformRawSpecification, RegexOptions.IgnorePatternWhitespace | RegexOptions.ExplicitCapture | RegexOptions.Compiled);
+        private static Regex itemVectorTransformRawPattern;
+#endif
 
         /**************************************************************************************************************************
          * WARNING: The regular expressions above MUST be kept in sync with the expressions in the ItemExpander class.
@@ -130,14 +130,14 @@ internal void Initialize(XmlDocument project, XmlDeclaration projectRootElementD
         /// <param name="text"></param>
         public override void WriteString(string text)
         {
-            MatchCollection itemVectorTransforms = itemVectorTransformRawPattern.Value.Matches(text);
+            MatchCollection itemVectorTransforms = ItemVectorTransformRawRegex.Matches(text);
 
             // if the string contains any item vector transforms
             if (itemVectorTransforms.Count > 0)
             {
                 // separate out the text that surrounds the transforms
                 // NOTE: use the Regex with no (named) capturing groups, otherwise Regex.Split() will split on them
-                string[] surroundingTextPieces = itemVectorTransformRawPattern.Value.Split(text);
+                string[] surroundingTextPieces = ItemVectorTransformRawRegex.Split(text);
 
                 ErrorUtilities.VerifyThrow(itemVectorTransforms.Count == (surroundingTextPieces.Length - 1),
                     "We must have two pieces of surrounding text for every item vector transform found.");
@@ -149,7 +149,7 @@ public override void WriteString(string text)
                     base.WriteString(surroundingTextPieces[i]);
 
                     // break up the transform into its constituent pieces
-                    Match itemVectorTransform = itemVectorTransformPattern.Value.Match(itemVectorTransforms[i].Value);
+                    Match itemVectorTransform = ItemVectorTransformRegex.Match(itemVectorTransforms[i].Value);
 
                     ErrorUtilities.VerifyThrow(itemVectorTransform.Success,
                         "Item vector transform must be matched by both the raw and decorated regular expressions.");
diff --git a/src/Shared/PropertyParser.cs b/src/Shared/PropertyParser.cs
index a9e1c29d72c..48110e0ca4c 100644
--- a/src/Shared/PropertyParser.cs
+++ b/src/Shared/PropertyParser.cs
@@ -47,10 +47,10 @@ internal static bool GetTable(TaskLoggingHelper log, string parameterName, strin
                     // whitespace from beginning and end of both name and value.  (When authoring a
                     // project/targets file, people like to use whitespace and newlines to pretty up
                     // the file format.)
-                    if (indexOfEqualsSign != -1)
+                    if (indexOfEqualsSign >= 0)
                     {
-                        propertyName = propertyNameValuePair.Substring(0, indexOfEqualsSign).Trim();
-                        propertyValue = propertyNameValuePair.Substring(indexOfEqualsSign + 1).Trim();
+                        propertyName = propertyNameValuePair.AsSpan(0, indexOfEqualsSign).Trim().ToString();
+                        propertyValue = propertyNameValuePair.AsSpan(indexOfEqualsSign + 1).Trim().ToString();
                     }
 
                     // Make sure we have a property name and property value (though the value is allowed to be blank).
@@ -103,8 +103,8 @@ internal static bool GetTableWithEscaping(TaskLoggingHelper log, string paramete
                         // whitespace from beginning and end of both name and value.  (When authoring a
                         // project/targets file, people like to use whitespace and newlines to pretty up
                         // the file format.)
-                        string propertyName = propertyNameValueString.Substring(0, indexOfEqualsSign).Trim();
-                        string propertyValue = EscapingUtilities.Escape(propertyNameValueString.Substring(indexOfEqualsSign + 1).Trim());
+                        string propertyName = propertyNameValueString.AsSpan(0, indexOfEqualsSign).Trim().ToString();
+                        string propertyValue = EscapingUtilities.Escape(propertyNameValueString.AsSpan(indexOfEqualsSign + 1).Trim().ToString());
 
                         // Make sure we have a property name and property value (though the value is allowed to be blank).
                         if (propertyName.Length == 0)
diff --git a/src/Shared/QuotingUtilities.cs b/src/Shared/QuotingUtilities.cs
index 17ca8a419db..5d42939b505 100644
--- a/src/Shared/QuotingUtilities.cs
+++ b/src/Shared/QuotingUtilities.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Text;
diff --git a/src/Shared/RegisteredTaskObjectCacheBase.cs b/src/Shared/RegisteredTaskObjectCacheBase.cs
index d7d25b7d962..10391f5d336 100644
--- a/src/Shared/RegisteredTaskObjectCacheBase.cs
+++ b/src/Shared/RegisteredTaskObjectCacheBase.cs
@@ -22,7 +22,7 @@ internal class RegisteredTaskObjectCacheBase
         /// <summary>
         /// The cache for AppDomain lifetime objects.
         /// </summary>
-        private static Lazy<ConcurrentDictionary<object, object>> s_appDomainLifetimeObjects = new Lazy<ConcurrentDictionary<object, object>>();
+        private static readonly Lazy<ConcurrentDictionary<object, object>> s_appDomainLifetimeObjects = new Lazy<ConcurrentDictionary<object, object>>();
 
         /// <summary>
         /// The cache for Build lifetime objects.
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index e046c7d4c5a..7ff74c83f19 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -122,7 +122,7 @@ internal static string ExtractMessageCode(bool msbuildCodeOnly, string message,
 
             if (i < message.Length)
             {
-                message = message.Substring(i, message.Length - i);
+                message = message.Substring(i);
             }
 
             return message;
diff --git a/src/Shared/StringUtils.cs b/src/Shared/StringUtils.cs
index 10152956f27..cb109d5f9d6 100644
--- a/src/Shared/StringUtils.cs
+++ b/src/Shared/StringUtils.cs
@@ -16,6 +16,10 @@ internal static class StringUtils
         /// <returns>Random generated string of the specified length.</returns>
         public static string GenerateRandomString(int length)
         {
+#if NET
+            return string.Create(length, 0, static (dest, _) =>
+                Random.Shared.GetItems("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+_", dest));
+#else
             // Base64, 2^6 = 64
             const int eachStringCharEncodesBites = 6;
             const int eachByteHasBits = 8;
@@ -32,6 +36,7 @@ public static string GenerateRandomString(int length)
             string randomBase64String = Convert.ToBase64String(randomBytes).Replace('/', '_');
 
             return randomBase64String.Substring(0, length);
+#endif
         }
 
         /// <summary>
@@ -45,10 +50,14 @@ public static string RemoveLastInstanceOf(this string fromString, string substri
         {
             int lastOccurrenceIndex = fromString.LastIndexOf(substring, comparison);
 
-            if (lastOccurrenceIndex != -1)
+            if (lastOccurrenceIndex >= 0)
             {
-                fromString = fromString.Substring(0, lastOccurrenceIndex) +
-                             fromString.Substring(lastOccurrenceIndex + substring.Length);
+                fromString =
+#if NET
+                    $"{fromString.AsSpan(0, lastOccurrenceIndex)}{fromString.AsSpan(lastOccurrenceIndex + substring.Length)}";
+#else
+                    $"{fromString.Substring(0, lastOccurrenceIndex)}{fromString.Substring(lastOccurrenceIndex + substring.Length)}";
+#endif
             }
 
             return fromString;
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index 723a4ba240b..df56c4efc53 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Globalization;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Shared/TaskHostTaskComplete.cs b/src/Shared/TaskHostTaskComplete.cs
index 862341eaa8f..6bded722522 100644
--- a/src/Shared/TaskHostTaskComplete.cs
+++ b/src/Shared/TaskHostTaskComplete.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-#if !CLR2COMPATIBILITY
+#if !CLR2COMPATIBILITY && FEATURE_REPORTFILEACCESSES
 using Microsoft.Build.Experimental.FileAccess;
 #endif
 using Microsoft.Build.Shared;
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 979319e5d36..b79bca33d16 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -4,7 +4,9 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 using System.Globalization;
 using System.IO;
 using System.Resources;
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 3e436da8c38..3b6265ca4d9 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -4,9 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.Globalization;
-using System.Linq;
 using System.Reflection;
 #if FEATURE_APPDOMAIN
 using System.Security;
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index 190f0dddf2b..4c607dfd2b4 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -82,7 +82,7 @@ private static string CreateFolderUnderTemp()
         /// <param name="subfolder"></param>
         internal static string GetTemporaryDirectory(bool createDirectory = true, string subfolder = null)
         {
-            string temporaryDirectory = Path.Combine(TempFileDirectory, "Temporary" + Guid.NewGuid().ToString("N"), subfolder ?? string.Empty);
+            string temporaryDirectory = Path.Combine(TempFileDirectory, $"Temporary{Guid.NewGuid():N}", subfolder ?? string.Empty);
 
             if (createDirectory)
             {
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 0e2f7591b55..70002db51f0 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -279,7 +279,7 @@ private void UpdateOSMap(ConfigurationElement element)
                     {
                         if (element.ElementInformation.LineNumber != 0)
                         {
-                            locationString = String.Format("{0} ({1})", element.ElementInformation.Source, element.ElementInformation.LineNumber);
+                            locationString = $"{element.ElementInformation.Source} ({element.ElementInformation.LineNumber})";
                         }
                         else
                         {
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index 87b3a3b7e67..70b8d4e0792 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -4,8 +4,8 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
 #if DEBUG
+using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.Reflection;
 #endif
@@ -25,7 +25,7 @@ internal static class Tracing
         /// <summary>
         /// A dictionary of named counters
         /// </summary>
-        private static Dictionary<string, int> s_counts;
+        private static readonly Dictionary<string, int> s_counts;
 
         /// <summary>
         /// Last time logging happened
@@ -35,7 +35,7 @@ internal static class Tracing
         /// <summary>
         /// How often to log
         /// </summary>
-        private static TimeSpan s_interval;
+        private static readonly TimeSpan s_interval;
 
         /// <summary>
         /// A place callers can put something worth logging later
@@ -45,7 +45,7 @@ internal static class Tracing
         /// <summary>
         /// Short name of the current assembly - to distinguish statics when this type is shared into different assemblies
         /// </summary>
-        private static string s_currentAssemblyName;
+        private static readonly string s_currentAssemblyName;
 #pragma warning restore 649
 
 #if DEBUG
@@ -95,7 +95,7 @@ internal static void Slot(string tag, string value)
         [Conditional("DEBUG")]
         internal static void Slot<K, V>(string tag, KeyValuePair<K, V> value)
         {
-            Slot(tag, value.Key.ToString() + "=" + value.Key.ToString());
+            Slot(tag, $"{value.Key}={value.Key}");
         }
 
         /// <summary>
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 3a3013b36aa..7c5efa8ce3d 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -31,12 +31,12 @@ internal class TypeLoader
         /// <summary>
         /// Cache to keep track of the assemblyLoadInfos based on a given type filter.
         /// </summary>
-        private static ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfLoadedTypesByFilter = new ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>>();
+        private static readonly ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfLoadedTypesByFilter = new ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>>();
 
         /// <summary>
         /// Cache to keep track of the assemblyLoadInfos based on a given type filter for assemblies which are to be loaded for reflectionOnlyLoads.
         /// </summary>
-        private static ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfReflectionOnlyLoadedTypesByFilter = new ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>>();
+        private static readonly ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfReflectionOnlyLoadedTypesByFilter = new ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>>();
 
         /// <summary>
         /// Type filter for this typeloader
@@ -45,7 +45,7 @@ internal class TypeLoader
 
         private static MetadataLoadContext _context;
 
-        private static string[] runtimeAssemblies = findRuntimeAssembliesWithMicrosoftBuildFramework();
+        private static readonly string[] runtimeAssemblies = findRuntimeAssembliesWithMicrosoftBuildFramework();
         private static string microsoftBuildFrameworkPath;
 
         // We need to append Microsoft.Build.Framework from next to the executing assembly first to make sure it's loaded before the runtime variant.
@@ -56,10 +56,7 @@ private static string[] findRuntimeAssembliesWithMicrosoftBuildFramework()
             string[] msbuildAssemblies = Directory.GetFiles(msbuildDirectory, "*.dll");
             string[] runtimeAssemblies = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), "*.dll");
 
-            List<string> runtimeAssembliesList = new(runtimeAssemblies);
-            runtimeAssembliesList.AddRange(msbuildAssemblies);
-
-            return runtimeAssembliesList.ToArray();
+            return [.. runtimeAssemblies, .. msbuildAssemblies];
         }
 
         /// <summary>
diff --git a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
index ec407e54d29..fbeba59cf92 100644
--- a/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
+++ b/src/Shared/UnitTests/AssemblyNameEx_Tests.cs
@@ -7,7 +7,6 @@
 using System.IO;
 using System.Linq;
 using System.Reflection;
-using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 using Shouldly;
diff --git a/src/Shared/UnitTests/CommunicationUtilities_Tests.cs b/src/Shared/UnitTests/CommunicationUtilities_Tests.cs
index 84cfcd034b8..63e1e2a7197 100644
--- a/src/Shared/UnitTests/CommunicationUtilities_Tests.cs
+++ b/src/Shared/UnitTests/CommunicationUtilities_Tests.cs
@@ -6,7 +6,6 @@
 using System.Collections.Generic;
 using Shouldly;
 using Xunit;
-using Xunit.Abstractions;
 using CommunicationsUtilities = Microsoft.Build.Internal.CommunicationsUtilities;
 
 namespace Microsoft.Build.UnitTests
diff --git a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
index 32101d5d60e..689edb1e36b 100644
--- a/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
+++ b/src/Shared/UnitTests/CopyOnWriteDictionary_Tests.cs
@@ -3,8 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.IO;
-using System.Runtime.Serialization.Formatters.Binary;
 using Microsoft.Build.Collections;
 using Shouldly;
 using Xunit;
diff --git a/src/Shared/UnitTests/ErrorUtilities_Tests.cs b/src/Shared/UnitTests/ErrorUtilities_Tests.cs
index 6adbc583bd9..4bd7a10e35d 100644
--- a/src/Shared/UnitTests/ErrorUtilities_Tests.cs
+++ b/src/Shared/UnitTests/ErrorUtilities_Tests.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Xunit;
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index 6d43904420f..35235a7d0f6 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -14,7 +14,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index a99d79be223..8f2a750f675 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
index efb5d7297ab..fd5e9a82ed8 100644
--- a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
+++ b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
@@ -8,7 +8,6 @@
 using System.Runtime.Versioning;
 using Microsoft.Build.Shared;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 
 
@@ -123,7 +122,7 @@ public void SetCurrentDirectoryDoesNotSetNonexistentFolder()
             {
                 for (int i = 0; i < 10; i++)
                 {
-                    nonexistentDirectory = Path.Combine(currentDirectory, "foo", "bar", "baz") + Guid.NewGuid();
+                    nonexistentDirectory = $"{Path.Combine(currentDirectory, "foo", "bar", "baz")}{Guid.NewGuid()}";
 
                     if (!Directory.Exists(nonexistentDirectory))
                     {
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index 25e7cb3a50d..da7375f123a 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -1,11 +1,11 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System;
 using Microsoft.Build.Shared;
 
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -130,7 +130,7 @@ public void TestMergeRuntimeValuesCurrentToCore()
         public void TestArchitectureValuesMatch()
         {
             string currentArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
-            string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
+            string notCurrentArchitecture = Environment.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
             Assert.True(XMakeAttributes.ArchitectureValuesMatch(XMakeAttributes.MSBuildArchitectureValues.any, XMakeAttributes.MSBuildArchitectureValues.currentArchitecture));
             Assert.True(XMakeAttributes.ArchitectureValuesMatch(XMakeAttributes.MSBuildArchitectureValues.any, XMakeAttributes.MSBuildArchitectureValues.x64));
@@ -145,7 +145,7 @@ public void TestArchitectureValuesMatch()
         public void TestMergeArchitectureValues()
         {
             string currentArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
-            string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
+            string notCurrentArchitecture = Environment.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
             string mergedArchitecture;
             Assert.True(XMakeAttributes.TryMergeArchitectureValues(XMakeAttributes.MSBuildArchitectureValues.any, XMakeAttributes.MSBuildArchitectureValues.currentArchitecture, out mergedArchitecture));
diff --git a/src/Shared/VersionUtilities.cs b/src/Shared/VersionUtilities.cs
index 91c4721f00c..99e1e36774d 100644
--- a/src/Shared/VersionUtilities.cs
+++ b/src/Shared/VersionUtilities.cs
@@ -74,7 +74,7 @@ internal static Version ConvertToVersion(string version, bool throwException)
             // Versions must have at least a Major and a Minor (e.g. 10.0), so if it's
             // just one number without a decimal, add a decimal and a 0. Random strings
             // like "tmp" will be filtered out in the Parse() or TryParse() steps
-            if (version.IndexOf(".") == -1)
+            if (version.IndexOf('.') == -1)
             {
                 version += ".0";
             }
diff --git a/src/Shared/XMakeElements.cs b/src/Shared/XMakeElements.cs
index 991feb5796c..69528ab540a 100644
--- a/src/Shared/XMakeElements.cs
+++ b/src/Shared/XMakeElements.cs
@@ -1,6 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
-
+#if NET
+using System.Buffers;
+#endif
 using System.Collections.Generic;
 
 #nullable disable
@@ -35,7 +37,12 @@ internal static class XMakeElements
         internal const string usingTaskBody = "Task";
         internal const string sdk = "Sdk";
 
-        internal static readonly char[] InvalidTargetNameCharacters = [ '$', '@', '(', ')', '%', '*', '?', '.' ];
+#if NET
+        internal static readonly SearchValues<char> InvalidTargetNameCharacters = SearchValues.Create(
+#else
+        internal static readonly char[] InvalidTargetNameCharacters = (
+#endif
+            ['$', '@', '(', ')', '%', '*', '?', '.']);
 
         // Names that cannot be used as property or item names because they are reserved
         internal static readonly HashSet<string> ReservedItemNames =
diff --git a/src/StringTools.Benchmark/StringTools.Benchmark.csproj b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
index 763be443c66..193a82a792b 100644
--- a/src/StringTools.Benchmark/StringTools.Benchmark.csproj
+++ b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
@@ -16,12 +16,6 @@
     <PackageReference Include="BenchmarkDotNet" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(DotNetBuildSourceOnly)' != 'true'">
-    <!-- Bump these to the latest version despite transitive references to older -->
-    <PackageReference Include="System.Private.Uri" />
-    <PackageReference Include="System.Runtime" />
-  </ItemGroup>
-
   <ItemGroup>
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.csproj
index b48cd46cb93..0cb576f1675 100644
--- a/src/StringTools.UnitTests/StringTools.UnitTests.csproj
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.csproj
@@ -12,7 +12,7 @@
 
   <ItemGroup>
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
index b63fa1e4e9e..d45c242ed70 100644
--- a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
@@ -1,9 +1,5 @@
 <Project Sdk="Microsoft.NET.Sdk">
 
-  <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
-       a .props file that prevents building the project from doing much of anything. -->
-  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="'$(MSBuildRuntimeType)' == 'Core'" />
-
   <PropertyGroup>
     <TargetFrameworks>$(FullFrameworkTFM)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
diff --git a/src/StringTools/FowlerNollVo1aHash.cs b/src/StringTools/FowlerNollVo1aHash.cs
index 5a9a876e4c0..56c2ca80891 100644
--- a/src/StringTools/FowlerNollVo1aHash.cs
+++ b/src/StringTools/FowlerNollVo1aHash.cs
@@ -1,8 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Runtime.InteropServices;
-using System;
 
 namespace Microsoft.NET.StringTools
 {
diff --git a/src/StringTools/InternableString.cs b/src/StringTools/InternableString.cs
index 7e657d56cdb..d19afe2a662 100644
--- a/src/StringTools/InternableString.cs
+++ b/src/StringTools/InternableString.cs
@@ -387,7 +387,7 @@ private static unsafe uint GetHashCodeHelper(char* charPtr, int length, uint has
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
         private static uint RotateLeft(uint value, int offset)
         {
-#if NETCOREAPP
+#if NET
             return System.Numerics.BitOperations.RotateLeft(value, offset);
 #else
             // Copied from System\Numerics\BitOperations.cs in dotnet/runtime as the routine is not available on .NET Framework.
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index 4809373c67c..5015904acba 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -1,7 +1,6 @@
 <Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
-    <TargetFrameworks>$(LibraryTargetFrameworks)</TargetFrameworks>
-    <TargetFrameworks Condition="'$(MSBuildRuntimeType)' != 'Core'">$(LibraryTargetFrameworks);net35</TargetFrameworks>
+    <TargetFrameworks>$(LibraryTargetFrameworks);net35</TargetFrameworks>
     <PlatformTarget>AnyCPU</PlatformTarget>
     <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
     <IsPackable>true</IsPackable>
diff --git a/src/StringTools/WeakStringCacheInterner.cs b/src/StringTools/WeakStringCacheInterner.cs
index 2eb3fd23231..cc53c501ce3 100644
--- a/src/StringTools/WeakStringCacheInterner.cs
+++ b/src/StringTools/WeakStringCacheInterner.cs
@@ -85,7 +85,7 @@ public string InternableToString(ref InternableString candidate)
             string expectedString = candidate.ExpensiveConvertToString();
             if (!String.Equals(internedString, expectedString))
             {
-                throw new InvalidOperationException(String.Format("Interned string {0} should have been {1}", internedString, expectedString));
+                throw new InvalidOperationException($"Interned string {internedString} should have been {expectedString}");
             }
 #endif
 
@@ -137,12 +137,12 @@ public string FormatStatistics()
 
             if (_internCallCountsByString != null)
             {
-                result.AppendLine(string.Format("\n{0}{1}{0}", new string('=', 41 - (title.Length / 2)), title));
-                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Hits", _regularInternHits, "hits"));
-                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "WeakStringCache Misses", _regularInternMisses, "misses"));
-                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings"));
-                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars"));
-                result.AppendLine(string.Format("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes"));
+                result.AppendLine($"\n{new string('=', 41 - (title.Length / 2))}{title}{new string('=', 41 - (title.Length / 2))}");
+                result.AppendLine($"||{"WeakStringCache Hits",50}|{_regularInternHits,20:N0}|{"hits",8}|");
+                result.AppendLine($"||{"WeakStringCache Misses",50}|{_regularInternMisses,20:N0}|{"misses",8}|");
+                result.AppendLine($"||{"Eliminated Strings*",50}|{_internEliminatedStrings,20:N0}|{"strings",8}|");
+                result.AppendLine($"||{"Eliminated Chars",50}|{_internEliminatedChars,20:N0}|{"chars",8}|");
+                result.AppendLine($"||{"Estimated Eliminated Bytes",50}|{_internEliminatedChars * 2,20:N0}|{"bytes",8}|");
                 result.AppendLine("Elimination assumes that strings provided were unique objects.");
                 result.AppendLine("|---------------------------------------------------------------------------------|");
 
@@ -158,7 +158,7 @@ public string FormatStatistics()
 
                 WeakStringCache.DebugInfo debugInfo = _weakStringCache.GetDebugInfo();
                 result.AppendLine("WeakStringCache statistics:");
-                result.AppendLine(string.Format("String count live/collected/total = {0}/{1}/{2}", debugInfo.LiveStringCount, debugInfo.CollectedStringCount, debugInfo.LiveStringCount + debugInfo.CollectedStringCount));
+                result.AppendLine($"String count live/collected/total = {debugInfo.LiveStringCount}/{debugInfo.CollectedStringCount}/{debugInfo.LiveStringCount + debugInfo.CollectedStringCount}");
             }
             else
             {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 164f91774e0..576145d5cd5 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -18,7 +18,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 using FrameworkNameVersioning = System.Runtime.Versioning.FrameworkName;
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 774d8f3d735..ddfb1bd9c4f 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -5,7 +5,6 @@
 using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics.CodeAnalysis;
 using System.IO;
 using System.Runtime.Versioning;
 using Microsoft.Build.Framework;
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
index a27434df16c..c11fc53cfcc 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SpecificVersionPrimary.cs
@@ -9,7 +9,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
index 9ab178efbb5..2dc93f2fe56 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/SuggestedRedirects.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Reflection;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
diff --git a/src/Tasks.UnitTests/AssignCulture_Tests.cs b/src/Tasks.UnitTests/AssignCulture_Tests.cs
index 47ceeb5d7b0..fd2d3e0995b 100644
--- a/src/Tasks.UnitTests/AssignCulture_Tests.cs
+++ b/src/Tasks.UnitTests/AssignCulture_Tests.cs
@@ -2,12 +2,10 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
index 9e70ea4d20a..a0eb459595a 100644
--- a/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
+++ b/src/Tasks.UnitTests/AssignLinkMetadata_Tests.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
diff --git a/src/Tasks.UnitTests/AssignTargetPath_Tests.cs b/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
index 2289f896eaf..f2c08c59c6d 100644
--- a/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
+++ b/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
@@ -3,7 +3,6 @@
 
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Shouldly;
diff --git a/src/Tasks.UnitTests/AxImp_Tests.cs b/src/Tasks.UnitTests/AxImp_Tests.cs
index 52d433c32f9..6525c1656ea 100644
--- a/src/Tasks.UnitTests/AxImp_Tests.cs
+++ b/src/Tasks.UnitTests/AxImp_Tests.cs
@@ -1,11 +1,9 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
index ce9d7feadcb..99df3fbf783 100644
--- a/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
+++ b/src/Tasks.UnitTests/AxTlbBaseTask_Tests.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Utilities;
 using Microsoft.Runtime.Hosting;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs b/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs
index 20542cd8ce8..20c5c443a17 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.IO;
 using System.IO.Compression;
 using Microsoft.Build.Logging;
diff --git a/src/Tasks.UnitTests/ComReference_Tests.cs b/src/Tasks.UnitTests/ComReference_Tests.cs
index 741cd74479e..5f2b31c1010 100644
--- a/src/Tasks.UnitTests/ComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ComReference_Tests.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/CombinePath_Tests.cs b/src/Tasks.UnitTests/CombinePath_Tests.cs
index a719717e07e..080cf10f288 100644
--- a/src/Tasks.UnitTests/CombinePath_Tests.cs
+++ b/src/Tasks.UnitTests/CombinePath_Tests.cs
@@ -4,11 +4,9 @@
 using System.IO;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/CombineTargetFrameworkInfoProperties_Tests.cs b/src/Tasks.UnitTests/CombineTargetFrameworkInfoProperties_Tests.cs
index e22a715f8a4..4bf3eba2529 100644
--- a/src/Tasks.UnitTests/CombineTargetFrameworkInfoProperties_Tests.cs
+++ b/src/Tasks.UnitTests/CombineTargetFrameworkInfoProperties_Tests.cs
@@ -1,7 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Shouldly;
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index 26e53c59436..d79ac579d3d 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -79,11 +79,6 @@ public static IEnumerable<object[]> GetNullAndEmptyArrays() =>
             */
         };
 
-        private const int NoParallelismThreadCount = 1;
-        private const int DefaultParallelismThreadCount = int.MaxValue;
-
-        private int GetParallelismThreadCount(bool isUseSingleThreadedCopy) => isUseSingleThreadedCopy ? NoParallelismThreadCount : DefaultParallelismThreadCount;
-
         /// <summary>
         /// Temporarily save off the value of MSBUILDALWAYSOVERWRITEREADONLYFILES, so that we can run
         /// the tests isolated from the current state of the environment, but put it back how it belongs
@@ -509,7 +504,7 @@ public void DontCopyOverSameFile(bool isUseHardLinks, bool isUseSymbolicLinks, b
                     UseSymboliclinksIfPossible = isUseSymbolicLinks,
                 };
 
-                t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy));
+                t.Execute(m.CopyFile, !isUseSingleThreadedCopy);
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -557,7 +552,7 @@ public void QuestionCopyFile(bool isUseHardLinks, bool isUseSymbolicLinks, bool
                     FailIfNotIncremental = true,
                 };
 
-                Assert.False(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+                Assert.False(t.Execute(m.CopyFile, !isUseSingleThreadedCopy));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -617,7 +612,7 @@ public void QuestionCopyFileSameContent(bool isUseHardLinks, bool isUseSymbolicL
                     SkipUnchangedFiles = true,
                     FailIfNotIncremental = true,
                 };
-                Assert.True(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+                Assert.True(t.Execute(m.CopyFile, !isUseSingleThreadedCopy));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -670,7 +665,7 @@ public void QuestionCopyFileNotSameContent(bool isUseHardLinks, bool isUseSymbol
                     FailIfNotIncremental = true,
                 };
 
-                Assert.False(t.Execute(m.CopyFile, GetParallelismThreadCount(isUseSingleThreadedCopy)));
+                Assert.False(t.Execute(m.CopyFile, !isUseSingleThreadedCopy));
 
                 // Expect for there to have been no copies.
                 Assert.Equal(0, m.copyCount);
@@ -2015,7 +2010,7 @@ public void CopyWithDuplicatesUsingFolder(bool isUseHardLinks, bool isUseSymboli
                     filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
                 }
                 return true;
-            }, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            }, !isUseSingleThreadedCopy);
 
             Assert.True(success);
             Assert.Equal(2, filesActuallyCopied.Count);
@@ -2082,7 +2077,7 @@ public void CopyWithDuplicatesUsingFiles(bool isUseHardLinks, bool isUseSymbolic
                     filesActuallyCopied.Add(new KeyValuePair<FileState, FileState>(source, dest));
                 }
                 return true;
-            }, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            }, !isUseSingleThreadedCopy);
 
             Assert.True(success);
             Assert.Equal(4, filesActuallyCopied.Count);
@@ -2352,7 +2347,7 @@ public void FailureWithNoRetries(bool isUseHardLinks, bool isUseSymbolicLinks, b
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.False(result);
             engine.AssertLogDoesntContain("MSB3026");
@@ -2419,7 +2414,7 @@ public void SuccessAfterOneRetry(bool isUseHardLinks, bool isUseSymbolicLinks, b
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.True(result);
             engine.AssertLogContains("MSB3026");
@@ -2446,7 +2441,7 @@ public void SuccessAfterOneRetryContinueToNextFile(bool isUseHardLinks, bool isU
             };
 
             var copyFunctor = new CopyFunctor(2, false /* do not throw on failure */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.True(result);
             engine.AssertLogContains("MSB3026");
@@ -2478,7 +2473,7 @@ public void TooFewRetriesReturnsFalse(bool isUseHardLinks, bool isUseSymbolicLin
             };
 
             var copyFunctor = new CopyFunctor(4, false /* do not throw */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.False(result);
             engine.AssertLogContains("MSB3026");
@@ -2507,7 +2502,7 @@ public void TooFewRetriesThrows(bool isUseHardLinks, bool isUseSymbolicLinks, bo
             };
 
             var copyFunctor = new CopyFunctor(3, true /* throw */);
-            bool result = t.Execute(copyFunctor.Copy, GetParallelismThreadCount(isUseSingleThreadedCopy));
+            bool result = t.Execute(copyFunctor.Copy, !isUseSingleThreadedCopy);
 
             Assert.False(result);
             engine.AssertLogContains("MSB3026");
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index de09dcbc85e..90a57722f30 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -4,18 +4,14 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.Definition;
-using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/Delete_Tests.cs b/src/Tasks.UnitTests/Delete_Tests.cs
index d404c63246f..e523c13816c 100644
--- a/src/Tasks.UnitTests/Delete_Tests.cs
+++ b/src/Tasks.UnitTests/Delete_Tests.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 6997613405b..2f0f9e1ace3 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -16,7 +16,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -171,9 +170,20 @@ public void Timeout()
             Assert.Equal(expectedExitCode, exec.ExitCode);
             ((MockEngine)exec.BuildEngine).AssertLogContains("MSB5002");
             int warningsCount = ((MockEngine)exec.BuildEngine).Warnings;
-            warningsCount.ShouldBe(1,
+            if (warningsCount == 1)
+            {
+                warningsCount.ShouldBe(1,
                 $"Expected 1 warning, encountered {warningsCount}: " + string.Join(",",
                     ((MockEngine)exec.BuildEngine).WarningEvents.Select(w => w.Message)));
+            }
+            else
+            {
+                // Occasionally temp files fail to delete because of virus checkers, so generate MSB5018 warning
+                ((MockEngine)exec.BuildEngine).AssertLogContains("MSB5018");
+                warningsCount.ShouldBe(2,
+                $"Expected 2 warnings, encountered {warningsCount}: " + string.Join(",",
+                    ((MockEngine)exec.BuildEngine).WarningEvents.Select(w => w.Message)));
+            }
 
             // ToolTask does not log an error on timeout.
             Assert.Equal(0, ((MockEngine)exec.BuildEngine).Errors);
diff --git a/src/Tasks.UnitTests/FileStateTests.cs b/src/Tasks.UnitTests/FileStateTests.cs
index 1048fc95358..1b23ffaba7d 100644
--- a/src/Tasks.UnitTests/FileStateTests.cs
+++ b/src/Tasks.UnitTests/FileStateTests.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/FindUnderPath_Tests.cs b/src/Tasks.UnitTests/FindUnderPath_Tests.cs
index ce0be31a183..5b38b678b58 100644
--- a/src/Tasks.UnitTests/FindUnderPath_Tests.cs
+++ b/src/Tasks.UnitTests/FindUnderPath_Tests.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 
 
diff --git a/src/Tasks.UnitTests/FormatUrl_Tests.cs b/src/Tasks.UnitTests/FormatUrl_Tests.cs
index 26fabaf9db5..8cc77f6358a 100644
--- a/src/Tasks.UnitTests/FormatUrl_Tests.cs
+++ b/src/Tasks.UnitTests/FormatUrl_Tests.cs
@@ -7,7 +7,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 namespace Microsoft.Build.UnitTests
 {
diff --git a/src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs b/src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs
index 8d50571656d..1c8bcd0ccf3 100644
--- a/src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs
+++ b/src/Tasks.UnitTests/GetAssembliesMetadata_Tests.cs
@@ -10,11 +10,11 @@
 using System.Text;
 using System.Threading.Tasks;
 using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
-using Xunit.Sdk;
-using Microsoft.Build.UnitTests.Shared;
 using Xunit.Abstractions;
+using Xunit.Sdk;
 
 namespace Microsoft.Build.Tasks.UnitTests
 {
diff --git a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
index 040199f9fb9..e5ad7426db7 100644
--- a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
+++ b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
@@ -10,7 +10,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/GetSDKReference_Tests.cs b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
index db7e1f155f1..f5ff062f87b 100644
--- a/src/Tasks.UnitTests/GetSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Linq;
 using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -13,7 +12,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/HintPathResolver_Tests.cs b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
index 599a5750961..9548e32f421 100644
--- a/src/Tasks.UnitTests/HintPathResolver_Tests.cs
+++ b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
@@ -8,7 +8,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/MakeDir_Tests.cs b/src/Tasks.UnitTests/MakeDir_Tests.cs
index 8a50acbd4c3..7b29328f258 100644
--- a/src/Tasks.UnitTests/MakeDir_Tests.cs
+++ b/src/Tasks.UnitTests/MakeDir_Tests.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index ca8bee21b50..a951d75d216 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/OutputPathTests.cs b/src/Tasks.UnitTests/OutputPathTests.cs
index af1d3902804..1bf85cccef8 100644
--- a/src/Tasks.UnitTests/OutputPathTests.cs
+++ b/src/Tasks.UnitTests/OutputPathTests.cs
@@ -12,7 +12,6 @@
 
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/PortableTasks_Tests.cs b/src/Tasks.UnitTests/PortableTasks_Tests.cs
index e409d1f61bd..cd051c5a90e 100644
--- a/src/Tasks.UnitTests/PortableTasks_Tests.cs
+++ b/src/Tasks.UnitTests/PortableTasks_Tests.cs
@@ -9,7 +9,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/RegressionTests.cs b/src/Tasks.UnitTests/RegressionTests.cs
index ef1b944e160..924a0adb84b 100644
--- a/src/Tasks.UnitTests/RegressionTests.cs
+++ b/src/Tasks.UnitTests/RegressionTests.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.UnitTests;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/ResolveComReference_Tests.cs b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
index 47fb7e3c853..9dc7b95f2c2 100644
--- a/src/Tasks.UnitTests/ResolveComReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveComReference_Tests.cs
@@ -5,8 +5,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.IO;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index 775098727b3..26ee71150e0 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -12,7 +12,6 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 using SDKReference = Microsoft.Build.Tasks.ResolveSDKReference.SDKReference;
 
 #nullable disable
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 472d732a973..b9d1c4eae42 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
@@ -12,7 +11,6 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 458fc147f78..772dfd5c743 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -11,12 +11,10 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
-using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index a77f9d5759e..e1867c0129a 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
-using System.Text.RegularExpressions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
diff --git a/src/Tasks.UnitTests/SGen_Tests.cs b/src/Tasks.UnitTests/SGen_Tests.cs
index 75b712a53a7..2755cc179aa 100644
--- a/src/Tasks.UnitTests/SGen_Tests.cs
+++ b/src/Tasks.UnitTests/SGen_Tests.cs
@@ -4,7 +4,6 @@
 using System;
 using System.IO;
 using System.Linq;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Shouldly;
 using Xunit;
diff --git a/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs b/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
index f0cd952108b..a784e141ede 100644
--- a/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
+++ b/src/Tasks.UnitTests/SdkToolsPathUtility_Tests.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/SecurityUtil_Tests.cs b/src/Tasks.UnitTests/SecurityUtil_Tests.cs
index 696e5ef1470..7ae12543968 100644
--- a/src/Tasks.UnitTests/SecurityUtil_Tests.cs
+++ b/src/Tasks.UnitTests/SecurityUtil_Tests.cs
@@ -2,15 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Runtime.ConstrainedExecution;
 using System.Runtime.Versioning;
-using System.Security.Cryptography;
 using System.Security.Cryptography.X509Certificates;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 using Shouldly;
 using Xunit;
diff --git a/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Class1.cs b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Class1.cs
index 891e68b690d..d36d6c2c0d4 100644
--- a/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Class1.cs
+++ b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Class1.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Reflection;
 using System.Runtime.InteropServices;
 
 namespace Custom_COM
diff --git a/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Properties/AssemblyInfo.cs b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Properties/AssemblyInfo.cs
index 233af2b505c..71939e001bb 100644
--- a/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Properties/AssemblyInfo.cs
+++ b/src/Tasks.UnitTests/TestResources/Projects/Custom_COM/Custom_COM/Properties/AssemblyInfo.cs
@@ -1,9 +1,8 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System.Resources;
 using System.Reflection;
-using System.Runtime.CompilerServices;
+using System.Resources;
 using System.Runtime.InteropServices;
 
 // General Information about an assembly is controlled through the following
diff --git a/src/Tasks.UnitTests/Unzip_Tests.cs b/src/Tasks.UnitTests/Unzip_Tests.cs
index bcfe0b54460..e2e1494ee52 100644
--- a/src/Tasks.UnitTests/Unzip_Tests.cs
+++ b/src/Tasks.UnitTests/Unzip_Tests.cs
@@ -5,13 +5,11 @@
 using System.Diagnostics;
 using System.IO;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
index 1c8dffcff37..d077c4f8ec7 100644
--- a/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
+++ b/src/Tasks.UnitTests/WriteCodeFragment_Tests.cs
@@ -10,7 +10,6 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
diff --git a/src/Tasks.UnitTests/XmlPeek_Tests.cs b/src/Tasks.UnitTests/XmlPeek_Tests.cs
index 63ce7c1be53..81b0a7ddd89 100644
--- a/src/Tasks.UnitTests/XmlPeek_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPeek_Tests.cs
@@ -6,7 +6,6 @@
 using System.Linq;
 
 using Microsoft.Build.Evaluation;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 
diff --git a/src/Tasks/AppConfig/BindingRedirect.cs b/src/Tasks/AppConfig/BindingRedirect.cs
index 8be7d2413c7..d29808b9b59 100644
--- a/src/Tasks/AppConfig/BindingRedirect.cs
+++ b/src/Tasks/AppConfig/BindingRedirect.cs
@@ -43,17 +43,21 @@ internal void Read(XmlReader reader)
 
             try
             {
-                if (dashPosition != -1)
+                if (dashPosition >= 0)
                 {
                     // This is a version range.
-                    OldVersionLow = new Version(oldVersion.Substring(0, dashPosition));
-                    OldVersionHigh = new Version(oldVersion.Substring(dashPosition + 1));
+#if NET
+                    OldVersionLow = Version.Parse(oldVersion.AsSpan(0, dashPosition));
+                    OldVersionHigh = Version.Parse(oldVersion.AsSpan(dashPosition + 1));
+#else
+                    OldVersionLow = Version.Parse(oldVersion.Substring(0, dashPosition));
+                    OldVersionHigh = Version.Parse(oldVersion.Substring(dashPosition + 1));
+#endif
                 }
                 else
                 {
                     // This is a single version.
-                    OldVersionLow = new Version(oldVersion);
-                    OldVersionHigh = new Version(oldVersion);
+                    OldVersionLow = OldVersionHigh = new Version(oldVersion);
                 }
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
diff --git a/src/Tasks/AssemblyDependency/AssemblyAttributes.cs b/src/Tasks/AssemblyDependency/AssemblyAttributes.cs
index 4e6fd111a27..56d51302e29 100644
--- a/src/Tasks/AssemblyDependency/AssemblyAttributes.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyAttributes.cs
@@ -1,12 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-
 namespace Microsoft.Build.Tasks.AssemblyDependency
 {
     /// <summary>
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
index 1453e8ab6d8..ded0c8b46bf 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigCache.cs
@@ -2,7 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Immutable;
+using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using Microsoft.Build.Shared;
@@ -19,7 +19,7 @@ internal class AssemblyFoldersFromConfigCache
         /// <summary>
         /// Set of files in ALL AssemblyFolderFromConfig directories
         /// </summary>
-        private readonly ImmutableHashSet<string> _filesInDirectories = ImmutableHashSet<string>.Empty;
+        private readonly HashSet<string> _filesInDirectories;
 
         /// <summary>
         /// File exists delegate we are replacing
@@ -45,12 +45,12 @@ internal AssemblyFoldersFromConfigCache(AssemblyFoldersFromConfig assemblyFolder
             }
             else
             {
-                _filesInDirectories = assemblyFoldersFromConfig.AsParallel()
+                _filesInDirectories = new(assemblyFoldersFromConfig.AsParallel()
                     .Where(assemblyFolder => FileUtilities.DirectoryExistsNoThrow(assemblyFolder.DirectoryPath))
                     .SelectMany(
                         assemblyFolder =>
-                            Directory.GetFiles(assemblyFolder.DirectoryPath, "*.*", SearchOption.TopDirectoryOnly))
-                    .ToImmutableHashSet(StringComparer.OrdinalIgnoreCase);
+                            Directory.GetFiles(assemblyFolder.DirectoryPath, "*.*", SearchOption.TopDirectoryOnly)),
+                    StringComparer.OrdinalIgnoreCase);
             }
         }
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index 531d95a8fc5..2a3c9c6aef3 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -12,12 +12,9 @@
 #endif
 using System.Reflection;
 using System.Runtime.Versioning;
-using System.Security.Cryptography;
-using System.Security.Cryptography.X509Certificates;
 using System.Text;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using static Microsoft.Build.Shared.FileSystem.WindowsNative;
 #if FEATURE_ASSEMBLYLOADCONTEXT
 using System.Reflection.PortableExecutable;
 using System.Reflection.Metadata;
@@ -50,7 +47,7 @@ internal class AssemblyInformation : DisposableBase
 #endif
 
 #if !FEATURE_ASSEMBLYLOADCONTEXT
-        private static string s_targetFrameworkAttribute = "System.Runtime.Versioning.TargetFrameworkAttribute";
+        private const string s_targetFrameworkAttribute = "System.Runtime.Versioning.TargetFrameworkAttribute";
 #endif
 #if !FEATURE_ASSEMBLYLOADCONTEXT
         // Borrowed from genman.
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 99307761f8f..ad9503b4121 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -3,14 +3,14 @@
 
 using System;
 using System.Collections.Generic;
+using System.IO;
 using System.Linq;
 using System.Reflection;
+using System.Xml;
 using System.Xml.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using System.IO;
-using System.Xml;
 
 #nullable disable
 
diff --git a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
index daeaae94b3b..1a6656c607d 100644
--- a/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
+++ b/src/Tasks/AssemblyDependency/GlobalAssemblyCache.cs
@@ -283,7 +283,7 @@ internal static string GetLocation(
             bool useGacRarCache = Environment.GetEnvironmentVariable("MSBUILDDISABLEGACRARCACHE") == null;
             if (buildEngine != null && useGacRarCache)
             {
-                string key = "44d78b60-3bbe-48fe-9493-04119ebf515f" + "|" + targetProcessorArchitecture.ToString() + "|" + targetedRuntimeVersion.ToString() + "|" + fullFusionName.ToString() + "|" + specificVersion.ToString();
+                string key = $"44d78b60-3bbe-48fe-9493-04119ebf515f|{targetProcessorArchitecture}|{targetedRuntimeVersion}|{fullFusionName}|{specificVersion}";
                 fusionNameToResolvedPath = buildEngine.GetRegisteredTaskObject(key, RegisteredTaskObjectLifetime.Build) as ConcurrentDictionary<AssemblyNameExtension, string>;
                 if (fusionNameToResolvedPath == null)
                 {
diff --git a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
index b7352e6b255..3c6fbf3ba98 100644
--- a/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
+++ b/src/Tasks/AssemblyDependency/InstalledAssemblies.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index d9ba3671e32..78648beda64 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -725,7 +725,7 @@ internal HashSet<AssemblyRemapping> RemappedAssemblyNames()
         /// </summary>
         internal void AddPreUnificationVersion(String referencePath, Version version, UnificationReason reason)
         {
-            string key = referencePath + version.ToString() + reason.ToString();
+            string key = $"{referencePath}{version}{reason}";
 
             // Only add a reference, version, and reason once.
             UnificationVersion unificationVersion;
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index de1a4b26b20..9e3b0c07d36 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -789,9 +789,7 @@ private static void TryGatherAssemblyNameEssentials(string fusionName, ref Assem
                 return;
             }
 
-            string newFusionName = String.Format(CultureInfo.InvariantCulture,
-                "{0}, Version={1}, Culture={2}, PublicKeyToken={3}",
-                name, version, culture, publicKeyToken);
+            string newFusionName = $"{name}, Version={version}, Culture={culture}, PublicKeyToken={publicKeyToken}";
 
             // Now try to convert to an AssemblyName.
             try
@@ -812,19 +810,20 @@ private static void TryGatherAssemblyNameEssentials(string fusionName, ref Assem
         private static void TryGetAssemblyNameComponent(string fusionName, string component, ref string value)
         {
             int position = fusionName.IndexOf(component + "=", StringComparison.Ordinal);
-            if (position == -1)
+            if (position < 0)
             {
                 return;
             }
+
             position += component.Length + 1;
-            int nextDelimiter = fusionName.IndexOfAny([',', ' '], position);
-            if (nextDelimiter == -1)
+            int nextDelimiter = fusionName.AsSpan(position).IndexOfAny(',', ' ');
+            if (nextDelimiter < 0)
             {
                 value = fusionName.Substring(position);
             }
             else
             {
-                value = fusionName.Substring(position, nextDelimiter - position);
+                value = fusionName.Substring(position, nextDelimiter);
             }
         }
 
@@ -2301,20 +2300,11 @@ private static bool CompareRefToDef(AssemblyName @ref, AssemblyName def)
 
             byte[] rpkt = @ref.GetPublicKeyToken();
             byte[] dpkt = def.GetPublicKeyToken();
-
-            if (rpkt.Length != dpkt.Length)
+            if (!rpkt.AsSpan().SequenceEqual(dpkt.AsSpan()))
             {
                 return false;
             }
 
-            for (int i = 0; i < rpkt.Length; i++)
-            {
-                if (rpkt[i] != dpkt[i])
-                {
-                    return false;
-                }
-            }
-
             if (@ref.Version != def.Version)
             {
                 return false;
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index b322052e386..a5a3ae00813 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -5,7 +5,9 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if !NET
 using System.Globalization;
+#endif
 using System.IO;
 using System.Linq;
 using System.Reflection;
@@ -1311,6 +1313,9 @@ internal static string ByteArrayToString(byte[] a)
                 return null;
             }
 
+#if NET
+            return Convert.ToHexStringLower(a);
+#else
             var buffer = new StringBuilder(a.Length * 2);
             for (int i = 0; i < a.Length; ++i)
             {
@@ -1318,6 +1323,7 @@ internal static string ByteArrayToString(byte[] a)
             }
 
             return buffer.ToString();
+#endif
         }
 
         /// <summary>
@@ -1536,22 +1542,22 @@ private void LogInputs()
             }
 
             Log.LogMessage(importance, property, "AppConfigFile");
-            Log.LogMessage(importance, indent + AppConfigFile);
+            Log.LogMessage(importance, $"{indent}{AppConfigFile}");
 
             Log.LogMessage(importance, property, "AutoUnify");
-            Log.LogMessage(importance, indent + AutoUnify.ToString());
+            Log.LogMessage(importance, $"{indent}{AutoUnify}");
 
             Log.LogMessage(importance, property, "CopyLocalDependenciesWhenParentReferenceInGac");
-            Log.LogMessage(importance, indent + _copyLocalDependenciesWhenParentReferenceInGac);
+            Log.LogMessage(importance, $"{indent}{_copyLocalDependenciesWhenParentReferenceInGac}");
 
             Log.LogMessage(importance, property, "FindDependencies");
-            Log.LogMessage(importance, indent + _findDependencies);
+            Log.LogMessage(importance, $"{indent}{_findDependencies}");
 
             Log.LogMessage(importance, property, "TargetProcessorArchitecture");
-            Log.LogMessage(importance, indent + TargetProcessorArchitecture);
+            Log.LogMessage(importance, $"{indent}{TargetProcessorArchitecture}");
 
             Log.LogMessage(importance, property, "StateFile");
-            Log.LogMessage(importance, indent + StateFile);
+            Log.LogMessage(importance, $"{indent}{StateFile}");
 
             Log.LogMessage(importance, property, "InstalledAssemblySubsetTables");
             foreach (ITaskItem installedAssemblySubsetTable in InstalledAssemblySubsetTables)
@@ -1561,33 +1567,33 @@ private void LogInputs()
             }
 
             Log.LogMessage(importance, property, "IgnoreInstalledAssemblySubsetTable");
-            Log.LogMessage(importance, indent + _ignoreDefaultInstalledAssemblySubsetTables);
+            Log.LogMessage(importance, $"{indent}{_ignoreDefaultInstalledAssemblySubsetTables}");
 
             Log.LogMessage(importance, property, "TargetFrameworkSubsets");
             foreach (string subset in _targetFrameworkSubsets)
             {
-                Log.LogMessage(importance, indent + subset);
+                Log.LogMessage(importance, $"{indent}{subset}");
             }
 
             Log.LogMessage(importance, property, "FullTargetFrameworkSubsetNames");
             foreach (string subset in FullTargetFrameworkSubsetNames)
             {
-                Log.LogMessage(importance, indent + subset);
+                Log.LogMessage(importance, $"{indent}{subset}");
             }
 
             Log.LogMessage(importance, property, "ProfileName");
-            Log.LogMessage(importance, indent + ProfileName);
+            Log.LogMessage(importance, $"{indent}{ProfileName}");
 
             Log.LogMessage(importance, property, "FullFrameworkFolders");
             foreach (string fullFolder in FullFrameworkFolders)
             {
-                Log.LogMessage(importance, indent + fullFolder);
+                Log.LogMessage(importance, $"{indent}{fullFolder}");
             }
 
             Log.LogMessage(importance, property, "LatestTargetFrameworkDirectories");
             foreach (string latestFolder in _latestTargetFrameworkDirectories)
             {
-                Log.LogMessage(importance, indent + latestFolder);
+                Log.LogMessage(importance, $"{indent}{latestFolder}");
             }
 
             Log.LogMessage(importance, property, "ProfileTablesLocation");
@@ -2843,7 +2849,7 @@ internal static string GenerateSubSetName(string[] frameworkSubSetNames, ITaskIt
                 }
             }
 
-            return String.Join(", ", subsetNames.ToArray());
+            return String.Join(", ", subsetNames);
         }
 
         /// <summary>
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index c22ab73bc9f..8e7c85a73b3 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -492,9 +492,9 @@ internal string[] Cultures
                     Refresh();
                 }
 
-                List<string> list = _cultures.Values.Select(v => v.ToString()).ToList();
-                list.Sort();
-                return list.ToArray();
+                string[] array = _cultures.Values.Select(v => v.ToString()).ToArray();
+                Array.Sort(array);
+                return array;
             }
         }
 
@@ -603,7 +603,7 @@ private void RefreshProducts()
                     foreach (string strSubDirectory in Directory.GetDirectories(packagePath))
                     {
                         int nStartIndex = packagePath.Length;
-                        if ((strSubDirectory.ToCharArray())[nStartIndex] == System.IO.Path.DirectorySeparatorChar)
+                        if (strSubDirectory[nStartIndex] == System.IO.Path.DirectorySeparatorChar)
                         {
                             nStartIndex++;
                         }
@@ -948,7 +948,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement, st
                                     }
 
                                     XmlNode langNode = langDoc.SelectSingleNode(BOOTSTRAPPER_PREFIX + ":Package", _xmlNamespaceManager);
-                                    Debug.Assert(langNode != null, string.Format(CultureInfo.CurrentCulture, "Unable to find a package node in {0}", strLangManifestFilename));
+                                    Debug.Assert(langNode != null, $"Unable to find a package node in {strLangManifestFilename}");
                                     if (langNode != null)
                                     {
                                         XmlElement langElement = (XmlElement)(_document.ImportNode(langNode, true));
@@ -1040,7 +1040,7 @@ private void ExploreDirectory(string strSubDirectory, XmlElement rootElement, st
                                 }
                                 else
                                 {
-                                    Debug.WriteLine(String.Format(CultureInfo.CurrentCulture, "Validation results already added for Product Code '{0}'", productCodeAttribute));
+                                    Debug.WriteLine($"Validation results already added for Product Code '{productCodeAttribute}'");
                                 }
                             }
                         }
@@ -1512,7 +1512,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                                 // Add the file size to the PackageFileNode
                                 XmlAttribute sizeAttribute = packageFileNode.OwnerDocument.CreateAttribute("Size");
                                 var fi = new FileInfo(packageFileSource.Value);
-                                sizeAttribute.Value = "" + (fi.Length.ToString(CultureInfo.InvariantCulture));
+                                sizeAttribute.Value = fi.Length.ToString(CultureInfo.InvariantCulture);
                                 MergeAttribute(packageFileNode, sizeAttribute);
                             }
                         }
@@ -1547,7 +1547,7 @@ private bool BuildPackages(BuildSettings settings, XmlElement configElement, Res
                 if (configElement != null)
                 {
                     configElement.AppendChild(configElement.OwnerDocument.ImportNode(node, true));
-                    DumpXmlToFile(node, string.Format(CultureInfo.CurrentCulture, "{0}.{1}.xml", package.Product.ProductCode, package.Culture));
+                    DumpXmlToFile(node, $"{package.Product.ProductCode}.{package.Culture}.xml");
                 }
             }
 
@@ -1602,13 +1602,17 @@ private static string ByteArrayToString(byte[] byteArray)
                 return null;
             }
 
-            var output = new StringBuilder(byteArray.Length);
+#if NET
+            return Convert.ToHexString(byteArray);
+#else
+            var output = new StringBuilder(byteArray.Length * 2);
             foreach (byte byteValue in byteArray)
             {
                 output.Append(byteValue.ToString("X02", CultureInfo.InvariantCulture));
             }
 
             return output.ToString();
+#endif
         }
 
         private static string GetFileHash(string filePath)
@@ -1983,7 +1987,7 @@ private static Stream GetEmbeddedResourceStream(string name)
         {
             Assembly a = Assembly.GetExecutingAssembly();
             Stream s = a.GetManifestResourceStream(String.Format(CultureInfo.InvariantCulture, "{0}.{1}", typeof(BootstrapperBuilder).Namespace, name));
-            Debug.Assert(s != null, String.Format(CultureInfo.CurrentCulture, "EmbeddedResource '{0}' not found", name));
+            Debug.Assert(s != null, $"EmbeddedResource '{name}' not found");
             return s;
         }
 
diff --git a/src/Tasks/BootstrapperUtil/BuildMessage.cs b/src/Tasks/BootstrapperUtil/BuildMessage.cs
index bc4272ed8d8..db219a6a7d0 100644
--- a/src/Tasks/BootstrapperUtil/BuildMessage.cs
+++ b/src/Tasks/BootstrapperUtil/BuildMessage.cs
@@ -13,9 +13,14 @@ namespace Microsoft.Build.Tasks.Deployment.Bootstrapper
     /// <summary>
     /// Represents messages that occur during the BootstrapperBuilder's Build operation.
     /// </summary>
-    public class BuildMessage : IBuildMessage
+    public partial class BuildMessage : IBuildMessage
     {
-        private static readonly Regex s_msbuildMessageCodePattern = new Regex(@"(\d+)$");
+#if NET
+        [GeneratedRegex(@"\d+$")]
+        private static partial Regex MsbuildMessageCodePattern { get; }
+#else
+        private static Regex MsbuildMessageCodePattern { get; } = new Regex(@"\d+$");
+#endif
 
         private BuildMessage(BuildMessageSeverity severity, string message, string helpKeyword, string helpCode)
         {
@@ -25,7 +30,7 @@ private BuildMessage(BuildMessageSeverity severity, string message, string helpK
             HelpCode = helpCode;
             if (!String.IsNullOrEmpty(HelpCode))
             {
-                Match match = s_msbuildMessageCodePattern.Match(HelpCode);
+                Match match = MsbuildMessageCodePattern.Match(HelpCode);
                 if (match.Success)
                 {
                     HelpId = int.Parse(match.Value, CultureInfo.InvariantCulture);
diff --git a/src/Tasks/BootstrapperUtil/Product.cs b/src/Tasks/BootstrapperUtil/Product.cs
index 6e9d0e1ceca..bf788c343b5 100644
--- a/src/Tasks/BootstrapperUtil/Product.cs
+++ b/src/Tasks/BootstrapperUtil/Product.cs
@@ -168,7 +168,7 @@ internal void AddPackage(Package package)
             }
             else
             {
-                Debug.WriteLine(String.Format(CultureInfo.CurrentCulture, "A package with culture '{0}' has already been added to product '{1}'", package.Culture.ToLowerInvariant(), ProductCode));
+                Debug.WriteLine($"A package with culture '{package.Culture.ToLowerInvariant()}' has already been added to product '{ProductCode}'");
             }
         }
 
diff --git a/src/Tasks/BootstrapperUtil/Util.cs b/src/Tasks/BootstrapperUtil/Util.cs
index 973ca74a61f..bfd845b297f 100644
--- a/src/Tasks/BootstrapperUtil/Util.cs
+++ b/src/Tasks/BootstrapperUtil/Util.cs
@@ -124,7 +124,12 @@ public static string GetDefaultPath(string visualStudioVersion)
             {
                 dotIndex = visualStudioVersion.Length;
             }
+
+#if NET
+            if (Int32.TryParse(visualStudioVersion.AsSpan(0, dotIndex), out int majorVersion) && (majorVersion < 11))
+#else
             if (Int32.TryParse(visualStudioVersion.Substring(0, dotIndex), out int majorVersion) && (majorVersion < 11))
+#endif
             {
                 visualStudioVersion = BOOTSTRAPPER_REGISTRY_PATH_VERSION_VS2010;
             }
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index 340be0e84b1..67e50ba29d6 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -263,7 +263,7 @@ internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silen
 
                 if (typeLibName.Length >= 4)
                 {
-                    if (string.Equals(typeLibName.Substring(typeLibName.Length - 4), ".dll", StringComparison.OrdinalIgnoreCase))
+                    if (typeLibName.AsSpan().EndsWith(".dll".AsSpan(), StringComparison.OrdinalIgnoreCase))
                     {
                         typeLibName = typeLibName.Substring(0, typeLibName.Length - 4);
                     }
diff --git a/src/Tasks/CompatibilitySuppressions.xml b/src/Tasks/CompatibilitySuppressions.xml
index 6e6f63a5eb6..fafd80dcb79 100644
--- a/src/Tasks/CompatibilitySuppressions.xml
+++ b/src/Tasks/CompatibilitySuppressions.xml
@@ -1,10 +1,6 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- For ease of logging the "not supported on Core" message, these tasks are a
-       TaskRequiresFramework on netstandard/netcore. Since the type is sealed there,
-       that shouldn't cause any implementation problems since no one can derive
-       from it and try to call TaskExtension.Log. -->
   <Suppression>
     <DiagnosticId>CP0007</DiagnosticId>
     <Target>T:Microsoft.Build.Tasks.AL</Target>
@@ -71,11 +67,6 @@
     <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
     <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
   </Suppression>
-  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
-      This is intentional, because you can only use MSBuild in the context of a .NET SDK
-      (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
-      have previously shipped netstandard2.0 packages, and if you want to support both
-      runtime contexts it still makes sense to target that. -->
   <Suppression>
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>.NETCoreApp,Version=v2.0</Target>
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index e553d1765af..96a0e17089b 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -7,7 +7,6 @@
 using System.IO;
 using System.Runtime.InteropServices;
 using System.Threading;
-using System.Threading.Tasks.Dataflow;
 
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
@@ -44,6 +43,33 @@ public class Copy : TaskExtension, IIncrementalTask, ICancelableTask
         // taking up the whole threadpool esp. when hosted in Visual Studio. IOW we use a specific number
         // instead of int.MaxValue.
         private static readonly int DefaultCopyParallelism = NativeMethodsShared.GetLogicalCoreCount() > 4 ? 6 : 4;
+        private static Thread[] copyThreads;
+        private static AutoResetEvent[] copyThreadSignals;
+        private AutoResetEvent _signalCopyTasksCompleted;
+
+        private static ConcurrentQueue<Action> _copyActionQueue = new ConcurrentQueue<Action>();
+
+        private static void InitializeCopyThreads()
+        {
+            lock (_copyActionQueue)
+            {
+                if (copyThreads == null)
+                {
+                    copyThreadSignals = new AutoResetEvent[DefaultCopyParallelism];
+                    copyThreads = new Thread[DefaultCopyParallelism];
+                    for (int i = 0; i < copyThreads.Length; ++i)
+                    {
+                        AutoResetEvent autoResetEvent = new AutoResetEvent(false);
+                        copyThreadSignals[i] = autoResetEvent;
+                        Thread newThread = new Thread(ParallelCopyTask);
+                        newThread.IsBackground = true;
+                        newThread.Name = "Parallel Copy Thread";
+                        newThread.Start(autoResetEvent);
+                        copyThreads[i] = newThread;
+                    }
+                }
+            }
+        }
 
         /// <summary>
         /// Constructor.
@@ -63,6 +89,8 @@ public Copy()
                 RemovingReadOnlyAttribute = Log.GetResourceMessage("Copy.RemovingReadOnlyAttribute");
                 SymbolicLinkComment = Log.GetResourceMessage("Copy.SymbolicLinkComment");
             }
+
+            _signalCopyTasksCompleted = new AutoResetEvent(false);
         }
 
         private static string CreatesDirectory;
@@ -79,7 +107,7 @@ public Copy()
         private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
 
         // Bool is just a placeholder, we're mainly interested in a threadsafe key set.
-        private readonly ConcurrentDictionary<string, bool> _directoriesKnownToExist = new ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
+        private readonly ConcurrentDictionary<string, bool> _directoriesKnownToExist = new ConcurrentDictionary<string, bool>(DefaultCopyParallelism, DefaultCopyParallelism, StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Force the copy to retry even when it hits ERROR_ACCESS_DENIED -- normally we wouldn't retry in this case since
@@ -93,7 +121,7 @@ public Copy()
         /// </summary>
         private static readonly bool s_forceSymlinks = Environment.GetEnvironmentVariable("MSBuildUseSymboliclinksIfPossible") != null;
 
-        private static readonly int s_parallelism = GetParallelismFromEnvironment();
+        private static readonly bool s_copyInParallel = GetParallelismFromEnvironment();
 
         /// <summary>
         /// Default milliseconds to wait between necessary retries
@@ -395,12 +423,12 @@ private void MakeFileWriteable(FileState file, bool logActivity)
         /// Copy the files.
         /// </summary>
         /// <param name="copyFile">Delegate used to copy the files.</param>
-        /// <param name="parallelism">
+        /// <param name="copyInParallel">
         /// Thread parallelism allowed during copies. 1 uses the original algorithm, >1 uses newer algorithm.
         /// </param>
         internal bool Execute(
             CopyFileWithState copyFile,
-            int parallelism)
+            bool copyInParallel)
         {
             // If there are no source files then just return success.
             if (IsSourceSetEmpty())
@@ -430,9 +458,9 @@ internal bool Execute(
 
             try
             {
-                success = parallelism == 1 || DestinationFiles.Length == 1
+                success = !copyInParallel || DestinationFiles.Length == 1
                     ? CopySingleThreaded(copyFile, out destinationFilesSuccessfullyCopied)
-                    : CopyParallel(copyFile, parallelism, out destinationFilesSuccessfullyCopied);
+                    : CopyParallel(copyFile, out destinationFilesSuccessfullyCopied);
             }
             catch (OperationCanceledException)
             {
@@ -507,6 +535,22 @@ private bool CopySingleThreaded(
             return success;
         }
 
+        private static void ParallelCopyTask(object state)
+        {
+            AutoResetEvent autoResetEvent = (AutoResetEvent)state;
+            while (true)
+            {
+                if (_copyActionQueue.TryDequeue(out Action copyAction))
+                {
+                    copyAction();
+                }
+                else
+                {
+                    autoResetEvent.WaitOne();
+                }
+            }
+        }
+
         /// <summary>
         /// Parallelize I/O with the same semantics as the single-threaded copy method above.
         /// ResolveAssemblyReferences tends to generate longer and longer lists of files to send
@@ -516,7 +560,6 @@ private bool CopySingleThreaded(
         /// </summary>
         private bool CopyParallel(
             CopyFileWithState copyFile,
-            int parallelism,
             out List<ITaskItem> destinationFilesSuccessfullyCopied)
         {
             bool success = true;
@@ -559,77 +602,23 @@ private bool CopyParallel(
 
             // Lockless flags updated from each thread - each needs to be a processor word for atomicity.
             var successFlags = new IntPtr[DestinationFiles.Length];
-            var actionBlockOptions = new ExecutionDataflowBlockOptions
-            {
-                MaxDegreeOfParallelism = parallelism,
-                CancellationToken = _cancellationTokenSource.Token
-            };
-            var partitionCopyActionBlock = new ActionBlock<List<int>>(
-                async (List<int> partition) =>
-                {
-                    // Break from synchronous thread context of caller to get onto thread pool thread.
-                    await System.Threading.Tasks.Task.Yield();
 
-                    for (int partitionIndex = 0; partitionIndex < partition.Count && !_cancellationTokenSource.IsCancellationRequested; partitionIndex++)
-                    {
-                        int fileIndex = partition[partitionIndex];
-                        ITaskItem sourceItem = SourceFiles[fileIndex];
-                        ITaskItem destItem = DestinationFiles[fileIndex];
-                        string sourcePath = sourceItem.ItemSpec;
-
-                        // Check if we just copied from this location to the destination, don't copy again.
-                        MSBuildEventSource.Log.CopyUpToDateStart(destItem.ItemSpec);
-                        bool copyComplete = partitionIndex > 0 &&
-                                            String.Equals(
-                                                sourcePath,
-                                                SourceFiles[partition[partitionIndex - 1]].ItemSpec,
-                                                StringComparison.OrdinalIgnoreCase);
-
-                        if (!copyComplete)
-                        {
-                            if (DoCopyIfNecessary(
-                                new FileState(sourceItem.ItemSpec),
-                                new FileState(destItem.ItemSpec),
-                                copyFile))
-                            {
-                                copyComplete = true;
-                            }
-                            else
-                            {
-                                // Thread race to set outer variable but they race to set the same (false) value.
-                                success = false;
-                            }
-                        }
-                        else
-                        {
-                            MSBuildEventSource.Log.CopyUpToDateStop(destItem.ItemSpec, true);
-                        }
+            ConcurrentQueue<List<int>> partitionQueue = new ConcurrentQueue<List<int>>(partitionsByDestination.Values);
 
-                        if (copyComplete)
-                        {
-                            sourceItem.CopyMetadataTo(destItem);
-                            successFlags[fileIndex] = (IntPtr)1;
-                        }
-                    }
-                },
-                actionBlockOptions);
+            int activeCopyThreads = DefaultCopyParallelism;
+            for (int i = 0; i < DefaultCopyParallelism; ++i)
+            {
+                _copyActionQueue.Enqueue(ProcessPartition);
+            }
 
-            foreach (List<int> partition in partitionsByDestination.Values)
+            InitializeCopyThreads();
+
+            for (int i = 0; i < DefaultCopyParallelism; ++i)
             {
-                bool partitionAccepted = partitionCopyActionBlock.Post(partition);
-                if (_cancellationTokenSource.IsCancellationRequested)
-                {
-                    break;
-                }
-                else if (!partitionAccepted)
-                {
-                    // Retail assert...
-                    ErrorUtilities.ThrowInternalError("Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity.");
-                }
+                copyThreadSignals[i].Set();
             }
 
-            partitionCopyActionBlock.Complete();
-            partitionCopyActionBlock.Completion.GetAwaiter().GetResult();
+            _signalCopyTasksCompleted.WaitOne();
 
             // Assemble an in-order list of destination items that succeeded.
             destinationFilesSuccessfullyCopied = new List<ITaskItem>(DestinationFiles.Length);
@@ -642,6 +631,65 @@ private bool CopyParallel(
             }
 
             return success;
+
+            void ProcessPartition()
+            {
+                try
+                {
+                    while (partitionQueue.TryDequeue(out List<int> partition))
+                    {
+                        for (int partitionIndex = 0; partitionIndex < partition.Count && !_cancellationTokenSource.IsCancellationRequested; partitionIndex++)
+                        {
+                            int fileIndex = partition[partitionIndex];
+                            ITaskItem sourceItem = SourceFiles[fileIndex];
+                            ITaskItem destItem = DestinationFiles[fileIndex];
+                            string sourcePath = sourceItem.ItemSpec;
+
+                            // Check if we just copied from this location to the destination, don't copy again.
+                            MSBuildEventSource.Log.CopyUpToDateStart(destItem.ItemSpec);
+                            bool copyComplete = partitionIndex > 0 &&
+                                                String.Equals(
+                                                    sourcePath,
+                                                    SourceFiles[partition[partitionIndex - 1]].ItemSpec,
+                                                    StringComparison.OrdinalIgnoreCase);
+
+                            if (!copyComplete)
+                            {
+                                if (DoCopyIfNecessary(
+                                    new FileState(sourceItem.ItemSpec),
+                                    new FileState(destItem.ItemSpec),
+                                    copyFile))
+                                {
+                                    copyComplete = true;
+                                }
+                                else
+                                {
+                                    // Thread race to set outer variable but they race to set the same (false) value.
+                                    success = false;
+                                }
+                            }
+                            else
+                            {
+                                MSBuildEventSource.Log.CopyUpToDateStop(destItem.ItemSpec, true);
+                            }
+
+                            if (copyComplete)
+                            {
+                                sourceItem.CopyMetadataTo(destItem);
+                                successFlags[fileIndex] = (IntPtr)1;
+                            }
+                        }
+                    }
+                }
+                finally
+                {
+                    int count = System.Threading.Interlocked.Decrement(ref activeCopyThreads);
+                    if (count == 0)
+                    {
+                        _signalCopyTasksCompleted.Set();
+                    }
+                }
+            }
         }
 
         private bool IsSourceSetEmpty()
@@ -1028,7 +1076,7 @@ private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationF
         /// <returns></returns>
         public override bool Execute()
         {
-            return Execute(CopyFileWithLogging, s_parallelism);
+            return Execute(CopyFileWithLogging, s_copyInParallel);
         }
 
         #endregion
@@ -1049,18 +1097,10 @@ private static bool PathsAreIdentical(FileState source, FileState destination)
             return string.Equals(source.FileNameFullPath, destination.FileNameFullPath, FileUtilities.PathComparison);
         }
 
-        private static int GetParallelismFromEnvironment()
+        private static bool GetParallelismFromEnvironment()
         {
             int parallelism = Traits.Instance.CopyTaskParallelism;
-            if (parallelism < 0)
-            {
-                parallelism = DefaultCopyParallelism;
-            }
-            else if (parallelism == 0)
-            {
-                parallelism = int.MaxValue;
-            }
-            return parallelism;
+            return parallelism != 1;
         }
     }
 }
diff --git a/src/Tasks/CreateProperty.cs b/src/Tasks/CreateProperty.cs
index d077411d58c..7d7d131b149 100644
--- a/src/Tasks/CreateProperty.cs
+++ b/src/Tasks/CreateProperty.cs
@@ -1,7 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using Microsoft.Build.Framework;
 
 #nullable disable
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index aed8b824d4f..baca3658583 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -4,9 +4,8 @@
 using System;
 using System.Collections.Generic;
 using System.Globalization;
-#if NET5_0_OR_GREATER
+#if NET
 using System.Linq;
-using Microsoft.Build.Framework;
 #endif
 using Microsoft.Build.Shared;
 
@@ -23,7 +22,7 @@ namespace Microsoft.Build.Tasks
     /// </summary>
     internal static class CultureInfoCache
     {
-#if !NET5_0_OR_GREATER
+#if !NET
         private static readonly Lazy<HashSet<string>> ValidCultureNames = new Lazy<HashSet<string>>(() => InitializeValidCultureNames());
 #endif
 
@@ -63,7 +62,7 @@ private static HashSet<string> InitializeValidCultureNames()
         /// <returns>True if the culture is determined to be valid.</returns>
         internal static bool IsValidCultureString(string name)
         {
-#if NET5_0_OR_GREATER
+#if NET
             try
             {
                 // GetCultureInfo throws if the culture doesn't exist
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 71dc72e4c91..9028bd1f386 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -156,7 +156,7 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
                     {
                         response.EnsureSuccessStatusCode();
                     }
-#if NET6_0_OR_GREATER
+#if NET
                     catch (HttpRequestException)
                     {
                         throw;
@@ -203,7 +203,7 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
                             Log.LogMessageFromResources(MessageImportance.High, "DownloadFile.Downloading", SourceUrl, destinationFile.FullName, response.Content.Headers.ContentLength);
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
                             using (Stream responseStream = await response.Content.ReadAsStreamAsync(
-#if NET6_0_OR_GREATER
+#if NET
                             cancellationToken
 #endif
                             ).ConfigureAwait(false))
@@ -260,7 +260,7 @@ private static bool IsRetriable(Exception exception, out Exception actualExcepti
                     }
                 }
 
-#if NET6_0_OR_GREATER
+#if NET
                 // net5.0 included StatusCode in the HttpRequestException.
                 switch (httpRequestException.StatusCode)
                 {
@@ -329,7 +329,7 @@ private bool TryGetFileName(HttpResponseMessage response, out string filename)
             return !String.IsNullOrWhiteSpace(filename);
         }
 
-#if !NET6_0_OR_GREATER
+#if !NET
         /// <summary>
         /// Represents a wrapper around the <see cref="HttpRequestException"/> that also contains the <see cref="HttpStatusCode"/>.
         /// DEPRECATED as of net5.0, which included the StatusCode in the HttpRequestException class.
diff --git a/src/Tasks/Error.cs b/src/Tasks/Error.cs
index 9d5ad2ab386..b507c65e066 100644
--- a/src/Tasks/Error.cs
+++ b/src/Tasks/Error.cs
@@ -3,7 +3,9 @@
 
 #nullable disable
 
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 
 namespace Microsoft.Build.Tasks
 {
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index cf87ebedec1..4daa47cf647 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -3,7 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 using System.IO;
 using System.Text;
 using System.Text.RegularExpressions;
diff --git a/src/Tasks/FileIO/GetFileHash.cs b/src/Tasks/FileIO/GetFileHash.cs
index 2d1ec4f5308..b975be5fd5e 100644
--- a/src/Tasks/FileIO/GetFileHash.cs
+++ b/src/Tasks/FileIO/GetFileHash.cs
@@ -143,7 +143,7 @@ internal static byte[] ComputeHash(Func<HashAlgorithm> algorithmFactory, string
             using (var stream = File.OpenRead(filePath))
             using (var algorithm = algorithmFactory())
             {
-#if NET5_0_OR_GREATER
+#if NET
                 return algorithm.ComputeHashAsync(stream, ct).Result;
 #else
                 return algorithm.ComputeHash(stream);
diff --git a/src/Tasks/FileIO/VerifyFileHash.cs b/src/Tasks/FileIO/VerifyFileHash.cs
index 9c3eca7556b..58bd4ce7aa8 100644
--- a/src/Tasks/FileIO/VerifyFileHash.cs
+++ b/src/Tasks/FileIO/VerifyFileHash.cs
@@ -2,9 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
-using System.Threading;
 
 #nullable disable
 
diff --git a/src/Tasks/FindInvalidProjectReferences.cs b/src/Tasks/FindInvalidProjectReferences.cs
index 791ac147af6..607df8b83cd 100644
--- a/src/Tasks/FindInvalidProjectReferences.cs
+++ b/src/Tasks/FindInvalidProjectReferences.cs
@@ -13,17 +13,22 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Returns the reference assembly paths to the various frameworks
     /// </summary>
-    public class FindInvalidProjectReferences : TaskExtension
+    public partial class FindInvalidProjectReferences : TaskExtension
     {
         #region Fields
 
+        private const string PlatformMonikerFormatPattern = @"(?<PLATFORMIDENTITY>^[^,]*),\s*Version=(?<PLATFORMVERSION>.*)";
+
         /// <summary>
         /// Regex for breaking up the platform moniker
         /// Example: XNA, Version=8.0
         /// </summary>
-        private static readonly Regex s_platformMonikerFormat = new Regex(
-             @"(?<PLATFORMIDENTITY>^[^,]*),\s*Version=(?<PLATFORMVERSION>.*)",
-            RegexOptions.IgnoreCase);
+#if NET
+        [GeneratedRegex(PlatformMonikerFormatPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex PlatformMonikerRegex { get; }
+#else
+        private static Regex PlatformMonikerRegex { get; } = new Regex(PlatformMonikerFormatPattern, RegexOptions.IgnoreCase);
+#endif
 
         /// <summary>
         /// Reference moniker metadata
@@ -111,7 +116,7 @@ public override bool Execute()
         /// </summary>
         private static bool ParseMoniker(string reference, out string platformIdentity, out Version platformVersion)
         {
-            Match match = s_platformMonikerFormat.Match(reference);
+            Match match = PlatformMonikerRegex.Match(reference);
 
             platformIdentity = String.Empty;
             bool parsedVersion = false;
diff --git a/src/Tasks/FormatVersion.cs b/src/Tasks/FormatVersion.cs
index 88cfc595cb5..86182dca239 100644
--- a/src/Tasks/FormatVersion.cs
+++ b/src/Tasks/FormatVersion.cs
@@ -47,9 +47,14 @@ public override bool Execute()
             {
                 OutputVersion = "1.0.0.0";
             }
-            else if (Version.EndsWith("*", StringComparison.Ordinal))
+            else if (Version[Version.Length - 1] == '*')
             {
-                OutputVersion = Version.Substring(0, Version.Length - 1) + Revision.ToString("G", CultureInfo.InvariantCulture);
+                OutputVersion =
+#if NET
+                    string.Create(CultureInfo.InvariantCulture, $"{Version.AsSpan(0, Version.Length - 1)}{Revision:G}");
+#else
+                    Version.Substring(0, Version.Length - 1) + Revision.ToString("G", CultureInfo.InvariantCulture);
+#endif
             }
             else
             {
diff --git a/src/Tasks/GenerateApplicationManifest.cs b/src/Tasks/GenerateApplicationManifest.cs
index 1c32b6feb36..cbd90c75ed4 100644
--- a/src/Tasks/GenerateApplicationManifest.cs
+++ b/src/Tasks/GenerateApplicationManifest.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Diagnostics;
-using System.Globalization;
 using System.IO;
 using System.Runtime.Versioning;
 using System.Xml;
@@ -241,7 +240,7 @@ private bool AddIsolatedComReferences(ApplicationManifest manifest)
                 }
             }
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateApplicationManifest.AddIsolatedComReferences t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"GenerateApplicationManifest.AddIsolatedComReferences t={Environment.TickCount - t1}");
             return success;
         }
 
@@ -326,7 +325,7 @@ private bool AddClickOnceFiles(ApplicationManifest manifest)
                 }
             }
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateApplicationManifest.AddClickOnceFiles t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"GenerateApplicationManifest.AddClickOnceFiles t={Environment.TickCount - t1}");
             return true;
         }
 
diff --git a/src/Tasks/GenerateManifestBase.cs b/src/Tasks/GenerateManifestBase.cs
index a58209b9053..54362377d72 100644
--- a/src/Tasks/GenerateManifestBase.cs
+++ b/src/Tasks/GenerateManifestBase.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Globalization;
 using System.IO;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -519,7 +518,7 @@ private bool ResolveFiles()
                 return false;
             }
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateManifestBase.ResolveFiles t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"GenerateManifestBase.ResolveFiles t={Environment.TickCount - t1}");
             return true;
         }
 
@@ -625,8 +624,8 @@ private bool WriteManifest()
                 return false;
             }
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateManifestBase.WriteManifest t={0}", Environment.TickCount - t1));
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "Total time to generate manifest '{1}': t={0}", Environment.TickCount - _startTime, Path.GetFileName(OutputManifest.ItemSpec)));
+            Util.WriteLog($"GenerateManifestBase.WriteManifest t={Environment.TickCount - t1}");
+            Util.WriteLog($"Total time to generate manifest '{Path.GetFileName(OutputManifest.ItemSpec)}': t={Environment.TickCount - _startTime}");
             return true;
         }
     }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index b888da26a59..d761f90b332 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -16,7 +16,6 @@
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
-using System.Linq;
 using System.Resources;
 using System.Resources.Extensions;
 using System.Reflection;
@@ -42,6 +41,7 @@
 using Microsoft.Build.Utilities;
 #if FEATURE_RESXREADER_LIVEDESERIALIZATION
 using Microsoft.Win32;
+using System.Linq;
 #endif
 
 #nullable disable
@@ -145,7 +145,7 @@ public sealed partial class GenerateResource : TaskExtension, IIncrementalTask
 #if FEATURE_RESGEN
         // Our calculation is not quite correct. Using a number substantially less than 32768 in order to
         // be sure we don't exceed it.
-        private static int s_maximumCommandLength = 28000;
+        private const int s_maximumCommandLength = 28000;
 #endif // FEATURE_RESGEN
 
         // Contains the list of paths from which inputs will not be taken into account during up-to-date check.
@@ -1793,7 +1793,7 @@ private bool NeedSeparateAppDomain()
                                             string resolvedTypeName = typeName;
 
                                             // This type name might be an alias, so first resolve that if any.
-                                            int indexOfSeperator = typeName.IndexOf(",", StringComparison.Ordinal);
+                                            int indexOfSeperator = typeName.IndexOf(',');
 
                                             if (indexOfSeperator != -1)
                                             {
@@ -2017,18 +2017,13 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
         }
 #endif
 
-        /// <summary>
-        /// Chars that should be ignored in the nicely justified block of base64
-        /// </summary>
-        private static readonly char[] s_specialChars = [' ', '\r', '\n'];
-
         /// <summary>
         /// Turns the nicely justified block of base64 found in a resx into a byte array.
         /// Copied from fx\src\winforms\managed\system\winforms\control.cs
         /// </summary>
         private static byte[] ByteArrayFromBase64WrappedString(string text)
         {
-            if (text.IndexOfAny(s_specialChars) != -1)
+            if (text.AsSpan().IndexOfAny(' ', '\r', '\n') != -1) // Chars that should be ignored in the nicely justified block of base64
             {
                 StringBuilder sb = new StringBuilder(text.Length);
                 for (int i = 0; i < text.Length; i++)
@@ -3044,7 +3039,7 @@ private void ReadResources(String filename, bool shouldUseSourcePath, String out
 
                     default:
                         // We should never get here, we've already checked the format
-                        Debug.Fail("Unknown format " + format.ToString());
+                        Debug.Fail($"Unknown format {format}");
                         return;
                 }
                 _logger.LogMessageFromResources(MessageImportance.Low, "GenerateResource.ReadResourceMessage", reader.resources.Count, filename);
@@ -3325,7 +3320,7 @@ private void WriteResources(ReaderInfo reader, String filename)
 #if FEATURE_RESXREADER_LIVEDESERIALIZATION
                     WriteResources(reader, new ResXResourceWriter(filename)); // closes writer for us
 #else
-                    _logger.LogError(format.ToString() + " not supported on .NET Core MSBuild");
+                    _logger.LogError($"{format} not supported on .NET Core MSBuild");
 #endif
                     break;
 
@@ -3339,7 +3334,7 @@ private void WriteResources(ReaderInfo reader, String filename)
 
                 default:
                     // We should never get here, we've already checked the format
-                    Debug.Fail("Unknown format " + format.ToString());
+                    Debug.Fail($"Unknown format {format}");
                     break;
             }
         }
@@ -3695,7 +3690,13 @@ private void ReadTextResources(ReaderInfo reader, String fileName)
                                     }
                                     try
                                     {
-                                        ch = (char)UInt16.Parse(new String(hex), NumberStyles.HexNumber, CultureInfo.CurrentCulture);
+                                        ch = (char)UInt16.Parse(
+#if NET
+                                            hex,
+#else
+                                            new String(hex),
+#endif
+                                            NumberStyles.HexNumber, CultureInfo.CurrentCulture);
                                     }
                                     catch (FormatException)
                                     {
@@ -4150,7 +4151,7 @@ public Type GetType(string name, bool throwOnError, bool ignoreCase)
                             result = a.GetType(name, false, ignoreCase);
                             if (result == null)
                             {
-                                int indexOfComma = name.IndexOf(",", StringComparison.Ordinal);
+                                int indexOfComma = name.IndexOf(',');
                                 if (indexOfComma != -1)
                                 {
                                     string shortName = name.Substring(0, indexOfComma);
diff --git a/src/Tasks/GetAssembliesMetadata.cs b/src/Tasks/GetAssembliesMetadata.cs
index 73a3877001f..c3186034f57 100644
--- a/src/Tasks/GetAssembliesMetadata.cs
+++ b/src/Tasks/GetAssembliesMetadata.cs
@@ -2,20 +2,11 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
 using System.IO;
-using System.Linq;
-using System.Reflection;
 using System.Runtime.Versioning;
-using System.Threading;
-using System.Threading.Tasks;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyDependency;
 using Microsoft.Build.Utilities;
 
diff --git a/src/Tasks/GetAssemblyIdentity.cs b/src/Tasks/GetAssemblyIdentity.cs
index 1d5c78c929e..375e0d2d430 100644
--- a/src/Tasks/GetAssemblyIdentity.cs
+++ b/src/Tasks/GetAssemblyIdentity.cs
@@ -3,12 +3,14 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
 using System.Reflection;
-using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
+#if !NET
+using System.Globalization;
+using System.Text;
+#endif
 
 #nullable disable
 
@@ -45,12 +47,17 @@ private static string ByteArrayToHex(Byte[] a)
             {
                 return null;
             }
+
+#if NET
+            return Convert.ToHexString(a);
+#else
             var s = new StringBuilder(a.Length * 2);
             foreach (Byte b in a)
             {
                 s.Append(b.ToString("X02", CultureInfo.InvariantCulture));
             }
             return s.ToString();
+#endif
         }
 
         public override bool Execute()
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index b1a24a00d6a..34f84047a3f 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -1090,7 +1090,7 @@ internal bool IsAssemblyListCacheFileUpToDate(string sdkIdentity, string sdkRoot
                 string currentAssembly = String.Empty;
                 try
                 {
-#if NETCOREAPP
+#if NET
                     currentAssembly = Assembly.GetExecutingAssembly().Location;
 #else
                     currentAssembly = Assembly.GetExecutingAssembly().CodeBase;
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index 0bc42f56bfe..828012a2add 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -94,6 +94,9 @@ public override bool Execute()
 
                         sha.TransformFinalBlock(shaBuffer, 0, shaBufferPosition);
 
+#if NET
+                        HashResult = Convert.ToHexStringLower(sha.Hash);
+#else
                         using (var stringBuilder = new ReuseableStringBuilder(sha.HashSize))
                         {
                             foreach (var b in sha.Hash)
@@ -102,6 +105,7 @@ public override bool Execute()
                             }
                             HashResult = stringBuilder.ToString();
                         }
+#endif
                     }
                     finally
                     {
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index 3169eaec219..12426e0c9aa 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -261,10 +261,7 @@ public override bool Execute()
             if (BuildInParallel)
             {
                 skipProjects = new bool[Projects.Length];
-                for (int i = 0; i < skipProjects.Length; i++)
-                {
-                    skipProjects[i] = true;
-                }
+                skipProjects.AsSpan().Fill(true);
             }
             else
             {
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 081762e8b84..22564f94bc6 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -9,7 +9,6 @@
 using System.Runtime.InteropServices;
 using System.Xml;
 using System.Xml.Serialization;
-using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -508,7 +507,7 @@ private void ValidateCom()
                 }
             }
 
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateManifest.CheckForComDuplicates t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"GenerateManifest.CheckForComDuplicates t={Environment.TickCount - t1}");
         }
 
         private void ValidateConfig()
@@ -661,11 +660,11 @@ private void ValidateReferencesForClickOnceApplication()
 
                     // Check for two or more items with the same TargetPath...
                     string key = assembly.TargetPath.ToLowerInvariant();
-                    if (!targetPathList.ContainsKey(key))
+                    if (!targetPathList.TryGetValue(key, out bool value))
                     {
                         targetPathList.Add(key, false);
                     }
-                    else if (!targetPathList[key])
+                    else if (!value)
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateTargetPath", assembly.ToString());
                         targetPathList[key] = true; // only warn once per path
@@ -707,18 +706,18 @@ private void ValidateReferencesForClickOnceApplication()
 
                     // Check for two or more items with the same TargetPath...
                     string key = file.TargetPath.ToLowerInvariant();
-                    if (!targetPathList.ContainsKey(key))
+                    if (!targetPathList.TryGetValue(key, out bool value))
                     {
                         targetPathList.Add(key, false);
                     }
-                    else if (!targetPathList[key])
+                    else if (!value)
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateTargetPath", file.TargetPath);
                         targetPathList[key] = true; // only warn once per path
                     }
                 }
             }
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "GenerateManifest.CheckManifestReferences t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"GenerateManifest.CheckManifestReferences t={Environment.TickCount - t1}");
         }
 
         private void ValidateReferenceForPartialTrust(AssemblyReference assembly, TrustInfo trustInfo)
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index 6328476020f..28dbbfef17f 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -26,7 +26,7 @@ namespace Microsoft.Build.Tasks.Deployment.ManifestUtilities
     /// <remarks>This is a serialization format, do not remove or change the private fields.</remarks>
     [ComVisible(false)]
     [XmlRoot("AssemblyIdentity")]
-    public sealed class AssemblyIdentity
+    public sealed partial class AssemblyIdentity
     {
         /// <summary>
         /// Specifies which attributes are to be returned by the GetFullName function.
@@ -59,6 +59,17 @@ public enum FullNameFlags
         private string _processorArchitecture;
         private string _type;
 
+        private const string AssemblyNamePattern =
+            "^(?<name>[^,]*)(, Version=(?<version>[^,]*))?(, Culture=(?<culture>[^,]*))?(, PublicKeyToken=(?<pkt>[^,]*))?(, ProcessorArchitecture=(?<pa>[^,]*))?(, Type=(?<type>[^,]*))?";
+
+#if NET
+        [GeneratedRegex(AssemblyNamePattern)]
+        private static partial Regex AssemblyNameRegex { get; }
+#else
+        private static Regex AssemblyNameRegex => _assemblyNameRegex ??= new Regex(AssemblyNamePattern);
+        private static Regex _assemblyNameRegex;
+#endif
+
         /// <summary>
         /// Initializes a new instance of the AssemblyIdentity class.
         /// </summary>
@@ -165,7 +176,7 @@ public AssemblyIdentity(AssemblyIdentity identity)
         public static AssemblyIdentity FromAssemblyName(string assemblyName)
         {
             // NOTE: We're not using System.Reflection.AssemblyName class here because we need ProcessorArchitecture and Type attributes.
-            Regex re = new Regex("^(?<name>[^,]*)(, Version=(?<version>[^,]*))?(, Culture=(?<culture>[^,]*))?(, PublicKeyToken=(?<pkt>[^,]*))?(, ProcessorArchitecture=(?<pa>[^,]*))?(, Type=(?<type>[^,]*))?");
+            Regex re = AssemblyNameRegex;
             Match m = re.Match(assemblyName);
             string name = m.Result("${name}");
             string version = m.Result("${version}");
@@ -367,10 +378,15 @@ public bool IsInFramework(string frameworkIdentifier, string frameworkVersion)
             Version version = null;
             if (!string.IsNullOrEmpty(frameworkVersion))
             {
-                // CA1307:Specify StringComparison.  Suppressed since a valid string representation of a version would be parsed correctly even if the the first character is not "v".
-                if (frameworkVersion.StartsWith("v"))
+                if (frameworkVersion[0] == 'v')
                 {
-                    System.Version.TryParse(frameworkVersion.Substring(1), out version);
+                    System.Version.TryParse(
+#if NET
+                        frameworkVersion.AsSpan(1),
+#else
+                        frameworkVersion.Substring(1),
+#endif
+                        out version);
                 }
                 else
                 {
@@ -514,14 +530,14 @@ internal string Resolve(string[] searchPaths, bool specificVersion)
 
             foreach (string searchPath in searchPaths)
             {
-                string file = String.Format(CultureInfo.InvariantCulture, "{0}.dll", _name);
+                string file = $"{_name}.dll";
                 string path = Path.Combine(searchPath, file);
                 if (FileSystems.Default.FileExists(path) && IsEqual(this, FromFile(path), specificVersion))
                 {
                     return path;
                 }
 
-                file = String.Format(CultureInfo.InvariantCulture, "{0}.manifest", _name);
+                file = $"{_name}.manifest";
                 path = Path.Combine(searchPath, file);
                 if (FileSystems.Default.FileExists(path) && IsEqual(this, FromManifest(path), specificVersion))
                 {
diff --git a/src/Tasks/ManifestUtil/CngLightup.cs b/src/Tasks/ManifestUtil/CngLightup.cs
index 9df8266fb8e..94e6a9c206c 100644
--- a/src/Tasks/ManifestUtil/CngLightup.cs
+++ b/src/Tasks/ManifestUtil/CngLightup.cs
@@ -26,7 +26,6 @@ namespace System.Security.Cryptography
 {
     internal static partial class CngLightup
     {
-        private const string DsaOid = "1.2.840.10040.4.1";
         private const string RsaOid = "1.2.840.113549.1.1.1";
 
         private const string HashAlgorithmNameTypeName = "System.Security.Cryptography.HashAlgorithmName";
@@ -57,9 +56,6 @@ internal static partial class CngLightup
 
         private static readonly Lazy<bool> s_preferRsaCng = new Lazy<bool>(DetectRsaCngSupport);
 
-        private static volatile Func<X509Certificate2, DSA> s_getDsaPublicKey;
-        private static volatile Func<X509Certificate2, DSA> s_getDsaPrivateKey;
-
         private static volatile Func<X509Certificate2, RSA> s_getRsaPublicKey;
         private static volatile Func<X509Certificate2, RSA> s_getRsaPrivateKey;
         private static volatile Func<RSA, byte[], string, byte[]> s_rsaPkcs1SignMethod;
@@ -112,30 +108,6 @@ internal static RSA GetRSAPrivateKey(X509Certificate2 cert)
             return s_getRsaPrivateKey(cert);
         }
 
-        internal static DSA GetDSAPublicKey(X509Certificate2 cert)
-        {
-            if (s_getDsaPublicKey == null)
-            {
-                s_getDsaPublicKey =
-                    BindCoreDelegate<DSA>("DSA", isPublic: true) ??
-                    BindGetCapiPublicKey<DSA, DSACryptoServiceProvider>(DsaOid);
-            }
-
-            return s_getDsaPublicKey(cert);
-        }
-
-        internal static DSA GetDSAPrivateKey(X509Certificate2 cert)
-        {
-            if (s_getDsaPrivateKey == null)
-            {
-                s_getDsaPrivateKey =
-                    BindCoreDelegate<DSA>("DSA", isPublic: false) ??
-                    BindGetCapiPrivateKey<DSA>(DsaOid, csp => new DSACryptoServiceProvider(csp));
-            }
-
-            return s_getDsaPrivateKey(cert);
-        }
-
 #if !CNG_LIGHTUP_NO_SYSTEM_CORE
         internal static ECDsa GetECDsaPublicKey(X509Certificate2 cert)
         {
@@ -526,7 +498,6 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
             // Load System.Core.dll and load the appropriate extension class
             // (one of
             //    System.Security.Cryptography.X509Certificates.RSACertificateExtensions
-            //    System.Security.Cryptography.X509Certificates.DSACertificateExtensions
             //    System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions
             // )
             string typeName = "System.Security.Cryptography.X509Certificates." + algorithmName + "CertificateExtensions";
@@ -547,8 +518,6 @@ private static Func<X509Certificate2, T> BindCoreDelegate<T>(string algorithmNam
             // (one of
             //     GetRSAPublicKey(this X509Certificate2 c)
             //     GetRSAPrivateKey(this X509Certificate2 c)
-            //     GetDSAPublicKey(this X509Certificate2 c)
-            //     GetDSAPrivateKey(this X509Certificate2 c)
             //     GetECDsaPublicKey(this X509Certificate2 c)
             //     GetECDsaPrivateKey(this X509Certificate2 c)
             // )
diff --git a/src/Tasks/ManifestUtil/ConvertUtil.cs b/src/Tasks/ManifestUtil/ConvertUtil.cs
index 7945fed64e5..88be5e23f8a 100644
--- a/src/Tasks/ManifestUtil/ConvertUtil.cs
+++ b/src/Tasks/ManifestUtil/ConvertUtil.cs
@@ -26,11 +26,11 @@ public static bool ToBoolean(string value, bool defaultValue)
                 }
                 catch (FormatException)
                 {
-                    Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Invalid value '{0}' for {1}, returning {2}", value, typeof(bool).Name, defaultValue.ToString()));
+                    Debug.Fail($"Invalid value '{value}' for {typeof(bool).Name}, returning {defaultValue}");
                 }
                 catch (ArgumentException)
                 {
-                    Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Invalid value '{0}' for {1}, returning {2}", value, typeof(bool).Name, defaultValue.ToString()));
+                    Debug.Fail($"Invalid value '{value}' for {typeof(bool).Name}, returning {defaultValue}");
                 }
             }
             return defaultValue;
diff --git a/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs b/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
index 01cb5f8f5d3..dd5d26ca355 100644
--- a/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
+++ b/src/Tasks/ManifestUtil/EmbeddedManifestReader.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Globalization;
 using System.IO;
 using System.Runtime.InteropServices;
 
@@ -74,7 +73,7 @@ public static Stream Read(string path)
 
             int t1 = Environment.TickCount;
             EmbeddedManifestReader r = new EmbeddedManifestReader(path);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "EmbeddedManifestReader.Read t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"EmbeddedManifestReader.Read t={Environment.TickCount - t1}");
             return r._manifest;
         }
     }
diff --git a/src/Tasks/ManifestUtil/Manifest.cs b/src/Tasks/ManifestUtil/Manifest.cs
index d8e5b2a8fdd..60b55b7cb1e 100644
--- a/src/Tasks/ManifestUtil/Manifest.cs
+++ b/src/Tasks/ManifestUtil/Manifest.cs
@@ -10,7 +10,6 @@
 using System.Runtime.InteropServices;
 using System.Xml;
 using System.Xml.Serialization;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
 #nullable disable
@@ -630,11 +629,11 @@ private void ValidateReferences()
                     // Check for two or more assemblies with the same identity...
                     string identity = assembly.AssemblyIdentity.GetFullName(AssemblyIdentity.FullNameFlags.All);
                     string key = identity.ToLowerInvariant();
-                    if (!identityList.ContainsKey(key))
+                    if (!identityList.TryGetValue(key, out bool value))
                     {
                         identityList.Add(key, false);
                     }
-                    else if (!identityList[key])
+                    else if (!value)
                     {
                         OutputMessages.AddWarningMessage("GenerateManifest.DuplicateAssemblyIdentity", identity);
                         identityList[key] = true; // only warn once per identity
diff --git a/src/Tasks/ManifestUtil/ManifestFormatter.cs b/src/Tasks/ManifestUtil/ManifestFormatter.cs
index d7d7ee01eb1..6300dba4d0b 100644
--- a/src/Tasks/ManifestUtil/ManifestFormatter.cs
+++ b/src/Tasks/ManifestUtil/ManifestFormatter.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Globalization;
 using System.IO;
 using System.Text;
 using System.Xml;
@@ -97,8 +96,8 @@ public static Stream Format(Stream input)
             w.WriteEndDocument();
             w.Flush();
             m.Position = 0;
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "ManifestWriter.Format t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"ManifestWriter.Format t={Environment.TickCount - t1}");
             return m;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Tasks/ManifestUtil/ManifestReader.cs b/src/Tasks/ManifestUtil/ManifestReader.cs
index 131de566c33..1bd48abe2db 100644
--- a/src/Tasks/ManifestUtil/ManifestReader.cs
+++ b/src/Tasks/ManifestUtil/ManifestReader.cs
@@ -246,7 +246,7 @@ private static Manifest Deserialize(Stream s)
             using (XmlReader xr = XmlReader.Create(s, xrSettings))
             {
                 var m = (Manifest)xs.Deserialize(xr);
-                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "ManifestReader.Deserialize t={0}", Environment.TickCount - t1));
+                Util.WriteLog($"ManifestReader.Deserialize t={Environment.TickCount - t1}");
                 return m;
             }
         }
diff --git a/src/Tasks/ManifestUtil/ManifestWriter.cs b/src/Tasks/ManifestUtil/ManifestWriter.cs
index 8da08fbacde..71d3a1478b6 100644
--- a/src/Tasks/ManifestUtil/ManifestWriter.cs
+++ b/src/Tasks/ManifestUtil/ManifestWriter.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections;
-using System.Globalization;
 using System.IO;
 using System.Runtime.InteropServices;
 using System.Xml.Serialization;
@@ -28,7 +27,7 @@ private static Stream Serialize(Manifest manifest)
 
             int t1 = Environment.TickCount;
             s.Serialize(w, manifest);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "ManifestWriter.Serialize t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"ManifestWriter.Serialize t={Environment.TickCount - t1}");
 
             w.Flush();
             m.Position = 0;
@@ -188,7 +187,7 @@ private static void WriteManifest(Manifest manifest, Stream output, string targe
             Util.WriteLogFile(n + ".write.3-formatted.xml", s4);
 
             Util.CopyStream(s4, output);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "ManifestWriter.WriteManifest t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"ManifestWriter.WriteManifest t={Environment.TickCount - t1}");
         }
     }
 }
diff --git a/src/Tasks/ManifestUtil/MetadataReader.cs b/src/Tasks/ManifestUtil/MetadataReader.cs
index fe8269ecdca..efd6d271087 100644
--- a/src/Tasks/ManifestUtil/MetadataReader.cs
+++ b/src/Tasks/ManifestUtil/MetadataReader.cs
@@ -173,7 +173,12 @@ private string GetPublicKeyToken()
                 an.SetPublicKey(pk);
                 byte[] pkt = an.GetPublicKeyToken();
 
-                publicKeyToken = BitConverter.ToString(pkt).Replace("-", "");
+                publicKeyToken =
+#if NET
+                    Convert.ToHexString(pkt);
+#else
+                    BitConverter.ToString(pkt).Replace("-", "");
+#endif
             }
 
             if (!String.IsNullOrEmpty(publicKeyToken))
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index 81c678e17cf..93ec71a20a8 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -3,7 +3,11 @@
 
 using System;
 using System.IO;
+#if !NET
 using System.Linq;
+#else
+using System.Text;
+#endif
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -222,7 +226,13 @@ public static string Resolve(string path)
                 {
                     // Unfortunately Uri.Host is read-only, so we need to reconstruct it manually...
                     int i = path.IndexOf(localHost, StringComparison.OrdinalIgnoreCase);
-                    return i >= 0 ? path.Substring(0, i) + Environment.MachineName.ToLowerInvariant() + path.Substring(i + localHost.Length) : path;
+                    return i >= 0 ?
+#if NET
+                        $"{path.AsSpan(0, i)}{Environment.MachineName.ToLowerInvariant()}{path.AsSpan(i + localHost.Length)}" :
+#else
+                        $"{path.Substring(0, i)}{Environment.MachineName.ToLowerInvariant()}{path.Substring(i + localHost.Length)}" :
+#endif
+                        path;
                 }
                 return path;
             }
@@ -231,7 +241,11 @@ public static string Resolve(string path)
             return Path.GetFullPath(path); // make sure it's a full path
         }
 
-        private static bool IsAsciiString(string str)
-            => str.All(c => c <= 127);
+        private static bool IsAsciiString(string str) =>
+#if NET
+            Ascii.IsValid(str);
+#else
+            str.All(c => c <= 127);
+#endif
     }
 }
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index bc10cb1d02c..5583c56c349 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -5,7 +5,6 @@
 using System.Collections;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
 using System.IO;
 using System.Runtime.InteropServices;
 #if !RUNTIME_TYPE_NETCORE
@@ -790,7 +789,7 @@ public void WriteManifest(Stream input, Stream output)
                 output.Flush();
             }
             document.Save(output);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "ManifestWriter.WriteTrustInfo t={0}", Environment.TickCount - t1));
+            Util.WriteLog($"ManifestWriter.WriteTrustInfo t={Environment.TickCount - t1}");
         }
     }
 }
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index a6b50bd028f..a2d89b437c7 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -67,47 +67,25 @@ public static string ByteArrayToHex(Byte[] a)
                 return null;
             }
 
-            StringBuilder s = new StringBuilder(a.Length);
+#if NET
+            return Convert.ToHexString(a);
+#else
+            StringBuilder s = new StringBuilder(a.Length * 2);
             foreach (Byte b in a)
             {
                 s.Append(b.ToString("X02", CultureInfo.InvariantCulture));
             }
 
             return s.ToString();
+#endif
         }
 
-        public static string ByteArrayToString(Byte[] a)
-        {
-            if (a == null)
-            {
-                return null;
-            }
-
-            StringBuilder s = new StringBuilder(a.Length);
-            foreach (Byte b in a)
-            {
-                s.Append(Convert.ToChar(b));
-            }
-
-            return s.ToString();
-        }
-
-        public static int CopyStream(Stream input, Stream output)
+        public static void CopyStream(Stream input, Stream output)
         {
             const int bufferSize = 0x4000;
-            byte[] buffer = new byte[bufferSize];
-            int bytesCopied = 0;
-            int bytesRead;
-            do
-            {
-                bytesRead = input.Read(buffer, 0, bufferSize);
-                output.Write(buffer, 0, bytesRead);
-                bytesCopied += bytesRead;
-            } while (bytesRead > 0);
-            output.Flush();
+            input.CopyTo(output, bufferSize);
             input.Position = 0;
             output.Position = 0;
-            return bytesCopied;
         }
 
         public static string FilterNonprintableChars(string value)
@@ -194,9 +172,15 @@ public static Version GetTargetFrameworkVersion(string targetFramework)
             Version frameworkVersion = null;
             if (!String.IsNullOrEmpty(targetFramework))
             {
-                if (targetFramework.StartsWith("v", StringComparison.OrdinalIgnoreCase))
+                if (targetFramework[0] is 'v' or 'V')
                 {
-                    Version.TryParse(targetFramework.Substring(1), out frameworkVersion);
+                    Version.TryParse(
+#if NET
+                        targetFramework.AsSpan(1),
+#else
+                        targetFramework.Substring(1),
+#endif
+                        out frameworkVersion);
                 }
                 else
                 {
@@ -216,8 +200,8 @@ public static string GetEmbeddedResourceString(string name)
         public static Stream GetEmbeddedResourceStream(string name)
         {
             Assembly a = Assembly.GetExecutingAssembly();
-            Stream s = a.GetManifestResourceStream(String.Format(CultureInfo.InvariantCulture, "{0}.{1}", typeof(Util).Namespace, name));
-            Debug.Assert(s != null, String.Format(CultureInfo.CurrentCulture, "EmbeddedResource '{0}' not found", name));
+            Stream s = a.GetManifestResourceStream($"{typeof(Util).Namespace}.{name}");
+            Debug.Assert(s != null, $"EmbeddedResource '{name}' not found");
             return s;
         }
 
@@ -634,8 +618,14 @@ public static Version ConvertFrameworkVersionToString(string version)
         {
             if (version.StartsWith("v", StringComparison.OrdinalIgnoreCase))
             {
-                return new Version(version.Substring(1));
+                return Version.Parse(
+#if NET
+                    version.AsSpan(1));
+#else
+                    version.Substring(1));
+#endif
             }
+
             return new Version(version);
         }
 
diff --git a/src/Tasks/ManifestUtil/XmlUtil.cs b/src/Tasks/ManifestUtil/XmlUtil.cs
index 32f985124aa..524ee02ff3d 100644
--- a/src/Tasks/ManifestUtil/XmlUtil.cs
+++ b/src/Tasks/ManifestUtil/XmlUtil.cs
@@ -5,7 +5,6 @@
 using System.Collections;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
 using System.IO;
 using System.Reflection;
 using System.Text;
@@ -82,14 +81,14 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
 
             int t2 = Environment.TickCount;
             XPathDocument d = new XPathDocument(s);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "new XPathDocument(1) t={0}", Environment.TickCount - t2));
+            Util.WriteLog($"new XPathDocument(1) t={Environment.TickCount - t2}");
 
             int t3 = Environment.TickCount;
             var xslc = new XslCompiledTransform();
             // Using the Trusted Xslt is fine as the style sheet comes from our own assemblies.
             // This is similar to the prior this.GetType().Assembly/Evidence method that was used in the now depricated XslTransform.
             xslc.Load(d, XsltSettings.TrustedXslt, s_resolver);
-            Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform.Load t={0}", Environment.TickCount - t3));
+            Util.WriteLog($"XslCompiledTransform.Load t={Environment.TickCount - t3}");
 
             // Need to copy input stream because XmlReader will close it,
             // causing errors for later callers that access the same stream
@@ -99,7 +98,7 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
             int t4 = Environment.TickCount;
             using (XmlReader reader = XmlReader.Create(clonedInput))
             {
-                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "new XmlReader(2) t={0}", Environment.TickCount - t4));
+                Util.WriteLog($"new XmlReader(2) t={Environment.TickCount - t4}");
 
                 XsltArgumentList args = null;
                 if (entries.Length > 0)
@@ -110,7 +109,7 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
                         string key = entry.Key.ToString();
                         object val = entry.Value.ToString();
                         args.AddParam(key, "", val);
-                        Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "arg: key='{0}' value='{1}'", key, val.ToString()));
+                        Util.WriteLog($"arg: key='{key}' value='{val}'");
                     }
                 }
 
@@ -122,13 +121,13 @@ public static Stream XslTransform(string resource, Stream input, params Dictiona
 
                 int t5 = Environment.TickCount;
                 xslc.Transform(reader, args, w, s_resolver);
-                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform.Transform t={0}", Environment.TickCount - t4));
+                Util.WriteLog($"XslCompiledTransform.Transform t={Environment.TickCount - t4}");
 
                 w.WriteEndDocument();
                 w.Flush();
                 m.Position = 0;
 
-                Util.WriteLog(String.Format(CultureInfo.CurrentCulture, "XslCompiledTransform(\"{0}\") t={1}", resource, Environment.TickCount - t1));
+                Util.WriteLog($"XslCompiledTransform(\"{resource}\") t={Environment.TickCount - t1}");
 
                 return m;
             }
@@ -153,7 +152,7 @@ public override Object GetEntity(Uri uri, string role, Type t)
                 {
                     // First look in assembly resources...
                     Assembly a = Assembly.GetExecutingAssembly();
-                    s = a.GetManifestResourceStream(String.Format(CultureInfo.InvariantCulture, "{0}.{1}", typeof(Util).Namespace, filename));
+                    s = a.GetManifestResourceStream($"{typeof(Util).Namespace}.{filename}");
 
                     if (s != null)
                     {
@@ -191,7 +190,7 @@ public override Object GetEntity(Uri uri, string role, Type t)
                 }
 
                 // Didn't find the resource...
-                Debug.Fail(String.Format(CultureInfo.CurrentCulture, "ResourceResolver could not find file '{0}'", filename));
+                Debug.Fail($"ResourceResolver could not find file '{filename}'");
                 return null;
             }
         }
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index 862bfb6b88c..d23e63c0870 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -817,12 +817,17 @@ private static string ObtainRFC3161Timestamp(string timeStampUrl, string signatu
 
                 try
                 {
+#if NET
+                    Span<byte> nonce = stackalloc byte[32];
+                    RandomNumberGenerator.Fill(nonce);
+#else
                     byte[] nonce = new byte[32];
 
                     using (RandomNumberGenerator rng = RandomNumberGenerator.Create())
                     {
                         rng.GetBytes(nonce);
                     }
+#endif
 
                     // Eventually, CryptEncodeObjectEx(...) is called on a CRYPT_TIMESTAMP_REQUEST with this nonce,
                     // and CryptEncodeObjectEx(...) interprets the nonce as a little endian, DER-encoded integer value
@@ -1044,13 +1049,19 @@ private static void StrongNameSignManifestDom(XmlDocument manifestDom, XmlDocume
             // Insert the signature now.
             signatureParent.AppendChild(xmlDigitalSignature);
         }
+
+#if !NET
         private static readonly char[] s_hexValues = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+#endif
 
         private static string BytesToHexString(byte[] array, int start, int end)
         {
             string result = null;
             if (array != null)
             {
+#if NET
+                return Convert.ToHexStringLower(array.AsSpan(start, end - start));
+#else
                 char[] hexOrder = new char[(end - start) * 2];
                 int i = end;
                 int digit, j = 0;
@@ -1062,6 +1073,7 @@ private static string BytesToHexString(byte[] array, int start, int end)
                     hexOrder[j++] = s_hexValues[digit];
                 }
                 result = new String(hexOrder);
+#endif
             }
             return result;
         }
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index b7590096722..48b9de51827 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1639,7 +1639,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     -->
 
   <Target
-    Name="_SplitProjectReferencesByFileExistence">
+    Name="_SplitProjectReferencesByFileExistence"
+    DependsOnTargets="AssignProjectConfiguration">
 
     <!--
         Use this task for matching projects with pre-resolved project outputs set by the IDE
@@ -2568,6 +2569,24 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
     </PropertyGroup>
 
+    <PropertyGroup>
+      <ConfigFileExists Condition="Exists('@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')')">true</ConfigFileExists>
+      <HasNoBindingRedirects Condition="'@(SuggestedBindingRedirects)' == ''">true</HasNoBindingRedirects>
+    </PropertyGroup>
+
+    <!-- Overwrites .config file with a App.config content if RAR returned empty @(SuggestedBindingRedirects). -->
+    <Copy
+      SourceFiles="@(AppConfigWithTargetPath->'%(FullPath)')"
+      DestinationFiles="$(_GenerateBindingRedirectsIntermediateAppConfig)"
+      SkipUnchangedFiles="true"
+      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'">
+      <Output TaskParameter="CopiedFiles" ItemName="FileWrites"/>
+    </Copy>
+    <Touch
+      Files="$(_GenerateBindingRedirectsIntermediateAppConfig)"
+      AlwaysCreate="true"
+      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'"/>
+
     <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
       <AppConfigWithTargetPath Include="$(AppConfig)">
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 111880e1d30..5f321996db9 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -12,7 +12,9 @@
 using System.Collections.Generic;
 using System.Collections;
 using System.Globalization;
+#if !NET
 using System.Linq;
+#endif
 #if FEATURE_HANDLEPROCESSCORRUPTEDSTATEEXCEPTIONS
 using System.Runtime.ExceptionServices;
 #endif
@@ -520,7 +522,7 @@ internal struct PROCESS_INFORMATION
     /// <summary>
     /// Interop methods.
     /// </summary>
-    internal static class NativeMethods
+    internal static partial class NativeMethods
     {
         #region Constants
 
@@ -1160,7 +1162,7 @@ internal static unsafe bool TryReadMetadataString(string fullPath, IntPtr attrDa
                             }
 
                             // And convert it to the output string.
-                            strValue = new String(Encoding.UTF8.GetChars(bytes));
+                            strValue = Encoding.UTF8.GetString(bytes);
                         }
                         else
                         {
@@ -1235,19 +1237,24 @@ internal static unsafe int CorSigUncompressData(IntPtr data, out int uncompresse
         /// This class is a wrapper over the native GAC enumeration API.
         /// </summary>
         [ComVisible(false)]
-        internal class AssemblyCacheEnum : IEnumerable<AssemblyNameExtension>
+        internal partial class AssemblyCacheEnum : IEnumerable<AssemblyNameExtension>
         {
             /// <summary>
             /// Path to the gac
             /// </summary>
             private static readonly string s_gacPath = Path.Combine(NativeMethodsShared.FrameworkBasePath, "gac");
 
+            private const string AssemblyVersionPattern = @"^([.\d]+)_([^_]*)_([a-fA-F\d]{16})$";
+
             /// <summary>
             /// Regex for directory version parsing
             /// </summary>
-            private static readonly Regex s_assemblyVersionRegex = new Regex(
-                @"^([.\d]+)_([^_]*)_([a-fA-F\d]{16})$",
-                RegexOptions.CultureInvariant | RegexOptions.Compiled);
+#if NET
+            [GeneratedRegex(AssemblyVersionPattern, RegexOptions.CultureInvariant)]
+            private static partial Regex AssemblyVersionRegex { get; }
+#else
+            private static Regex AssemblyVersionRegex { get; } = new Regex(AssemblyVersionPattern, RegexOptions.CultureInvariant | RegexOptions.Compiled);
+#endif
 
             /// <summary>
             /// The IAssemblyEnum interface which allows us to ask for the next assembly from the GAC enumeration.
@@ -1387,7 +1394,7 @@ public IEnumerator<AssemblyNameExtension> GetEnumerator()
                                 var versionString = Path.GetFileName(version);
                                 if (!string.IsNullOrWhiteSpace(versionString))
                                 {
-                                    var match = s_assemblyVersionRegex.Match(versionString);
+                                    var match = AssemblyVersionRegex.Match(versionString);
                                     if (match.Success)
                                     {
                                         var name = new AssemblyName
@@ -1407,10 +1414,16 @@ public IEnumerator<AssemblyNameExtension> GetEnumerator()
                                         if (!string.IsNullOrWhiteSpace(match.Groups[3].Value))
                                         {
                                             var value = match.Groups[3].Value;
-                                            name.SetPublicKeyToken(
+                                            byte[] key =
+#if NET
+                                                Convert.FromHexString(value.AsSpan(0, 16));
+#else
                                                 Enumerable.Range(0, 16)
-                                                    .Where(x => x % 2 == 0)
-                                                    .Select(x => Convert.ToByte(value.Substring(x, 2), 16)).ToArray());
+                                                .Where(x => x % 2 == 0)
+                                                .Select(x => Convert.ToByte(value.Substring(x, 2), 16))
+                                                .ToArray();
+#endif
+                                            name.SetPublicKeyToken(key);
                                         }
 
                                         yield return new AssemblyNameExtension(name);
@@ -1455,8 +1468,12 @@ public static string AssemblyPathFromStrongName(string strongName)
                             "{0}_{1}_{2}",
                             assemblyNameVersion.Version.ToString(4),
                             assemblyNameVersion.CultureName != "neutral" ? assemblyNameVersion.CultureName : string.Empty,
+#if NET
+                            Convert.ToHexStringLower(assemblyNameVersion.GetPublicKeyToken())),
+#else
                             assemblyNameVersion.GetPublicKeyToken()
                                 .Aggregate(new StringBuilder(), (builder, v) => builder.Append(v.ToString("x2")))),
+#endif
                         assemblyNameVersion.Name + ".dll");
 
                     if (FileSystems.Default.FileExists(path))
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index f5476e2f9fc..7d8e6acd7ce 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -372,7 +372,7 @@ private static string GetSimpleName(string assemblyName)
                 throw new ArgumentNullException(nameof(assemblyName));
             }
 
-            int i = assemblyName.IndexOf(",", StringComparison.Ordinal);
+            int i = assemblyName.IndexOf(',');
             return i > 0 ? assemblyName.Substring(0, i) : assemblyName;
         }
 
@@ -794,7 +794,7 @@ private static void ParseFileListSection(AssemblyTableInfo assemblyTableInfo, st
                         {
                             // When comparing the assembly entries we want to compare the FullName which is a formatted as name, version, publicKeyToken and culture and whether the entry is a redistroot flag
                             // We do not need to add the redistName and the framework directory because this will be the same for all entries in the current redist list being read.
-                            string hashIndex = String.Format(CultureInfo.InvariantCulture, "{0},{1}", newEntry.FullName, newEntry.IsRedistRoot == null ? "null" : newEntry.IsRedistRoot.ToString());
+                            string hashIndex = $"{newEntry.FullName},{(newEntry.IsRedistRoot == null ? "null" : newEntry.IsRedistRoot.ToString())}";
 
                             assemblyEntries.TryGetValue(hashIndex, out AssemblyEntry dictionaryEntry);
                             // If the entry is not in the dictionary or the entry is in the dictionary but the new entry has the ingac flag true, make sure the dictionary contains the entry with the ingac true.
diff --git a/src/Tasks/RequiresFramework35SP1Assembly.cs b/src/Tasks/RequiresFramework35SP1Assembly.cs
index 4714f818e73..741dcbe59fc 100644
--- a/src/Tasks/RequiresFramework35SP1Assembly.cs
+++ b/src/Tasks/RequiresFramework35SP1Assembly.cs
@@ -79,7 +79,12 @@ private static Version ConvertFrameworkVersionToString(string version)
         {
             if (version.StartsWith("v", StringComparison.OrdinalIgnoreCase))
             {
-                return new Version(version.Substring(1));
+                return Version.Parse(
+#if NET
+                    version.AsSpan(1));
+#else
+                    version.Substring(1));
+#endif
             }
             return new Version(version);
         }
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index c8ba6d686f4..c339ea9c5be 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -5,7 +5,7 @@
 #if !RUNTIME_TYPE_NETCORE
 using System.Collections.Generic;
 #endif
-#if !NET7_0_OR_GREATER
+#if !NET
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 9a78f010f16..d8a61ab1579 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -215,7 +215,12 @@ private static Version ConvertFrameworkVersionToString(string version)
         {
             if (version.StartsWith("v", StringComparison.OrdinalIgnoreCase))
             {
-                return new Version(version.Substring(1));
+                return Version.Parse(
+#if NET
+                    version.AsSpan(1));
+#else
+                    version.Substring(1));
+#endif
             }
             return new Version(version);
         }
@@ -346,7 +351,7 @@ private static CultureInfo GetItemCulture(ITaskItem item)
                 // Infer culture from path (i.e. "obj\debug\fr\WindowsApplication1.resources.dll" -> "fr")
                 string[] pathSegments = PathUtil.GetPathSegments(item.ItemSpec);
                 itemCulture = pathSegments.Length > 1 ? pathSegments[pathSegments.Length - 2] : null;
-                Debug.Assert(!String.IsNullOrEmpty(itemCulture), String.Format(CultureInfo.CurrentCulture, "Satellite item '{0}' is missing expected attribute '{1}'", item.ItemSpec, "Culture"));
+                Debug.Assert(!String.IsNullOrEmpty(itemCulture), $"Satellite item '{item.ItemSpec}' is missing expected attribute 'Culture'");
                 item.SetMetadata("Culture", itemCulture);
             }
             return new CultureInfo(itemCulture);
@@ -862,7 +867,7 @@ public void Add(ITaskItem item)
 
                 // Add to map with full name, for SpecificVersion=true case
                 string key = fusionName.ToLowerInvariant();
-                Debug.Assert(!_dictionary.ContainsKey(key), String.Format(CultureInfo.CurrentCulture, "Two or more items with same key '{0}' detected", key));
+                Debug.Assert(!_dictionary.ContainsKey(key), $"Two or more items with same key '{key}' detected");
                 if (!_dictionary.ContainsKey(key))
                 {
                     _dictionary.Add(key, entry);
@@ -921,7 +926,7 @@ public void Add(ITaskItem item)
                 {
                     // Use satellite assembly strong name signature as key
                     string key = identity.ToString();
-                    Debug.Assert(!_dictionary.ContainsKey(key), String.Format(CultureInfo.CurrentCulture, "Two or more items with same key '{0}' detected", key));
+                    Debug.Assert(!_dictionary.ContainsKey(key), $"Two or more items with same key '{key}' detected");
                     if (!_dictionary.ContainsKey(key))
                     {
                         _dictionary.Add(key, entry);
@@ -962,7 +967,7 @@ public void Add(ITaskItem item, bool includedByDefault)
                 }
 
                 string key = targetPath.ToLowerInvariant();
-                Debug.Assert(!_dictionary.ContainsKey(key), String.Format(CultureInfo.CurrentCulture, "Two or more items with same '{0}' attribute detected", ItemMetadataNames.targetPath));
+                Debug.Assert(!_dictionary.ContainsKey(key), $"Two or more items with same '{(object)ItemMetadataNames.targetPath}' attribute detected");
                 var entry = new MapEntry(item, includedByDefault);
                 if (!_dictionary.ContainsKey(key))
                 {
@@ -997,11 +1002,11 @@ private static PublishState StringToPublishState(string value)
                 }
                 catch (FormatException)
                 {
-                    Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Invalid value '{0}' for {1}", value, "PublishState"));
+                    Debug.Fail($"Invalid value '{value}' for PublishState");
                 }
                 catch (ArgumentException)
                 {
-                    Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Invalid value '{0}' for {1}", value, "PublishState"));
+                    Debug.Fail($"Invalid value '{value}' for PublishState");
                 }
             }
             return PublishState.Auto;
@@ -1036,14 +1041,14 @@ public static PublishFlags GetAssemblyFlags(PublishState state, bool copyLocal)
                         isPublished = false;
                         break;
                     case PublishState.DataFile:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "PublishState.DataFile is invalid for an assembly"));
+                        Debug.Fail("PublishState.DataFile is invalid for an assembly");
                         break;
                     case PublishState.Prerequisite:
                         isPrerequisite = true;
                         isPublished = false;
                         break;
                     default:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Unhandled value PublishFlags.{0}", state.ToString()));
+                        Debug.Fail($"Unhandled value PublishFlags.{state}");
                         break;
                 }
                 return new PublishFlags(isDataFile, isPrerequisite, isPublished);
@@ -1073,10 +1078,10 @@ public static PublishFlags GetFileFlags(PublishState state, string fileExtension
                         isPublished = true;
                         break;
                     case PublishState.Prerequisite:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "PublishState.Prerequisite is invalid for a file"));
+                        Debug.Fail("PublishState.Prerequisite is invalid for a file");
                         break;
                     default:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Unhandled value PublishFlags.{0}", state.ToString()));
+                        Debug.Fail($"Unhandled value PublishFlags.{state}");
                         break;
                 }
                 return new PublishFlags(isDataFile, isPrerequisite, isPublished);
@@ -1103,14 +1108,14 @@ public static PublishFlags GetSatelliteFlags(PublishState state, CultureInfo sat
                         isPublished = false;
                         break;
                     case PublishState.DataFile:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "PublishState.DataFile is invalid for an assembly"));
+                        Debug.Fail("PublishState.DataFile is invalid for an assembly");
                         break;
                     case PublishState.Prerequisite:
                         isPrerequisite = true;
                         isPublished = false;
                         break;
                     default:
-                        Debug.Fail(String.Format(CultureInfo.CurrentCulture, "Unhandled value PublishFlags.{0}", state.ToString()));
+                        Debug.Fail($"Unhandled value PublishFlags.{state}");
                         break;
                 }
                 return new PublishFlags(isDataFile, isPrerequisite, isPublished);
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 4cf06aa29e8..9d2c288a93e 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Text.RegularExpressions;
@@ -20,7 +19,7 @@ namespace Microsoft.Build.Tasks
     /// Resolves an SDKReference to a full path on disk
     /// </summary>
 #pragma warning disable RS0022 // Constructor make noninheritable base class inheritable: Longstanding API design that we shouldn't change now
-    public class ResolveSDKReference : TaskExtension
+    public partial class ResolveSDKReference : TaskExtension
 #pragma warning restore RS0022 // Constructor make noninheritable base class inheritable
     {
         #region fields
@@ -33,13 +32,18 @@ public class ResolveSDKReference : TaskExtension
             { "UAP", "Windows" }
         };
 
+        private const string SdkReferenceFormatPattern = @"(?<SDKSIMPLENAME>^[^,]*),\s*Version=(?<SDKVERSION>.*)";
+
         /// <summary>
         /// Regex for breaking up the sdk reference include into pieces.
         /// Example: XNA, Version=8.0
         /// </summary>
-        private static readonly Regex s_sdkReferenceFormat = new Regex(
-             @"(?<SDKSIMPLENAME>^[^,]*),\s*Version=(?<SDKVERSION>.*)",
-            RegexOptions.IgnoreCase);
+#if NET
+        [GeneratedRegex(SdkReferenceFormatPattern, RegexOptions.IgnoreCase)]
+        private static partial Regex SdkReferenceFormatRegex { get; }
+#else
+        private static Regex SdkReferenceFormatRegex { get; } = new Regex(SdkReferenceFormatPattern, RegexOptions.IgnoreCase);
+#endif
 
         /// <summary>
         /// SimpleName group
@@ -409,7 +413,7 @@ public override bool Execute()
                         {
                             if (!sdksAlreadyErrorOrWarnedFor.Contains(incompatibleReference) && incompatibleReference != notCompatibleReference /*cannot be incompatible with self*/)
                             {
-                                listOfIncompatibleReferences.Add(String.Format(CultureInfo.CurrentCulture, "\"{0}\"", incompatibleReference.SDKName));
+                                listOfIncompatibleReferences.Add($"\"{incompatibleReference.SDKName}\"");
                                 sdksAlreadyErrorOrWarnedFor.Add(incompatibleReference);
                             }
                         }
@@ -438,7 +442,7 @@ public override bool Execute()
                     {
                         if (!sdksAlreadyErrorOrWarnedFor.Contains(incompatibleReference) && incompatibleReference != notCompatibleReference /*cannot be incompatible with self*/)
                         {
-                            listOfIncompatibleReferences.Add(String.Format(CultureInfo.CurrentCulture, "\"{0}\"", incompatibleReference.SDKName));
+                            listOfIncompatibleReferences.Add($"\"{incompatibleReference.SDKName}\"");
                             sdksAlreadyErrorOrWarnedFor.Add(incompatibleReference);
                         }
                     }
@@ -481,7 +485,7 @@ internal static void AddMetadataToReferences(TaskLoggingHelper log, HashSet<SDKR
                     string sdkSimpleName = referenceItem.SimpleName;
                     string rawSdkVersion = referenceItem.Version;
 
-                    if (referencesToAddMetadata.ContainsKey(sdkSimpleName) && referencesToAddMetadata[sdkSimpleName].Equals(rawSdkVersion, StringComparison.InvariantCultureIgnoreCase))
+                    if (referencesToAddMetadata.TryGetValue(sdkSimpleName, out string value) && value.Equals(rawSdkVersion, StringComparison.InvariantCultureIgnoreCase))
                     {
                         referenceItem.ResolvedItem.SetMetadata(metadataName, metadataValue);
                     }
@@ -533,7 +537,7 @@ internal static string[] GetUnresolvedDependentSDKs(HashSet<SDKReference> sdkRef
                 // Return true if no reference could be found
                 return resolvedReference == null;
             })
-            .Select(y => String.Format(CultureInfo.CurrentCulture, "\"{0}\"", y))
+            .Select(y => $"\"{y}\"")
             .ToArray();
 
             return unresolvedDependencyIdentities;
@@ -574,7 +578,7 @@ internal SDKReference ParseSDKReference(ITaskItem referenceItem)
         /// </summary>
         private static bool ParseSDKReference(string reference, out string sdkSimpleName, out string rawSdkVersion)
         {
-            Match match = s_sdkReferenceFormat.Match(reference);
+            Match match = SdkReferenceFormatRegex.Match(reference);
 
             sdkSimpleName = String.Empty;
             bool parsedVersion = false;
@@ -733,7 +737,7 @@ public SDKReference(ITaskItem taskItem, string sdkName, string sdkVersion)
                 ReferenceItem = taskItem;
                 SimpleName = sdkName;
                 Version = sdkVersion;
-                SDKName = String.Format(CultureInfo.InvariantCulture, "{0}, Version={1}", SimpleName, Version);
+                SDKName = $"{SimpleName}, Version={Version}";
                 FrameworkIdentitiesFromManifest = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 AppxLocationsFromManifest = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                 ResolutionErrors = new List<Tuple<string, object[]>>();
@@ -1289,13 +1293,13 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
                     {
                         // Try and find a framework identity that matches on both the configuration and architecture "FrameworkIdentity-<Config>-<Arch>"
                         FrameworkIdentity = null;
-                        string frameworkIdentityKey = String.Format(CultureInfo.InvariantCulture, "{0}-{1}-{2}", SDKManifest.Attributes.FrameworkIdentity, sdkConfiguration, sdkArchitecture);
+                        string frameworkIdentityKey = $"{SDKManifest.Attributes.FrameworkIdentity}-{sdkConfiguration}-{sdkArchitecture}";
                         FrameworkIdentity = FindFrameworkIdentity(frameworkIdentityKey);
 
                         // Try and find a framework identity that matches on the configuration , Element must be named "FrameworkIdentity-<Config>" only.
                         if (FrameworkIdentity == null)
                         {
-                            frameworkIdentityKey = String.Format(CultureInfo.InvariantCulture, "{0}-{1}", SDKManifest.Attributes.FrameworkIdentity, sdkConfiguration);
+                            frameworkIdentityKey = $"{SDKManifest.Attributes.FrameworkIdentity}-{sdkConfiguration}";
                             FrameworkIdentity = FindFrameworkIdentity(frameworkIdentityKey);
                         }
 
diff --git a/src/Tasks/ResourceHandling/MSBuildResXReader.cs b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
index ea1ffae0211..1f6b95b7067 100644
--- a/src/Tasks/ResourceHandling/MSBuildResXReader.cs
+++ b/src/Tasks/ResourceHandling/MSBuildResXReader.cs
@@ -89,7 +89,11 @@ private static string GetFullTypeNameFromAlias(string aliasedTypeName, Dictionar
             int indexStart = aliasedTypeName.IndexOf(',');
             if (aliases.TryGetValue(aliasedTypeName.Substring(indexStart + 2), out string fullAssemblyIdentity))
             {
+#if NET
+                return string.Concat(aliasedTypeName.AsSpan(0, indexStart + 2), fullAssemblyIdentity);
+#else
                 return aliasedTypeName.Substring(0, indexStart + 2) + fullAssemblyIdentity;
+#endif
             }
 
             // Allow "System.String" bare
@@ -290,7 +294,7 @@ private static void AddLinkedResource(string resxFilename, bool pathsRelativeToB
         /// </remarks>
         private static bool IsByteArray(string fileRefType)
         {
-            return fileRefType.IndexOf("System.Byte[]") != -1 && fileRefType.IndexOf("mscorlib") != -1;
+            return fileRefType.Contains("System.Byte[]") && fileRefType.Contains("mscorlib");
         }
 
         internal static bool IsString(string fileRefType)
@@ -333,7 +337,7 @@ internal static string[] ParseResxFileRefString(string stringValue)
                 string remainingString;
                 if (stringValue.StartsWith("\""))
                 {
-                    int lastIndexOfQuote = stringValue.LastIndexOf("\"");
+                    int lastIndexOfQuote = stringValue.LastIndexOf('"');
                     if (lastIndexOfQuote - 1 < 0)
                     {
                         throw new ArgumentException(nameof(stringValue));
@@ -349,7 +353,7 @@ internal static string[] ParseResxFileRefString(string stringValue)
                 }
                 else
                 {
-                    int nextSemiColumn = stringValue.IndexOf(";");
+                    int nextSemiColumn = stringValue.IndexOf(';');
                     if (nextSemiColumn == -1)
                     {
                         throw new ArgumentException(nameof(stringValue));
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 82941a83d6b..5614177333f 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -2839,7 +2839,7 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="translated">Non è stato possibile inferire il tipo di parametro "{0}" perché il tipo di attributo è sconosciuto. Il valore sarà trattto come una stringa.</target>
+        <target state="translated">Non è stato possibile inferire il tipo di parametro "{0}" perché il tipo di attributo è sconosciuto. Il valore sarà tratto come una stringa.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 535156bc1fd..d5d9ebda785 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -536,10 +536,10 @@ internal bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynCodeTask
             // Start with the user specified references and include all of the default references that are language agnostic
             IEnumerable<string> references = taskInfo.References.Union(DefaultReferences[String.Empty]);
 
-            if (DefaultReferences.ContainsKey(taskInfo.CodeLanguage))
+            if (DefaultReferences.TryGetValue(taskInfo.CodeLanguage, out IEnumerable<string> value))
             {
                 // Append default references for the specific language
-                references = references.Union(DefaultReferences[taskInfo.CodeLanguage]);
+                references = references.Union(value);
             }
 
             List<string> directoriesToAddToAppDomain = new();
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
index 50a26f7f5f2..21021e60adf 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactoryCompilers.cs
@@ -4,10 +4,12 @@
 using System;
 using System.IO;
 using System.Linq;
-using System.Runtime.InteropServices;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
+#if RUNTIME_TYPE_NETCORE
+using System.Runtime.InteropServices;
+using Microsoft.Build.Shared;
+#endif
 
 #nullable disable
 
diff --git a/src/Tasks/System.Resources.Extensions.pkgdef b/src/Tasks/System.Resources.Extensions.pkgdef
index 62579ad4643..4e811b44871 100644
--- a/src/Tasks/System.Resources.Extensions.pkgdef
+++ b/src/Tasks/System.Resources.Extensions.pkgdef
@@ -3,5 +3,5 @@
 "codeBase"="$BaseInstallDir$\MSBuild\Current\Bin\System.Resources.Extensions.dll"
 "publicKeyToken"="cc7b13ffcd2ddd51"
 "culture"="neutral"
-"oldVersion"="0.0.0.0-99.9.9.9"
-"newVersion"="8.0.0.0"
+"oldVersion"="0.0.0.0-9.0.0.0"
+"newVersion"="9.0.0.0"
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index f85dc93eb7e..cbb66f13907 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -70,7 +70,7 @@ internal sealed class SystemState : StateFileBase, ITranslatable
         /// <summary>
         /// Additional level of caching kept at the process level.
         /// </summary>
-        private static ConcurrentDictionary<string, FileState> s_processWideFileStateCache = new ConcurrentDictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
+        private static readonly ConcurrentDictionary<string, FileState> s_processWideFileStateCache = new ConcurrentDictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// XML tables of installed assemblies.
diff --git a/src/Tasks/TaskRequiresFramework.cs b/src/Tasks/TaskRequiresFramework.cs
index e681eb903b5..cbc3caf0b2f 100644
--- a/src/Tasks/TaskRequiresFramework.cs
+++ b/src/Tasks/TaskRequiresFramework.cs
@@ -1,8 +1,9 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-
+#if NETFRAMEWORK
 using System;
+#endif
 
 namespace Microsoft.Build.Tasks
 {
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index 690308135f0..01026579232 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -327,7 +327,7 @@ private void ParsePattern(string pattern, out string[] patterns)
                     // Supporting property references would require access to Expander which is unavailable in Microsoft.Build.Tasks
                     Log.LogErrorWithCodeFromResources("Unzip.ErrorParsingPatternPropertyReferences", pattern);
                 }
-                else if (pattern.IndexOfAny(FileUtilities.InvalidPathChars) != -1)
+                else if (pattern.AsSpan().IndexOfAny(FileUtilities.InvalidPathChars) >= 0)
                 {
                     Log.LogErrorWithCodeFromResources("Unzip.ErrorParsingPatternInvalidPath", pattern);
                 }
diff --git a/src/Tasks/Warning.cs b/src/Tasks/Warning.cs
index 2f46b591c2a..b1db0edd418 100644
--- a/src/Tasks/Warning.cs
+++ b/src/Tasks/Warning.cs
@@ -3,7 +3,9 @@
 
 #nullable disable
 
+#if NET
 using System.Diagnostics.CodeAnalysis;
+#endif
 
 namespace Microsoft.Build.Tasks
 {
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index ecfe9bad0d6..9e08cea56bc 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -210,7 +210,13 @@ private string GenerateCode(out string extension)
 
                         if (name.StartsWith("_Parameter", StringComparison.OrdinalIgnoreCase))
                         {
-                            if (!Int32.TryParse(name.Substring("_Parameter".Length), out int index))
+                            if (!Int32.TryParse(
+#if NET
+                                name.AsSpan("_Parameter".Length),
+#else
+                                name.Substring("_Parameter".Length),
+#endif
+                                out int index))
                             {
                                 Log.LogErrorWithCodeFromResources("General.InvalidValue", name, "WriteCodeFragment");
                                 return null;
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index 1ef6c1ec726..f2fbe04a6b2 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -413,22 +413,21 @@ private static void EmitStringArraySwitch(CommandLineBuilder clb, CommandLineToo
         /// </summary>
         private static bool PerformSwitchValueSubstition(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch, string switchValue)
         {
-            Regex regex = new Regex(@"\[value]", RegexOptions.IgnoreCase);
-            Match match = regex.Match(commandLineToolSwitch.SwitchValue);
-            if (match.Success)
+            const string Value = "[value]";
+            int valuePos = commandLineToolSwitch.SwitchValue.IndexOf(Value, StringComparison.OrdinalIgnoreCase);
+            if (valuePos >= 0)
             {
-                string prefixToAppend = commandLineToolSwitch.SwitchValue.Substring(match.Index + match.Length, commandLineToolSwitch.SwitchValue.Length - (match.Index + match.Length));
-                string valueToAppend;
-                if (!switchValue.EndsWith("\\\\", StringComparison.OrdinalIgnoreCase) && switchValue.EndsWith("\\", StringComparison.OrdinalIgnoreCase) && prefixToAppend.Length > 0 && prefixToAppend[0] == '\"')
-                {
-                    // If the combined string would create \" then we need to escape it
-                    // if the combined string would create \\" then we ignore it as as assume it is already escaped.
-                    valueToAppend = commandLineToolSwitch.SwitchValue.Substring(0, match.Index) + switchValue + "\\" + prefixToAppend;
-                }
-                else
-                {
-                    valueToAppend = commandLineToolSwitch.SwitchValue.Substring(0, match.Index) + switchValue + prefixToAppend;
-                }
+                string prefixToAppend = commandLineToolSwitch.SwitchValue.Substring(valuePos + Value.Length);
+
+                // If the combined string would create \" then we need to escape it
+                // if the combined string would create \\" then we ignore it as as assume it is already escaped.
+                bool needsEscaping =
+                    !switchValue.EndsWith("\\\\", StringComparison.OrdinalIgnoreCase) &&
+                    switchValue.EndsWith("\\", StringComparison.OrdinalIgnoreCase) &&
+                    prefixToAppend.Length > 0 &&
+                    prefixToAppend[0] == '\"';
+
+                string valueToAppend = $"{commandLineToolSwitch.SwitchValue.Substring(0, valuePos)}{switchValue}{(needsEscaping ? "\\" : "")}{prefixToAppend}";
 
                 clb.AppendSwitch(valueToAppend);
                 return true;
@@ -645,8 +644,7 @@ private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
             // Match all instances of [asdf], where "asdf" can be any combination of any
             // characters *except* a [ or an ]. i.e., if "[ [ sdf ]" is passed, then we will
             // match "[ sdf ]"
-            string matchString = @"\[[^\[\]]+\]";
-            Regex regex = new Regex(matchString, RegexOptions.ECMAScript);
+            Regex regex = new Regex(@"\[[^\[\]]+\]", RegexOptions.ECMAScript);
             MatchCollection matches = regex.Matches(CommandLineTemplate);
 
             int indexOfEndOfLastSubstitution = 0;
@@ -735,7 +733,7 @@ private void GenerateTemplatedCommandLine(CommandLineBuilder builder)
                 indexOfEndOfLastSubstitution = match.Index + match.Length;
             }
 
-            builder.AppendTextUnquoted(CommandLineTemplate.Substring(indexOfEndOfLastSubstitution, CommandLineTemplate.Length - indexOfEndOfLastSubstitution));
+            builder.AppendTextUnquoted(CommandLineTemplate.Substring(indexOfEndOfLastSubstitution));
         }
     }
 }
diff --git a/src/Tasks/XamlTaskFactory/RelationsParser.cs b/src/Tasks/XamlTaskFactory/RelationsParser.cs
index 6a119d563f2..415c3174a9f 100644
--- a/src/Tasks/XamlTaskFactory/RelationsParser.cs
+++ b/src/Tasks/XamlTaskFactory/RelationsParser.cs
@@ -6,8 +6,6 @@
 using System.IO;
 using System.Xml;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-using Microsoft.IO;
 using File = System.IO.File;
 
 #nullable disable
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index e74251b8bba..18e0ce17d1d 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -71,7 +71,7 @@ public Type TaskType
             {
                 if (_taskType == null)
                 {
-                    _taskType = _taskAssembly.GetType(String.Concat(XamlTaskNamespace, ".", TaskName), true);
+                    _taskType = _taskAssembly.GetType($"{XamlTaskNamespace}.{TaskName}", true);
                 }
 
                 return _taskType;
@@ -195,7 +195,7 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
         /// <param name="taskFactoryLoggingHost">The task factory logging host will log messages in the context of the task.</param>
         public ITask CreateTask(IBuildEngine taskFactoryLoggingHost)
         {
-            string fullTaskName = String.Concat(TaskNamespace, ".", TaskName);
+            string fullTaskName = $"{TaskNamespace}.{TaskName}";
             return (ITask)_taskAssembly.CreateInstance(fullTaskName);
         }
 
diff --git a/src/UnitTests.Shared/DriveMapping.cs b/src/UnitTests.Shared/DriveMapping.cs
index 81324086548..c9034b6902a 100644
--- a/src/UnitTests.Shared/DriveMapping.cs
+++ b/src/UnitTests.Shared/DriveMapping.cs
@@ -2,10 +2,8 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 #nullable enable
-using System;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-using System.Text;
 
 namespace Microsoft.Build.UnitTests.Shared;
 
diff --git a/src/UnitTests.Shared/DummyMappedDrive.cs b/src/UnitTests.Shared/DummyMappedDrive.cs
index ec7df37a00d..064ec22d4b6 100644
--- a/src/UnitTests.Shared/DummyMappedDrive.cs
+++ b/src/UnitTests.Shared/DummyMappedDrive.cs
@@ -5,7 +5,6 @@
 using System;
 using System.Diagnostics;
 using System.IO;
-using System.Runtime.Versioning;
 
 namespace Microsoft.Build.UnitTests.Shared;
 
diff --git a/src/UnitTests.Shared/DummyMappedDriveUtils.cs b/src/UnitTests.Shared/DummyMappedDriveUtils.cs
index 90f596858d3..5e8412c956d 100644
--- a/src/UnitTests.Shared/DummyMappedDriveUtils.cs
+++ b/src/UnitTests.Shared/DummyMappedDriveUtils.cs
@@ -4,7 +4,6 @@
 #nullable enable
 using System;
 using Microsoft.Build.Framework;
-using Microsoft.Build.UnitTests.Shared;
 
 namespace Microsoft.Build.UnitTests.Shared;
 
diff --git a/src/UnitTests.Shared/ObjectModelHelpers.cs b/src/UnitTests.Shared/ObjectModelHelpers.cs
index 375c84d6779..a075aaad7e4 100644
--- a/src/UnitTests.Shared/ObjectModelHelpers.cs
+++ b/src/UnitTests.Shared/ObjectModelHelpers.cs
@@ -23,11 +23,9 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
-using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 
 #nullable disable
 
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index e0879c00028..038c1fc2b9b 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -3,12 +3,11 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.Shared;
 using System.IO;
 using System.Reflection;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Xunit.Abstractions;
-using System.Linq;
 
 #nullable disable
 
diff --git a/src/Utilities.UnitTests/EncodingUtilities_Tests.cs b/src/Utilities.UnitTests/EncodingUtilities_Tests.cs
index a56ee25c4db..591ba25fd9c 100644
--- a/src/Utilities.UnitTests/EncodingUtilities_Tests.cs
+++ b/src/Utilities.UnitTests/EncodingUtilities_Tests.cs
@@ -1,11 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using System;
 using System.Globalization;
-using System.Runtime.InteropServices;
-using System.Threading;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Shouldly;
 using Xunit;
diff --git a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
index e29bd389537..cdc831de205 100644
--- a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
+++ b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
@@ -9,8 +9,9 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <Reference Include="System.Net.Http" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
+
     <PackageReference Include="Shouldly" />
-    <PackageReference Include="System.Net.Http" />
     <PackageReference Include="Microsoft.CodeAnalysis.Build.Tasks" />
 
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
diff --git a/src/Utilities.UnitTests/MuxLogger_Tests.cs b/src/Utilities.UnitTests/MuxLogger_Tests.cs
index db440177756..b4228b11909 100644
--- a/src/Utilities.UnitTests/MuxLogger_Tests.cs
+++ b/src/Utilities.UnitTests/MuxLogger_Tests.cs
@@ -2,9 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.IO;
 using System.Threading;
-using System.Xml;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
diff --git a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
index ff9c8243fea..d4d52e05d0f 100644
--- a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
+++ b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
@@ -2,7 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index 04a54e3e511..a7db155e2ce 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -11,7 +11,6 @@
 using Microsoft.Build.Utilities;
 using Shouldly;
 using Xunit;
-using Xunit.NetCore.Extensions;
 
 #pragma warning disable 0219
 
diff --git a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
index 9a3a96ef330..04e54d27c00 100644
--- a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
+++ b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.IO;
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index a34a45ea3ec..a06401e8191 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -23,7 +23,6 @@
 using SharedDotNetFrameworkArchitecture = Microsoft.Build.Shared.DotNetFrameworkArchitecture;
 using Xunit;
 using Xunit.Abstractions;
-using Xunit.NetCore.Extensions;
 
 #nullable disable
 
@@ -2142,7 +2141,7 @@ public void GetPathToStandardLibraries64Bit35()
             string frameworkDirectory2064bit = FrameworkLocationHelper.GetPathToDotNetFrameworkV20(SharedDotNetFrameworkArchitecture.Bitness64);
             string frameworkDirectory20Current = FrameworkLocationHelper.GetPathToDotNetFrameworkV20(SharedDotNetFrameworkArchitecture.Current);
 
-            if (!EnvironmentUtilities.Is64BitOperatingSystem)
+            if (!Environment.Is64BitOperatingSystem)
             {
                 // "Not 64 bit OS "
                 return;
@@ -2163,7 +2162,7 @@ public void GetPathToStandardLibraries64Bit35()
             pathToFramework = ToolLocationHelper.GetPathToStandardLibraries(".NetFramework", "v3.5", string.Empty, "itanium");
             pathToFramework.ShouldBe(frameworkDirectory2064bit, StringCompareShould.IgnoreCase);
 
-            if (!EnvironmentUtilities.Is64BitProcess)
+            if (!Environment.Is64BitProcess)
             {
                 pathToFramework = ToolLocationHelper.GetPathToStandardLibraries(".NetFramework", "v3.5", string.Empty, "RandomPlatform");
                 pathToFramework.ShouldBe(frameworkDirectory2032bit, StringCompareShould.IgnoreCase);
@@ -2188,7 +2187,7 @@ public void GetPathToStandardLibraries64Bit40()
         {
             IList<string> referencePaths = ToolLocationHelper.GetPathToReferenceAssemblies(new FrameworkNameVersioning(".NETFramework", new Version("4.0")));
 
-            if (!EnvironmentUtilities.Is64BitOperatingSystem)
+            if (!Environment.Is64BitOperatingSystem)
             {
                 // "Not 64 bit OS "
                 return;
@@ -2233,7 +2232,7 @@ public void GetPathToStandardLibraries32Bit35()
             string frameworkDirectory2032bit = FrameworkLocationHelper.GetPathToDotNetFrameworkV20(SharedDotNetFrameworkArchitecture.Bitness32);
             string frameworkDirectory20Current = FrameworkLocationHelper.GetPathToDotNetFrameworkV20(SharedDotNetFrameworkArchitecture.Current);
 
-            if (EnvironmentUtilities.Is64BitOperatingSystem)
+            if (Environment.Is64BitOperatingSystem)
             {
                 // "Is a 64 bit OS "
                 return;
@@ -2271,7 +2270,7 @@ public void GetPathToStandardLibraries32Bit40()
         {
             IList<string> referencePaths = ToolLocationHelper.GetPathToReferenceAssemblies(new FrameworkNameVersioning(".NETFramework", new Version("4.0")));
 
-            if (EnvironmentUtilities.Is64BitOperatingSystem)
+            if (Environment.Is64BitOperatingSystem)
             {
                 // "Is 64 bit OS "
                 return;
diff --git a/src/Utilities/CommandLineBuilder.cs b/src/Utilities/CommandLineBuilder.cs
index c41b18d74c0..07ac12544e9 100644
--- a/src/Utilities/CommandLineBuilder.cs
+++ b/src/Utilities/CommandLineBuilder.cs
@@ -154,14 +154,14 @@ public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparat
         /// <summary>
         /// Use a private property so that we can lazy initialize the regex
         /// </summary>
-        private Regex DefinitelyNeedQuotes => _definitelyNeedQuotes
-            ?? (_definitelyNeedQuotes = new Regex(_quoteHyphens ? s_definitelyNeedQuotesRegexWithHyphen : s_definitelyNeedQuotesRegexNoHyphen, RegexOptions.CultureInvariant));
+        private Regex DefinitelyNeedQuotes => _definitelyNeedQuotes ??=
+            new Regex(_quoteHyphens ? s_definitelyNeedQuotesRegexWithHyphen : s_definitelyNeedQuotesRegexNoHyphen, RegexOptions.CultureInvariant);
 
         /// <summary>
         /// Use a private getter property to we can lazy initialize the regex
         /// </summary>
-        private Regex AllowedUnquoted => _allowedUnquoted
-            ?? (_allowedUnquoted = new Regex(_quoteHyphens ? s_allowedUnquotedRegexNoHyphen : s_allowedUnquotedRegexWithHyphen, RegexOptions.IgnoreCase | RegexOptions.CultureInvariant));
+        private Regex AllowedUnquoted => _allowedUnquoted ??=
+            new Regex(_quoteHyphens ? s_allowedUnquotedRegexNoHyphen : s_allowedUnquotedRegexWithHyphen, RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);
 
         /// <summary>
         /// Checks the given switch parameter to see if it must/can be quoted.
@@ -259,6 +259,9 @@ protected void AppendQuotedTextToBuffer(StringBuilder buffer, string unquotedTex
                 }
 
                 // Count the number of quotes
+#if NET
+                int literalQuotes = unquotedTextToAppend.AsSpan().Count('"');
+#else
                 int literalQuotes = 0;
                 for (int i = 0; i < unquotedTextToAppend.Length; i++)
                 {
@@ -267,6 +270,8 @@ protected void AppendQuotedTextToBuffer(StringBuilder buffer, string unquotedTex
                         literalQuotes++;
                     }
                 }
+#endif
+
                 if (literalQuotes > 0)
                 {
                     // Replace any \" sequences with \\"
diff --git a/src/Utilities/CompatibilitySuppressions.xml b/src/Utilities/CompatibilitySuppressions.xml
index eeee8bb3f8a..d61bb3c6b1f 100644
--- a/src/Utilities/CompatibilitySuppressions.xml
+++ b/src/Utilities/CompatibilitySuppressions.xml
@@ -1,11 +1,6 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
-       This is intentional, because you can only use MSBuild in the context of a .NET SDK
-       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
-       have previously shipped netstandard2.0 packages, and if you want to support both
-       runtime contexts it still makes sense to target that. -->
   <Suppression>
     <DiagnosticId>PKV004</DiagnosticId>
     <Target>.NETCoreApp,Version=v2.0</Target>
diff --git a/src/Utilities/LockCheck.cs b/src/Utilities/LockCheck.cs
index 7b191851e70..187d3d59f8e 100644
--- a/src/Utilities/LockCheck.cs
+++ b/src/Utilities/LockCheck.cs
@@ -7,7 +7,6 @@
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -241,7 +240,7 @@ public override bool Equals(object obj)
 
             public override string ToString()
             {
-                return ProcessId + "@" + StartTime.ToString("s");
+                return $"{ProcessId}@{StartTime:s}";
             }
         }
 
diff --git a/src/Utilities/SDKManifest.cs b/src/Utilities/SDKManifest.cs
index 86e0be400ce..d8c06a2c234 100644
--- a/src/Utilities/SDKManifest.cs
+++ b/src/Utilities/SDKManifest.cs
@@ -45,22 +45,22 @@ public class SDKManifest
         /// <summary>
         /// Pattern in path to extension SDK used to help determine if manifest is from a framework SDK
         /// </summary>
-        private static string s_extensionSDKPathPattern = @"\MICROSOFT SDKS\WINDOWS\V8.0\EXTENSIONSDKS";
+        private const string s_extensionSDKPathPattern = @"\MICROSOFT SDKS\WINDOWS\V8.0\EXTENSIONSDKS";
 
         /// <summary>
         /// Default version of MaxPlatformVersion in framework extension SDKs with manifest not containing such a property
         /// </summary>
-        private static string s_defaultMaxPlatformVersion = "8.0";
+        private const string s_defaultMaxPlatformVersion = "8.0";
 
         /// <summary>
         /// Default version of MinOSVersion in framework extension SDKs with manifest not containing such a property
         /// </summary>
-        private static string s_defaultMinOSVersion = "6.2.1";
+        private const string s_defaultMinOSVersion = "6.2.1";
 
         /// <summary>
         /// Default version of MaxOSVersionTested in framework extension SDKs with manifest not containing such a property
         /// </summary>
-        private static string s_defaultMaxOSVersionTested = "6.2.1";
+        private const string s_defaultMaxOSVersionTested = "6.2.1";
 
         /// <summary>
         /// What should happen if this sdk is resolved with other sdks of the same productfamily or same sdk name.
diff --git a/src/Utilities/TargetPlatformSDK.cs b/src/Utilities/TargetPlatformSDK.cs
index 8740fe39e10..64ef39b0ed5 100644
--- a/src/Utilities/TargetPlatformSDK.cs
+++ b/src/Utilities/TargetPlatformSDK.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -189,6 +188,6 @@ public bool ContainsPlatform(string targetPlatformIdentifier, string targetPlatf
         /// <summary>
         /// Given an identifier and version, construct a string to use as a key for that combination.
         /// </summary>
-        internal static string GetSdkKey(string sdkIdentifier, string sdkVersion) => string.Format(CultureInfo.InvariantCulture, "{0}, Version={1}", sdkIdentifier, sdkVersion);
+        internal static string GetSdkKey(string sdkIdentifier, string sdkVersion) => $"{sdkIdentifier}, Version={sdkVersion}";
     }
 }
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 3f13658e0dd..25ae27e63d0 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -9,7 +9,6 @@
 using System.Runtime.Versioning;
 using System.Text;
 using System.Xml;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyFoldersFromConfig;
@@ -1821,7 +1820,7 @@ public static string GetPathToStandardLibraries(string targetFrameworkIdentifier
                 if (NativeMethodsShared.IsWindows && platformTarget != null)
                 {
                     // If we are a 32 bit operating system the we should always return the 32 bit directory, or we are targeting x86, arm is also 32 bit
-                    if (!EnvironmentUtilities.Is64BitOperatingSystem || platformTarget.Equals("x86", StringComparison.OrdinalIgnoreCase) || platformTarget.Equals("arm", StringComparison.OrdinalIgnoreCase))
+                    if (!Environment.Is64BitOperatingSystem || platformTarget.Equals("x86", StringComparison.OrdinalIgnoreCase) || platformTarget.Equals("arm", StringComparison.OrdinalIgnoreCase))
                     {
                         targetedArchitecture = SharedDotNetFrameworkArchitecture.Bitness32;
                     }
@@ -2863,7 +2862,7 @@ private static void GatherSDKListFromRegistry(string registryRoot, Dictionary<Ta
             OpenBaseKey openBaseKey = new OpenBaseKey(RegistryHelper.OpenBaseKey);
             FileExists fileExists = new FileExists(File.Exists);
 
-            bool is64bitOS = EnvironmentUtilities.Is64BitOperatingSystem;
+            bool is64bitOS = Environment.Is64BitOperatingSystem;
 
             // Under WOW64 the HKEY_CURRENT_USER\SOFTWARE key is shared. This means the values are the same in the 64 bit and 32 bit views. This means we only need to get one view of this key.
             GatherSDKsFromRegistryImpl(platformMonikers, registryRoot, RegistryView.Default, RegistryHive.CurrentUser, getSubkeyNames, getRegistrySubKeyDefaultValue, openBaseKey, fileExists);
@@ -3738,9 +3737,13 @@ private static SharedDotNetFrameworkArchitecture ConvertToSharedDotNetFrameworkA
         private static Version ConvertTargetFrameworkVersionToVersion(string targetFrameworkVersion)
         {
             // Trim off the v if is is there.
-            if (!string.IsNullOrEmpty(targetFrameworkVersion) && targetFrameworkVersion.Substring(0, 1).Equals("v", StringComparison.OrdinalIgnoreCase))
+            if (!string.IsNullOrEmpty(targetFrameworkVersion) && targetFrameworkVersion[0] is 'v' or 'V')
             {
-                targetFrameworkVersion = targetFrameworkVersion.Substring(1);
+#if NET
+                return Version.Parse(targetFrameworkVersion.AsSpan(1));
+#else
+                return new Version(targetFrameworkVersion.Substring(1));
+#endif
             }
 
             return new Version(targetFrameworkVersion);
@@ -3859,8 +3862,13 @@ private static IList<string> GetFrameworkVersions(string frameworkReferenceRoot,
                     // only add if the version folder name is of the right format
                     if (folder.Name.Length >= 4 && folder.Name.StartsWith("v", StringComparison.OrdinalIgnoreCase))
                     {
-                        Version ver;
-                        if (Version.TryParse(folder.Name.Substring(1), out ver))
+                        if (Version.TryParse(
+#if NET
+                            folder.Name.AsSpan(1),
+#else
+                            folder.Name.Substring(1),
+#endif
+                            out _))
                         {
                             frameworkVersions.Add(folder.Name);
                         }
@@ -3982,10 +3990,14 @@ private VersionComparer()
 
             public int Compare(string versionX, string versionY)
             {
+#if NET
+                return Version.Parse(versionX.AsSpan(1)).CompareTo(Version.Parse(versionY.AsSpan(1)));
+#else
                 return new Version(versionX.Substring(1)).CompareTo(new Version(versionY.Substring(1)));
+#endif
             }
         }
 
-        #endregion
+#endregion
     }
 }
diff --git a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
index c3b83f0c8e8..5753a79bada 100644
--- a/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
+++ b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
@@ -27,7 +27,7 @@
       "type": "parameter",
       "description": "Overrides the default Microsoft.Build version where check's interfaces are placed",
       "datatype": "text",
-      "defaultValue": "17.13.0",
+      "defaultValue": "17.15.0",
       "replaces": "1.0.0-MicrosoftBuildPackageVersion",
       "displayName": "Microsoft.Build default package version override"
     }
