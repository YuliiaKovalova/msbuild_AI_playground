diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 53e990b4bfd..c39946e0c80 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -11,6 +11,7 @@
 using Microsoft.Build.Engine.UnitTests.Globbing;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Shouldly;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
@@ -32,6 +33,7 @@ public class ProjectItem_Tests : IDisposable
                         </ItemGroup>
                     </Project>
                 ";
+
         internal const string ItemWithIncludeUpdateAndRemove = @"
                     <Project>
                         <ItemGroup>
@@ -46,6 +48,12 @@ public class ProjectItem_Tests : IDisposable
                     </Project>
                 ";
 
+        internal const string ImportProjectElement = @"
+                    <Project>
+                        <Import Project='{0}'/>
+                    </Project>
+                ";
+
         protected TestEnvironment _env;
 
         public ProjectItem_Tests()
@@ -757,101 +765,216 @@ public void IncludeWithWildcardShouldNotPreserveUserSlashesInFixedDirectoryPart(
         }
 
         /// <summary>
-        /// Project getter that renames an item to a wildcard that results in drive enumeration exception.
+        /// Project getter that renames an item to a drive enumerating wildcard that results in an exception.
         /// </summary>
-        [Fact]
-        public void ProjectGetterResultingInDriveEnumerationException()
+        [Theory]
+        [InlineData(@"\**\*.log")]
+        [InlineData(@"$(empty)\**\*.log")]
+        [InlineData(@"\$(empty)**\*.log")]
+        [InlineData(@"\*$(empty)*\*.log")]
+        public void ProjectGetterResultsInDriveEnumerationException(string unevaluatedInclude)
         {
             using (var env = TestEnvironment.Create())
             {
-                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
-                Project project = new Project();
-                Assert.Throws<InvalidProjectFileException>(() => { ProjectItem item = project.AddItem("i", "\\**\\*.log")[0]; });
+                try
+                {
+                    // Setup
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "1");
+                    Project project = new Project();
+
+                    // Add item and verify
+                    Should.Throw<InvalidProjectFileException>(() => { _ = project.AddItem("i", unevaluatedInclude); });
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
             }
         }
 
         /// <summary>
-        /// Project getter that renames an item to a wildcard that results in logging a warning for attempted drive enumeration.
+        /// Project getter that renames an item to a drive enumerating wildcard that results in a logged warning.
         /// </summary>
-        [Fact]
-        public void ProjectGetterResultingInDriveEnumerationWarning()
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"z:\**\*.log")]
+        [InlineData(@"z:$(empty)\**\*.log")]
+        [InlineData(@"z:\**")]
+        [InlineData(@"z:\\**")]
+        [InlineData(@"z:\\\\\\\\**")]
+        [InlineData(@"z:\**\*.cs")]
+        public void ProjectGetterResultsInWindowsDriveEnumerationWarning(string unevaluatedInclude)
+        {
+            ProjectGetterResultsInDriveEnumerationWarning(unevaluatedInclude);
+        }
+
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"/**/*.log")]
+        [InlineData(@"$(empty)/**/*.log")]
+        [InlineData(@"/$(empty)**/*.log")]
+        [InlineData(@"/*$(empty)*/*.log")]
+        public void ProjectGetterResultsInUnixDriveEnumerationWarning(string unevaluatedInclude)
+        {
+            ProjectGetterResultsInDriveEnumerationWarning(unevaluatedInclude);
+        }
+
+        private static void ProjectGetterResultsInDriveEnumerationWarning(string unevaluatedInclude)
         {
             using (var env = TestEnvironment.Create())
             {
-                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "0");
-                Project project = new Project();
-                ProjectItem item = project.AddItem("i", "\\**\\*.log")[0];
+                try
+                {
+                    // Reset state
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "0");
+
+                    // Setup
+                    ProjectCollection projectCollection = new ProjectCollection();
+                    MockLogger collectionLogger = new MockLogger();
+                    projectCollection.RegisterLogger(collectionLogger);
+                    Project project = new Project(projectCollection);
+
+                    // Add item
+                    _= project.AddItem("i", unevaluatedInclude);
+
+                    // Verify
+                    collectionLogger.WarningCount.ShouldBe(1);
+                    collectionLogger.AssertLogContains("MSB5029");
+                    projectCollection.UnregisterAllLoggers();
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
             }
         }
 
         /// <summary>
-        /// Throws exception when an included wildcard evaluates to a drive enumeration.
+        /// Project instance created from a file that contains a drive enumerating wildcard results in a thrown exception.
         /// </summary>
-        [Fact]
-        public void PropertyEvaluationResultingInDriveEnumeration()
-        {
-            using (var env = TestEnvironment.Create())
-            {
-                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
-                string content =
-                @"<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                    <ItemGroup>
-                        <FilesToCopy Include=""$(Microsoft_WindowsAzure_EngSys)\**\*"" Exclude=""$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*"" />
-                    </ItemGroup>
-                  </Project>
-                ";
+        [Theory]
+        [InlineData(
+            ImportProjectElement,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            null)]
 
-                var testFile = env.CreateFile(env.CreateFolder(), "a.csproj", content);
-                Should.Throw<InvalidProjectFileException>(() => { ProjectInstance.FromFile(testFile.Path, new ProjectOptions()); });
-            }
+        // LazyItem.IncludeOperation
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        // LazyItem.IncludeOperation for Exclude
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(EmptyProperty)\*.cs",
+            @"$(Microsoft_WindowsAzure_EngSys)\**")]
+        public void ThrowExceptionUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
+        {
+            content = string.Format(content, placeHolder, excludePlaceHolder);
+            CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, true);
         }
 
         /// <summary>
-        /// Throws exception when an imported wildcard evaluates to a drive enumeration.
+        /// Project instance created from a file that contains a drive enumerating wildcard results in a logged warning on the Windows platform.
         /// </summary>
-        [Fact]
-        public void ImportEvaluationResultingInDriveEnumeration()
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            ImportProjectElement,
+            @"z:\**\*.targets",
+            null)]
+
+        // LazyItem.IncludeOperation
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        // LazyItem.IncludeOperation for Exclude
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(EmptyProperty)\*.cs",
+            @"z:\$(Microsoft_WindowsAzure_EngSys)**")]
+        public void LogWindowsWarningUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
         {
-            using (var env = TestEnvironment.Create())
-            {
-                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
-                string content =
-                @"<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                    <Import Project=""$(Microsoft_WindowsAzure_EngSys)\**\*"" />
-                  </Project>
-                ";
+            content = string.Format(content, placeHolder, excludePlaceHolder);
+            CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, false);
+        }
 
-                var testFile = env.CreateFile(env.CreateFolder(), "a.csproj", content);
-                Should.Throw<InvalidProjectFileException>(() => { ProjectInstance.FromFile(testFile.Path, new ProjectOptions()); });
-            }
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(
+            ImportProjectElement,
+            @"\**\*.targets",
+            null)]
+
+        // LazyItem.IncludeOperation
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        // LazyItem.IncludeOperation for Exclude
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(EmptyProperty)\*.cs",
+            @"$(Microsoft_WindowsAzure_EngSys)\**")]
+        public void LogWarningUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
+        {
+            content = string.Format(content, placeHolder, excludePlaceHolder);
+                CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, false);
         }
 
-        /// <summary>
-        /// Logs warning when an imported wildcard evaluates to a drive enumeration.
-        /// </summary>
-        [Fact]
-        public void ImportEvaluationResultingInLogDriveEnumeration()
+        private static void CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(string content, bool throwException)
         {
             using (var env = TestEnvironment.Create())
             {
-                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "0");
-                string content =
-                @"<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                    <Import Project=""$(Microsoft_WindowsAzure_EngSys)\**\*"" />
-                  </Project>
-                ";
-
-                var testFile = env.CreateFile(env.CreateFolder(), "a.csproj", content);
-                ProjectOptions options = new ProjectOptions();
-                options.ProjectCollection = new ProjectCollection();
+                // Clean file contents by replacing single quotes with double quotes, etc.
+                content = ObjectModelHelpers.CleanupFileContents(content);
+                var testProject = env.CreateTestProjectWithFiles(content.Cleanup());
 
-                MockLogger collectionLogger = new MockLogger();
-                options.ProjectCollection.RegisterLogger(collectionLogger);
+                // Setup and create project instance from file
+                CreateProjectInstanceFromFileWithDriveEnumeratingWildcard(env, testProject.ProjectFile, throwException);
+            }
+        }
 
-                ProjectInstance.FromFile(testFile.Path, options); // Issue: Unauthorized access exception
+        private static void CreateProjectInstanceFromFileWithDriveEnumeratingWildcard(TestEnvironment env, string testProjectFile, bool throwException)
+        {
+            try
+            {
+                // Reset state 
+                Helpers.ResetStateForDriveEnumeratingWildcardTests(env, throwException ? "1" : "0");
 
-                Assert.Equal(1, collectionLogger.WarningCount);
-                options.ProjectCollection.UnregisterAllLoggers();
+                if (throwException)
+                {
+                    // Verify
+                    Should.Throw<InvalidProjectFileException>(() => { ProjectInstance.FromFile(testProjectFile, new ProjectOptions()); });
+                }
+                else
+                {
+                    // Setup
+                    MockLogger collectionLogger = new MockLogger();
+                    ProjectOptions options = new ProjectOptions();
+                    options.ProjectCollection = new ProjectCollection();
+                    options.ProjectCollection.RegisterLogger(collectionLogger);
+
+                    // Action
+                    ProjectInstance.FromFile(testProjectFile, options);
+
+                    // Verify
+                    collectionLogger.WarningCount.ShouldBe(1);
+                    collectionLogger.AssertLogContains("MSB5029");
+                    options.ProjectCollection.UnregisterAllLoggers();
+                }
+            }
+            finally
+            {
+                ChangeWaves.ResetStateForTests();
             }
         }
 
@@ -1009,7 +1132,7 @@ public void IncludeAndExcludeWorkWithRelativeAndAbsolutePaths(
         [InlineData(
             "../a.cs;b.cs", // include string
             "**/*.cs", // exclude string
-            new[] { "a.cs", "ProjectDir/b.cs" }, // files to create relative to the test root dir
+            new[] {"a.cs", "ProjectDir/b.cs"}, // files to create relative to the test root dir
             "ProjectDir", // relative path from test root to project
             new[] { "../a.cs" } // expected items
             )]
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index 272ad1343da..c3316bb2267 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -15,8 +15,8 @@
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
-using System.Linq;
 using Shouldly;
+using System.Linq;
 
 #nullable disable
 
@@ -32,6 +32,39 @@ public class ProjectItemInstance_Tests
         /// </summary>
         public const int BuiltInMetadataCount = 15;
 
+        internal const string TargetItemWithInclude = @"
+            <Project>
+                <Target Name='TestTarget'>
+                    <ItemGroup>
+                        <i Include='{0}'/>
+                    </ItemGroup>
+                </Target>
+            </Project>
+            ";
+
+        internal const string TargetItemWithIncludeAndExclude = @"
+            <Project>
+                <Target Name='TestTarget'>
+                    <ItemGroup>
+                        <i Include='{0}' Exclude='{1}'/>
+                    </ItemGroup>
+                </Target>
+            </Project>
+            ";
+
+        internal const string TargetWithDefinedPropertyAndItemWithInclude = @"
+            <Project>
+                <PropertyGroup>
+                    <{0}>{1}</{0}>
+                </PropertyGroup>
+                <Target Name='TestTarget'>
+                    <ItemGroup>
+                        <i Include='{2}' />
+                    </ItemGroup>
+                </Target>
+            </Project>
+            ";
+
         /// <summary>
         /// Basic ProjectItemInstance without metadata
         /// </summary>
@@ -840,34 +873,159 @@ public void MetadataConditionReferringToMetadataOnSameItem()
         }
 
         /// <summary>
-        /// Tests item inclusion of drive enumeration wildcard within a target.
+        /// Fail build for drive enumerating wildcards that exist in projects on any platform.
         /// </summary>
-        [Fact]
-        public void TargetItemEvaluationResultingInDriveEnumeration()
+        [Theory]
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb",
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*")]
+
+        [InlineData(
+            TargetItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            "$(Microsoft_WindowsAzure_EngSys)**",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"\")]
+        public void ThrowExceptionUponBuildingProjectWithDriveEnumeration(string content, string include, string exclude = null, string property = null, string propertyValue = null)
         {
-            using (var env = TestEnvironment.Create())
-            {
-                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
-                string content =
-                @"<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                    <Target Name=""TestTarget"">
-                        <ItemGroup>
-                            <FilesToCopy Include=""$(Microsoft_WindowsAzure_EngSys)\**\*"" Exclude=""$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*"" />
-                        </ItemGroup>
-                    </Target>
-                  </Project>
-                ";
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                string.Format(content, include, exclude) :
+                string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "1",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.FailWithError);
+        }
+
+        /// <summary>
+        /// Log warning for drive enumerating wildcards that exist in projects on Windows platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb",
+            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)**",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"z:\")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"z:")]
+        public void LogWindowsWarningUponBuildingProjectWithDriveEnumeration(string content, string include, string exclude = null, string property = null, string propertyValue = null)
+        {
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                string.Format(content, include, exclude) :
+                string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "0",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.SucceedWithWarning);
+        }
 
-                var testFile = env.CreateFile(env.CreateFolder(), "a.csproj", content);
-                var p = ProjectInstance.FromFile(testFile.Path, new ProjectOptions());
+        /// <summary>
+        /// Log warning for drive enumerating wildcards that exist in projects on Unix platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)**",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"/")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)*/*.log",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"/*")]
+        public void LogUnixWarningUponBuildingProjectWithDriveEnumeration(string content, string include, string exclude = null, string property = null, string propertyValue = null)
+        {
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                    string.Format(content, include, exclude) :
+                    string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                    content,
+                    "0",
+                    "TestTarget",
+                    Helpers.ExpectedBuildResult.SucceedWithWarning);
+        }
 
-                BuildManager buildManager = BuildManager.DefaultBuildManager;
-                BuildRequestData data = new BuildRequestData(p, new[] { "TestTarget" });
-                BuildParameters parameters = new BuildParameters();
-                BuildResult buildResult = buildManager.Build(parameters, data);
-                buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
-                buildResult["TestTarget"].Exception?.Message.ShouldContain("this resulted in an attempted drive enumeration");
-            }
+        /// <summary>
+        /// Tests target item evaluation resulting in no build failures.
+        /// </summary>
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)*.cs",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"c:\*\")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"\$(Microsoft_WindowsAzure_EngSys)*\*.cs",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"c:")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @":\$(Microsoft_WindowsAzure_EngSys)*\*.log",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"c")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)*\*.log",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"\")]
+        public void NoErrorsAndWarningsUponBuildingProject(string content, string include, string exclude = null, string property = null, string propertyValue = null)
+        {
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                    string.Format(content, include, exclude) :
+                    string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "0",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.SucceedWithNoErrorsAndWarnings);
         }
 
         [Fact]
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 643cd2b3f93..505bc1d2df1 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -371,7 +371,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             ISet<string> removeMetadata
         )
         {
-            //todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
+            // todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
             ProjectErrorUtilities.VerifyThrowInvalidProject(!(keepMetadata != null && removeMetadata != null), originalItem.KeepMetadataLocation, "KeepAndRemoveMetadataMutuallyExclusive");
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
@@ -426,36 +426,28 @@ ISet<string> removeMetadata
                 }
                 else
                 {
-                    try
+                    // The expression is not of the form "@(X)". Treat as string
+
+                    // Pass the non wildcard expanded excludes here to fix https://github.com/dotnet/msbuild/issues/2621
+                    string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(
+                        Project.Directory,
+                        includeSplit,
+                        excludes,
+                        loggingMechanism: LoggingContext,
+                        includeLocation: originalItem.IncludeLocation,
+                        excludeLocation: originalItem.ExcludeLocation,
+                        disableExcludeDriveEnumerationWarning: true);
+
+                    foreach (string includeSplitFile in includeSplitFiles)
                     {
-                        // The expression is not of the form "@(X)". Treat as string
-
-                        // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621
-                        (string[] includeSplitFiles, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(
-                            Project.Directory,
-                            includeSplit,
-                            excludes);
-
-                        if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
-                        {
-                            LoggingContext.LogWarning($"Drive enumeration was detected during wildcard expansion, for the Include attribute, which relied on the file spec {includeSplit}.");
-                        }
-
-                        foreach (string includeSplitFile in includeSplitFiles)
-                        {
-                            items.Add(new ProjectItemInstance(
-                                Project,
-                                originalItem.ItemType,
-                                includeSplitFile,
-                                includeSplit /* before wildcard expansion */,
-                                null,
-                                null,
-                                originalItem.Location.File));
-                        }
-                    }
-                    catch (DriveEnumerationWildcardException ex)
-                    {
-                        ProjectErrorUtilities.ThrowInvalidProject(originalItem.IncludeLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(includeSplit), XMakeAttributes.include, XMakeElements.itemGroup, ex.Message);
+                        items.Add(new ProjectItemInstance(
+                            Project,
+                            originalItem.ItemType,
+                            includeSplitFile,
+                            includeSplit /* before wildcard expansion */,
+                            null,
+                            null,
+                            originalItem.Location.File));
                     }
                 }
             }
@@ -465,22 +457,15 @@ ISet<string> removeMetadata
 
             foreach (string excludeSplit in excludes)
             {
-                try
-                {
-                    (string[] excludeSplitFiles, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListUnescaped(Project.Directory, excludeSplit);
-                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
-                    {
-                        LoggingContext.LogWarning($"Drive enumeration was detected during wildcard expansion for Exclude attribute with the filespec {excludeSplit}.");
-                    }
+                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(
+                    Project.Directory,
+                    excludeSplit,
+                    loggingMechanism: LoggingContext,
+                    excludeLocation: originalItem.ExcludeLocation);
 
-                    foreach (string excludeSplitFile in excludeSplitFiles)
-                    {
-                        excludesUnescapedForComparison.Add(excludeSplitFile);
-                    }
-                }
-                catch (DriveEnumerationWildcardException ex)
+                foreach (string excludeSplitFile in excludeSplitFiles)
                 {
-                    ProjectErrorUtilities.ThrowInvalidProject(originalItem.ExcludeLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(excludeSplit), XMakeAttributes.exclude, XMakeElements.itemGroup, ex.Message);
+                    excludesUnescapedForComparison.Add(excludeSplitFile);
                 }
             }
 
@@ -558,28 +543,22 @@ Expander<ProjectPropertyInstance, ProjectItemInstance> expander
                 // wildcards.  Then loop through each file returned, and add it
                 // to our hashtable.
 
-                try
-                {
-                    // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them
-                    // as literals. Everything else is safe to unescape at this point, since we're only matching
-                    // against the file system.
-                    (string[] fileList, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);
-                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
-                    {
-                        LoggingContext.LogWarning($"Drive enumeration was detected during wildcard expansion, for the Exclude attribute, which relied on the file spec {piece}.");
-                    }
+                // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them
+                // as literals. Everything else is safe to unescape at this point, since we're only matching
+                // against the file system.
+                string[] fileList = EngineFileUtilities.GetFileListEscaped(
+                    Project.Directory,
+                    piece,
+                    loggingMechanism: LoggingContext,
+                    includeLocation: specificationLocation,
+                    excludeLocation: specificationLocation);
 
-                    foreach (string file in fileList)
-                    {
-                        // Now unescape everything, because this is the end of the road for this filename.
-                        // We're just going to compare it to the unescaped include path to filter out the
-                        // file excludes.
-                        specificationsToFind.Add(EscapingUtilities.UnescapeAll(file));
-                    }
-                }
-                catch (DriveEnumerationWildcardException ex)
+                foreach (string file in fileList)
                 {
-                    ProjectErrorUtilities.ThrowInvalidProject(specificationLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(piece), XMakeAttributes.exclude, XMakeElements.itemGroup, ex.Message);
+                    // Now unescape everything, because this is the end of the road for this filename.
+                    // We're just going to compare it to the unescaped include path to filter out the
+                    // file excludes.
+                    specificationsToFind.Add(EscapingUtilities.UnescapeAll(file));
                 }
             }
 
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 8839a075048..ec05dfd174f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -906,10 +906,6 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     }
                     else if (type == typeof(Exception) || type.GetTypeInfo().IsSubclassOf(typeof(Exception)))
                     {
-                        if ((Environment.GetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration") == "1") && (taskException.Message.Contains("resulted in an attempted drive enumeration")))
-                        {
-                            throw new InvalidProjectFileException("Failed to execute task object for given project instance as this resulted in an attempted drive enumeration.", taskException);
-                        }
                         // Occasionally, when debugging a very uncommon task exception, it is useful to loop the build with 
                         // a debugger attached to break on 2nd chance exceptions.
                         // That requires that there needs to be a way to not catch here, by setting an environment variable.
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index d8a59104e6f..0adf9e61756 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -3477,11 +3477,15 @@ public string ExpandItemIncludeBestEffortLeaveEscaped(ProjectItemElement renamed
 
                 var itemFactory = new ProjectItemFactory(Owner, renamedItemElement);
 
-                (List<ProjectItem> items, FileMatcher.SearchAction action, string fileSpecEscaped) = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, renamedItemElement, itemFactory, renamedItemElement.Include, _data.Expander);
-                if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
-                {
-                    LoggingService.LogWarning(s_buildEventContext, "", new BuildEventFileInfo(FullPath), "InvalidAttributeValue", EscapingUtilities.UnescapeAll(fileSpecEscaped), XMakeAttributes.include, XMakeElements.itemGroup);
-                }
+                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(
+                    DirectoryPath,
+                    renamedItemElement,
+                    itemFactory,
+                    renamedItemElement.Include,
+                    _data.Expander,
+                    LoggingService,
+                    FullPath,
+                    s_buildEventContext);
 
                 if (items.Count != 1)
                 {
@@ -3541,11 +3545,15 @@ private List<ProjectItem> AddItemHelper(ProjectItemElement itemElement, string u
             {
                 var itemFactory = new ProjectItemFactory(Owner, itemElement);
 
-                (List<ProjectItem> items, FileMatcher.SearchAction action, string fileSpecEscaped) = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, itemElement, itemFactory, unevaluatedInclude, _data.Expander);
-                if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
-                {
-                    LoggingService.LogWarning(s_buildEventContext, "", new BuildEventFileInfo(FullPath), "InvalidAttributeValue", EscapingUtilities.UnescapeAll(fileSpecEscaped), XMakeAttributes.include, XMakeElements.itemGroup);
-                }
+                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(
+                    DirectoryPath,
+                    itemElement,
+                    itemFactory,
+                    unevaluatedInclude,
+                    _data.Expander,
+                    LoggingService,
+                    FullPath,
+                    s_buildEventContext);
 
                 foreach (ProjectItem item in items)
                 {
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 0c8e78b1607..147d7cfb5ba 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -341,14 +341,12 @@ internal static void Evaluate(
         /// Helper that creates a list of ProjectItem's given an unevaluated Include and a ProjectRootElement.
         /// Used by both Evaluator.EvaluateItemElement and by Project.AddItem.
         /// </summary>
-        internal static (List<I>, FileMatcher.SearchAction, string) CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander<P, I> expander)
+        internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander<P, I> expander, ILoggingService loggingService, string buildEventFileInfoFullPath, BuildEventContext buildEventContext)
         {
             ErrorUtilities.VerifyThrowArgumentLength(unevaluatedIncludeEscaped, nameof(unevaluatedIncludeEscaped));
 
             List<I> items = new List<I>();
             itemFactory.ItemElement = itemElement;
-            FileMatcher.SearchAction action = FileMatcher.SearchAction.None;
-            string fileSpecEscaped = string.Empty;
 
             // STEP 1: Expand properties in Include
             string evaluatedIncludeEscaped = expander.ExpandIntoStringLeaveEscaped(unevaluatedIncludeEscaped, ExpanderOptions.ExpandProperties, itemElement.IncludeLocation);
@@ -375,31 +373,29 @@ internal static (List<I>, FileMatcher.SearchAction, string) CreateItemsFromInclu
                     else
                     {
                         // The expression is not of the form "@(X)". Treat as string
-                        try
+                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
+                            rootDirectory,
+                            includeSplitEscaped,
+                            excludeSpecsEscaped: null,
+                            forceEvaluate: false,
+                            fileMatcher: expander.EvaluationContext?.FileMatcher,
+                            loggingMechanism: loggingService,
+                            includeLocation: itemElement.IncludeLocation,
+                            buildEventFileInfoFullPath: buildEventFileInfoFullPath,
+                            buildEventContext: buildEventContext);
+
+                        if (includeSplitFilesEscaped.Length > 0)
                         {
-                            (string[] includeSplitFilesEscaped, action) = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);
-                            if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
+                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
                             {
-                                fileSpecEscaped = includeSplitEscaped;
+                                items.Add(itemFactory.CreateItem(includeSplitFileEscaped, includeSplitEscaped, itemElement.ContainingProject.FullPath));
                             }
-
-                            if (includeSplitFilesEscaped.Length > 0)
-                            {
-                                foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
-                                {
-                                    items.Add(itemFactory.CreateItem(includeSplitFileEscaped, includeSplitEscaped, itemElement.ContainingProject.FullPath));
-                                }
-                            }
-                        }
-                        catch (DriveEnumerationWildcardException ex)
-                        {
-                            ProjectErrorUtilities.ThrowInvalidProject(itemElement.IncludeLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(includeSplitEscaped), XMakeAttributes.include, XMakeElements.itemGroup, ex.Message);
                         }
                     }
                 }
             }
 
-            return (items, action, fileSpecEscaped);
+            return items;
         }
 
         /// <summary>
@@ -2055,15 +2051,13 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                     }
 
                     // Expand the wildcards and provide an alphabetical order list of import statements.
-                    (importFilesEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true, fileMatcher: _evaluationContext.FileMatcher);
-                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
-                    {
-                        _evaluationLoggingContext.LogWarning("InvalidAttributeValue", EscapingUtilities.UnescapeAll(importExpressionEscapedItem), XMakeAttributes.project, XMakeElements.import);
-                    }
-                }
-                catch (DriveEnumerationWildcardException ex)
-                {
-                    ProjectErrorUtilities.ThrowInvalidProject(importLocationInProject, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(importExpressionEscapedItem), XMakeAttributes.project, XMakeElements.import, ex.Message);
+                    importFilesEscaped = EngineFileUtilities.GetFileListEscaped(
+                        directoryOfImportingFile,
+                        importExpressionEscapedItem,
+                        forceEvaluate: true,
+                        fileMatcher: _evaluationContext.FileMatcher,
+                        loggingMechanism: _evaluationLoggingContext,
+                        importLocation: importLocationInProject);
                 }
                 catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
                 {
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index ec62e48c499..1bacf84bbe7 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -1976,7 +1976,7 @@ out List<Pair<string, S>> itemsFromCapture
                     Stack<TransformFunction<S>> transformFunctionStack = PrepareTransformStackFromMatch<S>(elementLocation, expressionCapture);
 
                     // iterate over the tranform chain, creating the final items from its results
-                    foreach (Pair<string, S> itemTuple in Transform<S>(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType, elementLocation)))
+                    foreach (Pair<string, S> itemTuple in Transform<S>(expander, includeNullEntries, transformFunctionStack, IntrinsicItemFunctions<S>.GetItemPairEnumerable(itemsOfType)))
                     {
                         if (!string.IsNullOrEmpty(itemTuple.Key) && (options & ExpanderOptions.BreakOnNotEmpty) != 0)
                         {
@@ -2234,34 +2234,20 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation
                 /// Create an enumerator from a base IEnumerable of items into an enumerable
                 /// of transformation result which includes the new itemspec and the base item.
                 /// </summary>
-                internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType, IElementLocation elementLocation)
+                internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType)
                 {
                     // iterate over the items, and yield out items in the tuple format
                     foreach (var item in itemsOfType)
                     {
                         if (Traits.Instance.UseLazyWildCardEvaluation)
                         {
-                            string[] fileListEscaped = null;
-                            try
+                            foreach (var resultantItem in
+                                EngineFileUtilities.GetFileListEscaped(
+                                    item.ProjectDirectory,
+                                    item.EvaluatedIncludeEscaped,
+                                    forceEvaluate: true))
                             {
-                                (fileListEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(
-                                     item.ProjectDirectory,
-                                     item.EvaluatedIncludeEscaped,
-                                     forceEvaluate: true);
-
-                                // TODO: Log warning if return value is LogDriveEnumerationWildcard
-                            }
-                            catch (DriveEnumerationWildcardException ex)
-                            {
-                                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(item.EvaluatedIncludeEscaped), XMakeAttributes.include, XMakeElements.itemGroup, ex.Message);
-                            }
-
-                            if (fileListEscaped != null)
-                            {
-                                foreach (var resultantItem in fileListEscaped)
-                                {
-                                    yield return new Pair<string, S>(resultantItem, item);
-                                }
+                                yield return new Pair<string, S>(resultantItem, item);
                             }
                         }
                         else
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 8fd82e449b2..ce0dc977426 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -112,30 +112,26 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                                 MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
                             }
 
-                            try
+                            using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
                             {
-                                using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
-                                {
-                                    (includeSplitFilesEscaped, FileMatcher.SearchAction action) = EngineFileUtilities.GetFileListEscaped(_rootDirectory, glob, excludePatternsForGlobs, fileMatcher: FileMatcher);
-                                    if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
-                                    {
-                                        _lazyEvaluator._loggingContext.LogWarning("InvalidAttributeValue", EscapingUtilities.UnescapeAll(glob), XMakeAttributes.include, XMakeElements.itemGroup);
-                                    }
-                                }
-
-                                if (MSBuildEventSource.Log.IsEnabled())
-                                {
-                                    MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
-                                }
-
-                                foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
-                                {
-                                    itemsToAdd.Add(_itemFactory.CreateItem(includeSplitFileEscaped, glob, _itemElement.ContainingProject.FullPath));
-                                }
+                                includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
+                                    _rootDirectory,
+                                    glob,
+                                    excludePatternsForGlobs,
+                                    fileMatcher: FileMatcher,
+                                    loggingMechanism: _lazyEvaluator._loggingContext,
+                                    includeLocation: _itemElement.IncludeLocation,
+                                    excludeLocation: _itemElement.ExcludeLocation);
                             }
-                            catch (DriveEnumerationWildcardException ex)
+
+                            if (MSBuildEventSource.Log.IsEnabled())
+                            {
+                                MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
+                            }
+
+                            foreach (string includeSplitFileEscaped in includeSplitFilesEscaped)
                             {
-                                ProjectErrorUtilities.ThrowInvalidProject(_itemElement.IncludeLocation, "InvalidAttributeValueWithException", EscapingUtilities.UnescapeAll(glob), XMakeAttributes.include, XMakeElements.itemGroup, ex.Message);
+                                itemsToAdd.Add(_itemFactory.CreateItem(includeSplitFileEscaped, glob, _itemElement.ContainingProject.FullPath));
                             }
                         }
                     }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 8ee8b514349..c25e4dc39fe 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -695,10 +695,6 @@
       <Link>SharedUtilities\FileMatcher.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\DriveEnumerationWildcardException.cs">
-      <Link>SharedUtilities\DriveEnumerationWildcardException.cs</Link>
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\FileUtilities.cs">
       <Link>SharedUtilities\FileUtilities.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 9033588f3bc..9fc047c95c1 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -6,10 +6,11 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Text.RegularExpressions;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -17,6 +18,8 @@ namespace Microsoft.Build.Internal
 {
     internal static class EngineFileUtilities
     {
+        private const string DriveEnumeratingWildcardMessageResourceName = "WildcardResultsInDriveEnumeration";
+
         // Regexes for wildcard filespecs that should not get expanded
         // By default all wildcards are expanded.
         private static List<Regex> s_lazyWildCardExpansionRegexes;
@@ -47,14 +50,27 @@ internal static void CaptureLazyWildcardRegexes()
         /// </summary>
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
+        /// <param name="loggingMechanism">Accepted loggers for drive enumeration: TargetLoggingContext, ILoggingService,
+        /// and EvaluationLoggingContext.</param>
+        /// <param name="excludeLocation">Location of Exclude element in file, used after drive enumeration detection.</param>
         /// <returns>Array of file paths, unescaped.</returns>
-        internal static (string[], FileMatcher.SearchAction) GetFileListUnescaped
+        internal static string[] GetFileListUnescaped
             (
             string directoryEscaped,
-            string filespecEscaped
+            string filespecEscaped,
+            object loggingMechanism = null,
+            IElementLocation excludeLocation = null
             )
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: false, forceEvaluateWildCards: false, excludeSpecsEscaped: null, fileMatcher: FileMatcher.Default);
+            return GetFileList(
+                directoryEscaped,
+                filespecEscaped,
+                returnEscaped: false,
+                forceEvaluateWildCards: false,
+                excludeSpecsEscaped: null,
+                fileMatcher: FileMatcher.Default,
+                loggingMechanism: loggingMechanism,
+                excludeLocation: excludeLocation);
         }
 
         /// <summary>
@@ -70,19 +86,49 @@ string filespecEscaped
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <param name="excludeSpecsEscaped">Filespecs to exclude, escaped.</param>
-        /// <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off</param>
-        /// <param name="fileMatcher"></param>
+        /// <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off.</param>
+        /// <param name="fileMatcher">Class that contains functions for matching filenames with patterns.</param>
+        /// <param name="loggingMechanism">Accepted loggers for drive enumeration: TargetLoggingContext, ILoggingService,
+        /// and EvaluationLoggingContext.</param>
+        /// <param name="includeLocation">Location of Include element in file, used after drive enumeration detection.</param>
+        /// <param name="excludeLocation">Location of Exclude element in file, used after drive enumeration detection.</param>
+        /// <param name="importLocation">Location of Import element in file, used after drive enumeration detection.</param>
+        /// <param name="buildEventContext">Context to log a warning, used after drive enumeration detection.</param>
+        /// <param name="buildEventFileInfoFullPath">Full path to project file to create BuildEventFileInfo,
+        /// used after drive enumeration detection.</param>
+        /// <param name="disableExcludeDriveEnumerationWarning">Flag used to detect when to properly log a warning
+        /// for the Exclude attribute after detecting a drive enumerating wildcard.</param>
         /// <returns>Array of file paths, escaped.</returns>
-        internal static (string[], FileMatcher.SearchAction) GetFileListEscaped
+        internal static string[] GetFileListEscaped
             (
             string directoryEscaped,
             string filespecEscaped,
             IEnumerable<string> excludeSpecsEscaped = null,
             bool forceEvaluate = false,
-            FileMatcher fileMatcher = null
+            FileMatcher fileMatcher = null,
+            object loggingMechanism = null,
+            IElementLocation includeLocation = null,
+            IElementLocation excludeLocation = null,
+            IElementLocation importLocation = null,
+            BuildEventContext buildEventContext = null,
+            string buildEventFileInfoFullPath = null,
+            bool disableExcludeDriveEnumerationWarning = false
             )
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: true, forceEvaluate, excludeSpecsEscaped, fileMatcher ?? FileMatcher.Default);
+            return GetFileList(
+                directoryEscaped,
+                filespecEscaped,
+                returnEscaped: true,
+                forceEvaluate,
+                excludeSpecsEscaped,
+                fileMatcher ?? FileMatcher.Default,
+                loggingMechanism: loggingMechanism,
+                includeLocation: includeLocation,
+                excludeLocation: excludeLocation,
+                importLocation: importLocation,
+                buildEventFileInfoFullPath: buildEventFileInfoFullPath,
+                buildEventContext: buildEventContext,
+                disableExcludeDriveEnumerationWarning: disableExcludeDriveEnumerationWarning);
         }
 
         internal static bool FilespecHasWildcards(string filespecEscaped)
@@ -112,24 +158,44 @@ internal static bool FilespecHasWildcards(string filespecEscaped)
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <param name="returnEscaped"><code>true</code> to return escaped specs.</param>
-        /// <param name="forceEvaluateWildCards">Whether to force file glob expansion when eager expansion is turned off</param>
+        /// <param name="forceEvaluateWildCards">Whether to force file glob expansion when eager expansion is turned off.</param>
         /// <param name="excludeSpecsEscaped">The exclude specification, escaped.</param>
-        /// <param name="fileMatcher"></param>
+        /// <param name="fileMatcher">Class that contains functions for matching filenames with patterns.</param>
+        /// <param name="loggingMechanism">Accepted loggers for drive enumeration: TargetLoggingContext, ILoggingService,
+        /// and EvaluationLoggingContext.</param>
+        /// <param name="includeLocation">Location of Include element in file, used after drive enumeration detection.</param>
+        /// <param name="excludeLocation">Location of Exclude element in file, used after drive enumeration detection.</param>
+        /// <param name="importLocation">Location of Import element in file, used after drive enumeration detection.</param>
+        /// <param name="buildEventContext">Context to log a warning, used after drive enumeration detection.</param>
+        /// <param name="buildEventFileInfoFullPath">Full path to project file to create BuildEventFileInfo,
+        /// used after drive enumeration detection.</param>
+        /// <param name="disableExcludeDriveEnumerationWarning">Flag used to detect when to properly log a warning
+        /// for the Exclude attribute after detecting a drive enumerating wildcard.</param>
         /// <returns>Array of file paths.</returns>
-        private static (string[], FileMatcher.SearchAction) GetFileList
+        private static string[] GetFileList
             (
             string directoryEscaped,
             string filespecEscaped,
             bool returnEscaped,
             bool forceEvaluateWildCards,
             IEnumerable<string> excludeSpecsEscaped,
-            FileMatcher fileMatcher
+            FileMatcher fileMatcher,
+            object loggingMechanism = null,
+            IElementLocation includeLocation = null,
+            IElementLocation excludeLocation = null,
+            IElementLocation importLocation = null,
+            BuildEventContext buildEventContext = null,
+            string buildEventFileInfoFullPath = null,
+            bool disableExcludeDriveEnumerationWarning = false
             )
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
 
             string[] fileList;
+
+            // Used to properly detect and log drive enumerating wildcards when applicable.
             FileMatcher.SearchAction action = FileMatcher.SearchAction.None;
+            string excludeFileSpec = string.Empty;
 
             if (!FilespecHasWildcards(filespecEscaped) ||
                 FilespecMatchesLazyWildcard(filespecEscaped, forceEvaluateWildCards))
@@ -153,8 +219,98 @@ FileMatcher fileMatcher
                 // the list into a string array.  If the filespec started out
                 // as a relative path, we will get back a bunch of relative paths.
                 // If the filespec started out as an absolute path, we will get
-                // back a bunch of absolute paths.
-                (fileList, action) = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
+                // back a bunch of absolute paths. Also retrieves the search action
+                // and relevant Exclude filespec for drive enumerating wildcard detection.
+                (fileList, action, excludeFileSpec) = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
+
+                // Determines whether Exclude filespec or passed in file spec should be
+                // used in drive enumeration warning or exception.
+                bool excludeFileSpecIsEmpty = string.IsNullOrWhiteSpace(excludeFileSpec);
+                string fileSpec = excludeFileSpecIsEmpty ? filespecUnescaped : excludeFileSpec;
+
+                switch (action)
+                {
+                    case (FileMatcher.SearchAction.LogDriveEnumeratingWildcard):
+                        switch (loggingMechanism)
+                        {
+                            // Logging mechanism received from ItemGroupIntrinsicTask.
+                            case TargetLoggingContext targetLoggingContext:
+                                LogDriveEnumerationWarningWithTargetLoggingContext(
+                                    targetLoggingContext,
+                                    includeLocation,
+                                    excludeFileSpecIsEmpty,
+                                    disableExcludeDriveEnumerationWarning,                                
+                                    fileSpec);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator.
+                            case ILoggingService loggingService:
+                                LogDriveEnumerationWarningWithLoggingService(
+                                    loggingService,
+                                    buildEventContext,
+                                    buildEventFileInfoFullPath,
+                                    filespecUnescaped);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator and LazyItemEvaluator.IncludeOperation.
+                            case EvaluationLoggingContext evaluationLoggingContext:
+                                LogDriveEnumerationWarningWithEvaluationLoggingContext(
+                                    evaluationLoggingContext,
+                                    importLocation,
+                                    excludeFileSpecIsEmpty,
+                                    filespecUnescaped,
+                                    fileSpec);
+
+                                break;
+
+                            default:
+                                throw new InternalErrorException($"Logging type {loggingMechanism.GetType()} is not understood by {nameof(GetFileList)}.");
+                        }
+
+                        break;
+
+                    case (FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard):
+                        switch (loggingMechanism)
+                        {
+                            // Logging mechanism received from ItemGroupIntrinsicTask.
+                            case TargetLoggingContext targetLoggingContext:
+                                ThrowDriveEnumerationExceptionWithTargetLoggingContext(
+                                    includeLocation,
+                                    excludeLocation,
+                                    excludeFileSpecIsEmpty,
+                                    filespecUnescaped,
+                                    fileSpec);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator.
+                            case ILoggingService loggingService:
+                                ThrowDriveEnumerationExceptionWithLoggingService(includeLocation, filespecUnescaped);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator and LazyItemEvaluator.IncludeOperation.
+                            case EvaluationLoggingContext evaluationLoggingContext:
+                                ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(
+                                    importLocation,
+                                    includeLocation,
+                                    excludeLocation,
+                                    filespecUnescaped,
+                                    fileSpec,
+                                    excludeFileSpecIsEmpty);
+
+                                break;
+
+                            default:
+                                throw new InternalErrorException($"Logging type {loggingMechanism.GetType()} is not understood by {nameof(GetFileList)}.");
+                        }
+
+                        break;
+
+                    default: break;
+                }
 
                 ErrorUtilities.VerifyThrow(fileList != null, "We must have a list of files here, even if it's empty.");
 
@@ -177,7 +333,153 @@ FileMatcher fileMatcher
                 }
             }
 
-            return (fileList, action);
+            return fileList;
+        }
+
+        private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLoggingContext targetLoggingContext, IElementLocation includeLocation, bool excludeFileSpecIsEmpty, bool disableExcludeDriveEnumerationWarning, string fileSpec)
+        {
+            // Both condition lines are necessary to skip for the first GetFileListEscaped call
+            // and reach for the GetFileListUnescaped call when the wildcarded Exclude attribute results
+            // in a drive enumeration. Since we only want to check for the Exclude
+            // attribute here, we want to ensure that includeLocation is null - otherwise,
+            // Include wildcard attributes for the GetFileListEscaped calls would falsely appear
+            // with the Exclude attribute in the logged warning.
+            if (((!excludeFileSpecIsEmpty) && (!disableExcludeDriveEnumerationWarning)) ||
+                (includeLocation == null))
+            {
+                targetLoggingContext.LogWarning(
+                        DriveEnumeratingWildcardMessageResourceName,
+                        fileSpec,
+                        XMakeAttributes.exclude,
+                        XMakeElements.itemGroup);
+            }
+
+            // Both conditions are necessary to reach for both GetFileListEscaped calls
+            // and skip for the GetFileListUnescaped call when the wildcarded Include attribute
+            // results in drive enumeration.
+            else if (excludeFileSpecIsEmpty && (includeLocation != null))
+            {
+                targetLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+        }
+
+        private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService loggingService, BuildEventContext buildEventContext, string buildEventFileInfoFullPath, string filespecUnescaped)
+        {
+            if (buildEventContext != null)
+            {
+                loggingService.LogWarning(
+                    buildEventContext,
+                    string.Empty,
+                    new BuildEventFileInfo(buildEventFileInfoFullPath),
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+        }
+
+        private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(EvaluationLoggingContext evaluationLoggingContext, IElementLocation importLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
+        {
+            if (importLocation != null)
+            {
+                evaluationLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.project,
+                    XMakeElements.import);
+            }
+            else if (excludeFileSpecIsEmpty)
+            {
+                evaluationLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+            else
+            {
+                evaluationLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.exclude,
+                    XMakeElements.itemGroup);
+            }
+        }
+
+        private static void ThrowDriveEnumerationExceptionWithTargetLoggingContext(IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
+        {
+            // The first condition is necessary to reach for both GetFileListEscaped calls
+            // whenever the wildcarded Include attribute results in drive enumeration, and
+            // the second condition is necessary to skip for the GetFileListUnescaped call
+            // whenever the wildcarded Exclude attribute results in drive enumeration.
+            if (excludeFileSpecIsEmpty && (includeLocation != null))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    includeLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+
+            // The first condition is necessary to reach for both GetFileListEscaped calls
+            // whenever the wildcarded Exclude attribute results in drive enumeration, and
+            // the second condition is necessary to reach for the GetFileListUnescaped call
+            // (also when the wildcarded Exclude attribute results in drive enumeration).
+            else if ((!excludeFileSpecIsEmpty) || (includeLocation == null))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                        excludeLocation,
+                        DriveEnumeratingWildcardMessageResourceName,
+                        fileSpec,
+                        XMakeAttributes.exclude,
+                        XMakeElements.itemGroup);
+            }
+        }
+
+        private static void ThrowDriveEnumerationExceptionWithLoggingService(IElementLocation includeLocation, string filespecUnescaped)
+        {
+            ProjectErrorUtilities.ThrowInvalidProject(
+                includeLocation,
+                DriveEnumeratingWildcardMessageResourceName,
+                filespecUnescaped,
+                XMakeAttributes.include,
+                XMakeElements.itemGroup);
+        }
+
+        private static void ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(IElementLocation importLocation, IElementLocation includeLocation, IElementLocation excludeLocation, string filespecUnescaped, string fileSpec, bool excludeFileSpecIsEmpty)
+        {
+            if (importLocation != null)
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    importLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.project,
+                    XMakeElements.import);
+            }
+            else if (excludeFileSpecIsEmpty)
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    includeLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+            else
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    excludeLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.exclude,
+                    XMakeElements.itemGroup);
+            }
         }
 
         private static bool FilespecMatchesLazyWildcard(string filespecEscaped, bool forceEvaluateWildCards)
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 5342a0b2a89..2cea08d2ad3 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -43,7 +43,7 @@ public Traits()
         /// </summary>
         public readonly bool UseLazyWildCardEvaluation = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildSkipEagerWildCardEvaluationRegexes"));
         public readonly bool LogExpandedWildcards = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGEXPANDEDWILDCARDS"));
-        public readonly bool ThrowOnWildcardDriveEnumeration = Environment.GetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration") == "1";
+        public readonly bool ThrowOnDriveEnumeratingWildcard = Environment.GetEnvironmentVariable("MSBUILDFAILONDRIVEENUMERATINGWILDCARD") == "1";
 
         /// <summary>
         /// Cache file existence for the entire process
diff --git a/src/Shared/DriveEnumerationWildcardException.cs b/src/Shared/DriveEnumerationWildcardException.cs
deleted file mode 100644
index 9106405a394..00000000000
--- a/src/Shared/DriveEnumerationWildcardException.cs
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-
-namespace Microsoft.Build.Shared
-{
-    /// <summary>
-    /// Thrown in cases where a drive enumeration wildcard was encountered when finding files that match a given file spec.
-    /// </summary>
-    internal class DriveEnumerationWildcardException : Exception
-    {
-        public DriveEnumerationWildcardException()
-        {
-        }
-
-        public DriveEnumerationWildcardException(string projectDirectory, string wildcardEvaluation)
-            : base(ConstructErrorMessage(projectDirectory, wildcardEvaluation))
-        {
-        }
-
-        public DriveEnumerationWildcardException(string message, Exception innerException)
-            : base(message, innerException)
-        {
-        }
-
-        private static string ConstructErrorMessage(string projectDirectory, string wildcardEvaluation)
-        {
-            return $"Failed to find files in {projectDirectory} that matched the filespec {wildcardEvaluation}, " +
-                    "as this resulted in an attempted drive enumeration. Ensure that items and properties " +
-                    "are properly defined in your project.";
-        }
-    }
-}
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 8bf441c77fe..e837e1435fe 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -1941,8 +1941,8 @@ public TaskOptions(int maxTasks)
         /// <param name="projectDirectoryUnescaped">The project directory.</param>
         /// <param name="filespecUnescaped">Get files that match the given file spec.</param>
         /// <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
-        /// <returns>The array of files.</returns>
-        internal (string[], SearchAction) GetFiles
+        /// <returns>The search action, array of files, and Exclude file spec (if applicable).</returns>
+        internal (string[] FileList, SearchAction Action, string ExcludeFileSpec) GetFiles
             (
             string projectDirectoryUnescaped,
             string filespecUnescaped,
@@ -1952,7 +1952,7 @@ public TaskOptions(int maxTasks)
             // For performance. Short-circuit iff there is no wildcard.
             if (!HasWildcards(filespecUnescaped))
             {
-                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), SearchAction.None);
+                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), SearchAction.None, string.Empty);
             }
 
             if (_cachedGlobExpansions == null)
@@ -1966,8 +1966,9 @@ public TaskOptions(int maxTasks)
             var enumerationKey = ComputeFileEnumerationCacheKey(projectDirectoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
 
             IReadOnlyList<string> files;
-            string[] getFilesList;
+            string[] fileList;
             SearchAction action = SearchAction.None;
+            string excludeFileSpec = string.Empty;
             if (!_cachedGlobExpansions.TryGetValue(enumerationKey, out files))
             {
                 // avoid parallel evaluations of the same wildcard by using a unique lock for each wildcard
@@ -1976,14 +1977,17 @@ public TaskOptions(int maxTasks)
                 {
                     if (!_cachedGlobExpansions.TryGetValue(enumerationKey, out files))
                     {
-                        (getFilesList, action) = GetFilesImplementation(
+                        files = _cachedGlobExpansions.GetOrAdd(
+                                enumerationKey,
+                                (_) =>
+                                {
+                                    (fileList, action, excludeFileSpec) = GetFilesImplementation(
                                         projectDirectoryUnescaped,
                                         filespecUnescaped,
                                         excludeSpecsUnescaped);
 
-                        files = _cachedGlobExpansions.GetOrAdd(
-                                enumerationKey,
-                                getFilesList);
+                                    return fileList;
+                                });
                     }
                 }
             }
@@ -1991,7 +1995,7 @@ public TaskOptions(int maxTasks)
             // Copy the file enumerations to prevent outside modifications of the cache (e.g. sorting, escaping) and to maintain the original method contract that a new array is created on each call.
             var filesToReturn = files.ToArray();
 
-            return (filesToReturn, action);
+            return (filesToReturn, action, excludeFileSpec);
         }
 
         private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnescaped, string filespecUnescaped, List<string> excludes)
@@ -2075,8 +2079,8 @@ public enum SearchAction
             RunSearch,
             ReturnFileSpec,
             ReturnEmptyList,
-            ReturnThrowOnDriveEnumerationWildcard,
-            ReturnLogDriveEnumerationWildcard
+            FailOnDriveEnumeratingWildcard,
+            LogDriveEnumeratingWildcard
         }
 
         private SearchAction GetFileSearchData(
@@ -2141,24 +2145,13 @@ out bool isLegalFileSpec
             }
 
             /*
-             * If the fixed directory part contains the drive or simply '/', and the drive enumeration wildcard is set, then
+             * If a drive enumerating wildcard pattern is detected with the fixed directory and wildcard parts, then
              * this should either be logged or an exception should be thrown.
              */
-            int fixedDirectoryPartLength = fixedDirectoryPart.Length;
-            bool logDriveEnumerationWildcard = false;
-            if (fixedDirectoryPartLength > 0 && wildcardDirectoryPart.Length >= 2)
+            bool logDriveEnumeratingWildcard = IsDriveEnumeratingWildcardPattern(fixedDirectoryPart, wildcardDirectoryPart);
+            if (logDriveEnumeratingWildcard && Traits.Instance.ThrowOnDriveEnumeratingWildcard)
             {
-                if (FileUtilities.IsAnySlash(fixedDirectoryPart[fixedDirectoryPartLength - 1]) && // ex: /**
-                    wildcardDirectoryPart[0] == '*' &&
-                    wildcardDirectoryPart[1] == '*')
-                {
-                    if (Traits.Instance.ThrowOnWildcardDriveEnumeration)
-                    {
-                        return SearchAction.ReturnThrowOnDriveEnumerationWildcard;
-                    }
-
-                    logDriveEnumerationWildcard = true;
-                }
+                return SearchAction.FailOnDriveEnumeratingWildcard;
             }
 
             string directoryPattern = null;
@@ -2209,9 +2202,9 @@ out bool isLegalFileSpec
             result.BaseDirectory = Normalize(fixedDirectoryPart);
             result.RemainingWildcardDirectory = Normalize(wildcardDirectoryPart);
 
-            if (logDriveEnumerationWildcard)
+            if (logDriveEnumeratingWildcard)
             {
-                return SearchAction.ReturnLogDriveEnumerationWildcard;
+                return SearchAction.LogDriveEnumeratingWildcard;
             }
 
             return SearchAction.RunSearch;
@@ -2290,6 +2283,76 @@ internal static string Normalize(string aString)
             return sb.ToString();
         }
 
+        /// <summary>
+        /// Returns true if drive enumerating wildcard patterns are detected using the directory and wildcard parts.
+        /// </summary>
+        /// <param name="directoryPart">Fixed directory string, portion of file spec info.</param>
+        /// <param name="wildcardPart">Wildcard string, portion of file spec info.</param>
+        internal static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart)
+        {
+            int directoryPartLength = directoryPart.Length;
+            int wildcardPartLength = wildcardPart.Length;
+
+            // Handles detection of <drive letter>:<slashes>** pattern for Windows.
+            if (NativeMethodsShared.IsWindows &&
+                directoryPartLength >= 3 &&
+                wildcardPartLength >= 2 &&
+                IsDrivePatternWithoutSlash(directoryPart[0], directoryPart[1]))
+            {
+                return IsFullFileSystemScan(2, directoryPartLength, directoryPart, wildcardPart);
+            }
+
+            // Handles detection of <slashes>** pattern for any platform.
+            else if (directoryPartLength >= 1 &&
+                     wildcardPartLength >= 2)
+            {
+                return IsFullFileSystemScan(0, directoryPartLength, directoryPart, wildcardPart);
+            }
+
+            return false;
+        }
+
+        /// <summary>
+        /// Returns true if given characters follow a drive pattern without the slash (ex: C:).
+        /// </summary>
+        /// <param name="firstValue">First char from directory part of file spec string.</param>
+        /// <param name="secondValue">Second char from directory part of file spec string.</param>
+        private static bool IsDrivePatternWithoutSlash(char firstValue, char secondValue)
+        {
+            return IsValidDriveChar(firstValue) && (secondValue == ':');
+        }
+
+        /// <summary>
+        /// Returns true if selected characters from the fixed directory and wildcard pattern make up the "{any number of slashes}**" pattern.
+        /// </summary>
+        /// <param name="directoryPartIndex">Starting index to begin detecting slashes in directory part of file spec string.</param>
+        /// <param name="directoryPartLength">Length of directory part of file spec string.</param>
+        /// <param name="directoryPart">Fixed directory string, portion of file spec info.</param>
+        /// <param name="wildcardPart">Wildcard string, portion of file spec info.</param>
+        private static bool IsFullFileSystemScan(int directoryPartIndex, int directoryPartLength, string directoryPart, string wildcardPart)
+        {
+            for (int i = directoryPartIndex; i < directoryPartLength; i++)
+            {
+                if (!FileUtilities.IsAnySlash(directoryPart[i]))
+                {
+                    return false;
+                }
+            }
+
+            return (wildcardPart[0] == '*') && (wildcardPart[1] == '*');
+        }
+
+        /// <summary>
+        /// Returns true if the given character is a valid drive letter.
+        /// </summary>
+        /// <remarks>
+        /// Copied from https://github.com/dotnet/corefx/blob/master/src/Common/src/System/IO/PathInternal.Windows.cs#L77-L83
+        /// </remarks>
+        private static bool IsValidDriveChar(char value)
+        {
+            return (value >= 'A' && value <= 'Z') || (value >= 'a' && value <= 'z');
+        }
+
         /// <summary>
         /// Skips slash characters in a string.
         /// </summary>
@@ -2308,15 +2371,6 @@ private static int SkipSlashes(string aString, int startingIndex)
             return index;
         }
 
-        // copied from https://github.com/dotnet/corefx/blob/master/src/Common/src/System/IO/PathInternal.Windows.cs#L77-L83
-        /// <summary>
-        /// Returns true if the given character is a valid drive letter
-        /// </summary>
-        private static bool IsValidDriveChar(char value)
-        {
-            return (value >= 'A' && value <= 'Z') || (value >= 'a' && value <= 'z');
-        }
-
         private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List<string> excludeSpecsUnescaped)
         {
             if (excludeSpecsUnescaped != null)
@@ -2349,8 +2403,8 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
         /// <param name="projectDirectoryUnescaped">The project directory.</param>
         /// <param name="filespecUnescaped">Get files that match the given file spec.</param>
         /// <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
-        /// <returns>The array of files.</returns>
-        private (string[], SearchAction) GetFilesImplementation(
+        /// <returns>The search action, array of files, and Exclude file spec (if applicable).</returns>
+        private (string[] FileList, SearchAction Action, string ExcludeFileSpec) GetFilesImplementation(
             string projectDirectoryUnescaped,
             string filespecUnescaped,
             List<string> excludeSpecsUnescaped)
@@ -2365,17 +2419,17 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
 
             if (action == SearchAction.ReturnEmptyList)
             {
-                return (Array.Empty<string>(), action);
+                return (Array.Empty<string>(), action, string.Empty);
             }
             else if (action == SearchAction.ReturnFileSpec)
             {
-                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), action);
+                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), action, string.Empty);
             }
-            else if (action == SearchAction.ReturnThrowOnDriveEnumerationWildcard)
+            else if (action == SearchAction.FailOnDriveEnumeratingWildcard)
             {
-                throw new DriveEnumerationWildcardException(projectDirectoryUnescaped, filespecUnescaped);
+                return (Array.Empty<string>(), action, string.Empty);
             }
-            else if ((action != SearchAction.RunSearch) && (action != SearchAction.ReturnLogDriveEnumerationWildcard))
+            else if ((action != SearchAction.RunSearch) && (action != SearchAction.LogDriveEnumeratingWildcard))
             {
                 // This means the enum value wasn't valid (or a new one was added without updating code correctly)
                 throw new NotSupportedException(action.ToString());
@@ -2387,6 +2441,10 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
             //  The BaseDirectory of the exclude search is the key for this dictionary.
             Dictionary<string, List<RecursionState>> searchesToExcludeInSubdirs = null;
 
+            // Track the search action and exclude file spec for proper detection and logging of drive enumerating wildcards.
+            SearchAction trackSearchAction = action;
+            string trackExcludeFileSpec = string.Empty;
+
             HashSet<string> resultsToExclude = null;
             if (excludeSpecsUnescaped != null)
             {
@@ -2412,7 +2470,16 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
                         // Nothing to do
                         continue;
                     }
-                    else if (excludeAction != SearchAction.RunSearch)
+                    else if (excludeAction == SearchAction.FailOnDriveEnumeratingWildcard)
+                    {
+                        return (Array.Empty<string>(), excludeAction, excludeSpec);
+                    }
+                    else if (excludeAction == SearchAction.LogDriveEnumeratingWildcard)
+                    {
+                        trackSearchAction = excludeAction;
+                        trackExcludeFileSpec = excludeSpec;
+                    }
+                    else if ((excludeAction != SearchAction.RunSearch) && (excludeAction != SearchAction.LogDriveEnumeratingWildcard))
                     {
                         // This means the enum value wasn't valid (or a new one was added without updating code correctly)
                         throw new NotSupportedException(excludeAction.ToString());
@@ -2569,14 +2636,14 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
                 // Flatten to get exceptions than are thrown inside a nested Parallel.ForEach
                 if (ex.Flatten().InnerExceptions.All(ExceptionHandling.IsIoRelatedException))
                 {
-                    return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), action);
+                    return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), trackSearchAction, trackExcludeFileSpec);
                 }
                 throw;
             }
             catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
             {
                 // Assume it's not meant to be a path
-                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), action);
+                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), trackSearchAction, trackExcludeFileSpec);
             }
 
             /*
@@ -2586,7 +2653,7 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
                 ? listOfFiles.SelectMany(list => list).Where(f => !resultsToExclude.Contains(f)).ToArray()
                 : listOfFiles.SelectMany(list => list).ToArray();
 
-            return (files, action);
+            return (files, trackSearchAction, trackExcludeFileSpec);
         }
 
         private bool InnerExceptionsAreAllIoRelated(AggregateException ex)
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index 4a2ab0dd185..b1c884da6fd 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -278,10 +278,15 @@
     <value>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</value>
     <comment>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</comment>
   </data>
+  <data name="WildcardResultsInDriveEnumeration" xml:space="preserve">
+    <value>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</value>
+    <comment>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</comment>
+  </data>
   <!--
         The shared message bucket is: MSB5001 - MSB5999
 
-        Next message code should be MSB5029
+        Next message code should be MSB5030
 
         Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
             <none>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 80de31cf354..2ae3ccc1cd9 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Parametr {0} s piazenou hodnotou {1} nesm obsahovat neplatnou cestu nebo neplatn znaky souboru.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index 28e73b49c1a..12ae56e9f4a 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Der Parameter "{0}" mit dem zugewiesenen Wert "{1}" darf keinen ungltigen Pfad und keine ungltigen Dateizeichen haben.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 332d51f7961..3c8570e8e88 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -308,6 +308,12 @@
         <target state="translated">El parmetro "{0}" con el valor asignado "{1}" no puede tener una ruta de acceso no vlida o caracteres de archivo no vlidos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 98d0ecd2344..53bf871cc4e 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Le paramtre "{0}" avec la valeur assigne "{1}" ne peut pas avoir un chemin non valide ou des caractres de fichier non valides.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 31c10bd56ca..da4df2e58a7 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Il parametro "{0}" con valore assegnato "{1}" non pu contenere un percorso non valido o caratteri di file non validi.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index 762d7780a9b..734c1003330 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -308,6 +308,12 @@
         <target state="translated"> "{1}"  "{0}" </target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 7cd5d631a66..3f41262d271 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -308,6 +308,12 @@
         <target state="translated">"{1}"   "{0}"           .</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 3755284c24a..3b400e189a6 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Parametr {0} z przypisan wartoci {1} nie moe mie nieprawidowej cieki ani zawiera nieprawidowych znakw w pliku.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 6fd1b77903b..3db1eecab19 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -308,6 +308,12 @@
         <target state="translated">O parmetro "{0}" com o valor "{1}" atribudo no pode ter um caminho invlido ou caracteres de arquivo invlidos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index 3570539b1f8..f93ae4dddea 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -308,6 +308,12 @@
         <target state="translated"> "{0}"    "{1}"         .</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index d6831788b90..a630c160819 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -308,6 +308,12 @@
         <target state="translated">"{1}" deeri atanan "{0}" parametresinde geersiz yol veya geersiz dosya karakterleri bulunamaz.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index b5468e75bcb..44151824d95 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -308,6 +308,12 @@
         <target state="translated">{1}{0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 893e286184a..6ea33bb0148 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -308,6 +308,12 @@
         <target state="translated"> "{1}"  "{0}" </target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="new">MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index c6c031bec49..e83e0c56d1b 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -62,7 +62,7 @@ public void GetFilesPatternMatching(string pattern, int expectedMatchCount)
                 File.WriteAllBytes(Path.Combine(testFolder.Path, file), new byte[1]);
             }
 
-            string[] fileMatches = FileMatcher.Default.GetFiles(testFolder.Path, pattern).Item1;
+            string[] fileMatches = FileMatcher.Default.GetFiles(testFolder.Path, pattern).FileList;
 
             fileMatches.Length.ShouldBe(expectedMatchCount, $"Matches: '{String.Join("', '", fileMatches)}'");
         }
@@ -83,7 +83,7 @@ public void GetFilesComplexGlobbingMatching(GetFilesComplexGlobbingMatchingInfo
 
             void VerifyImpl(FileMatcher fileMatcher, string include, string[] excludes, bool shouldHaveNoMatches = false, string customMessage = null)
             {
-                string[] matchedFiles = fileMatcher.GetFiles(testFolder.Path, include, excludes?.ToList()).Item1;
+                string[] matchedFiles = fileMatcher.GetFiles(testFolder.Path, include, excludes?.ToList()).FileList;
 
                 if (shouldHaveNoMatches)
                 {
@@ -1042,8 +1042,8 @@ public void DotDotForParentDirectory()
                 // On Linux *. * does not pick up files with no extension
                 ValidateFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine("..", "..", "File"), false);
             }
-            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new [] {"..", "..", "dir1", "dir2", "File.txt"}), false);
-            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new [] {"..", "..", "dir1", "dir2", "File"}), false);
+            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new[] { "..", "..", "dir1", "dir2", "File.txt" }), false);
+            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new[] { "..", "..", "dir1", "dir2", "File" }), false);
         }
 
         [Fact]
@@ -1256,7 +1256,7 @@ public void IllegalTooLongPathOptOutWave17_0()
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
                 string longString = new string('X', 500) + "*"; // need a wildcard to do anything
-                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString).Item1;
+                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString).FileList;
 
                 Assert.Equal(longString, result[0]); // Does not throw
                 ChangeWaves.ResetStateForTests();
@@ -1298,7 +1298,7 @@ public void Regress367780_CrashOnStarDotDot()
             Directory.CreateDirectory(workingPath);
             Directory.CreateDirectory(workingPathSubfolder);
 
-            files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).Item1;
+            files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).FileList;
         }
 
         [Fact]
@@ -1310,7 +1310,7 @@ public void Regress141071_StarStarSlashStarStarIsLiteral()
 
             Directory.CreateDirectory(workingPath);
             File.WriteAllText(fileName, "Hello there.");
-            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).Item1;
+            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).FileList;
 
             string result = String.Join(", ", files);
             Console.WriteLine(result);
@@ -1330,7 +1330,7 @@ public void Regress14090_TrailingDotMatchesNoExtension()
             Directory.CreateDirectory(workingPath);
             Directory.CreateDirectory(workingPathSubdir);
             File.AppendAllText(workingPathSubdirBing, "y");
-            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).Item1;
+            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).FileList;
 
             string result = String.Join(", ", files);
             Console.WriteLine(result);
@@ -1353,19 +1353,19 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
                 {
                     env.SetEnvironmentVariable("MsBuildCacheFileEnumerations", "1");
 
-                    var testProject = env.CreateTestProjectWithFiles(string.Empty, new[] {"a.cs", "b.cs", "c.cs"});
+                    var testProject = env.CreateTestProjectWithFiles(string.Empty, new[] { "a.cs", "b.cs", "c.cs" });
 
-                    var files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs").Item1;
+                    var files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs").FileList;
                     Array.Sort(files);
-                    Assert.Equal(new []{"a.cs", "b.cs", "c.cs"}, files);
+                    Assert.Equal(new[] { "a.cs", "b.cs", "c.cs" }, files);
 
-                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string>{"a.cs"}).Item1;
+                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string> { "a.cs" }).FileList;
                     Array.Sort(files);
-                    Assert.Equal(new[] {"b.cs", "c.cs" }, files);
+                    Assert.Equal(new[] { "b.cs", "c.cs" }, files);
 
-                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string>{"a.cs", "c.cs"}).Item1;
+                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string> { "a.cs", "c.cs" }).FileList;
                     Array.Sort(files);
-                    Assert.Equal(new[] {"b.cs" }, files);
+                    Assert.Equal(new[] { "b.cs" }, files);
                 }
             }
             finally
@@ -1374,21 +1374,146 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
             }
         }
 
-        [Fact]
-        public void DriveEnumerationWildcardThrowsException()
+        [PlatformSpecific(TestPlatforms.Any)]
+        [Theory]
+        [InlineData(@"\", "**")]
+        [InlineData(@"\\", "**")]
+        [InlineData(@"\\\\\\\\", "**")]
+        [InlineData("/", "**/*.cs")]
+        [InlineData("/", "**")]
+        [InlineData("//", "**")]
+        [InlineData("////////", "**")]
+        public void DriveEnumeratingWildcardIsObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
+            DriveEnumeratingWildcardIsObserved(directoryPart, wildcardPart);
+
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"\", "**")]
+        [InlineData(@"c:\", "**")]
+        [InlineData(@"c:\\", "**")]
+        [InlineData(@"c:\\\\\\\\", "**")]
+        [InlineData(@"c:\", @"**\*.cs")]
+        public void DriveEnumeratingWildcardIsObservedOnWindows(string directoryPart, string wildcardPart)
+        {
+            DriveEnumeratingWildcardIsObserved(directoryPart, wildcardPart);
+            DriveEnumeratingWildcardFailsAndReturns(directoryPart, wildcardPart);
+        }
+
+        private void DriveEnumeratingWildcardIsObserved(string directoryPart, string wildcardPart) =>
+            FileMatcher.IsDriveEnumeratingWildcardPattern(directoryPart, wildcardPart).ShouldBeTrue();
+
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"\", "**")]
+        [InlineData("/", "**/*.cs")]
+        [InlineData("/", "**")]
+        [InlineData("//", "**")]
+        [InlineData("////////", "**")]
+        public void DriveEnumeratingWildcardFailsAndReturnsOnUnix(string directoryPart, string wildcardPart)
+        {
+            DriveEnumeratingWildcardFailsAndReturns(directoryPart, wildcardPart);
+        }
+
+        private void DriveEnumeratingWildcardFailsAndReturns(string directoryPart, string wildcardPart)
+        {
+            string driveEnumeratingWildcard = string.Concat(directoryPart, wildcardPart);
+
+            using (var env = TestEnvironment.Create())
+            {
+                try
+                {
+                    // Set env var to fail on drive enumerating wildcard detection
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "1");
+
+                    (string[] fileList, FileMatcher.SearchAction action, string excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        driveEnumeratingWildcard);
+
+                    action.ShouldBe(FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard);
+                    fileList.ShouldBeEmpty();
+                    excludeFileSpec.ShouldBe(string.Empty);
+
+                    // Handle failing with drive enumerating exclude
+                    (fileList, action, excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        @"/*/*.cs",
+                        new List<string> { driveEnumeratingWildcard });
+
+                    action.ShouldBe(FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard);
+                    fileList.ShouldBeEmpty();
+                    excludeFileSpec.ShouldBe(driveEnumeratingWildcard);
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
+
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"z:\**")]
+        [InlineData(@"z:\\**")]
+        [InlineData(@"z:\\\\\\\\**")]
+        [InlineData(@"z:\**\*.cs")]
+        public void DriveEnumeratingWildcardIsLoggedOnWindows(string driveEnumeratingWildcard)
         {
             using (var env = TestEnvironment.Create())
             {
-                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
+                try
+                {
+                    // Set env var to log on drive enumerating wildcard detection
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "0");
 
-                Assert.Throws<DriveEnumerationWildcardException>(() => { FileMatcher.Default.GetFiles(string.Empty, NativeMethodsShared.IsWindows ? @"c:\**\*.cs" : "/**/*.cs"); });
+                    (_, FileMatcher.SearchAction action, string excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        driveEnumeratingWildcard);
 
-                Assert.Throws<DriveEnumerationWildcardException>(() => { FileMatcher.Default.GetFiles(string.Empty, NativeMethodsShared.IsWindows ? @"c:\**" : "/**"); });
+                    action.ShouldBe(FileMatcher.SearchAction.LogDriveEnumeratingWildcard);
+                    excludeFileSpec.ShouldBe(string.Empty);
 
-                Assert.Throws<DriveEnumerationWildcardException>(() => { FileMatcher.Default.GetFiles(string.Empty, NativeMethodsShared.IsWindows ? @"\**" : "/**"); });
+                    // Handle logging with drive enumerating exclude
+                    (_, action, excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        @"/*/*.cs",
+                        new List<string> { driveEnumeratingWildcard });
+
+                    action.ShouldBe(FileMatcher.SearchAction.LogDriveEnumeratingWildcard);
+                    excludeFileSpec.ShouldBe(driveEnumeratingWildcard);
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
             }
         }
 
+        [PlatformSpecific(TestPlatforms.Any)]
+        [Theory]
+        [InlineData(@"\", @"*\*.cs")]
+        [InlineData(@"\\", @"*\*.cs")]
+        [InlineData(@"\", @"*\*.*")]
+        [InlineData(@"/", @"*/*.cs")]
+        [InlineData(@"//", @"*/*.cs")]
+        [InlineData(@"/", @"*/*.*")]
+        public void DriveEnumeratingWildcardIsNotObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
+            DriveEnumeratingWildcardIsNotObserved(directoryPart, wildcardPart);
+
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"c:\", "**")]
+        [InlineData(@"c:\\", "**")]
+        [InlineData(@"c:\\\\\\\\", "**")]
+        [InlineData(@"c:\", @"**\*.cs")]
+        public void DriveEnumeratingWildcardIsNotObservedOnUnix(string directoryPart, string wildcardPart)
+        {
+            DriveEnumeratingWildcardIsNotObserved(directoryPart, wildcardPart);
+        }
+
+        private void DriveEnumeratingWildcardIsNotObserved(string directoryPart, string wildcardPart) =>
+            FileMatcher.IsDriveEnumeratingWildcardPattern(directoryPart, wildcardPart).ShouldBeFalse();
+
         [Fact]
         public void RemoveProjectDirectory()
         {
@@ -2398,7 +2523,7 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
                 String.Empty, /* we don't need project directory as we use mock filesystem */
                 filespec,
                 excludeFilespecs?.ToList()
-            ).Item1;
+            ).FileList;
 
             Func<string[], string[]> normalizeAllFunc = (paths => normalizeAllPaths ? paths.Select(MockFileSystem.Normalize).ToArray() : paths);
             Func<string[], string[]> normalizeMatching = (paths => normalizeExpectedMatchingFiles ? paths.Select(MockFileSystem.Normalize).ToArray() : paths);
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index d6c10b453e0..d4d5b8e3d1e 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -13,7 +13,9 @@
 using System.Threading.Tasks;
 using System.Xml;
 
+using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.FileSystem;
@@ -1403,6 +1405,107 @@ public static BuildResult BuildProjectFileUsingBuildManager(string projectFile,
             }
         }
 
+        internal enum ExpectedBuildResult
+        {
+            // The build should fail with a logged error upon drive enumerationg wildcard detection and setting of environment variable.
+            FailWithError,
+            // The build should succeed with a logged warning upon drive enumerating wildcard detection (regardless of environment variable value).
+            SucceedWithWarning,
+            // The build should succeed with no logged warnings and errors, as there are no drive enumerating wildcards.
+            SucceedWithNoErrorsAndWarnings
+        }
+
+        /// <summary>
+        /// Verify that a drive enumerating wildcard warning is logged or exception is thrown. 
+        /// </summary>
+        internal static void CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(string content, string failOnDriveEnumerationEnvVar, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
+        {
+            using (var env = TestEnvironment.Create(testOutput))
+            {
+                // Clean file contents by replacing single quotes with double quotes, etc.
+                content = ObjectModelHelpers.CleanupFileContents(content);
+                var testProject = env.CreateTestProjectWithFiles(content.Cleanup());
+
+                // Reset state
+                ResetStateForDriveEnumeratingWildcardTests(env, failOnDriveEnumerationEnvVar);
+
+                // Setup and build test target
+                BuildTargetWithDriveEnumeratingWildcardUsingBuildManager(env, testProject.ProjectFile, targetName, expectedBuildResult, testOutput);
+            }
+        }
+
+        internal static void ResetStateForDriveEnumeratingWildcardTests(TestEnvironment env, string setEnvVar)
+        {
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDFAILONDRIVEENUMERATINGWILDCARD", setEnvVar);
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+        }
+
+        internal static void BuildTargetWithDriveEnumeratingWildcardUsingBuildManager(TestEnvironment env, string testProjectFile, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
+        {
+            try
+            {
+                // Setup build
+                MockLogger mockLogger = (testOutput == null) ? new MockLogger() : new MockLogger(testOutput);
+                var p = ProjectInstance.FromFile(testProjectFile, new ProjectOptions());
+                BuildManager buildManager = BuildManager.DefaultBuildManager;
+                BuildRequestData data = new BuildRequestData(p, new[] { targetName });
+                BuildParameters parameters = new BuildParameters()
+                {
+                    Loggers = new ILogger[] { mockLogger },
+                };
+
+                // Perform build using build manager
+                BuildResult buildResult = buildManager.Build(parameters, data);
+
+                // Verify result based on value of ExpectedBuildResult
+                if (expectedBuildResult == ExpectedBuildResult.FailWithError)
+                {
+                    VerifyErrorLoggedForDriveEnumeratingWildcard(buildResult, mockLogger, targetName);
+                }
+                else if (expectedBuildResult == ExpectedBuildResult.SucceedWithWarning)
+                {
+                    VerifyWarningLoggedForDriveEnumeratingWildcard(buildResult, mockLogger, targetName);
+                }
+                else if (expectedBuildResult == ExpectedBuildResult.SucceedWithNoErrorsAndWarnings)
+                {
+                    VerifyNoErrorsAndWarningsForDriveEnumeratingWildcard(buildResult, mockLogger, targetName);
+                }
+            }
+            finally
+            {
+                ChangeWaves.ResetStateForTests();
+            }
+        }
+
+        private static void VerifyErrorLoggedForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
+        {
+            buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+            buildResult[targetName].ResultCode.ShouldBe(TargetResultCode.Failure);
+            mockLogger.ErrorCount.ShouldBe(1);
+            mockLogger.Errors[0].Code.ShouldBe("MSB5029");
+        }
+
+        private static void VerifyWarningLoggedForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
+        {
+            VerifySuccessOfBuildAndTargetResults(buildResult, targetName);
+            mockLogger.WarningCount.ShouldBe(1);
+            mockLogger.Warnings[0].Code.ShouldBe("MSB5029");
+        }
+
+        private static void VerifyNoErrorsAndWarningsForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
+        {
+            VerifySuccessOfBuildAndTargetResults(buildResult, targetName);
+            mockLogger.WarningCount.ShouldBe(0);
+            mockLogger.ErrorCount.ShouldBe(0);
+        }
+
+        private static void VerifySuccessOfBuildAndTargetResults(BuildResult buildResult, string targetName)
+        {
+            buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+            buildResult[targetName].ResultCode.ShouldBe(TargetResultCode.Success);
+        }
+
         /// <summary>
         /// Build a project with the provided content in memory.
         /// Assert that it fails, and return the mock logger with the output.
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 62d420dd530..3092c041e8a 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -4,6 +4,7 @@
 using System.IO;
 using System.Collections.Generic;
 using Microsoft.Build.Definition;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -19,6 +20,16 @@ namespace Microsoft.Build.UnitTests
 {
     sealed public class CreateItem_Tests
     {
+        internal const string CreateItemWithInclude = @"
+            <Project>
+                <Target Name='TestTarget' Returns='@(Text)'>
+                    <CreateItem Include='{0}'>
+                        <Output TaskParameter='Include' ItemName='Text'/>
+                    </CreateItem>
+                </Target>
+            </Project>
+            ";
+
         private readonly ITestOutputHelper _testOutput;
 
         public CreateItem_Tests(ITestOutputHelper output)
@@ -265,109 +276,171 @@ public void AdditionalMetaDataOverwriteExisting()
         }
 
         /// <summary>
-        /// Throw exception when encountering wildcard drive enumeration during task item creation.
+        /// Logs error when encountering wildcard drive enumeration during task item creation.
         /// </summary>
-        [Fact]
-        public void WildcardDriveEnumerationTaskItemThrowsException()
+        [Theory]
+        [InlineData(@"/**")]
+        [InlineData(@"/**/*.cs")]
+        [InlineData(@"/**/*/*.cs")]
+        public void WildcardDriveEnumerationTaskItemLogsError(string itemSpec)
         {
             using (var env = TestEnvironment.Create())
             {
-                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
-                CreateItem t = new CreateItem();
-                t.BuildEngine = new MockEngine();
-
-                t.Include = new ITaskItem[] { new TaskItem(@"\**") };
+                Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "1");
 
-                Assert.Throws<DriveEnumerationWildcardException>(() =>
+                try
                 {
-                    t.Execute();
-                });
+                    MockEngine engine = new MockEngine();
+                    CreateItem t = new CreateItem()
+                    {
+                        BuildEngine = engine,
+                        Include = new ITaskItem[] { new TaskItem(itemSpec) },
+                    };
+
+                    t.Execute().ShouldBeFalse();
+                    engine.Errors.ShouldBe(1);
+                    engine.AssertLogContains("MSB5029");
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
             }
         }
 
         /// <summary>
-        /// Using the CreateItem task to expand wildcards and result in a failure due to
-        /// attempted drive enumeration.
+        /// Logs warning when encountering wildcard drive enumeration during task item creation on Windows platform.
         /// </summary>
-        [Fact]
-        public void CreateItemEvaluationResultingInWildcardDriveEnumeration()
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"z:\**")]
+        [InlineData(@"z:\**\*.log")]
+        [InlineData(@"z:\\\\**\*.log")]
+        public void LogWindowsWarningUponCreateItemExecution(string itemSpec)
         {
-            using var env = TestEnvironment.Create(_testOutput);
-            env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
-
-            string content =
-                @"<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                    <Target Name =""TestTarget"" Returns=""@(Text)"">
-                      <CreateItem Include=""\**\*.txt"">
-                        <Output TaskParameter=""Include"" ItemName=""Text""/>
-                      </CreateItem>
-                    </Target>
-                  </Project>
-                ";
-
-            var testFile = env.CreateFile(env.CreateFolder(), "a.csproj", content);
-            var p = ProjectInstance.FromFile(testFile.Path, new ProjectOptions());
-
-            BuildManager buildManager = BuildManager.DefaultBuildManager;
-            BuildRequestData data = new BuildRequestData(p, new[] { "TestTarget" });
-            BuildParameters parameters = new BuildParameters();
-            BuildResult buildResult = buildManager.Build(parameters, data);
-            buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
-            buildResult["TestTarget"].Exception?.Message.ShouldContain("this resulted in an attempted drive enumeration");
+            VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(itemSpec);
         }
 
         /// <summary>
-        /// Logs warning when encountering wildcard drive enumeration during task item creation.
+        /// Logs warning when encountering wildcard drive enumeration during task item creation on Unix platform.
         /// </summary>
-        [Fact]
-        public void CreateItemEvaluationResultingInLogWildcardDriveEnumeration()
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"\**")]
+        [InlineData(@"\**\*.log")]
+        public void LogUnixWarningUponCreateItemExecution(string itemSpec)
         {
-            using var env = TestEnvironment.Create(_testOutput);
-            env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "0");
-
-            string content =
-                @"<Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                    <Target Name =""TestTarget"" Returns=""@(Text)"">
-                      <CreateItem Include=""\**\*.txt"">
-                        <Output TaskParameter=""Include"" ItemName=""Text""/>
-                      </CreateItem>
-                    </Target>
-                  </Project>
-                ";
-
-            var testFile = env.CreateFile(env.CreateFolder(), "a.csproj", content);
-            var p = ProjectInstance.FromFile(testFile.Path, new ProjectOptions());
-
-            BuildManager buildManager = BuildManager.DefaultBuildManager;
-            BuildRequestData data = new BuildRequestData(p, new[] { "TestTarget" });
-            BuildParameters parameters = new BuildParameters();
-            BuildResult buildResult = buildManager.Build(parameters, data); // Issue: Results in unauthorized access exception
-            buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+            VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(itemSpec);
         }
 
-        /// <summary>
-        /// Logs warning when encountering wildcard drive enumeration during task item creation.
-        /// </summary>
-        [Fact]
-        public void WildcardDriveEnumerationTaskItemLogsWarning()
+        private static void VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(string itemSpec)
         {
             using (var env = TestEnvironment.Create())
             {
-                env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "0");
-                CreateItem t = new CreateItem();
-                MockEngine engine = new MockEngine();
+                Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "0");
 
-                t.BuildEngine = engine;
-                t.Include = new ITaskItem[] { new TaskItem(@"\**") }; // Issue: Results in unauthorized access exception
-
-                bool succeeded = t.Execute();
-
-                Assert.True(succeeded);
-                Assert.Equal(1, engine.Warnings);
+                try
+                {
+                    MockEngine engine = new MockEngine();
+                    CreateItem t = new CreateItem()
+                    {
+                        BuildEngine = engine,
+                        Include = new ITaskItem[] { new TaskItem(itemSpec) },
+                    };
+
+                    t.Execute().ShouldBeTrue();
+                    engine.Warnings.ShouldBe(1);
+                    engine.AssertLogContains("MSB5029");
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
             }
         }
-    }
-}
 
+        /// <summary>
+        /// Throws exception when encountering wildcard drive enumeration during CreateItem task execution.
+        /// </summary>
+        [Theory]
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**\*.txt")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"$(empty)\**\*.cs")]
+        public void ThrowExceptionUponItemCreationWithDriveEnumeration(string content, string include)
+        {
+            content = string.Format(content, include);
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "1",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.FailWithError,
+                _testOutput);
+        }
 
+        /// <summary>
+        /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Windows platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            CreateItemWithInclude,
+            @"z:\**")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"z:\**\*.txt")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"z:$(empty)\**\*.cs")]
+        public void LogWindowsWarningUponItemCreationWithDriveEnumeration(string content, string include)
+        {
+            content = string.Format(content, include);
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "0",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.SucceedWithWarning,
+                _testOutput);
+        }
 
+        /// <summary>
+        /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Unix platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**\*.txt")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"$(empty)\**\*.cs")]
+        public void LogUnixWarningUponItemCreationWithDriveEnumeration(string content, string include)
+        {
+            content = string.Format(content, include);
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                    content,
+                    "0",
+                    "TestTarget",
+                    Helpers.ExpectedBuildResult.SucceedWithWarning,
+                    _testOutput);
+        }
+    }
+}
diff --git a/src/Tasks/CreateItem.cs b/src/Tasks/CreateItem.cs
index 0112a8c0e71..8f2ef0163ff 100644
--- a/src/Tasks/CreateItem.cs
+++ b/src/Tasks/CreateItem.cs
@@ -61,18 +61,13 @@ public override bool Execute()
             }
 
             // Expand wild cards.
-            (Include, FileMatcher.SearchAction includeAction, string includeFileSpec) = ExpandWildcards(Include);
-            (Exclude, FileMatcher.SearchAction excludeAction, string excludeFileSpec) = ExpandWildcards(Exclude);
+            (Include, bool expandedInclude) = TryExpandingWildcards(Include, XMakeAttributes.include);
+            (Exclude, bool expandedExclude) = TryExpandingWildcards(Exclude, XMakeAttributes.exclude);
 
-            // Log potential drive enumeration glob anomalies when applicable.
-            if (includeAction == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
-            {
-                Log.LogWarning($"Drive enumeration was detected during wildcard expansion in CreateItem for Include attribute with the filespec {includeFileSpec}");
-            }
-
-            if (excludeAction == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
+            // Execution stops if wildcard expansion fails due to drive enumeration and related env var is set.
+            if (!(expandedInclude && expandedExclude))
             {
-                Log.LogWarning($"Drive enumeration was detected during wildcard expansion in CreateItem for Exclude attribute with the filespec {excludeFileSpec}");
+                return false;
             }
 
             // Simple case:  no additional attribute to add and no Exclude.  In this case the
@@ -139,53 +134,82 @@ private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTab
             return outputItems;
         }
 
+        /// <summary>
+        /// Attempts to expand wildcards and logs warnings or errors for attempted drive enumeration.
+        /// </summary>
+        private (ITaskItem[] Element, bool NoLoggedErrors) TryExpandingWildcards(ITaskItem[] expand, string attributeType)
+        {
+            const string CreateItemTask = nameof(CreateItem);
+
+            string fileSpec;
+            FileMatcher.SearchAction searchAction;
+
+            (expand, searchAction, fileSpec) = ExpandWildcards(expand);
+
+            // Log potential drive enumeration glob anomalies when applicable.
+            if (searchAction == FileMatcher.SearchAction.LogDriveEnumeratingWildcard)
+            {
+                Log.LogWarningWithCodeFromResources(
+                    "WildcardResultsInDriveEnumeration",
+                    EscapingUtilities.UnescapeAll(fileSpec),
+                    attributeType,
+                    CreateItemTask);
+            }
+            else if (searchAction == FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard)
+            {
+                Log.LogErrorWithCodeFromResources(
+                    "WildcardResultsInDriveEnumeration",
+                    EscapingUtilities.UnescapeAll(fileSpec),
+                    attributeType,
+                    CreateItemTask);
+            }
+
+            return (expand, !Log.HasLoggedErrors);
+        }
+
         /// <summary>
         /// Expand wildcards in the item list.
         /// </summary>
-        private static (ITaskItem[], FileMatcher.SearchAction, string) ExpandWildcards(ITaskItem[] expand)
+        private static (ITaskItem[] Element, FileMatcher.SearchAction Action, string FileSpec) ExpandWildcards(ITaskItem[] expand)
         {
+            // Used to detect and log drive enumerating wildcard patterns.
+            string[] files;
+            FileMatcher.SearchAction action = FileMatcher.SearchAction.None;
+            string itemSpec = string.Empty;
+
             if (expand == null)
             {
-                return (null, FileMatcher.SearchAction.None, string.Empty);
+                return (null, action, itemSpec);
             }
             else
             {
-                FileMatcher.SearchAction logDriveEnumerationAction = FileMatcher.SearchAction.None;
-                string logDriveEnumerationFileSpec = string.Empty;
                 var expanded = new List<ITaskItem>();
                 foreach (ITaskItem i in expand)
                 {
                     if (FileMatcher.HasWildcards(i.ItemSpec))
                     {
-                        try
+                        (files, action, _) = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);
+                        itemSpec = i.ItemSpec;
+                        if (action == FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard)
                         {
-                            (string[] files, FileMatcher.SearchAction action) = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);
-                            if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
-                            {
-                                logDriveEnumerationAction = action;
-                                logDriveEnumerationFileSpec = i.ItemSpec;
-                            }
+                            return (expanded.ToArray(), action, itemSpec);
+                        }
 
-                            foreach (string file in files)
-                            {
-                                TaskItem newItem = new TaskItem(i) { ItemSpec = file };
+                        foreach (string file in files)
+                        {
+                            TaskItem newItem = new TaskItem(i) { ItemSpec = file };
 
-                                // Compute the RecursiveDir portion.
-                                FileMatcher.Result match = FileMatcher.Default.FileMatch(i.ItemSpec, file);
-                                if (match.isLegalFileSpec && match.isMatch)
+                            // Compute the RecursiveDir portion.
+                            FileMatcher.Result match = FileMatcher.Default.FileMatch(i.ItemSpec, file);
+                            if (match.isLegalFileSpec && match.isMatch)
+                            {
+                                if (!string.IsNullOrEmpty(match.wildcardDirectoryPart))
                                 {
-                                    if (!string.IsNullOrEmpty(match.wildcardDirectoryPart))
-                                    {
-                                        newItem.SetMetadata(FileUtilities.ItemSpecModifiers.RecursiveDir, match.wildcardDirectoryPart);
-                                    }
+                                    newItem.SetMetadata(FileUtilities.ItemSpecModifiers.RecursiveDir, match.wildcardDirectoryPart);
                                 }
-
-                                expanded.Add(newItem);
                             }
-                        }
-                        catch (DriveEnumerationWildcardException)
-                        {
-                            throw;
+
+                            expanded.Add(newItem);
                         }
                     }
                     else
@@ -193,7 +217,7 @@ private static (ITaskItem[], FileMatcher.SearchAction, string) ExpandWildcards(I
                         expanded.Add(i);
                     }
                 }
-                return (expanded.ToArray(), logDriveEnumerationAction, logDriveEnumerationFileSpec);
+                return (expanded.ToArray(), action, itemSpec);
             }
         }
 
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index e60f7e0daa5..9c4dc1d21d9 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -128,9 +128,6 @@
     <Compile Include="..\Shared\FileMatcher.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="..\Shared\DriveEnumerationWildcardException.cs">
-      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
-    </Compile>
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Modifiers.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
@@ -194,6 +191,12 @@
     <Compile Include="..\Shared\LanguageParser\VisualBasictokenizer.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\XMakeAttributes.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="..\Shared\XMakeElements.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="AppConfig\*.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index 743244e1b5c..67cb313a50e 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -3609,35 +3609,6 @@ public void FlatTrackingExcludeDirectories()
             Assert.Equal(originalNewest, data.NewestFileTimeUtc); // "Timestamp changed when no tracked files changed."
         }
 
-        /// <summary>
-        /// Throws exception upon creation of a new FlatTrackingData object with a task item,
-        /// which has an invalid item spec that attempts to enumerate the drive.
-        /// </summary>
-        [Fact]
-        public void ThrowExceptionOnDriveEnumerationDuringWildcardExpansion()
-        {
-            Console.WriteLine("Test: ThrowExceptionOnDriveEnumerationDuringWildcardExpansion");
-
-            using var env = TestEnvironment.Create();
-            env.SetEnvironmentVariable("MsBuildCheckWildcardDriveEnumeration", "1");
-
-            // Get the newest time w/o any exclude paths
-            Dictionary<string, DateTime> sharedLastWriteTimeUtcCache = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);
-
-            // Adds wildcard that attempts drive enumeration in task item
-            Assert.Throws<DriveEnumerationWildcardException>(() =>
-            {
-                FlatTrackingData data = new FlatTrackingData
-                (
-                    DependencyTestHelper.ItemArray(new TaskItem(@"\**\*.log")),
-                    null,
-                    DateTime.MinValue,
-                    null,
-                    sharedLastWriteTimeUtcCache
-                );
-            });
-        }
-
         [Fact]
         public void TrackingDataCacheResetOnTlogChange()
         {
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index a47393aac3e..5e5bcafb605 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -71,9 +71,6 @@
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
       <Link>Shared\CopyOnWriteDictionary.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\DriveEnumerationWildcardException.cs">
-      <Link>Shared\DriveEnumerationWildcardException.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\EncodingUtilities.cs">
       <Link>Shared\EncodingUtilities.cs</Link>
     </Compile>
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 68059971d3d..99c1745f803 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -151,7 +151,7 @@ private void InternalConstruct(ITask ownerTask, ITaskItem[] tlogFiles, ITaskItem
                 };
             }
 
-            _tlogFiles = TrackedDependencies.ExpandWildcards(tlogFiles, _log);
+            _tlogFiles = TrackedDependencies.ExpandWildcards(tlogFiles);
             _tlogAvailable = TrackedDependencies.ItemsExist(_tlogFiles);
             _sourceFiles = sourceFiles;
             _outputs = outputs;
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index e68acf7208f..2ccbbce8f3b 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -79,7 +79,7 @@ private void InternalConstruct(ITask ownerTask, ITaskItem[] tlogFiles, bool cons
                 };
             }
 
-            _tlogFiles = TrackedDependencies.ExpandWildcards(tlogFiles, _log);
+            _tlogFiles = TrackedDependencies.ExpandWildcards(tlogFiles);
             _tlogAvailable = TrackedDependencies.ItemsExist(_tlogFiles);
             DependencyTable = new Dictionary<string, Dictionary<string, DateTime>>(StringComparer.OrdinalIgnoreCase);
             if (_tlogFiles != null && constructOutputsFromTLogs)
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index 864722d290a..1c6529ac55d 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -268,11 +268,11 @@ private void InternalConstruct(ITask ownerTask, ITaskItem[] tlogFilesLocal, ITas
                 };
             }
 
-            ITaskItem[] expandedTlogFiles = TrackedDependencies.ExpandWildcards(tlogFilesLocal, _log);
+            ITaskItem[] expandedTlogFiles = TrackedDependencies.ExpandWildcards(tlogFilesLocal);
 
             if (tlogFilesToIgnore != null)
             {
-                ITaskItem[] expandedTlogFilesToIgnore = TrackedDependencies.ExpandWildcards(tlogFilesToIgnore, _log);
+                ITaskItem[] expandedTlogFilesToIgnore = TrackedDependencies.ExpandWildcards(tlogFilesToIgnore);
 
                 if (expandedTlogFilesToIgnore.Length > 0)
                 {
diff --git a/src/Utilities/TrackedDependencies/TrackedDependencies.cs b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
index d1ff53f0708..ccc53acd3ae 100644
--- a/src/Utilities/TrackedDependencies/TrackedDependencies.cs
+++ b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
@@ -22,9 +22,8 @@ public static class TrackedDependencies
         /// Expand wildcards in the item list.
         /// </summary>
         /// <param name="expand"></param>
-        /// <param name="log"></param>
         /// <returns>Array of items expanded</returns>
-        public static ITaskItem[] ExpandWildcards(ITaskItem[] expand, TaskLoggingHelper log)
+        public static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
         {
             if (expand == null)
             {
@@ -36,36 +35,25 @@ public static ITaskItem[] ExpandWildcards(ITaskItem[] expand, TaskLoggingHelper
             {
                 if (FileMatcher.HasWildcards(item.ItemSpec))
                 {
-                    try
-                    {
-                        string[] files;
-                        string directoryName = Path.GetDirectoryName(item.ItemSpec);
-                        string searchPattern = Path.GetFileName(item.ItemSpec);
-
-                        // Very often with TLog files we're talking about
-                        // a directory and a simply wildcarded filename
-                        // Optimize for that case here.
-                        if (!FileMatcher.HasWildcards(directoryName) && FileSystems.Default.DirectoryExists(directoryName))
-                        {
-                            files = Directory.GetFiles(directoryName, searchPattern);
-                        }
-                        else
-                        {
-                            (files, FileMatcher.SearchAction action) = FileMatcher.Default.GetFiles(null, item.ItemSpec);
-                            if (action == FileMatcher.SearchAction.ReturnLogDriveEnumerationWildcard)
-                            {
-                                log.LogWarning($"Drive enumeration was attempted while assisting with tracking dependencies during wildcard expansion, which relied on the item spec {item.ItemSpec}.");
-                            }
-                        }
+                    string[] files;
+                    string directoryName = Path.GetDirectoryName(item.ItemSpec);
+                    string searchPattern = Path.GetFileName(item.ItemSpec);
 
-                        foreach (string file in files)
-                        {
-                            expanded.Add(new TaskItem(item) { ItemSpec = file });
-                        }
+                    // Very often with TLog files we're talking about
+                    // a directory and a simply wildcarded filename
+                    // Optimize for that case here.
+                    if (!FileMatcher.HasWildcards(directoryName) && FileSystems.Default.DirectoryExists(directoryName))
+                    {
+                        files = Directory.GetFiles(directoryName, searchPattern);
                     }
-                    catch (DriveEnumerationWildcardException)
+                    else
+                    {
+                        files = FileMatcher.Default.GetFiles(null, item.ItemSpec).FileList;
+                    }
+
+                    foreach (string file in files)
                     {
-                        throw;
+                        expanded.Add(new TaskItem(item) { ItemSpec = file });
                     }
                 }
                 else
