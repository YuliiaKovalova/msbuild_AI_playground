diff --git a/src/Tasks/ResolveAssemblyReferences/BuildEventArgsFormatter.cs b/src/Tasks/ResolveAssemblyReferences/BuildEventArgsFormatter.cs
deleted file mode 100644
index 1039d0b61a2..00000000000
--- a/src/Tasks/ResolveAssemblyReferences/BuildEventArgsFormatter.cs
+++ /dev/null
@@ -1,145 +0,0 @@
-﻿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using MessagePack;
-using MessagePack.Formatters;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Nerdbank.Streams;
-using System;
-using System.Buffers;
-using System.ComponentModel;
-using System.IO;
-using System.Reflection;
-
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences
-{
-    internal static partial class BuildEventArgsFormatter
-    {
-        public static IMessagePackFormatter<BuildErrorEventArgs> ErrorFormatter { get; } = new BuildError();
-        public static IMessagePackFormatter<BuildWarningEventArgs> WarningFormatter { get; } = new BuildWarning();
-        public static IMessagePackFormatter<BuildMessageEventArgs> MessageFormatter { get; } = new BuildMessage();
-        public static IMessagePackFormatter<CustomBuildEventArgs> CustomFormatter { get; } = new Custom();
-
-
-        private abstract class Formatter<TArg> : IMessagePackFormatter<TArg> where TArg : BuildEventArgs
-        {
-            public TArg Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
-            {
-                ReadOnlySequence<byte>? buffer = reader.ReadBytes();
-
-                if (!buffer.HasValue)
-                {
-                    return null;
-                }
-
-                try
-                {
-                    BinaryReader binaryReader = new BinaryReader(buffer.Value.AsStream());
-                    TArg arg = GetEventArgInstance();
-                    // We are communicating with current MSBuild RAR node, if not something is really wrong
-                    arg.CreateFromStream(binaryReader, int.MaxValue);
-                    return arg;
-                }
-                catch (Exception)
-                {
-                    return null;
-                }
-            }
-
-            public void Serialize(ref MessagePackWriter writer, TArg value, MessagePackSerializerOptions options)
-            {
-                if (value is null)
-                {
-                    writer.Write((byte[])null);
-                    return;
-                }
-
-                using MemoryStream stream = new MemoryStream();
-                using BinaryWriter binaryWriter = new BinaryWriter(stream);
-
-                value.WriteToStream(binaryWriter);
-                writer.Write(stream.ToArray());
-            }
-
-            protected abstract TArg GetEventArgInstance();
-        }
-
-        private sealed class BuildError : Formatter<BuildErrorEventArgs>, IMessagePackFormatter<BuildErrorEventArgs>
-        {
-            protected override BuildErrorEventArgs GetEventArgInstance() => new BuildErrorEventArgs();
-        }
-
-        private sealed class BuildMessage : Formatter<BuildMessageEventArgs>, IMessagePackFormatter<BuildMessageEventArgs>
-        {
-            protected override BuildMessageEventArgs GetEventArgInstance() => new BuildMessageEventArgs();
-        }
-
-        private sealed class BuildWarning : Formatter<BuildWarningEventArgs>, IMessagePackFormatter<BuildWarningEventArgs>
-        {
-            protected override BuildWarningEventArgs GetEventArgInstance() => new BuildWarningEventArgs();
-        }
-
-        private sealed class Custom : IMessagePackFormatter<CustomBuildEventArgs>
-        {
-            private static IMessagePackFormatter<ExternalProjectFinishedEventArgs> ExternalProjectFinishedFormatter = new ExternalProjectFinished();
-            private static IMessagePackFormatter<ExternalProjectStartedEventArgs> ExternalProjectStartedFormatter = new ExternalProjectStarted();
-
-            public CustomBuildEventArgs Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
-            {
-                ushort formatter = reader.ReadUInt16();
-
-                switch (formatter)
-                {
-                    case 1:
-                        return ExternalProjectStartedFormatter.Deserialize(ref reader, options);
-                    case 2:
-                        return ExternalProjectFinishedFormatter.Deserialize(ref reader, options);
-                    default:
-                        ErrorUtilities.ThrowInternalError("Unexpected formatter id");
-                        return null; // Never hits...
-                }
-            }
-
-            public void Serialize(ref MessagePackWriter writer, CustomBuildEventArgs value, MessagePackSerializerOptions options)
-            {
-                ushort formatterId = value switch
-                {
-                    ExternalProjectStartedEventArgs _ => 1,
-                    ExternalProjectFinishedEventArgs _ => 2,
-                    _ => 0
-                };
-
-                if (formatterId == 0)
-                {
-                    ErrorUtilities.ThrowArgumentOutOfRange(nameof(value));
-                }
-
-                writer.WriteUInt16(formatterId);
-
-                switch (formatterId)
-                {
-                    case 1:
-                        ExternalProjectStartedFormatter.Serialize(ref writer, value as ExternalProjectStartedEventArgs, options);
-                        break;
-                    case 2:
-                        ExternalProjectFinishedFormatter.Serialize(ref writer, value as ExternalProjectFinishedEventArgs, options);
-                        break;
-                    default:
-                        ErrorUtilities.ThrowInternalErrorUnreachable();
-                        break;
-                }
-            }
-
-            private class ExternalProjectFinished : Formatter<ExternalProjectFinishedEventArgs>, IMessagePackFormatter<ExternalProjectFinishedEventArgs>
-            {
-                protected override ExternalProjectFinishedEventArgs GetEventArgInstance() => new ExternalProjectFinishedEventArgs();
-            }
-
-            private class ExternalProjectStarted : Formatter<ExternalProjectStartedEventArgs>, IMessagePackFormatter<ExternalProjectStartedEventArgs>
-            {
-                protected override ExternalProjectStartedEventArgs GetEventArgInstance() => new ExternalProjectStartedEventArgs();
-            }
-        }
-    }
-}
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs
new file mode 100644
index 00000000000..0eb4bf41e66
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/BuildEventArgsFormatter.cs
@@ -0,0 +1,404 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using MessagePack;
+using MessagePack.Formatters;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences
+{
+    internal sealed class BuildEventArgsFormatter
+        : IMessagePackFormatter<BuildErrorEventArgs>, IMessagePackFormatter<BuildWarningEventArgs>, IMessagePackFormatter<BuildMessageEventArgs>,
+         IMessagePackFormatter<CustomBuildEventArgs>, IMessagePackFormatter<ExternalProjectStartedEventArgs>, IMessagePackFormatter<ExternalProjectFinishedEventArgs>
+    {
+
+        internal static readonly IMessagePackFormatter Instance = new BuildEventArgsFormatter();
+
+        private BuildEventArgsFormatter() { }
+
+        private bool DeserializeBase(ref MessagePackReader reader, out string message, out string helpKeyword, out string senderName)
+        {
+            message = null;
+            helpKeyword = null;
+            senderName = null;
+
+            if (reader.TryReadNil())
+            {
+                return true;
+            }
+
+            message = reader.ReadString();
+            helpKeyword = reader.ReadString();
+            senderName = reader.ReadString();
+
+            return false;
+        }
+
+        private bool SerializeBase(ref MessagePackWriter wrtier, BuildEventArgs buildEvent)
+        {
+            if (buildEvent == null)
+            {
+                wrtier.WriteNil();
+                return true;
+            }
+
+            wrtier.Write(buildEvent.Message);
+            wrtier.Write(buildEvent.HelpKeyword);
+            wrtier.Write(buildEvent.SenderName);
+
+            return false;
+        }
+
+
+        BuildWarningEventArgs IMessagePackFormatter<BuildWarningEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (DeserializeBase(ref reader, out string message, out string helpKeyword, out string senderName))
+            {
+                return null;
+            }
+
+            string code = reader.ReadString();
+            int columnNumber = reader.ReadInt32();
+            int endColumnNumber = reader.ReadInt32();
+            int endLineNumber = reader.ReadInt32();
+            string file = reader.ReadString();
+            int lineNumber = reader.ReadInt32();
+            string subCategory = reader.ReadString();
+
+            BuildWarningEventArgs buildEvent =
+                new BuildWarningEventArgs(
+                        subCategory,
+                        code,
+                        file,
+                        lineNumber,
+                        columnNumber,
+                        endLineNumber,
+                        endColumnNumber,
+                        message,
+                        helpKeyword,
+                        senderName);
+
+            return buildEvent;
+        }
+
+        void IMessagePackFormatter<BuildWarningEventArgs>.Serialize(ref MessagePackWriter writer, BuildWarningEventArgs value, MessagePackSerializerOptions options)
+        {
+            if (SerializeBase(ref writer, value))
+            {
+                return;
+            }
+
+            writer.Write(value.Code);
+            writer.WriteInt32(value.ColumnNumber);
+            writer.WriteInt32(value.EndColumnNumber);
+            writer.WriteInt32(value.EndLineNumber);
+            writer.Write(value.File);
+            writer.WriteInt32(value.LineNumber);
+            writer.Write(value.Subcategory);
+        }
+
+        BuildErrorEventArgs IMessagePackFormatter<BuildErrorEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (DeserializeBase(ref reader, out string message, out string helpKeyword, out string senderName))
+            {
+                return null;
+            }
+
+            string code = reader.ReadString();
+            int columnNumber = reader.ReadInt32();
+            int endColumnNumber = reader.ReadInt32();
+            int endLineNumber = reader.ReadInt32();
+            string file = reader.ReadString();
+            int lineNumber = reader.ReadInt32();
+            string subCategory = reader.ReadString();
+
+            BuildErrorEventArgs buildEvent =
+                new BuildErrorEventArgs(
+                        subCategory,
+                        code,
+                        file,
+                        lineNumber,
+                        columnNumber,
+                        endLineNumber,
+                        endColumnNumber,
+                        message,
+                        helpKeyword,
+                        senderName);
+
+            return buildEvent;
+        }
+
+
+        void IMessagePackFormatter<BuildErrorEventArgs>.Serialize(ref MessagePackWriter writer, BuildErrorEventArgs value, MessagePackSerializerOptions options)
+        {
+            if (SerializeBase(ref writer, value))
+            {
+                return;
+            }
+
+            writer.Write(value.Code);
+            writer.WriteInt32(value.ColumnNumber);
+            writer.WriteInt32(value.EndColumnNumber);
+            writer.WriteInt32(value.EndLineNumber);
+            writer.Write(value.File);
+            writer.WriteInt32(value.LineNumber);
+            writer.Write(value.Subcategory);
+        }
+
+        BuildMessageEventArgs IMessagePackFormatter<BuildMessageEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (DeserializeBase(ref reader, out string message, out string helpKeyword, out string senderName))
+            {
+                return null;
+            }
+
+            int importance = reader.ReadInt32();
+
+            return new BuildMessageEventArgs(message, helpKeyword, senderName, (MessageImportance)importance);
+        }
+
+        void IMessagePackFormatter<BuildMessageEventArgs>.Serialize(ref MessagePackWriter writer, BuildMessageEventArgs value, MessagePackSerializerOptions options)
+        {
+            if (SerializeBase(ref writer, value))
+            {
+                return;
+            }
+
+            int importance = (int)value.Importance;
+
+            writer.WriteInt32(importance);
+        }
+
+        CustomBuildEventArgs IMessagePackFormatter<CustomBuildEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (reader.TryReadNil())
+            {
+                return null;
+            }
+
+            int customType = reader.ReadInt32();
+
+            switch (customType)
+            {
+                case 1:
+                    return (this as IMessagePackFormatter<ExternalProjectStartedEventArgs>).Deserialize(ref reader, options);
+                case 2:
+                    return (this as IMessagePackFormatter<ExternalProjectFinishedEventArgs>).Deserialize(ref reader, options);
+                default:
+                    ErrorUtilities.ThrowInternalError("Unexpected formatter id");
+                    return null;
+            }
+        }
+
+        void IMessagePackFormatter<CustomBuildEventArgs>.Serialize(ref MessagePackWriter writer, CustomBuildEventArgs value, MessagePackSerializerOptions options)
+        {
+            if(value == null)
+            {
+                writer.WriteNil();
+                return;
+            }
+
+            int customType = value switch
+            {
+                ExternalProjectStartedEventArgs _ => 1,
+                ExternalProjectFinishedEventArgs _ => 2,
+                _ => 0
+            };
+
+            writer.WriteInt32(customType);
+
+            switch (customType)
+            {
+                case 1:
+                    (this as IMessagePackFormatter<ExternalProjectStartedEventArgs>).Serialize(ref writer, value as ExternalProjectStartedEventArgs, options);
+                    break;
+                case 2:
+                    (this as IMessagePackFormatter<ExternalProjectFinishedEventArgs>).Serialize(ref writer, value as ExternalProjectFinishedEventArgs, options);
+                    break;
+                default:
+                    ErrorUtilities.ThrowInternalError("Unexpected formatter id");
+                    break;
+            }
+        }
+
+        ExternalProjectStartedEventArgs IMessagePackFormatter<ExternalProjectStartedEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (DeserializeBase(ref reader, out string message, out string helpKeyword, out string senderName))
+            {
+                return null;
+            }
+
+            string projectFile = reader.ReadString();
+            string targetNames = reader.ReadString();
+
+            return new ExternalProjectStartedEventArgs(
+                   message,
+                   helpKeyword,
+                   senderName,
+                   projectFile,
+                   targetNames);
+        }
+
+        void IMessagePackFormatter<ExternalProjectStartedEventArgs>.Serialize(ref MessagePackWriter writer, ExternalProjectStartedEventArgs value, MessagePackSerializerOptions options)
+        {
+            if (SerializeBase(ref writer, value))
+            {
+                return;
+            }
+
+            writer.Write(value.ProjectFile);
+            writer.Write(value.TargetNames);
+        }
+
+        ExternalProjectFinishedEventArgs IMessagePackFormatter<ExternalProjectFinishedEventArgs>.Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (DeserializeBase(ref reader, out string message, out string helpKeyword, out string senderName))
+            {
+                return null;
+            }
+
+            string projectFile = reader.ReadString();
+            bool succeeded = reader.ReadBoolean();
+
+            return new ExternalProjectFinishedEventArgs(
+                    message,
+                    helpKeyword,
+                    senderName,
+                    projectFile,
+                    succeeded);
+        }
+
+        void IMessagePackFormatter<ExternalProjectFinishedEventArgs>.Serialize(ref MessagePackWriter writer, ExternalProjectFinishedEventArgs value, MessagePackSerializerOptions options)
+        {
+            if (SerializeBase(ref writer, value))
+            {
+                return;
+            }
+
+            writer.Write(value.ProjectFile);
+            writer.Write(value.Succeeded);
+        }
+
+
+        //private abstract class Formatter<TArg> : IMessagePackFormatter<TArg> where TArg : BuildEventArgs
+        //{
+        //    public TArg Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        //    {
+        //        ReadOnlySequence<byte>? buffer = reader.ReadBytes();
+
+        //        if (!buffer.HasValue)
+        //        {
+        //            return null;
+        //        }
+
+        //        try
+        //        {
+        //            BinaryReader binaryReader = new BinaryReader(buffer.Value.AsStream());
+        //            TArg arg = GetEventArgInstance();
+        //            // We are communicating with current MSBuild RAR node, if not something is really wrong
+        //            arg.CreateFromStream(binaryReader, int.MaxValue);
+        //            return arg;
+        //        }
+        //        catch (Exception)
+        //        {
+        //            return null;
+        //        }
+        //    }
+
+        //    public void Serialize(ref MessagePackWriter writer, TArg value, MessagePackSerializerOptions options)
+        //    {
+        //        if (value is null)
+        //        {
+        //            writer.Write((byte[])null);
+        //            return;
+        //        }
+
+        //        using MemoryStream stream = new MemoryStream();
+        //        using BinaryWriter binaryWriter = new BinaryWriter(stream);
+
+        //        value.WriteToStream(binaryWriter);
+        //        writer.Write(stream.ToArray());
+        //    }
+
+        //    protected abstract TArg GetEventArgInstance();
+        //}
+
+        //private sealed class BuildError : Formatter<BuildErrorEventArgs>, IMessagePackFormatter<BuildErrorEventArgs>
+        //{
+        //    protected override BuildErrorEventArgs GetEventArgInstance() => new BuildErrorEventArgs();
+        //}
+
+        //private sealed class BuildMessage : Formatter<BuildMessageEventArgs>, IMessagePackFormatter<BuildMessageEventArgs>
+        //{
+        //    protected override BuildMessageEventArgs GetEventArgInstance() => new BuildMessageEventArgs();
+        //}
+
+        //private sealed class BuildWarning : Formatter<BuildWarningEventArgs>, IMessagePackFormatter<BuildWarningEventArgs>
+        //{
+        //    protected override BuildWarningEventArgs GetEventArgInstance() => new BuildWarningEventArgs();
+        //}
+
+        //private sealed class Custom : IMessagePackFormatter<CustomBuildEventArgs>
+        //{
+        //    private static IMessagePackFormatter<ExternalProjectFinishedEventArgs> ExternalProjectFinishedFormatter = new ExternalProjectFinished();
+        //    private static IMessagePackFormatter<ExternalProjectStartedEventArgs> ExternalProjectStartedFormatter = new ExternalProjectStarted();
+
+        //    public CustomBuildEventArgs Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        //    {
+        //        ushort formatter = reader.ReadUInt16();
+
+        //        switch (formatter)
+        //        {
+        //            case 1:
+        //                return ExternalProjectStartedFormatter.Deserialize(ref reader, options);
+        //            case 2:
+        //                return ExternalProjectFinishedFormatter.Deserialize(ref reader, options);
+        //            default:
+        //                ErrorUtilities.ThrowInternalError("Unexpected formatter id");
+        //                return null; // Never hits...
+        //        }
+        //    }
+
+        //    public void Serialize(ref MessagePackWriter writer, CustomBuildEventArgs value, MessagePackSerializerOptions options)
+        //    {
+        //        ushort formatterId = value switch
+        //        {
+        //            ExternalProjectStartedEventArgs _ => 1,
+        //            ExternalProjectFinishedEventArgs _ => 2,
+        //            _ => 0
+        //        };
+
+        //        if (formatterId == 0)
+        //        {
+        //            ErrorUtilities.ThrowArgumentOutOfRange(nameof(value));
+        //        }
+
+        //        writer.WriteUInt16(formatterId);
+
+        //        switch (formatterId)
+        //        {
+        //            case 1:
+        //                ExternalProjectStartedFormatter.Serialize(ref writer, value as ExternalProjectStartedEventArgs, options);
+        //                break;
+        //            case 2:
+        //                ExternalProjectFinishedFormatter.Serialize(ref writer, value as ExternalProjectFinishedEventArgs, options);
+        //                break;
+        //            default:
+        //                ErrorUtilities.ThrowInternalErrorUnreachable();
+        //                break;
+        //        }
+        //    }
+
+        //    private class ExternalProjectFinished : Formatter<ExternalProjectFinishedEventArgs>, IMessagePackFormatter<ExternalProjectFinishedEventArgs>
+        //    {
+        //        protected override ExternalProjectFinishedEventArgs GetEventArgInstance() => new ExternalProjectFinishedEventArgs();
+        //    }
+
+        //    private class ExternalProjectStarted : Formatter<ExternalProjectStartedEventArgs>, IMessagePackFormatter<ExternalProjectStartedEventArgs>
+        //    {
+        //        protected override ExternalProjectStartedEventArgs GetEventArgInstance() => new ExternalProjectStartedEventArgs();
+        //    }
+        //}
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs
new file mode 100644
index 00000000000..2008ab597df
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs
@@ -0,0 +1,64 @@
+using MessagePack;
+using MessagePack.Formatters;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
+{
+    internal sealed class ReadOnlyTaskItemFormatter : IMessagePackFormatter<ReadOnlyTaskItem>
+    {
+        public void Serialize(ref MessagePackWriter writer, ReadOnlyTaskItem value, MessagePackSerializerOptions options)
+        {
+            if (value == null)
+            {
+                writer.WriteNil();
+                return;
+            }
+
+            IFormatterResolver formatterResolver = options.Resolver;
+            writer.WriteArrayHeader(2);
+            writer.Write(value.ItemSpec);
+            formatterResolver.GetFormatter<Dictionary<string, string>>().Serialize(ref writer, value.MetadataNameToValue, options);
+        }
+
+        public ReadOnlyTaskItem Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (reader.TryReadNil())
+            {
+                return null;
+            }
+
+            options.Security.DepthStep(ref reader);
+            IFormatterResolver formatterResolver = options.Resolver;
+            int length = reader.ReadArrayHeader();
+            string itemSpec = null;
+            Dictionary<string, string> metadataNameToValue = null;
+
+            for (int i = 0; i < length; i++)
+            {
+                var key = i;
+
+                switch (key)
+                {
+                    case 0:
+                        itemSpec = reader.ReadString();
+                        break;
+                    case 1:
+                        metadataNameToValue = formatterResolver.GetFormatter<Dictionary<string, string>>().Deserialize(ref reader, options);
+                        break;
+                    default:
+                        reader.Skip();
+                        break;
+                }
+            }
+
+            ReadOnlyTaskItem result = new ReadOnlyTaskItem(itemSpec)
+            {
+                ItemSpec = itemSpec,
+                MetadataNameToValue = metadataNameToValue
+            };
+            reader.Depth--;
+            return result;
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceRequestFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceRequestFormatter.cs
new file mode 100644
index 00000000000..657c7f6b4bf
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceRequestFormatter.cs
@@ -0,0 +1,299 @@
+using System;
+using System.Buffers;
+using MessagePack;
+using MessagePack.Formatters;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
+{
+    internal sealed class ResolveAssemblyReferenceRequestFormatter : IMessagePackFormatter<ResolveAssemblyReferenceRequest>
+    {
+        public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceRequest value, MessagePackSerializerOptions options)
+        {
+            if (value == null)
+            {
+                writer.WriteNil();
+                return;
+            }
+
+            IFormatterResolver formatterResolver = options.Resolver;
+            writer.WriteArrayHeader(41);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.AllowedAssemblyExtensions, options);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.AllowedRelatedFileExtensions, options);
+            writer.Write(value.AppConfigFile);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.Assemblies, options);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.AssemblyFiles, options);
+            writer.Write(value.AutoUnify);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.CandidateAssemblyFiles, options);
+            writer.Write(value.CopyLocalDependenciesWhenParentReferenceInGac);
+            writer.Write(value.DoNotCopyLocalIfInGac);
+            writer.Write(value.FindDependencies);
+            writer.Write(value.FindDependenciesOfExternallyResolvedReferences);
+            writer.Write(value.FindRelatedFiles);
+            writer.Write(value.FindSatellites);
+            writer.Write(value.FindSerializationAssemblies);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.FullFrameworkAssemblyTables, options);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.FullFrameworkFolders, options);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.FullTargetFrameworkSubsetNames, options);
+            writer.Write(value.IgnoreDefaultInstalledAssemblySubsetTables);
+            writer.Write(value.IgnoreDefaultInstalledAssemblyTables);
+            writer.Write(value.IgnoreTargetFrameworkAttributeVersionMismatch);
+            writer.Write(value.IgnoreVersionForFrameworkReferences);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.InstalledAssemblySubsetTables, options);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.InstalledAssemblyTables, options);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.LatestTargetFrameworkDirectories, options);
+            writer.Write(value.ProfileName);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.ResolvedSDKReferences, options);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.SearchPaths, options);
+            writer.Write(value.Silent);
+            writer.Write(value.StateFile);
+            writer.Write(value.SupportsBindingRedirectGeneration);
+            writer.Write(value.TargetedRuntimeVersion);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.TargetFrameworkDirectories, options);
+            writer.Write(value.TargetFrameworkMoniker);
+            writer.Write(value.TargetFrameworkMonikerDisplayName);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.TargetFrameworkSubsets, options);
+            writer.Write(value.TargetFrameworkVersion);
+            writer.Write(value.TargetProcessorArchitecture);
+            writer.Write(value.UnresolveFrameworkAssembliesFromHigherFrameworks);
+            writer.Write(value.UseResolveAssemblyReferenceService);
+            writer.Write(value.WarnOrErrorOnTargetArchitectureMismatch);
+            writer.Write(value.CurrentPath);
+        }
+
+        public ResolveAssemblyReferenceRequest Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (reader.TryReadNil())
+            {
+                return null;
+            }
+
+            options.Security.DepthStep(ref reader);
+            IFormatterResolver formatterResolver = options.Resolver;
+            int length = reader.ReadArrayHeader();
+            string[] allowedAssemblyExtensions = default;
+            string[] allowedRelatedFileExtensions = default;
+            string appConfigFile = default;
+            ReadOnlyTaskItem[] assemblies = default;
+            ReadOnlyTaskItem[] assemblyFiles = default;
+            bool autoUnify = default;
+            string[] candidateAssemblyFiles = default;
+            bool copyLocalDependenciesWhenParentReferenceInGac = default;
+            bool doNotCopyLocalIfInGac = default;
+            bool findDependencies = default;
+            bool findDependenciesOfExternallyResolvedReferences = default;
+            bool findRelatedFiles = default;
+            bool findSatellites = default;
+            bool findSerializationAssemblies = default;
+            ReadOnlyTaskItem[] fullFrameworkAssemblyTables = default;
+            string[] fullFrameworkFolders = default;
+            string[] fullTargetFrameworkSubsetNames = default;
+            bool ignoreDefaultInstalledAssemblySubsetTables = default;
+            bool ignoreDefaultInstalledAssemblyTables = default;
+            bool ignoreTargetFrameworkAttributeVersionMismatch = default;
+            bool ignoreVersionForFrameworkReferences = default;
+            ReadOnlyTaskItem[] installedAssemblySubsetTables = default;
+            ReadOnlyTaskItem[] installedAssemblyTables = default;
+            string[] latestTargetFrameworkDirectories = default;
+            string profileName = default;
+            ReadOnlyTaskItem[] resolvedSDKReferences = default;
+            string[] searchPaths = default;
+            bool silent = default;
+            string stateFile = default;
+            bool supportsBindingRedirectGeneration = default;
+            string targetedRuntimeVersion = default;
+            string[] targetFrameworkDirectories = default;
+            string targetFrameworkMoniker = default;
+            string targetFrameworkMonikerDisplayName = default;
+            string[] targetFrameworkSubsets = default;
+            string targetFrameworkVersion = default;
+            string targetProcessorArchitecture = default;
+            bool unresolveFrameworkAssembliesFromHigherFrameworks = default;
+            bool useResolveAssemblyReferenceService = default;
+            string warnOrErrorOnTargetArchitectureMismatch = default;
+            string currentPath = default;
+
+            for (int i = 0; i < length; i++)
+            {
+                int key = i;
+
+                switch (key)
+                {
+                    case 0:
+                        allowedAssemblyExtensions = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 1:
+                        allowedRelatedFileExtensions = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 2:
+                        appConfigFile = reader.ReadString();
+                        break;
+                    case 3:
+                        assemblies = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 4:
+                        assemblyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 5:
+                        autoUnify = reader.ReadBoolean();
+                        break;
+                    case 6:
+                        candidateAssemblyFiles = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 7:
+                        copyLocalDependenciesWhenParentReferenceInGac = reader.ReadBoolean();
+                        break;
+                    case 8:
+                        doNotCopyLocalIfInGac = reader.ReadBoolean();
+                        break;
+                    case 9:
+                        findDependencies = reader.ReadBoolean();
+                        break;
+                    case 10:
+                        findDependenciesOfExternallyResolvedReferences = reader.ReadBoolean();
+                        break;
+                    case 11:
+                        findRelatedFiles = reader.ReadBoolean();
+                        break;
+                    case 12:
+                        findSatellites = reader.ReadBoolean();
+                        break;
+                    case 13:
+                        findSerializationAssemblies = reader.ReadBoolean();
+                        break;
+                    case 14:
+                        fullFrameworkAssemblyTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 15:
+                        fullFrameworkFolders = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 16:
+                        fullTargetFrameworkSubsetNames = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 17:
+                        ignoreDefaultInstalledAssemblySubsetTables = reader.ReadBoolean();
+                        break;
+                    case 18:
+                        ignoreDefaultInstalledAssemblyTables = reader.ReadBoolean();
+                        break;
+                    case 19:
+                        ignoreTargetFrameworkAttributeVersionMismatch = reader.ReadBoolean();
+                        break;
+                    case 20:
+                        ignoreVersionForFrameworkReferences = reader.ReadBoolean();
+                        break;
+                    case 21:
+                        installedAssemblySubsetTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 22:
+                        installedAssemblyTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 23:
+                        latestTargetFrameworkDirectories = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 24:
+                        profileName = reader.ReadString();
+                        break;
+                    case 25:
+                        resolvedSDKReferences = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 26:
+                        searchPaths = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 27:
+                        silent = reader.ReadBoolean();
+                        break;
+                    case 28:
+                        stateFile = reader.ReadString();
+                        break;
+                    case 29:
+                        supportsBindingRedirectGeneration = reader.ReadBoolean();
+                        break;
+                    case 30:
+                        targetedRuntimeVersion = reader.ReadString();
+                        break;
+                    case 31:
+                        targetFrameworkDirectories = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 32:
+                        targetFrameworkMoniker = reader.ReadString();
+                        break;
+                    case 33:
+                        targetFrameworkMonikerDisplayName = reader.ReadString();
+                        break;
+                    case 34:
+                        targetFrameworkSubsets = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 35:
+                        targetFrameworkVersion = reader.ReadString();
+                        break;
+                    case 36:
+                        targetProcessorArchitecture = reader.ReadString();
+                        break;
+                    case 37:
+                        unresolveFrameworkAssembliesFromHigherFrameworks = reader.ReadBoolean();
+                        break;
+                    case 38:
+                        useResolveAssemblyReferenceService = reader.ReadBoolean();
+                        break;
+                    case 39:
+                        warnOrErrorOnTargetArchitectureMismatch = reader.ReadString();
+                        break;
+                    case 40:
+                        currentPath = reader.ReadString();
+                        break;
+                    default:
+                        reader.Skip();
+                        break;
+                }
+            }
+
+            ResolveAssemblyReferenceRequest result = new ResolveAssemblyReferenceRequest
+            {
+                AllowedAssemblyExtensions = allowedAssemblyExtensions,
+                AllowedRelatedFileExtensions = allowedRelatedFileExtensions,
+                AppConfigFile = appConfigFile,
+                Assemblies = assemblies,
+                AssemblyFiles = assemblyFiles,
+                AutoUnify = autoUnify,
+                CandidateAssemblyFiles = candidateAssemblyFiles,
+                CopyLocalDependenciesWhenParentReferenceInGac = copyLocalDependenciesWhenParentReferenceInGac,
+                DoNotCopyLocalIfInGac = doNotCopyLocalIfInGac,
+                FindDependencies = findDependencies,
+                FindDependenciesOfExternallyResolvedReferences = findDependenciesOfExternallyResolvedReferences,
+                FindRelatedFiles = findRelatedFiles,
+                FindSatellites = findSatellites,
+                FindSerializationAssemblies = findSerializationAssemblies,
+                FullFrameworkAssemblyTables = fullFrameworkAssemblyTables,
+                FullFrameworkFolders = fullFrameworkFolders,
+                FullTargetFrameworkSubsetNames = fullTargetFrameworkSubsetNames,
+                IgnoreDefaultInstalledAssemblySubsetTables = ignoreDefaultInstalledAssemblySubsetTables,
+                IgnoreDefaultInstalledAssemblyTables = ignoreDefaultInstalledAssemblyTables,
+                IgnoreTargetFrameworkAttributeVersionMismatch = ignoreTargetFrameworkAttributeVersionMismatch,
+                IgnoreVersionForFrameworkReferences = ignoreVersionForFrameworkReferences,
+                InstalledAssemblySubsetTables = installedAssemblySubsetTables,
+                InstalledAssemblyTables = installedAssemblyTables,
+                LatestTargetFrameworkDirectories = latestTargetFrameworkDirectories,
+                ProfileName = profileName,
+                ResolvedSDKReferences = resolvedSDKReferences,
+                SearchPaths = searchPaths,
+                Silent = silent,
+                StateFile = stateFile,
+                SupportsBindingRedirectGeneration = supportsBindingRedirectGeneration,
+                TargetedRuntimeVersion = targetedRuntimeVersion,
+                TargetFrameworkDirectories = targetFrameworkDirectories,
+                TargetFrameworkMoniker = targetFrameworkMoniker,
+                TargetFrameworkMonikerDisplayName = targetFrameworkMonikerDisplayName,
+                TargetFrameworkSubsets = targetFrameworkSubsets,
+                TargetFrameworkVersion = targetFrameworkVersion,
+                TargetProcessorArchitecture = targetProcessorArchitecture,
+                UnresolveFrameworkAssembliesFromHigherFrameworks = unresolveFrameworkAssembliesFromHigherFrameworks,
+                UseResolveAssemblyReferenceService = useResolveAssemblyReferenceService,
+                WarnOrErrorOnTargetArchitectureMismatch = warnOrErrorOnTargetArchitectureMismatch,
+                CurrentPath = currentPath
+            };
+            reader.Depth--;
+            return result;
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResponseFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResponseFormatter.cs
new file mode 100644
index 00000000000..f9be26bb7b4
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResponseFormatter.cs
@@ -0,0 +1,131 @@
+using System;
+using System.Buffers;
+using MessagePack;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
+{
+    internal sealed class ResolveAssemblyReferenceResponseFormatter : MessagePack.Formatters.IMessagePackFormatter<ResolveAssemblyReferenceResponse>
+    {
+        public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceResponse value, MessagePackSerializerOptions options)
+        {
+            if (value == null)
+            {
+                writer.WriteNil();
+                return;
+            }
+
+            IFormatterResolver formatterResolver = options.Resolver;
+            writer.WriteArrayHeader(11);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.CopyLocalFiles, options);
+            writer.Write(value.DependsOnNETStandard);
+            writer.Write(value.DependsOnSystemRuntime);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.FilesWritten, options);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.RelatedFiles, options);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.ResolvedDependencyFiles, options);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.ResolvedFiles, options);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.SatelliteFiles, options);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.ScatterFiles, options);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.SerializationAssemblyFiles, options);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.SuggestedRedirects, options);
+            //formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.Assemblies, options);
+            //formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.AssemblyFiles, options);
+        }
+
+        public ResolveAssemblyReferenceResponse Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (reader.TryReadNil())
+            {
+                return null;
+            }
+
+            options.Security.DepthStep(ref reader);
+            IFormatterResolver formatterResolver = options.Resolver;
+            int length = reader.ReadArrayHeader();
+            ReadOnlyTaskItem[] copyLocalFiles = default;
+            string dependsOnNETStandard = default;
+            string dependsOnSystemRuntime = default;
+            ReadOnlyTaskItem[] filesWritten = default;
+            ReadOnlyTaskItem[] relatedFiles = default;
+            ReadOnlyTaskItem[] resolvedDependencyFiles = default;
+            ReadOnlyTaskItem[] resolvedFiles = default;
+            ReadOnlyTaskItem[] satelliteFiles = default;
+            ReadOnlyTaskItem[] scatterFiles = default;
+            ReadOnlyTaskItem[] serializationAssemblyFiles = default;
+            ReadOnlyTaskItem[] suggestedRedirects = default;
+            //ReadOnlyTaskItem[] assemblies = default;
+            //ReadOnlyTaskItem[] assemblyFiles = default;
+
+            for (int i = 0; i < length; i++)
+            {
+                int key = i;
+
+                switch (key)
+                {
+                    case 0:
+                        copyLocalFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 1:
+                        dependsOnNETStandard = reader.ReadString();
+                        break;
+                    case 2:
+                        dependsOnSystemRuntime = reader.ReadString();
+                        break;
+                    case 3:
+                        filesWritten = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 4:
+                        relatedFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 5:
+                        resolvedDependencyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 6:
+                        resolvedFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 7:
+                        satelliteFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 8:
+                        scatterFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 9:
+                        serializationAssemblyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 10:
+                        suggestedRedirects = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    //case 11:
+                    //    assemblies = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                    //    break;
+                    //case 12:
+                    //    assemblyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                    //    break;
+                    default:
+                        reader.Skip();
+                        break;
+                }
+            }
+
+            ResolveAssemblyReferenceResponse result = new ResolveAssemblyReferenceResponse
+            {
+                CopyLocalFiles = copyLocalFiles,
+                DependsOnNETStandard = dependsOnNETStandard,
+                DependsOnSystemRuntime = dependsOnSystemRuntime,
+                FilesWritten = filesWritten,
+                RelatedFiles = relatedFiles,
+                ResolvedDependencyFiles = resolvedDependencyFiles,
+                ResolvedFiles = resolvedFiles,
+                SatelliteFiles = satelliteFiles,
+                ScatterFiles = scatterFiles,
+                SerializationAssemblyFiles = serializationAssemblyFiles,
+                SuggestedRedirects = suggestedRedirects,
+                //Assemblies = assemblies,
+                //AssemblyFiles = assemblyFiles
+            };
+            reader.Depth--;
+            return result;
+        }
+    }
+}
+
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResultFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResultFormatter.cs
new file mode 100644
index 00000000000..f9f13e107d8
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResultFormatter.cs
@@ -0,0 +1,103 @@
+using System;
+using System.Buffers;
+using System.Collections.Generic;
+using MessagePack;
+using MessagePack.Formatters;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
+{
+    internal sealed class ResolveAssemblyReferenceResultFormatter : IMessagePackFormatter<ResolveAssemblyReferenceResult>
+    {
+        public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceResult value, MessagePackSerializerOptions options)
+        {
+            if (value == null)
+            {
+                writer.WriteNil();
+                return;
+            }
+
+            IFormatterResolver formatterResolver = options.Resolver;
+            writer.WriteArrayHeader(8);
+            writer.Write(value.TaskResult);
+            formatterResolver.GetFormatter<ResolveAssemblyReferenceResponse>().Serialize(ref writer, value.Response, options);
+            writer.Write(value.EventCount);
+            formatterResolver.GetFormatter<List<CustomBuildEventArgs>>().Serialize(ref writer, value.CustomBuildEvents, options);
+            formatterResolver.GetFormatter<List<BuildErrorEventArgs>>().Serialize(ref writer, value.BuildErrorEvents, options);
+            formatterResolver.GetFormatter<List<BuildMessageEventArgs>>().Serialize(ref writer, value.BuildMessageEvents, options);
+            formatterResolver.GetFormatter<List<BuildWarningEventArgs>>().Serialize(ref writer, value.BuildWarningEvents, options);
+            formatterResolver.GetFormatter<ResolveAssemblyReferenceRequest>().Serialize(ref writer, value.Request, options);
+        }
+
+        public ResolveAssemblyReferenceResult Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (reader.TryReadNil())
+            {
+                return null;
+            }
+
+            options.Security.DepthStep(ref reader);
+            IFormatterResolver formatterResolver = options.Resolver;
+            int length = reader.ReadArrayHeader();
+            List<BuildErrorEventArgs> buildErrorEvents = default;
+            List<BuildMessageEventArgs> buildMessageEvents = default;
+            List<BuildWarningEventArgs> buildWarningEvents = default;
+            List<CustomBuildEventArgs> customBuildEvents = default;
+            int eventCount = default;
+            ResolveAssemblyReferenceResponse response = default;
+            ResolveAssemblyReferenceRequest request = default;
+            bool taskResult = default;
+
+            for (int i = 0; i < length; i++)
+            {
+                int key = i;
+
+                switch (key)
+                {
+                    case 4:
+                        buildErrorEvents = formatterResolver.GetFormatter<List<BuildErrorEventArgs>>().Deserialize(ref reader, options);
+                        break;
+                    case 5:
+                        buildMessageEvents = formatterResolver.GetFormatter<List<BuildMessageEventArgs>>().Deserialize(ref reader, options);
+                        break;
+                    case 6:
+                        buildWarningEvents = formatterResolver.GetFormatter<List<BuildWarningEventArgs>>().Deserialize(ref reader, options);
+                        break;
+                    case 3:
+                        customBuildEvents = formatterResolver.GetFormatter<List<CustomBuildEventArgs>>().Deserialize(ref reader, options);
+                        break;
+                    case 2:
+                        eventCount = reader.ReadInt32();
+                        break;
+                    case 1:
+                        response = formatterResolver.GetFormatter<ResolveAssemblyReferenceResponse>().Deserialize(ref reader, options);
+                        break;
+                    case 7:
+                        request = formatterResolver.GetFormatter<ResolveAssemblyReferenceRequest>().Deserialize(ref reader, options);
+                        break;
+                    case 0:
+                        taskResult = reader.ReadBoolean();
+                        break;
+                    default:
+                        reader.Skip();
+                        break;
+                }
+            }
+
+            ResolveAssemblyReferenceResult result = new ResolveAssemblyReferenceResult
+            {
+                BuildErrorEvents = buildErrorEvents,
+                BuildMessageEvents = buildMessageEvents,
+                BuildWarningEvents = buildWarningEvents,
+                CustomBuildEvents = customBuildEvents,
+                EventCount = eventCount,
+                Response = response,
+                TaskResult = taskResult,
+                Request = request
+            };
+            reader.Depth--;
+            return result;
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/ResolveAssemlyReferneceResolver.cs b/src/Tasks/ResolveAssemblyReferences/ResolveAssemlyReferneceResolver.cs
new file mode 100644
index 00000000000..99f5f3eb77c
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/ResolveAssemlyReferneceResolver.cs
@@ -0,0 +1,104 @@
+using System;
+using System.Collections.Generic;
+using MessagePack;
+using MessagePack.Formatters;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences
+{
+    internal sealed class ResolveAssemlyReferneceResolver : IFormatterResolver
+    {
+        public static readonly IFormatterResolver Instance = new ResolveAssemlyReferneceResolver();
+
+        public IMessagePackFormatter<T> GetFormatter<T>()
+        {
+            return FormatterCache<T>.Formatter;
+        }
+
+        private static class FormatterCache<T>
+        {
+            internal static readonly IMessagePackFormatter<T> Formatter;
+
+            static FormatterCache()
+            {
+                var f = GeneratedResolverGetFormatterHelper.GetFormatter(typeof(T));
+                if (f != null)
+                {
+                    Formatter = (IMessagePackFormatter<T>)f;
+                    return;
+                }
+                else if (typeof(T) == typeof(BuildMessageEventArgs))
+                {
+                    Formatter = (IMessagePackFormatter<T>)BuildEventArgsFormatter.Instance;
+                    return;
+                }
+                else if (typeof(T) == typeof(BuildErrorEventArgs))
+                {
+                    Formatter = (IMessagePackFormatter<T>)BuildEventArgsFormatter.Instance;
+                    return;
+                }
+                else if (typeof(T) == typeof(BuildWarningEventArgs))
+                {
+                    Formatter = (IMessagePackFormatter<T>)BuildEventArgsFormatter.Instance;
+                    return;
+                }
+                else if (typeof(T) == typeof(CustomBuildEventArgs))
+                {
+                    Formatter = (IMessagePackFormatter<T>)BuildEventArgsFormatter.Instance;
+                    return;
+                }
+            }
+        }
+    }
+
+    internal static class GeneratedResolverGetFormatterHelper
+    {
+        private static readonly Dictionary<Type, int> lookup;
+
+        static GeneratedResolverGetFormatterHelper()
+        {
+            lookup = new Dictionary<Type, int>
+            {
+                { typeof(ReadOnlyTaskItem[]), 0 },
+                { typeof(Dictionary<string, string>), 1 },
+                { typeof(List<BuildErrorEventArgs>), 2 },
+                { typeof(List<BuildMessageEventArgs>), 3 },
+                { typeof(List<BuildWarningEventArgs>), 4 },
+                { typeof(List<CustomBuildEventArgs>), 5 },
+                { typeof(ReadOnlyTaskItem), 6 },
+                { typeof(ResolveAssemblyReferenceRequest), 7 },
+                { typeof(ResolveAssemblyReferenceResponse), 8 },
+                { typeof(ResolveAssemblyReferenceResult), 9 },
+                { typeof(string[]), 10 },
+                { typeof(string), 11 },
+            };
+        }
+
+        internal static object GetFormatter(Type t)
+        {
+            if (!lookup.TryGetValue(t, out int key))
+            {
+                return null;
+            }
+
+            return key switch
+            {
+                0 => new ArrayFormatter<ReadOnlyTaskItem>(),
+                1 => new DictionaryFormatter<string, string>(),
+                2 => new ListFormatter<BuildErrorEventArgs>(),
+                3 => new ListFormatter<BuildMessageEventArgs>(),
+                4 => new ListFormatter<BuildWarningEventArgs>(),
+                5 => new ListFormatter<CustomBuildEventArgs>(),
+                6 => new ReadOnlyTaskItemFormatter(),
+                7 => new ResolveAssemblyReferenceRequestFormatter(),
+                8 => new ResolveAssemblyReferenceResponseFormatter(),
+                9 => new ResolveAssemblyReferenceResultFormatter(),
+                10 => NullableStringArrayFormatter.Instance,
+                11 => NullableStringFormatter.Instance,
+                _ => null,
+            };
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs b/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs
index d5321377616..56f3fce42be 100644
--- a/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs
+++ b/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs
@@ -3,38 +3,35 @@
 
 using System;
 using System.IO;
+using System.IO.Pipes;
+using System.Threading.Tasks;
 using MessagePack;
 using MessagePack.Formatters;
 using MessagePack.Resolvers;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
 using Nerdbank.Streams;
 using StreamJsonRpc;
 
-#nullable enable
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences
 {
     internal static class RpcUtils
     {
+        private readonly static IFormatterResolver _resolver;
+        private readonly static MessagePackSerializerOptions _options;
+
+        static RpcUtils()
+        {
+            _resolver = ResolveAssemlyReferneceResolver.Instance;
+            _options = MessagePackSerializerOptions.Standard.WithResolver(_resolver);
+        }
+
         internal static IJsonRpcMessageHandler GetRarMessageHandler(Stream stream)
         {
             MessagePackFormatter formatter = new MessagePackFormatter();
 
-            IFormatterResolver resolver = CompositeResolver.Create(
-                new IMessagePackFormatter[]
-                {
-                    BuildEventArgsFormatter.CustomFormatter,
-                    BuildEventArgsFormatter.ErrorFormatter,
-                    BuildEventArgsFormatter.WarningFormatter,
-                    BuildEventArgsFormatter.MessageFormatter
-                },
-                new[]
-                {
-                    StandardResolver.Instance
-                }
-            );
-            MessagePackSerializerOptions options = MessagePackSerializerOptions.Standard.WithResolver(resolver);
+            formatter.SetMessagePackSerializerOptions(_options);
 
-            formatter.SetMessagePackSerializerOptions(options);
             return new LengthHeaderMessageHandler(stream.UsePipe(), formatter);
         }
     }
