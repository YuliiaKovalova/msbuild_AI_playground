diff --git a/.github/policies/resourceManagement.yml b/.github/policies/resourceManagement.yml
index 5b8c19d80a5..effb189ad06 100644
--- a/.github/policies/resourceManagement.yml
+++ b/.github/policies/resourceManagement.yml
@@ -152,5 +152,21 @@ configuration:
       - addReply:
           reply: Hello! I noticed that you're targeting one of our servicing branches. Please consider updating the version.
       description: Comment on vs* branches
+    - if:
+      - payloadType: Pull_Request
+      - or:
+        - isAction:
+            action: Opened
+        - isAction:
+            action: Reopened
+      - or:
+        - filesMatchPattern:
+            pattern: ^.+\.swr$
+        - filesMatchPattern:
+            pattern: src/Package/MSBuild.VSSetup.*/.*
+      then:
+      - addReply:
+          reply: Hello @${issueAuthor}, I noticed that youâ€™re changing an *.swr file or any file under src/Package/MSBuild.VSSetup.*. Please make sure to validate this change by an experimental VS insertion. This is accomplished by pushing to an exp/* branch, which requires write permissions to this repo.
+      description: Remind to run VS Perf DDRITs when deployed assemblies change
 onFailure: 
 onSuccess: 
diff --git a/.opt-prof.yml b/.opt-prof.yml
index d569cf29f20..2f752db4225 100644
--- a/.opt-prof.yml
+++ b/.opt-prof.yml
@@ -21,8 +21,6 @@ resources:
     project: DevDiv
     source: DartLab
     branch: main
-    tags:
-    - production
   - pipeline: DartLab.OptProf
     source: DartLab.OptProf
     branch: main
@@ -32,7 +30,6 @@ resources:
   - repository: DartLabTemplates
     type: git
     name: DartLab.Templates
-    ref: refs/tags/Production
   - repository: DartLabOptProfTemplates
     type: git
     name: DartLab.OptProf
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 528f761dc3e..3bf73e47ab0 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -22,7 +22,7 @@ variables:
   - name: OptProfDrop
     value: ''
   - name: SourceBranch
-    value: $(IbcBranchName)
+    value: $(IbcSourceBranchName)
   # If we're not on a vs* branch, use main as our optprof collection branch
   - ${{ if not(startsWith(variables['Build.SourceBranch'], 'refs/heads/vs')) }}:
     - name: SourceBranch
diff --git a/MSBuild.sln b/MSBuild.sln
index 2254de84835..d1daf054f9e 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -80,7 +80,7 @@ Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "MSBuild.VSSetup.Arm64", "sr
 EndProject
 Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.UnitTests.Shared", "src\UnitTests.Shared\Microsoft.Build.UnitTests.Shared.csproj", "{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}"
 EndProject
-Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.Analyzers.UnitTests", "src\Analyzers.UnitTests\Microsoft.Build.Analyzers.UnitTests.csproj", "{B18BAE17-D78F-4F89-B7A4-808C05E64D73}"
+Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Microsoft.Build.BuildCheck.UnitTests", "src\BuildCheck.UnitTests\Microsoft.Build.BuildCheck.UnitTests.csproj", "{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -866,30 +866,30 @@ Global
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x64.Build.0 = Release|x64
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x86.ActiveCfg = Release|Any CPU
 		{52A0B9C1-23B7-4CCC-B3FC-BDBA1C619E2A}.Release|x86.Build.0 = Release|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Debug|ARM64.ActiveCfg = Debug|arm64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Debug|ARM64.Build.0 = Debug|arm64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Debug|x64.ActiveCfg = Debug|x64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Debug|x64.Build.0 = Debug|x64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Debug|x86.ActiveCfg = Debug|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Debug|x86.Build.0 = Debug|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|arm64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.MachineIndependent|ARM64.Build.0 = MachineIndependent|arm64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Release|Any CPU.Build.0 = Release|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Release|ARM64.ActiveCfg = Release|arm64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Release|ARM64.Build.0 = Release|arm64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Release|x64.ActiveCfg = Release|x64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Release|x64.Build.0 = Release|x64
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Release|x86.ActiveCfg = Release|Any CPU
-		{B18BAE17-D78F-4F89-B7A4-808C05E64D73}.Release|x86.Build.0 = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|ARM64.ActiveCfg = Debug|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|ARM64.Build.0 = Debug|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x64.ActiveCfg = Debug|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x64.Build.0 = Debug|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Debug|x86.Build.0 = Debug|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|ARM64.Build.0 = MachineIndependent|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|Any CPU.Build.0 = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|ARM64.ActiveCfg = Release|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|ARM64.Build.0 = Release|arm64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x64.ActiveCfg = Release|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x64.Build.0 = Release|x64
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x86.ActiveCfg = Release|Any CPU
+		{434CC6DB-1E66-4FB1-A66C-D5BBE99F0ED8}.Release|x86.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 86ff4fe515e..f2ad4211e16 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -33,6 +33,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Load NuGet.Frameworks into secondary AppDomain (MSBuild.exe only)](https://github.com/dotnet/msbuild/pull/9446)
 - [Update Traits when environment has been changed](https://github.com/dotnet/msbuild/pull/9655)
 - [Exec task does not trim leading whitespaces for ConsoleOutput](https://github.com/dotnet/msbuild/pull/9722)
+- [Introduce [MSBuild]::StableStringHash overloads](https://github.com/dotnet/msbuild/issues/9519)
 - [Keep the encoding of standard output & error consistent with the console code page for ToolTask](https://github.com/dotnet/msbuild/pull/9539)
 
 
diff --git a/documentation/wiki/MSBuild-Environment-Variables.md b/documentation/wiki/MSBuild-Environment-Variables.md
index 01c8b7fb66c..39daa716718 100644
--- a/documentation/wiki/MSBuild-Environment-Variables.md
+++ b/documentation/wiki/MSBuild-Environment-Variables.md
@@ -1,12 +1,33 @@
-# MSBuild environment variables
+# MSBuild environment variables list
 
-- [MsBuildSkipEagerWildCardEvaluationRegexes](#msbuildskipeagerwildcardevaluationregexes)
+This document describes the environment variables that are respected in MSBuild, its purpose and usage. 
 
+Some of the env variables listed here are unsupported, meaning there is no guarantee that variable or a specific combination of multiple variables will be respected in upcoming release, so please use at your own risk.
 
-### MsBuildSkipEagerWildCardEvaluationRegexes
+* `MSBuildDebugEngine=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
+  * Set this to cause any MSBuild invocation launched within this environment to emit binary logs and additional debugging information to `<DIRECTORY>`. Useful when debugging build or evaluation issues when you can't directly influence the MSBuild invocation, such as in Visual Studio. More details on [capturing binary logs](./Providing-Binary-Logs.md)
+* `MSBUILDTARGETOUTPUTLOGGING=1`
+   * Set this to enable [printing all target outputs to the log](https://learn.microsoft.com/archive/blogs/msbuild/displaying-target-output-items-using-the-console-logger).
+* `MSBUILDLOGTASKINPUTS=1`
+   * Log task inputs (not needed if there are any diagnostic loggers already).
+ * `MSBUILDEMITSOLUTION=1`
+   * Save the generated .proj file for the .sln that is used to build the solution. The generated files are emitted into a binary log by default and their presence on disk can break subsequent builds.
+* `MSBUILDENABLEALLPROPERTYFUNCTIONS=1`
+   * Enable [additional property functions](https://devblogs.microsoft.com/visualstudio/msbuild-property-functions/). If you need this level of detail you are generally served better with a binary log than the text log.
+* `MSBUILDLOGVERBOSERARSEARCHRESULTS=1`
+   * In ResolveAssemblyReference task, log verbose search results.
+* `MSBUILDLOGCODETASKFACTORYOUTPUT=1`
+   * Dump generated code for task to a <GUID>.txt file in the TEMP directory
+* `MSBUILDDISABLENODEREUSE=1`
+   * Set this to not leave MSBuild processes behind (see `/nr:false`, but the environment variable is useful to also set this for Visual Studio for example).
+* `MSBUILDLOGASYNC=1`
+   * Enable asynchronous logging.
+* `MSBUILDDEBUGONSTART=1`
+   * Launches debugger on build start. Works on Windows operating systems only.  
+   * Setting the value of 2 allows for manually attaching a debugger to a process ID. This works on Windows and non-Windows operating systems.
+* `MSBUILDDEBUGSCHEDULER=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
+   * Dumps scheduler state at specified directory (`MSBUILDDEBUGSCHEDULER` is implied by `MSBuildDebugEngine`).
 
-If specified, overrides the default behavior of glob expansion. 
-
-During glob expansion, if the path with wildcards that is being processed matches one of the regular expressions provided in the [environment variable](#msbuildskipeagerwildcardevaluationregexes), the path is not processed (expanded). 
-
-The value of the envvironment variable is a list of regular expressions, separated by semilcon (;).
\ No newline at end of file
+* `MsBuildSkipEagerWildCardEvaluationRegexes`
+  *  If specified, overrides the default behavior of glob expansion. During glob expansion, if the path with wildcards that is being processed matches one of the regular expressions provided in the [environment variable](#msbuildskipeagerwildcardevaluationregexes), the path is not processed (expanded). 
+  * The value of the environment  variable is a list of regular expressions, separated by semicolon (;).
\ No newline at end of file
diff --git a/documentation/wiki/MSBuild-Tips-&-Tricks.md b/documentation/wiki/MSBuild-Tips-&-Tricks.md
index 94b9ec2f91b..17b137ae33d 100644
--- a/documentation/wiki/MSBuild-Tips-&-Tricks.md
+++ b/documentation/wiki/MSBuild-Tips-&-Tricks.md
@@ -6,37 +6,22 @@ See the [MSBuild Command-Line Reference](https://learn.microsoft.com/visualstudi
  * `MSBuild.exe -nr:false`
    * Disable node reuse (`/nodeReuse:false`). Don't leave MSBuild.exe processes hanging around (and possibly locking files) after the build completes. See more details in MSBuild command line help (/?). See also `MSBUILDDISABLENODEREUSE=1` below. Note that using this when building repeatedly will cause slower builds.
  * `MSBuild.exe -bl`
-   * Records all build events to a structured binary log file. The [MSBuildStructuredLog](https://github.com/KirillOsenkov/MSBuildStructuredLog) tool can be used to analyze this file.
+   * Records all build events to a structured [binary log file](./Providing-Binary-Logs.md). The [MSBuildStructuredLog](https://github.com/KirillOsenkov/MSBuildStructuredLog) tool can be used to analyze this file.
  * `MSBuild.exe -noconlog`
    * Used to suppress the usage of the console logger, which is otherwise always attached.
  * `MSBuild.exe -flp:v=diag`
    * Passes parameters to the file logger. If you want to attach multiple file loggers, you do so by specifying additional parameters in the switches /flp1, /flp2, /flp3, and so on.
 
+
+# Building MSBuild
+
+The documentation on building MSBuild:
+- [Full Framework MSBuild](./Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md)
+- [.Net Core MSBuild](./Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md)
+
 # Environment Variables
 
- * `MSBuildDebugEngine=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
-  * Set this to cause any MSBuild invocation launched within this environment to emit binary logs and additional debugging information to `<DIRECTORY>`. Useful when debugging build or evaluation issues when you can't directly influence the MSBuild invocation, such as in Visual Studio.
- * `MSBUILDTARGETOUTPUTLOGGING=1`
-   * Set this to enable [printing all target outputs to the log](https://learn.microsoft.com/archive/blogs/msbuild/displaying-target-output-items-using-the-console-logger).
- * `MSBUILDLOGTASKINPUTS=1`
-   * Log task inputs (not needed if there are any diagnostic loggers already).
- * `MSBUILDEMITSOLUTION=1`
-   * Save the generated .proj file for the .sln that is used to build the solution.
- * `MSBUILDENABLEALLPROPERTYFUNCTIONS=1`
-   * Enable [additional property functions](https://devblogs.microsoft.com/visualstudio/msbuild-property-functions/).
- * `MSBUILDLOGVERBOSERARSEARCHRESULTS=1`
-   * In ResolveAssemblyReference task, log verbose search results.
- * `MSBUILDLOGCODETASKFACTORYOUTPUT=1`
-   * Dump generated code for task to a <GUID>.txt file in the TEMP directory
- * `MSBUILDDISABLENODEREUSE=1`
-   * Set this to not leave MSBuild processes behind (see `/nr:false` above, but the environment variable is useful to also set this for Visual Studio for example).
- * `MSBUILDLOGASYNC=1`
-   * Enable asynchronous logging.
- * `MSBUILDDEBUGONSTART=1`
-   * Launch debugger on build start.
-   * Setting the value of 2 allows for manually attaching a debugger to a process ID.
- * `MSBUILDDEBUGSCHEDULER=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
-   * Dumps scheduler state at specified directory (`MSBUILDDEBUGSCHEDULER` is implied by `MSBuildDebugEngine`).
+The list of environment variables could be found [here](./MSBuild-Environment-Variables.md)
 
 # TreatAsLocalProperty
 If MSBuild.exe is passed properties on the command line, such as `/p:Platform=AnyCPU` then this value overrides whatever assignments you have to that property inside property groups. For instance, `<Platform>x86</Platform>` will be ignored. To make sure your local assignment to properties overrides whatever they pass on the command line, add the following at the top of your MSBuild project file:
diff --git a/eng/BootStrapMSBuild.props b/eng/BootStrapMsBuild.props
similarity index 87%
rename from eng/BootStrapMSBuild.props
rename to eng/BootStrapMsBuild.props
index e70bcb3489d..858cf76ac54 100644
--- a/eng/BootStrapMSBuild.props
+++ b/eng/BootStrapMsBuild.props
@@ -12,7 +12,7 @@
   </PropertyGroup>
   
   <PropertyGroup Condition="$(TargetFramework.StartsWith('net4'))">
-	<BootstrapBinaryDestination>$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin</BootstrapBinaryDestination>
+    <BootstrapBinaryDestination>$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin</BootstrapBinaryDestination>
   </PropertyGroup>
   
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMsBuild.targets
similarity index 100%
rename from eng/BootStrapMSBuild.targets
rename to eng/BootStrapMsBuild.targets
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 3cbca66f8b2..9cf2b0ee820 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -67,14 +67,14 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24158.4">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24165.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>052a4b9e7a9bdb9744c86c05665f1b46e4d59b15</Sha>
+      <Sha>f311667e0587f19c3fa9553a909975662107a351</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24158.4">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24165.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>052a4b9e7a9bdb9744c86c05665f1b46e4d59b15</Sha>
+      <Sha>f311667e0587f19c3fa9553a909975662107a351</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23475.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
@@ -87,18 +87,18 @@
       <Sha>73f0850939d96131c28cf6ea6ee5aacb4da0083a</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.10.0-preview.2.78">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.10.0-preview.2.81">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>2fdd0d41e33c3354de2750fe154b56751a6682aa</Sha>
+      <Sha>1845d6bd450a7453d573035371c9fec43683d1ef</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24161.2">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24168.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>01b7c233fdda946c1a5628d4692ed827a07e33dd</Sha>
+      <Sha>2348a50bb566b39305c474793b43edb5635db6f4</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24158.4">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24165.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>052a4b9e7a9bdb9744c86c05665f1b46e4d59b15</Sha>
+      <Sha>f311667e0587f19c3fa9553a909975662107a351</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 132e1e07e4e..68276f7464f 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,11 +48,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24158.4</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24165.4</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24161.2</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.10.0-preview.2.78</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24168.1</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.10.0-preview.2.81</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index f1cb3b4a4e9..b6e3c089135 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -113,18 +113,14 @@ try {
   # Opt into performance logging. https://github.com/dotnet/msbuild/issues/5900
   $env:DOTNET_PERFLOG_DIR=$PerfLogDir
 
-  # Expose stage 1 path so unit tests can find the bootstrapped MSBuild.
-  $env:MSBUILD_BOOTSTRAPPED_BINDIR=$Stage1BinDir
-
   # When using bootstrapped MSBuild:
   # - Turn off node reuse (so that bootstrapped MSBuild processes don't stay running and lock files)
-  # - Do run tests
-  # - Don't try to create a bootstrap deployment
+  # - Create bootstrap environment as it's required when also running tests
   if ($onlyDocChanged) {
     & $PSScriptRoot\Common\Build.ps1 -restore -build -ci /p:CreateBootstrap=false /nr:false @properties
   }
   else {
-    & $PSScriptRoot\Common\Build.ps1 -restore -build -test -ci /p:CreateBootstrap=false /nr:false @properties
+    & $PSScriptRoot\Common\Build.ps1 -restore -build -test -ci /p:CreateBootstrap=true /nr:false @properties
   }
 
   exit $lastExitCode
diff --git a/eng/cibuild_bootstrapped_msbuild.sh b/eng/cibuild_bootstrapped_msbuild.sh
index 43fa422fad4..8edd377ec73 100755
--- a/eng/cibuild_bootstrapped_msbuild.sh
+++ b/eng/cibuild_bootstrapped_msbuild.sh
@@ -71,9 +71,6 @@ mv $ArtifactsDir $Stage1Dir
 # Ensure that debug bits fail fast, rather than hanging waiting for a debugger attach.
 export MSBUILDDONOTLAUNCHDEBUGGER=true
 
-# Expose stage 1 path so unit tests can find the bootstrapped MSBuild.
-export MSBUILD_BOOTSTRAPPED_BINDIR="$Stage1Dir/bin"
-
 # Opt into performance logging.
 export DOTNET_PERFLOG_DIR=$PerfLogDir
 
@@ -83,11 +80,10 @@ export DOTNET_HOST_PATH="$_InitializeDotNetCli/dotnet"
 
 # When using bootstrapped MSBuild:
 # - Turn off node reuse (so that bootstrapped MSBuild processes don't stay running and lock files)
-# - Do run tests
-# - Don't try to create a bootstrap deployment
+# - Create bootstrap environment as it's required when also running tests
 if [ $onlyDocChanged = 0 ]
 then
-    . "$ScriptRoot/common/build.sh" --restore --build --test --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=false $properties $extra_properties
+    . "$ScriptRoot/common/build.sh" --restore --build --test --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=true $properties $extra_properties
 
 else
     . "$ScriptRoot/common/build.sh" --restore --build --ci --nodereuse false --configuration $configuration /p:CreateBootstrap=false $properties $extra_properties
diff --git a/eng/common/templates-official/job/job.yml b/eng/common/templates-official/job/job.yml
index 647e3f92e5f..a2709d10562 100644
--- a/eng/common/templates-official/job/job.yml
+++ b/eng/common/templates-official/job/job.yml
@@ -206,9 +206,11 @@ jobs:
         continueOnError: true
         condition: always()
     - ${{ if and(ne(parameters.artifacts.publish.logs, 'false'), ne(parameters.artifacts.publish.logs, '')) }}:
-      - publish: artifacts/log
-        artifact: ${{ coalesce(parameters.artifacts.publish.logs.name, 'Logs_Build_$(Agent.Os)_$(_BuildConfig)') }}
-        displayName: Publish logs
+      - task: 1ES.PublishPipelineArtifact@1
+        inputs:
+          targetPath: 'artifacts/log'
+          artifactName: ${{ coalesce(parameters.artifacts.publish.logs.name, 'Logs_Build_$(Agent.Os)_$(_BuildConfig)') }}
+        displayName: 'Publish logs'
         continueOnError: true
         condition: always()
 
@@ -253,7 +255,9 @@ jobs:
         IgnoreDirectories: ${{ parameters.componentGovernanceIgnoreDirectories }}
 
   - ${{ if eq(parameters.enableBuildRetry, 'true') }}:
-    - publish: $(Build.SourcesDirectory)\eng\common\BuildConfiguration
-      artifact: BuildConfiguration
-      displayName: Publish build retry configuration
-      continueOnError: true
+    - task: 1ES.PublishPipelineArtifact@1
+      inputs:
+        targetPath: '$(Build.SourcesDirectory)\eng\common\BuildConfiguration'
+        artifactName: 'BuildConfiguration'
+      displayName: 'Publish build retry configuration'
+      continueOnError: true
\ No newline at end of file
diff --git a/eng/common/templates-official/job/publish-build-assets.yml b/eng/common/templates-official/job/publish-build-assets.yml
index ea5104625fa..53138622fe7 100644
--- a/eng/common/templates-official/job/publish-build-assets.yml
+++ b/eng/common/templates-official/job/publish-build-assets.yml
@@ -94,14 +94,16 @@ jobs:
       inputs:
         targetType: inline
         script: |
-          Add-Content -Path "$(Build.StagingDirectory)/ReleaseConfigs.txt" -Value $(BARBuildId)
-          Add-Content -Path "$(Build.StagingDirectory)/ReleaseConfigs.txt" -Value "$(DefaultChannels)"
-          Add-Content -Path "$(Build.StagingDirectory)/ReleaseConfigs.txt" -Value $(IsStableBuild)
+          New-Item -Path "$(Build.StagingDirectory)/ReleaseConfigs" -ItemType Directory -Force
+          $filePath = "$(Build.StagingDirectory)/ReleaseConfigs/ReleaseConfigs.txt"
+          Add-Content -Path $filePath -Value $(BARBuildId)
+          Add-Content -Path $filePath -Value "$(DefaultChannels)"
+          Add-Content -Path $filePath -Value $(IsStableBuild)
     
     - task: 1ES.PublishBuildArtifacts@1
       displayName: Publish ReleaseConfigs Artifact
       inputs:
-        PathtoPublish: '$(Build.StagingDirectory)/ReleaseConfigs.txt'
+        PathtoPublish: '$(Build.StagingDirectory)/ReleaseConfigs'
         PublishLocation: Container
         ArtifactName: ReleaseConfigs
 
diff --git a/global.json b/global.json
index daf524dfe83..644248c5b89 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.8.5"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24158.4"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24165.4"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/MockHost.cs b/src/Build.UnitTests/BackEnd/MockHost.cs
index a5df5d99cfa..920e49b51e1 100644
--- a/src/Build.UnitTests/BackEnd/MockHost.cs
+++ b/src/Build.UnitTests/BackEnd/MockHost.cs
@@ -200,7 +200,7 @@ public IBuildComponent GetComponent(BuildComponentType type)
                 BuildComponentType.ResultsCache => (IBuildComponent)_resultsCache,
                 BuildComponentType.RequestBuilder => (IBuildComponent)_requestBuilder,
                 BuildComponentType.SdkResolverService => (IBuildComponent)_sdkResolverService,
-                BuildComponentType.BuildCheck => (IBuildComponent)_buildCheckManagerProvider,
+                BuildComponentType.BuildCheckManagerProvider => (IBuildComponent)_buildCheckManagerProvider,
                 _ => throw new ArgumentException("Unexpected type " + type),
             };
         }
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 0649b96b566..67eba7e0b12 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -74,6 +74,7 @@ public void VerifyEventType()
             ResponseFileUsedEventArgs responseFileUsed = new("path");
             UninitializedPropertyReadEventArgs uninitializedPropertyRead = new("prop", "message", "help", "sender", MessageImportance.Normal);
             EnvironmentVariableReadEventArgs environmentVariableRead = new("env", "message", "help", "sender", MessageImportance.Normal);
+            GeneratedFileUsedEventArgs generatedFileUsed = new GeneratedFileUsedEventArgs("path", "some content");
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -106,6 +107,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(responseFileUsed, LoggingEventType.ResponseFileUsedEvent);
             VerifyLoggingPacket(uninitializedPropertyRead, LoggingEventType.UninitializedPropertyRead);
             VerifyLoggingPacket(environmentVariableRead, LoggingEventType.EnvironmentVariableReadEvent);
+            VerifyLoggingPacket(generatedFileUsed, LoggingEventType.GeneratedFileUsedEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
@@ -307,6 +309,7 @@ public void TestTranslation()
                         ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
                         BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
                     },
+                    new GeneratedFileUsedEventArgs("path", "some content"),
                 };
                 foreach (BuildEventArgs arg in testArgs)
                 {
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 99474115048..46170961e81 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -547,6 +547,7 @@ public void RoundtripResponseFileUsedEventArgs()
                 e => e.ResponseFilePath);
         }
 
+
         [Fact]
         public void RoundtripCriticalBuildMessageEventArgs()
         {
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index d7744692f25..b7744d6ed4f 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -3890,8 +3890,14 @@ public void PropertyStringConstructorConsumingItemMetadata(string metadatumName,
             result.ShouldBe(metadatumValue);
         }
 
-        [Fact]
-        public void PropertyFunctionHashCodeSameOnlyIfStringSame()
+        public static IEnumerable<object[]> GetHashAlgoTypes()
+            => Enum.GetNames(typeof(IntrinsicFunctions.StringHashingAlgorithm))
+                .Append(null)
+                .Select(t => new object[] { t });
+
+        [Theory]
+        [MemberData(nameof(GetHashAlgoTypes))]
+        public void PropertyFunctionHashCodeSameOnlyIfStringSame(string hashType)
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
             Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
@@ -3906,8 +3912,9 @@ public void PropertyFunctionHashCodeSameOnlyIfStringSame()
                 "cat12s",
                 "cat1s"
             };
-            int[] hashes = stringsToHash.Select(toHash =>
-                (int)expander.ExpandPropertiesLeaveTypedAndEscaped($"$([MSBuild]::StableStringHash('{toHash}'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance))
+            string hashTypeString = hashType == null ? "" : $", '{hashType}'";
+            object[] hashes = stringsToHash.Select(toHash =>
+                expander.ExpandPropertiesLeaveTypedAndEscaped($"$([MSBuild]::StableStringHash('{toHash}'{hashTypeString}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance))
                 .ToArray();
             for (int a = 0; a < hashes.Length; a++)
             {
@@ -3925,6 +3932,33 @@ public void PropertyFunctionHashCodeSameOnlyIfStringSame()
             }
         }
 
+        [Theory]
+        [MemberData(nameof(GetHashAlgoTypes))]
+        public void PropertyFunctionHashCodeReturnsExpectedType(string hashType)
+        {
+            PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            Type expectedType;
+
+            expectedType = hashType switch
+            {
+                null => typeof(int),
+                "Legacy" => typeof(int),
+                "Fnv1a32bit" => typeof(int),
+                "Fnv1a32bitFast" => typeof(int),
+                "Fnv1a64bit" => typeof(long),
+                "Fnv1a64bitFast" => typeof(long),
+                "Sha256" => typeof(string),
+                _ => throw new ArgumentOutOfRangeException(nameof(hashType))
+            };
+
+
+            string hashTypeString = hashType == null ? "" : $", '{hashType}'";
+            object hashValue = expander.ExpandPropertiesLeaveTypedAndEscaped($"$([MSBuild]::StableStringHash('FooBar'{hashTypeString}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+
+            hashValue.ShouldBeOfType(expectedType);
+        }
+
         [Theory]
         [InlineData("easycase")]
         [InlineData("")]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index f99833cdc15..25bcabbeed3 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2984,10 +2984,10 @@ private ILoggingService CreateLoggingService(
             loggingService.WarningsNotAsErrors = warningsNotAsErrors;
             loggingService.WarningsAsMessages = warningsAsMessages;
 
-            if (((IBuildComponentHost)this).BuildParameters.IsBuildCheckEnabled)
+            if (_buildParameters.IsBuildCheckEnabled)
             {
                 var buildCheckManagerProvider =
-                    ((IBuildComponentHost)this).GetComponent(BuildComponentType.BuildCheck) as IBuildCheckManagerProvider;
+                    ((IBuildComponentHost)this).GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider;
                 buildCheckManagerProvider!.Instance.SetDataSource(BuildCheckDataSource.EventArgs);
 
                 loggers = (loggers ?? Enumerable.Empty<ILogger>()).Concat(new[]
diff --git a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
index 865d1da9149..abcb6c22fb0 100644
--- a/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
+++ b/src/Build/BackEnd/Components/BuildComponentFactoryCollection.cs
@@ -78,7 +78,7 @@ public void RegisterDefaultFactories()
             _componentEntriesByType[BuildComponentType.LoggingService] = new BuildComponentEntry(BuildComponentType.LoggingService, null);
             _componentEntriesByType[BuildComponentType.RequestBuilder] = new BuildComponentEntry(BuildComponentType.RequestBuilder, RequestBuilder.CreateComponent, CreationPattern.CreateAlways);
             // This conditionally registers real or no-op implementation based on BuildParameters
-            _componentEntriesByType[BuildComponentType.BuildCheck] = new BuildComponentEntry(BuildComponentType.BuildCheck, BuildCheckManagerProvider.CreateComponent, CreationPattern.Singleton);
+            _componentEntriesByType[BuildComponentType.BuildCheckManagerProvider] = new BuildComponentEntry(BuildComponentType.BuildCheckManagerProvider, BuildCheckManagerProvider.CreateComponent, CreationPattern.Singleton);
             _componentEntriesByType[BuildComponentType.TargetBuilder] = new BuildComponentEntry(BuildComponentType.TargetBuilder, TargetBuilder.CreateComponent, CreationPattern.CreateAlways);
             _componentEntriesByType[BuildComponentType.TaskBuilder] = new BuildComponentEntry(BuildComponentType.TaskBuilder, TaskBuilder.CreateComponent, CreationPattern.CreateAlways);
             _componentEntriesByType[BuildComponentType.RegisteredTaskObjectCache] = new BuildComponentEntry(BuildComponentType.RegisteredTaskObjectCache, RegisteredTaskObjectCache.CreateComponent, CreationPattern.Singleton);
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 05d11dc38cb..7e72bd3a159 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -283,7 +283,7 @@ public void CleanupForBuild()
                         throw new AggregateException(deactivateExceptions);
                     }
 
-                    var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheck) as IBuildCheckManagerProvider)!.Instance;
+                    var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance;
                     buildCheckManager.FinalizeProcessing(_nodeLoggingContext);
                 },
                 isLastTask: true);
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index 2ebea5a290a..8b2ded4d251 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -146,7 +146,7 @@ internal enum BuildComponentType
         /// <summary>
         /// The Build Analyzer Manager.
         /// </summary>
-        BuildCheck,
+        BuildCheckManagerProvider,
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 5c58d92561e..1a16e9f2190 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -102,9 +102,9 @@ internal sealed class EventSourceSink :
         public event TelemetryEventHandler TelemetryLogged;
 
         /// <summary>
-        /// This event is raised to log build cop events.
+        /// This event is raised to log BuildCheck events.
         /// </summary>
-        public event BuildCheckEventHandler BuildCheckEventRaised;
+        internal event BuildCheckEventHandler BuildCheckEventRaised;
         #endregion
 
         #region Properties
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index 5d4938c7b7b..b5b3454e36f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -1120,7 +1120,7 @@ private async Task<BuildResult> BuildProject()
         {
             // We consider this the entrypoint for the project build for purposes of BuildCheck processing 
 
-            var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheck) as IBuildCheckManagerProvider)!.Instance;
+            var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance;
             buildCheckManager.SetDataSource(BuildCheckDataSource.BuildExecution);
 
             ErrorUtilities.VerifyThrow(_targetBuilder != null, "Target builder is null");
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index d821a43951f..27e1b307aab 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -476,9 +476,6 @@ internal void LoadProjectIntoConfiguration(
                     projectLoadSettings |= ProjectLoadSettings.FailOnUnresolvedSdk;
                 }
 
-                // Here - if we'll have in-execution analysis and it'll need DOM from Project,
-                //  this is the place for Project creation.
-
                 return new ProjectInstance(
                     ProjectFullPath,
                     globalProperties,
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs b/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
index 9e610834691..30b34dfa65f 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
+++ b/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
@@ -10,13 +10,12 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// </summary>
 public class BuildAnalyzerRule
 {
-    public BuildAnalyzerRule(string id, string title, string description, string category, string messageFormat,
+    public BuildAnalyzerRule(string id, string title, string description, string messageFormat,
         BuildAnalyzerConfiguration defaultConfiguration)
     {
         Id = id;
         Title = title;
         Description = description;
-        Category = category;
         MessageFormat = messageFormat;
         DefaultConfiguration = defaultConfiguration;
     }
@@ -43,11 +42,6 @@ public BuildAnalyzerRule(string id, string title, string description, string cat
     /// </summary>
     public string Description { get; }
 
-    /// <summary>
-    /// TODO: We might turn this into enum, or just remove this.
-    /// </summary>
-    public string Category { get; }
-
     /// <summary>
     /// Message format that will be used by the actual reports (<see cref="BuildCheckResult"/>) - those will just supply the actual arguments.
     /// </summary>
diff --git a/src/Build/BuildCheck/API/BuildCheckResult.cs b/src/Build/BuildCheck/API/BuildCheckResult.cs
index 97975cf7051..03a69e02939 100644
--- a/src/Build/BuildCheck/API/BuildCheckResult.cs
+++ b/src/Build/BuildCheck/API/BuildCheckResult.cs
@@ -38,6 +38,10 @@ internal BuildEventArgs ToEventArgs(BuildAnalyzerResultSeverity severity)
         };
 
     public BuildAnalyzerRule BuildAnalyzerRule { get; }
+
+    /// <summary>
+    /// Optional location of the finding (in near future we might need to support multiple locations).
+    /// </summary>
     public ElementLocation Location { get; }
 
     public string LocationString => Location.LocationString;
diff --git a/src/Build/BuildCheck/API/ConfigurationContext.cs b/src/Build/BuildCheck/API/ConfigurationContext.cs
index 4ea815eb2b8..49dcdcfafec 100644
--- a/src/Build/BuildCheck/API/ConfigurationContext.cs
+++ b/src/Build/BuildCheck/API/ConfigurationContext.cs
@@ -36,5 +36,5 @@ internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData
     /// <summary>
     /// Custom configuration data - per each rule that has some specified.
     /// </summary>
-    public CustomConfigurationData[] CustomConfigurationData { get; init; }
+    public IReadOnlyList<CustomConfigurationData> CustomConfigurationData { get; init; }
 }
diff --git a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs b/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
index 74a8bf6a1ce..a746f581e14 100644
--- a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
+++ b/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
@@ -10,7 +10,8 @@
 
 namespace Microsoft.Build.BuildCheck.Acquisition;
 
-// TODO: Acquisition
+// https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=52643036
+// Acquisition
 //  define the data that will be passed to the acquisition module (and remoted if needed)
 internal class AnalyzerAcquisitionData(string assemblyPath)
 {
diff --git a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
index ff8e78ad5f8..174fb305b83 100644
--- a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
+++ b/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.BuildCheck.Analyzers;
 internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
 {
     public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0101", "ConflictingOutputPath",
-        "Two projects should not share their OutputPath nor IntermediateOutputPath locations", "Configuration",
+        "Two projects should not share their OutputPath nor IntermediateOutputPath locations",
         "Projects {0} and {1} have conflicting output paths: {2}.",
         new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
 
@@ -77,7 +77,7 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
-                // TODO: let's support transmitting locations of specific properties
+                // Populating precise location tracked via https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=58661732
                 ElementLocation.EmptyLocation,
                 Path.GetFileName(projectPath),
                 Path.GetFileName(conflictingProject),
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
index d46e013da46..c2c36c813f9 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationInternal.cs
@@ -26,7 +26,7 @@ public BuildAnalyzerConfigurationInternal(string ruleId, EvaluationAnalysisScope
     // Intentionally not checking the RuleId
     //  as for analyzers with multiple rules, we can squash config to a single one,
     //  if the ruleId is the only thing differing.
-    public bool IsEqual(BuildAnalyzerConfigurationInternal? other) =>
+    public bool IsSameConfigurationAs(BuildAnalyzerConfigurationInternal? other) =>
         other != null &&
         Severity == other.Severity &&
         IsEnabled == other.IsEnabled &&
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
index 22d116d95a1..92673cf7f79 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
@@ -43,7 +43,7 @@ internal void StartNewProject(
             }
         }
 
-        if (CommonConfig == null || !userConfigs.All(t => t.IsEqual(CommonConfig)))
+        if (CommonConfig == null || !userConfigs.All(t => t.IsSameConfigurationAs(CommonConfig)))
         {
             CommonConfig = null;
         }
@@ -59,7 +59,7 @@ internal void Uninitialize()
 
     internal void ClearStats() => _stopwatch.Reset();
 
-    internal IDisposable StartSpan()
+    internal CleanupScope StartSpan()
     {
         _stopwatch.Start();
         return new CleanupScope(_stopwatch.Stop);
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 55b70993bb5..9995aef71b3 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -94,7 +94,7 @@ private void RunRegisteredActions<T>(
             /* (BuildAnalyzerWrapper2, Action<BuildAnalysisContext<T>>) */
             analyzerCallback =>
             {
-                // TODO: tracing - we might want tp account this entire block
+                // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
                 //  to the relevant analyzer (with only the currently accounted part as being the 'core-execution' subspan)
 
                 BuildAnalyzerConfigurationInternal? commonConfig = analyzerCallback.Item1.CommonConfig;
@@ -120,7 +120,9 @@ private void RunRegisteredActions<T>(
                     }
                 }
 
-                // TODO: if the input data supports that - check the configPerRule[0].EvaluationAnalysisScope
+                // Here we might want to check the configPerRule[0].EvaluationAnalysisScope - if the input data supports that
+                // The decision and implementation depends on the outcome of the investigation tracked in:
+                // https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57851137
 
                 BuildCheckDataContext<T> context = new BuildCheckDataContext<T>(
                     analyzerCallback.Item1,
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
index a87f8939229..29a0a8acf50 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
@@ -9,7 +9,7 @@
 
 namespace Microsoft.Build.BuildCheck.Infrastructure;
 
-internal class BuildCheckConfigurationException : Exception
+internal sealed class BuildCheckConfigurationException : Exception
 {
     /// <summary>
     /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 832a611ad81..68d924c9e5e 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -92,9 +92,9 @@ private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
             BuildEventContext.InvalidNodeId, BuildEventContext.InvalidTargetId,
             BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
 
-        LoggingContext loggingContext = loggingContextFactory.CreateLoggingContext(buildEventContext).ToLoggingContext();
+        LoggingContext loggingContext = loggingContextFactory.CreateLoggingContext(buildEventContext);
 
-        // TODO: tracing: https://github.com/dotnet/msbuild/issues/9629
+        // Tracing: https://github.com/dotnet/msbuild/issues/9629
         loggingContext.LogCommentFromText(MessageImportance.High, msg);
     }
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index df7263e2d4d..9cc89118eef 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -23,358 +23,351 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure
-{
-    internal delegate BuildAnalyzer BuildAnalyzerFactory();
+namespace Microsoft.Build.BuildCheck.Infrastructure;
 
-    internal delegate BuildAnalyzerWrapper BuildAnalyzerWrapperFactory(ConfigurationContext configurationContext);
+internal delegate BuildAnalyzer BuildAnalyzerFactory();
+internal delegate BuildAnalyzerWrapper BuildAnalyzerWrapperFactory(ConfigurationContext configurationContext);
 
-    /// <summary>
-    /// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
-    /// </summary>
-    internal sealed class BuildCheckManagerProvider : IBuildCheckManagerProvider
-    {
-        private static int s_isInitialized = 0;
+/// <summary>
+/// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
+/// </summary>
+internal sealed class BuildCheckManagerProvider : IBuildCheckManagerProvider
+{
+    private static int s_isInitialized = 0;
+    private static IBuildCheckManager s_globalInstance = new NullBuildCheckManager();
+    internal static IBuildCheckManager GlobalInstance => s_isInitialized != 0 ? s_globalInstance : throw new InvalidOperationException("BuildCheckManagerProvider not initialized");
 
-        private static IBuildCheckManager s_globalInstance = new NullBuildCheckManager();
+    public IBuildCheckManager Instance => GlobalInstance;
 
-        public IBuildCheckManager Instance => GlobalInstance;
+    internal static IBuildComponent CreateComponent(BuildComponentType type)
+    {
+        ErrorUtilities.VerifyThrow(type == BuildComponentType.BuildCheckManagerProvider, "Cannot create components of type {0}", type);
+        return new BuildCheckManagerProvider();
+    }
 
-        internal static IBuildCheckManager GlobalInstance => s_isInitialized != 0 ? s_globalInstance : throw new InvalidOperationException("BuildCheckManagerProvider not initialized");
+    public void InitializeComponent(IBuildComponentHost host)
+    {
+        ErrorUtilities.VerifyThrow(host != null, "BuildComponentHost was null");
 
-        internal static IBuildComponent CreateComponent(BuildComponentType type)
+        if (Interlocked.CompareExchange(ref s_isInitialized, 1, 0) == 1)
         {
-            ErrorUtilities.VerifyThrow(type == BuildComponentType.BuildCheck, "Cannot create components of type {0}", type);
-            return new BuildCheckManagerProvider();
+            // Initialization code already run(ing)
+            return;
         }
 
-        public void InitializeComponent(IBuildComponentHost host)
+        if (host!.BuildParameters.IsBuildCheckEnabled)
         {
-            ErrorUtilities.VerifyThrow(host != null, "BuildComponentHost was null");
+            s_globalInstance = new BuildCheckManager(host.LoggingService);
+        }
+        else
+        {
+            s_globalInstance = new NullBuildCheckManager();
+        }
+    }
 
-            if (Interlocked.CompareExchange(ref s_isInitialized, 1, 0) == 1)
-            {
-                // Already initialized
-                return;
-            }
+    public void ShutdownComponent() => GlobalInstance.Shutdown();
 
-            if (host!.BuildParameters.IsBuildCheckEnabled)
-            {
-                s_globalInstance = new BuildCheckManager(host.LoggingService);
-            }
-            else
+
+    private sealed class BuildCheckManager : IBuildCheckManager
+    {
+        private readonly TracingReporter _tracingReporter = new TracingReporter();
+        private readonly BuildCheckCentralContext _buildCheckCentralContext = new();
+        private readonly ILoggingService _loggingService;
+        private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry =[];
+        private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
+        private readonly BuildEventsProcessor _buildEventsProcessor;
+        private readonly BuildCheckAcquisitionModule _acquisitionModule = new();
+
+        private bool IsInProcNode => _enabledDataSources[(int)BuildCheckDataSource.EventArgs] &&
+                                     _enabledDataSources[(int)BuildCheckDataSource.BuildExecution];
+
+        /// <summary>
+        /// Notifies the manager that the data source will be used -
+        ///   so it should register the built-in analyzers for the source if it hasn't been done yet.
+        /// </summary>
+        /// <param name="buildCheckDataSource"></param>
+        public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
+        {
+            if (!_enabledDataSources[(int)buildCheckDataSource])
             {
-                s_globalInstance = new NullBuildCheckManager();
+                _enabledDataSources[(int)buildCheckDataSource] = true;
+                RegisterBuiltInAnalyzers(buildCheckDataSource);
             }
         }
 
-        public void ShutdownComponent() => GlobalInstance.Shutdown();
-
-
-        private sealed class BuildCheckManager : IBuildCheckManager
+        public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData)
         {
-            private readonly TracingReporter _tracingReporter = new TracingReporter();
-            private readonly BuildCheckCentralContext _buildCheckCentralContext = new();
-            private readonly ILoggingService _loggingService;
-            private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry =[];
-            private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
-            private readonly BuildEventsProcessor _buildEventsProcessor;
-            private readonly BuildCheckAcquisitionModule _acquisitionModule = new();
-
-            private bool IsInProcNode => _enabledDataSources[(int)BuildCheckDataSource.EventArgs] &&
-                                         _enabledDataSources[(int)BuildCheckDataSource.BuildExecution];
-
-            /// <summary>
-            /// Notifies the manager that the data source will be used -
-            ///   so it should register the built-in analyzers for the source if it hasn't been done yet.
-            /// </summary>
-            /// <param name="buildCheckDataSource"></param>
-            public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
+            if (IsInProcNode)
             {
-                if (!_enabledDataSources[(int)buildCheckDataSource])
-                {
-                    _enabledDataSources[(int)buildCheckDataSource] = true;
-                    RegisterBuiltInAnalyzers(buildCheckDataSource);
-                }
+                var factory = _acquisitionModule.CreateBuildAnalyzerFactory(acquisitionData);
+                RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, factory);
             }
-
-            public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData)
+            else
             {
-                if (IsInProcNode)
-                {
-                    BuildAnalyzerFactory? factory = _acquisitionModule.CreateBuildAnalyzerFactory(acquisitionData);
-                    if (factory != null)
-                    {
-                        RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, factory);
-                    }
-                }
-                else
-                {
-                    BuildCheckAcquisitionEventArgs eventArgs = acquisitionData.ToBuildEventArgs();
+                BuildCheckAcquisitionEventArgs eventArgs = acquisitionData.ToBuildEventArgs();
 
-                    // TODO: We may want to pass the real context here (from evaluation)
-                    eventArgs.BuildEventContext = new BuildEventContext(
-                        BuildEventContext.InvalidNodeId,
-                        BuildEventContext.InvalidProjectInstanceId,
-                        BuildEventContext.InvalidProjectContextId,
-                        BuildEventContext.InvalidTargetId,
-                        BuildEventContext.InvalidTaskId);
+                // We may want to pass the real context here (from evaluation)
+                eventArgs.BuildEventContext = new BuildEventContext(
+                    BuildEventContext.InvalidNodeId,
+                    BuildEventContext.InvalidProjectInstanceId,
+                    BuildEventContext.InvalidProjectContextId,
+                    BuildEventContext.InvalidTargetId,
+                    BuildEventContext.InvalidTaskId);
 
-                    _loggingService.LogBuildEvent(eventArgs);
-                }
+                _loggingService.LogBuildEvent(eventArgs);
             }
+        }
 
-            internal BuildCheckManager(ILoggingService loggingService)
-            {
-                _loggingService = loggingService;
-                _buildEventsProcessor = new(_buildCheckCentralContext);
-            }
+        internal BuildCheckManager(ILoggingService loggingService)
+        {
+            _loggingService = loggingService;
+            _buildEventsProcessor = new(_buildCheckCentralContext);
+        }
 
-            private static T Construct<T>() where T : new() => new();
-            private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][] s_builtInFactoriesPerDataSource =
+        private static T Construct<T>() where T : new() => new();
+        private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][] s_builtInFactoriesPerDataSource =
+        [
+            // BuildCheckDataSource.EventArgs
             [
-                // BuildCheckDataSource.EventArgs
-                [
-                    ([SharedOutputPathAnalyzer.SupportedRule.Id], SharedOutputPathAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathAnalyzer>)
-                ],
-                // BuildCheckDataSource.Execution
-                []
-            ];
-
-            private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
-            {
-                _analyzersRegistry.AddRange(
-                    s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
-                        .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
-            }
+                ([SharedOutputPathAnalyzer.SupportedRule.Id], SharedOutputPathAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathAnalyzer>)
+            ],
+            // BuildCheckDataSource.Execution
+            []
+        ];
+
+        private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
+        {
+            _analyzersRegistry.AddRange(
+                s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
+                    .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+        }
 
-            /// <summary>
-            /// To be used by acquisition module
-            /// Registeres the custom analyzer, the construction of analyzer is deferred until the first using project is encountered
-            /// </summary>
-            internal void RegisterCustomAnalyzer(
-                BuildCheckDataSource buildCheckDataSource,
-                BuildAnalyzerFactory factory,
-                string[] ruleIds,
-                bool defaultEnablement)
+        /// <summary>
+        /// To be used by acquisition module
+        /// Registeres the custom analyzer, the construction of analyzer is deferred until the first using project is encountered
+        /// </summary>
+        internal void RegisterCustomAnalyzer(
+            BuildCheckDataSource buildCheckDataSource,
+            BuildAnalyzerFactory factory,
+            string[] ruleIds,
+            bool defaultEnablement)
+        {
+            if (_enabledDataSources[(int)buildCheckDataSource])
             {
-                if (_enabledDataSources[(int)buildCheckDataSource])
-                {
-                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(factory, ruleIds, defaultEnablement));
-                }
+                _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(factory, ruleIds, defaultEnablement));
             }
+        }
 
-            /// <summary>
-            /// To be used by acquisition module
-            /// Registeres the custom analyzer, the construction of analyzer is needed during registration.
-            /// </summary>
-            internal void RegisterCustomAnalyzer(
-                BuildCheckDataSource buildCheckDataSource,
-                BuildAnalyzerFactory factory)
+        /// <summary>
+        /// To be used by acquisition module
+        /// Registeres the custom analyzer, the construction of analyzer is needed during registration
+        /// </summary>
+        internal void RegisterCustomAnalyzer(
+            BuildCheckDataSource buildCheckDataSource,
+            BuildAnalyzerFactory factory)
+        {
+            if (_enabledDataSources[(int)buildCheckDataSource])
             {
-                if (_enabledDataSources[(int)buildCheckDataSource])
-                {
-                    var instance = factory();
-                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(
-                        factory,
-                        instance.SupportedRules.Select(r => r.Id).ToArray(),
-                        instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
-                }
+                var instance = factory();
+                _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(factory,
+                    instance.SupportedRules.Select(r => r.Id).ToArray(),
+                    instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
             }
+        }
 
-            private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryContext, string projectFullPath, BuildEventContext buildEventContext)
+        private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryContext, string projectFullPath, BuildEventContext buildEventContext)
+        {
+            // For custom analyzers - it should run only on projects where referenced
+            //  (otherwise error out - https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57849480)
+            //  on others it should work similarly as disabling them.
+            // Disabled analyzer should not only post-filter results - it shouldn't even see the data 
+
+            BuildAnalyzerWrapper wrapper;
+            BuildAnalyzerConfigurationInternal[] configurations;
+            if (analyzerFactoryContext.MaterializedAnalyzer == null)
             {
-                // TODO: For user analyzers - it should run only on projects where referenced
-                //  on others it should work similarly as disabling them.
-                // Disabled analyzer should not only post-filter results - it shouldn't even see the data 
+                BuildAnalyzerConfiguration[] userConfigs =
+                    ConfigurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
-                BuildAnalyzerWrapper wrapper;
-                BuildAnalyzerConfigurationInternal[] configurations;
-                if (analyzerFactoryContext.MaterializedAnalyzer == null)
+                if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
                 {
-                    BuildAnalyzerConfiguration[] userConfigs =
-                        ConfigurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
-
-                    if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
-                    {
-                        // the analyzer was not yet instantiated nor mounted - so nothing to do here now.
-                        return;
-                    }
-
-                    CustomConfigurationData[] customConfigData =
-                        ConfigurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
-
-                    ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData);
-
-                    wrapper = analyzerFactoryContext.Factory(configurationContext);
-                    analyzerFactoryContext.MaterializedAnalyzer = wrapper;
-                    BuildAnalyzer analyzer = wrapper.BuildAnalyzer;
-
-                    if (
-                        analyzer.SupportedRules.Count != analyzerFactoryContext.RuleIds.Length
-                        ||
-                        !analyzer.SupportedRules.Select(r => r.Id)
-                            .SequenceEqual(analyzerFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
-                    )
-                    {
-                        throw new BuildCheckConfigurationException(
-                            $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
-                    }
-
-                    configurations = ConfigurationProvider.GetMergedConfigurations(userConfigs, analyzer);
-
-                    // technically all analyzers rules could be disabled, but that would mean
-                    // that the provided 'IsEnabledByDefault' value wasn't correct - the only
-                    // price to be paid in that case is slight performance cost.
-
-                    // Create the wrapper and register to central context
-                    wrapper.StartNewProject(projectFullPath, configurations);
-                    var wrappedContext = new BuildCheckRegistrationContext(wrapper, _buildCheckCentralContext);
-                    analyzer.RegisterActions(wrappedContext);
+                    // the analyzer was not yet instantiated nor mounted - so nothing to do here now.
+                    return;
                 }
-                else
-                {
-                    wrapper = analyzerFactoryContext.MaterializedAnalyzer;
 
-                    configurations = ConfigurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
+                CustomConfigurationData[] customConfigData =
+                    ConfigurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
-                    ConfigurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
-                        analyzerFactoryContext.RuleIds[0]);
+                ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData);
 
-                    // Update the wrapper
-                    wrapper.StartNewProject(projectFullPath, configurations);
-                }
+                wrapper = analyzerFactoryContext.Factory(configurationContext);
+                analyzerFactoryContext.MaterializedAnalyzer = wrapper;
+                BuildAnalyzer analyzer = wrapper.BuildAnalyzer;
 
-                if (configurations.GroupBy(c => c.EvaluationAnalysisScope).Count() > 1)
+                if (
+                    analyzer.SupportedRules.Count != analyzerFactoryContext.RuleIds.Length
+                    ||
+                    !analyzer.SupportedRules.Select(r => r.Id)
+                        .SequenceEqual(analyzerFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
+                )
                 {
                     throw new BuildCheckConfigurationException(
-                        string.Format("All rules for a single analyzer should have the same EvaluationAnalysisScope for a single project (violating rules: [{0}], project: {1})",
-                            analyzerFactoryContext.RuleIds.ToCsvString(),
-                            projectFullPath));
+                        $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
                 }
-            }
 
-            private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventContext buildEventContext)
+                configurations = ConfigurationProvider.GetMergedConfigurations(userConfigs, analyzer);
+
+                // technically all analyzers rules could be disabled, but that would mean
+                // that the provided 'IsEnabledByDefault' value wasn't correct - the only
+                // price to be paid in that case is slight performance cost.
+
+                // Create the wrapper and register to central context
+                wrapper.StartNewProject(projectFullPath, configurations);
+                var wrappedContext = new BuildCheckRegistrationContext(wrapper, _buildCheckCentralContext);
+                analyzer.RegisterActions(wrappedContext);
+            }
+            else
             {
-                // Only add analyzers here
-                // On an execution node - we might remove and dispose the analyzers once project is done
+                wrapper = analyzerFactoryContext.MaterializedAnalyzer;
 
-                // If it's already constructed - just control the custom settings do not differ
+                configurations = ConfigurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
 
-                List<BuildAnalyzerFactoryContext> analyzersToRemove = new();
-                foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
-                {
-                    try
-                    {
-                        SetupSingleAnalyzer(analyzerFactoryContext, projectFullPath, buildEventContext);
-                    }
-                    catch (BuildCheckConfigurationException e)
-                    {
-                        _loggingService.LogErrorFromText(buildEventContext, null, null, null,
-                            new BuildEventFileInfo(projectFullPath),
-                            e.Message);
-                        _loggingService.LogCommentFromText(buildEventContext, MessageImportance.High, $"Dismounting analyzer '{analyzerFactoryContext.FriendlyName}'");
-                        analyzersToRemove.Add(analyzerFactoryContext);
-                    }
-                }
+                ConfigurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
+                    analyzerFactoryContext.RuleIds[0]);
 
-                analyzersToRemove.ForEach(c => _analyzersRegistry.Remove(c));
-                foreach (var analyzerToRemove in analyzersToRemove.Select(a => a.MaterializedAnalyzer).Where(a => a != null))
-                {
-                    _buildCheckCentralContext.DeregisterAnalyzer(analyzerToRemove!);
-                    _tracingReporter.AddStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
-                    analyzerToRemove.BuildAnalyzer.Dispose();
-                }
+                // Update the wrapper
+                wrapper.StartNewProject(projectFullPath, configurations);
+            }
+
+            if (configurations.GroupBy(c => c.EvaluationAnalysisScope).Count() > 1)
+            {
+                throw new BuildCheckConfigurationException(
+                    string.Format("All rules for a single analyzer should have the same EvaluationAnalysisScope for a single project (violating rules: [{0}], project: {1})",
+                        analyzerFactoryContext.RuleIds.ToCsvString(),
+                        projectFullPath));
             }
+        }
 
+        private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventContext buildEventContext)
+        {
+            // Only add analyzers here
+            // On an execution node - we might remove and dispose the analyzers once project is done
 
-            public void ProcessEvaluationFinishedEventArgs(
-                IBuildAnalysisLoggingContext buildAnalysisContext,
-                ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
-                => _buildEventsProcessor
-                    .ProcessEvaluationFinishedEventArgs(buildAnalysisContext, evaluationFinishedEventArgs);
+            // If it's already constructed - just control the custom settings do not differ
 
-            // TODO: tracing: https://github.com/dotnet/msbuild/issues/9629
-            public Dictionary<string, TimeSpan> CreateTracingStats()
+            List<BuildAnalyzerFactoryContext> analyzersToRemove = new();
+            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
             {
-                foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+                try
                 {
-                    if (analyzerFactoryContext.MaterializedAnalyzer != null)
-                    {
-                        _tracingReporter.AddStats(analyzerFactoryContext.FriendlyName,
-                            analyzerFactoryContext.MaterializedAnalyzer.Elapsed);
-                        analyzerFactoryContext.MaterializedAnalyzer.ClearStats();
-                    }
+                    SetupSingleAnalyzer(analyzerFactoryContext, projectFullPath, buildEventContext);
                 }
-
-                return _tracingReporter.TracingStats;
-            }
-
-            public void FinalizeProcessing(LoggingContext loggingContext)
-            {
-                if (IsInProcNode)
+                catch (BuildCheckConfigurationException e)
                 {
-                    // We do not want to send tracing stats from in-proc node
-                    return;
+                    _loggingService.LogErrorFromText(buildEventContext, null, null, null,
+                        new BuildEventFileInfo(projectFullPath),
+                        e.Message);
+                    _loggingService.LogCommentFromText(buildEventContext, MessageImportance.High, $"Dismounting analyzer '{analyzerFactoryContext.FriendlyName}'");
+                    analyzersToRemove.Add(analyzerFactoryContext);
                 }
-
-                BuildCheckTracingEventArgs eventArgs =
-                    new(CreateTracingStats()) { BuildEventContext = loggingContext.BuildEventContext };
-                loggingContext.LogBuildEvent(eventArgs);
             }
 
-            public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext,
-                string fullPath)
+            analyzersToRemove.ForEach(c => _analyzersRegistry.Remove(c));
+            foreach (var analyzerToRemove in analyzersToRemove.Select(a => a.MaterializedAnalyzer).Where(a => a != null))
             {
-                if (buildCheckDataSource == BuildCheckDataSource.EventArgs && IsInProcNode)
-                {
-                    // Skipping this event - as it was already handled by the in-proc node.
-                    // This is because in-proc node has the BuildEventArgs source and BuildExecution source
-                    //  both in a single manager. The project started is first encountered by the execution before the EventArg is sent
-                    return;
-                }
-
-                SetupAnalyzersForNewProject(fullPath, buildEventContext);
+                _buildCheckCentralContext.DeregisterAnalyzer(analyzerToRemove!);
+                _tracingReporter.AddStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
+                analyzerToRemove.BuildAnalyzer.Dispose();
             }
+        }
 
-            /*
-             *
-             * Following methods are for future use (should we decide to approach in-execution analysis)
-             *
-             */
 
+        public void ProcessEvaluationFinishedEventArgs(
+            AnalyzerLoggingContext buildAnalysisContext,
+            ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
+            => _buildEventsProcessor
+                .ProcessEvaluationFinishedEventArgs(buildAnalysisContext, evaluationFinishedEventArgs);
 
-            public void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        // Tracing: https://github.com/dotnet/msbuild/issues/9629
+        public Dictionary<string, TimeSpan> CreateTracingStats()
+        {
+            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
             {
+                if (analyzerFactoryContext.MaterializedAnalyzer != null)
+                {
+                    _tracingReporter.AddStats(analyzerFactoryContext.FriendlyName,
+                        analyzerFactoryContext.MaterializedAnalyzer.Elapsed);
+                    analyzerFactoryContext.MaterializedAnalyzer.ClearStats();
+                }
             }
 
-            public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+            return _tracingReporter.TracingStats;
+        }
+
+        public void FinalizeProcessing(LoggingContext loggingContext)
+        {
+            if (IsInProcNode)
             {
+                // We do not want to send tracing stats from in-proc node
+                return;
             }
 
-            public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+            BuildCheckTracingEventArgs eventArgs =
+                new(CreateTracingStats()) { BuildEventContext = loggingContext.BuildEventContext };
+            loggingContext.LogBuildEvent(eventArgs);
+        }
+
+        public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext,
+            string fullPath)
+        {
+            if (buildCheckDataSource == BuildCheckDataSource.EventArgs && IsInProcNode)
             {
+                // Skipping this event - as it was already handled by the in-proc node.
+                // This is because in-proc node has the BuildEventArgs source and BuildExecution source
+                //  both in a single manager. The project started is first encountered by the execution before the EventArg is sent
+                return;
             }
 
-            public void Shutdown()
-            { /* Too late here for any communication to the main node or for logging anything */ }
+            SetupAnalyzersForNewProject(fullPath, buildEventContext);
+        }
+
+        /*
+         *
+         * Following methods are for future use (should we decide to approach in-execution analysis)
+         *
+         */
+
 
-            private class BuildAnalyzerFactoryContext(
-                BuildAnalyzerFactory factory,
-                string[] ruleIds,
-                bool isEnabledByDefault)
+        public void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        {
+        }
+
+        public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        {
+        }
+
+        public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext)
+        {
+        }
+
+        public void Shutdown()
+        { /* Too late here for any communication to the main node or for logging anything */ }
+
+        private class BuildAnalyzerFactoryContext(
+            BuildAnalyzerFactory factory,
+            string[] ruleIds,
+            bool isEnabledByDefault)
+        {
+            public BuildAnalyzerWrapperFactory Factory { get; init; } = configContext =>
             {
-                public BuildAnalyzerWrapperFactory Factory { get; init; } = configContext =>
-                {
-                    BuildAnalyzer ba = factory();
-                    ba.Initialize(configContext);
-                    return new BuildAnalyzerWrapper(ba);
-                };
-                public BuildAnalyzerWrapper? MaterializedAnalyzer { get; set; }
-                public string[] RuleIds { get; init; } = ruleIds;
-                public bool IsEnabledByDefault { get; init; } = isEnabledByDefault;
-                public string FriendlyName => MaterializedAnalyzer?.BuildAnalyzer.FriendlyName ?? factory().FriendlyName;
-            }
+                BuildAnalyzer ba = factory();
+                ba.Initialize(configContext);
+                return new BuildAnalyzerWrapper(ba);
+            };
+            public BuildAnalyzerWrapper? MaterializedAnalyzer { get; set; }
+            public string[] RuleIds { get; init; } = ruleIds;
+            public bool IsEnabledByDefault { get; init; } = isEnabledByDefault;
+            public string FriendlyName => MaterializedAnalyzer?.BuildAnalyzer.FriendlyName ?? factory().FriendlyName;
         }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index 723e0430636..9514f0a7ca0 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -29,12 +29,10 @@ internal class BuildEventsProcessor(BuildCheckCentralContext buildCheckCentralCo
     private readonly BuildCheckCentralContext _buildCheckCentralContext = buildCheckCentralContext;
 
     // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
-    public void ProcessEvaluationFinishedEventArgs(
-        IBuildAnalysisLoggingContext buildAnalysisContext,
+    internal void ProcessEvaluationFinishedEventArgs(
+        AnalyzerLoggingContext buildAnalysisContext,
         ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
     {
-        LoggingContext loggingContext = buildAnalysisContext.ToLoggingContext();
-
         Dictionary<string, string> propertiesLookup = new Dictionary<string, string>();
         Internal.Utilities.EnumerateProperties(evaluationFinishedEventArgs.Properties, propertiesLookup,
             static (dict, kvp) => dict.Add(kvp.Key, kvp.Value));
@@ -42,7 +40,7 @@ public void ProcessEvaluationFinishedEventArgs(
         EvaluatedPropertiesAnalysisData analysisData =
             new(evaluationFinishedEventArgs.ProjectFile!, propertiesLookup);
 
-        _buildCheckCentralContext.RunEvaluatedPropertiesActions(analysisData, loggingContext, ReportResult);
+        _buildCheckCentralContext.RunEvaluatedPropertiesActions(analysisData, buildAnalysisContext, ReportResult);
 
         if (_buildCheckCentralContext.HasParsedItemsActions)
         {
@@ -53,7 +51,7 @@ public void ProcessEvaluationFinishedEventArgs(
             ParsedItemsAnalysisData itemsAnalysisData = new(evaluationFinishedEventArgs.ProjectFile!,
                 new ItemsHolder(xml.Items, xml.ItemGroups));
 
-            _buildCheckCentralContext.RunParsedItemsActions(itemsAnalysisData, loggingContext, ReportResult);
+            _buildCheckCentralContext.RunParsedItemsActions(itemsAnalysisData, buildAnalysisContext, ReportResult);
         }
     }
 
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index d77f5c2ce16..67c2155500e 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -15,11 +15,11 @@
 namespace Microsoft.Build.BuildCheck.Infrastructure;
 
 
-// TODO: https://github.com/dotnet/msbuild/issues/9628
-//  Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)
+// Let's flip form statics to instance, with exposed interface (so that we can easily swap implementations)
+// Tracked via: https://github.com/dotnet/msbuild/issues/9828
 internal static class ConfigurationProvider
 {
-    // TODO: This module should have a mechanism for removing unneeded configurations
+    // We might want to have a mechanism for removing unneeded configurations
     //  (disabled rules and analyzers that need to run in different node)
     private static readonly Dictionary<string, BuildAnalyzerConfiguration> _editorConfig = LoadConfiguration();
 
@@ -54,7 +54,7 @@ private static Dictionary<string, BuildAnalyzerConfiguration> LoadConfiguration(
 
         if (!File.Exists(configPath))
         {
-            // TODO: pass the current project path
+            // This is just a dummy implementation for testing purposes
             var dir = Environment.CurrentDirectory;
             configPath = Path.Combine(dir, configFileName);
 
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index 703d0b6bfa9..ca91897ad44 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BuildCheck.Acquisition;
 using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.BuildCheck.Logging;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
@@ -28,7 +29,7 @@ internal enum BuildCheckDataSource
 internal interface IBuildCheckManager
 {
     void ProcessEvaluationFinishedEventArgs(
-        IBuildAnalysisLoggingContext buildAnalysisContext,
+        AnalyzerLoggingContext buildAnalysisContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
 
     void SetDataSource(BuildCheckDataSource buildCheckDataSource);
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index 22ae0b70bae..baecbac2423 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -8,6 +8,7 @@
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BuildCheck.Acquisition;
+using Microsoft.Build.BuildCheck.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
 
diff --git a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
index 614a1711a77..2d6d850737b 100644
--- a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
+++ b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
@@ -11,7 +11,6 @@ namespace Microsoft.Build.BuildCheck.Infrastructure;
 
 internal class TracingReporter
 {
-    internal const string INFRA_STAT_NAME = "Infrastructure";
     internal Dictionary<string, TimeSpan> TracingStats { get; } = new();
 
     public void AddStats(string name, TimeSpan subtotal)
diff --git a/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs b/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
index 7d1d5badc92..1b3eb9cb4bb 100644
--- a/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
+++ b/src/Build/BuildCheck/Logging/AnalyzerLoggingContext.cs
@@ -7,7 +7,7 @@
 
 namespace Microsoft.Build.BuildCheck.Logging;
 
-internal class AnalyzerLoggingContext : LoggingContext, IBuildAnalysisLoggingContext
+internal class AnalyzerLoggingContext : LoggingContext
 {
     public AnalyzerLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
         : base(loggingService, eventContext)
diff --git a/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs b/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
index 1cd2f468885..3b1e035aed9 100644
--- a/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
+++ b/src/Build/BuildCheck/Logging/AnalyzerLoggingContextFactory.cs
@@ -9,6 +9,6 @@ namespace Microsoft.Build.BuildCheck.Logging;
 
 internal class AnalyzerLoggingContextFactory(ILoggingService loggingService) : IBuildAnalysisLoggingContextFactory
 {
-    public IBuildAnalysisLoggingContext CreateLoggingContext(BuildEventContext eventContext) =>
+    public AnalyzerLoggingContext CreateLoggingContext(BuildEventContext eventContext) =>
         new AnalyzerLoggingContext(loggingService, eventContext);
 }
diff --git a/src/Build/BuildCheck/Logging/BuildAnalysisLoggingContextExtensions.cs b/src/Build/BuildCheck/Logging/BuildAnalysisLoggingContextExtensions.cs
deleted file mode 100644
index 4951fd7e3c6..00000000000
--- a/src/Build/BuildCheck/Logging/BuildAnalysisLoggingContextExtensions.cs
+++ /dev/null
@@ -1,15 +0,0 @@
-ï»¿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Experimental.BuildCheck;
-
-namespace Microsoft.Build.BuildCheck.Logging;
-
-internal static class BuildAnalysisLoggingContextExtensions
-{
-    public static LoggingContext ToLoggingContext(this IBuildAnalysisLoggingContext loggingContext) =>
-        loggingContext as AnalyzerLoggingContext ??
-        throw new InvalidOperationException("The logging context is not an AnalyzerLoggingContext");
-}
diff --git a/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContext.cs b/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContext.cs
deleted file mode 100644
index c7433a14eb9..00000000000
--- a/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContext.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-ï»¿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Microsoft.Build.Experimental.BuildCheck;
-
-public interface IBuildAnalysisLoggingContext
-{ }
diff --git a/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs b/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
index e239c8dc73d..e5188703ff7 100644
--- a/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
+++ b/src/Build/BuildCheck/Logging/IBuildAnalysisLoggingContextFactory.cs
@@ -1,11 +1,12 @@
 ï»¿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.Build.BuildCheck.Logging;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-public interface IBuildAnalysisLoggingContextFactory
+internal interface IBuildAnalysisLoggingContextFactory
 {
-    IBuildAnalysisLoggingContext CreateLoggingContext(BuildEventContext eventContext);
+    AnalyzerLoggingContext CreateLoggingContext(BuildEventContext eventContext);
 }
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index d9a560c7e60..d0738fe6b71 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -25,6 +25,10 @@ public abstract class AnalysisData(string projectFilePath)
     public string ProjectFilePath { get; } = projectFilePath;
 }
 
+/// <summary>
+/// Data passed from infrastructure to build analyzers.
+/// </summary>
+/// <typeparam name="T">The type of the actual data for analysis.</typeparam>
 public class BuildCheckDataContext<T> where T : AnalysisData
 {
     private readonly BuildAnalyzerWrapper _analyzerWrapper;
diff --git a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs b/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
index 0a31bdf675a..f3a336a41ec 100644
--- a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
+++ b/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
@@ -5,6 +5,10 @@
 using Microsoft.Build.BackEnd.Logging;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
+
+/// <summary>
+/// BuildCheck OM data representing the evaluated properties of a project.
+/// </summary>
 public class EvaluatedPropertiesAnalysisData : AnalysisData
 {
     internal EvaluatedPropertiesAnalysisData(
diff --git a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs b/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
index 62a0e588ae3..a6b34446258 100644
--- a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
+++ b/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
@@ -7,20 +7,29 @@
 using System.Text;
 using System.Threading.Tasks;
 using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
+/// <summary>
+/// Extension methods for <see cref="ProjectItemElement"/>.
+/// </summary>
 public static class ItemTypeExtensions
 {
     public static IEnumerable<ProjectItemElement> GetItemsOfType(this IEnumerable<ProjectItemElement> items,
         string itemType)
     {
         return items.Where(i =>
-            i.ItemType.Equals(itemType, StringComparison.CurrentCultureIgnoreCase));
+            MSBuildNameIgnoreCaseComparer.Default.Equals(i.ItemType, itemType));
     }
 }
 
+/// <summary>
+/// Holder for evaluated items and item groups.
+/// </summary>
+/// <param name="items"></param>
+/// <param name="itemGroups"></param>
 public class ItemsHolder(IEnumerable<ProjectItemElement> items, IEnumerable<ProjectItemGroupElement> itemGroups)
 {
     public IEnumerable<ProjectItemElement> Items { get; } = items;
@@ -32,6 +41,9 @@ public IEnumerable<ProjectItemElement> GetItemsOfType(string itemType)
     }
 }
 
+/// <summary>
+/// BuildCheck OM data representing the evaluated items of a project.
+/// </summary>
 public class ParsedItemsAnalysisData : AnalysisData
 {
     internal ParsedItemsAnalysisData(
diff --git a/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs b/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
index 1a978642eb8..96efc8ff2fd 100644
--- a/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
+++ b/src/Build/BuildCheck/Utilities/EnumerableExtensions.cs
@@ -16,25 +16,11 @@ internal static class EnumerableExtensions
     /// </summary>
     /// <typeparam name="T"></typeparam>
     /// <param name="source">Sequence to be turned into csv string.</param>
-    /// <param name="useSpace">Indicates whether space should be inserted between comas and following items.</param>
+    /// <param name="useSpace">Indicates whether space should be inserted between commas and following items.</param>
     /// <returns>Csv string.</returns>
     public static string ToCsvString<T>(this IEnumerable<T>? source, bool useSpace = true)
     {
-        return source == null ? "<NULL>" : string.Join("," + (useSpace ? " " : string.Empty), source);
-    }
-
-    /// <summary>
-    /// Performs an action for each element in given sequence.
-    /// </summary>
-    /// <param name="sequence"></param>
-    /// <param name="action"></param>
-    /// <typeparam name="T"></typeparam>
-    public static void ForEach<T>(this IEnumerable<T> sequence, Action<T> action)
-    {
-        foreach (T element in sequence)
-        {
-            action(element);
-        }
+        return source == null ? "<NULL>" : string.Join(useSpace ? ", " : ",", source);
     }
 
     /// <summary>
@@ -52,13 +38,13 @@ public static void Merge<TKey, TValue>(
     {
         foreach (var pair in another)
         {
-            if (!dict.ContainsKey(pair.Key))
+            if (!dict.TryGetValue(pair.Key, out TValue? value))
             {
                 dict[pair.Key] = pair.Value;
             }
             else
             {
-                dict[pair.Key] = mergeValues(dict[pair.Key], pair.Value);
+                dict[pair.Key] = mergeValues(value, pair.Value);
             }
         }
     }
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index f30ccbd0844..acabdac5e5f 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -4203,7 +4203,15 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                         {
                             if (TryGetArg(args, out string arg0))
                             {
-                                returnVal = IntrinsicFunctions.StableStringHash(arg0);
+                                // Prevent loading methods refs from StringTools if ChangeWave opted out.
+                                returnVal = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)
+                                    ? IntrinsicFunctions.StableStringHash(arg0)
+                                    : IntrinsicFunctions.StableStringHashLegacy(arg0);
+                                return true;
+                            }
+                            else if (TryGetArgs(args, out string arg1, out string arg2) && Enum.TryParse<IntrinsicFunctions.StringHashingAlgorithm>(arg2, true, out var hashAlgorithm))
+                            {
+                                returnVal = IntrinsicFunctions.StableStringHash(arg1, hashAlgorithm);
                                 return true;
                             }
                         }
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index a2ade0332e1..625246427fc 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
+using System.Runtime.CompilerServices;
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
@@ -19,6 +20,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
+using Microsoft.NET.StringTools;
 using Microsoft.Win32;
 
 // Needed for DoesTaskHostExistForParameters
@@ -402,12 +404,60 @@ internal static string ConvertFromBase64(string toDecode)
             return Encoding.UTF8.GetString(Convert.FromBase64String(toDecode));
         }
 
+        internal enum StringHashingAlgorithm
+        {
+            // Legacy way of calculating StableStringHash - which was derived from string GetHashCode
+            Legacy,
+            // FNV-1a 32bit hash
+            Fnv1a32bit,
+            // Custom FNV-1a 32bit hash - optimized for speed by hashing by the whole chars (not individual bytes)
+            Fnv1a32bitFast,
+            // FNV-1a 64bit hash
+            Fnv1a64bit,
+            // Custom FNV-1a 64bit hash - optimized for speed by hashing by the whole chars (not individual bytes)
+            Fnv1a64bitFast,
+            // SHA256 hash - gets the hex string of the hash (with no prefix)
+            Sha256
+        }
+
         /// <summary>
-        /// Hash the string independent of bitness and target framework.
+        /// Legacy implementation that doesn't lead to JIT pulling the new functions from StringTools (so those must not be referenced anywhere in the function body)
+        ///  - for cases where the calling code would erroneously load old version of StringTools alongside of the new version of Microsoft.Build.
+        /// Should be removed once Wave17_10 is removed.
         /// </summary>
-        internal static int StableStringHash(string toHash)
-        {
-            return CommunicationsUtilities.GetHashCode(toHash);
+        internal static object StableStringHashLegacy(string toHash)
+            => CommunicationsUtilities.GetHashCode(toHash);
+
+        /// <summary>
+        /// Hash the string independent of bitness, target framework and default codepage of the environment.
+        /// We do not want this to be inlined, as then the Expander would call directly the new overload, and hence
+        ///  JIT load the functions from StringTools - so we would not be able to prevent their loading with ChangeWave as we do now.
+        /// </summary>
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        internal static object StableStringHash(string toHash)
+            => StableStringHash(toHash, StringHashingAlgorithm.Legacy);
+
+        internal static object StableStringHash(string toHash, StringHashingAlgorithm algo) =>
+            algo switch
+            {
+                StringHashingAlgorithm.Legacy => CommunicationsUtilities.GetHashCode(toHash),
+                StringHashingAlgorithm.Fnv1a32bit => FowlerNollVo1aHash.ComputeHash32(toHash),
+                StringHashingAlgorithm.Fnv1a32bitFast => FowlerNollVo1aHash.ComputeHash32Fast(toHash),
+                StringHashingAlgorithm.Fnv1a64bit => FowlerNollVo1aHash.ComputeHash64(toHash),
+                StringHashingAlgorithm.Fnv1a64bitFast => FowlerNollVo1aHash.ComputeHash64Fast(toHash),
+                StringHashingAlgorithm.Sha256 => CalculateSha256(toHash),
+                _ => throw new ArgumentOutOfRangeException(nameof(algo), algo, null)
+            };
+
+        private static string CalculateSha256(string toHash)
+        {
+            var sha = System.Security.Cryptography.SHA256.Create();
+            var hashResult = new StringBuilder();
+            foreach (byte theByte in sha.ComputeHash(Encoding.UTF8.GetBytes(toHash)))
+            {
+                hashResult.Append(theByte.ToString("x2"));
+            }
+            return hashResult.ToString();
         }
 
         /// <summary>
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 1fbad6a47b6..c8e70102bda 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -340,7 +340,9 @@ internal bool IsEventSerializable(BuildEventArgs e)
 #pragma warning disable SYSLIB0050
             // Types which are not serializable and are not IExtendedBuildEventArgs as
             // those always implement custom serialization by WriteToStream and CreateFromStream.
-            if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)
+            if (!e.GetType().GetTypeInfo().IsSerializable &&
+                e is not IExtendedBuildEventArgs &&
+                e is not GeneratedFileUsedEventArgs)
 #pragma warning restore SYSLIB0050
             {
                 _loggingContext.LogWarning(null, new BuildEventFileInfo(string.Empty), "ExpectedEventToBeSerializable", e.GetType().Name);
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index a9e6f75705f..54de65d1d05 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -67,6 +67,8 @@ public sealed class BinaryLogger : ILogger
         //   - Making ProjectStartedEventArgs, ProjectEvaluationFinishedEventArgs, AssemblyLoadBuildEventArgs equal
         //     between de/serialization roundtrips.
         //   - Adding serialized events lengths - to support forward compatible reading
+        // version 19:
+        //   - GeneratedFileUsedEventArgs exposed for brief period of time (so let's continue with 20)
 
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
@@ -333,19 +335,29 @@ private void Write(BuildEventArgs e)
         {
             if (stream != null)
             {
-                // TODO: think about queuing to avoid contention
-                lock (eventArgsWriter)
+                if (projectImportsCollector != null)
                 {
-                    eventArgsWriter.Write(e);
+                    CollectImports(e);
                 }
 
-                if (projectImportsCollector != null)
+                if (DoNotWriteToBinlog(e))
                 {
-                    CollectImports(e);
+                    return;
+                }
+
+                // TODO: think about queuing to avoid contention
+                lock (eventArgsWriter)
+                {
+                    eventArgsWriter.Write(e);
                 }
             }
         }
 
+        private static bool DoNotWriteToBinlog(BuildEventArgs e)
+        {
+            return e is GeneratedFileUsedEventArgs;
+        }
+
         private void CollectImports(BuildEventArgs e)
         {
             if (e is ProjectImportedEventArgs importArgs && importArgs.ImportedProjectFile != null)
@@ -364,6 +376,11 @@ private void CollectImports(BuildEventArgs e)
             {
                 projectImportsCollector.AddFile(responseFileArgs.ResponseFilePath);
             }
+            else if (e is GeneratedFileUsedEventArgs generatedFileUsedEventArgs && generatedFileUsedEventArgs.FilePath != null)
+            {
+                string fullPath = Path.GetFullPath(generatedFileUsedEventArgs.FilePath);
+                projectImportsCollector.AddFileFromMemory(fullPath, generatedFileUsedEventArgs.Content);
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 8a8311e1fd6..a3ce5efa3c5 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -15,6 +15,8 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
+using Microsoft.NET.StringTools;
 
 #nullable disable
 
@@ -1260,9 +1262,9 @@ private void Write(IExtendedBuildEventArgs extendedData)
 
         internal readonly struct HashKey : IEquatable<HashKey>
         {
-            private readonly ulong value;
+            private readonly long value;
 
-            private HashKey(ulong i)
+            private HashKey(long i)
             {
                 value = i;
             }
@@ -1275,13 +1277,13 @@ public HashKey(string text)
                 }
                 else
                 {
-                    value = FnvHash64.GetHashCode(text);
+                    value = FowlerNollVo1aHash.ComputeHash64Fast(text);
                 }
             }
 
             public static HashKey Combine(HashKey left, HashKey right)
             {
-                return new HashKey(FnvHash64.Combine(left.value, right.value));
+                return new HashKey(FowlerNollVo1aHash.Combine64(left.value, right.value));
             }
 
             public HashKey Add(HashKey other) => Combine(this, other);
@@ -1311,35 +1313,5 @@ public override string ToString()
                 return value.ToString();
             }
         }
-
-        internal static class FnvHash64
-        {
-            public const ulong Offset = 14695981039346656037;
-            public const ulong Prime = 1099511628211;
-
-            public static ulong GetHashCode(string text)
-            {
-                ulong hash = Offset;
-
-                unchecked
-                {
-                    for (int i = 0; i < text.Length; i++)
-                    {
-                        char ch = text[i];
-                        hash = (hash ^ ch) * Prime;
-                    }
-                }
-
-                return hash;
-            }
-
-            public static ulong Combine(ulong left, ulong right)
-            {
-                unchecked
-                {
-                    return (left ^ right) * Prime;
-                }
-            }
-        }
     }
 }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 2daff2fe714..dc2d2ed13ca 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -183,7 +183,6 @@
     <Compile Include="BuildCheck\Infrastructure\CustomConfigurationData.cs" />
     <Compile Include="BuildCheck\API\IBuildCheckRegistrationContext.cs" />
     <Compile Include="BuildCheck\Infrastructure\IBuildCheckManager.cs" />
-    <Compile Include="BuildCheck\Logging\IBuildAnalysisLoggingContext.cs" />
     <Compile Include="BuildCheck\Logging\IBuildAnalysisLoggingContextFactory.cs" />
     <Compile Include="BuildCheck\OM\EvaluatedPropertiesAnalysisData.cs" />
     <Compile Include="BuildCheck\OM\ParsedItemsAnalysisData.cs" />
@@ -197,7 +196,6 @@
     <Compile Include="FileAccess\RequestedAccess.cs" />
     <Compile Include="BuildCheck\Logging\AnalyzerLoggingContext.cs" />
     <Compile Include="BuildCheck\Logging\AnalyzerLoggingContextFactory.cs" />
-    <Compile Include="BuildCheck\Logging\BuildAnalysisLoggingContextExtensions.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
diff --git a/src/Analyzers.UnitTests/AssemblyInfo.cs b/src/BuildCheck.UnitTests/AssemblyInfo.cs
similarity index 100%
rename from src/Analyzers.UnitTests/AssemblyInfo.cs
rename to src/BuildCheck.UnitTests/AssemblyInfo.cs
diff --git a/src/Analyzers.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
similarity index 85%
rename from src/Analyzers.UnitTests/EndToEndTests.cs
rename to src/BuildCheck.UnitTests/EndToEndTests.cs
index dc6bce0563b..f0fda0d4b29 100644
--- a/src/Analyzers.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -14,7 +14,7 @@
 using Xunit;
 using Xunit.Abstractions;
 
-namespace Microsoft.Build.Analyzers.UnitTests
+namespace Microsoft.Build.BuildCheck.UnitTests
 {
     public class EndToEndTests : IDisposable
     {
@@ -30,9 +30,10 @@ public EndToEndTests(ITestOutputHelper output)
         public void Dispose() => _env.Dispose();
 
         [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode)
+        [InlineData(true, true)]
+        [InlineData(false, true)]
+        [InlineData(false, false)]
+        public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool analysisRequested)
         {
             string contents = $"""
                 <Project Sdk="Microsoft.NET.Sdk" DefaultTargets="Hello">
@@ -113,16 +114,25 @@ public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode)
 
             // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
             // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
-            // TODO: See if there is a way of fixing it in the engine.
+            // See if there is a way of fixing it in the engine - tracked: https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=55702688.
             _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
 
             _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", buildInOutOfProcessNode ? "1" : "0");
             _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
-            string output = RunnerUtilities.ExecBootstrapedMSBuild($"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -analyze", out bool success);
+            string output = RunnerUtilities.ExecBootstrapedMSBuild(
+                $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
+                (analysisRequested ? " -analyze" : string.Empty), out bool success);
             _env.Output.WriteLine(output);
             success.ShouldBeTrue();
-            // The conflicting outputs warning appears
-            output.ShouldContain("BC0101");
+            // The conflicting outputs warning appears - but only if analysis was requested
+            if (analysisRequested)
+            {
+                output.ShouldContain("BC0101");
+            }
+            else
+            {
+                output.ShouldNotContain("BC0101");
+            }
         }
     }
 }
diff --git a/src/Analyzers.UnitTests/Microsoft.Build.Analyzers.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
similarity index 100%
rename from src/Analyzers.UnitTests/Microsoft.Build.Analyzers.UnitTests.csproj
rename to src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
diff --git a/src/Framework.UnitTests/GeneratedFileUsedEventArgs_Tests.cs b/src/Framework.UnitTests/GeneratedFileUsedEventArgs_Tests.cs
new file mode 100644
index 00000000000..576c37e265f
--- /dev/null
+++ b/src/Framework.UnitTests/GeneratedFileUsedEventArgs_Tests.cs
@@ -0,0 +1,38 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class GeneratedFileUsedEventArgs_Tests
+    {
+        [Fact]
+        public void SerializationDeserializationTest()
+        {
+            string filePath = "path";
+            string content = "content";
+            GeneratedFileUsedEventArgs arg = new(filePath, content);
+
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter bw = new BinaryWriter(stream);
+            arg.WriteToStream(bw);
+
+            stream.Position = 0;
+            using BinaryReader br = new BinaryReader(stream);
+            GeneratedFileUsedEventArgs argDeserialized = new();
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+            argDeserialized.CreateFromStream(br, packetVersion);
+
+            argDeserialized.FilePath.ShouldBe(filePath);
+            argDeserialized.Content.ShouldBe(content);
+        }
+    }
+}
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index 1a415871da0..539fd2c3e4d 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -12,11 +12,18 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-public abstract class BuildCheckEventArgs : BuildEventArgs
-{
-}
-
-public sealed class BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> tracingData) : BuildCheckEventArgs
+/// <summary>
+/// Base class for all build check event args.
+/// Not intended to be extended by external code.
+/// </summary>
+internal abstract class BuildCheckEventArgs : BuildEventArgs
+{ }
+
+/// <summary>
+/// Transport mean for the BuildCheck tracing data from additional nodes.
+/// </summary>
+/// <param name="tracingData"></param>
+internal sealed class BuildCheckTracingEventArgs(Dictionary<string, TimeSpan> tracingData) : BuildCheckEventArgs
 {
     internal BuildCheckTracingEventArgs()
         : this([])
@@ -87,7 +94,7 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         AcquisitionPath = reader.ReadString();
     }
 }
-public sealed class BuildCheckResultWarning : BuildWarningEventArgs
+internal sealed class BuildCheckResultWarning : BuildWarningEventArgs
 {
     public BuildCheckResultWarning(IBuildCheckResult result)
     {
@@ -113,7 +120,7 @@ internal override void CreateFromStream(BinaryReader reader, int version)
     public override string? Message { get; protected set; }
 }
 
-public sealed class BuildCheckResultError : BuildErrorEventArgs
+internal sealed class BuildCheckResultError : BuildErrorEventArgs
 {
     public BuildCheckResultError(IBuildCheckResult result)
     {
@@ -139,7 +146,7 @@ internal override void CreateFromStream(BinaryReader reader, int version)
     public override string? Message { get; protected set; }
 }
 
-public sealed class BuildCheckResultMessage : BuildMessageEventArgs
+internal sealed class BuildCheckResultMessage : BuildMessageEventArgs
 {
     public BuildCheckResultMessage(IBuildCheckResult result)
     {
diff --git a/src/Framework/BuildCheck/IBuildCheckResult.cs b/src/Framework/BuildCheck/IBuildCheckResult.cs
index e6f04518305..1d471e6c9bc 100644
--- a/src/Framework/BuildCheck/IBuildCheckResult.cs
+++ b/src/Framework/BuildCheck/IBuildCheckResult.cs
@@ -12,7 +12,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Holder for the reported result of a build cop rule.
 /// </summary>
-public interface IBuildCheckResult
+internal interface IBuildCheckResult
 {
     /// <summary>
     /// Optional location of the finding (in near future we might need to support multiple locations).
diff --git a/src/Framework/Features.cs b/src/Framework/Features.cs
index 48d3f785a63..ec1183c94f5 100644
--- a/src/Framework/Features.cs
+++ b/src/Framework/Features.cs
@@ -44,6 +44,7 @@ public static class Features
         {
             { "BuildCheck.Beta", FeatureStatus.Preview },
             { "EvaluationContext_SharedSDKCachePolicy", FeatureStatus.Available }, // EvaluationContext supports the SharingPolicy.SharedSDKCache flag.
+            { "TerminalLogger_MultiLineHandler", FeatureStatus.Available }, // TerminalLogger has better explicit support for rendering multi-line messages
             // Add more features here.
         };
 
diff --git a/src/Framework/GeneratedFileUsedEventArgs.cs b/src/Framework/GeneratedFileUsedEventArgs.cs
new file mode 100644
index 00000000000..f64ba9521ff
--- /dev/null
+++ b/src/Framework/GeneratedFileUsedEventArgs.cs
@@ -0,0 +1,60 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Arguments for the generated file used event
+    /// </summary>
+    internal class GeneratedFileUsedEventArgs : BuildMessageEventArgs
+    {
+        public GeneratedFileUsedEventArgs()
+        {
+        }
+
+        /// <summary>
+        /// Initializes a new instance of the <see cref="GeneratedFileUsedEventArgs"/> class.
+        /// </summary>
+        /// 
+        public GeneratedFileUsedEventArgs(string filePath, string content)
+        // We are not sending the event to binlog (just the file), so we do not want it
+        // to have any stringified representation for other logs either.
+            : base(string.Empty, null, null, MessageImportance.Low)
+        {
+            FilePath = filePath;
+            Content = content;
+        }
+
+        /// <summary>
+        /// The file path relative to the current project.
+        /// </summary>
+        public string? FilePath { set; get; }
+
+        /// <summary>
+        /// The content of the file.
+        /// </summary>
+        public string? Content { set; get; }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            if (FilePath != null && Content != null)
+            {
+                writer.Write(FilePath);
+                writer.Write(Content);
+            }
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            FilePath = reader.ReadString();
+            Content = reader.ReadString();
+        }
+    }
+}
diff --git a/src/Framework/IEventSource.cs b/src/Framework/IEventSource.cs
index 146142b488a..8e5402b6fd3 100644
--- a/src/Framework/IEventSource.cs
+++ b/src/Framework/IEventSource.cs
@@ -80,7 +80,7 @@ namespace Microsoft.Build.Framework
     /// <summary>
     /// Type of handler for BuildCheckEventRaised events
     /// </summary>
-    public delegate void BuildCheckEventHandler(object sender, BuildCheckEventArgs e);
+    internal delegate void BuildCheckEventHandler(object sender, BuildCheckEventArgs e);
 
     /// <summary>
     /// This interface defines the events raised by the build engine.
diff --git a/src/Framework/Properties/AssemblyInfo.cs b/src/Framework/Properties/AssemblyInfo.cs
index 790d9898146..633749084f0 100644
--- a/src/Framework/Properties/AssemblyInfo.cs
+++ b/src/Framework/Properties/AssemblyInfo.cs
@@ -45,7 +45,7 @@
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
-[assembly: InternalsVisibleTo("Microsoft.Build.Analyzers.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+[assembly: InternalsVisibleTo("Microsoft.Build.BuildCheck.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 // Ideally we wouldn't need to IVT to OM.UnitTests, which is supposed to test
 // only the public surface area of Microsoft.Build. However, there's a bunch
 // of shared code in Framework that's used there, and we can still avoid IVT
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 2ae43884646..8a2a558e452 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -1,6 +1,6 @@
-ï»¿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
-  <Import Project="$(RepoRoot)eng\BootStrapMSBuild.props" />
+  <Import Project="$(RepoRoot)eng\BootStrapMsBuild.props" />
 
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
@@ -48,6 +48,6 @@
   <Import Project="..\Package\GetBinPaths.targets" Condition="$(TargetFramework.StartsWith('net4'))" />
   <Import Project="..\Package\GetBinPaths.Arm64.targets" Condition="$(TargetFramework.StartsWith('net4'))" />
 
-  <Import Project="$(RepoRoot)eng\BootStrapMSBuild.targets" />
+  <Import Project="$(RepoRoot)eng\BootStrapMsBuild.targets" />
 
 </Project>
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
index aeec26abf26..04778898b3c 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
@@ -1,5 +1,9 @@
 ï»¿]9;4;3;\  project [33;1msucceeded with warnings[m (0.2s)
-    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
 [?25l[1F
 [?25h
 Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
index 3b6fcaf238d..c469153e853 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
@@ -1,5 +1,9 @@
 ï»¿  project [33;1msucceeded with warnings[m (0.2s)
-    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
 [?25l[1F
 [?25h
 Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
index aeec26abf26..04778898b3c 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
@@ -1,5 +1,9 @@
 ï»¿]9;4;3;\  project [33;1msucceeded with warnings[m (0.2s)
-    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
 [?25l[1F
 [?25h
 Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
index 75749517b55..a1c6889502a 100644
--- a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -42,6 +42,8 @@ public class TerminalLogger_Tests : IEventSource, IDisposable
 
         private VerifySettings _settings = new();
 
+        private readonly CultureInfo _originalCulture = Thread.CurrentThread.CurrentCulture;
+
         public TerminalLogger_Tests()
         {
             _mockTerminal = new Terminal(_outputWriter);
@@ -52,6 +54,9 @@ public TerminalLogger_Tests()
             _terminallogger.CreateStopwatch = () => new MockStopwatch();
 
             UseProjectRelativeDirectory("Snapshots");
+
+            // Avoids issues with different cultures on different machines
+            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
         }
 
         #region IEventSource implementation
@@ -93,6 +98,7 @@ public TerminalLogger_Tests()
         public void Dispose()
         {
             _terminallogger.Shutdown();
+            Thread.CurrentThread.CurrentCulture = _originalCulture;
         }
 
         #endregion
@@ -220,7 +226,7 @@ public Task PrintBuildSummary_SucceededWithWarnings()
         {
             InvokeLoggerCallbacksForSimpleProject(succeeded: true, () =>
             {
-                WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Warning!"));
+                WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("A\nMulti\r\nLine\nWarning!"));
             });
 
             return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index d85b33302ed..e7800bdf4ca 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -268,7 +268,7 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "warnnotaserror", "noerr" },           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false),
             new ParameterizedSwitchInfo(  new string[] { "warnasmessage", "nowarn" },           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "binarylogger", "bl" },                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false),
-            new ParameterizedSwitchInfo(  new string[] { "analyze", "al" },                     ParameterizedSwitch.Analyze,                    null,                           false,          null,                                  true,   false),
+            new ParameterizedSwitchInfo(  new string[] { "analyze", },                     ParameterizedSwitch.Analyze,                    null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "restore", "r" },                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "profileevaluation", "prof" },         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false),
             new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false),
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index 195ebb95789..9c8e7e4b624 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Text;
 using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -12,6 +13,7 @@
 
 #if NET7_0_OR_GREATER
 using System.Diagnostics.CodeAnalysis;
+using System.Globalization;
 #endif
 #if NETFRAMEWORK
 using Microsoft.IO;
@@ -42,6 +44,8 @@ internal sealed partial class TerminalLogger : INodeLogger
     private static readonly string[] _immediateMessageKeywords = { "[CredentialProvider]", "--interactive" };
 #endif
 
+    private static readonly string[] newLineStrings = { "\r\n", "\n" };
+
     /// <summary>
     /// A wrapper over the project context ID passed to us in <see cref="IEventSource"/> logger events.
     /// </summary>
@@ -574,6 +578,7 @@ private void TargetStarted(object sender, TargetStartedEventArgs e)
 
             string projectFile = Path.GetFileNameWithoutExtension(e.ProjectFile);
 
+
             var isTestTarget = e.TargetName == _testStartTarget;
 
             var targetName = isTestTarget ? "Testing" : e.TargetName;
@@ -725,19 +730,16 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
     private void WarningRaised(object sender, BuildWarningEventArgs e)
     {
         BuildEventContext? buildEventContext = e.BuildEventContext;
-        string message = EventArgsFormatting.FormatEventMessage(
+        string message = FormatEventMessage(
                 category: AnsiCodes.Colorize("warning", TerminalColor.Yellow),
                 subcategory: e.Subcategory,
                 message: e.Message,
                 code: AnsiCodes.Colorize(e.Code, TerminalColor.Yellow),
                 file: HighlightFileName(e.File),
-                projectFile: e.ProjectFile ?? null,
                 lineNumber: e.LineNumber,
                 endLineNumber: e.EndLineNumber,
                 columnNumber: e.ColumnNumber,
-                endColumnNumber: e.EndColumnNumber,
-                threadId: e.ThreadId,
-                logOutputProperties: null);
+                endColumnNumber: e.EndColumnNumber);
 
         if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
@@ -774,19 +776,16 @@ private bool IsImmediateMessage(string message) =>
     private void ErrorRaised(object sender, BuildErrorEventArgs e)
     {
         BuildEventContext? buildEventContext = e.BuildEventContext;
-        string message = EventArgsFormatting.FormatEventMessage(
+        string message = FormatEventMessage(
                 category: AnsiCodes.Colorize("error", TerminalColor.Red),
                 subcategory: e.Subcategory,
                 message: e.Message,
                 code: AnsiCodes.Colorize(e.Code, TerminalColor.Red),
                 file: HighlightFileName(e.File),
-                projectFile: e.ProjectFile ?? null,
                 lineNumber: e.LineNumber,
                 endLineNumber: e.EndLineNumber,
                 columnNumber: e.ColumnNumber,
-                endColumnNumber: e.EndColumnNumber,
-                threadId: e.ThreadId,
-                logOutputProperties: null);
+                endColumnNumber: e.EndColumnNumber);
 
         if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
@@ -938,5 +937,107 @@ private int NodeIndexForContext(BuildEventContext context)
             : path;
     }
 
+    private string FormatEventMessage(
+            string category,
+            string subcategory,
+            string? message,
+            string code,
+            string? file,
+            int lineNumber,
+            int endLineNumber,
+            int columnNumber,
+            int endColumnNumber)
+    {
+        message ??= string.Empty;
+        StringBuilder builder = new(128);
+
+        if (string.IsNullOrEmpty(file))
+        {
+            builder.Append("MSBUILD : ");    // Should not be localized.
+        }
+        else
+        {
+            builder.Append(file);
+
+            if (lineNumber == 0)
+            {
+                builder.Append(" : ");
+            }
+            else
+            {
+                if (columnNumber == 0)
+                {
+                    builder.Append(endLineNumber == 0 ?
+                        $"({lineNumber}): " :
+                        $"({lineNumber}-{endLineNumber}): ");
+                }
+                else
+                {
+                    if (endLineNumber == 0)
+                    {
+                        builder.Append(endColumnNumber == 0 ?
+                            $"({lineNumber},{columnNumber}): " :
+                            $"({lineNumber},{columnNumber}-{endColumnNumber}): ");
+                    }
+                    else
+                    {
+                        builder.Append(endColumnNumber == 0 ?
+                            $"({lineNumber}-{endLineNumber},{columnNumber}): " :
+                            $"({lineNumber},{columnNumber},{endLineNumber},{endColumnNumber}): ");
+                    }
+                }
+            }
+        }
+
+        if (!string.IsNullOrEmpty(subcategory))
+        {
+            builder.Append(subcategory);
+            builder.Append(' ');
+        }
+
+        builder.Append($"{category} {code}: ");
+
+        // render multi-line message in a special way
+        if (message.IndexOf('\n') >= 0)
+        {
+            const string indent = $"{Indentation}{Indentation}{Indentation}";
+            string[] lines = message.Split(newLineStrings, StringSplitOptions.None);
+
+            foreach (string line in lines)
+            {
+                if (indent.Length + line.Length > Terminal.Width) // custom wrapping with indentation
+                {
+                    WrapText(builder, line, Terminal.Width, indent);
+                }
+                else
+                {
+                    builder.AppendLine();
+                    builder.Append(indent);
+                    builder.Append(line);
+                }
+            }
+        }
+        else
+        {
+            builder.Append(message);
+        }
+
+        return builder.ToString();
+    }
+
+    private static void WrapText(StringBuilder sb, string text, int maxLength, string indent)
+    {
+        int start = 0;
+        while (start < text.Length)
+        {
+            int length = Math.Min(maxLength - indent.Length, text.Length - start);
+            sb.AppendLine();
+            sb.Append(indent);
+            sb.Append(text.AsSpan().Slice(start, length));
+
+            start += length;
+        }
+    }
+
     #endregion
 }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index ac9c638e003..52dfa6daf87 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1849,6 +1849,26 @@ internal static void SetConsoleUI()
             CultureInfo.CurrentUICulture = desiredCulture;
             CultureInfo.DefaultThreadCurrentUICulture = desiredCulture;
 
+#if RUNTIME_TYPE_NETCORE
+            if (EncodingUtilities.CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding())
+#else
+            if (EncodingUtilities.CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding()
+                && !CultureInfo.CurrentUICulture.TwoLetterISOLanguageName.Equals("en", StringComparison.InvariantCultureIgnoreCase))
+#endif
+            {
+                try
+                {
+                    // Setting both encodings causes a change in the CHCP, making it so we don't need to P-Invoke CHCP ourselves.
+                    Console.OutputEncoding = Encoding.UTF8;
+                    // If the InputEncoding is not set, the encoding will work in CMD but not in PowerShell, as the raw CHCP page won't be changed.
+                    Console.InputEncoding = Encoding.UTF8;
+                }
+                catch (Exception ex) when (ex is IOException || ex is SecurityException)
+                {
+                    // The encoding is unavailable. Do nothing.
+                }
+            }
+
             // Determine if the language can be displayed in the current console codepage, otherwise set to US English
             int codepage;
 
@@ -2725,7 +2745,7 @@ private static bool ProcessCommandLineSwitches(
 
         private static bool IsBuildCheckEnabled(CommandLineSwitches commandLineSwitches)
         {
-            // todo: opt-in behavior: https://github.com/dotnet/msbuild/issues/9723
+            // Opt-in behavior to be determined by: https://github.com/dotnet/msbuild/issues/9723
             bool isAnalysisEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Analyze);
             return isAnalysisEnabled;
         }
diff --git a/src/Shared/IsExternalInit.cs b/src/Shared/IsExternalInit.cs
index 92d5c4c320a..ae2ffb321cd 100644
--- a/src/Shared/IsExternalInit.cs
+++ b/src/Shared/IsExternalInit.cs
@@ -3,5 +3,7 @@
 
 namespace System.Runtime.CompilerServices
 {
+    // Needed so we can use init setters in full fw or netstandard
+    //  (details: https://developercommunity.visualstudio.com/t/error-cs0518-predefined-type-systemruntimecompiler/1244809)
     internal static class IsExternalInit { }
 }
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 3a90c6a33ae..291594fcfdc 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -211,30 +211,35 @@ internal enum LoggingEventType : int
         /// </summary>
         ExtendedCriticalBuildMessageEvent = 33,
 
+        /// <summary>
+        /// Event is a <see cref="GeneratedFileUsedEventArgs"/>
+        /// </summary>
+        GeneratedFileUsedEvent = 34,
+        
         /// <summary>
         /// Event is <see cref="BuildCheckResultMessage"/>
         /// </summary>
-        BuildCheckMessageEvent = 34,
+        BuildCheckMessageEvent = 35,
 
         /// <summary>
         /// Event is <see cref="BuildCheckResultWarning"/>
         /// </summary>
-        BuildCheckWarningEvent = 35,
+        BuildCheckWarningEvent = 36,
 
         /// <summary>
         /// Event is <see cref="BuildCheckResultError"/>
         /// </summary>
-        BuildCheckErrorEvent = 36,
+        BuildCheckErrorEvent = 37,
 
         /// <summary>
         /// Event is <see cref="BuildCheckTracingEventArgs"/>
         /// </summary>
-        BuildCheckTracingEvent = 37,
+        BuildCheckTracingEvent = 38,
 
         /// <summary>
         /// Event is <see cref="BuildCheckAcquisitionEventArgs"/>
         /// </summary>
-        BuildCheckAcquisitionEvent = 38,
+        BuildCheckAcquisitionEvent = 39,
     }
     #endregion
 
@@ -619,7 +624,8 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
                 LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
                 LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
-                LoggingEventType.ResponseFileUsedEvent => new ResponseFileUsedEventArgs(null),
+                LoggingEventType.ResponseFileUsedEvent => new ResponseFileUsedEventArgs(null),               
+
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
                 LoggingEventType.AssemblyLoadEvent => new AssemblyLoadBuildEventArgs(),
                 LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
@@ -640,6 +646,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.PropertyInitialValueSet => new PropertyInitialValueSetEventArgs(),
                 LoggingEventType.PropertyReassignment => new PropertyReassignmentEventArgs(),
                 LoggingEventType.UninitializedPropertyRead => new UninitializedPropertyReadEventArgs(),
+                LoggingEventType.GeneratedFileUsedEvent => new GeneratedFileUsedEventArgs(),
                 LoggingEventType.BuildCheckMessageEvent => new BuildCheckResultMessage(),
                 LoggingEventType.BuildCheckWarningEvent => new BuildCheckResultWarning(),
                 LoggingEventType.BuildCheckErrorEvent => new BuildCheckResultError(),
@@ -756,6 +763,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.UninitializedPropertyRead;
             }
+            else if (eventType == typeof(GeneratedFileUsedEventArgs))
+            {
+                return LoggingEventType.GeneratedFileUsedEvent;
+            }
             else if (eventType == typeof(BuildCheckResultMessage))
             {
                 return LoggingEventType.BuildCheckMessageEvent;
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index da848678ded..9a5315b1b32 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -503,6 +503,21 @@ public void LogMessageFromResources(MessageImportance importance, string message
 #endif
         }
 
+        /// <summary>
+        /// Logs a file generated from the given data.
+        /// </summary>
+        /// <param name="filePath">The file path relative to the currecnt project.</param>
+        /// <param name="content">The content of the file.</param>
+        public void LogIncludeGeneratedFile(string filePath, string content)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(filePath, nameof(filePath));
+            ErrorUtilities.VerifyThrowArgumentNull(content, nameof(content));
+
+            var e = new GeneratedFileUsedEventArgs(filePath, content);
+
+            BuildEngine.LogMessageEvent(e);
+        }
+
         /// <summary>
         /// Flatten the inner exception message
         /// </summary>
diff --git a/src/StringTools/FowlerNollVo1aHash.cs b/src/StringTools/FowlerNollVo1aHash.cs
new file mode 100644
index 00000000000..5a9a876e4c0
--- /dev/null
+++ b/src/StringTools/FowlerNollVo1aHash.cs
@@ -0,0 +1,145 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+using System;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// Fowler/Noll/Vo hashing.
+    /// </summary>
+    public static class FowlerNollVo1aHash
+    {
+        // Fowler/Noll/Vo hashing.
+        // http://www.isthe.com/chongo/tech/comp/fnv/
+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash
+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c
+
+        // 32 bit FNV prime and offset basis for FNV-1a.
+        private const uint fnvPrimeA32Bit = 16777619;
+        private const uint fnvOffsetBasisA32Bit = 2166136261;
+
+        // 64 bit FNV prime and offset basis for FNV-1a.
+        private const long fnvPrimeA64Bit = 1099511628211;
+        private const long fnvOffsetBasisA64Bit = unchecked((long)14695981039346656037);
+
+        /// <summary>
+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).
+        /// </summary>
+        /// <param name="text">String to be hashed.</param>
+        /// <returns>32 bit signed hash</returns>
+        public static int ComputeHash32(string text)
+        {
+            uint hash = fnvOffsetBasisA32Bit;
+
+            unchecked
+            {
+                for (int i = 0; i < text.Length; i++)
+                {
+                    char ch = text[i];
+                    byte b = (byte)ch;
+                    hash ^= b;
+                    hash *= fnvPrimeA32Bit;
+
+                    b = (byte)(ch >> 8);
+                    hash ^= b;
+                    hash *= fnvPrimeA32Bit;
+                }
+            }
+
+            return unchecked((int)hash);
+        }
+
+        /// <summary>
+        /// Computes 32 bit Fowler/Noll/Vo-1a inspired hash of a string.
+        /// The hashing algorithm process the data by the whole 16bit chars, instead of by bytes.
+        ///  this speeds up the hashing process almost by 2x, while not significantly increasing collisions rate.
+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a
+        /// </summary>
+        /// <param name="text">String to be hashed.</param>
+        /// <returns>32 bit unsigned hash</returns>
+        public static int ComputeHash32Fast(string text)
+        {
+            uint hash = fnvOffsetBasisA32Bit;
+
+            unchecked
+            {
+                for (int i = 0; i < text.Length; i++)
+                {
+                    char ch = text[i];
+
+                    hash = (hash ^ ch) * fnvPrimeA32Bit;
+                }
+            }
+
+            return unchecked((int)hash);
+        }
+
+        /// <summary>
+        /// Computes 64 bit Fowler/Noll/Vo-1a inspired hash of a string.
+        /// The hashing algorithm process the data by the whole 16bit chars, instead of by bytes.
+        ///  this speeds up the hashing process almost by 2x, while not significantly increasing collisions rate.
+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a
+        /// </summary>
+        /// <param name="text">String to be hashed.</param>
+        /// <returns>64 bit unsigned hash</returns>
+        public static long ComputeHash64Fast(string text)
+        {
+            long hash = fnvOffsetBasisA64Bit;
+
+            unchecked
+            {
+                for (int i = 0; i < text.Length; i++)
+                {
+                    char ch = text[i];
+
+                    hash = (hash ^ ch) * fnvPrimeA64Bit;
+                }
+            }
+
+            return hash;
+        }
+
+        /// <summary>
+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).
+        /// </summary>
+        /// <param name="text">String to be hashed.</param>
+        /// <returns>64 bit unsigned hash</returns>
+        public static long ComputeHash64(string text)
+        {
+            long hash = fnvOffsetBasisA64Bit;
+
+            unchecked
+            {
+                for (int i = 0; i < text.Length; i++)
+                {
+                    char ch = text[i];
+                    byte b = (byte)ch;
+                    hash ^= b;
+                    hash *= fnvPrimeA64Bit;
+
+                    b = (byte)(ch >> 8);
+                    hash ^= b;
+                    hash *= fnvPrimeA64Bit;
+                }
+            }
+
+            return hash;
+        }
+
+        /// <summary>
+        /// Combines two 64 bit hashes generated by <see cref="FowlerNollVo1aHash"/> class into one.
+        /// </summary>
+        /// <param name="left">First hash value to be combined.</param>
+        /// <param name="right">Second hash value to be combined.</param>
+        /// <returns></returns>
+        public static long Combine64(long left, long right)
+        {
+            unchecked
+            {
+                return (left ^ right) * fnvPrimeA64Bit;
+            }
+        }
+    }
+}
diff --git a/src/StringTools/SpanBasedStringBuilder.cs b/src/StringTools/SpanBasedStringBuilder.cs
index 0bea471d8be..01c9c70c18c 100644
--- a/src/StringTools/SpanBasedStringBuilder.cs
+++ b/src/StringTools/SpanBasedStringBuilder.cs
@@ -154,12 +154,12 @@ public void Dispose()
         /// Appends a string.
         /// </summary>
         /// <param name="value">The string to append.</param>
-        public void Append(string value)
+        public void Append(string? value)
         {
             if (!string.IsNullOrEmpty(value))
             {
-                _spans.Add(value.AsMemory());
-                Length += value.Length;
+                _spans.Add(value!.AsMemory());
+                Length += value!.Length;
             }
         }
 
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs b/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs
new file mode 100644
index 00000000000..20542cd8ce8
--- /dev/null
+++ b/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs
@@ -0,0 +1,133 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.IO.Compression;
+using Microsoft.Build.Logging;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    internal enum FactoryType
+    {
+        CodeTaskFactory,
+        RoslynCodeTaskFactory,
+    }
+
+    internal static class CodeTaskFactoryEmbeddedFileInBinlogTestHelper
+    {
+        internal static void BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+            FactoryType factoryType,
+            string taskName,
+            string sourceContent,
+            bool buildShouldSucceed)
+        {
+            using var env = TestEnvironment.Create();
+
+            TransientTestFolder folder = env.CreateFolder(createFolder: true);
+
+            var sourceClass = env.CreateFile(folder, $"{taskName}.cs", sourceContent);
+
+            string projectFileContents = $"""
+                <Project>
+
+                  <UsingTask
+                    TaskName="{taskName}"
+                    TaskFactory="{factoryType}"
+                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
+                    <Task>
+                      <Code Type="Class" Language="cs" Source="{sourceClass.Path}">
+                      </Code>
+                    </Task>
+                  </UsingTask>
+
+                    <Target Name="SayHello">
+                        <{taskName} />
+                    </Target>
+
+                </Project>
+                """;
+
+            TransientTestFile binlog = env.ExpectFile(".binlog");
+
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+
+            Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result, out string projectDirectoryPath);
+
+            Assert.Equal(buildShouldSucceed, result);
+
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            // For unix-based systems path uses '/'
+            projectDirectoryPath = NativeMethodsShared.IsWindows ? projectDirectoryPath.Replace(":\\", "\\") : projectDirectoryPath.Replace("/", "\\");
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(
+                zE => zE.FullName.StartsWith(projectDirectoryPath) && zE.Name.EndsWith($"{taskName}-compilation-file.tmp"),
+                $"Binlog's embedded files didn't have the expected '{projectDirectoryPath}/{{guid}}-{taskName}-compilation-file.tmp'.");
+        }
+
+        internal static void BuildAndCheckForEmbeddedFileInBinlog(
+            FactoryType factoryType,
+            string taskName,
+            string taskXml,
+            bool buildShouldSucceed)
+        {
+            string projectFileContents = $"""
+                <Project>
+
+                  <UsingTask
+                    TaskName="{taskName}"
+                    TaskFactory="{factoryType}"
+                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
+                    {taskXml}
+                  </UsingTask>
+
+                    <Target Name="SayHello">
+                        <{taskName} />
+                    </Target>
+
+                </Project>
+                """;
+
+            using var env = TestEnvironment.Create();
+
+            TransientTestFile binlog = env.ExpectFile(".binlog");
+
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+
+            Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result, out string projectDirectory);
+
+            Assert.Equal(buildShouldSucceed, result);
+
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            // For unix-based systems path uses '/'
+            projectDirectory = NativeMethodsShared.IsWindows ? projectDirectory.Replace(":\\", "\\") : projectDirectory.Replace("/", "\\");
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(
+                zE => zE.FullName.StartsWith(projectDirectory) && zE.Name.EndsWith($"{taskName}-compilation-file.tmp"),
+                $"Binlog's embedded files didn't have the expected '{projectDirectory}/{{guid}}-{taskName}-compilation-file.tmp'.");
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index f6d0b3a01ed..784e05d8bae 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -16,6 +16,7 @@ namespace Microsoft.Build.UnitTests
 #if FEATURE_CODETASKFACTORY
 
     using System.CodeDom.Compiler;
+    using Microsoft.Build.Tasks.UnitTests;
 
     public sealed class CodeTaskFactoryTests
     {
@@ -1120,6 +1121,81 @@ public void RedundantMSBuildReferences()
             MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
             mockLogger.AssertLogContains("Hello, World!");
         }
+
+        [Fact]
+        public void EmbedsGeneratedFromSourceFileInBinlog()
+        {
+            string taskName = "HelloTask";
+
+            string sourceContent = $$"""
+                namespace InlineTask
+                {
+                    using Microsoft.Build.Utilities;
+
+                    public class {{taskName}} : Task
+                    {
+                        public override bool Execute()
+                        {
+                            Log.LogMessage("Hello, world!");
+                            return !Log.HasLoggedErrors;
+                        }
+                    }
+                }
+                """;
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, taskName, sourceContent, true);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFromSourceFileInBinlogWhenFailsToCompile()
+        {
+            string taskName = "HelloTask";
+
+            string sourceContent =  $$"""
+                namespace InlineTask
+                {
+                    using Microsoft.Build.Utilities;
+
+                    public class {{taskName}} : Task
+                    {
+                """;
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, taskName, sourceContent, false);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFileInBinlog()
+        {
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!"");
+                		   ]]>
+                    </Code>
+                </Task>";
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, "HelloTask", taskXml, true);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFileInBinlogWhenFailsToCompile()
+        {
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!
+                		   ]]>
+                    </Code>
+                </Task>";
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, "HelloTask", taskXml, false);
+        }
     }
 #else
     public sealed class CodeTaskFactoryTests
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index 967dfe65a42..0a142052398 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -644,6 +644,81 @@ public override bool Execute()
             }
         }
 
+        [Fact]
+        public void EmbedsGeneratedFromSourceFileInBinlog()
+        {
+            string taskName = "HelloTask";
+
+            string sourceContent = $$"""
+                namespace InlineTask
+                {
+                    using Microsoft.Build.Utilities;
+
+                    public class {{taskName}} : Task
+                    {
+                        public override bool Execute()
+                        {
+                            Log.LogMessage("Hello, world!");
+                            return !Log.HasLoggedErrors;
+                        }
+                    }
+                }
+                """;
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, taskName, sourceContent, true);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFromSourceFileInBinlogWhenFailsToCompile()
+        {
+            string taskName = "HelloTask";
+
+            string sourceContent =  $$"""
+                namespace InlineTask
+                {
+                    using Microsoft.Build.Utilities;
+
+                    public class {{taskName}} : Task
+                    {
+                """;
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, taskName, sourceContent, false);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFileInBinlog()
+        {
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!"");
+                		   ]]>
+                    </Code>
+                </Task>";
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, "HelloTask", taskXml, true);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFileInBinlogWhenFailsToCompile()
+        {
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!
+                		   ]]>
+                    </Code>
+                </Task>";
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, "HelloTask", taskXml, false);
+        }
+
 #if !FEATURE_RUN_EXE_IN_TESTS
         [Fact]
         public void RoslynCodeTaskFactory_UsingAPI()
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 73eb0403611..f863c969cbf 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -791,6 +791,10 @@ private Assembly CompileInMemoryAssembly()
                 // Our code generation is complete, grab the source from the builder ready for compilation
                 string fullCode = codeBuilder.ToString();
 
+                // Embed generated file in the binlog
+                string fileNameInBinlog = $"{Guid.NewGuid()}-{_nameOfTask}-compilation-file.tmp";
+                _log.LogIncludeGeneratedFile(fileNameInBinlog, fullCode);
+
                 var fullSpec = new FullTaskSpecification(finalReferencedAssemblies, fullCode);
                 if (!s_compiledTaskCache.TryGetValue(fullSpec, out Assembly existingAssembly))
                 {
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 63d7fd5b8ae..7989a98917a 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -685,6 +685,10 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
 
             try
             {
+                // Embed generated file in the binlog
+                string fileNameInBinlog = $"{Guid.NewGuid()}-{_taskName}-compilation-file.tmp";
+                _log.LogIncludeGeneratedFile(fileNameInBinlog, taskInfo.SourceCode);
+
                 // Create the code
                 File.WriteAllText(sourceCodePath, taskInfo.SourceCode);
 
diff --git a/src/UnitTests.Shared/AssemblyInfo.cs b/src/UnitTests.Shared/BootstrapLocationAttribute.cs
similarity index 82%
rename from src/UnitTests.Shared/AssemblyInfo.cs
rename to src/UnitTests.Shared/BootstrapLocationAttribute.cs
index 5b383e24105..7f8627a69b3 100644
--- a/src/UnitTests.Shared/AssemblyInfo.cs
+++ b/src/UnitTests.Shared/BootstrapLocationAttribute.cs
@@ -6,9 +6,8 @@
 namespace Microsoft.Build.UnitTests.Shared;
 
 [System.AttributeUsage(System.AttributeTargets.Assembly)]
-internal sealed class BootstrapLocationAttribute(string bootstrapRoot, string bootstrapMsbuildBinaryLocation)
+internal sealed class BootstrapLocationAttribute(string bootstrapMsbuildBinaryLocation)
     : System.Attribute
 {
-    public string BootstrapRoot { get; } = bootstrapRoot;
     public string BootstrapMsbuildBinaryLocation { get; } = bootstrapMsbuildBinaryLocation;
 }
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 9a63822e930..fee3abf670f 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -28,12 +28,11 @@
     <Compile Include="..\Shared\IsExternalInit.cs" />
   </ItemGroup>
 
-  <Import Project="..\..\eng\BootStrapMSBuild.props" />
+  <Import Project="..\..\eng\BootStrapMsBuild.props" />
 
   <ItemGroup>
     <AssemblyAttribute Include="Microsoft.Build.UnitTests.Shared.BootstrapLocationAttribute">
-      <_Parameter1>$(ArtifactsBinDir)</_Parameter1>
-      <_Parameter2>$(BootstrapBinaryDestination)</_Parameter2>
+      <_Parameter1>$(BootstrapBinaryDestination)</_Parameter1>
     </AssemblyAttribute>
   </ItemGroup>
 </Project>
diff --git a/src/UnitTests.Shared/ObjectModelHelpers.cs b/src/UnitTests.Shared/ObjectModelHelpers.cs
index a7609b3a908..ce51be22785 100644
--- a/src/UnitTests.Shared/ObjectModelHelpers.cs
+++ b/src/UnitTests.Shared/ObjectModelHelpers.cs
@@ -1359,6 +1359,20 @@ private static void BuildProjectWithNewOM(string content, ref MockLogger logger,
             result = project.Build(loggers);
         }
 
+        public static void BuildProjectWithNewOMAndBinaryLogger(string content, BinaryLogger binaryLogger, out bool result, out string projectDirectory)
+        {
+            // Replace the nonstandard quotes with real ones
+            content = ObjectModelHelpers.CleanupFileContents(content);
+
+            Project project = new Project(XmlReader.Create(new StringReader(content)), null, toolsVersion: null);
+
+            List<ILogger> loggers = new List<ILogger>() { binaryLogger };
+
+            result = project.Build(loggers);
+
+            projectDirectory = project.DirectoryPath;
+        }
+
         public static MockLogger BuildProjectContentUsingBuildManagerExpectResult(string content, BuildResultCode expectedResult)
         {
             var logger = new MockLogger();
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 373692d37f5..6310534a391 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -58,33 +58,11 @@ public static string ExecBootstrapedMSBuild(string msbuildParameters, out bool s
                                                    ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
 
             string binaryFolder = attribute.BootstrapMsbuildBinaryLocation;
-            string bindirOverride = Environment.GetEnvironmentVariable("MSBUILD_BOOTSTRAPPED_BINDIR");
-            if (!string.IsNullOrEmpty(bindirOverride))
-            {
-                // The bootstrap environment has moved to another location. Assume the same relative layout and adjust the path.
-#if NET
-                string relativePath = Path.GetRelativePath(attribute.BootstrapRoot, binaryFolder);
-                binaryFolder = Path.GetFullPath(relativePath, bindirOverride);
-#else
-                binaryFolder = Path.GetFullPath(binaryFolder);
-                if (binaryFolder.StartsWith(attribute.BootstrapRoot))
-                {
-                    binaryFolder = binaryFolder.Substring(attribute.BootstrapRoot.Length);
-                    if (binaryFolder.StartsWith(Path.DirectorySeparatorChar.ToString()))
-                    {
-                        binaryFolder = binaryFolder.Substring(1);
-                    }
-
-                    binaryFolder = Path.Combine(bindirOverride, binaryFolder);
-                }
-#endif
-            }
 #if NET
             string pathToExecutable = EnvironmentProvider.GetDotnetExePath()!;
             msbuildParameters = Path.Combine(binaryFolder, "MSBuild.dll") + " " + msbuildParameters;
 #else
-            string pathToExecutable =
-                Path.Combine(binaryFolder, "msbuild.exe");
+            string pathToExecutable = Path.Combine(binaryFolder, "MSBuild.exe");
 #endif
             return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper);
         }
diff --git a/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json b/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
index 071723c97cc..52c4467e930 100644
--- a/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
+++ b/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
@@ -27,7 +27,7 @@
       "type": "parameter",
       "description": "Overrides the default Microsoft.Build version where analyzer's interfaces are placed",
       "datatype": "text",
-      "defaultValue": "17.9.5",
+      "defaultValue": "17.11.0",
       "replaces": "1.0.0-MicrosoftBuildPackageVersion",
       "displayName": "Microsoft.Build default package version override"
     }
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj b/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
index 6de9fb1f434..b18c65a87dd 100644
--- a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
+++ b/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
@@ -1,17 +1,17 @@
 <Project Sdk="Microsoft.NET.Sdk">
 
   <PropertyGroup>
-	  <TargetFramework>netstandard2.0</TargetFramework>
-	  <DevelopmentDependency>true</DevelopmentDependency>
-	  <IncludeBuildOutput>false</IncludeBuildOutput>
-	  <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
-	  <!-- The output structure was modified for msbuild develomplent needs.-->
+    <TargetFramework>netstandard2.0</TargetFramework>
+    <DevelopmentDependency>true</DevelopmentDependency>
+    <IncludeBuildOutput>false</IncludeBuildOutput>
+    <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
+    <!-- The output structure was modified for msbuild development needs.-->
     <NoWarn>NU5101;NU5128</NoWarn>
   </PropertyGroup>
 
   <ItemGroup>
-	  <None Include="Directory.Build.props" Pack="true" PackagePath="build\Directory.Build.props" />
-	  <Content Include="README.md" />
+    <None Include="Directory.Build.props" Pack="true" PackagePath="build\Directory.Build.props" />
+    <Content Include="README.md" />
   </ItemGroup>
 
   <ItemGroup>
@@ -20,26 +20,26 @@
   </ItemGroup>
 
   <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
-	<!-- Merge the collection of PackageReference and Assemblies using the NuGetPackageId key.
+    <!-- Merge the collection of PackageReference and Assemblies using the NuGetPackageId key.
        This produces a new list containing the DLL path and the "IncludeInPackage" metadata-->
-	<JoinItems Left="@(ResolvedCompileFileDefinitions)" LeftKey="NuGetPackageId" LeftMetadata="*" Right="@(PackageReference)" RightKey="" RightMetadata="*" ItemSpecToUse="Left">
-		<Output TaskParameter="JoinResult" ItemName="_PackagesToPack" />
-	</JoinItems>
-
-	<ItemGroup>
-		<!-- Remove NETStandard DLLs -->
-		<_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(NuGetPackageId) == 'NETStandard.Library'" />
-		<_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(_PackagesToPack.IncludeInPackage) != 'true'" />
-	</ItemGroup>
-
-	<Message Importance="High" Text="Adding DLLs from the following packages: @(_PackagesToPack->'%(NuGetPackageId)')" />
-
-	<ItemGroup>
-		<!-- Update the collection of items to pack with the DLLs from the NuGet packages -->
-		<None Include="@(_PackagesToPack)" Pack="true" PackagePath="lib" Visible="false" />
-
-		<!-- Add the DLL produced by the current project to the NuGet package -->
-		<None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="lib" Visible="false" />
-	</ItemGroup>
-</Target>
+    <JoinItems Left="@(ResolvedCompileFileDefinitions)" LeftKey="NuGetPackageId" LeftMetadata="*" Right="@(PackageReference)" RightKey="" RightMetadata="*" ItemSpecToUse="Left">
+    <Output TaskParameter="JoinResult" ItemName="_PackagesToPack" />
+    </JoinItems>
+
+    <ItemGroup>
+    <!-- Remove NETStandard DLLs -->
+    <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(NuGetPackageId) == 'NETStandard.Library'" />
+    <_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(_PackagesToPack.IncludeInPackage) != 'true'" />
+    </ItemGroup>
+
+    <Message Importance="High" Text="Adding DLLs from the following packages: @(_PackagesToPack->'%(NuGetPackageId)')" />
+
+    <ItemGroup>
+    <!-- Update the collection of items to pack with the DLLs from the NuGet packages -->
+    <None Include="@(_PackagesToPack)" Pack="true" PackagePath="lib" Visible="false" />
+
+    <!-- Add the DLL produced by the current project to the NuGet package -->
+    <None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="lib" Visible="false" />
+    </ItemGroup>
+  </Target>
 </Project>
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Directory.Build.props b/template_feed/Microsoft.AnalyzerTemplate/Directory.Build.props
index 8de4380640c..3b752b831cc 100644
--- a/template_feed/Microsoft.AnalyzerTemplate/Directory.Build.props
+++ b/template_feed/Microsoft.AnalyzerTemplate/Directory.Build.props
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project>
   <PropertyGroup>
 	  <MSBuildAnalyzer>$([MSBuild]::RegisterAnalyzer($(MSBuildThisFileDirectory)..\lib\Company.AnalyzerTemplate.dll))</MSBuildAnalyzer>
   </PropertyGroup>
