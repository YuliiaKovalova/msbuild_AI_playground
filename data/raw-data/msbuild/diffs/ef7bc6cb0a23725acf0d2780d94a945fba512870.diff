diff --git a/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs b/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
index ff9827a3632..30190647fb5 100644
--- a/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
@@ -21,7 +21,7 @@ public class BuildExecutionCheckConfiguration
     //  nor in the editorconfig configuration file.
     public static BuildExecutionCheckConfiguration Default { get; } = new()
     {
-        EvaluationAnalysisScope = BuildCheck.EvaluationAnalysisScope.ProjectOnly,
+        EvaluationCheckScope = BuildCheck.EvaluationCheckScope.ProjectOnly,
         Severity = BuildExecutionCheckResultSeverity.None
     };
 
@@ -35,7 +35,7 @@ public class BuildExecutionCheckConfiguration
     ///
     /// If not supported by the data source - then the setting is ignored
     /// </summary>
-    public EvaluationAnalysisScope? EvaluationAnalysisScope { get; internal init; }
+    public EvaluationCheckScope? EvaluationCheckScope { get; internal init; }
 
     /// <summary>
     /// The severity of the result for the rule.
@@ -69,12 +69,12 @@ public bool? IsEnabled {
     /// <returns>A new instance of <see cref="BuildAnalyzerConfiguration"/> with the specified settings.</returns>
     internal static BuildExecutionCheckConfiguration Create(Dictionary<string, string>? configDictionary) => new()
     {
-        EvaluationAnalysisScope = TryExtractEvaluationAnalysisScope(configDictionary),
+        EvaluationCheckScope = TryExtractEvaluationAnalysisScope(configDictionary),
         Severity = TryExtractSeverity(configDictionary),
     };
 
 
-    private static EvaluationAnalysisScope? TryExtractEvaluationAnalysisScope(Dictionary<string, string>? config)
+    private static EvaluationCheckScope? TryExtractEvaluationAnalysisScope(Dictionary<string, string>? config)
     {
 
         if (!TryExtractValue(BuildCheckConstants.scopeConfigurationKey, config, out string? stringValue) || stringValue is null)
@@ -85,13 +85,13 @@ public bool? IsEnabled {
         switch (stringValue)
         {
             case "project":
-                return BuildCheck.EvaluationAnalysisScope.ProjectOnly;
+                return BuildCheck.EvaluationCheckScope.ProjectOnly;
             case "current_imports":
-                return BuildCheck.EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree;
+                return BuildCheck.EvaluationCheckScope.ProjectWithImportsFromCurrentWorkTree;
             case "without_sdks":
-                return BuildCheck.EvaluationAnalysisScope.ProjectWithImportsWithoutSdks;
+                return BuildCheck.EvaluationCheckScope.ProjectWithImportsWithoutSdks;
             case "all":
-                return BuildCheck.EvaluationAnalysisScope.ProjectWithAllImports;
+                return BuildCheck.EvaluationCheckScope.ProjectWithAllImports;
             default:
                 ThrowIncorrectValueException(BuildCheckConstants.scopeConfigurationKey, stringValue);
                 break;
diff --git a/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
similarity index 90%
rename from src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs
rename to src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
index 0804d6d76c3..935f0fa00ee 100644
--- a/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs
+++ b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
@@ -10,7 +10,7 @@
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
-using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData;
+using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData;
 
 #if FEATURE_MSIOREDIST
 using Path = Microsoft.IO.Path;
@@ -18,18 +18,18 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
 
-internal sealed class DoubleWritesAnalyzer : BuildAnalyzer
+internal sealed class DoubleWritesCheck : BuildExecutionCheck
 {
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+    public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(
         "BC0102",
         "DoubleWrites",
         "Two tasks should not write the same file",
         "Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.",
-        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning });
+        new BuildExecutionCheckConfiguration() { Severity = BuildExecutionCheckResultSeverity.Warning });
 
     public override string FriendlyName => "MSBuild.DoubleWritesAnalyzer";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
@@ -46,7 +46,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
     /// </summary>
     private readonly Dictionary<string, (string projectFilePath, string taskName)> _filesWritten = new(StringComparer.CurrentCultureIgnoreCase);
 
-    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
         // This analyzer uses a hard-coded list of tasks known to write files.
         switch (context.Data.TaskName)
@@ -58,7 +58,7 @@ private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisDa
         }
     }
 
-    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
         var taskParameters = context.Data.Parameters;
 
@@ -78,7 +78,7 @@ void AnalyzeParameter(string parameterName)
         }
     }
 
-    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
         var taskParameters = context.Data.Parameters;
 
@@ -101,7 +101,7 @@ private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> c
         }
     }
 
-    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationAnalysisData> context, string fileBeingWritten)
+    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationCheckData> context, string fileBeingWritten)
     {
         if (!string.IsNullOrEmpty(fileBeingWritten))
         {
diff --git a/src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
similarity index 89%
rename from src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs
rename to src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
index 8f189848c9d..75b24ecbb5f 100644
--- a/src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs
+++ b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
@@ -7,23 +7,23 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
 
-internal sealed class NoEnvironmentVariablePropertyAnalyzer : BuildAnalyzer
+internal sealed class NoEnvironmentVariablePropertyCheck : BuildExecutionCheck
 {
     /// <summary>
     /// Contains the list of reported environment variables.
     /// </summary>
     private readonly HashSet<EnvironmentVariableIdentityKey> _environmentVariablesReported = new HashSet<EnvironmentVariableIdentityKey>();
 
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+    public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(
         "BC0103",
         "NoEnvironmentVariablePropertyAnalyzer",
         "No implicit property derived from an environment variable should be used during the build",
         "Property is derived from environment variable: '{0}' with value: '{1}'. Properties should be passed explicitly using the /p option.",
-        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Suggestion });
+        new BuildExecutionCheckConfiguration() { Severity = BuildExecutionCheckResultSeverity.Suggestion });
 
     public override string FriendlyName => "MSBuild.NoEnvironmentVariablePropertyAnalyzer";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
diff --git a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
similarity index 89%
rename from src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
rename to src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
index d75d8dbdafe..74c60c37903 100644
--- a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
+++ b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
@@ -13,17 +13,17 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
 
-internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
+internal sealed class SharedOutputPathCheck : BuildExecutionCheck
 {
     private const string RuleId = "BC0101";
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(RuleId, "ConflictingOutputPath",
+    public static BuildExecutionCheckRule SupportedRule = new BuildExecutionCheckRule(RuleId, "ConflictingOutputPath",
         "Two projects should not share their OutputPath nor IntermediateOutputPath locations",
         "Projects {0} and {1} have conflicting output paths: {2}.",
-        new BuildAnalyzerConfiguration() { RuleId = RuleId, Severity = BuildAnalyzerResultSeverity.Warning });
+        new BuildExecutionCheckConfiguration() { RuleId = RuleId, Severity = BuildExecutionCheckResultSeverity.Warning });
 
     public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
index ec285013977..bfd311d03dc 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
@@ -69,7 +69,7 @@ private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventAr
         {
             _buildCheckManager.StartProjectEvaluation(
                 BuildCheckDataSource.EventArgs,
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs.ProjectFile!);
         }
     }
@@ -77,7 +77,7 @@ private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventAr
     private void HandleProjectFinishedRequest(ProjectFinishedEventArgs eventArgs)
         => _buildCheckManager.EndProjectRequest(
                 BuildCheckDataSource.EventArgs,
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs!.ProjectFile!);
 
     private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
@@ -90,27 +90,27 @@ private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
 
     private void HandleTaskStartedEvent(TaskStartedEventArgs eventArgs)
         => _buildCheckManager.ProcessTaskStartedEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
     private void HandleTaskFinishedEvent(TaskFinishedEventArgs eventArgs)
         => _buildCheckManager.ProcessTaskFinishedEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
     private void HandleTaskParameterEvent(TaskParameterEventArgs eventArgs)
         => _buildCheckManager.ProcessTaskParameterEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
     private void HandleBuildCheckAcquisitionEvent(BuildCheckAcquisitionEventArgs eventArgs)
-        => _buildCheckManager.ProcessAnalyzerAcquisition(
-                eventArgs.ToAnalyzerAcquisitionData(),
-                _analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)));
+        => _buildCheckManager.ProcessCheckAcquisition(
+                eventArgs.ToCheckAcquisitionData(),
+                _checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)));
 
     private void HandleEnvironmentVariableReadEvent(EnvironmentVariableReadEventArgs eventArgs)
         => _buildCheckManager.ProcessEnvironmentVariableReadEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)),
+                _checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)),
                 eventArgs);
 
     private bool IsMetaProjFile(string? projectFile) => projectFile?.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase) == true;
@@ -119,15 +119,15 @@ private void HandleEnvironmentVariableReadEvent(EnvironmentVariableReadEventArgs
 
     private void HandleBuildFinishedEvent(BuildFinishedEventArgs eventArgs)
     {
-        _stats.Merge(_buildCheckManager.CreateAnalyzerTracingStats(), (span1, span2) => span1 + span2);
+        _stats.Merge(_buildCheckManager.CreateCheckTracingStats(), (span1, span2) => span1 + span2);
 
-        LogAnalyzerStats(_analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)));
+        LogCheckStats(_checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)));
     }
 
-    private void LogAnalyzerStats(ICheckContext analysisContext)
+    private void LogCheckStats(ICheckContext checkContext)
     {
         Dictionary<string, TimeSpan> infraStats = new Dictionary<string, TimeSpan>();
-        Dictionary<string, TimeSpan> analyzerStats = new Dictionary<string, TimeSpan>();
+        Dictionary<string, TimeSpan> checkStats = new Dictionary<string, TimeSpan>();
 
         foreach (var stat in _stats)
         {
@@ -138,20 +138,20 @@ private void LogAnalyzerStats(ICheckContext analysisContext)
             }
             else
             {
-                analyzerStats[stat.Key] = stat.Value;
+                checkStats[stat.Key] = stat.Value;
             }
         }
 
         BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_stats, true)
-        { BuildEventContext = analysisContext.BuildEventContext };
+        { BuildEventContext = checkContext.BuildEventContext };
 
-        analysisContext.DispatchBuildEvent(statEvent);
+        checkContext.DispatchBuildEvent(statEvent);
 
-        analysisContext.DispatchAsCommentFromText(MessageImportance.Low, $"BuildCheck run times{Environment.NewLine}");
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, $"BuildCheck run times{Environment.NewLine}");
         string infraData = BuildCsvString("Infrastructure run times", infraStats);
-        analysisContext.DispatchAsCommentFromText(MessageImportance.Low, infraData);
-        string analyzerData = BuildCsvString("Analyzer run times", analyzerStats);
-        analysisContext.DispatchAsCommentFromText(MessageImportance.Low, analyzerData);
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, infraData);
+        string checkData = BuildCsvString("Checks run times", checkStats);
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, checkData);
     }
 
     private string BuildCsvString(string title, Dictionary<string, TimeSpan> rowData)
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index ddcfa20f9d5..c796d502a7a 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -21,22 +21,22 @@ internal BuildCheckCentralContext(ConfigurationProvider configurationProvider)
         => _configurationProvider = configurationProvider;
 
     private record CallbackRegistry(
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>)> EvaluatedPropertiesActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<TaskInvocationAnalysisData>>)> TaskInvocationActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<PropertyReadData>>)> PropertyReadActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<PropertyWriteData>>)> PropertyWriteActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ProjectProcessingDoneData>>)> ProjectProcessingDoneActions)
+        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>)> EvaluatedPropertiesActions,
+        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<ParsedItemsCheckData>>)> ParsedItemsActions,
+        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<TaskInvocationCheckData>>)> TaskInvocationActions,
+        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<PropertyReadData>>)> PropertyReadActions,
+        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<PropertyWriteData>>)> PropertyWriteActions,
+        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<ProjectProcessingDoneData>>)> ProjectProcessingDoneActions)
     {
         public CallbackRegistry() : this([], [], [], [], [], []) { }
 
-        internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
+        internal void DeregisterCheck(BuildExecutionCheckWrapper check)
         {
-            EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == analyzer);
-            ParsedItemsActions.RemoveAll(a => a.Item1 == analyzer);
-            PropertyReadActions.RemoveAll(a => a.Item1 == analyzer);
-            PropertyWriteActions.RemoveAll(a => a.Item1 == analyzer);
-            ProjectProcessingDoneActions.RemoveAll(a => a.Item1 == analyzer);
+            EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == check);
+            ParsedItemsActions.RemoveAll(a => a.Item1 == check);
+            PropertyReadActions.RemoveAll(a => a.Item1 == check);
+            PropertyWriteActions.RemoveAll(a => a.Item1 == check);
+            ProjectProcessingDoneActions.RemoveAll(a => a.Item1 == check);
         }
     }
 
@@ -53,85 +53,85 @@ internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
     internal bool HasPropertyReadActions => _globalCallbacks.PropertyReadActions.Count > 0;
     internal bool HasPropertyWriteActions => _globalCallbacks.PropertyWriteActions.Count > 0;
 
-    internal void RegisterEvaluatedPropertiesAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
+    internal void RegisterEvaluatedPropertiesAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
         // Here we might want to communicate to node that props need to be sent.
         //  (it was being communicated via MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION)
-        => RegisterAction(analyzer, evaluatedPropertiesAction, _globalCallbacks.EvaluatedPropertiesActions);
+        => RegisterAction(check, evaluatedPropertiesAction, _globalCallbacks.EvaluatedPropertiesActions);
 
-    internal void RegisterParsedItemsAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
-        => RegisterAction(analyzer, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
+    internal void RegisterParsedItemsAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction)
+        => RegisterAction(check, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
 
-    internal void RegisterTaskInvocationAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
-        => RegisterAction(analyzer, taskInvocationAction, _globalCallbacks.TaskInvocationActions);
+    internal void RegisterTaskInvocationAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
+        => RegisterAction(check, taskInvocationAction, _globalCallbacks.TaskInvocationActions);
 
-    internal void RegisterPropertyReadAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction)
-        => RegisterAction(analyzer, propertyReadAction, _globalCallbacks.PropertyReadActions);
+    internal void RegisterPropertyReadAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction)
+        => RegisterAction(check, propertyReadAction, _globalCallbacks.PropertyReadActions);
 
-    internal void RegisterPropertyWriteAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction)
-        => RegisterAction(analyzer, propertyWriteAction, _globalCallbacks.PropertyWriteActions);
+    internal void RegisterPropertyWriteAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction)
+        => RegisterAction(check, propertyWriteAction, _globalCallbacks.PropertyWriteActions);
 
-    internal void RegisterProjectProcessingDoneAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<ProjectProcessingDoneData>> projectDoneAction)
-        => RegisterAction(analyzer, projectDoneAction, _globalCallbacks.ProjectProcessingDoneActions);
+    internal void RegisterProjectProcessingDoneAction(BuildExecutionCheckWrapper check, Action<BuildCheckDataContext<ProjectProcessingDoneData>> projectDoneAction)
+        => RegisterAction(check, projectDoneAction, _globalCallbacks.ProjectProcessingDoneActions);
 
     private void RegisterAction<T>(
-        BuildAnalyzerWrapper wrappedAnalyzer,
+        BuildExecutionCheckWrapper wrappedCheck,
         Action<BuildCheckDataContext<T>> handler,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
-        where T : AnalysisData
+        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
+        where T : CheckData
     {
         void WrappedHandler(BuildCheckDataContext<T> context)
         {
-            using var _ = wrappedAnalyzer.StartSpan();
+            using var _ = wrappedCheck.StartSpan();
             handler(context);
         }
 
         lock (handlersRegistry)
         {
-            handlersRegistry.Add((wrappedAnalyzer, WrappedHandler));
+            handlersRegistry.Add((wrappedCheck, WrappedHandler));
         }
     }
 
-    internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
+    internal void DeregisterCheck(BuildExecutionCheckWrapper check)
     {
-        _globalCallbacks.DeregisterAnalyzer(analyzer);
+        _globalCallbacks.DeregisterCheck(check);
     }
 
     internal void RunEvaluatedPropertiesActions(
-        EvaluatedPropertiesCheckData evaluatedPropertiesAnalysisData,
-        ICheckContext analysisContext,
-        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        EvaluatedPropertiesCheckData evaluatedPropertiesCheckData,
+        ICheckContext checkContext,
+        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesAnalysisData,
-            analysisContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesCheckData,
+            checkContext, resultHandler);
 
     internal void RunParsedItemsActions(
-        ParsedItemsAnalysisData parsedItemsAnalysisData,
-        ICheckContext analysisContext,
-        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        ParsedItemsCheckData parsedItemsCheckData,
+        ICheckContext checkContext,
+        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsAnalysisData,
-            analysisContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsCheckData,
+            checkContext, resultHandler);
 
     internal void RunTaskInvocationActions(
-        TaskInvocationAnalysisData taskInvocationAnalysisData,
-        ICheckContext analysisContext,
-        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        TaskInvocationCheckData taskInvocationCheckData,
+        ICheckContext checkContext,
+        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationAnalysisData,
-            analysisContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationCheckData,
+            checkContext, resultHandler);
 
     internal void RunPropertyReadActions(
         PropertyReadData propertyReadDataData,
-        AnalysisLoggingContext analysisContext,
-        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        CheckLoggingContext checkContext,
+        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.PropertyReadActions, propertyReadDataData,
-            analysisContext, resultHandler);
+            checkContext, resultHandler);
 
     internal void RunPropertyWriteActions(
         PropertyWriteData propertyWriteData,
-        AnalysisLoggingContext analysisContext,
-        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        CheckLoggingContext analysisContext,
+        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.PropertyWriteActions, propertyWriteData,
             analysisContext, resultHandler);
@@ -139,27 +139,27 @@ internal void RunPropertyWriteActions(
     internal void RunProjectProcessingDoneActions(
         ProjectProcessingDoneData projectProcessingDoneData,
         ICheckContext analysisContext,
-        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.ProjectProcessingDoneActions, projectProcessingDoneData,
             analysisContext, resultHandler);
 
     private void RunRegisteredActions<T>(
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
-        T analysisData,
-        ICheckContext analysisContext,
-        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> resultHandler)
-    where T : AnalysisData
+        List<(BuildExecutionCheckWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
+        T checkData,
+        ICheckContext checkContext,
+        Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult> resultHandler)
+    where T : CheckData
     {
-        string projectFullPath = analysisData.ProjectFilePath;
+        string projectFullPath = checkData.ProjectFilePath;
 
-        foreach (var analyzerCallback in registeredCallbacks)
+        foreach (var checkCallback in registeredCallbacks)
         {
             // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
             //  to the relevant analyzer (with BuildAnalyzerConfigurationEffectiveonly the currently accounted part as being the 'core-execution' subspan)
 
-            BuildAnalyzerConfigurationEffective? commonConfig = analyzerCallback.Item1.CommonConfig;
-            BuildAnalyzerConfigurationEffective[] configPerRule;
+            BuildExecutionCheckConfigurationEffective? commonConfig = checkCallback.Item1.CommonConfig;
+            BuildExecutionCheckConfigurationEffective[] configPerRule;
 
             if (commonConfig != null)
             {
@@ -174,7 +174,7 @@ private void RunRegisteredActions<T>(
             {
                 configPerRule =
                     _configurationProvider.GetMergedConfigurations(projectFullPath,
-                        analyzerCallback.Item1.BuildAnalyzer);
+                        checkCallback.Item1.BuildExecutionCheck);
                 if (configPerRule.All(c => !c.IsEnabled))
                 {
                     return;
@@ -186,13 +186,13 @@ private void RunRegisteredActions<T>(
             // https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57851137
 
             BuildCheckDataContext<T> context = new BuildCheckDataContext<T>(
-                analyzerCallback.Item1,
-                analysisContext,
+                checkCallback.Item1,
+                checkContext,
                 configPerRule,
                 resultHandler,
-                analysisData);
+                checkData);
 
-            analyzerCallback.Item2(context);
+            checkCallback.Item2(context);
         }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index d9f91a3b95f..5ab0bb84644 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -16,15 +16,15 @@ internal sealed class BuildCheckConnectorLogger : ILogger
 {
     private readonly BuildCheckBuildEventHandler _eventHandler;
     private readonly IBuildCheckManager _buildCheckManager;
-    private readonly ICheckContextFactory _analysisContextFactory;
+    private readonly ICheckContextFactory _checkContextFactory;
 
     internal BuildCheckConnectorLogger(
-        ICheckContextFactory analyzerContextFactory,
+        ICheckContextFactory checkContextFactory,
         IBuildCheckManager buildCheckManager)
     {
         _buildCheckManager = buildCheckManager;
-        _analysisContextFactory = analyzerContextFactory;
-        _eventHandler = new BuildCheckBuildEventHandler(analyzerContextFactory, buildCheckManager);
+        _checkContextFactory = checkContextFactory;
+        _eventHandler = new BuildCheckBuildEventHandler(checkContextFactory, buildCheckManager);
     }
 
     public LoggerVerbosity Verbosity { get; set; }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
index bc4f01f7ac5..cef7f60b980 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
@@ -7,20 +7,20 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal sealed class BuildCheckRegistrationContext(BuildAnalyzerWrapper analyzerWrapper, BuildCheckCentralContext buildCheckCentralContext) : IBuildCheckRegistrationContext
+internal sealed class BuildCheckRegistrationContext(BuildExecutionCheckWrapper checkWrapper, BuildCheckCentralContext buildCheckCentralContext) : IBuildCheckRegistrationContext
 {
     public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
     {
-        buildCheckCentralContext.RegisterEvaluatedPropertiesAction(analyzerWrapper, evaluatedPropertiesAction);
+        buildCheckCentralContext.RegisterEvaluatedPropertiesAction(checkWrapper, evaluatedPropertiesAction);
     }
 
-    public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
+    public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction)
     {
-        buildCheckCentralContext.RegisterParsedItemsAction(analyzerWrapper, parsedItemsAction);
+        buildCheckCentralContext.RegisterParsedItemsAction(checkWrapper, parsedItemsAction);
     }
 
-    public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
+    public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
     {
-        buildCheckCentralContext.RegisterTaskInvocationAction(analyzerWrapper, taskInvocationAction);
+        buildCheckCentralContext.RegisterTaskInvocationAction(checkWrapper, taskInvocationAction);
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 94b6966c1c8..4ea641981b3 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -19,7 +19,7 @@
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 internal delegate BuildExecutionCheck BuildExecutionCheckFactory();
-internal delegate BuildExecutionCheckWrapper BuildAnalyzerWrapperFactory(ConfigurationContext configurationContext);
+internal delegate BuildExecutionCheckWrapper BuildExecutionCheckWrapperFactory(ConfigurationContext configurationContext);
 
 /// <summary>
 /// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
@@ -70,14 +70,14 @@ internal sealed class BuildCheckManager : IBuildCheckManager, IBuildEngineDataRo
         private readonly TracingReporter _tracingReporter = new TracingReporter();
         private readonly ConfigurationProvider _configurationProvider = new ConfigurationProvider();
         private readonly BuildCheckCentralContext _buildCheckCentralContext;
-        private readonly List<BuildExecutionCheckFactoryContext> _analyzersRegistry;
+        private readonly List<BuildExecutionCheckFactoryContext> _checkRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
         private readonly BuildEventsProcessor _buildEventsProcessor;
         private readonly IBuildCheckAcquisitionModule _acquisitionModule;
 
         internal BuildCheckManager()
         {
-            _analyzersRegistry = new List<BuildExecutionCheckFactoryContext>();
+            _checkRegistry = new List<BuildExecutionCheckFactoryContext>();
             _acquisitionModule = new BuildCheckAcquisitionModule();
             _buildCheckCentralContext = new(_configurationProvider);
             _buildEventsProcessor = new(_buildCheckCentralContext);
@@ -97,35 +97,35 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
             if (!_enabledDataSources[(int)buildCheckDataSource])
             {
                 _enabledDataSources[(int)buildCheckDataSource] = true;
-                RegisterBuiltInAnalyzers(buildCheckDataSource);
+                RegisterBuiltInChecks(buildCheckDataSource);
             } 
             stopwatch.Stop();
             _tracingReporter.AddSetDataSourceStats(stopwatch.Elapsed);
         }
 
-        public void ProcessAnalyzerAcquisition(
+        public void ProcessChecksAcquisition(
             CheckAcquisitionData acquisitionData,
-            ICheckContext analysisContext)
+            ICheckContext checkContext)
         {
             Stopwatch stopwatch = Stopwatch.StartNew();
             if (IsInProcNode)
             {
-                var analyzersFactories = _acquisitionModule.CreateBuildExecutionCheckFactories(acquisitionData, analysisContext);
-                if (analyzersFactories.Count != 0)
+                var checkFactories = _acquisitionModule.CreateBuildExecutionCheckFactories(acquisitionData, checkContext);
+                if (checkFactories.Count != 0)
                 {
-                    RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, analyzersFactories, analysisContext);
+                    RegisterCustomCheck(BuildCheckDataSource.EventArgs, checkFactories, checkContext);
                 }
                 else
                 {
-                    analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerFailedAcquisition", acquisitionData.AssemblyPath);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerFailedAcquisition", acquisitionData.AssemblyPath);
                 }
             }
             else
             {
                 BuildCheckAcquisitionEventArgs eventArgs = acquisitionData.ToBuildEventArgs();
-                eventArgs.BuildEventContext = analysisContext.BuildEventContext!;
+                eventArgs.BuildEventContext = checkContext.BuildEventContext!;
 
-                analysisContext.DispatchBuildEvent(eventArgs);
+                checkContext.DispatchBuildEvent(eventArgs);
             }
 
             stopwatch.Stop();
@@ -138,9 +138,9 @@ private static readonly (string[] ruleIds, bool defaultEnablement, BuildExecutio
         [
             // BuildCheckDataSource.EventArgs
             [
-                ([SharedOutputPathAnalyzer.SupportedRule.Id], SharedOutputPathAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathAnalyzer>),
-                ([DoubleWritesAnalyzer.SupportedRule.Id], DoubleWritesAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesAnalyzer>),
-                ([NoEnvironmentVariablePropertyAnalyzer.SupportedRule.Id], NoEnvironmentVariablePropertyAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyAnalyzer>)
+                ([SharedOutputPathCheck.SupportedRule.Id], SharedOutputPathCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathCheck>),
+                ([DoubleWritesCheck.SupportedRule.Id], DoubleWritesCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesCheck>),
+                ([NoEnvironmentVariablePropertyCheck.SupportedRule.Id], NoEnvironmentVariablePropertyCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyCheck>)
             ],
             // BuildCheckDataSource.Execution
             []
@@ -151,15 +151,15 @@ private static readonly (string[] ruleIds, bool defaultEnablement, BuildExecutio
         /// </summary>
         internal static (string[] ruleIds, bool defaultEnablement, BuildExecutionCheckFactory factory)[][]? s_testFactoriesPerDataSource;
 
-        private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
+        private void RegisterBuiltInChecks(BuildCheckDataSource buildCheckDataSource)
         {
-            _analyzersRegistry.AddRange(
+            _ChecksRegistry.AddRange(
                 s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
                     .Select(v => new BuildExecutionCheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
 
             if (s_testFactoriesPerDataSource is not null)
             {
-                _analyzersRegistry.AddRange(
+                _checksRegistry.AddRange(
                     s_testFactoriesPerDataSource[(int)buildCheckDataSource]
                         .Select(v => new BuildExecutionCheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
             }
@@ -169,21 +169,21 @@ private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
         /// To be used by acquisition module.
         /// Registers the custom analyzers, the construction of analyzers is deferred until the first using project is encountered.
         /// </summary>
-        internal void RegisterCustomAnalyzers(
+        internal void RegisterCustomChecks(
             BuildCheckDataSource buildCheckDataSource,
             IEnumerable<BuildExecutionCheckFactory> factories,
             string[] ruleIds,
             bool defaultEnablement,
-            ICheckContext analysisContext)
+            ICheckContext checkContext)
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
             {
                 foreach (BuildExecutionCheckFactory factory in factories)
                 {
-                    _analyzersRegistry.Add(new BuildExecutionCheckFactoryContext(factory, ruleIds, defaultEnablement));
+                    _checksRegistry.Add(new BuildExecutionCheckFactoryContext(factory, ruleIds, defaultEnablement));
 
                     var instance = factory();
-                    analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
                 }
             }
         }
@@ -195,55 +195,55 @@ internal void RegisterCustomAnalyzers(
         /// <param name="buildCheckDataSource">Represents different data sources used in build check operations.</param>
         /// <param name="factories">A collection of build analyzer factories for rules instantiation.</param>
         /// <param name="analysisContext">The logging context of the build event.</param>
-        internal void RegisterCustomAnalyzer(
+        internal void RegisterCustomCheck(
             BuildCheckDataSource buildCheckDataSource,
             IEnumerable<BuildExecutionCheckFactory> factories,
-            ICheckContext analysisContext)
+            ICheckContext checkContext)
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
             {
                 foreach (var factory in factories)
                 {
                     var instance = factory();
-                    _analyzersRegistry.Add(new BuildExecutionCheckFactoryContext(
+                    _checksRegistry.Add(new BuildExecutionCheckFactoryContext(
                         factory,
                         instance.SupportedRules.Select(r => r.Id).ToArray(),
                         instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
-                    analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
                 }
             }
         }
 
-        private void SetupSingleAnalyzer(BuildExecutionCheckFactoryContext analyzerFactoryContext, string projectFullPath)
+        private void SetupSingleCheck(BuildExecutionCheckFactoryContext checkFactoryContext, string projectFullPath)
         {
             // For custom analyzers - it should run only on projects where referenced
             // (otherwise error out - https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57849480)
             // on others it should work similarly as disabling them.
             // Disabled analyzer should not only post-filter results - it shouldn't even see the data 
             BuildExecutionCheckWrapper wrapper;
-            BuildAnalyzerConfigurationEffective[] configurations;
-            if (analyzerFactoryContext.MaterializedAnalyzer == null)
+            BuildExecutionCheckConfigurationEffective[] configurations;
+            if (checkFactoryContext.MaterializedCheck == null)
             {
                 BuildExecutionCheckConfiguration[] userConfigs =
-                    _configurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetUserConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
-                if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
+                if (userConfigs.All(c => !(c.IsEnabled ?? checkFactoryContext.IsEnabledByDefault)))
                 {
                     // the analyzer was not yet instantiated nor mounted - so nothing to do here now.
                     return;
                 }
 
                 CustomConfigurationData[] customConfigData =
-                    _configurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetCustomConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
-                BuildExecutionCheck uninitializedAnalyzer = analyzerFactoryContext.Factory();
-                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, uninitializedAnalyzer);
+                BuildExecutionCheck uninitializedCheck = checkFactoryContext.Factory();
+                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, uninitializedCheck);
 
                 ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData, configurations);
 
-                wrapper = analyzerFactoryContext.Initialize(uninitializedAnalyzer, configurationContext);
-                analyzerFactoryContext.MaterializedAnalyzer = wrapper;
-                BuildExecutionCheck analyzer = wrapper.BuildAnalyzer;
+                wrapper = checkFactoryContext.Initialize(uninitializedCheck, configurationContext);
+                checkFactoryContext.MaterializedCheck = wrapper;
+                BuildExecutionCheck check = wrapper.BuildExecutionCheck;
 
                 // This is to facilitate possible perf improvement for custom analyzers - as we might want to
                 //  avoid loading the assembly and type just to check if it's supported.
@@ -251,14 +251,14 @@ private void SetupSingleAnalyzer(BuildExecutionCheckFactoryContext analyzerFacto
                 //  optional arguments of the intrinsic property function) - we can then avoid loading it.
                 // But once loaded - we should verify that the declared enablement status and rule ids match the actual ones.
                 if (
-                    analyzer.SupportedRules.Count != analyzerFactoryContext.RuleIds.Length
+                    check.SupportedRules.Count != checkFactoryContext.RuleIds.Length
                     ||
-                    !analyzer.SupportedRules.Select(r => r.Id)
-                        .SequenceEqual(analyzerFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
+                    !check.SupportedRules.Select(r => r.Id)
+                        .SequenceEqual(checkFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
                 )
                 {
                     throw new BuildCheckConfigurationException(
-                        $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
+                        $"The analyzer '{check.FriendlyName}' exposes rules '{check.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{checkFactoryContext.RuleIds.ToCsvString()}'");
                 }
 
                 // technically all analyzers rules could be disabled, but that would mean
@@ -268,66 +268,66 @@ private void SetupSingleAnalyzer(BuildExecutionCheckFactoryContext analyzerFacto
                 // Create the wrapper and register to central context
                 wrapper.StartNewProject(projectFullPath, configurations);
                 var wrappedContext = new BuildCheckRegistrationContext(wrapper, _buildCheckCentralContext);
-                analyzer.RegisterActions(wrappedContext);
+                check.RegisterActions(wrappedContext);
             }
             else
             {
-                wrapper = analyzerFactoryContext.MaterializedAnalyzer;
+                wrapper = checkFactoryContext.MaterializedCheck;
 
-                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildExecutionCheck);
 
                 _configurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
-                    analyzerFactoryContext.RuleIds[0]);
+                    checkFactoryContext.RuleIds[0]);
 
                 // Update the wrapper
                 wrapper.StartNewProject(projectFullPath, configurations);
             }
 
-            if (configurations.GroupBy(c => c.EvaluationAnalysisScope).Count() > 1)
+            if (configurations.GroupBy(c => c.EvaluationCheckScope).Count() > 1)
             {
                 throw new BuildCheckConfigurationException(
                     string.Format("All rules for a single analyzer should have the same EvaluationAnalysisScope for a single project (violating rules: [{0}], project: {1})",
-                        analyzerFactoryContext.RuleIds.ToCsvString(),
+                        checkFactoryContext.RuleIds.ToCsvString(),
                         projectFullPath));
             }
         }
 
-        private void SetupAnalyzersForNewProject(string projectFullPath, ICheckContext analysisContext)
+        private void SetupChecksForNewProject(string projectFullPath, ICheckContext checkContext)
         {
             // Only add analyzers here
             // On an execution node - we might remove and dispose the analyzers once project is done
 
             // If it's already constructed - just control the custom settings do not differ
             Stopwatch stopwatch = Stopwatch.StartNew();
-            List<BuildExecutionCheckFactoryContext> analyzersToRemove = new();
-            foreach (BuildExecutionCheckFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            List<BuildExecutionCheckFactoryContext> checksToRemove = new();
+            foreach (BuildExecutionCheckFactoryContext checkFactoryContext in _checksRegistry)
             {
                 try
                 {
-                    SetupSingleAnalyzer(analyzerFactoryContext, projectFullPath);
+                    SetupSingleCheck(checkFactoryContext, projectFullPath);
                 }
                 catch (BuildCheckConfigurationException e)
                 {
-                    analysisContext.DispatchAsErrorFromText(
+                    checkContext.DispatchAsErrorFromText(
                         null,
                         null,
                         null,
                         new BuildEventFileInfo(projectFullPath),
                         e.Message);
-                    analyzersToRemove.Add(analyzerFactoryContext);
+                    checksToRemove.Add(checkFactoryContext);
                 }
             }
 
-            analyzersToRemove.ForEach(c =>
+            checksToRemove.ForEach(c =>
             {
-                _analyzersRegistry.Remove(c);
-                analysisContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting analyzer '{c.FriendlyName}'");
+                _checksRegistry.Remove(c);
+                checkContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting analyzer '{c.FriendlyName}'");
             });
-            foreach (var analyzerToRemove in analyzersToRemove.Select(a => a.MaterializedAnalyzer).Where(a => a != null))
+            foreach (var checkToRemove in checksToRemove.Select(a => a.MaterializedCheck).Where(a => a != null))
             {
-                _buildCheckCentralContext.DeregisterAnalyzer(analyzerToRemove!);
-                _tracingReporter.AddAnalyzerStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
-                analyzerToRemove.BuildAnalyzer.Dispose();
+                _buildCheckCentralContext.DeregisterCheck(checkToRemove!);
+                _tracingReporter.AddCheckStats(checkToRemove!.BuildCheck.FriendlyName, checkToRemove.Elapsed);
+                checkToRemove.BuildExecutionCheck.Dispose();
             }
 
             stopwatch.Stop();
@@ -335,12 +335,12 @@ private void SetupAnalyzersForNewProject(string projectFullPath, ICheckContext a
         }
 
         public void ProcessEvaluationFinishedEventArgs(
-            ICheckContext analysisContext,
+            ICheckContext checkContext,
             ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
             => _buildEventsProcessor
-                .ProcessEvaluationFinishedEventArgs(analysisContext, evaluationFinishedEventArgs);
+                .ProcessEvaluationFinishedEventArgs(checkContext, evaluationFinishedEventArgs);
 
-        public void ProcessEnvironmentVariableReadEventArgs(ICheckContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
+        public void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
         {
             if (projectEvaluationEventArgs is EnvironmentVariableReadEventArgs evr)
             {
@@ -354,35 +354,35 @@ public void ProcessEnvironmentVariableReadEventArgs(ICheckContext analysisContex
         }
 
         public void ProcessTaskStartedEventArgs(
-            ICheckContext analysisContext,
+            ICheckContext checkContext,
             TaskStartedEventArgs taskStartedEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskStartedEventArgs(analysisContext, taskStartedEventArgs);
+                .ProcessTaskStartedEventArgs(checkContext, taskStartedEventArgs);
 
         public void ProcessTaskFinishedEventArgs(
-            ICheckContext analysisContext,
+            ICheckContext checkContext,
             TaskFinishedEventArgs taskFinishedEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskFinishedEventArgs(analysisContext, taskFinishedEventArgs);
+                .ProcessTaskFinishedEventArgs(checkContext, taskFinishedEventArgs);
 
         public void ProcessTaskParameterEventArgs(
-            ICheckContext analysisContext,
+            ICheckContext checkContext,
             TaskParameterEventArgs taskParameterEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskParameterEventArgs(analysisContext, taskParameterEventArgs);
+                .ProcessTaskParameterEventArgs(checkContext, taskParameterEventArgs);
 
-        public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats()
+        public Dictionary<string, TimeSpan> CreateCheckTracingStats()
         {
-            foreach (BuildExecutionCheckFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            foreach (BuildExecutionCheckFactoryContext checkFactoryContext in _checksRegistry)
             {
-                if (analyzerFactoryContext.MaterializedAnalyzer != null)
+                if (checkFactoryContext.MaterializedCheck != null)
                 {
-                    _tracingReporter.AddAnalyzerStats(analyzerFactoryContext.FriendlyName, analyzerFactoryContext.MaterializedAnalyzer.Elapsed);
-                    analyzerFactoryContext.MaterializedAnalyzer.ClearStats();
+                    _tracingReporter.AddCheckStats(checkFactoryContext.FriendlyName, checkFactoryContext.MaterializedCheck.Elapsed);
+                    checkFactoryContext.MaterializedCheck.ClearStats();
                 }
             }
 
-            _tracingReporter.AddAnalyzerInfraStats();
+            _tracingReporter.AddCheckInfraStats();
             return _tracingReporter.TracingStats;
         }
 
@@ -394,11 +394,11 @@ public void FinalizeProcessing(LoggingContext loggingContext)
                 return;
             }
 
-            var analyzerEventStats = CreateAnalyzerTracingStats();
+            var checkEventStats = CreateCheckTracingStats();
 
-            BuildCheckTracingEventArgs analyzerEventArg =
-                new(analyzerEventStats) { BuildEventContext = loggingContext.BuildEventContext };
-            loggingContext.LogBuildEvent(analyzerEventArg);
+            BuildCheckTracingEventArgs checkEventArg =
+                new(checkEventStats) { BuildEventContext = loggingContext.BuildEventContext };
+            loggingContext.LogBuildEvent(checkEventArg);
         }
 
         private readonly ConcurrentDictionary<int, string> _projectsByContextId = new();
@@ -430,7 +430,7 @@ private string GetProjectFullPath(BuildEventContext buildEventContext)
 
         public void StartProjectEvaluation(
             BuildCheckDataSource buildCheckDataSource,
-            ICheckContext analysisContext,
+            ICheckContext checkContext,
             string projectFullPath)
         {
             if (buildCheckDataSource == BuildCheckDataSource.EventArgs && IsInProcNode)
@@ -441,8 +441,8 @@ public void StartProjectEvaluation(
                 return;
             }
 
-            SetupAnalyzersForNewProject(projectFullPath, analysisContext);
-            _projectsByContextId[analysisContext.BuildEventContext.ProjectContextId] = projectFullPath;
+            SetupChecksForNewProject(projectFullPath, checkContext);
+            _projectsByContextId[checkContext.BuildEventContext.ProjectContextId] = projectFullPath;
         }
 
         /*
@@ -464,14 +464,14 @@ public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, Build
 
         public void EndProjectRequest(
             BuildCheckDataSource buildCheckDataSource,
-            ICheckContext analysisContext,
+            ICheckContext checkContext,
             string projectFullPath)
         {
-            _buildEventsProcessor.ProcessProjectDone(analysisContext, projectFullPath);
-            _projectsByContextId.TryRemove(analysisContext.BuildEventContext.ProjectContextId, out _);
+            _buildEventsProcessor.ProcessProjectDone(checkContext, projectFullPath);
+            _projectsByContextId.TryRemove(checkContext.BuildEventContext.ProjectContextId, out _);
         }
 
-        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
         {
             if (!_buildCheckCentralContext.HasPropertyReadActions)
             {
@@ -479,13 +479,13 @@ public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggi
             }
 
             PropertyReadData propertyReadData = new(
-                GetProjectFullPath(analysisContext.BuildEventContext),
-                analysisContext.BuildEventContext.ProjectInstanceId,
+                GetProjectFullPath(checkContext.BuildEventContext),
+                checkContext.BuildEventContext.ProjectInstanceId,
                 propertyReadInfo);
-            _buildEventsProcessor.ProcessPropertyRead(propertyReadData, analysisContext);
+            _buildEventsProcessor.ProcessPropertyRead(propertyReadData, checkContext);
         }
 
-        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
         {
             if (!_buildCheckCentralContext.HasPropertyWriteActions)
             {
@@ -493,10 +493,10 @@ public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLo
             }
 
             PropertyWriteData propertyWriteData = new(
-                GetProjectFullPath(analysisContext.BuildEventContext),
-                analysisContext.BuildEventContext.ProjectInstanceId,
+                GetProjectFullPath(checkContext.BuildEventContext),
+                checkContext.BuildEventContext.ProjectInstanceId,
                 propertyWriteInfo);
-            _buildEventsProcessor.ProcessPropertyWrite(propertyWriteData, analysisContext);
+            _buildEventsProcessor.ProcessPropertyWrite(propertyWriteData, checkContext);
         }
 
         public void Shutdown()
@@ -519,13 +519,13 @@ public BuildExecutionCheckWrapper Initialize(BuildExecutionCheck ba, Configurati
                 return new BuildExecutionCheckWrapper(ba);
             }
 
-            public BuildExecutionCheckWrapper? MaterializedAnalyzer { get; set; }
+            public BuildExecutionCheckWrapper? MaterializedCheck { get; set; }
 
             public string[] RuleIds { get; init; } = ruleIds;
 
             public bool IsEnabledByDefault { get; init; } = isEnabledByDefault;
 
-            public string FriendlyName => MaterializedAnalyzer?.BuildAnalyzer.FriendlyName ?? factory().FriendlyName;
+            public string FriendlyName => MaterializedCheck?.BuildCheck.FriendlyName ?? factory().FriendlyName;
         }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs
index 9405818dc9f..515b050a8cc 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs
@@ -43,7 +43,7 @@ public static IEventSource GetMergedEventSource(
 
         // Create BuildCheckBuildEventHandler that passes new events to the mergedEventSource
         var buildCheckEventHandler = new BuildCheckBuildEventHandler(
-            new AnalysisDispatchingContextFactory(mergedEventSource),
+            new CheckDispatchingContextFactory(mergedEventSource),
             buildCheckManagerProvider.Instance);
 
         // Pass the events from replayEventSource to the BuildCheckBuildEventHandler to produce new events
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index 93f693a81c7..b3a555da595 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -22,8 +22,8 @@ internal class BuildEventsProcessor(BuildCheckCentralContext buildCheckCentralCo
     /// </remarks>
     private struct ExecutingTaskData
     {
-        public TaskInvocationAnalysisData AnalysisData;
-        public Dictionary<string, TaskInvocationAnalysisData.TaskParameter> TaskParameters;
+        public TaskInvocationCheckData CheckData;
+        public Dictionary<string, TaskInvocationCheckData.TaskParameter> TaskParameters;
     }
 
     /// <summary>
@@ -47,20 +47,20 @@ public TaskKey(BuildEventContext context)
 
     // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
     internal void ProcessEvaluationFinishedEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checkContext,
         ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
     {
         Dictionary<string, string> propertiesLookup = new Dictionary<string, string>();
         Internal.Utilities.EnumerateProperties(evaluationFinishedEventArgs.Properties, propertiesLookup,
             static (dict, kvp) => dict.Add(kvp.Key, kvp.Value));
 
-        EvaluatedPropertiesCheckData analysisData =
+        EvaluatedPropertiesCheckData checkData =
             new(evaluationFinishedEventArgs.ProjectFile!,
                 evaluationFinishedEventArgs.BuildEventContext?.ProjectInstanceId,
                 propertiesLookup,
                 _evaluatedEnvironmentVariables);
 
-        _buildCheckCentralContext.RunEvaluatedPropertiesActions(analysisData, analysisContext, ReportResult);
+        _buildCheckCentralContext.RunEvaluatedPropertiesActions(checkData, checkContext, ReportResult);
 
         if (_buildCheckCentralContext.HasParsedItemsActions)
         {
@@ -68,12 +68,12 @@ internal void ProcessEvaluationFinishedEventArgs(
                 evaluationFinishedEventArgs.ProjectFile!, /*unused*/
                 null, /*unused*/null, _cache, false /*Not explicitly loaded - unused*/);
 
-            ParsedItemsAnalysisData itemsAnalysisData = new(
+            ParsedItemsCheckData itemsCheckData = new(
                 evaluationFinishedEventArgs.ProjectFile!,
                 evaluationFinishedEventArgs.BuildEventContext?.ProjectInstanceId,
                 new ItemsHolder(xml.Items, xml.ItemGroups));
 
-            _buildCheckCentralContext.RunParsedItemsActions(itemsAnalysisData, analysisContext, ReportResult);
+            _buildCheckCentralContext.RunParsedItemsActions(itemsCheckData, checkContext, ReportResult);
         }
     }
 
@@ -89,7 +89,7 @@ internal void ProcessEnvironmentVariableReadEventArgs(string envVarName, string
     }
 
     internal void ProcessTaskStartedEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checkContext,
         TaskStartedEventArgs taskStartedEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
@@ -107,12 +107,12 @@ internal void ProcessTaskStartedEventArgs(
 
             // Add a new entry to _tasksBeingExecuted. TaskParameters are initialized empty and will be recorded
             // based on TaskParameterEventArgs we receive later.
-            Dictionary<string, TaskInvocationAnalysisData.TaskParameter> taskParameters = new();
+            Dictionary<string, TaskInvocationCheckData.TaskParameter> taskParameters = new();
 
             ExecutingTaskData taskData = new()
             {
                 TaskParameters = taskParameters,
-                AnalysisData = new(
+                CheckData = new(
                     projectFilePath: taskStartedEventArgs.ProjectFile!,
                     projectConfigurationId: taskStartedEventArgs.BuildEventContext.ProjectInstanceId,
                     taskInvocationLocation: invocationLocation,
@@ -126,7 +126,7 @@ internal void ProcessTaskStartedEventArgs(
     }
 
     internal void ProcessTaskFinishedEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checkContext,
         TaskFinishedEventArgs taskFinishedEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
@@ -142,13 +142,13 @@ internal void ProcessTaskFinishedEventArgs(
             {
                 // All task parameters have been recorded by now so remove the task from the dictionary and fire the registered build check actions.
                 _tasksBeingExecuted.Remove(taskKey);
-                _buildCheckCentralContext.RunTaskInvocationActions(taskData.AnalysisData, analysisContext, ReportResult);
+                _buildCheckCentralContext.RunTaskInvocationActions(taskData.CheckData, checkContext, ReportResult);
             }
         }
     }
 
     internal void ProcessTaskParameterEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checkContext,
         TaskParameterEventArgs taskParameterEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
@@ -177,46 +177,46 @@ internal void ProcessTaskParameterEventArgs(
                 _ => taskParameterEventArgs.Items,
             };
 
-            taskData.TaskParameters[parameterName] = new TaskInvocationAnalysisData.TaskParameter(parameterValue, isOutput);
+            taskData.TaskParameters[parameterName] = new TaskInvocationCheckData.TaskParameter(parameterValue, isOutput);
         }
     }
 
-    public void ProcessPropertyRead(PropertyReadData propertyReadData, AnalysisLoggingContext analysisContext)
+    public void ProcessPropertyRead(PropertyReadData propertyReadData, CheckLoggingContext checkContext)
         => _buildCheckCentralContext.RunPropertyReadActions(
                 propertyReadData,
-                analysisContext,
+                checkContext,
                 ReportResult);
 
-    public void ProcessPropertyWrite(PropertyWriteData propertyWriteData, AnalysisLoggingContext analysisContext)
+    public void ProcessPropertyWrite(PropertyWriteData propertyWriteData, CheckLoggingContext checkContext)
         => _buildCheckCentralContext.RunPropertyWriteActions(
                 propertyWriteData,
-                analysisContext,
+                checkContext,
                 ReportResult);
 
-    public void ProcessProjectDone(ICheckContext analysisContext, string projectFullPath)
+    public void ProcessProjectDone(ICheckContext checkContext, string projectFullPath)
         => _buildCheckCentralContext.RunProjectProcessingDoneActions(
-                new ProjectProcessingDoneData(projectFullPath, analysisContext.BuildEventContext.ProjectInstanceId),
-                analysisContext,
+                new ProjectProcessingDoneData(projectFullPath, checkContext.BuildEventContext.ProjectInstanceId),
+                checkContext,
                 ReportResult);
 
     private static void ReportResult(
-        BuildAnalyzerWrapper analyzerWrapper,
-        ICheckContext analysisContext,
-        BuildAnalyzerConfigurationEffective[] configPerRule,
+        BuildExecutionCheckWrapper checkWrapper,
+        ICheckContext checkContext,
+        BuildExecutionCheckConfigurationEffective[] configPerRule,
         BuildCheckResult result)
     {
-        if (!analyzerWrapper.BuildAnalyzer.SupportedRules.Contains(result.BuildAnalyzerRule))
+        if (!checkWrapper.BuildExecutionCheck.SupportedRules.Contains(result.BuildExecutionCheckRule))
         {
-            analysisContext.DispatchAsErrorFromText(null, null, null,
+            checkContext.DispatchAsErrorFromText(null, null, null,
                 BuildEventFileInfo.Empty,
-                $"The analyzer '{analyzerWrapper.BuildAnalyzer.FriendlyName}' reported a result for a rule '{result.BuildAnalyzerRule.Id}' that it does not support.");
+                $"The analyzer '{checkWrapper.BuildExecutionCheck.FriendlyName}' reported a result for a rule '{result.BuildExecutionCheckRule.Id}' that it does not support.");
             return;
         }
 
-        BuildAnalyzerConfigurationEffective config = configPerRule.Length == 1
+        BuildExecutionCheckConfigurationEffective config = configPerRule.Length == 1
             ? configPerRule[0]
             : configPerRule.First(r =>
-                r.RuleId.Equals(result.BuildAnalyzerRule.Id, StringComparison.CurrentCultureIgnoreCase));
+                r.RuleId.Equals(result.BuildExecutionCheckRule.Id, StringComparison.CurrentCultureIgnoreCase));
 
         if (!config.IsEnabled)
         {
@@ -229,6 +229,6 @@ private static void ReportResult(
         // eventArgs.BuildEventContext = loggingContext.BuildEventContext;
         eventArgs.BuildEventContext = BuildEventContext.Invalid;
 
-        analysisContext.DispatchBuildEvent(eventArgs);
+        checkContext.DispatchBuildEvent(eventArgs);
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationEffective.cs b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckConfigurationEffective.cs
similarity index 56%
rename from src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationEffective.cs
rename to src/Build/BuildCheck/Infrastructure/BuildExecutionCheckConfigurationEffective.cs
index 2b7bbf16ebc..e1bad8f76c3 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationEffective.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckConfigurationEffective.cs
@@ -9,33 +9,33 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// <summary>
 /// Counterpart type for BuildAnalyzerConfiguration - with all properties non-nullable
 /// </summary>
-public sealed class BuildAnalyzerConfigurationEffective
+public sealed class BuildExecutionCheckConfigurationEffective
 {
-    public BuildAnalyzerConfigurationEffective(string ruleId, EvaluationAnalysisScope evaluationAnalysisScope, BuildAnalyzerResultSeverity severity)
+    public BuildExecutionCheckConfigurationEffective(string ruleId, EvaluationCheckScope evaluationCheckScope, BuildExecutionCheckResultSeverity severity)
     {
-        if (severity == BuildAnalyzerResultSeverity.Default)
+        if (severity == BuildExecutionCheckResultSeverity.Default)
         {
             throw new ArgumentOutOfRangeException(nameof(severity), severity, "Severity 'Default' is not recognized by the BuildCheck reports infrastructure");
         }
 
         RuleId = ruleId;
-        EvaluationAnalysisScope = evaluationAnalysisScope;
+        EvaluationCheckScope = evaluationCheckScope;
         Severity = severity;
     }
 
     public string RuleId { get; }
 
-    public EvaluationAnalysisScope EvaluationAnalysisScope { get; }
+    public EvaluationCheckScope EvaluationCheckScope { get; }
 
-    public BuildAnalyzerResultSeverity Severity { get; }
+    public BuildExecutionCheckResultSeverity Severity { get; }
 
-    public bool IsEnabled => Severity >= BuildAnalyzerResultSeverity.Suggestion;
+    public bool IsEnabled => Severity >= BuildExecutionCheckResultSeverity.Suggestion;
 
     // Intentionally not checking the RuleId
     //  as for analyzers with multiple rules, we can squash config to a single one,
     //  if the ruleId is the only thing differing.
-    public bool IsSameConfigurationAs(BuildAnalyzerConfigurationEffective? other) =>
+    public bool IsSameConfigurationAs(BuildExecutionCheckConfigurationEffective? other) =>
         other != null &&
         Severity == other.Severity &&
-        EvaluationAnalysisScope == other.EvaluationAnalysisScope;
+        EvaluationCheckScope == other.EvaluationCheckScope;
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckWrapper.cs
similarity index 85%
rename from src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
rename to src/Build/BuildCheck/Infrastructure/BuildExecutionCheckWrapper.cs
index 8f560f561c5..61d8521de2f 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildExecutionCheckWrapper.cs
@@ -17,22 +17,22 @@ internal sealed class BuildExecutionCheckWrapper
 {
     private readonly Stopwatch _stopwatch = new Stopwatch();
 
-    public BuildExecutionCheckWrapper(BuildExecutionCheck buildAnalyzer)
+    public BuildExecutionCheckWrapper(BuildExecutionCheck buildExecutionCheck)
     {
-        BuildAnalyzer = buildAnalyzer;
+        BuildExecutionCheck = buildExecutionCheck;
     }
 
-    internal BuildExecutionCheck BuildAnalyzer { get; }
+    internal BuildExecutionCheck BuildExecutionCheck { get; }
     private bool _isInitialized = false;
 
     // Let's optimize for the scenario where users have a single .editorconfig file that applies to the whole solution.
     // In such case - configuration will be same for all projects. So we do not need to store it per project in a collection.
-    internal BuildAnalyzerConfigurationEffective? CommonConfig { get; private set; }
+    internal BuildExecutionCheckConfigurationEffective? CommonConfig { get; private set; }
 
     // start new project
     internal void StartNewProject(
         string fullProjectPath,
-        IReadOnlyList<BuildAnalyzerConfigurationEffective> userConfigs)
+        IReadOnlyList<BuildExecutionCheckConfigurationEffective> userConfigs)
     {
         if (!_isInitialized)
         {
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
similarity index 96%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
index bf69888f476..71befe7991b 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
@@ -17,12 +17,12 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// <see cref="ICheckContext"/> that uses <see cref="EventArgsDispatcher"/> to dispatch.
 /// </summary>
-internal class AnalysisDispatchingContext : ICheckContext
+internal class CheckDispatchingContext : ICheckContext
 {
     private readonly EventArgsDispatcher _eventDispatcher;
     private readonly BuildEventContext _eventContext;
 
-    public AnalysisDispatchingContext(
+    public CheckDispatchingContext(
         EventArgsDispatcher dispatch,
         BuildEventContext eventContext)
     {
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs
similarity index 62%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs
index 1751c3c0d32..6c536a14df9 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs
@@ -6,19 +6,19 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal class AnalysisDispatchingContextFactory : ICheckContextFactory
+internal class CheckDispatchingContextFactory : ICheckContextFactory
 {
     private readonly EventArgsDispatcher _eventDispatcher;
 
     public event AnyEventHandler? AnyEventRaised;
 
-    public AnalysisDispatchingContextFactory(EventArgsDispatcher eventDispatcher)
+    public CheckDispatchingContextFactory(EventArgsDispatcher eventDispatcher)
     {
         _eventDispatcher = eventDispatcher;
 
         _eventDispatcher.AnyEventRaised += (sender, e) => AnyEventRaised?.Invoke(sender, e);
     }
 
-    public ICheckContext CreateAnalysisContext(BuildEventContext eventContext)
-        => new AnalysisDispatchingContext(_eventDispatcher, eventContext);
+    public ICheckContext CreateCheckContext(BuildEventContext eventContext)
+        => new CheckDispatchingContext(_eventDispatcher, eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
similarity index 93%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
index 77aebf274b9..c295b254f49 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// Making this a record struct to avoid allocations (unless called through interface - which leads to boxing).
 /// This is wanted since this can be used in a hot path (of property reads and writes)
 /// </remarks>
-internal readonly struct AnalysisLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
+internal readonly struct CheckLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
     : ICheckContext
 {
     public BuildEventContext BuildEventContext => eventContext;
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs
similarity index 57%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs
index 0d1f49f5f0c..5f429c94b02 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs
@@ -11,12 +11,12 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal class AnalysisLoggingContextFactory : ICheckContextFactory
+internal class CheckLoggingContextFactory : ICheckContextFactory
 {
     private readonly ILoggingService _loggingService;
 
-    public AnalysisLoggingContextFactory(ILoggingService loggingService) => _loggingService = loggingService;
+    public CheckLoggingContextFactory(ILoggingService loggingService) => _loggingService = loggingService;
 
-    public ICheckContext CreateAnalysisContext(BuildEventContext eventContext)
-        => new AnalysisLoggingContext(_loggingService, eventContext);
+    public ICheckContext CreateCheckContext(BuildEventContext eventContext)
+        => new CheckLoggingContext(_loggingService, eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
similarity index 100%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
similarity index 78%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
index 1010e803ed0..da90050598d 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
@@ -7,5 +7,5 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 
 internal interface ICheckContextFactory
 {
-    ICheckContext CreateAnalysisContext(BuildEventContext eventContext);
+    ICheckContext CreateCheckContext(BuildEventContext eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index a927682ef76..944915af262 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -20,7 +20,7 @@ internal sealed class ConfigurationProvider
     /// <summary>
     /// The dictionary used for storing the BuildAnalyzerConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
     /// </summary>
-    private readonly ConcurrentDictionary<string, BuildAnalyzerConfiguration> _buildAnalyzerConfiguration = new ConcurrentDictionary<string, BuildAnalyzerConfiguration>(StringComparer.InvariantCultureIgnoreCase);
+    private readonly ConcurrentDictionary<string, BuildExecutionCheckConfiguration> _buildExecutionCheckConfiguration = new ConcurrentDictionary<string, BuildExecutionCheckConfiguration>(StringComparer.InvariantCultureIgnoreCase);
 
     /// <summary>
     /// The dictionary used for storing the key-value pairs retrieved from the .editorconfigs for specific projectfile. The key is equal to projectFullPath.
@@ -101,12 +101,12 @@ internal void VerifyCustomConfigurationEquality(string ruleId, CustomConfigurati
         }
     }
 
-    internal BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
+    internal BuildExecutionCheckConfigurationEffective[] GetMergedConfigurations(
         string projectFullPath,
-        BuildAnalyzer analyzer)
-        => FillConfiguration(projectFullPath, analyzer.SupportedRules, GetMergedConfiguration);
+        BuildExecutionCheck check)
+        => FillConfiguration(projectFullPath, check.SupportedRules, GetMergedConfiguration);
 
-    internal BuildAnalyzerConfiguration[] GetUserConfigurations(
+    internal BuildExecutionCheckConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
@@ -122,17 +122,17 @@ public CustomConfigurationData[] GetCustomConfigurations(
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
 
-    internal BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
-        BuildAnalyzerConfiguration[] userConfigs,
-        BuildAnalyzer analyzer)
+    internal BuildExecutionCheckConfigurationEffective[] GetMergedConfigurations(
+        BuildExecutionCheckConfiguration[] userConfigs,
+        BuildExecutionCheck check)
     {
-        var configurations = new BuildAnalyzerConfigurationEffective[userConfigs.Length];
+        var configurations = new BuildExecutionCheckConfigurationEffective[userConfigs.Length];
 
         for (int idx = 0; idx < userConfigs.Length; idx++)
         {
             configurations[idx] = MergeConfiguration(
-                analyzer.SupportedRules[idx].Id,
-                analyzer.SupportedRules[idx].DefaultConfiguration,
+                check.SupportedRules[idx].Id,
+                check.SupportedRules[idx].DefaultConfiguration,
                 userConfigs[idx]);
         }
 
@@ -226,19 +226,19 @@ internal Dictionary<string, string> GetConfiguration(string projectFullPath, str
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
+    internal BuildExecutionCheckConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
     {
         var cacheKey = $"{ruleId}-{projectFullPath}";
 
-        var editorConfigValue = _buildAnalyzerConfiguration.GetOrAdd(cacheKey, (key) =>
+        var editorConfigValue = _buildExecutionCheckConfiguration.GetOrAdd(cacheKey, (key) =>
         {
-            BuildAnalyzerConfiguration? editorConfig = BuildAnalyzerConfiguration.Null;
+            BuildExecutionCheckConfiguration? editorConfig = BuildExecutionCheckConfiguration.Null;
             editorConfig.RuleId = ruleId;
             var config = GetConfiguration(projectFullPath, ruleId);
 
             if (config.Any())
             {
-                editorConfig = BuildAnalyzerConfiguration.Create(config);
+                editorConfig = BuildExecutionCheckConfiguration.Create(config);
             }
 
             return editorConfig;
@@ -254,44 +254,44 @@ internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath,
     /// <param name="projectFullPath"></param>
     /// <param name="analyzerRule"></param>
     /// <returns></returns>
-    internal BuildAnalyzerConfigurationEffective GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
-        => GetMergedConfiguration(projectFullPath, analyzerRule.Id, analyzerRule.DefaultConfiguration);
+    internal BuildExecutionCheckConfigurationEffective GetMergedConfiguration(string projectFullPath, BuildExecutionCheckRule checkRule)
+        => GetMergedConfiguration(projectFullPath, checkRule.Id, checkRule.DefaultConfiguration);
 
-    internal BuildAnalyzerConfigurationEffective MergeConfiguration(
+    internal BuildExecutionCheckConfigurationEffective MergeConfiguration(
         string ruleId,
-        BuildAnalyzerConfiguration defaultConfig,
-        BuildAnalyzerConfiguration editorConfig)
-        => new BuildAnalyzerConfigurationEffective(
+        BuildExecutionCheckConfiguration defaultConfig,
+        BuildExecutionCheckConfiguration editorConfig)
+        => new BuildExecutionCheckConfigurationEffective(
             ruleId: ruleId,
-            evaluationAnalysisScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationAnalysisScope),
+            evaluationCheckScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationCheckScope),
             severity: GetSeverityValue(editorConfig, defaultConfig));
 
-    private BuildAnalyzerConfigurationEffective GetMergedConfiguration(
+    private BuildExecutionCheckConfigurationEffective GetMergedConfiguration(
         string projectFullPath,
         string ruleId,
-        BuildAnalyzerConfiguration defaultConfig)
+        BuildExecutionCheckConfiguration defaultConfig)
         => MergeConfiguration(ruleId, defaultConfig, GetUserConfiguration(projectFullPath, ruleId));
 
     private T GetConfigValue<T>(
-        BuildAnalyzerConfiguration editorConfigValue,
-        BuildAnalyzerConfiguration defaultValue,
-        Func<BuildAnalyzerConfiguration, T?> propertyGetter) where T : struct
+        BuildExecutionCheckConfiguration editorConfigValue,
+        BuildExecutionCheckConfiguration defaultValue,
+        Func<BuildExecutionCheckConfiguration, T?> propertyGetter) where T : struct
         => propertyGetter(editorConfigValue) ??
            propertyGetter(defaultValue) ??
-           EnsureNonNull(propertyGetter(BuildAnalyzerConfiguration.Default));
+           EnsureNonNull(propertyGetter(BuildExecutionCheckConfiguration.Default));
 
-    private BuildAnalyzerResultSeverity GetSeverityValue(BuildAnalyzerConfiguration editorConfigValue, BuildAnalyzerConfiguration defaultValue)
+    private BuildExecutionCheckResultSeverity GetSeverityValue(BuildExecutionCheckConfiguration editorConfigValue, BuildExecutionCheckConfiguration defaultValue)
     {
-        BuildAnalyzerResultSeverity? resultSeverity = null;
+        BuildExecutionCheckResultSeverity? resultSeverity = null;
 
         // Consider Default as null, so the severity from the default value could be selected.
         // Default severity is not recognized by the infrastructure and serves for configuration purpuses only. 
-        if (editorConfigValue.Severity != null && editorConfigValue.Severity != BuildAnalyzerResultSeverity.Default)
+        if (editorConfigValue.Severity != null && editorConfigValue.Severity != BuildExecutionCheckResultSeverity.Default)
         {
             resultSeverity = editorConfigValue.Severity;
         }
 
-        resultSeverity ??= defaultValue.Severity ?? EnsureNonNull(BuildAnalyzerConfiguration.Default.Severity);
+        resultSeverity ??= defaultValue.Severity ?? EnsureNonNull(BuildExecutionCheckConfiguration.Default.Severity);
 
         return resultSeverity.Value;
     }
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index 81611053648..fbeb7c68f42 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -36,30 +36,30 @@ internal enum BuildCheckDataSource
 internal interface IBuildCheckManager
 {
     void ProcessEvaluationFinishedEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checksContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
 
     void ProcessEnvironmentVariableReadEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checksContext,
         EnvironmentVariableReadEventArgs envVariableReadEventArgs);
 
     void ProcessTaskStartedEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checksContext,
         TaskStartedEventArgs taskStartedEventArgs);
 
     void ProcessTaskFinishedEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checksContext,
         TaskFinishedEventArgs taskFinishedEventArgs);
 
     void ProcessTaskParameterEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checksContext,
         TaskParameterEventArgs taskParameterEventArgs);
 
     void SetDataSource(BuildCheckDataSource buildCheckDataSource);
 
-    void ProcessAnalyzerAcquisition(CheckAcquisitionData acquisitionData, ICheckContext analysisContext);
+    void ProcessCheckAcquisition(CheckAcquisitionData acquisitionData, ICheckContext checksContext);
 
-    Dictionary<string, TimeSpan> CreateAnalyzerTracingStats();
+    Dictionary<string, TimeSpan> CreateCheckTracingStats();
 
     void FinalizeProcessing(LoggingContext loggingContext);
 
@@ -67,13 +67,13 @@ void ProcessTaskParameterEventArgs(
     //  but as well from the ConnectorLogger - as even if interleaved, it gives the info
     //  to manager about what analyzers need to be materialized and configuration fetched.
     // No unloading of analyzers is yet considered - once loaded it stays for whole build.
-    void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, ICheckContext analysisContext, string projectFullPath);
+    void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, ICheckContext checksContext, string projectFullPath);
 
     void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
 
     void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string projectFullPath);
 
-    void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, ICheckContext analysisContext, string projectFullPath);
+    void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, ICheckContext checksContext, string projectFullPath);
 
     void Shutdown();
 }
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
index 8789bc73568..0c543194184 100644
--- a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
@@ -14,12 +14,12 @@ void ProcessPropertyRead(
         PropertyReadInfo propertyReadInfo,
         // This is intentionally AnalysisLoggingContext instead of ICheckContext - to avoid boxing allocations
         //  on a hot path of properties reading (same for writing)
-        AnalysisLoggingContext analysisContext);
+        CheckLoggingContext checkContext);
 
     /// <summary>
     /// Signals that a property was written to.
     /// </summary>
     void ProcessPropertyWrite(
         PropertyWriteInfo propertyWriteInfo,
-        AnalysisLoggingContext analysisContext);
+        CheckLoggingContext checkContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index e33ed43ee7d..3f627afff02 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -17,7 +17,7 @@ public void Shutdown()
     }
 
     public void ProcessEvaluationFinishedEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checkContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs)
     {
     }
@@ -27,26 +27,26 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
     }
 
     public void ProcessTaskStartedEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checkContext,
         TaskStartedEventArgs taskStartedEventArgs)
     {
     }
 
     public void ProcessTaskFinishedEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checkContext,
         TaskFinishedEventArgs taskFinishedEventArgs)
     {
     }
 
     public void ProcessTaskParameterEventArgs(
-        ICheckContext analysisContext,
+        ICheckContext checkContext,
         TaskParameterEventArgs taskParameterEventArgs)
     {
     }
 
     public void ProcessAnalyzerAcquisition(
         CheckAcquisitionData acquisitionData,
-        ICheckContext analysisContext)
+        ICheckContext checkContext)
     {
     }
 
@@ -54,7 +54,7 @@ public void FinalizeProcessing(LoggingContext loggingContext)
     {
     }
 
-    public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, ICheckContext analysisContext, string fullPath)
+    public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, ICheckContext checkContext, string fullPath)
     {
     }
 
@@ -66,7 +66,7 @@ public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, Build
     {
     }
 
-    public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, ICheckContext analysisContext,
+    public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, ICheckContext checkContext,
         string projectFullPath)
     {
     }
@@ -90,12 +90,12 @@ public void EndTaskInvocation(BuildCheckDataSource buildCheckDataSource, TaskFin
     public void ProcessTaskParameter(BuildCheckDataSource buildCheckDataSource, TaskParameterEventArgs eventArg)
     { }
 
-    public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext buildEventContext)
+    public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext buildEventContext)
     { }
 
-    public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext buildEventContext)
+    public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext buildEventContext)
     { }
 	
-    public void ProcessEnvironmentVariableReadEventArgs(ICheckContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
+    public void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
     { }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
index 9809ad27e49..d7f75922966 100644
--- a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
+++ b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
@@ -17,11 +17,11 @@ internal class TracingReporter
 
     // Infrastructure time keepers
     // TODO: add more timers throughout BuildCheck run
-    private TimeSpan analyzerAcquisitionTime;
-    private TimeSpan analyzerSetDataSourceTime;
-    private TimeSpan newProjectAnalyzersTime;
+    private TimeSpan checkAcquisitionTime;
+    private TimeSpan checkSetDataSourceTime;
+    private TimeSpan newProjectChecksTime;
 
-    public void AddAnalyzerStats(string name, TimeSpan subtotal)
+    public void AddCheckStats(string name, TimeSpan subtotal)
     {
         if (TracingStats.TryGetValue(name, out TimeSpan existing))
         {
@@ -35,25 +35,25 @@ public void AddAnalyzerStats(string name, TimeSpan subtotal)
 
     public void AddAcquisitionStats(TimeSpan subtotal)
     {
-        analyzerAcquisitionTime += subtotal;
+        checkAcquisitionTime += subtotal;
     }
 
     public void AddSetDataSourceStats(TimeSpan subtotal)
     {
-        analyzerSetDataSourceTime += subtotal;
+        checkSetDataSourceTime += subtotal;
     }
 
     public void AddNewProjectStats(TimeSpan subtotal)
     {
-        newProjectAnalyzersTime += subtotal;
+        newProjectChecksTime += subtotal;
     }
 
-    public void AddAnalyzerInfraStats()
+    public void AddCheckInfraStats()
     {
         var infraStats = new Dictionary<string, TimeSpan>() {
-                { $"{BuildCheckConstants.infraStatPrefix}analyzerAcquisitionTime", analyzerAcquisitionTime },
-                { $"{BuildCheckConstants.infraStatPrefix}analyzerSetDataSourceTime", analyzerSetDataSourceTime },
-                { $"{BuildCheckConstants.infraStatPrefix}newProjectAnalyzersTime", newProjectAnalyzersTime }
+                { $"{BuildCheckConstants.infraStatPrefix}checkAcquisitionTime", checkAcquisitionTime },
+                { $"{BuildCheckConstants.infraStatPrefix}checkSetDataSourceTime", checkSetDataSourceTime },
+                { $"{BuildCheckConstants.infraStatPrefix}newProjectChecksTime", newProjectChecksTime }
             };
 
         TracingStats.Merge(infraStats, (span1, span2) => span1 + span2);
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index 39d9688951b..a3d400c92b0 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -64,18 +64,18 @@ public class BuildCheckDataContext<T> where T : CheckData
 {
     private readonly BuildExecutionCheckWrapper _executionCheckWrapper;
     private readonly ICheckContext _checkContext;
-    private readonly BuildAnalyzerConfigurationEffective[] _configPerRule;
-    private readonly Action<BuildExecutionCheckWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> _resultHandler;
+    private readonly BuildExecutionCheckConfigurationEffective[] _configPerRule;
+    private readonly Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult> _resultHandler;
 
     internal BuildCheckDataContext(
-        BuildExecutionCheckWrapper analyzerWrapper,
+        BuildExecutionCheckWrapper checkWrapper,
         ICheckContext loggingContext,
         BuildExecutionCheckConfigurationEffective[] configPerRule,
         Action<BuildExecutionCheckWrapper, ICheckContext, BuildExecutionCheckConfigurationEffective[], BuildCheckResult> resultHandler,
         T data)
     {
-        _executionCheckWrapper = analyzerWrapper;
-        _executionCheckContext = loggingContext;
+        _executionCheckWrapper = checkWrapper;
+        _checkContext = loggingContext;
         _configPerRule = configPerRule;
         _resultHandler = resultHandler;
         Data = data;
diff --git a/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs b/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs
index c5f301c0260..9b84e9ca2f9 100644
--- a/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs
+++ b/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs
@@ -9,9 +9,9 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// BuildCheck OM data representing the evaluated properties of a project.
 /// </summary>
-public class EvaluatedPropertiesAnalysisData : CheckData
+public class EvaluatedPropertiesCheckData : CheckData
 {
-    internal EvaluatedPropertiesAnalysisData(
+    internal EvaluatedPropertiesCheckData(
         string projectFilePath,
         int? projectConfigurationId,
         IReadOnlyDictionary<string, string> evaluatedProperties,
