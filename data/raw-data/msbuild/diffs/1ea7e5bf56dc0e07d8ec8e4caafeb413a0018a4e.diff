diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 14986a790d2..92ec499b948 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -13,6 +13,9 @@
     <PackageVersion Include="BenchmarkDotNet" Version="0.13.1" />
     <PackageVersion Update="BenchmarkDotNet" Condition="'$(BenchmarkDotNetVersion)' != ''" Version="$(BenchmarkDotNetVersion)" />
 
+    <PackageVersion Include="FluentAssertions" Version="6.11.0" />
+    <PackageVersion Update="FluentAssertions" Condition="'$(FluentAssertionsVersion)' != ''" Version="$(FluentAssertionsVersion)" />
+
     <PackageVersion Include="LargeAddressAware" Version="1.0.5" />
     <PackageVersion Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 13de6f28e6f..a97eb5cb6d1 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using FluentAssertions;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -57,9 +58,14 @@ public void VerifyEventType()
             ProjectStartedEventArgs projectStarted = new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null);
             ProjectFinishedEventArgs projectFinished = new ProjectFinishedEventArgs("message", "help", "ProjectFile", true);
             ExternalProjectStartedEventArgs externalStartedEvent = new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames");
+            ExternalProjectFinishedEventArgs externalFinishedEvent = new("message", "help", "senderName", "projectFile", true);
             ProjectEvaluationStartedEventArgs evaluationStarted = new ProjectEvaluationStartedEventArgs();
             ProjectEvaluationFinishedEventArgs evaluationFinished = new ProjectEvaluationFinishedEventArgs();
-
+            AssemblyLoadBuildEventArgs assemblyLoad = new(AssemblyLoadingContext.Evaluation, null, null, "path", Guid.NewGuid(), null);
+            ExtendedBuildErrorEventArgs extError = new("extError", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
+            ExtendedBuildWarningEventArgs extWarning = new("extWarn", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender");
+            ExtendedBuildMessageEventArgs extMessage = new("extMsg", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", MessageImportance.Normal);
+            ExtendedCustomBuildEventArgs extCustom = new("extCustom", "message", "help", "sender");
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
             VerifyLoggingPacket(lowMessage, LoggingEventType.BuildMessageEvent);
@@ -76,7 +82,13 @@ public void VerifyEventType()
             VerifyLoggingPacket(projectFinished, LoggingEventType.ProjectFinishedEvent);
             VerifyLoggingPacket(evaluationStarted, LoggingEventType.ProjectEvaluationStartedEvent);
             VerifyLoggingPacket(evaluationFinished, LoggingEventType.ProjectEvaluationFinishedEvent);
-            VerifyLoggingPacket(externalStartedEvent, LoggingEventType.CustomEvent);
+            VerifyLoggingPacket(externalStartedEvent, LoggingEventType.ExternalProjectStartedEvent);
+            VerifyLoggingPacket(externalFinishedEvent, LoggingEventType.ExternalProjectFinishedEvent);
+            VerifyLoggingPacket(assemblyLoad, LoggingEventType.AssemblyLoadEvent);
+            VerifyLoggingPacket(extError, LoggingEventType.ExtendedBuildErrorEvent);
+            VerifyLoggingPacket(extWarning, LoggingEventType.ExtendedBuildWarningEvent);
+            VerifyLoggingPacket(extMessage, LoggingEventType.ExtendedBuildMessageEvent);
+            VerifyLoggingPacket(extCustom, LoggingEventType.ExtendedCustomEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
@@ -236,11 +248,36 @@ public void TestTranslation()
                     new ProjectStartedEventArgs(-1, "message", "help", "ProjectFile", "targetNames", null, null, null),
                     new ProjectFinishedEventArgs("message", "help", "ProjectFile", true),
                     new ExternalProjectStartedEventArgs("message", "help", "senderName", "projectFile", "targetNames"),
+                    new ExternalProjectFinishedEventArgs("message", "help", "senderName", "projectFile", true),
                     CreateProjectEvaluationStarted(),
                     CreateProjectEvaluationFinished(),
-                    CreateTargetSkipped()
+                    new AssemblyLoadBuildEventArgs(AssemblyLoadingContext.Evaluation, "init", "aname", "path", Guid.NewGuid(), "domain", MessageImportance.Normal),
+                    CreateTargetSkipped(),
+                    new ExtendedBuildErrorEventArgs("extError", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
+                    new ExtendedBuildWarningEventArgs("extWarn", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
+                    new ExtendedBuildMessageEventArgs("extWarn", "SubCategoryForSchemaValidationErrors", "MSB4000", "file", 1, 2, 3, 4, "message", "help", "sender", MessageImportance.Normal, DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
+                    new ExtendedCustomBuildEventArgs("extCustom", "message", "help", "sender", DateTime.UtcNow, "arg1")
+                    {
+                        ExtendedData = "{'long-json':'mostly-strings'}",
+                        ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
+                        BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
+                    },
                 };
-
                 foreach (BuildEventArgs arg in testArgs)
                 {
                     LogMessagePacket packet = new LogMessagePacket(new KeyValuePair<int, BuildEventArgs>(0, arg));
@@ -250,7 +287,17 @@ public void TestTranslation()
 
                     LogMessagePacket deserializedPacket = tempPacket as LogMessagePacket;
 
-                    CompareLogMessagePackets(packet, deserializedPacket);
+                    packet.Should().BeEquivalentTo(deserializedPacket, options => options
+                        .RespectingRuntimeTypes());
+
+                    BuildEventArgs args = packet.NodeBuildEvent?.Value;
+                    BuildEventArgs desArgs = deserializedPacket?.NodeBuildEvent?.Value;
+                    desArgs.Should().BeEquivalentTo(args, options => options
+                        .RespectingRuntimeTypes()
+                        // Since we use struct DictionaryEntry of class TaskItemData, generated DictionaryEntry.Equals compare TaskItemData by references.
+                        // Bellow will instruct equivalency test to not use DictionaryEntry.Equals but its public members for equivalency tests.
+                        .ComparingByMembers<DictionaryEntry>() 
+                        .WithTracing());
                 }
             }
             finally
@@ -273,249 +320,6 @@ private static void VerifyLoggingPacket(BuildEventArgs buildEvent, LoggingEventT
             Assert.True(Object.ReferenceEquals(buildEvent, packet.NodeBuildEvent.Value.Value)); // "Expected buildEvent to have the same object reference as packet.BuildEvent"
         }
 
-        /// <summary>
-        /// Compares two BuildEventArgs objects for equivalence.
-        /// </summary>
-        private void CompareNodeBuildEventArgs(KeyValuePair<int, BuildEventArgs> leftTuple, KeyValuePair<int, BuildEventArgs> rightTuple, bool expectInvalidBuildEventContext)
-        {
-            BuildEventArgs left = leftTuple.Value;
-            BuildEventArgs right = rightTuple.Value;
-
-            if (expectInvalidBuildEventContext)
-            {
-                Assert.Equal(BuildEventContext.Invalid, right.BuildEventContext);
-            }
-            else
-            {
-                Assert.Equal(left.BuildEventContext, right.BuildEventContext);
-            }
-
-            Assert.Equal(leftTuple.Key, rightTuple.Key);
-            Assert.Equal(left.HelpKeyword, right.HelpKeyword);
-            Assert.Equal(left.Message, right.Message);
-            Assert.Equal(left.SenderName, right.SenderName);
-            Assert.Equal(left.ThreadId, right.ThreadId);
-            Assert.Equal(left.Timestamp, right.Timestamp);
-        }
-
-        /// <summary>
-        /// Compares two LogMessagePacket objects for equivalence.
-        /// </summary>
-        private void CompareLogMessagePackets(LogMessagePacket left, LogMessagePacket right)
-        {
-            Assert.Equal(left.EventType, right.EventType);
-            Assert.Equal(left.NodeBuildEvent.Value.Value.GetType(), right.NodeBuildEvent.Value.Value.GetType());
-
-            CompareNodeBuildEventArgs(left.NodeBuildEvent.Value, right.NodeBuildEvent.Value, left.EventType == LoggingEventType.CustomEvent /* expectInvalidBuildEventContext */);
-
-            switch (left.EventType)
-            {
-                case LoggingEventType.BuildErrorEvent:
-                    BuildErrorEventArgs leftError = left.NodeBuildEvent.Value.Value as BuildErrorEventArgs;
-                    BuildErrorEventArgs rightError = right.NodeBuildEvent.Value.Value as BuildErrorEventArgs;
-                    Assert.NotNull(leftError);
-                    Assert.NotNull(rightError);
-                    Assert.Equal(leftError.Code, rightError.Code);
-                    Assert.Equal(leftError.ColumnNumber, rightError.ColumnNumber);
-                    Assert.Equal(leftError.EndColumnNumber, rightError.EndColumnNumber);
-                    Assert.Equal(leftError.EndLineNumber, rightError.EndLineNumber);
-                    Assert.Equal(leftError.File, rightError.File);
-                    Assert.Equal(leftError.LineNumber, rightError.LineNumber);
-                    Assert.Equal(leftError.Message, rightError.Message);
-                    Assert.Equal(leftError.Subcategory, rightError.Subcategory);
-                    break;
-
-                case LoggingEventType.BuildFinishedEvent:
-                    BuildFinishedEventArgs leftFinished = left.NodeBuildEvent.Value.Value as BuildFinishedEventArgs;
-                    BuildFinishedEventArgs rightFinished = right.NodeBuildEvent.Value.Value as BuildFinishedEventArgs;
-                    Assert.NotNull(leftFinished);
-                    Assert.NotNull(rightFinished);
-                    Assert.Equal(leftFinished.Succeeded, rightFinished.Succeeded);
-                    break;
-
-                case LoggingEventType.BuildMessageEvent:
-                    BuildMessageEventArgs leftMessage = left.NodeBuildEvent.Value.Value as BuildMessageEventArgs;
-                    BuildMessageEventArgs rightMessage = right.NodeBuildEvent.Value.Value as BuildMessageEventArgs;
-                    Assert.NotNull(leftMessage);
-                    Assert.NotNull(rightMessage);
-                    Assert.Equal(leftMessage.Importance, rightMessage.Importance);
-                    break;
-
-                case LoggingEventType.BuildStartedEvent:
-                    BuildStartedEventArgs leftBuildStart = left.NodeBuildEvent.Value.Value as BuildStartedEventArgs;
-                    BuildStartedEventArgs rightBuildStart = right.NodeBuildEvent.Value.Value as BuildStartedEventArgs;
-                    Assert.NotNull(leftBuildStart);
-                    Assert.NotNull(rightBuildStart);
-                    break;
-
-                case LoggingEventType.BuildWarningEvent:
-                    BuildWarningEventArgs leftBuildWarn = left.NodeBuildEvent.Value.Value as BuildWarningEventArgs;
-                    BuildWarningEventArgs rightBuildWarn = right.NodeBuildEvent.Value.Value as BuildWarningEventArgs;
-                    Assert.NotNull(leftBuildWarn);
-                    Assert.NotNull(rightBuildWarn);
-                    Assert.Equal(leftBuildWarn.Code, rightBuildWarn.Code);
-                    Assert.Equal(leftBuildWarn.ColumnNumber, rightBuildWarn.ColumnNumber);
-                    Assert.Equal(leftBuildWarn.EndColumnNumber, rightBuildWarn.EndColumnNumber);
-                    Assert.Equal(leftBuildWarn.EndLineNumber, rightBuildWarn.EndLineNumber);
-                    Assert.Equal(leftBuildWarn.File, rightBuildWarn.File);
-                    Assert.Equal(leftBuildWarn.LineNumber, rightBuildWarn.LineNumber);
-                    Assert.Equal(leftBuildWarn.Subcategory, rightBuildWarn.Subcategory);
-                    break;
-
-                case LoggingEventType.CustomEvent:
-                    ExternalProjectStartedEventArgs leftCustom = left.NodeBuildEvent.Value.Value as ExternalProjectStartedEventArgs;
-                    ExternalProjectStartedEventArgs rightCustom = right.NodeBuildEvent.Value.Value as ExternalProjectStartedEventArgs;
-                    Assert.NotNull(leftCustom);
-                    Assert.NotNull(rightCustom);
-                    Assert.Equal(leftCustom.ProjectFile, rightCustom.ProjectFile);
-                    Assert.Equal(leftCustom.TargetNames, rightCustom.TargetNames);
-                    break;
-
-                case LoggingEventType.ProjectFinishedEvent:
-                    ProjectFinishedEventArgs leftProjectFinished = left.NodeBuildEvent.Value.Value as ProjectFinishedEventArgs;
-                    ProjectFinishedEventArgs rightProjectFinished = right.NodeBuildEvent.Value.Value as ProjectFinishedEventArgs;
-                    Assert.NotNull(leftProjectFinished);
-                    Assert.NotNull(rightProjectFinished);
-                    Assert.Equal(leftProjectFinished.ProjectFile, rightProjectFinished.ProjectFile);
-                    Assert.Equal(leftProjectFinished.Succeeded, rightProjectFinished.Succeeded);
-                    break;
-
-                case LoggingEventType.ProjectStartedEvent:
-                    ProjectStartedEventArgs leftProjectStarted = left.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
-                    ProjectStartedEventArgs rightProjectStarted = right.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
-                    Assert.NotNull(leftProjectStarted);
-                    Assert.NotNull(rightProjectStarted);
-                    Assert.Equal(leftProjectStarted.ParentProjectBuildEventContext, rightProjectStarted.ParentProjectBuildEventContext);
-                    Assert.Equal(leftProjectStarted.ProjectFile, rightProjectStarted.ProjectFile);
-                    Assert.Equal(leftProjectStarted.ProjectId, rightProjectStarted.ProjectId);
-                    Assert.Equal(leftProjectStarted.TargetNames, rightProjectStarted.TargetNames);
-
-                    // UNDONE: (Serialization.) We don't actually serialize the items at this time.
-                    // Assert.AreEqual(leftProjectStarted.Items, rightProjectStarted.Items);
-                    // UNDONE: (Serialization.) We don't actually serialize properties at this time.
-                    // Assert.AreEqual(leftProjectStarted.Properties, rightProjectStarted.Properties);
-                    break;
-
-                case LoggingEventType.ProjectEvaluationStartedEvent:
-                    ProjectEvaluationStartedEventArgs leftEvaluationStarted = left.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
-                    ProjectEvaluationStartedEventArgs rightEvaluationStarted = right.NodeBuildEvent.Value.Value as ProjectEvaluationStartedEventArgs;
-                    Assert.NotNull(leftEvaluationStarted);
-                    Assert.NotNull(rightEvaluationStarted);
-                    Assert.Equal(leftEvaluationStarted.ProjectFile, rightEvaluationStarted.ProjectFile);
-                    break;
-
-                case LoggingEventType.ProjectEvaluationFinishedEvent:
-                    ProjectEvaluationFinishedEventArgs leftEvaluationFinished = left.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
-                    ProjectEvaluationFinishedEventArgs rightEvaluationFinished = right.NodeBuildEvent.Value.Value as ProjectEvaluationFinishedEventArgs;
-                    Assert.NotNull(leftEvaluationFinished);
-                    Assert.NotNull(rightEvaluationFinished);
-                    Assert.Equal(leftEvaluationFinished.ProjectFile, rightEvaluationFinished.ProjectFile);
-                    Assert.Equal(leftEvaluationFinished.ProfilerResult, rightEvaluationFinished.ProfilerResult);
-                    Assert.Equal(
-                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.GlobalProperties),
-                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.GlobalProperties));
-                    Assert.Equal(
-                        TranslationHelpers.GetPropertiesString(leftEvaluationFinished.Properties),
-                        TranslationHelpers.GetPropertiesString(rightEvaluationFinished.Properties));
-                    Assert.Equal(
-                        TranslationHelpers.GetMultiItemsString(leftEvaluationFinished.Items),
-                        TranslationHelpers.GetMultiItemsString(rightEvaluationFinished.Items));
-                    break;
-
-                case LoggingEventType.TargetFinishedEvent:
-                    TargetFinishedEventArgs leftTargetFinished = left.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
-                    TargetFinishedEventArgs rightTargetFinished = right.NodeBuildEvent.Value.Value as TargetFinishedEventArgs;
-                    Assert.NotNull(leftTargetFinished);
-                    Assert.NotNull(rightTargetFinished);
-                    Assert.Equal(leftTargetFinished.ProjectFile, rightTargetFinished.ProjectFile);
-                    Assert.Equal(leftTargetFinished.Succeeded, rightTargetFinished.Succeeded);
-                    Assert.Equal(leftTargetFinished.TargetFile, rightTargetFinished.TargetFile);
-                    Assert.Equal(leftTargetFinished.TargetName, rightTargetFinished.TargetName);
-                    // TODO: target output translation is a special case and is done in TranslateTargetFinishedEvent
-                    // Assert.Equal(leftTargetFinished.TargetOutputs, rightTargetFinished.TargetOutputs);
-                    break;
-
-                case LoggingEventType.TargetStartedEvent:
-                    TargetStartedEventArgs leftTargetStarted = left.NodeBuildEvent.Value.Value as TargetStartedEventArgs;
-                    TargetStartedEventArgs rightTargetStarted = right.NodeBuildEvent.Value.Value as TargetStartedEventArgs;
-                    Assert.NotNull(leftTargetStarted);
-                    Assert.NotNull(rightTargetStarted);
-                    Assert.Equal(leftTargetStarted.ProjectFile, rightTargetStarted.ProjectFile);
-                    Assert.Equal(leftTargetStarted.TargetFile, rightTargetStarted.TargetFile);
-                    Assert.Equal(leftTargetStarted.TargetName, rightTargetStarted.TargetName);
-                    break;
-
-                case LoggingEventType.TargetSkipped:
-                    TargetSkippedEventArgs leftTargetSkipped = left.NodeBuildEvent.Value.Value as TargetSkippedEventArgs;
-                    TargetSkippedEventArgs rightTargetSkipped = right.NodeBuildEvent.Value.Value as TargetSkippedEventArgs;
-                    Assert.Equal(leftTargetSkipped.BuildReason, rightTargetSkipped.BuildReason);
-                    Assert.Equal(leftTargetSkipped.SkipReason, rightTargetSkipped.SkipReason);
-                    Assert.Equal(leftTargetSkipped.BuildEventContext, rightTargetSkipped.BuildEventContext);
-                    Assert.Equal(leftTargetSkipped.OriginalBuildEventContext, rightTargetSkipped.OriginalBuildEventContext);
-                    Assert.Equal(leftTargetSkipped.Condition, rightTargetSkipped.Condition);
-                    Assert.Equal(leftTargetSkipped.EvaluatedCondition, rightTargetSkipped.EvaluatedCondition);
-                    Assert.Equal(leftTargetSkipped.Importance, rightTargetSkipped.Importance);
-                    Assert.Equal(leftTargetSkipped.OriginallySucceeded, rightTargetSkipped.OriginallySucceeded);
-                    Assert.Equal(leftTargetSkipped.ProjectFile, rightTargetSkipped.ProjectFile);
-                    Assert.Equal(leftTargetSkipped.TargetFile, rightTargetSkipped.TargetFile);
-                    Assert.Equal(leftTargetSkipped.TargetName, rightTargetSkipped.TargetName);
-                    Assert.Equal(leftTargetSkipped.ParentTarget, rightTargetSkipped.ParentTarget);
-                    break;
-
-                case LoggingEventType.TaskCommandLineEvent:
-                    TaskCommandLineEventArgs leftCommand = left.NodeBuildEvent.Value.Value as TaskCommandLineEventArgs;
-                    TaskCommandLineEventArgs rightCommand = right.NodeBuildEvent.Value.Value as TaskCommandLineEventArgs;
-                    Assert.NotNull(leftCommand);
-                    Assert.NotNull(rightCommand);
-                    Assert.Equal(leftCommand.CommandLine, rightCommand.CommandLine);
-                    Assert.Equal(leftCommand.Importance, rightCommand.Importance);
-                    Assert.Equal(leftCommand.TaskName, rightCommand.TaskName);
-                    break;
-
-                case LoggingEventType.TaskParameterEvent:
-                    var leftTaskParameter = left.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
-                    var rightTaskParameter = right.NodeBuildEvent.Value.Value as TaskParameterEventArgs;
-                    Assert.NotNull(leftTaskParameter);
-                    Assert.NotNull(rightTaskParameter);
-                    Assert.Equal(leftTaskParameter.Kind, rightTaskParameter.Kind);
-                    Assert.Equal(leftTaskParameter.ItemType, rightTaskParameter.ItemType);
-                    Assert.Equal(leftTaskParameter.Items.Count, rightTaskParameter.Items.Count);
-                    Assert.Equal(leftTaskParameter.Message, rightTaskParameter.Message);
-                    Assert.Equal(leftTaskParameter.BuildEventContext, rightTaskParameter.BuildEventContext);
-                    Assert.Equal(leftTaskParameter.Timestamp, rightTaskParameter.Timestamp);
-                    Assert.Equal(leftTaskParameter.LineNumber, rightTaskParameter.LineNumber);
-                    Assert.Equal(leftTaskParameter.ColumnNumber, rightTaskParameter.ColumnNumber);
-                    break;
-
-                case LoggingEventType.TaskFinishedEvent:
-                    TaskFinishedEventArgs leftTaskFinished = left.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
-                    TaskFinishedEventArgs rightTaskFinished = right.NodeBuildEvent.Value.Value as TaskFinishedEventArgs;
-                    Assert.NotNull(leftTaskFinished);
-                    Assert.NotNull(rightTaskFinished);
-                    Assert.Equal(leftTaskFinished.ProjectFile, rightTaskFinished.ProjectFile);
-                    Assert.Equal(leftTaskFinished.Succeeded, rightTaskFinished.Succeeded);
-                    Assert.Equal(leftTaskFinished.TaskFile, rightTaskFinished.TaskFile);
-                    Assert.Equal(leftTaskFinished.TaskName, rightTaskFinished.TaskName);
-                    break;
-
-                case LoggingEventType.TaskStartedEvent:
-                    TaskStartedEventArgs leftTaskStarted = left.NodeBuildEvent.Value.Value as TaskStartedEventArgs;
-                    TaskStartedEventArgs rightTaskStarted = right.NodeBuildEvent.Value.Value as TaskStartedEventArgs;
-                    Assert.NotNull(leftTaskStarted);
-                    Assert.NotNull(rightTaskStarted);
-                    Assert.Equal(leftTaskStarted.ProjectFile, rightTaskStarted.ProjectFile);
-                    Assert.Equal(leftTaskStarted.TaskFile, rightTaskStarted.TaskFile);
-                    Assert.Equal(leftTaskStarted.TaskName, rightTaskStarted.TaskName);
-                    Assert.Equal(leftTaskStarted.LineNumber, rightTaskStarted.LineNumber);
-                    Assert.Equal(leftTaskStarted.ColumnNumber, rightTaskStarted.ColumnNumber);
-                    break;
-
-                default:
-                    Assert.True(false, string.Format("Unexpected logging event type {0}", left.EventType));
-                    break;
-            }
-        }
-
         #endregion
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
index 8f4a5d6c1aa..3fe12dd13fe 100644
--- a/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHost_Tests.cs
@@ -385,6 +385,61 @@ public void TestLogCustomEventNotSerializableSP()
             Assert.Equal("testCustomBuildEvent", _customLogger.LastCustom.Message);
         }
 
+        /// <summary>
+        /// Test that extended custom events are logged properly
+        /// </summary>
+        [Fact]
+        public void TestLogExtendedCustomEventNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogCustomEvent(new ExtendedCustomBuildEventArgs("testExtCustomBuildEvent", "ext message", null, null));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastCustom is ExtendedCustomBuildEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext message", _customLogger.LastCustom.Message);
+        }
+
+        [Fact]
+        public void TestLogExtendedCustomErrorNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogErrorEvent(new ExtendedBuildErrorEventArgs("testExtCustomBuildError", null, null, null, 0, 0, 0, 0,"ext err message", null, null));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastError is ExtendedBuildErrorEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext err message", _customLogger.LastError.Message);
+        }
+
+        [Fact]
+        public void TestLogExtendedCustomWarningNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogWarningEvent(new ExtendedBuildWarningEventArgs("testExtCustomBuildWarning", null, null, null, 0, 0, 0, 0, "ext warn message", null, null));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastWarning is ExtendedBuildWarningEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext warn message", _customLogger.LastWarning.Message);
+        }
+
+        [Fact]
+        public void TestLogExtendedCustomMessageNotSerializableMP()
+        {
+            _mockHost.BuildParameters.MaxNodeCount = 4;
+
+            // Log the custom event args.  (Pretend that the task actually did this.)
+            _taskHost.LogMessageEvent(new ExtendedBuildMessageEventArgs("testExtCustomBuildMessage", "ext message", null, null, MessageImportance.Normal));
+
+            // Make sure our custom logger received the actual custom event and not some fake.
+            Assert.True(_customLogger.LastMessage is ExtendedBuildMessageEventArgs); // "Expected custom build Event"
+            Assert.Equal("ext message", _customLogger.LastMessage.Message);
+        }
+
         /// <summary>
         /// Test that errors are logged properly
         /// </summary>
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 168cca02bbe..62d15cc8697 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -13,6 +13,7 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests.BackEnd;
+using Shouldly;
 using Xunit;
 
 #nullable disable
@@ -242,6 +243,40 @@ public void RoundtripBuildErrorEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripExtendedErrorEventArgs_SerializedAsError(bool useArguments)
+        {
+            var args = new ExtendedBuildErrorEventArgs(
+                "extendedDataType",
+                "Subcategory",
+                "Code",
+                "File",
+                1,
+                2,
+                3,
+                4,
+                "Message with arguments: '{0}'",
+                "Help",
+                "SenderName",
+                DateTime.Parse("9/1/2021 12:02:07 PM"),
+                useArguments ? new object[] { "argument0" } : null);
+
+            // For now we don't serialize extended data into binary log
+            Roundtrip<BuildErrorEventArgs>(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
@@ -274,6 +309,40 @@ public void RoundtripBuildWarningEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripExtendedWarningEventArgs_SerializedAsWarning(bool useArguments)
+        {
+            var args = new ExtendedBuildWarningEventArgs(
+                "extendedDataType",
+                "Subcategory",
+                "Code",
+                "File",
+                1,
+                2,
+                3,
+                4,
+                "Message with arguments: '{0}'",
+                "Help",
+                "SenderName",
+                DateTime.Parse("9/1/2021 12:02:07 PM"),
+                useArguments ? new object[] { "argument0" } : null);
+
+            // For now we don't serialize extended data into binary log
+            Roundtrip<BuildWarningEventArgs>(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
         [Theory]
         [InlineData(true)]
         [InlineData(false)]
@@ -308,6 +377,122 @@ public void RoundtripBuildMessageEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void RoundtripExtendedBuildMessageEventArgs_SerializedAsMessage(bool useArguments)
+        {
+            var args = new ExtendedBuildMessageEventArgs(
+                "extendedDataType",
+                "Subcategory",
+                "Code",
+                "File",
+                1, 
+                2,
+                3,
+                4,
+                "Message",
+                "Help",
+                "SenderName",
+                MessageImportance.High,
+                DateTime.Parse("12/12/2015 06:11:56 PM"),
+                useArguments ? new object[] { "argument0" } : null);
+
+            Roundtrip<BuildMessageEventArgs>(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.Importance.ToString(),
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
+        [Fact]
+        public void RoundtripAssemblyLoadBuild()
+        {
+            string assemblyName = Guid.NewGuid().ToString();
+            string assemblyPath = Guid.NewGuid().ToString();
+            Guid mvid = Guid.NewGuid();
+            string loadingInitiator = Guid.NewGuid().ToString();
+            string appDomainName = Guid.NewGuid().ToString();
+            AssemblyLoadingContext context =
+                (AssemblyLoadingContext)(new Random().Next(Enum.GetNames(typeof(AssemblyLoadingContext)).Length));
+
+            AssemblyLoadBuildEventArgs args = new(context, loadingInitiator, assemblyName, assemblyPath, mvid, appDomainName);
+
+            Roundtrip(args,
+                e => e.Code,
+                e => e.ColumnNumber.ToString(),
+                e => e.EndColumnNumber.ToString(),
+                e => e.EndLineNumber.ToString(),
+                e => e.File,
+                e => e.LineNumber.ToString(),
+                e => e.Message,
+                e => e.Importance.ToString(),
+                e => e.ProjectFile,
+                e => e.Subcategory,
+                e => e.LoadingContext.ToString(),
+                e => e.AssemblyName,
+                e => e.AssemblyPath,
+                e => e.MVID.ToString(),
+                e => e.AppDomainDescriptor,
+                e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
+        }
+
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ExtendedCustomBuildEventArgs_SerializedAsMessage(bool withOptionalData)
+        {
+            ExtendedCustomBuildEventArgs args = new(
+                type: "TypeOfExtendedCustom",
+                message: withOptionalData ? "a message with args {0} {1}" : null,
+                helpKeyword: withOptionalData ? "MSBT123" : null,
+                senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+                eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+                messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
+
+
+            var memoryStream = new MemoryStream();
+            var binaryWriter = new BinaryWriter(memoryStream);
+            var buildEventArgsWriter = new BuildEventArgsWriter(binaryWriter);
+            buildEventArgsWriter.Write(args);
+
+            memoryStream.Position = 0;
+            var binaryReader = new BinaryReader(memoryStream);
+
+            using var buildEventArgsReader = new BuildEventArgsReader(binaryReader, BinaryLogger.FileFormatVersion);
+            var deserialized = buildEventArgsReader.Read();
+            BuildMessageEventArgs desArgs = (BuildMessageEventArgs)deserialized;
+
+            desArgs.ShouldBeOfType(typeof(BuildMessageEventArgs));
+
+            desArgs.Message.ShouldBe(args.Message);
+            desArgs.HelpKeyword.ShouldBe(args.HelpKeyword);
+            desArgs.SenderName.ShouldBe(args.SenderName);
+            desArgs.Importance.ShouldBe(MessageImportance.Normal);
+            desArgs.Timestamp.ShouldBe(args.Timestamp);
+
+            if (withOptionalData)
+            {
+                desArgs.BuildEventContext.ShouldBe(args.BuildEventContext);
+            }
+            else
+            {
+                desArgs.BuildEventContext.ShouldBe(BuildEventContext.Invalid);
+            }
+        }
+
         [Fact]
         public void RoundtripResponseFileUsedEventArgs()
         {
@@ -669,7 +854,7 @@ private void Roundtrip<T>(T args, params Func<T, string>[] fieldsToCompare)
             Assert.Equal(length, memoryStream.Position);
 
             Assert.NotNull(deserializedArgs);
-            Assert.Equal(args.GetType(), deserializedArgs.GetType());
+            Assert.Equal(typeof(T), deserializedArgs.GetType());
 
             foreach (var field in fieldsToCompare)
             {
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index 34c4fd896c9..e679717eab3 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -16,7 +16,7 @@
 
   <ItemGroup>
     <Reference Include="System.IO.Compression" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
-
+    <PackageReference Include="FluentAssertions" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
diff --git a/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs b/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs
new file mode 100644
index 00000000000..d1bcb987a1f
--- /dev/null
+++ b/src/Framework.UnitTests/ExtendedBuildEventArgs_Tests.cs
@@ -0,0 +1,218 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using FluentAssertions;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests;
+
+public class ExtendedBuildEventArgs_Tests
+{
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedCustomBuildEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedCustomBuildEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+            {
+                ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+                ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { {"m1", "v1" }, { "m2", "v2" } } : null,
+                BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+            };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedCustomBuildEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedErrorEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedBuildErrorEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            subcategory: withOptionalData ? "sub-type" : null,
+            code: withOptionalData ? "a-code" : null,
+            file: withOptionalData ? ".\\dev\\my.csproj" : null,
+            lineNumber: withOptionalData ? 1 : default,
+            columnNumber: withOptionalData ? 2 : default,
+            endLineNumber: withOptionalData ? 3 : default,
+            endColumnNumber: withOptionalData ? 4 : default,
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            helpLink: withOptionalData ? "(001)2234456" : null,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+        {
+            ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+            ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { { "m1", "v1" }, { "m2", "v2" } } : null,
+            BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+        };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedBuildErrorEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedWarningEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedBuildWarningEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            subcategory: withOptionalData ? "sub-type" : null,
+            code: withOptionalData ? "a-code" : null,
+            file: withOptionalData ? ".\\dev\\my.csproj" : null,
+            lineNumber: withOptionalData ? 1 : default,
+            columnNumber: withOptionalData ? 2 : default,
+            endLineNumber: withOptionalData ? 3 : default,
+            endColumnNumber: withOptionalData ? 4 : default,
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            helpLink: withOptionalData ? "(001)2234456" : null,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+        {
+            ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+            ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { { "m1", "v1" }, { "m2", "v2" } } : null,
+            BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+        };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedBuildWarningEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+    [InlineData(true)]
+    [InlineData(false)]
+    [Theory]
+    public void ExtendedMessageEventArgs_SerializationDeserialization(bool withOptionalData)
+    {
+        ExtendedBuildMessageEventArgs arg = new(
+            type: "TypeOfExtendedCustom",
+            subcategory: withOptionalData ? "sub-type" : null,
+            code: withOptionalData ? "a-code" : null,
+            file: withOptionalData ? ".\\dev\\my.csproj" : null,
+            lineNumber: withOptionalData ? 1 : default,
+            columnNumber: withOptionalData ? 2 : default,
+            endLineNumber: withOptionalData ? 3 : default,
+            endColumnNumber: withOptionalData ? 4 : default,
+            message: withOptionalData ? "a message with args {0} {1}" : null,
+            helpKeyword: withOptionalData ? "MSBT123" : null,
+            senderName: withOptionalData ? $"UnitTest {Guid.NewGuid()}" : null,
+            importance: withOptionalData ? MessageImportance.Normal : default,
+            eventTimestamp: withOptionalData ? DateTime.Parse("3/1/2017 11:11:56 AM") : DateTime.Now,
+            messageArgs: withOptionalData ? new object[] { "arg0val", "arg1val" } : null)
+        {
+            ExtendedData = withOptionalData ? "{'long-json':'mostly-strings'}" : null,
+            ExtendedMetadata = withOptionalData ? new Dictionary<string, string?> { { "m1", "v1" }, { "m2", "v2" } } : null,
+            BuildEventContext = withOptionalData ? new BuildEventContext(1, 2, 3, 4, 5, 6, 7) : null,
+        };
+
+        using MemoryStream stream = new MemoryStream();
+        using BinaryWriter bw = new BinaryWriter(stream);
+        arg.WriteToStream(bw);
+
+        stream.Position = 0;
+        using BinaryReader br = new BinaryReader(stream);
+        ExtendedBuildMessageEventArgs argDeserialized = new();
+        argDeserialized.CreateFromStream(br, 80);
+
+        argDeserialized.Should().BeEquivalentTo(arg);
+    }
+
+    [Fact]
+    public void ExtendedCustomBuildEventArgs_Ctors()
+    {
+        var ea = new ExtendedCustomBuildEventArgs();
+        ea = new ExtendedCustomBuildEventArgs("type");
+        ea = new ExtendedCustomBuildEventArgs("type", "Message {0}", "Help", "sender");
+        ea = new ExtendedCustomBuildEventArgs("type", "Message {0}", "Help", "sender", DateTime.Now);
+        ea = new ExtendedCustomBuildEventArgs("type", "Message {0}", "Help", "sender", DateTime.Now, "arg1");
+        ea = new ExtendedCustomBuildEventArgs("type");
+        ea = new ExtendedCustomBuildEventArgs("type", null, null, null);
+        ea = new ExtendedCustomBuildEventArgs("type", null, null, null, default(DateTime));
+        ea = new ExtendedCustomBuildEventArgs("type", null, null, null, default(DateTime), null);
+    }
+
+    [Fact]
+    public void ExtendedBuildErrorEventArgs_Ctors()
+    {
+        var ea = new ExtendedBuildErrorEventArgs();
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender");
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", DateTime.Now);
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", DateTime.Now, "Message");
+        ea = new ExtendedBuildErrorEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", "HelpLink", DateTime.Now, "Message");
+        ea = new ExtendedBuildErrorEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null);
+        ea = new ExtendedBuildErrorEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, DateTime.Now);
+        ea = new ExtendedBuildErrorEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, null, DateTime.Now, null);
+    }
+
+    [Fact]
+    public void ExtendedBuildWarningEventArgs_Ctors()
+    {
+        var ea = new ExtendedBuildWarningEventArgs();
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender");
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", DateTime.Now);
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", DateTime.Now, "Message");
+        ea = new ExtendedBuildWarningEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", "HelpLink", DateTime.Now, "Message");
+        ea = new ExtendedBuildWarningEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null);
+        ea = new ExtendedBuildWarningEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, DateTime.Now);
+        ea = new ExtendedBuildWarningEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, null, DateTime.Now, null);
+    }
+
+    [Fact]
+    public void ExtendedBuildMessageEventArgs_Ctors()
+    {
+        var ea = new ExtendedBuildMessageEventArgs();
+        ea = new ExtendedBuildMessageEventArgs("type");
+        ea = new ExtendedBuildMessageEventArgs("type", "Message", "HelpKeyword", "sender", MessageImportance.High);
+        ea = new ExtendedBuildMessageEventArgs("type", "Message", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", "Message", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now, "arg1");
+        ea = new ExtendedBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", MessageImportance.High);
+        ea = new ExtendedBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", "Subcategory", "Code", "File", 1, 2, 3, 4, "{0}", "HelpKeyword", "sender", MessageImportance.High, DateTime.Now, "Message");
+        ea = new ExtendedBuildMessageEventArgs("type");
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, default);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, default, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, default, default, null);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, default);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, default, DateTime.Now);
+        ea = new ExtendedBuildMessageEventArgs("type", null, null, null, 1, 2, 3, 4, null, null, null, default, DateTime.Now, null);
+    }
+}
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index e3b953a332a..09c42cc408e 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -11,6 +11,7 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="FluentAssertions" />
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Shouldly" />
