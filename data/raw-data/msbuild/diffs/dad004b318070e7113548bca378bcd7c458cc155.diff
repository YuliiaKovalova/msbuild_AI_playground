diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index 7983229f5b2..a3fc16da831 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -144,7 +144,7 @@ internal enum BuildComponentType
         NodeLauncher,
 
         /// <summary>
-        /// The Build Analyzer Manager.
+        /// The Build Check Manager.
         /// </summary>
         BuildCheckManagerProvider,
     }
diff --git a/src/Build/BuildCheck/API/BuildAnalyzer.cs b/src/Build/BuildCheck/API/BuildExecutionCheck.cs
similarity index 70%
rename from src/Build/BuildCheck/API/BuildAnalyzer.cs
rename to src/Build/BuildCheck/API/BuildExecutionCheck.cs
index 0c6ed5a0752..b8046a40150 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzer.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheck.cs
@@ -9,29 +9,29 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Base class for build analyzers.
-/// Same base will be used for custom and built-in analyzers.
-/// <see cref="BuildAnalyzer"/> is a unit of build analysis execution, but it can contain multiple rules - each representing a distinct violation.
+/// Base class for build checks.
+/// Same base will be used for custom and built-in checks.
+/// <see cref="BuildExecutionCheck"/> is a unit of build checks execution, but it can contain multiple rules - each representing a distinct violation.
 /// </summary>
-public abstract class BuildAnalyzer : IDisposable
+public abstract class BuildExecutionCheck : IDisposable
 {
     /// <summary>
-    /// Friendly name of the analyzer.
+    /// Friendly name of the check.
     /// Should be unique - as it will be used in the tracing stats, infrastructure error messages, etc.
     /// </summary>
     public abstract string FriendlyName { get; }
 
     /// <summary>
-    /// Single or multiple rules supported by the analyzer.
+    /// Single or multiple rules supported by the check.
     /// </summary>
-    public abstract IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; }
+    public abstract IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; }
 
     /// <summary>
-    /// Optional initialization of the analyzer.
+    /// Optional initialization of the check.
     /// </summary>
     /// <param name="configurationContext">
     /// Custom data (not recognized by the infrastructure) passed from .editorconfig
-    /// Currently the custom data has to be identical for all rules in the analyzer and all projects.
+    /// Currently the custom data has to be identical for all rules in the check and all projects.
     /// </param>
     public abstract void Initialize(ConfigurationContext configurationContext);
 
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
similarity index 83%
rename from src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
rename to src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
index 25492910718..ff9827a3632 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheckConfiguration.cs
@@ -15,17 +15,17 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// Each rule can have its own configuration, which can differ per each project.
 /// The <see cref="EvaluationAnalysisScope"/> setting must be same for all rules in the same analyzer (but can differ between projects)
 /// </summary>
-public class BuildAnalyzerConfiguration
+public class BuildExecutionCheckConfiguration
 {
     // Defaults to be used if any configuration property is not specified neither as default
     //  nor in the editorconfig configuration file.
-    public static BuildAnalyzerConfiguration Default { get; } = new()
+    public static BuildExecutionCheckConfiguration Default { get; } = new()
     {
         EvaluationAnalysisScope = BuildCheck.EvaluationAnalysisScope.ProjectOnly,
-        Severity = BuildAnalyzerResultSeverity.None
+        Severity = BuildExecutionCheckResultSeverity.None
     };
 
-    public static BuildAnalyzerConfiguration Null { get; } = new();
+    public static BuildExecutionCheckConfiguration Null { get; } = new();
 
     public string? RuleId { get; internal set; }
 
@@ -40,7 +40,7 @@ public class BuildAnalyzerConfiguration
     /// <summary>
     /// The severity of the result for the rule.
     /// </summary>
-    public BuildAnalyzerResultSeverity? Severity { get; internal init; }
+    public BuildExecutionCheckResultSeverity? Severity { get; internal init; }
 
     /// <summary>
     /// Whether the analyzer rule is enabled.
@@ -51,9 +51,9 @@ public bool? IsEnabled {
         get
         {
             // Do not consider Default as enabled, because the default severity of the rule coule be set to None
-            if (Severity.HasValue && Severity.Value != BuildAnalyzerResultSeverity.Default)
+            if (Severity.HasValue && Severity.Value != BuildExecutionCheckResultSeverity.Default)
             {
-                return !Severity.Value.Equals(BuildAnalyzerResultSeverity.None);
+                return !Severity.Value.Equals(BuildExecutionCheckResultSeverity.None);
             }
 
             return null;
@@ -67,7 +67,7 @@ public bool? IsEnabled {
     /// </summary>
     /// <param name="configDictionary">The configuration dictionary containing the settings for the build analyzer. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
     /// <returns>A new instance of <see cref="BuildAnalyzerConfiguration"/> with the specified settings.</returns>
-    internal static BuildAnalyzerConfiguration Create(Dictionary<string, string>? configDictionary) => new()
+    internal static BuildExecutionCheckConfiguration Create(Dictionary<string, string>? configDictionary) => new()
     {
         EvaluationAnalysisScope = TryExtractEvaluationAnalysisScope(configDictionary),
         Severity = TryExtractSeverity(configDictionary),
@@ -100,7 +100,7 @@ public bool? IsEnabled {
         return null;
     }
 
-    private static BuildAnalyzerResultSeverity? TryExtractSeverity(Dictionary<string, string>? config)
+    private static BuildExecutionCheckResultSeverity? TryExtractSeverity(Dictionary<string, string>? config)
     {
         if (!TryExtractValue(BuildCheckConstants.severityConfigurationKey, config, out string? stringValue) || stringValue is null)
         {
@@ -110,15 +110,15 @@ public bool? IsEnabled {
         switch (stringValue)
         {
             case "none":
-                return BuildAnalyzerResultSeverity.None;
+                return BuildExecutionCheckResultSeverity.None;
             case "default":
-                return BuildAnalyzerResultSeverity.Default;
+                return BuildExecutionCheckResultSeverity.Default;
             case "suggestion":
-                return BuildAnalyzerResultSeverity.Suggestion;
+                return BuildExecutionCheckResultSeverity.Suggestion;
             case "warning":
-                return BuildAnalyzerResultSeverity.Warning;
+                return BuildExecutionCheckResultSeverity.Warning;
             case "error":
-                return BuildAnalyzerResultSeverity.Error;
+                return BuildExecutionCheckResultSeverity.Error;
             default:
                 ThrowIncorrectValueException(BuildCheckConstants.severityConfigurationKey, stringValue);
                 break;
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs b/src/Build/BuildCheck/API/BuildExecutionCheckResultSeverity.cs
similarity index 94%
rename from src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
rename to src/Build/BuildCheck/API/BuildExecutionCheckResultSeverity.cs
index cd98bdbbf22..db758641143 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheckResultSeverity.cs
@@ -6,7 +6,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// The severity of reported result (or preconfigured or user configured severity for a rule).
 /// </summary>
-public enum BuildAnalyzerResultSeverity
+public enum BuildExecutionCheckResultSeverity
 {
     /// <summary>
     /// When set, the default value of the BuildCheck rule will be used.
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs b/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
similarity index 76%
rename from src/Build/BuildCheck/API/BuildAnalyzerRule.cs
rename to src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
index 8b43dad4999..ee6e008b71e 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
+++ b/src/Build/BuildCheck/API/BuildExecutionCheckRule.cs
@@ -5,13 +5,13 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
 /// Represents a rule that is a unit of build analysis.
-/// <see cref="BuildAnalyzer"/> is a unit of executing the analysis, but it can be discovering multiple distinct violation types,
-///  for this reason a single <see cref="BuildAnalyzer"/> can expose multiple <see cref="BuildAnalyzerRule"/>s.
+/// <see cref="BuildExecutionCheck"/> is a unit of executing the analysis, but it can be discovering multiple distinct violation types,
+///  for this reason a single <see cref="BuildExecutionCheck"/> can expose multiple <see cref="BuildExecutionCheckRule"/>s.
 /// </summary>
-public class BuildAnalyzerRule
+public class BuildExecutionCheckRule
 {
-    public BuildAnalyzerRule(string id, string title, string description, string messageFormat,
-        BuildAnalyzerConfiguration defaultConfiguration)
+    public BuildExecutionCheckRule(string id, string title, string description, string messageFormat,
+        BuildExecutionCheckConfiguration defaultConfiguration)
     {
         Id = id;
         Title = title;
@@ -51,5 +51,5 @@ public BuildAnalyzerRule(string id, string title, string description, string mes
     /// The default configuration - overridable by the user via .editorconfig.
     /// If no user specified configuration is provided, this default will be used.
     /// </summary>
-    public BuildAnalyzerConfiguration DefaultConfiguration { get; }
+    public BuildExecutionCheckConfiguration DefaultConfiguration { get; }
 }
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index ccb9dcfdafb..44a05f6f894 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -25,19 +25,19 @@ internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
     /// <summary>
     /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
     /// </summary>
-    public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(
-        AnalyzerAcquisitionData analyzerAcquisitionData,
-        IAnalysisContext analysisContext)
+    public List<BuildExecutionCheckFactory> CreateBuildExecutionCheckFactories(
+        CheckAcquisitionData checkAcquisitionData,
+        ICheckContext analysisContext)
     {
-        var analyzersFactories = new List<BuildAnalyzerFactory>();
+        var analyzersFactories = new List<BuildExecutionCheckFactory>();
 
         try
         {
             Assembly? assembly = null;
 #if FEATURE_ASSEMBLYLOADCONTEXT
-            assembly = s_coreClrAssemblyLoader.LoadFromPath(analyzerAcquisitionData.AssemblyPath);
+            assembly = s_coreClrAssemblyLoader.LoadFromPath(checkAcquisitionData.AssemblyPath);
 #else
-            assembly = Assembly.LoadFrom(analyzerAcquisitionData.AssemblyPath);
+            assembly = Assembly.LoadFrom(checkAcquisitionData.AssemblyPath);
 #endif
 
             IList<Type> availableTypes = assembly.GetExportedTypes();
diff --git a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs b/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
similarity index 70%
rename from src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
rename to src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
index 908aa931bef..84bfd2d64a0 100644
--- a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
+++ b/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
@@ -13,15 +13,15 @@ namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 // https://github.com/dotnet/msbuild/issues/9633
 // Acquisition
 //  define the data that will be passed to the acquisition module (and remoted if needed)
-internal class AnalyzerAcquisitionData(string assemblyPath)
+internal class CheckAcquisitionData(string assemblyPath)
 {
     public string AssemblyPath { get; init; } = assemblyPath;
 }
 
-internal static class AnalyzerAcquisitionDataExtensions
+internal static class CheckAcquisitionDataExtensions
 {
-    public static AnalyzerAcquisitionData ToAnalyzerAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
+    public static CheckAcquisitionData ToCheckAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
         new(eventArgs.AcquisitionPath);
 
-    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this AnalyzerAcquisitionData data) => new(data.AssemblyPath);
+    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this CheckAcquisitionData data) => new(data.AssemblyPath);
 }
diff --git a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
index 20259725b4f..8b06dd966a8 100644
--- a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
@@ -12,5 +12,5 @@ internal interface IBuildCheckAcquisitionModule
     /// <summary>
     /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
     /// </summary>
-    List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, IAnalysisContext analysisContext);
+    List<BuildExecutionCheckFactory> CreateBuildExecutionCheckFactories(CheckAcquisitionData analyzerAcquisitionData, ICheckContext analysisContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs b/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs
index f9e8cd36cfb..bf69888f476 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs
@@ -15,9 +15,9 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// <see cref="IAnalysisContext"/> that uses <see cref="EventArgsDispatcher"/> to dispatch.
+/// <see cref="ICheckContext"/> that uses <see cref="EventArgsDispatcher"/> to dispatch.
 /// </summary>
-internal class AnalysisDispatchingContext : IAnalysisContext
+internal class AnalysisDispatchingContext : ICheckContext
 {
     private readonly EventArgsDispatcher _eventDispatcher;
     private readonly BuildEventContext _eventContext;
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs b/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs
index 0a133f90f3d..1751c3c0d32 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs
@@ -6,7 +6,7 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal class AnalysisDispatchingContextFactory : IAnalysisContextFactory
+internal class AnalysisDispatchingContextFactory : ICheckContextFactory
 {
     private readonly EventArgsDispatcher _eventDispatcher;
 
@@ -19,6 +19,6 @@ public AnalysisDispatchingContextFactory(EventArgsDispatcher eventDispatcher)
         _eventDispatcher.AnyEventRaised += (sender, e) => AnyEventRaised?.Invoke(sender, e);
     }
 
-    public IAnalysisContext CreateAnalysisContext(BuildEventContext eventContext)
+    public ICheckContext CreateAnalysisContext(BuildEventContext eventContext)
         => new AnalysisDispatchingContext(_eventDispatcher, eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs b/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs
index 5df77259f6e..77aebf274b9 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs
@@ -13,14 +13,14 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// <see cref="IAnalysisContext"/> that uses <see cref="ILoggingService"/> to dispatch.
+/// <see cref="ICheckContext"/> that uses <see cref="ILoggingService"/> to dispatch.
 /// </summary>
 /// <remarks>
 /// Making this a record struct to avoid allocations (unless called through interface - which leads to boxing).
 /// This is wanted since this can be used in a hot path (of property reads and writes)
 /// </remarks>
 internal readonly struct AnalysisLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
-    : IAnalysisContext
+    : ICheckContext
 {
     public BuildEventContext BuildEventContext => eventContext;
 
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs b/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs
index b1a716d7b7f..0d1f49f5f0c 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs
@@ -11,12 +11,12 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal class AnalysisLoggingContextFactory : IAnalysisContextFactory
+internal class AnalysisLoggingContextFactory : ICheckContextFactory
 {
     private readonly ILoggingService _loggingService;
 
     public AnalysisLoggingContextFactory(ILoggingService loggingService) => _loggingService = loggingService;
 
-    public IAnalysisContext CreateAnalysisContext(BuildEventContext eventContext)
+    public ICheckContext CreateAnalysisContext(BuildEventContext eventContext)
         => new AnalysisLoggingContext(_loggingService, eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs b/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs
index 00439c6dd55..7c4e82861ea 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Interface that contains an instance of <see cref="BuildEventContext"/> and methods to dispatch it.
 /// </summary>
-internal interface IAnalysisContext
+internal interface ICheckContext
 {
     /// <summary>
     /// Instance of <see cref="BuildEventContext"/>.
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs b/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs
index 66cc71f507c..1010e803ed0 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs
@@ -5,7 +5,7 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal interface IAnalysisContextFactory
+internal interface ICheckContextFactory
 {
-    IAnalysisContext CreateAnalysisContext(BuildEventContext eventContext);
+    ICheckContext CreateAnalysisContext(BuildEventContext eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
index 46c42eaa4d1..8f560f561c5 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
@@ -13,16 +13,16 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// <summary>
 /// A wrapping, enriching class for BuildAnalyzer - so that we have additional data and functionality.
 /// </summary>
-internal sealed class BuildAnalyzerWrapper
+internal sealed class BuildExecutionCheckWrapper
 {
     private readonly Stopwatch _stopwatch = new Stopwatch();
 
-    public BuildAnalyzerWrapper(BuildAnalyzer buildAnalyzer)
+    public BuildExecutionCheckWrapper(BuildExecutionCheck buildAnalyzer)
     {
         BuildAnalyzer = buildAnalyzer;
     }
 
-    internal BuildAnalyzer BuildAnalyzer { get; }
+    internal BuildExecutionCheck BuildAnalyzer { get; }
     private bool _isInitialized = false;
 
     // Let's optimize for the scenario where users have a single .editorconfig file that applies to the whole solution.
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
index 2b6b94aa2d5..ec285013977 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
@@ -16,16 +16,16 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 internal class BuildCheckBuildEventHandler
 {
     private readonly IBuildCheckManager _buildCheckManager;
-    private readonly IAnalysisContextFactory _analyzerContextFactory;
+    private readonly ICheckContextFactory _checkContextFactory;
 
     private readonly Dictionary<Type, Action<BuildEventArgs>> _eventHandlers;
 
     internal BuildCheckBuildEventHandler(
-        IAnalysisContextFactory analyzerContextFactory,
+        ICheckContextFactory checkContextFactory,
         IBuildCheckManager buildCheckManager)
     {
         _buildCheckManager = buildCheckManager;
-        _analyzerContextFactory = analyzerContextFactory;
+        _checkContextFactory = checkContextFactory;
 
         _eventHandlers = new()
         {
@@ -56,7 +56,7 @@ private void HandleProjectEvaluationFinishedEvent(ProjectEvaluationFinishedEvent
         if (!IsMetaProjFile(eventArgs.ProjectFile))
         {
             _buildCheckManager.ProcessEvaluationFinishedEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
             _buildCheckManager.EndProjectEvaluation(BuildCheckDataSource.EventArgs, eventArgs.BuildEventContext!);
@@ -124,7 +124,7 @@ private void HandleBuildFinishedEvent(BuildFinishedEventArgs eventArgs)
         LogAnalyzerStats(_analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)));
     }
 
-    private void LogAnalyzerStats(IAnalysisContext analysisContext)
+    private void LogAnalyzerStats(ICheckContext analysisContext)
     {
         Dictionary<string, TimeSpan> infraStats = new Dictionary<string, TimeSpan>();
         Dictionary<string, TimeSpan> analyzerStats = new Dictionary<string, TimeSpan>();
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index 36419acdf49..b244cadeb27 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -98,24 +98,24 @@ internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
 
     internal void RunEvaluatedPropertiesActions(
         EvaluatedPropertiesAnalysisData evaluatedPropertiesAnalysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        ICheckContext analysisContext,
+        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesAnalysisData,
             analysisContext, resultHandler);
 
     internal void RunParsedItemsActions(
         ParsedItemsAnalysisData parsedItemsAnalysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        ICheckContext analysisContext,
+        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsAnalysisData,
             analysisContext, resultHandler);
 
     internal void RunTaskInvocationActions(
         TaskInvocationAnalysisData taskInvocationAnalysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        ICheckContext analysisContext,
+        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationAnalysisData,
             analysisContext, resultHandler);
@@ -123,7 +123,7 @@ internal void RunTaskInvocationActions(
     internal void RunPropertyReadActions(
         PropertyReadData propertyReadDataData,
         AnalysisLoggingContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.PropertyReadActions, propertyReadDataData,
             analysisContext, resultHandler);
@@ -131,15 +131,15 @@ internal void RunPropertyReadActions(
     internal void RunPropertyWriteActions(
         PropertyWriteData propertyWriteData,
         AnalysisLoggingContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.PropertyWriteActions, propertyWriteData,
             analysisContext, resultHandler);
 
     internal void RunProjectProcessingDoneActions(
         ProjectProcessingDoneData projectProcessingDoneData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        ICheckContext analysisContext,
+        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.ProjectProcessingDoneActions, projectProcessingDoneData,
             analysisContext, resultHandler);
@@ -147,8 +147,8 @@ internal void RunProjectProcessingDoneActions(
     private void RunRegisteredActions<T>(
         List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
         T analysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> resultHandler)
+        ICheckContext analysisContext,
+        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> resultHandler)
     where T : AnalysisData
     {
         string projectFullPath = analysisData.ProjectFilePath;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 5aa8ca900e9..d9f91a3b95f 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -16,10 +16,10 @@ internal sealed class BuildCheckConnectorLogger : ILogger
 {
     private readonly BuildCheckBuildEventHandler _eventHandler;
     private readonly IBuildCheckManager _buildCheckManager;
-    private readonly IAnalysisContextFactory _analysisContextFactory;
+    private readonly ICheckContextFactory _analysisContextFactory;
 
     internal BuildCheckConnectorLogger(
-        IAnalysisContextFactory analyzerContextFactory,
+        ICheckContextFactory analyzerContextFactory,
         IBuildCheckManager buildCheckManager)
     {
         _buildCheckManager = buildCheckManager;
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 3e8d53982c5..94b6966c1c8 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -18,8 +18,8 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal delegate BuildAnalyzer BuildAnalyzerFactory();
-internal delegate BuildAnalyzerWrapper BuildAnalyzerWrapperFactory(ConfigurationContext configurationContext);
+internal delegate BuildExecutionCheck BuildExecutionCheckFactory();
+internal delegate BuildExecutionCheckWrapper BuildAnalyzerWrapperFactory(ConfigurationContext configurationContext);
 
 /// <summary>
 /// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
@@ -70,14 +70,14 @@ internal sealed class BuildCheckManager : IBuildCheckManager, IBuildEngineDataRo
         private readonly TracingReporter _tracingReporter = new TracingReporter();
         private readonly ConfigurationProvider _configurationProvider = new ConfigurationProvider();
         private readonly BuildCheckCentralContext _buildCheckCentralContext;
-        private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry;
+        private readonly List<BuildExecutionCheckFactoryContext> _analyzersRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
         private readonly BuildEventsProcessor _buildEventsProcessor;
         private readonly IBuildCheckAcquisitionModule _acquisitionModule;
 
         internal BuildCheckManager()
         {
-            _analyzersRegistry = new List<BuildAnalyzerFactoryContext>();
+            _analyzersRegistry = new List<BuildExecutionCheckFactoryContext>();
             _acquisitionModule = new BuildCheckAcquisitionModule();
             _buildCheckCentralContext = new(_configurationProvider);
             _buildEventsProcessor = new(_buildCheckCentralContext);
@@ -98,19 +98,19 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
             {
                 _enabledDataSources[(int)buildCheckDataSource] = true;
                 RegisterBuiltInAnalyzers(buildCheckDataSource);
-            }
+            } 
             stopwatch.Stop();
             _tracingReporter.AddSetDataSourceStats(stopwatch.Elapsed);
         }
 
         public void ProcessAnalyzerAcquisition(
-            AnalyzerAcquisitionData acquisitionData,
-            IAnalysisContext analysisContext)
+            CheckAcquisitionData acquisitionData,
+            ICheckContext analysisContext)
         {
             Stopwatch stopwatch = Stopwatch.StartNew();
             if (IsInProcNode)
             {
-                var analyzersFactories = _acquisitionModule.CreateBuildAnalyzerFactories(acquisitionData, analysisContext);
+                var analyzersFactories = _acquisitionModule.CreateBuildExecutionCheckFactories(acquisitionData, analysisContext);
                 if (analyzersFactories.Count != 0)
                 {
                     RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, analyzersFactories, analysisContext);
@@ -134,7 +134,7 @@ public void ProcessAnalyzerAcquisition(
 
         private static T Construct<T>() where T : new() => new();
 
-        private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][] s_builtInFactoriesPerDataSource =
+        private static readonly (string[] ruleIds, bool defaultEnablement, BuildExecutionCheckFactory factory)[][] s_builtInFactoriesPerDataSource =
         [
             // BuildCheckDataSource.EventArgs
             [
@@ -149,19 +149,19 @@ private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzer
         /// <summary>
         /// For tests only. TODO: Remove when analyzer acquisition is done.
         /// </summary>
-        internal static (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][]? s_testFactoriesPerDataSource;
+        internal static (string[] ruleIds, bool defaultEnablement, BuildExecutionCheckFactory factory)[][]? s_testFactoriesPerDataSource;
 
         private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
         {
             _analyzersRegistry.AddRange(
                 s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
-                    .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+                    .Select(v => new BuildExecutionCheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
 
             if (s_testFactoriesPerDataSource is not null)
             {
                 _analyzersRegistry.AddRange(
                     s_testFactoriesPerDataSource[(int)buildCheckDataSource]
-                        .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+                        .Select(v => new BuildExecutionCheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
             }
         }
 
@@ -171,16 +171,16 @@ private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
         /// </summary>
         internal void RegisterCustomAnalyzers(
             BuildCheckDataSource buildCheckDataSource,
-            IEnumerable<BuildAnalyzerFactory> factories,
+            IEnumerable<BuildExecutionCheckFactory> factories,
             string[] ruleIds,
             bool defaultEnablement,
-            IAnalysisContext analysisContext)
+            ICheckContext analysisContext)
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
             {
-                foreach (BuildAnalyzerFactory factory in factories)
+                foreach (BuildExecutionCheckFactory factory in factories)
                 {
-                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(factory, ruleIds, defaultEnablement));
+                    _analyzersRegistry.Add(new BuildExecutionCheckFactoryContext(factory, ruleIds, defaultEnablement));
 
                     var instance = factory();
                     analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
@@ -197,15 +197,15 @@ internal void RegisterCustomAnalyzers(
         /// <param name="analysisContext">The logging context of the build event.</param>
         internal void RegisterCustomAnalyzer(
             BuildCheckDataSource buildCheckDataSource,
-            IEnumerable<BuildAnalyzerFactory> factories,
-            IAnalysisContext analysisContext)
+            IEnumerable<BuildExecutionCheckFactory> factories,
+            ICheckContext analysisContext)
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
             {
                 foreach (var factory in factories)
                 {
                     var instance = factory();
-                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(
+                    _analyzersRegistry.Add(new BuildExecutionCheckFactoryContext(
                         factory,
                         instance.SupportedRules.Select(r => r.Id).ToArray(),
                         instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
@@ -214,17 +214,17 @@ internal void RegisterCustomAnalyzer(
             }
         }
 
-        private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryContext, string projectFullPath)
+        private void SetupSingleAnalyzer(BuildExecutionCheckFactoryContext analyzerFactoryContext, string projectFullPath)
         {
             // For custom analyzers - it should run only on projects where referenced
             // (otherwise error out - https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57849480)
             // on others it should work similarly as disabling them.
             // Disabled analyzer should not only post-filter results - it shouldn't even see the data 
-            BuildAnalyzerWrapper wrapper;
+            BuildExecutionCheckWrapper wrapper;
             BuildAnalyzerConfigurationEffective[] configurations;
             if (analyzerFactoryContext.MaterializedAnalyzer == null)
             {
-                BuildAnalyzerConfiguration[] userConfigs =
+                BuildExecutionCheckConfiguration[] userConfigs =
                     _configurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
                 if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
@@ -236,14 +236,14 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
                 CustomConfigurationData[] customConfigData =
                     _configurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
 
-                BuildAnalyzer uninitializedAnalyzer = analyzerFactoryContext.Factory();
+                BuildExecutionCheck uninitializedAnalyzer = analyzerFactoryContext.Factory();
                 configurations = _configurationProvider.GetMergedConfigurations(userConfigs, uninitializedAnalyzer);
 
                 ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData, configurations);
 
                 wrapper = analyzerFactoryContext.Initialize(uninitializedAnalyzer, configurationContext);
                 analyzerFactoryContext.MaterializedAnalyzer = wrapper;
-                BuildAnalyzer analyzer = wrapper.BuildAnalyzer;
+                BuildExecutionCheck analyzer = wrapper.BuildAnalyzer;
 
                 // This is to facilitate possible perf improvement for custom analyzers - as we might want to
                 //  avoid loading the assembly and type just to check if it's supported.
@@ -292,15 +292,15 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
             }
         }
 
-        private void SetupAnalyzersForNewProject(string projectFullPath, IAnalysisContext analysisContext)
+        private void SetupAnalyzersForNewProject(string projectFullPath, ICheckContext analysisContext)
         {
             // Only add analyzers here
             // On an execution node - we might remove and dispose the analyzers once project is done
 
             // If it's already constructed - just control the custom settings do not differ
             Stopwatch stopwatch = Stopwatch.StartNew();
-            List<BuildAnalyzerFactoryContext> analyzersToRemove = new();
-            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            List<BuildExecutionCheckFactoryContext> analyzersToRemove = new();
+            foreach (BuildExecutionCheckFactoryContext analyzerFactoryContext in _analyzersRegistry)
             {
                 try
                 {
@@ -335,12 +335,12 @@ private void SetupAnalyzersForNewProject(string projectFullPath, IAnalysisContex
         }
 
         public void ProcessEvaluationFinishedEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext analysisContext,
             ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
             => _buildEventsProcessor
                 .ProcessEvaluationFinishedEventArgs(analysisContext, evaluationFinishedEventArgs);
 
-        public void ProcessEnvironmentVariableReadEventArgs(IAnalysisContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
+        public void ProcessEnvironmentVariableReadEventArgs(ICheckContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
         {
             if (projectEvaluationEventArgs is EnvironmentVariableReadEventArgs evr)
             {
@@ -354,26 +354,26 @@ public void ProcessEnvironmentVariableReadEventArgs(IAnalysisContext analysisCon
         }
 
         public void ProcessTaskStartedEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext analysisContext,
             TaskStartedEventArgs taskStartedEventArgs)
             => _buildEventsProcessor
                 .ProcessTaskStartedEventArgs(analysisContext, taskStartedEventArgs);
 
         public void ProcessTaskFinishedEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext analysisContext,
             TaskFinishedEventArgs taskFinishedEventArgs)
             => _buildEventsProcessor
                 .ProcessTaskFinishedEventArgs(analysisContext, taskFinishedEventArgs);
 
         public void ProcessTaskParameterEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext analysisContext,
             TaskParameterEventArgs taskParameterEventArgs)
             => _buildEventsProcessor
                 .ProcessTaskParameterEventArgs(analysisContext, taskParameterEventArgs);
 
         public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats()
         {
-            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            foreach (BuildExecutionCheckFactoryContext analyzerFactoryContext in _analyzersRegistry)
             {
                 if (analyzerFactoryContext.MaterializedAnalyzer != null)
                 {
@@ -430,7 +430,7 @@ private string GetProjectFullPath(BuildEventContext buildEventContext)
 
         public void StartProjectEvaluation(
             BuildCheckDataSource buildCheckDataSource,
-            IAnalysisContext analysisContext,
+            ICheckContext analysisContext,
             string projectFullPath)
         {
             if (buildCheckDataSource == BuildCheckDataSource.EventArgs && IsInProcNode)
@@ -464,7 +464,7 @@ public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, Build
 
         public void EndProjectRequest(
             BuildCheckDataSource buildCheckDataSource,
-            IAnalysisContext analysisContext,
+            ICheckContext analysisContext,
             string projectFullPath)
         {
             _buildEventsProcessor.ProcessProjectDone(analysisContext, projectFullPath);
@@ -502,24 +502,24 @@ public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLo
         public void Shutdown()
         { /* Too late here for any communication to the main node or for logging anything */ }
 
-        private class BuildAnalyzerFactoryContext(
-            BuildAnalyzerFactory factory,
+        private class BuildExecutionCheckFactoryContext(
+            BuildExecutionCheckFactory factory,
             string[] ruleIds,
             bool isEnabledByDefault)
         {
-            public BuildAnalyzer Factory()
+            public BuildExecutionCheck Factory()
             {
-                BuildAnalyzer ba = factory();
+                BuildExecutionCheck ba = factory();
                 return ba;
             }
 
-            public BuildAnalyzerWrapper Initialize(BuildAnalyzer ba, ConfigurationContext configContext)
+            public BuildExecutionCheckWrapper Initialize(BuildExecutionCheck ba, ConfigurationContext configContext)
             {
                 ba.Initialize(configContext);
-                return new BuildAnalyzerWrapper(ba);
+                return new BuildExecutionCheckWrapper(ba);
             }
 
-            public BuildAnalyzerWrapper? MaterializedAnalyzer { get; set; }
+            public BuildExecutionCheckWrapper? MaterializedAnalyzer { get; set; }
 
             public string[] RuleIds { get; init; } = ruleIds;
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index 05134a3c8c1..63ea8481cfb 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -47,7 +47,7 @@ public TaskKey(BuildEventContext context)
 
     // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
     internal void ProcessEvaluationFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
     {
         Dictionary<string, string> propertiesLookup = new Dictionary<string, string>();
@@ -89,7 +89,7 @@ internal void ProcessEnvironmentVariableReadEventArgs(string envVarName, string
     }
 
     internal void ProcessTaskStartedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         TaskStartedEventArgs taskStartedEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
@@ -126,7 +126,7 @@ internal void ProcessTaskStartedEventArgs(
     }
 
     internal void ProcessTaskFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         TaskFinishedEventArgs taskFinishedEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
@@ -148,7 +148,7 @@ internal void ProcessTaskFinishedEventArgs(
     }
 
     internal void ProcessTaskParameterEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         TaskParameterEventArgs taskParameterEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
@@ -193,7 +193,7 @@ public void ProcessPropertyWrite(PropertyWriteData propertyWriteData, AnalysisLo
                 analysisContext,
                 ReportResult);
 
-    public void ProcessProjectDone(IAnalysisContext analysisContext, string projectFullPath)
+    public void ProcessProjectDone(ICheckContext analysisContext, string projectFullPath)
         => _buildCheckCentralContext.RunProjectProcessingDoneActions(
                 new ProjectProcessingDoneData(projectFullPath, analysisContext.BuildEventContext.ProjectInstanceId),
                 analysisContext,
@@ -201,7 +201,7 @@ public void ProcessProjectDone(IAnalysisContext analysisContext, string projectF
 
     private static void ReportResult(
         BuildAnalyzerWrapper analyzerWrapper,
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         BuildAnalyzerConfigurationEffective[] configPerRule,
         BuildCheckResult result)
     {
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index d3174b94ed0..81611053648 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -36,28 +36,28 @@ internal enum BuildCheckDataSource
 internal interface IBuildCheckManager
 {
     void ProcessEvaluationFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
 
     void ProcessEnvironmentVariableReadEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         EnvironmentVariableReadEventArgs envVariableReadEventArgs);
 
     void ProcessTaskStartedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         TaskStartedEventArgs taskStartedEventArgs);
 
     void ProcessTaskFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         TaskFinishedEventArgs taskFinishedEventArgs);
 
     void ProcessTaskParameterEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         TaskParameterEventArgs taskParameterEventArgs);
 
     void SetDataSource(BuildCheckDataSource buildCheckDataSource);
 
-    void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, IAnalysisContext analysisContext);
+    void ProcessAnalyzerAcquisition(CheckAcquisitionData acquisitionData, ICheckContext analysisContext);
 
     Dictionary<string, TimeSpan> CreateAnalyzerTracingStats();
 
@@ -67,13 +67,13 @@ void ProcessTaskParameterEventArgs(
     //  but as well from the ConnectorLogger - as even if interleaved, it gives the info
     //  to manager about what analyzers need to be materialized and configuration fetched.
     // No unloading of analyzers is yet considered - once loaded it stays for whole build.
-    void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext, string projectFullPath);
+    void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, ICheckContext analysisContext, string projectFullPath);
 
     void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
 
     void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string projectFullPath);
 
-    void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext, string projectFullPath);
+    void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, ICheckContext analysisContext, string projectFullPath);
 
     void Shutdown();
 }
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
index 4aceff798f6..8789bc73568 100644
--- a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
@@ -12,7 +12,7 @@ internal interface IBuildEngineDataRouter
 {
     void ProcessPropertyRead(
         PropertyReadInfo propertyReadInfo,
-        // This is intentionally AnalysisLoggingContext instead of IAnalysisContext - to avoid boxing allocations
+        // This is intentionally AnalysisLoggingContext instead of ICheckContext - to avoid boxing allocations
         //  on a hot path of properties reading (same for writing)
         AnalysisLoggingContext analysisContext);
 
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index 338a282cdcd..e33ed43ee7d 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -17,7 +17,7 @@ public void Shutdown()
     }
 
     public void ProcessEvaluationFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs)
     {
     }
@@ -27,26 +27,26 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
     }
 
     public void ProcessTaskStartedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         TaskStartedEventArgs taskStartedEventArgs)
     {
     }
 
     public void ProcessTaskFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         TaskFinishedEventArgs taskFinishedEventArgs)
     {
     }
 
     public void ProcessTaskParameterEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext analysisContext,
         TaskParameterEventArgs taskParameterEventArgs)
     {
     }
 
     public void ProcessAnalyzerAcquisition(
-        AnalyzerAcquisitionData acquisitionData,
-        IAnalysisContext analysisContext)
+        CheckAcquisitionData acquisitionData,
+        ICheckContext analysisContext)
     {
     }
 
@@ -54,7 +54,7 @@ public void FinalizeProcessing(LoggingContext loggingContext)
     {
     }
 
-    public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext, string fullPath)
+    public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, ICheckContext analysisContext, string fullPath)
     {
     }
 
@@ -66,7 +66,7 @@ public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, Build
     {
     }
 
-    public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext,
+    public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, ICheckContext analysisContext,
         string projectFullPath)
     {
     }
@@ -96,6 +96,6 @@ public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggi
     public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext buildEventContext)
     { }
 	
-    public void ProcessEnvironmentVariableReadEventArgs(IAnalysisContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
+    public void ProcessEnvironmentVariableReadEventArgs(ICheckContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
     { }
 }
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index 823e9f0541c..bba1991c38c 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -63,15 +63,15 @@ public abstract class AnalysisData(string projectFilePath, int? projectConfigura
 public class BuildCheckDataContext<T> where T : AnalysisData
 {
     private readonly BuildAnalyzerWrapper _analyzerWrapper;
-    private readonly IAnalysisContext _analysisContext;
+    private readonly ICheckContext _analysisContext;
     private readonly BuildAnalyzerConfigurationEffective[] _configPerRule;
-    private readonly Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> _resultHandler;
+    private readonly Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> _resultHandler;
 
     internal BuildCheckDataContext(
         BuildAnalyzerWrapper analyzerWrapper,
-        IAnalysisContext loggingContext,
+        ICheckContext loggingContext,
         BuildAnalyzerConfigurationEffective[] configPerRule,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> resultHandler,
+        Action<BuildAnalyzerWrapper, ICheckContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> resultHandler,
         T data)
     {
         _analyzerWrapper = analyzerWrapper;
diff --git a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
index 5ab4ea729b0..228e8850489 100644
--- a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
+++ b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
@@ -66,10 +66,10 @@ internal sealed class BuildCheckAcquisitionModuleMock : IBuildCheckAcquisitionMo
 
     internal BuildCheckAcquisitionModuleMock(bool isAnalyzerRuleExistForTest) => _isAnalyzerRuleExistForTest = isAnalyzerRuleExistForTest;
 
-    public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, IAnalysisContext analysisContext)
+    public List<BuildExecutionCheckFactory> CreateBuildAnalyzerFactories(CheckAcquisitionData analyzerAcquisitionData, ICheckContext analysisContext)
         => _isAnalyzerRuleExistForTest
-        ? new List<BuildAnalyzerFactory>() { () => new BuildAnalyzerRuleMock("Rule1"), () => new BuildAnalyzerRuleMock("Rule2") }
-        : new List<BuildAnalyzerFactory>();
+        ? new List<BuildExecutionCheckFactory>() { () => new BuildAnalyzerRuleMock("Rule1"), () => new BuildAnalyzerRuleMock("Rule2") }
+        : new List<BuildExecutionCheckFactory>();
 }
 
 internal sealed class BuildAnalyzerRuleMock : BuildAnalyzer
diff --git a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
index 2dc907aaf15..649ef42f3af 100644
--- a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
+++ b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
@@ -41,7 +41,7 @@ public void TriggerTaskInvocationAction(TaskInvocationAnalysisData data)
                 }
             }
 
-            private void ResultHandler(BuildAnalyzerWrapper wrapper, IAnalysisContext context, BuildAnalyzerConfigurationEffective[] configs, BuildCheckResult result)
+            private void ResultHandler(BuildAnalyzerWrapper wrapper, ICheckContext context, BuildAnalyzerConfigurationEffective[] configs, BuildCheckResult result)
                 => Results.Add(result);
         }
 
