diff --git a/.github/CODE_OF_CONDUCT.md b/.github/CODE_OF_CONDUCT.md
index 6684a497cb9..91d2e404ff1 100644
--- a/.github/CODE_OF_CONDUCT.md
+++ b/.github/CODE_OF_CONDUCT.md
@@ -1,3 +1,6 @@
 # Code of Conduct
 
-This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.
+This project has adopted the code of conduct defined by the Contributor Covenant
+to clarify expected behavior in our community.
+
+For more information, see the [.NET Foundation Code of Conduct](https://dotnetfoundation.org/code-of-conduct).
\ No newline at end of file
diff --git a/README.md b/README.md
index b81b6c6c627..2950b52008a 100644
--- a/README.md
+++ b/README.md
@@ -53,10 +53,6 @@ MSBuild can be run on Unix systems that support .NET Core. Set-up instructions c
 
 You can turn on localized builds via the `/p:LocalizedBuild=true` command line argument. For more information on localized builds and how to make contributions to MSBuild's translations, see our [localization documentation](documentation/wiki/Localization.md)
 
-## How to Engage, Contribute and Provide Feedback
-
-This project has adopted the [Microsoft Open Source Code of Conduct](https://opensource.microsoft.com/codeofconduct/). For more information see the [Code of Conduct FAQ](https://opensource.microsoft.com/codeofconduct/faq/) or contact [opencode@microsoft.com](mailto:opencode@microsoft.com) with any additional questions or comments.
-
 #### Getting Started
 
 Before you contribute, please read through the contributing and developer guides to get an idea of what kinds of pull requests we accept.
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index bf6fdd62e01..536996904e0 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1530,7 +1530,7 @@ public void ExpandAllIntoStringTruncated()
             Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(lookup, lookup, itemMetadata, FileSystems.Default);
 
             XmlAttribute xmlattribute = (new XmlDocument()).CreateAttribute("dummy");
-            xmlattribute.Value = "'%(ManySpacesMetadata)' != '' and '$(ManySpacesProperty)' != '' and '@(ManySpacesItem)' != '' and '@(Exactly1024)' != '' and '@(ManyItems)' != '' and '@(ManyItems->'%(Foo)')' != ''";
+            xmlattribute.Value = "'%(ManySpacesMetadata)' != '' and '$(ManySpacesProperty)' != '' and '@(ManySpacesItem)' != '' and '@(Exactly1024)' != '' and '@(ManyItems)' != '' and '@(ManyItems->'%(Foo)')' != '' and '@(ManyItems->'%(Nonexistent)')' != ''";
 
             var expected =
                 $"'{"",1021}...' != '' and " +
@@ -1538,7 +1538,13 @@ public void ExpandAllIntoStringTruncated()
                 $"'Foo;{"",1017}...' != '' and " +
                 $"'{"",1024};...' != '' and " +
                 "'ThisIsAFairlyLongFileName_0.bmp;ThisIsAFairlyLongFileName_1.bmp;ThisIsAFairlyLongFileName_2.bmp;...' != '' and " +
-                "'ThisIsAFairlyLongMetadataValue_0;ThisIsAFairlyLongMetadataValue_1;ThisIsAFairlyLongMetadataValue_2;...' != ''";
+                "'ThisIsAFairlyLongMetadataValue_0;ThisIsAFairlyLongMetadataValue_1;ThisIsAFairlyLongMetadataValue_2;...' != '' and " +
+                $"';;;...' != ''";
+            // NOTE: semicolons in the last part are *weird* because they don't actually mean anything and you get logging like
+            //     Target "Build" skipped, due to false condition; ( '@(I->'%(nonexistent)')' == '' ) was evaluated as ( ';' == '' ).
+            // but that goes back to MSBuild 4.something so I'm codifying it in this test. If you're here because you cleaned it up
+            // and want to fix the test my current opinion is that's fine.
+
             Assert.Equal(expected, expander.ExpandIntoStringAndUnescape(xmlattribute.Value, ExpanderOptions.ExpandAll | ExpanderOptions.Truncate, MockElementLocation.Instance));
         }
 
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 177903a4e72..814ffa7c218 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -81,6 +81,7 @@ public sealed class SolutionFile
         private const string fsProjectGuid = "{F2A71F9B-5D33-465A-A702-920D77279786}";
         private const string dbProjectGuid = "{C8D11400-126E-41CD-887F-60BD40844F9E}";
         private const string wdProjectGuid = "{2CFEAB61-6A3B-4EB8-B523-560B4BEEF521}";
+        private const string synProjectGuid = "{BBD0F5D1-1CC4-42FD-BA4C-A96779C64378}";
         private const string webProjectGuid = "{E24C65DC-7377-472B-9ABA-BC803B73C61A}";
         private const string solutionFolderGuid = "{2150E333-8FDC-42A3-9474-1A3956D46DE8}";
         private const string sharedProjectGuid = "{D954291E-2A0B-460D-934E-DC6B0785DB48}";
@@ -1266,7 +1267,8 @@ ProjectInSolution proj
                 (String.Equals(projectTypeGuid, cpsFsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
                 (String.Equals(projectTypeGuid, fsProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
                 (String.Equals(projectTypeGuid, dbProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
-                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)))
+                (String.Equals(projectTypeGuid, vjProjectGuid, StringComparison.OrdinalIgnoreCase)) ||
+                (String.Equals(projectTypeGuid, synProjectGuid, StringComparison.OrdinalIgnoreCase)))
             {
                 proj.ProjectType = SolutionProjectType.KnownToBeMSBuildFormat;
             }
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 62efc814b55..99d9cd4e81e 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -60,7 +60,7 @@ public class Project : ILinkableObject
         private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c!= '/' && c != '\\' && c != ':').ToArray();
 
         /// <summary>
-        /// Context to log messages and events in
+        /// Context to log messages and events in.
         /// </summary>
         private static readonly BuildEventContext s_buildEventContext = new BuildEventContext(0 /* node ID */, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
 
@@ -157,7 +157,7 @@ public Project(ProjectCollection projectCollection, NewProjectFileOptions newPro
         /// Project will be added to the specified project collection when it is named.
         /// </summary>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         public Project(IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection)
             : this(ProjectRootElement.Create(projectCollection, DefaultNewProjectTemplateOptions), globalProperties, toolsVersion, projectCollection)
@@ -170,7 +170,7 @@ public Project(IDictionary<string, string> globalProperties, string toolsVersion
         /// Project will be added to the specified project collection when it is named.
         /// </summary>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="newProjectFileOptions">The <see cref="NewProjectFileOptions"/> to use for the new project.</param>
         public Project(IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, NewProjectFileOptions newProjectFileOptions)
@@ -185,7 +185,7 @@ public Project(IDictionary<string, string> globalProperties, string toolsVersion
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         public Project(ProjectRootElement xml)
             : this(xml, null, null)
         {
@@ -198,9 +198,9 @@ public Project(ProjectRootElement xml)
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion)
             : this(xml, globalProperties, toolsVersion, ProjectCollection.GlobalProjectCollection)
         {
@@ -213,9 +213,9 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection)
             : this(xml, globalProperties, toolsVersion, projectCollection, ProjectLoadSettings.Default)
@@ -229,9 +229,9 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
@@ -246,9 +246,9 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xml">ProjectRootElement to use</param>
+        /// <param name="xml">ProjectRootElement to use.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
@@ -277,7 +277,7 @@ private Project(ProjectRootElement xml, IDictionary<string, string> globalProper
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         public Project(XmlReader xmlReader)
             : this(xmlReader, null, null)
         {
@@ -290,9 +290,9 @@ public Project(XmlReader xmlReader)
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion)
             : this(xmlReader, globalProperties, toolsVersion, ProjectCollection.GlobalProjectCollection)
         {
@@ -305,9 +305,9 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection)
             : this(xmlReader, globalProperties, toolsVersion, projectCollection, ProjectLoadSettings.Default)
@@ -321,9 +321,9 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
@@ -338,9 +338,9 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// Throws InvalidProjectFileException if the evaluation fails.
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// </summary>
-        /// <param name="xmlReader">Xml reader to read project from</param>
+        /// <param name="xmlReader">Xml reader to read project from.</param>
         /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-        /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+        /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
         /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
@@ -397,7 +397,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// May throw IO-related exceptions.
         /// </summary>
-        /// <param name="projectFile">The project file</param>
+        /// <param name="projectFile">The project file.</param>
         /// <param name="globalProperties">The global properties. May be null.</param>
         /// <param name="toolsVersion">The tools version. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
@@ -414,7 +414,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// May throw IO-related exceptions.
         /// </summary>
-        /// <param name="projectFile">The project file</param>
+        /// <param name="projectFile">The project file.</param>
         /// <param name="globalProperties">The global properties. May be null.</param>
         /// <param name="toolsVersion">The tools version. May be null.</param>
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
@@ -432,7 +432,7 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
         /// May throw IO-related exceptions.
         /// </summary>
-        /// <param name="projectFile">The project file</param>
+        /// <param name="projectFile">The project file.</param>
         /// <param name="globalProperties">The global properties. May be null.</param>
         /// <param name="toolsVersion">The tools version. May be null.</param>
         /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
@@ -562,7 +562,7 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// The backing Xml project.
-        /// Can never be null
+        /// Can never be null.
         /// </summary>
         /// <remarks>
         /// There is no setter here as that doesn't make sense. If you have a new ProjectRootElement, evaluate it into a new Project.
@@ -595,7 +595,7 @@ private enum BuildEnabledSetting
         /// </summary>
         /// <comments>
         /// data.ItemTypes is a KeyCollection, so it doesn't need any
-        /// additional read-only protection
+        /// additional read-only protection.
         /// </comments>
         public ICollection<string> ItemTypes => implementation.ItemTypes;
 
@@ -625,12 +625,12 @@ private enum BuildEnabledSetting
 
         /// <summary>
         /// Read-only dictionary of item definitions in this project.
-        /// Keyed by item type
+        /// Keyed by item type.
         /// </summary>
         public IDictionary<string, ProjectItemDefinition> ItemDefinitions => implementation.ItemDefinitions;
 
         /// <summary>
-        /// Items in this project, ordered within groups of item types
+        /// Items in this project, ordered within groups of item types.
         /// </summary>
         [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
         public ICollection<ProjectItem> Items => implementation.Items;
@@ -806,12 +806,12 @@ public bool IsBuildEnabled
         public int LastEvaluationId => implementation.LastEvaluationId;
 
         /// <summary>
-        /// List of names of the properties that, while global, are still treated as overridable
+        /// List of names of the properties that, while global, are still treated as overridable.
         /// </summary>
         internal ISet<string> GlobalPropertiesToTreatAsLocal => implementationInternal.GlobalPropertiesToTreatAsLocal;
 
         /// <summary>
-        /// The logging service used for evaluation errors
+        /// The logging service used for evaluation errors.
         /// </summary>
         internal ILoggingService LoggingService => ProjectCollection.LoggingService;
 
@@ -862,7 +862,7 @@ public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item)
         ///GlobResult(glob: "*.txt", exclude=[]),
         ///GlobResult(glob: "*.a", exclude=[]),
         ///GlobResult(glob: "*.cs", exclude=["bar"])
-        ///]
+        ///].
         /// </example>
         /// <remarks>
         /// <see cref="GlobResult.MsBuildGlob"/> is a <see cref="IMSBuildGlob"/> that combines all globs in the include element and ignores
@@ -884,11 +884,11 @@ public List<GlobResult> GetAllGlobs()
         }
 
         /// <summary>
-        /// See <see cref="GetAllGlobs()"/>
+        /// See <see cref="GetAllGlobs()"/>.
         /// </summary>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
         {
@@ -896,21 +896,21 @@ public List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
         }
 
         /// <summary>
-        /// Overload of <see cref="GetAllGlobs()"/>
+        /// Overload of <see cref="GetAllGlobs()"/>.
         /// </summary>
-        /// <param name="itemType">Confine search to item elements of this type</param>
+        /// <param name="itemType">Confine search to item elements of this type.</param>
         public List<GlobResult> GetAllGlobs(string itemType)
         {
             return implementation.GetAllGlobs(itemType, null);
         }
 
         /// <summary>
-        /// See <see cref="GetAllGlobs(string)"/>
+        /// See <see cref="GetAllGlobs(string)"/>.
         /// </summary>
-        /// <param name="itemType">type of the item</param>
+        /// <param name="itemType">Type of the item.</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluationContext)
         {
@@ -921,11 +921,11 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         /// Finds all the item elements in the logical project with itemspecs that match the given string:
         /// - elements that would include (or exclude) the string
         /// - elements that would update the string (not yet implemented)
-        /// - elements that would remove the string (not yet implemented)
+        /// - elements that would remove the string (not yet implemented).
         /// </summary>
         ///
         /// <example>
-        /// The following snippet shows what <c>GetItemProvenance("a.cs")</c> returns for various item elements
+        /// The following snippet shows what <c>GetItemProvenance("a.cs")</c> returns for various item elements.
         /// <code>
         /// <A Include="a.cs;*.cs"/> // Occurrences:2; Operation: Include; Provenance: StringLiteral | Glob
         /// <B Include="*.cs" Exclude="a.cs"/> // Occurrences: 1; Operation: Exclude; Provenance: StringLiteral
@@ -956,7 +956,7 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         /// This API and its return types are prone to change.
         /// </remarks>
         ///
-        /// <param name="itemToMatch">The string to perform matching against</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
         ///
         /// <returns>
         /// A list of <see cref="ProvenanceResult"/>, sorted in project evaluation order.
@@ -967,12 +967,12 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch)
         }
 
         /// <summary>
-        /// See <see cref="GetItemProvenance(string)"/>
+        /// See <see cref="GetItemProvenance(string)"/>.
         /// </summary>
-        /// <param name="itemToMatch">The string to perform matching against</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationContext evaluationContext)
         {
@@ -980,23 +980,23 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationCo
         }
 
         /// <summary>
-        /// Overload of <see cref="GetItemProvenance(string)"/>
+        /// Overload of <see cref="GetItemProvenance(string)"/>.
         /// </summary>
-        /// <param name="itemToMatch">The string to perform matching against</param>
-        /// <param name="itemType">The item type to constrain the search in</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
+        /// <param name="itemType">The item type to constrain the search in.</param>
         public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType)
         {
             return GetItemProvenance(itemToMatch, itemType, null);
         }
 
         /// <summary>
-        /// See <see cref="GetItemProvenance(string, string)"/>
+        /// See <see cref="GetItemProvenance(string, string)"/>.
         /// </summary>
-        /// <param name="itemToMatch">The string to perform matching against</param>
-        /// <param name="itemType">The type of the item to perform matching against</param>
+        /// <param name="itemToMatch">The string to perform matching against.</param>
+        /// <param name="itemType">The type of the item to perform matching against.</param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, EvaluationContext evaluationContext)
         {
@@ -1004,7 +1004,7 @@ public List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemT
         }
 
         /// <summary>
-        /// Overload of <see cref="GetItemProvenance(string)"/>
+        /// Overload of <see cref="GetItemProvenance(string)"/>.
         /// </summary>
         /// <param name="item">
         /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
@@ -1017,7 +1017,7 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item)
         }
 
         /// <summary>
-        /// See <see cref="GetItemProvenance(ProjectItem)"/>
+        /// See <see cref="GetItemProvenance(ProjectItem)"/>.
         /// </summary>
         /// <param name="item">
         /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
@@ -1026,7 +1026,7 @@ public List<ProvenanceResult> GetItemProvenance(ProjectItem item)
         /// </param>
         /// <param name="evaluationContext">
         ///     The evaluation context to use in case reevaluation is required.
-        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+        ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
         /// </param>
         public List<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationContext evaluationContext)
         {
@@ -1065,7 +1065,7 @@ public static string GetMetadataValueEscaped(ProjectItemDefinition item, string
         }
 
         /// <summary>
-        /// Get the escaped value of the provided property
+        /// Get the escaped value of the provided property.
         /// </summary>
         [SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "IProperty is an internal interface; this is less confusing to outside customers. ")]
         public static string GetPropertyValueEscaped(ProjectProperty property)
@@ -1087,7 +1087,7 @@ public IEnumerable<ProjectElement> GetLogicalProject()
 
         /// <summary>
         /// Get any property in the project that has the specified name,
-        /// otherwise returns null
+        /// otherwise returns null.
         /// </summary>
         [DebuggerStepThrough]
         public ProjectProperty GetProperty(string name)
@@ -1318,7 +1318,7 @@ public string ExpandString(string unexpandedValue)
         /// This instance can be used to build independently.
         /// Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
         /// </summary>
-        /// <returns>the created project instance</returns>
+        /// <returns>The created project instance.</returns>
         public ProjectInstance CreateProjectInstance()
         {
             return CreateProjectInstance(ProjectInstanceSettings.None, null);
@@ -1331,19 +1331,19 @@ public ProjectInstance CreateProjectInstance()
         /// The instance is immutable; none of the objects that form it can be modified. This makes it safe to
         /// access concurrently from multiple threads.
         /// </summary>
-        /// <param name="settings">The project instance creation settings</param>
-        /// <returns>the created project instance</returns>
+        /// <param name="settings">The project instance creation settings.</param>
+        /// <returns>the created project instance.</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings)
         {
             return CreateProjectInstance(settings, null);
         }
 
         /// <summary>
-        /// See <see cref="CreateProjectInstance(ProjectInstanceSettings)"/>
+        /// See <see cref="CreateProjectInstance(ProjectInstanceSettings)"/>.
         /// </summary>
-        /// <param name="settings">The project instance creation settings</param>
-        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
-        /// <returns>the created project instance</returns>
+        /// <param name="settings">The project instance creation settings.</param>
+        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
+        /// <returns>the created project instance.</returns>
         public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
         {
             return implementation.CreateProjectInstance(settings, evaluationContext);
@@ -1374,9 +1374,9 @@ public void ReevaluateIfNecessary()
         }
 
         /// <summary>
-        /// See <see cref="ReevaluateIfNecessary()"/>
+        /// See <see cref="ReevaluateIfNecessary()"/>.
         /// </summary>
-        /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/></param>
+        /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/>.</param>
         public void ReevaluateIfNecessary(EvaluationContext evaluationContext)
         {
             implementation.ReevaluateIfNecessary(evaluationContext);
@@ -1442,6 +1442,7 @@ public void SaveLogicalProject(TextWriter writer)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build()
         {
             return Build((string[])null);
@@ -1454,6 +1455,8 @@ public bool Build()
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="logger">Logger to use.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(ILogger logger)
         {
             var loggers = new List<ILogger>(1) { logger };
@@ -1467,6 +1470,8 @@ public bool Build(ILogger logger)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="loggers">List of loggers.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(IEnumerable<ILogger> loggers)
         {
             return Build((string[])null, loggers, null);
@@ -1479,6 +1484,9 @@ public bool Build(IEnumerable<ILogger> loggers)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             return Build((string[])null, loggers, remoteLoggers);
@@ -1491,6 +1499,8 @@ public bool Build(IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerReco
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="target">Target to build.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string target)
         {
             return Build(target, null, null);
@@ -1503,6 +1513,9 @@ public bool Build(string target)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="target">Target to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string target, IEnumerable<ILogger> loggers)
         {
             return Build(target, loggers, null);
@@ -1515,6 +1528,10 @@ public bool Build(string target, IEnumerable<ILogger> loggers)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="target">Target to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             // targets may be null, but not an entry within it
@@ -1530,6 +1547,8 @@ public bool Build(string target, IEnumerable<ILogger> loggers, IEnumerable<Forwa
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="targets">Targets to build.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets)
         {
             return Build(targets, null, null);
@@ -1543,6 +1562,9 @@ public bool Build(string[] targets)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="targets">Targets to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers)
         {
             return Build(targets, loggers, null);
@@ -1556,18 +1578,23 @@ public bool Build(string[] targets, IEnumerable<ILogger> loggers)
         /// virtual items for build purposes, clone an instance explicitly and build that.
         /// Does not modify the Project object.
         /// </summary>
+        /// <param name="targets">Targets to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
             return Build(targets, loggers, remoteLoggers, null);
         }
 
         /// <summary>
-        /// See <see cref="Build(string[], IEnumerable&lt;ILogger&gt;, IEnumerable&lt;ForwardingLoggerRecord&gt;)"/>
+        /// See <see cref="Build(string[], IEnumerable&lt;ILogger&gt;, IEnumerable&lt;ForwardingLoggerRecord&gt;)"/>.
         /// </summary>
-        /// <param name="targets"></param>
-        /// <param name="loggers"></param>
-        /// <param name="remoteLoggers"></param>
-        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+        /// <param name="targets">Targets to build.</param>
+        /// <param name="loggers">List of loggers.</param>
+        /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+        /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
+        /// <returns>Returns true on success and false on failure or disabled build.</returns>
         public bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
         {
             return implementation.Build(targets, loggers, remoteLoggers, evaluationContext);
@@ -1744,7 +1771,7 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
         }
 
         /// <summary>
-        /// Internal project evaluation implementation
+        /// Internal project evaluation implementation.
         /// </summary>
         private class ProjectImpl : ProjectLink, IProjectLinkInternal
         {
@@ -1799,13 +1826,13 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             /// <summary>
             ///
             /// </summary>
-            /// <param name="owner">The owning project object</param>
-            /// <param name="xml">ProjectRootElement to use</param>
+            /// <param name="owner">The owning project object.</param>
+            /// <param name="xml">ProjectRootElement to use.</param>
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-            /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+            /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
@@ -1823,13 +1850,13 @@ public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, st
             /// Throws InvalidProjectFileException if the evaluation fails.
             /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
             /// </summary>
-            /// <param name="owner">The owning project object</param>
-            /// <param name="xmlReader">Xml reader to read project from</param>
+            /// <param name="owner">The owning project object.</param>
+            /// <param name="xmlReader">Xml reader to read project from.</param>
             /// <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
-            /// <param name="toolsVersion">Tools version to evaluate with. May be null</param>
+            /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(xmlReader, nameof(xmlReader));
@@ -1858,13 +1885,13 @@ public ProjectImpl(Project owner, XmlReader xmlReader, IDictionary<string, strin
             /// Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
             /// May throw IO-related exceptions.
             /// </summary>
-            /// <param name="owner">The owning project object</param>
-            /// <param name="projectFile">The project file</param>
+            /// <param name="owner">The owning project object.</param>
+            /// <param name="projectFile">The project file.</param>
             /// <param name="globalProperties">The global properties. May be null.</param>
             /// <param name="toolsVersion">The tools version. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The load settings for this project.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public ProjectImpl(Project owner, string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
@@ -1956,7 +1983,7 @@ public bool IsZombified
 
             /// <summary>
             /// The backing Xml project.
-            /// Can never be null
+            /// Can never be null.
             /// </summary>
             /// <remarks>
             /// There is no setter here as that doesn't make sense. If you have a new ProjectRootElement, evaluate it into a new Project.
@@ -2064,7 +2091,7 @@ public override IDictionary<string, string> GlobalProperties
             /// </summary>
             /// <comments>
             /// data.ItemTypes is a KeyCollection, so it doesn't need any
-            /// additional read-only protection
+            /// additional read-only protection.
             /// </comments>
             public override ICollection<string> ItemTypes => _data.ItemTypes;
 
@@ -2106,12 +2133,12 @@ public override IDictionary<string, List<string>> ConditionedProperties
 
             /// <summary>
             /// Read-only dictionary of item definitions in this project.
-            /// Keyed by item type
+            /// Keyed by item type.
             /// </summary>
             public override IDictionary<string, ProjectItemDefinition> ItemDefinitions => _data.ItemDefinitions;
 
             /// <summary>
-            /// Items in this project, ordered within groups of item types
+            /// Items in this project, ordered within groups of item types.
             /// </summary>
             [SuppressMessage("Microsoft.Naming", "CA1721:PropertyNamesShouldNotMatchGetMethods", Justification = "This is a reasonable choice. API review approved")]
             public override ICollection<ProjectItem> Items => new ReadOnlyCollection<ProjectItem>(_data.Items);
@@ -2388,21 +2415,21 @@ public override bool IsBuildEnabled
             public override int LastEvaluationId => _data.EvaluationId;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable
+            /// List of names of the properties that, while global, are still treated as overridable.
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _data.GlobalPropertiesToTreatAsLocal;
 
             /// <summary>
-            /// The logging service used for evaluation errors
+            /// The logging service used for evaluation errors.
             /// </summary>
             internal ILoggingService LoggingService => ProjectCollection.LoggingService;
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetAllGlobs(EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetAllGlobs(EvaluationContext)"/>.
             /// </summary>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext)
             {
@@ -2410,12 +2437,12 @@ public override List<GlobResult> GetAllGlobs(EvaluationContext evaluationContext
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetAllGlobs(string, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetAllGlobs(string, EvaluationContext)"/>.
             /// </summary>
             /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluationContext)
             {
@@ -2591,12 +2618,12 @@ private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dict
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetItemProvenance(string, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetItemProvenance(string, EvaluationContext)"/>.
             /// </summary>
-            /// <param name="itemToMatch">The string to perform matching against</param>
+            /// <param name="itemToMatch">The string to perform matching against.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationContext evaluationContext)
             {
@@ -2604,13 +2631,13 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, Eva
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetItemProvenance(string, string, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetItemProvenance(string, string, EvaluationContext)"/>.
             /// </summary>
-            /// <param name="itemToMatch">The string to perform matching against</param>
+            /// <param name="itemToMatch">The string to perform matching against.</param>
             /// <param name="itemType">The type of items to return.</param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, EvaluationContext evaluationContext)
             {
@@ -2618,7 +2645,7 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, str
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.GetItemProvenance(ProjectItem, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.GetItemProvenance(ProjectItem, EvaluationContext)"/>.
             /// </summary>
             /// /// <param name="item"> 
             /// The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
@@ -2627,7 +2654,7 @@ public override List<ProvenanceResult> GetItemProvenance(string itemToMatch, str
             /// </param>
             /// <param name="evaluationContext">
             ///     The evaluation context to use in case reevaluation is required.
-            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>
+            ///     To avoid reevaluation use <see cref="ProjectLoadSettings.RecordEvaluatedItemElements"/>.
             /// </param>
             public override List<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationContext evaluationContext)
             {
@@ -2721,6 +2748,13 @@ ProvenanceResult SingleItemSpecProvenance(string itemSpec, IElementLocation elem
                     SingleItemSpecProvenance(itemElement.Exclude, itemElement.ExcludeLocation, Operation.Exclude) ?? result;
             }
 
+            /// <summary>
+            /// Since:
+            ///     - we have no proper AST and interpreter for itemspecs that we can do analysis on
+            ///     - GetItemProvenance needs to have correct counts for exclude strings (as correct as it can get while doing it after evaluation)
+            ///
+            /// The temporary hack is to use the expander to expand the strings, and if any property or item references were encountered, return Provenance.Inconclusive.
+            /// </summary>
             private static int ItemMatchesInItemSpec(string itemToMatch, EvaluationItemSpec itemSpec, out Provenance provenance)
             {
                 provenance = Provenance.Undefined;
@@ -2790,7 +2824,7 @@ public override IEnumerable<ProjectElement> GetLogicalProject()
 
             /// <summary>
             /// Get any property in the project that has the specified name,
-            /// otherwise returns null
+            /// otherwise returns null.
             /// </summary>
             [DebuggerStepThrough]
             public override ProjectProperty GetProperty(string name)
@@ -3170,10 +3204,10 @@ public override string ExpandString(string unexpandedValue)
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.CreateProjectInstance(ProjectInstanceSettings, EvaluationContext)"/>
+            /// See <see cref="ProjectLink.CreateProjectInstance(ProjectInstanceSettings, EvaluationContext)"/>.
             /// </summary>
-            /// <param name="settings">Project instance creation settings</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="settings">Project instance creation settings.</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             /// <returns></returns>
             public override ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext)
             {
@@ -3201,9 +3235,9 @@ public override void MarkDirty()
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.ReevaluateIfNecessary"/>
+            /// See <see cref="ProjectLink.ReevaluateIfNecessary"/>.
             /// </summary>
-            /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/></param>
+            /// <param name="evaluationContext">The <see cref="EvaluationContext"/> to use. See <see cref="EvaluationContext"/>.</param>
             public override void ReevaluateIfNecessary(EvaluationContext evaluationContext)
             {
                 ReevaluateIfNecessary(LoggingService, evaluationContext);
@@ -3225,12 +3259,12 @@ public override void SaveLogicalProject(TextWriter writer)
             }
 
             /// <summary>
-            /// See <see cref="ProjectLink.Build"/>
+            /// See <see cref="ProjectLink.Build"/>.
             /// </summary>
-            /// <param name="targets">targets to build</param>
-            /// <param name="loggers">List of loggers</param>
-            /// <param name="remoteLoggers">remote loggers for multi proc logging</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
+            /// <param name="targets">Targets to build.</param>
+            /// <param name="loggers">List of loggers.</param>
+            /// <param name="remoteLoggers">Remote loggers for multi proc logging.</param>
+            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
             public override bool Build(string[] targets, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext)
             {
                 if (!IsBuildEnabled)
@@ -3897,7 +3931,7 @@ internal class Data : IItemProvider<ProjectItem>, IPropertyProvider<ProjectPrope
             private static WeakReference<RetrievableEntryHashSet<ProjectTargetInstance>> s_typicalTargetsCollection;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable
+            /// List of names of the properties that, while global, are still treated as overridable.
             /// </summary>
             private ISet<string> _globalPropertiesToTreatAsLocal;
 
@@ -3917,14 +3951,14 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Whether evaluation should collect items ignoring condition,
             /// as well as items respecting condition; and collect
-            /// conditioned properties, as well as regular properties
+            /// conditioned properties, as well as regular properties.
             /// </summary>
             public bool ShouldEvaluateForDesignTime => true;
 
             public bool CanEvaluateElementsWithFalseConditions { get; }
 
             /// <summary>
-            /// Collection of all evaluated item definitions, one per item-type
+            /// Collection of all evaluated item definitions, one per item-type.
             /// </summary>
             IEnumerable<ProjectItemDefinition> IEvaluatorData<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.ItemDefinitionsEnumerable => ItemDefinitions.Values;
 
@@ -3948,7 +3982,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => this.Project.ProjectCollection.EnvironmentProperties;
 
             /// <summary>
-            /// List of names of the properties that, while global, are still treated as overridable
+            /// List of names of the properties that, while global, are still treated as overridable.
             /// </summary>
             public ISet<string> GlobalPropertiesToTreatAsLocal => _globalPropertiesToTreatAsLocal ?? (_globalPropertiesToTreatAsLocal =
                                                                       new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default));
@@ -4040,12 +4074,12 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             public int EvaluationId { get; set; } = BuildEventContext.InvalidEvaluationId;
 
             /// <summary>
-            /// The root directory for this project
+            /// The root directory for this project.
             /// </summary>
             public string Directory => Project.DirectoryPath;
 
             /// <summary>
-            /// Registry of usingtasks, for build
+            /// Registry of usingtasks, for build.
             /// </summary>
             public TaskRegistry TaskRegistry { get; set; }
 
@@ -4055,7 +4089,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// </summary>
             /// <comments>
             /// item.ItemTypes is a KeyCollection, so it doesn't need any
-            /// additional read-only protection
+            /// additional read-only protection.
             /// </comments>
             public ICollection<string> ItemTypes => Items.ItemTypes;
 
@@ -4099,17 +4133,17 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             internal bool HasUnsavedChanges { get; set; }
 
             /// <summary>
-            /// Collection of all evaluated item definitions, one per item-type
+            /// Collection of all evaluated item definitions, one per item-type.
             /// </summary>
             internal RetrievableEntryHashSet<ProjectItemDefinition> ItemDefinitions { get; private set; }
 
             /// <summary>
-            /// Project that owns this data
+            /// Project that owns this data.
             /// </summary>
             internal Project Project { get; }
 
             /// <summary>
-            /// Targets in the project, used to build
+            /// Targets in the project, used to build.
             /// </summary>
             internal RetrievableEntryHashSet<ProjectTargetInstance> Targets { get; set; }
 
@@ -4126,7 +4160,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             internal List<ResolvedImport> ImportClosureWithDuplicates { get; private set; }
 
             /// <summary>
-            /// The toolsversion that was originally specified on the project's root element
+            /// The toolsversion that was originally specified on the project's root element.
             /// </summary>
             internal string OriginalProjectToolsVersion { get; private set; }
 
@@ -4254,7 +4288,7 @@ public void AddItem(ProjectItem item)
             }
 
             /// <summary>
-            /// Adds a new item to the collection of all items ignoring condition
+            /// Adds a new item to the collection of all items ignoring condition.
             /// </summary>
             public void AddItemIgnoringCondition(ProjectItem item)
             {
@@ -4298,7 +4332,7 @@ public void AddToAllEvaluatedItemsList(ProjectItem item)
             }
 
             /// <summary>
-            /// Adds a new item definition
+            /// Adds a new item definition.
             /// </summary>
             public IItemDefinition<ProjectMetadata> AddItemDefinition(string itemType)
             {
@@ -4438,7 +4472,7 @@ public ICollection<ProjectItem> GetItems(string itemType)
             #region IPropertyProvider<ProjectProperty> Members
 
             /// <summary>
-            /// Returns the property with the specified name or null if it was not present
+            /// Returns the property with the specified name or null if it was not present.
             /// </summary>
             /// <param name="name">The property name.</param>
             /// <returns>The property.</returns>
@@ -4448,7 +4482,7 @@ public ProjectProperty GetProperty(string name)
             }
 
             /// <summary>
-            /// Returns the property with the specified name or null if it was not present
+            /// Returns the property with the specified name or null if it was not present.
             /// </summary>
             /// <returns>The property.</returns>
             public ProjectProperty GetProperty(string name, int startIndex, int endIndex)
@@ -4549,7 +4583,7 @@ public class GlobResult
         public IEnumerable<string> Removes { get; set; }
 
         /// <summary>
-        /// Constructor
+        /// Constructor.
         /// </summary>
         public GlobResult(ProjectItemElement itemElement, IEnumerable<string> includeGlobStrings, IMSBuildGlob globWithGaps, IEnumerable<string> excludeFragmentStrings, IEnumerable<string> removeFragmentStrings)
         {
@@ -4591,7 +4625,7 @@ public enum Provenance
     }
 
     /// <summary>
-    /// Enum that specifies how an item element references an item
+    /// Enum that specifies how an item element references an item.
     /// </summary>
     public enum Operation
     {
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 4322d3fcaa2..cdbc45e9f47 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -118,7 +118,7 @@ internal enum ExpanderOptions
     /// Requires the caller to have previously provided the necessary material for the expansion requested.
     /// For example, if the caller requests ExpanderOptions.ExpandItems, the Expander will throw if it was not given items.
     /// </remarks>
-    /// <typeparam name="P">Type of the properties used</typeparam>
+    /// <typeparam name="P">Type of the properties used.</typeparam>
     /// <typeparam name="I">Type of the items used.</typeparam>
     internal class Expander<P, I>
         where P : class, IProperty
@@ -140,7 +140,7 @@ internal class Expander<P, I>
 
         /// <summary>
         /// Those characters which indicate that an expression may contain expandable
-        /// expressions
+        /// expressions.
         /// </summary>
         private static char[] s_expandableChars = { '$', '%', '@' };
 
@@ -151,22 +151,22 @@ internal class Expander<P, I>
         private static CompareInfo s_invariantCompareInfo = CultureInfo.InvariantCulture.CompareInfo;
 
         /// <summary>
-        /// Properties to draw on for expansion
+        /// Properties to draw on for expansion.
         /// </summary>
         private IPropertyProvider<P> _properties;
 
         /// <summary>
-        /// Items to draw on for expansion
+        /// Items to draw on for expansion.
         /// </summary>
         private IItemProvider<I> _items;
 
         /// <summary>
-        /// Metadata to draw on for expansion
+        /// Metadata to draw on for expansion.
         /// </summary>
         private IMetadataTable _metadata;
 
         /// <summary>
-        /// Set of properties which are null during expansion
+        /// Set of properties which are null during expansion.
         /// </summary>
         private UsedUninitializedProperties _usedUninitializedProperties;
 
@@ -235,7 +235,7 @@ internal UsedUninitializedProperties UsedUninitializedProperties
 
         /// <summary>
         /// Tests to see if the expression may contain expandable expressions, i.e.
-        /// contains $, % or @
+        /// contains $, % or @.
         /// </summary>
         internal static bool ExpressionMayContainExpandableExpressions(string expression)
         {
@@ -292,7 +292,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
 
         /// <summary>
         /// Used only for unit tests. Expands the property expression (including any metadata expressions) and returns
-        /// the result typed (i.e. not converted into a string if the result is a function return)
+        /// the result typed (i.e. not converted into a string if the result is a function return).
         /// </summary>
         internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
@@ -340,7 +340,7 @@ internal IList<TaskItem> ExpandIntoTaskItemsLeaveEscaped(string expression, Expa
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
-        /// <typeparam name="T">Type of items to return</typeparam>
+        /// <typeparam name="T">Type of items to return.</typeparam>
         internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory<I, T> itemFactory, ExpanderOptions options, IElementLocation elementLocation)
             where T : class, IItem
         {
@@ -413,7 +413,7 @@ internal IList<T> ExpandIntoItemsLeaveEscaped<T>(string expression, IItemFactory
         /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
         /// have an item type set on it, it will be given the item type of the item vector to use.
         /// </summary>
-        /// <typeparam name="T">Type of the items that should be returned</typeparam>
+        /// <typeparam name="T">Type of the items that should be returned.</typeparam>
         internal IList<T> ExpandSingleItemVectorExpressionIntoItems<T>(string expression, IItemFactory<I, T> itemFactory, ExpanderOptions options, bool includeNullItems, out bool isTransformExpression, IElementLocation elementLocation)
             where T : class, IItem
         {
@@ -456,7 +456,7 @@ internal bool ExpandExpressionCapture(
         }
 
         /// <summary>
-        /// Returns true if the supplied string contains a valid property name
+        /// Returns true if the supplied string contains a valid property name.
         /// </summary>
         private static bool IsValidPropertyName(string propertyName)
         {
@@ -477,7 +477,7 @@ private static bool IsValidPropertyName(string propertyName)
         }
 
         /// <summary>
-        /// Returns true if ExpanderOptions.Truncate is set and EscapeHatches.DoNotTruncateConditions is not set
+        /// Returns true if ExpanderOptions.Truncate is set and EscapeHatches.DoNotTruncateConditions is not set.
         /// </summary>
         private static bool IsTruncationEnabled(ExpanderOptions options)
         {
@@ -503,7 +503,7 @@ private static int ScanForClosingParenthesis(string expression, int index)
         /// Takes the expression and the index to start at.
         /// Returns the index of the matching parenthesis, or -1 if it was not found.
         /// Also returns flags to indicate if a propertyfunction or registry property is likely
-        /// to be found in the expression
+        /// to be found in the expression.
         /// </summary>
         private static int ScanForClosingParenthesis(string expression, int index, out bool potentialPropertyFunction, out bool potentialRegistryFunction)
         {
@@ -561,7 +561,7 @@ private static int ScanForClosingParenthesis(string expression, int index, out b
         }
 
         /// <summary>
-        /// Skip all characters until we find the matching quote character
+        /// Skip all characters until we find the matching quote character.
         /// </summary>
         private static int ScanForClosingQuote(char quoteChar, string expression, int index)
         {
@@ -587,7 +587,7 @@ private static int ScanForClosingQuote(char quoteChar, string expression, int in
 
         /// <summary>
         /// Add the argument in the StringBuilder to the arguments list, handling nulls
-        /// appropriately
+        /// appropriately.
         /// </summary>
         private static void AddArgument(List<string> arguments, ReuseableStringBuilder argumentBuilder)
         {
@@ -722,12 +722,12 @@ private static class MetadataExpander
         {
             /// <summary>
             /// Expands all embedded item metadata in the given string, using the bucketed items.
-            /// Metadata may be qualified, like %(Compile.WarningLevel), or unqualified, like %(Compile)
+            /// Metadata may be qualified, like %(Compile.WarningLevel), or unqualified, like %(Compile).
             /// </summary>
-            /// <param name="expression">The expression containing item metadata references</param>
-            /// <param name="metadata"></param>
-            /// <param name="options"></param>
-            /// <param name="elementLocation"></param>
+            /// <param name="expression">The expression containing item metadata references.</param>
+            /// <param name="metadata">The metadata to be expanded.</param>
+            /// <param name="options">Used to specify what to expand.</param>
+            /// <param name="elementLocation">The location information for error reporting purposes.</param>
             /// <returns>The string with item metadata expanded in-place, escaped.</returns>
             internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTable metadata, ExpanderOptions options, IElementLocation elementLocation)
             {
@@ -848,7 +848,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
             private class MetadataMatchEvaluator
             {
                 /// <summary>
-                /// Source of the metadata
+                /// Source of the metadata.
                 /// </summary>
                 private IMetadataTable _metadata;
 
@@ -858,7 +858,7 @@ private class MetadataMatchEvaluator
                 private ExpanderOptions _options;
 
                 /// <summary>
-                /// Constructor taking a source of metadata
+                /// Constructor taking a source of metadata.
                 /// </summary>
                 internal MetadataMatchEvaluator(IMetadataTable metadata, ExpanderOptions options)
                 {
@@ -907,13 +907,13 @@ internal string ExpandSingleMetadata(Match itemMetadataMatch)
         }
 
         /// <summary>
-        /// Expands property expressions, like $(Configuration) and $(Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation)
+        /// Expands property expressions, like $(Configuration) and $(Registry:HKEY_LOCAL_MACHINE\Software\Vendor\Tools@TaskLocation).
         /// </summary>
         /// <remarks>
         /// This is a private nested class, exposed only through the Expander class.
         /// That allows it to hide its private methods even from Expander.
         /// </remarks>
-        /// <typeparam name="T">Type of the properties used to expand the expression</typeparam>
+        /// <typeparam name="T">Type of the properties used to expand the expression.</typeparam>
         private static class PropertyExpander<T>
             where T : class, IProperty
         {
@@ -1184,7 +1184,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
             }
 
             /// <summary>
-            /// Expand the body of the property, including any functions that it may contain
+            /// Expand the body of the property, including any functions that it may contain.
             /// </summary>
             internal static object ExpandPropertyBody(
                 string propertyBody,
@@ -1304,7 +1304,7 @@ internal static object ExpandPropertyBody(
             /// <summary>
             /// Convert the object into an MSBuild friendly string
             /// Arrays are supported.
-            /// Will not return NULL
+            /// Will not return NULL.
             /// </summary>
             internal static string ConvertToString(object valueToConvert)
             {
@@ -1379,7 +1379,7 @@ internal static string ConvertToString(object valueToConvert)
             }
 
             /// <summary>
-            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo)
+            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
             {
@@ -1387,7 +1387,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
             }
 
             /// <summary>
-            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo)
+            /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
             private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
             {
@@ -1629,7 +1629,7 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
         /// 
         ///     "my list: @(files -> 'temp\%(Filename).xml', ' ')   expands to string      "my list: temp\a.xml temp\b.xml"
         /// 
-        ///     "my list: @(files->'')                              expands to string      "my list: ;"
+        ///     "my list: @(files->'')                              expands to string      "my list: ;".
         /// </summary>
         /// <remarks>
         /// This is a private nested class, exposed only through the Expander class.
@@ -1638,9 +1638,9 @@ private static string ExpandRegistryValue(string registryExpression, IElementLoc
         private static class ItemExpander
         {
             /// <summary>
-            /// Execute the list of transform functions
+            /// Execute the list of transform functions.
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expander, bool includeNullEntries, Stack<TransformFunction<S>> transformFunctionStack, IEnumerable<Pair<string, S>> itemsOfType)
                 where S : class, IItem
             {
@@ -1687,8 +1687,8 @@ internal static IEnumerable<Pair<string, S>> Transform<S>(Expander<P, I> expande
             /// Item type of the items returned is determined by the IItemFactory passed in; if the IItemFactory does not 
             /// have an item type set on it, it will be given the item type of the item vector to use.
             /// </summary>
-            /// <typeparam name="S">Type of the items provided by the item source used for expansion</typeparam>
-            /// <typeparam name="T">Type of the items that should be returned</typeparam>
+            /// <typeparam name="S">Type of the items provided by the item source used for expansion.</typeparam>
+            /// <typeparam name="T">Type of the items that should be returned.</typeparam>
             internal static IList<T> ExpandSingleItemVectorExpressionIntoItems<S, T>(
                     Expander<P, I> expander, string expression, IItemProvider<S> items, IItemFactory<S, T> itemFactory, ExpanderOptions options,
                     bool includeNullEntries, out bool isTransformExpression, IElementLocation elementLocation)
@@ -1843,15 +1843,15 @@ internal static IList<T> ExpandExpressionCaptureIntoItems<S, T>(
             /// Item1 represents the item string, escaped
             /// Item2 represents the original item.
             /// 
-            /// Item1 differs from Item2's string when it is coming from a transform
+            /// Item1 differs from Item2's string when it is coming from a transform.
             /// 
             /// </param>
-            /// <param name="expander">The expander whose state will be used to expand any transforms</param>
-            /// <param name="expressionCapture">The <see cref="ExpandSingleItemVectorExpressionIntoExpressionCapture"/> representing the structure of an item expression</param>
-            /// <param name="evaluatedItems"><see cref="IItemProvider{T}"/> to provide the inital items (which may get subsequently transformed, if <paramref name="expressionCapture"/> is a transform expression)></param>
-            /// <param name="elementLocation">Location of the xml element containing the <paramref name="expressionCapture"/></param>
-            /// <param name="options">expander options</param>
-            /// <param name="includeNullEntries">Wether to include items that evaluated to empty / null</param>
+            /// <param name="expander">The expander whose state will be used to expand any transforms.</param>
+            /// <param name="expressionCapture">The <see cref="ExpandSingleItemVectorExpressionIntoExpressionCapture"/> representing the structure of an item expression.</param>
+            /// <param name="evaluatedItems"><see cref="IItemProvider{T}"/> to provide the inital items (which may get subsequently transformed, if <paramref name="expressionCapture"/> is a transform expression)>.</param>
+            /// <param name="elementLocation">Location of the xml element containing the <paramref name="expressionCapture"/>.</param>
+            /// <param name="options">expander options.</param>
+            /// <param name="includeNullEntries">Wether to include items that evaluated to empty / null.</param>
             internal static bool ExpandExpressionCapture<S>(
                 Expander<P, I> expander,
                 ExpressionShredder.ItemExpressionCapture expressionCapture,
@@ -1934,7 +1934,7 @@ out List<Pair<string, S>> itemsFromCapture
             /// If the expression is empty, returns empty string.
             /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
             /// </summary>
-            /// <typeparam name="T">Type of the items provided</typeparam>
+            /// <typeparam name="T">Type of the items provided.</typeparam>
             internal static string ExpandItemVectorsIntoString<T>(Expander<P, I> expander, string expression, IItemProvider<T> items, ExpanderOptions options, IElementLocation elementLocation)
                 where T : class, IItem
             {
@@ -1987,9 +1987,9 @@ internal static string ExpandItemVectorsIntoString<T>(Expander<P, I> expander, s
             }
 
             /// <summary>
-            /// Prepare the stack of transforms that will be executed on a given set of items
+            /// Prepare the stack of transforms that will be executed on a given set of items.
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             private static Stack<TransformFunction<S>> PrepareTransformStackFromMatch<S>(IElementLocation elementLocation, ExpressionShredder.ItemExpressionCapture match)
                 where S : class, IItem
             {
@@ -2033,7 +2033,7 @@ private static Stack<TransformFunction<S>> PrepareTransformStackFromMatch<S>(IEl
             /// Expand the match provided into a string, and append that to the provided string builder.
             /// Returns true if ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and so it broke out early.
             /// </summary>
-            /// <typeparam name="S">Type of source items</typeparam>
+            /// <typeparam name="S">Type of source items.</typeparam>
             private static bool ExpandExpressionCaptureIntoStringBuilder<S>(
                 Expander<P, I> expander,
                 ExpressionShredder.ItemExpressionCapture capture,
@@ -2068,7 +2068,7 @@ ExpanderOptions options
                             return false;
                         }
                         int currentLength = builder.Length - startLength;
-                        if (currentLength + item.Key.Length > CharacterLimitPerExpansion)
+                        if (!string.IsNullOrEmpty(item.Key) && currentLength + item.Key.Length > CharacterLimitPerExpansion)
                         {
                             int truncateIndex = CharacterLimitPerExpansion - currentLength - 3;
                             if (truncateIndex > 0)
@@ -2091,26 +2091,26 @@ ExpanderOptions options
             }
 
             /// <summary>
-            /// The set of functions that called during an item transformation, e.g. @(CLCompile->ContainsMetadata('MetaName', 'metaValue'))
+            /// The set of functions that called during an item transformation, e.g. @(CLCompile->ContainsMetadata('MetaName', 'metaValue')).
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             internal static class IntrinsicItemFunctions<S>
                 where S : class, IItem
             {
                 /// <summary>
-                /// A cache of previously created item function delegates
+                /// A cache of previously created item function delegates.
                 /// </summary>
                 private static ConcurrentDictionary<string, ItemTransformFunction> s_transformFunctionDelegateCache = new ConcurrentDictionary<string, ItemTransformFunction>(StringComparer.OrdinalIgnoreCase);
 
                 /// <summary>
                 /// Delegate that represents the signature of all item transformation functions
-                /// This is used to support calling the functions by name
+                /// This is used to support calling the functions by name.
                 /// </summary>
                 public delegate IEnumerable<Pair<string, S>> ItemTransformFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments);
 
                 /// <summary>
                 /// Get a delegate to the given item transformation function by supplying the name and the
-                /// Item type that should be used
+                /// Item type that should be used.
                 /// </summary>
                 internal static ItemTransformFunction GetItemTransformFunction(IElementLocation elementLocation, string functionName, Type itemType)
                 {
@@ -2167,7 +2167,7 @@ internal static ItemTransformFunction GetItemTransformFunction(IElementLocation
 
                 /// <summary>
                 /// Create an enumerator from a base IEnumerable of items into an enumerable
-                /// of transformation result which includes the new itemspec and the base item
+                /// of transformation result which includes the new itemspec and the base item.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S> itemsOfType)
                 {
@@ -2194,7 +2194,7 @@ var resultantItem in
                 }
 
                 /// <summary>
-                /// Intrinsic function that returns the number of items in the list
+                /// Intrinsic function that returns the number of items in the list.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Count(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2203,7 +2203,7 @@ internal static IEnumerable<Pair<string, S>> Count(Expander<P, I> expander, IEle
 
                 /// <summary>
                 /// Intrinsic function that returns the specified built-in modifer value of the items in itemsOfType
-                /// Tuple is {current item include, item under transformation}
+                /// Tuple is {current item include, item under transformation}.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ItemSpecModifierFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2470,7 +2470,7 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                 }
 
                 /// <summary>
-                /// Intrinsic function that returns the contents of the metadata in specified in argument[0]
+                /// Intrinsic function that returns the contents of the metadata in specified in argument[0].
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2527,7 +2527,7 @@ internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, I
 
                 /// <summary>
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
-                /// Using a case sensitive comparison
+                /// Using a case sensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2536,7 +2536,7 @@ internal static IEnumerable<Pair<string, S>> DistinctWithCase(Expander<P, I> exp
 
                 /// <summary>
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2545,7 +2545,7 @@ internal static IEnumerable<Pair<string, S>> Distinct(Expander<P, I> expander, I
 
                 /// <summary>
                 /// Intrinsic function that returns only the items from itemsOfType that have distinct Item1 in the Tuple
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> DistinctWithComparer(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments, StringComparer comparer)
                 {
@@ -2578,7 +2578,7 @@ internal static IEnumerable<Pair<string, S>> Reverse(Expander<P, I> expander, IE
                 }
 
                 /// <summary>
-                /// Intrinsic function that transforms expressions like the %(foo) in @(Compile->'%(foo)')
+                /// Intrinsic function that transforms expressions like the %(foo) in @(Compile->'%(foo)').
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2618,7 +2618,7 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
 
                 /// <summary>
                 /// Intrinsic function that transforms expressions by invoking methods of System.String on the itemspec
-                /// of the item in the pipeline
+                /// of the item in the pipeline.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                     Expander<P, I> expander,
@@ -2660,7 +2660,7 @@ internal static IEnumerable<Pair<string, S>> ExecuteStringFunction(
                 }
 
                 /// <summary>
-                /// Intrinsic function that returns the items from itemsOfType with their metadata cleared, i.e. only the itemspec is retained
+                /// Intrinsic function that returns the items from itemsOfType with their metadata cleared, i.e. only the itemspec is retained.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2677,7 +2677,7 @@ internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expand
 
                 /// <summary>
                 /// Intrinsic function that returns only those items that have a not-blank value for the metadata specified
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2714,7 +2714,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
 
                 /// <summary>
                 /// Intrinsic function that returns only those items have the given metadata value
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2750,7 +2750,7 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
 
                 /// <summary>
                 /// Intrinsic function that returns a boolean to indicate if any of the items have the given metadata value
-                /// Using a case insensitive comparison
+                /// Using a case insensitive comparison.
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
@@ -2801,34 +2801,34 @@ internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I>
             }
 
             /// <summary>
-            /// Represents all the components of a transform function, including the ability to execute it 
+            /// Represents all the components of a transform function, including the ability to execute it. 
             /// </summary>
-            /// <typeparam name="S">class, IItem</typeparam>
+            /// <typeparam name="S">class, IItem.</typeparam>
             internal class TransformFunction<S>
                 where S : class, IItem
             {
                 /// <summary>
-                /// The delegate that points to the transform function
+                /// The delegate that points to the transform function.
                 /// </summary>
                 private IntrinsicItemFunctions<S>.ItemTransformFunction _transform;
 
                 /// <summary>
-                /// Arguments to pass to the transform function as parsed out of the project file
+                /// Arguments to pass to the transform function as parsed out of the project file.
                 /// </summary>
                 private string[] _arguments;
 
                 /// <summary>
-                /// The element location of the transform expression
+                /// The element location of the transform expression.
                 /// </summary>
                 private IElementLocation _elementLocation;
 
                 /// <summary>
-                /// The name of the function that this class will call
+                /// The name of the function that this class will call.
                 /// </summary>
                 private string _functionName;
 
                 /// <summary>
-                /// TransformFunction constructor
+                /// TransformFunction constructor.
                 /// </summary>
                 public TransformFunction(IElementLocation elementLocation, string functionName, IntrinsicItemFunctions<S>.ItemTransformFunction transform, string[] arguments)
                 {
@@ -2839,7 +2839,7 @@ public TransformFunction(IElementLocation elementLocation, string functionName,
                 }
 
                 /// <summary>
-                /// Arguments to pass to the transform function as parsed out of the project file
+                /// Arguments to pass to the transform function as parsed out of the project file.
                 /// </summary>
                 public string[] Arguments
                 {
@@ -2847,7 +2847,7 @@ public string[] Arguments
                 }
 
                 /// <summary>
-                /// The element location of the transform expression
+                /// The element location of the transform expression.
                 /// </summary>
                 public IElementLocation ElementLocation
                 {
@@ -2855,7 +2855,7 @@ public IElementLocation ElementLocation
                 }
 
                 /// <summary>
-                /// Execute this transform function with the arguments contained within this TransformFunction instance
+                /// Execute this transform function with the arguments contained within this TransformFunction instance.
                 /// </summary>
                 public IEnumerable<Pair<string, S>> Execute(Expander<P, I> expander, bool includeNullEntries, IEnumerable<Pair<string, S>> itemsOfType)
                 {
@@ -2871,22 +2871,22 @@ public IEnumerable<Pair<string, S>> Execute(Expander<P, I> expander, bool includ
             private class MetadataMatchEvaluator
             {
                 /// <summary>
-                /// The current ItemSpec of the item being matched
+                /// The current ItemSpec of the item being matched.
                 /// </summary>
                 private string _itemSpec;
 
                 /// <summary>
-                /// Item used as the source of metadata
+                /// Item used as the source of metadata.
                 /// </summary>
                 private IItem _sourceOfMetadata;
 
                 /// <summary>
-                /// Location of the match
+                /// Location of the match.
                 /// </summary>
                 private IElementLocation _elementLocation;
 
                 /// <summary>
-                /// Constructor
+                /// Constructor.
                 /// </summary>
                 internal MetadataMatchEvaluator(string itemSpec, IItem sourceOfMetadata, IElementLocation elementLocation)
                 {
@@ -2898,7 +2898,7 @@ internal MetadataMatchEvaluator(string itemSpec, IItem sourceOfMetadata, IElemen
                 /// <summary>
                 /// Expands the metadata in the match provided into a string result.
                 /// The match is expected to be the content of a transform.
-                /// For example, representing "%(Filename.obj)" in the original expression "@(Compile->'%(Filename.obj)')"
+                /// For example, representing "%(Filename.obj)" in the original expression "@(Compile->'%(Filename.obj)')".
                 /// </summary>
                 internal string GetMetadataValueFromMatch(Match match)
                 {
@@ -2959,7 +2959,7 @@ private static class RegularExpressions
             internal const string NameGroup = "NAME";
 
             /// <summary>
-            /// Name of the group matching the prefix on a metadata expression, for example "Compile." in "%(Compile.Object)"
+            /// Name of the group matching the prefix on a metadata expression, for example "Compile." in "%(Compile.Object)".
             /// </summary>
             internal const string ItemSpecificationGroup = "ITEM_SPECIFICATION";
 
@@ -2969,9 +2969,9 @@ private static class RegularExpressions
             internal const string ItemTypeGroup = "ITEM_TYPE";
 
             /// <summary>
-            /// regular expression used to match item metadata references outside of item vector transforms
+            /// regular expression used to match item metadata references outside of item vector transforms.
             /// </summary>
-            /// <remarks>PERF WARNING: this Regex is complex and tends to run slowly</remarks>
+            /// <remarks>PERF WARNING: this Regex is complex and tends to run slowly.</remarks>
             internal static readonly Lazy<Regex> NonTransformItemMetadataPattern = new Lazy<Regex>(
                 () => new Regex
                     (
@@ -2990,12 +2990,12 @@ private static class RegularExpressions
             private const string ItemMetadataSpecification = @"%\(\s* (?<ITEM_SPECIFICATION>(?<ITEM_TYPE>" + ProjectWriter.itemTypeOrMetadataNameSpecification + @")\s*\.\s*)? (?<NAME>" + ProjectWriter.itemTypeOrMetadataNameSpecification + @") \s*\)";
 
             /// <summary>
-            /// description of an item vector with a transform, left hand side 
+            /// description of an item vector with a transform, left hand side. 
             /// </summary> 
             private const string ItemVectorWithTransformLHS = @"@\(\s*" + ProjectWriter.itemTypeOrMetadataNameSpecification + @"\s*->\s*'[^']*";
 
             /// <summary>
-            /// description of an item vector with a transform, right hand side 
+            /// description of an item vector with a transform, right hand side. 
             /// </summary> 
             private const string ItemVectorWithTransformRHS = @"[^']*'(\s*,\s*'[^']*')?\s*\)";
 
@@ -3008,37 +3008,37 @@ private struct FunctionBuilder<T>
             where T : class, IProperty
         {
             /// <summary>
-            /// The type of this function's receiver
+            /// The type of this function's receiver.
             /// </summary>
             public Type ReceiverType { get; set; }
 
             /// <summary>
-            /// The name of the function
+            /// The name of the function.
             /// </summary>
             public string Name { get; set; }
 
             /// <summary>
-            /// The arguments for the function
+            /// The arguments for the function.
             /// </summary>
             public string[] Arguments { get; set; }
 
             /// <summary>
-            /// The expression that this function is part of
+            /// The expression that this function is part of.
             /// </summary>
             public string Expression { get; set; }
 
             /// <summary>
-            /// The property name that this function is applied on
+            /// The property name that this function is applied on.
             /// </summary>
             public string Receiver { get; set; }
 
             /// <summary>
-            /// The binding flags that will be used during invocation of this function
+            /// The binding flags that will be used during invocation of this function.
             /// </summary>
             public BindingFlags BindingFlags { get; set; }
 
             /// <summary>
-            /// The remainder of the body once the function and arguments have been extracted
+            /// The remainder of the body once the function and arguments have been extracted.
             /// </summary>
             public string Remainder { get; set; }
 
@@ -3067,44 +3067,44 @@ internal Function<T> Build()
 
         /// <summary>
         /// This class represents the function as extracted from an expression
-        /// It is also responsible for executing the function
+        /// It is also responsible for executing the function.
         /// </summary>
-        /// <typeparam name="T">Type of the properties used to expand the expression</typeparam>
+        /// <typeparam name="T">Type of the properties used to expand the expression.</typeparam>
         private class Function<T>
             where T : class, IProperty
         {
             /// <summary>
-            /// The type of this function's receiver
+            /// The type of this function's receiver.
             /// </summary>
             private Type _receiverType;
 
             /// <summary>
-            /// The name of the function
+            /// The name of the function.
             /// </summary>
             private string _methodMethodName;
 
             /// <summary>
-            /// The arguments for the function
+            /// The arguments for the function.
             /// </summary>
             private string[] _arguments;
 
             /// <summary>
-            /// The expression that this function is part of
+            /// The expression that this function is part of.
             /// </summary>
             private string _expression;
 
             /// <summary>
-            /// The property name that this function is applied on
+            /// The property name that this function is applied on.
             /// </summary>
             private string _receiver;
 
             /// <summary>
-            /// The binding flags that will be used during invocation of this function
+            /// The binding flags that will be used during invocation of this function.
             /// </summary>
             private BindingFlags _bindingFlags;
 
             /// <summary>
-            /// The remainder of the body once the function and arguments have been extracted
+            /// The remainder of the body once the function and arguments have been extracted.
             /// </summary>
             private string _remainder;
 
@@ -3116,7 +3116,7 @@ private class Function<T>
             private IFileSystem _fileSystem;
 
             /// <summary>
-            /// Construct a function that will be executed during property evaluation
+            /// Construct a function that will be executed during property evaluation.
             /// </summary>
             internal Function(
                 Type receiverType,
@@ -3153,7 +3153,7 @@ internal Function(
             /// This accessor is used by the Expander
             /// Examples of expression root:
             ///     [System.Diagnostics.Process]::Start
-            ///     SomeMSBuildProperty
+            ///     SomeMSBuildProperty.
             /// </summary>
             internal string Receiver
             {
@@ -3161,7 +3161,7 @@ internal string Receiver
             }
 
             /// <summary>
-            /// Extract the function details from the given property function expression
+            /// Extract the function details from the given property function expression.
             /// </summary>
             internal static Function<T> ExtractPropertyFunction(
                 string expressionFunction,
@@ -3285,7 +3285,7 @@ internal static Function<T> ExtractPropertyFunction(
             }
 
             /// <summary>
-            /// Execute the function on the given instance
+            /// Execute the function on the given instance.
             /// </summary>
             internal object Execute(object objectInstance, IPropertyProvider<T> properties, ExpanderOptions options, IElementLocation elementLocation)
             {
@@ -3522,12 +3522,12 @@ internal object Execute(object objectInstance, IPropertyProvider<T> properties,
             /// bad for debugging experience and has a performance cost.
             /// A typical binding operation with exception can take ~1.500 ms; this call is ~0.050 ms
             /// (rough numbers just for comparison).
-            /// See https://github.com/Microsoft/msbuild/issues/2217
+            /// See https://github.com/Microsoft/msbuild/issues/2217.
             /// </summary>
-            /// <param name="returnVal">The value returned from the function call</param>
-            /// <param name="objectInstance">Object that the function is called on</param>
-            /// <param name="args">arguments</param>
-            /// <returns>True if the well known function call binding was successful</returns>
+            /// <param name="returnVal">The value returned from the function call.</param>
+            /// <param name="objectInstance">Object that the function is called on.</param>
+            /// <param name="args">arguments.</param>
+            /// <returns>True if the well known function call binding was successful.</returns>
             private bool TryExecuteWellKnownFunction(out object returnVal, object objectInstance, object[] args)
             {
                 returnVal = null;
@@ -4461,8 +4461,8 @@ private void LogFunctionCall(string fileName, object objectInstance, object[] ar
             /// <summary>
             /// Given a type name and method name, try to resolve the type.
             /// </summary>
-            /// <param name="typeName">May be full name or assembly qualified name</param>
-            /// <param name="simpleMethodName">simple name of the method</param>
+            /// <param name="typeName">May be full name or assembly qualified name.</param>
+            /// <param name="simpleMethodName">simple name of the method.</param>
             /// <returns></returns>
             private static Type GetTypeForStaticMethod(string typeName, string simpleMethodName)
             {
@@ -4552,7 +4552,7 @@ private static Type GetTypeForStaticMethod(string typeName, string simpleMethodN
             }
 
             /// <summary>
-            /// Gets the specified type using the namespace to guess the assembly that its in
+            /// Gets the specified type using the namespace to guess the assembly that its in.
             /// </summary>
             private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
             {
@@ -4592,7 +4592,7 @@ private static Type GetTypeFromAssemblyUsingNamespace(string typeName)
             }
 
             /// <summary>
-            /// Get the specified type from the assembly partial name supplied
+            /// Get the specified type from the assembly partial name supplied.
             /// </summary>
             [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Reflection.Assembly.LoadWithPartialName", Justification = "Necessary since we don't have the full assembly name. ")]
             private static Type GetTypeFromAssembly(string typeName, string candidateAssemblyName)
@@ -4631,7 +4631,7 @@ private static Type GetTypeFromAssembly(string typeName, string candidateAssembl
 
             /// <summary>
             /// Extracts the name, arguments, binding flags, and invocation type for an indexer
-            /// Also extracts the remainder of the expression that is not part of this indexer
+            /// Also extracts the remainder of the expression that is not part of this indexer.
             /// </summary>
             private static void ConstructIndexerFunction(string expressionFunction, IElementLocation elementLocation, object propertyValue, int methodStartIndex, int indexerEndIndex, ref FunctionBuilder<T> functionBuilder)
             {
@@ -4674,7 +4674,7 @@ private static void ConstructIndexerFunction(string expressionFunction, IElement
 
             /// <summary>
             /// Extracts the name, arguments, binding flags, and invocation type for a static or instance function.
-            /// Also extracts the remainder of the expression that is not part of this function
+            /// Also extracts the remainder of the expression that is not part of this function.
             /// </summary>
             private static void ConstructFunction(IElementLocation elementLocation, string expressionFunction, int argumentStartIndex, int methodStartIndex, ref FunctionBuilder<T> functionBuilder)
             {
@@ -4785,7 +4785,7 @@ private static void ConstructFunction(IElementLocation elementLocation, string e
 
             /// <summary>
             /// Coerce the arguments according to the parameter types
-            /// Will only return null if the coercion didn't work due to an InvalidCastException
+            /// Will only return null if the coercion didn't work due to an InvalidCastException.
             /// </summary>
             private static object[] CoerceArguments(object[] args, ParameterInfo[] parameters)
             {
@@ -5036,12 +5036,12 @@ private object LateBindExecute(Exception ex, BindingFlags bindingFlags, object o
     }
 
     /// <summary>
-    /// This class wraps information about properties which have been used before they are initialized 
+    /// This class wraps information about properties which have been used before they are initialized. 
     /// </summary>
     internal class UsedUninitializedProperties
     {
         /// <summary>
-        /// This class wraps information about properties which have been used before they are initialized
+        /// This class wraps information about properties which have been used before they are initialized.
         /// </summary>
         internal UsedUninitializedProperties()
         {
@@ -5049,7 +5049,7 @@ internal UsedUninitializedProperties()
         }
 
         /// <summary>
-        /// Hash set of properties which have been used before being initialized
+        /// Hash set of properties which have been used before being initialized.
         /// </summary>
         internal IDictionary<string, IElementLocation> Properties
         {
@@ -5067,7 +5067,7 @@ internal bool Warn
         }
 
         /// <summary>
-        ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property
+        ///  What is the currently evaluating property element, this is so that we do not add a un initialized property if we are evaluating that property.
         /// </summary>
         internal string CurrentlyEvaluatingPropertyElementName
         {
diff --git a/src/Shared/FileUtilitiesRegex.cs b/src/Shared/FileUtilitiesRegex.cs
index 9ab2e9faf9e..0e3be28f1da 100644
--- a/src/Shared/FileUtilitiesRegex.cs
+++ b/src/Shared/FileUtilitiesRegex.cs
@@ -20,10 +20,10 @@ internal static class FileUtilitiesRegex
         private static readonly char _forwardSlash = '/';
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:", "D:")
+        /// Indicates whether the specified string follows the pattern drive pattern (for example "C:", "D:").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern</param>
-        /// <returns>true if follows the drive pattern, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern.</param>
+        /// <returns>true if follows the drive pattern, false otherwise.</returns>
         internal static bool IsDrivePattern(string pattern)
         {
             // Format must be two characters long: "<drive letter>:"
@@ -32,10 +32,10 @@ internal static bool IsDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string follows the pattern drive pattern (e.g. "C:/" or "C:\")
+        /// Indicates whether the specified string follows the pattern drive pattern (for example "C:/" or "C:\").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern with slash</param>
-        /// <returns>true if follows the drive pattern with slash, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern with slash.</param>
+        /// <returns>true if follows the drive pattern with slash, false otherwise.</returns>
         internal static bool IsDrivePatternWithSlash(string pattern)
         {
             return pattern.Length == 3 &&
@@ -43,10 +43,10 @@ internal static bool IsDrivePatternWithSlash(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:")
+        /// Indicates whether the specified string starts with the drive pattern (for example "C:").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern</param>
-        /// <returns>true if starts with drive pattern, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern.</param>
+        /// <returns>true if starts with drive pattern, false otherwise.</returns>
         internal static bool StartsWithDrivePattern(string pattern)
         {
             // Format dictates a length of at least 2,
@@ -58,10 +58,10 @@ internal static bool StartsWithDrivePattern(string pattern)
         }
 
         /// <summary>
-        /// Indicates whether the specified string starts with the drive pattern (e.g. "C:/" or "C:\")
+        /// Indicates whether the specified string starts with the drive pattern (for example "C:/" or "C:\").
         /// </summary>
-        /// <param name="pattern">input to check for drive pattern</param>
-        /// <returns>true if starts with drive pattern with slash, false otherwise</returns>
+        /// <param name="pattern">Input to check for drive pattern.</param>
+        /// <returns>true if starts with drive pattern with slash, false otherwise.</returns>
         internal static bool StartsWithDrivePatternWithSlash(string pattern)
         {
             // Format dictates a length of at least 3,
@@ -76,8 +76,8 @@ internal static bool StartsWithDrivePatternWithSlash(string pattern)
         /// <summary>
         /// Indicates whether the specified file-spec comprises exactly "\\server\share" (with no trailing characters).
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern</param>
-        /// <returns>true if comprises Unc pattern</returns>
+        /// <param name="pattern">Input to check for UNC pattern.</param>
+        /// <returns>true if comprises UNC pattern.</returns>
         internal static bool IsUncPattern(string pattern)
         {
             //Return value == pattern.length means:
@@ -90,8 +90,8 @@ internal static bool IsUncPattern(string pattern)
         /// <summary>
         /// Indicates whether the specified file-spec begins with "\\server\share".
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern</param>
-        /// <returns>true if starts with Unc pattern</returns>
+        /// <param name="pattern">Input to check for UNC pattern.</param>
+        /// <returns>true if starts with UNC pattern.</returns>
         internal static bool StartsWithUncPattern(string pattern)
         {
             //Any non -1 value returned means there was a match, therefore is begins with the pattern.
@@ -101,8 +101,8 @@ internal static bool StartsWithUncPattern(string pattern)
         /// <summary>
         /// Indicates whether the file-spec begins with a UNC pattern and how long the match is.
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern</param>
-        /// <returns>length of the match, -1 if no match</returns>
+        /// <param name="pattern">Input to check for UNC pattern.</param>
+        /// <returns>length of the match, -1 if no match.</returns>
         internal static int StartsWithUncPatternMatchLength(string pattern)
         {
             if (!MeetsUncPatternMinimumRequirements(pattern))
@@ -151,7 +151,7 @@ internal static int StartsWithUncPatternMatchLength(string pattern)
         /// <summary>
         /// Indicates whether or not the file-spec meets the minimum requirements of a UNC pattern.
         /// </summary>
-        /// <param name="pattern">input to check for Unc pattern minimum requirements</param>
+        /// <param name="pattern">Input to check for UNC pattern minimum requirements.</param>
         /// <returns>true if the UNC pattern is a minimum length of 5 and the first two characters are be a slash, false otherwise.</returns>
 #if !NET35
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
diff --git a/src/Tasks.UnitTests/XmlPoke_Tests.cs b/src/Tasks.UnitTests/XmlPoke_Tests.cs
index b57cd585398..98b16aaacc0 100644
--- a/src/Tasks.UnitTests/XmlPoke_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPoke_Tests.cs
@@ -1,22 +1,15 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
-using Microsoft.Build.Tasks;
-using Microsoft.Build.UnitTests;
-using Microsoft.Build.Utilities;
-using Microsoft.Build.Shared;
 using System;
-using System.CodeDom.Compiler;
 using System.Collections.Generic;
-using System.Reflection;
-using System.Reflection.Emit;
 using System.IO;
 using System.Linq;
-using System.Text;
 using System.Xml;
-using Xunit;
+using Microsoft.Build.Tasks;
+using Microsoft.Build.Utilities;
 using Shouldly;
+using Xunit;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -24,16 +17,16 @@ sealed public class XmlPoke_Tests
     {
         private const string XmlNamespaceUsedByTests = "http://nsurl";
 
-        private string _xmlFileWithNs = $@"<?xml version='1.0' encoding='utf-8'?>
+        private const string _xmlFileWithNs = @"<?xml version='1.0' encoding='utf-8'?>
         
-<class AccessModifier='public' Name='test' xmlns:s='{XmlNamespaceUsedByTests}'>
+<class AccessModifier='public' Name='test' xmlns:s='" + XmlNamespaceUsedByTests + @"'>
   <s:variable Type='String' Name='a'></s:variable>
   <s:variable Type='String' Name='b'></s:variable>
   <s:variable Type='String' Name='c'></s:variable>
   <method AccessModifier='public static' Name='GetVal' />
 </class>";
 
-        private string _xmlFileNoNs = @"<?xml version='1.0' encoding='utf-8'?>
+        private const string _xmlFileNoNs = @"<?xml version='1.0' encoding='utf-8'?>
         
 <class AccessModifier='public' Name='test'>
   <variable Type='String' Name='a'></variable>
@@ -57,9 +50,11 @@ public void PokeWithNamespace()
 
             List<XmlAttribute> nodes = xmlDocument.SelectNodes(query, ns)?.Cast<XmlAttribute>().ToList();
 
-            Assert.True(nodes?.Count == 3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.True(nodes?.All(i => i.Value.Equals("Mert")), $"All <variable /> elements should have Name=\"Mert\" {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldAllBe(i => i.Value.Equals("Mert"), $"All <variable /> elements should have Name=\"Mert\" {Environment.NewLine}{xmlDocument.OuterXml}");
         }
 
         [Fact]
@@ -73,9 +68,11 @@ public void PokeNoNamespace()
 
             List<XmlAttribute> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlAttribute>().ToList();
 
-            Assert.True(nodes?.Count == 3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.True(nodes?.All(i => i.Value.Equals(value)), $"All <variable /> elements should have Name=\"{value}\" {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.Count.ShouldBe(3, $"There should be 3 <variable /> elements with a Name attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.ShouldAllBe(i => i.Value.Equals(value), $"All <variable /> elements should have Name=\"{value}\" {Environment.NewLine}{xmlDocument.OuterXml}");
         }
 
         [Fact]
@@ -88,9 +85,11 @@ public void PokeAttribute()
 
             List<XmlAttribute> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlAttribute>().ToList();
 
-            Assert.True(nodes?.Count == 1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <class /> elements with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.Equal(value, nodes?.First().Value);
+            nodes[0].Value.ShouldBe(value);
         }
 
         [Fact]
@@ -103,13 +102,17 @@ public void PokeChildren()
 
             List<XmlElement> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlElement>().ToList();
 
-            Assert.True(nodes?.Count == 1, $"There should be 1 <class /> element {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <class /> elements {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(1, $"There should be 1 <class /> element {Environment.NewLine}{xmlDocument.OuterXml}");
 
             var testNodes = nodes?.First().ChildNodes.Cast<XmlElement>().ToList();
 
-            Assert.True(testNodes?.Count == 1, $"There should be 1 <class /> element with one child Test element {Environment.NewLine}{xmlDocument.OuterXml}");
+            testNodes.ShouldNotBeNull($"There should be <class /> elements with one child Test element {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            testNodes.Count.ShouldBe(1, $"There should be 1 <class /> element with one child Test element {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            Assert.Equal("Testing", testNodes?.First().InnerText);
+            testNodes[0].InnerText.ShouldBe("Testing");
         }
 
         [Fact]
@@ -123,9 +126,11 @@ public void PokeAttributeWithCondition()
 
             List<XmlAttribute> nodes = xmlDocument.SelectNodes(string.Format(queryTemplate, value))?.Cast<XmlAttribute>().ToList();
 
-            nodes?.Count.ShouldBe(1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(1, $"There should be 1 <class /> element with an AccessModifier attribute {Environment.NewLine}{xmlDocument.OuterXml}");
 
-            nodes?[0].Value.ShouldBe(value);
+            nodes[0].Value.ShouldBe(value);
         }
 
         [Fact]
@@ -155,23 +160,14 @@ public void PokeMissingParams()
                     p.Value = new TaskItem("Mert");
                 }
 
-                bool exceptionThrown = false;
-                try
-                {
-                    p.Execute();
-                }
-                catch (ArgumentNullException)
-                {
-                    exceptionThrown = true;
-                }
-
+                // "Expecting argumentnullexception for the first 7 tests"
                 if (i < 7)
                 {
-                    Assert.True(exceptionThrown); // "Expecting argumentnullexception for the first 7 tests"
+                    Should.Throw<ArgumentNullException>(() => p.Execute());
                 }
                 else
                 {
-                    Assert.False(exceptionThrown); // "Expecting argumentnullexception for the first 7 tests"
+                    Should.NotThrow(() => p.Execute());
                 }
             }
         }
@@ -188,12 +184,11 @@ public void ErrorInNamespaceDecl()
             p.XmlInputPath = new TaskItem(xmlInputPath);
             p.Query = "//s:variable/@Name";
             p.Namespaces = "<!THIS IS ERROR Namespace Prefix=\"s\" Uri=\"http://nsurl\" />";
-            Assert.Equal("<!THIS IS ERROR Namespace Prefix=\"s\" Uri=\"http://nsurl\" />", p.Namespaces);
+            p.Namespaces.ShouldBe("<!THIS IS ERROR Namespace Prefix=\"s\" Uri=\"http://nsurl\" />");
             p.Value = new TaskItem("Nur");
 
-            bool executeResult = p.Execute();
-            Assert.Contains("MSB3731", engine.Log);
-            Assert.False(executeResult); // "Execution should've failed"
+            p.Execute().ShouldBeFalse(); // "Execution should've failed"
+            engine.AssertLogContains("MSB3731");
         }
 
         [Fact]
@@ -209,8 +204,8 @@ public void PokeNoNSWPrefixedQueryError()
             p.XmlInputPath = new TaskItem(xmlInputPath);
             p.Query = "//s:variable/@Name";
             p.Value = new TaskItem("Nur");
-            Assert.False(p.Execute()); // "Test should've failed"
-            Assert.True(engine.Log.Contains("MSB3732"), "Engine log should contain error code MSB3732 " + engine.Log);
+            p.Execute().ShouldBeFalse(); // "Test should've failed"
+            engine.AssertLogContains("MSB3732");
         }
 
         [Fact]
@@ -242,11 +237,11 @@ public void MissingNamespaceParameters()
 
                 if (i == 3)
                 {
-                    Assert.True(result); // "Only 3rd value should pass."
+                    result.ShouldBeTrue(); // "Only 3rd value should pass."
                 }
                 else
                 {
-                    Assert.False(result); // "Only 3rd value should pass."
+                    result.ShouldBeFalse(); // "Only 3rd value should pass."
                 }
             }
         }
@@ -262,11 +257,13 @@ public void PokeElement()
 
             List<XmlElement> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlElement>().ToList();
 
-            Assert.True(nodes?.Count == 3, $"There should be 3 <variable/> elements {Environment.NewLine}{xmlDocument.OuterXml}");
+            nodes.ShouldNotBeNull($"There should be <variable/> elements {Environment.NewLine}{xmlDocument.OuterXml}");
+
+            nodes.Count.ShouldBe(3, $"There should be 3 <variable/> elements {Environment.NewLine}{xmlDocument.OuterXml}");
 
             foreach (var node in nodes)
             {
-                Assert.Equal(value, node.InnerXml);
+                node.InnerXml.ShouldBe(value);
             }
         }
 
@@ -287,7 +284,7 @@ public void PokeWithoutUsingTask()
             logger.AssertLogDoesntContain("MSB4036");
         }
 
-        private void Prepare(string xmlFile, out string xmlInputPath)
+        private static void Prepare(string xmlFile, out string xmlInputPath)
         {
             string dir = Path.Combine(Path.GetTempPath(), DateTime.Now.Ticks.ToString());
             Directory.CreateDirectory(dir);
@@ -302,7 +299,7 @@ private void Prepare(string xmlFile, out string xmlInputPath)
         /// <param name="useNamespace"><code>true</code> to use namespaces, otherwise <code>false</code> (Default).</param>
         /// <param name="value">The value to use.</param>
         /// <returns>An <see cref="XmlDocument"/> containing the resulting XML after the XmlPoke task has executed.</returns>
-        private XmlDocument ExecuteXmlPoke(string query, bool useNamespace = false, string value = null)
+        private static XmlDocument ExecuteXmlPoke(string query, bool useNamespace = false, string value = null)
         {
             MockEngine engine = new MockEngine(true);
 
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index e2fc1791d9b..21c68d036f2 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -104,7 +104,7 @@ internal sealed class ReferenceTable
         /// </summary>
         private readonly IsWinMDFile _isWinMDFile;
 
-        /// <summary>version of the framework targeted by this project</summary>
+        /// <summary>Version of the framework targeted by this project.</summary>
         private readonly Version _projectTargetFramework;
 
         /// <summary>
@@ -113,7 +113,7 @@ internal sealed class ReferenceTable
         private readonly FrameworkNameVersioning _targetFrameworkMoniker;
 
         /// <summary>
-        /// Logging helper to allow the logging of meessages from the Reference Table
+        /// Logging helper to allow the logging of meessages from the Reference Table.
         /// </summary>
         private readonly TaskLoggingHelper _log;
 
@@ -188,11 +188,11 @@ internal sealed class ReferenceTable
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
         /// <param name="allowedAssemblyExtensions"></param>
         /// <param name="getRuntimeVersion"></param>
-        /// <param name="getRootedPath"></param>
-        /// <param name="targetedRuntimeVersion"></param>
-        /// <param name="projectTargetFramework"></param>
-        /// <param name="targetFrameworkMoniker"></param>
-        /// <param name="log"></param>
+        /// /// <param name="getRootedPath">Get absolute path from relative one.</param>
+        /// <param name="targetedRuntimeVersion">Version of the runtime to target.</param>
+        /// <param name="projectTargetFramework">Version of the framework targeted by the project.</param>
+        /// <param name="targetFrameworkMoniker">Target framework moniker we are targeting.</param>
+        /// <param name="log">Logging helper to allow the logging of meessages from the Reference Table.</param>
         /// <param name="latestTargetFrameworkDirectories"></param>
         /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
         /// <param name="doNotCopyLocalIfInGac"></param>
@@ -227,11 +227,11 @@ internal sealed class ReferenceTable
         /// <param name="assemblyMetadataCache">Cache of metadata already read from paths.</param>
         /// <param name="allowedAssemblyExtensions"></param>
         /// <param name="getRuntimeVersion"></param>
-        /// <param name="getRootedPath"></param>
-        /// <param name="targetedRuntimeVersion"></param>
-        /// <param name="projectTargetFramework"></param>
-        /// <param name="targetFrameworkMoniker"></param>
-        /// <param name="log"></param>
+        /// <param name="getRootedPath">Get absolute path from relative one.</param>
+        /// <param name="targetedRuntimeVersion">Version of the runtime to target.</param>
+        /// <param name="projectTargetFramework">Version of the framework targeted by the project.</param>
+        /// <param name="targetFrameworkMoniker">Target framework moniker we are targeting.</param>
+        /// <param name="log">Logging helper to allow the logging of meessages from the Reference Table.</param>
         /// <param name="latestTargetFrameworkDirectories"></param>
         /// <param name="copyLocalDependenciesWhenParentReferenceInGac"></param>
         /// <param name="doNotCopyLocalIfInGac"></param>
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 5fc96169dcf..7a3ad571bda 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -3825,10 +3825,10 @@ private void AddResource(ReaderInfo reader, IResource entry, String inputFileNam
         /// <summary>
         /// Add a resource from an XML or binary format file to the internal data structures
         /// </summary>
-        /// <param name="reader">Reader info</param>
-        /// <param name="name">Resource name</param>
-        /// <param name="value">Resource value</param>
-        /// <param name="inputFileName">Input file for messages</param>
+        /// <param name="reader">Reader information.</param>
+        /// <param name="name">Resource name.</param>
+        /// <param name="value">Resource value.</param>
+        /// <param name="inputFileName">Input file for messages.</param>
         private void AddResource(ReaderInfo reader, string name, object value, String inputFileName)
         {
             AddResource(reader, name, value, inputFileName, 0, 0);
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index ea9cf1c27e4..1dd51c92c86 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -252,10 +252,10 @@ internal SystemState(SerializationInfo info, StreamingContext context)
 
         /// <summary>
         /// Set the target framework paths.
-        /// This is used to optimize IO in the case of files requested from one 
+        /// This is used to optimize IO in the case of files requested from one
         /// of the FX folders.
         /// </summary>
-        /// <param name="installedAssemblyTableInfos"></param>
+        /// <param name="installedAssemblyTableInfos">List of Assembly Table Info.</param>
         internal void SetInstalledAssemblyInformation
         (
             AssemblyTableInfo[] installedAssemblyTableInfos
