diff --git a/.github/workflows/copilot-setup-steps.yml b/.github/workflows/copilot-setup-steps.yml
new file mode 100644
index 00000000000..1cc553480d6
--- /dev/null
+++ b/.github/workflows/copilot-setup-steps.yml
@@ -0,0 +1,25 @@
+name: "Copilot Setup Steps"
+
+# Allow testing of the setup steps from your repository's "Actions" tab.
+on: workflow_dispatch
+
+jobs:
+  # The job MUST be called `copilot-setup-steps` or it will not be picked up by Copilot.
+  # See https://docs.github.com/en/copilot/customizing-copilot/customizing-the-development-environment-for-copilot-coding-agent
+  copilot-setup-steps:
+    runs-on: ubuntu-latest
+
+    permissions:
+      contents: read
+
+    # You can define any steps you want, and they will run before the agent starts.
+    # If you do not check out your code, Copilot will do this for you.
+    steps:
+      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
+
+      - uses: actions/setup-dotnet@67a3573c9a986a3f9c594539f4ab511d57bb3ce9 # 4.3.1
+        with:
+          global-json-file: global.json
+
+      - name: Restore MSBuild
+        run: ./eng/common/build.sh --restore
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index f8f6e6e69a0..03d6b6d9b64 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -110,11 +110,15 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: eq(variables.onlyDocChanged, 0)
-  - task: CmdLine@2
-    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
-    condition: failed()
+  - task: PowerShell@2
     inputs:
-      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
+      targetType: 'inline'
+      script: |
+        $files = Get-ChildItem -Path . -Recurse -Include *.received.*
+        if ($files.Count -gt 0) {
+          echo "##vso[task.setvariable variable=publishverify]Yes"
+        }
+    displayName: 'Set flag to publish *.received.* files when Verify test fails'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -308,11 +312,15 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: eq(variables.onlyDocChanged, 0)
-  - task: CmdLine@2
-    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
-    condition: failed()
+  - task: PowerShell@2
     inputs:
-      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
+      targetType: 'inline'
+      script: |
+        $files = Get-ChildItem -Path . -Recurse -Include *.received.*
+        if ($files.Count -gt 0) {
+          echo "##vso[task.setvariable variable=publishverify]Yes"
+        }
+    displayName: 'Set flag to publish *.received.* files when Verify test fails'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
@@ -375,11 +383,15 @@ jobs:
       mergeTestResults: true
     continueOnError: true
     condition: eq(variables.onlyDocChanged, 0)
-  - task: CmdLine@2
-    displayName: 'Set flag to publish Verify *.received.* files when test step fails'
-    condition: failed()
+  - task: PowerShell@2
     inputs:
-      script: 'echo "##vso[task.setvariable variable=publishverify]Yes"'
+      targetType: 'inline'
+      script: |
+        $files = Get-ChildItem -Path . -Recurse -Include *.received.*
+        if ($files.Count -gt 0) {
+          echo "##vso[task.setvariable variable=publishverify]Yes"
+        }
+    displayName: 'Set flag to publish *.received.* files when Verify test fails'
   - task: PublishBuildArtifacts@1
     displayName: 'Publish Artifact: logs'
     inputs:
diff --git a/NuGet.config b/NuGet.config
index c39ceddacb7..a11137a9563 100644
--- a/NuGet.config
+++ b/NuGet.config
@@ -15,37 +15,13 @@
     <add key="dotnet9" value="https://dnceng.pkgs.visualstudio.com/public/_packaging/dotnet9/nuget/v3/index.json" />
     <add key="dotnet9-transport" value="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet9-transport/nuget/v3/index.json" />
     <add key="vs-impl" value="https://pkgs.dev.azure.com/azure-public/vside/_packaging/vs-impl/nuget/v3/index.json" />
+    <!-- We don't want other than VS OpenTelemetry libraries from vs-impl -->
+    <packageSourceMapping>
+      <packageSource key="vs-impl">
+        <package pattern="Microsoft.VisualStudio.OpenTelemetry*" />
+      </packageSource>
+    </packageSourceMapping>
   </packageSources>
-  <!-- We don't want other than VS OpenTelemetry libraries from vs-impl -->
-  <packageSourceMapping>
-    <packageSource key="vs-impl">
-      <package pattern="Microsoft.VisualStudio.OpenTelemetry*" />
-    </packageSource>
-    <packageSource key="arcade">
-      <package pattern="*" />
-    </packageSource>
-    <packageSource key="dotnet-public">
-      <package pattern="*" />
-    </packageSource>
-    <packageSource key="dotnet-tools">
-      <package pattern="*" />
-    </packageSource>
-    <packageSource key="dotnet6">
-      <package pattern="*" />
-    </packageSource>
-    <packageSource key="dotnet8">
-      <package pattern="*" />
-    </packageSource>
-    <packageSource key="dotnet8-transport">
-      <package pattern="*" />
-    </packageSource>
-    <packageSource key="dotnet9">
-      <package pattern="*" />
-    </packageSource>
-    <packageSource key="dotnet9-transport">
-      <package pattern="*" />
-    </packageSource>
-  </packageSourceMapping>
   <disabledPackageSources>
     <!--Begin: Package sources managed by Dependency Flow automation. Do not edit the sources below.-->
     <!--  Begin: Package sources from dotnet-runtime -->
diff --git a/documentation/wiki/CacheFlow.png b/documentation/wiki/CacheFlow.png
new file mode 100644
index 00000000000..851101e87cf
Binary files /dev/null and b/documentation/wiki/CacheFlow.png differ
diff --git a/documentation/wiki/Results-Cache.md b/documentation/wiki/Results-Cache.md
new file mode 100644
index 00000000000..c3e6609708a
--- /dev/null
+++ b/documentation/wiki/Results-Cache.md
@@ -0,0 +1,58 @@
+# MSBuild Caching: `ResultsCache`
+
+MSBuild uses caching to speed up builds. It does this by remembering the outcomes of parts of the build it has already completed. If it needs to build the same part again with the same settings, it can often reuse the stored outcome instead of doing all the work from scratch. This is especially helpful for large projects or when you're making small changes and rebuilding.
+
+![MSBuild Cache Flow](CacheFlow.png)
+
+## `ResultsCache` (The Core Cache Component)
+
+`ResultsCache` is the primary storage mechanism where MSBuild keeps the outcomes of its build targets.
+
+### What It Does
+
+1.  **Stores and Retrieves Build Outcomes**:
+    *   It holds onto `BuildResult` objects. Each `BuildResult` is a record of the outcome for one or more build steps (targets) for a specific project setup (configuration).
+    *   These outcomes are organized using a special ID (`configurationId`) that represents the unique way a project was defined (like list of targets, tools versions, etc).
+    *   When MSBuild is about to build something, it first queries this cache: "Have I processed this exact task before with these exact settings?" If the cache has a valid outcome, MSBuild can use it.
+    *   When new build work is completed, the outcomes are added to this cache so they can be used in the future. If outcomes for that specific setup already exist, the new information is merged with the old.
+
+2.  **Checks if a Build Request Can Be Fulfilled from Cache**:
+    *   Before actually starting a build task, MSBuild uses this cache to see if all the necessary pieces have already been successfully built and their stored outcomes are still valid.
+    *   This check considers the specific build settings and whether detailed project information (like all its properties and items) is needed from the cached outcome. If everything checks out, the build step can be satisfied from the cache.
+
+3.  **Clears Out Stored Outcomes**:
+    *   Sometimes, the cache needs to be cleared. `ResultsCache` can remove all the outcomes it has stored.
+    *   It can also clear out outcomes for just one specific project setup, for example, if project files have changed and the old outcomes are no longer valid.
+
+4.  **Prepares Cache Data for Transfer**:
+    *   `ResultsCache` can convert the information it stores (either all of it or specific `BuildResult` records) into a special format.
+    *   This format can then be sent to other MSBuild processes.
+
+### How `BuildRequestDataFlags` Affect Caching
+
+When MSBuild decides to build something, the request (`BuildRequest`) carries special instructions called `BuildRequestDataFlags`. These flags tell MSBuild *how* to perform the build and *what kind of result* is expected. The `ResultsCache` pays close attention to these flags because they are crucial for determining if a cached outcome is truly a match for a new request.
+It's an out-in feature that can be disabled with change wave `17.12`. See more details in [ChangeWaves.md](ChangeWaves.md)
+
+Here's how some important flags interact with caching:
+
+*   **Flags Affecting Build Behavior:** (if any of the flags is presented only in request or cache) cache miss is returned:
+    *   `IgnoreMissingEmptyAndInvalidImports`: This flag changes how MSBuild handles project imports. If a cached outcome was generated with a different setting for this flag than the current request, the cache will consider it a mismatch.
+    *   `FailOnUnresolvedSdk`: Similar to the imports flag, this affects SDK resolution.
+
+*   **Flags Affecting What's Returned (`ProjectInstance` State):**
+    *   `ProvideProjectStateAfterBuild`: If a build request includes this flag, it means the caller wants the complete `ProjectInstance` (all evaluated properties, items, etc.) along with the target outcomes.
+        *   **Cache Hit**: A cached `BuildResult` can satisfy this if it also contains the full `ProjectInstance` (meaning it was originally built with this flag).
+        *   **Cache Miss**: If the cached `BuildResult` *doesn't* have the full `ProjectInstance`, it cannot satisfy a request that demands it, even if the target outcomes match.
+    *   `ProvideSubsetOfStateAfterBuild`: This flag is used when the caller only needs specific parts of the `ProjectInstance`, defined by a `RequestedProjectStateFilter`.
+        *   **Cache Hit**: A cached `BuildResult` can satisfy this if:
+            1.  It contains the full `ProjectInstance` (the full state naturally includes any subset).
+            2.  It was itself created with `ProvideSubsetOfStateAfterBuild`, and the subset it contains is a superset of (or identical to) what the current request is asking for.
+        *   **Cache Miss**: If the cached subset is insufficient for the current request's filter.
+
+When a `BuildResult` is stored in the cache, the `BuildRequestDataFlags` active during its creation are saved with it. During a cache lookup, these stored flags are compared against the flags of the new `BuildRequest` to ensure compatibility. If the flags indicate a significant difference in how the build was or should be performed, or in what output is expected, a cache miss will occur even if target names and configurations seem to match.
+
+### How It Works with Other Parts
+
+*   **`Scheduler`**: This is the part of MSBuild that decides what to build and when. It communicates frequently with `ResultsCache` – asking if work can be satisfied from the cache and informing the cache about new outcomes.
+*   **`BuildResult`**: This is the `BuildResult` object that `ResultsCache` stores. `ResultsCache` uses features of `BuildResult` to combine outcomes and check if they are still valid.
+*   **`BuildRequest`**: When MSBuild needs to build something, it creates a `BuildRequest`. This request tells `ResultsCache` what to look for (which project setup, which targets, and what kind of outcome, including flags, is needed).
diff --git a/eng/BootStrapMsBuild.targets b/eng/BootStrapMsBuild.targets
index 4789ffcec85..2466f17e7dd 100644
--- a/eng/BootStrapMsBuild.targets
+++ b/eng/BootStrapMsBuild.targets
@@ -118,6 +118,7 @@
       <FreshlyBuiltBinariesx64 Include="$(X64BinPath)**\*.exe.config" />
       <FreshlyBuiltBinariesx64 Include="$(MSBuildTaskHostX64BinPath)**\*.exe.config" />
       <FreshlyBuiltBinariesx64 Include="$(X64BinPath)**\*.dll.config" />
+      <FreshlyBuiltBinariesx64 Remove="$(X64BinPath)**\Microsoft.VisualStudio.SolutionPersistence.dll" />
 
       <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.Tasks.Core.dll" />
       <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.dll" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 8616e51a6a1..bd3033107ec 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
-  <Source Uri="https://github.com/dotnet/dotnet" Mapping="msbuild" Sha="170498a9429a5553fe7ac0ec2341d19bbb97cbe8" BarId="268722" />
+  <Source Uri="https://github.com/dotnet/dotnet" Mapping="msbuild" Sha="ad8565092bbfdd5c8b4a94a718d10b2d394f7aee" BarId="268384" />
   <ProductDependencies>
     <!-- Necessary for source-build. This allows the live version of the package to be used by source-build. -->
     <Dependency Name="Microsoft.Bcl.Cryptography" Version="9.0.0">
@@ -112,21 +112,21 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25266.2">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="9.0.0-beta.25271.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>c62eeb5b5432f9eaa034fbd641ccd9fd0d928fb3</Sha>
+      <Sha>086a1771875b63404b4a710d27250fe384dc2810</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.15.0-preview.1.56">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.15.0-preview.1.70">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>cd2f5c4be1dfd21e7331aebebbbbee14111f348d</Sha>
+      <Sha>fb8b14ee3c574f9b559fc2057cadd20d55a75526</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-3.25262.10">
       <Uri>https://github.com/dotnet/roslyn</Uri>
       <Sha>8edf7bcd4f1594c3d68a6a567469f41dbd33dd1b</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25266.2">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="9.0.0-beta.25271.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>c62eeb5b5432f9eaa034fbd641ccd9fd0d928fb3</Sha>
+      <Sha>086a1771875b63404b4a710d27250fe384dc2810</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index c0ff62d9095..ab42c5f727f 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -80,8 +80,8 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25266.2</MicrosoftDotNetXUnitExtensionsVersion>
-    <NuGetBuildTasksVersion>6.15.0-preview.1.56</NuGetBuildTasksVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25271.1</MicrosoftDotNetXUnitExtensionsVersion>
+    <NuGetBuildTasksVersion>6.15.0-preview.1.70</NuGetBuildTasksVersion>
     <MicrosoftNetCompilersToolsetVersion>4.14.0-3.25262.10</MicrosoftNetCompilersToolsetVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
diff --git a/global.json b/global.json
index 854434d36d6..4b3d71ef4a0 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.12.0"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25266.2"
+    "Microsoft.DotNet.Arcade.Sdk": "9.0.0-beta.25271.1"
   }
 }
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
index d5b4b8bbf38..61d2d5b6516 100644
--- a/src/Build.OM.UnitTests/NugetRestoreTests.cs
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.IO;
+using System.Reflection;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
@@ -22,7 +23,19 @@ public NugetRestoreTests(ITestOutputHelper output)
         [WindowsFullFrameworkOnlyFact]
         public void TestOldNuget()
         {
-            string msbuildExePath = Path.GetDirectoryName(RunnerUtilities.PathToCurrentlyRunningMsBuildExe)!;
+            TestNugetRestore(string.Empty);
+        }
+
+        [WindowsFullFrameworkOnlyFact]
+        public void TestOldNugetWithMsBuild64bit()
+        {
+            TestNugetRestore("amd64");
+        }
+
+        private void TestNugetRestore(string msbuildSubFolder)
+        {
+            string currentAssemblyDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)!;
+            string bootstrapMsBuildBinaryDir = Path.Combine(RunnerUtilities.BootstrapMsBuildBinaryLocation, msbuildSubFolder);
             using TestEnvironment testEnvironment = TestEnvironment.Create();
             TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
             // The content of the solution isn't known to matter, but having a custom solution makes it easier to add requirements should they become evident.
@@ -46,7 +59,7 @@ public void TestOldNuget()
 EndGlobalSection
 EndGlobal
 ");
-            RunnerUtilities.RunProcessAndGetOutput(Path.Combine(msbuildExePath, "nuget", "NuGet.exe"), "restore " + sln.Path + " -MSBuildPath \"" + msbuildExePath + "\"", out bool success, outputHelper: _output);
+            RunnerUtilities.RunProcessAndGetOutput(Path.Combine(currentAssemblyDir, "nuget", "NuGet.exe"), "restore " + sln.Path + " -MSBuildPath \"" + bootstrapMsBuildBinaryDir + "\"", out bool success, outputHelper: _output);
             success.ShouldBeTrue();
         }
     }
diff --git a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
index e470f6be153..c8a163318f0 100644
--- a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
@@ -101,7 +101,7 @@ public void Dispose()
         /// <summary>
         /// Verify that when a single request is submitted, we get a request assigned back out.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestSimpleRequest()
         {
             CreateConfiguration(1, "foo.proj");
@@ -117,7 +117,7 @@ public void TestSimpleRequest()
         /// <summary>
         /// Verify that when we submit a request and we already have results, we get the results back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestSimpleRequestWithCachedResultsSuccess()
         {
             CreateConfiguration(1, "foo.proj");
@@ -141,7 +141,7 @@ public void TestSimpleRequestWithCachedResultsSuccess()
         /// <summary>
         /// Verify that when we submit a request with failing results, we get the results back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestSimpleRequestWithCachedResultsFail()
         {
             CreateConfiguration(1, "foo.proj");
@@ -165,7 +165,7 @@ public void TestSimpleRequestWithCachedResultsFail()
         /// <summary>
         /// Verify that when we submit a child request with results cached, we get those results back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestChildRequest()
         {
             CreateConfiguration(1, "foo.proj");
@@ -195,7 +195,7 @@ public void TestChildRequest()
         /// <summary>
         /// Verify that when multiple requests are submitted, the first one in is the first one out.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMultipleRequests()
         {
             CreateConfiguration(1, "foo.proj");
@@ -213,7 +213,7 @@ public void TestMultipleRequests()
         /// <summary>
         /// Verify that when multiple requests are submitted with results cached, we get the results back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMultipleRequestsWithSomeResults()
         {
             CreateConfiguration(1, "foo.proj");
@@ -235,7 +235,7 @@ public void TestMultipleRequestsWithSomeResults()
         /// <summary>
         /// Verify that when multiple requests are submitted with results cached, we get the results back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMultipleRequestsWithAllResults()
         {
             CreateConfiguration(1, "foo.proj");
@@ -266,7 +266,7 @@ public void TestMultipleRequestsWithAllResults()
         /// Verify that if the affinity of one of the requests is out-of-proc, we create an out-of-proc node (but only one)
         /// even if the max node count = 1.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestOutOfProcNodeCreatedWhenAffinityIsOutOfProc()
         {
             CreateConfiguration(1, "foo.proj");
@@ -288,7 +288,7 @@ public void TestOutOfProcNodeCreatedWhenAffinityIsOutOfProc()
         /// Verify that if the affinity of our requests is out-of-proc, that many out-of-proc nodes will
         /// be made (assuming it does not exceed MaxNodeCount)
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestOutOfProcNodesCreatedWhenAffinityIsOutOfProc()
         {
             _host.BuildParameters.MaxNodeCount = 4;
@@ -313,7 +313,7 @@ public void TestOutOfProcNodesCreatedWhenAffinityIsOutOfProc()
         /// we still won't create any new nodes if they're all for the same configuration --
         /// they'd end up all being assigned to the same node.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestNoNewNodesCreatedForMultipleRequestsWithSameConfiguration()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -336,7 +336,7 @@ public void TestNoNewNodesCreatedForMultipleRequestsWithSameConfiguration()
         /// Verify that if the affinity of our requests is "any", we will not create more than
         /// MaxNodeCount nodes (1 IP node + MaxNodeCount - 1 OOP nodes)
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMaxNodeCountNotExceededWithRequestsOfAffinityAny()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -366,7 +366,7 @@ public void TestMaxNodeCountNotExceededWithRequestsOfAffinityAny()
         /// node will service an Any request instead of an inproc request, leaving only one non-inproc request for the second round
         /// of node creation.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void VerifyRequestOrderingDoesNotAffectNodeCreationCountWithInProcAndAnyRequests()
         {
             // Since we're creating our own BuildManager, we need to make sure that the default
@@ -414,7 +414,7 @@ public void VerifyRequestOrderingDoesNotAffectNodeCreationCountWithInProcAndAnyR
         /// Verify that if the affinity of our requests is out-of-proc, we will create as many as
         /// MaxNodeCount out-of-proc nodes
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMaxNodeCountOOPNodesCreatedForOOPAffinitizedRequests()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -444,7 +444,7 @@ public void TestMaxNodeCountOOPNodesCreatedForOOPAffinitizedRequests()
         /// is less than MaxNodeCount, that we only create MaxNodeCount - 1 OOP nodes (for a total of MaxNodeCount
         /// nodes, when the inproc node is included)
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMaxNodeCountNodesNotExceededWithSomeOOPRequests1()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -474,7 +474,7 @@ public void TestMaxNodeCountNodesNotExceededWithSomeOOPRequests1()
         /// is less than MaxNodeCount, that we only create MaxNodeCount - 1 OOP nodes (for a total of MaxNodeCount
         /// nodes, when the inproc node is included)
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestMaxNodeCountNodesNotExceededWithSomeOOPRequests2()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -511,7 +511,7 @@ public void SchedulerShouldHonorDisableInprocNode()
         /// Make sure that traversal projects are marked with an affinity of "InProc", which means that
         /// even if multiple are available, we should still only have the single inproc node.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestTraversalAffinityIsInProc()
         {
             _host.BuildParameters.MaxNodeCount = 3;
@@ -560,7 +560,7 @@ public void TestProxyAffinityIsInProc()
         /// With something approximating the BuildManager's build loop, make sure that we don't end up
         /// trying to create more nodes than we can actually support.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void VerifyNoOverCreationOfNodesWithBuildLoop()
         {
             // Since we're creating our own BuildManager, we need to make sure that the default
@@ -615,7 +615,7 @@ public void BuildResultNotPlacedInCurrentCacheIfConfigExistsInOverrideCache()
         /// <summary>
         /// Verify that if we get two requests but one of them is a failure, we only get the failure result back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestTwoRequestsWithFirstFailure()
         {
             CreateConfiguration(1, "foo.proj");
@@ -634,7 +634,7 @@ public void TestTwoRequestsWithFirstFailure()
         /// <summary>
         /// Verify that if we get two requests but one of them is a failure, we only get the failure result back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestTwoRequestsWithSecondFailure()
         {
             CreateConfiguration(1, "foo.proj");
@@ -653,7 +653,7 @@ public void TestTwoRequestsWithSecondFailure()
         /// <summary>
         /// Verify that if we get three requests but one of them is a failure, we only get the failure result back.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestThreeRequestsWithOneFailure()
         {
             CreateConfiguration(1, "foo.proj");
@@ -673,7 +673,7 @@ public void TestThreeRequestsWithOneFailure()
         /// <summary>
         /// Verify that providing a result to the only outstanding request results in build complete.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestResult()
         {
             CreateConfiguration(1, "foo.proj");
@@ -697,7 +697,7 @@ public void TestResult()
         /// <summary>
         /// Tests that the detailed summary setting causes the summary to be produced.
         /// </summary>
-        [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
+        [Fact]
         public void TestDetailedSummary()
         {
             string contents = ObjectModelHelpers.CleanupFileContents(@"
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index 54cb31e6598..ce24deabc92 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1282,7 +1282,7 @@ private void InitializeHost(bool throwOnExecute)
             itemsByName.Add(item2);
             _twoItems = new ITaskItem[] { new TaskItem(item), new TaskItem(item2) };
 
-            _bucket = new ItemBucket(Array.Empty<string>(), new Dictionary<string, string>(), new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
+            _bucket = new ItemBucket(new Dictionary<string, ICollection<ProjectItemInstance>>().Keys, new Dictionary<string, string>(), new Lookup(itemsByName, new PropertyDictionary<ProjectPropertyInstance>()), 0);
             _bucket.Initialize(null);
             _host.FindTask(null);
             _host.InitializeForBatch(talc, _bucket, null);
diff --git a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
index f500c937ab9..bc5f79f7ac9 100644
--- a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
+++ b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
@@ -259,8 +259,9 @@ public void BuildEnvironmentDetectsVisualStudioByMSBuildProcessAmd64()
         }
 
         [WindowsFullFrameworkOnlyTheory(additionalMessage: "No Visual Studio installed for .NET.")]
-        [InlineData("17.0", true)]
-        [InlineData("17.3", true)]
+        [InlineData("18.0", true)]
+        [InlineData("17.0", false)]
+        [InlineData("17.3", false)]
         [InlineData("16.0", false)]
         public void BuildEnvironmentDetectsVisualStudioFromSetupInstance(string visualStudioVersion, bool shouldBeValid)
         {
diff --git a/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
index 4501f10688c..8f162834b18 100644
--- a/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/IntrinsicFunctionOverload_Tests.cs
@@ -1,6 +1,7 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.IO;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.UnitTests;
@@ -121,6 +122,129 @@ public void MSBuildSubtractInteger()
             actualProperty.EvaluatedValue.ShouldBe(expected);
         }
 
+        [Fact]
+        public void FileExists_WhenFileExists_ReturnsTrue()
+        {          
+            using TestEnvironment env = TestEnvironment.Create();
+
+            string testFilePath = Path.Combine(env.DefaultTestDirectory.Path, "TestFile.txt");
+            File.WriteAllText(testFilePath, "Test content");
+
+            string projectContent = $@"
+                <Project>
+                    <PropertyGroup>
+                        <TestFilePath>{testFilePath.Replace(@"\", @"\\")}</TestFilePath>
+                        <FileExists>$([MSBuild]::FileExists($(TestFilePath)))</FileExists>
+                    </PropertyGroup>
+                </Project>";
+
+            using ProjectFromString projectFromString = new(projectContent.Cleanup());
+            Project project = projectFromString.Project;
+
+            ProjectProperty actualProperty = project.GetProperty("FileExists");
+            actualProperty.EvaluatedValue.ShouldBe("True");
+        }
+
+        [Fact]
+        public void FileExists_WhenFileDoesNotExist_ReturnsFalse()
+        {
+            const string projectContent = @"
+            <Project>
+                <PropertyGroup>
+                    <TestFilePath>NonExistentFile.txt</TestFilePath>
+                    <FileExists>$([MSBuild]::FileExists($(TestFilePath)))</FileExists>
+                </PropertyGroup>
+            </Project>";
+
+            using ProjectFromString projectFromString = new(projectContent.Cleanup());
+            Project project = projectFromString.Project;
+
+            ProjectProperty actualProperty = project.GetProperty("FileExists");
+            actualProperty.EvaluatedValue.ShouldBe("False");
+        }
+
+        [Fact]
+        public void SystemIODirectoryExists_WhenDirectoryExists_ReturnsTrue()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string testDirPath = Path.Combine(env.DefaultTestDirectory.Path, "TestDir");
+
+            Directory.CreateDirectory(testDirPath);
+
+            string projectContent = $@"
+                <Project>
+                    <PropertyGroup>
+                        <TestDirPath>{testDirPath.Replace(@"\", @"\\")}</TestDirPath>
+                        <DirExists>$([System.IO.Directory]::Exists($(TestDirPath)))</DirExists>
+                    </PropertyGroup>
+                </Project>";
+
+            using ProjectFromString projectFromString = new(projectContent.Cleanup());
+            Project project = projectFromString.Project;
+
+            ProjectProperty actualProperty = project.GetProperty("DirExists");
+            actualProperty.EvaluatedValue.ShouldBe("True");
+        }
+
+        [Fact]
+        public void SystemIODirectoryExists_WhenDirectoryDoesNotExist_ReturnsFalse()
+        {
+            const string projectContent = @"
+            <Project>
+                <PropertyGroup>
+                    <TestDirPath>TestDir</TestDirPath>
+                    <DirExists>$([System.IO.Directory]::Exists($(TestDirPath)))</DirExists>
+                </PropertyGroup>
+            </Project>";
+
+            using ProjectFromString projectFromString = new(projectContent.Cleanup());
+            Project project = projectFromString.Project;
+
+            ProjectProperty actualProperty = project.GetProperty("DirExists");
+            actualProperty.EvaluatedValue.ShouldBe("False");
+        }
+
+        [Fact]
+        public void DirectoryExists_WhenDirectoryExists_ReturnsTrue()
+        {
+            using TestEnvironment env = TestEnvironment.Create();
+            string testDirPath = Path.Combine(env.DefaultTestDirectory.Path, "TestDir");
+
+            Directory.CreateDirectory(testDirPath);
+
+            string projectContent = $@"
+            <Project>
+                <PropertyGroup>
+                    <TestDirPath>{testDirPath.Replace(@"\", @"\\")}</TestDirPath>
+                    <DirExists>$([MSBuild]::DirectoryExists($(TestDirPath)))</DirExists>
+                </PropertyGroup>
+            </Project>";
+
+            using ProjectFromString projectFromString = new(projectContent.Cleanup());
+            Project project = projectFromString.Project;
+
+            ProjectProperty actualProperty = project.GetProperty("DirExists");
+            actualProperty.EvaluatedValue.ShouldBe("True");
+        }
+
+        [Fact]
+        public void DirectoryExists_WhenDirectoryDoesNotExists_ReturnsFalse()
+        {
+            const string projectContent = @"
+            <Project>
+                <PropertyGroup>
+                    <TestDirPath>TestDir</TestDirPath>
+                    <DirExists>$([MSBuild]::DirectoryExists($(TestDirPath)))</DirExists>
+                </PropertyGroup>
+            </Project>";
+
+            using ProjectFromString projectFromString = new(projectContent.Cleanup());
+            Project project = projectFromString.Project;
+
+            ProjectProperty actualProperty = project.GetProperty("DirExists");
+            actualProperty.EvaluatedValue.ShouldBe("False");
+        }
+
         [Fact]
         public void MSBuildSubtractIntegerGreaterThanMax()
         {
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index fa6ae4bbbfd..40d303360c4 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -560,6 +560,21 @@ public void BeginBuild(BuildParameters parameters)
                     _buildParameters.OutputResultsCacheFile = FileUtilities.NormalizePath("msbuild-cache");
                 }
 
+                // Launch the RAR node before the detoured launcher overrides the default node launcher.
+                if (_buildParameters.EnableRarNode)
+                {
+                    NodeLauncher nodeLauncher = ((IBuildComponentHost)this).GetComponent<NodeLauncher>(BuildComponentType.NodeLauncher);
+                    _ = Task.Run(() =>
+                    {
+                        RarNodeLauncher rarNodeLauncher = new(nodeLauncher);
+
+                        if (!rarNodeLauncher.Start())
+                        {
+                            _buildParameters.EnableRarNode = false;
+                        }
+                    });
+                }
+
 #if FEATURE_REPORTFILEACCESSES
                 if (_buildParameters.ReportFileAccesses)
                 {
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 1bfab1b0e52..9ae5c5f5bde 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -124,6 +124,8 @@ public class BuildParameters : ITranslatable
         private bool _enableNodeReuse = false;
 #endif
 
+        private bool _enableRarNode;
+
         /// <summary>
         /// The original process environment.
         /// </summary>
@@ -277,6 +279,7 @@ internal BuildParameters(BuildParameters other, bool resetEnvironment = false)
             _culture = other._culture;
             _defaultToolsVersion = other._defaultToolsVersion;
             _enableNodeReuse = other._enableNodeReuse;
+            _enableRarNode = other._enableRarNode;
             _buildProcessEnvironment = resetEnvironment
                 ? CommunicationsUtilities.GetEnvironmentVariables()
                 : other._buildProcessEnvironment != null
@@ -424,6 +427,15 @@ public bool EnableNodeReuse
             set => _enableNodeReuse = Environment.GetEnvironmentVariable("MSBUILDDISABLENODEREUSE") == "1" ? false : value;
         }
 
+        /// <summary>
+        /// When true, the ResolveAssemblyReferences task executes in an out-of-proc node which persists across builds.
+        /// </summary>
+        public bool EnableRarNode
+        {
+            get => _enableRarNode;
+            set => _enableRarNode = value;
+        }
+
         /// <summary>
         /// Gets an immutable collection of environment properties.
         /// </summary>
@@ -915,6 +927,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _defaultToolsVersion);
             translator.Translate(ref _disableInProcNode);
             translator.Translate(ref _enableNodeReuse);
+            translator.Translate(ref _enableRarNode);
             translator.TranslateProjectPropertyInstanceDictionary(ref _environmentProperties);
             /* No forwarding logger information sent here - that goes with the node configuration */
             translator.TranslateProjectPropertyInstanceDictionary(ref _globalProperties);
diff --git a/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs b/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs
new file mode 100644
index 00000000000..1c3d3b0208a
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/RarNodeLauncher.cs
@@ -0,0 +1,79 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+
+namespace Microsoft.Build.BackEnd
+{
+    internal sealed class RarNodeLauncher
+    {
+        private readonly INodeLauncher _nodeLauncher;
+
+        private readonly string _pipeName;
+
+        internal RarNodeLauncher(INodeLauncher nodeLauncher)
+        {
+            _nodeLauncher = nodeLauncher;
+            _pipeName = NamedPipeUtil.GetRarNodePipeName(new(HandshakeOptions.None));
+        }
+
+        /// <summary>
+        /// Creates a new MSBuild process with the RAR nodemode.
+        /// </summary>
+        public bool Start()
+        {
+            if (IsRarNodeRunning())
+            {
+                CommunicationsUtilities.Trace("Existing RAR node found.");
+                return true;
+            }
+
+            CommunicationsUtilities.Trace("Launching RAR node...");
+
+            try
+            {
+                LaunchNode();
+            }
+            catch (NodeFailedToLaunchException ex)
+            {
+                CommunicationsUtilities.Trace("Failed to launch RAR node: {0}", ex);
+                return false;
+            }
+
+            return true;
+        }
+
+        private bool IsRarNodeRunning()
+        {
+            // Determine if the node is running by checking if the expected named pipe exists.
+            if (NativeMethodsShared.IsWindows)
+            {
+                const string NamedPipeRoot = @"\\.\pipe\";
+
+                // File.Exists() will crash the pipe server, as the underlying Windows APIs have undefined behavior
+                // when used with pipe objects. Enumerating the pipe directory avoids this issue.
+                IEnumerable<string> pipeNames = FileSystems.Default.EnumerateFiles(NamedPipeRoot);
+
+                return pipeNames.Contains(Path.Combine(NamedPipeRoot, _pipeName));
+            }
+            else
+            {
+                // On Unix, named pipes are implemented via sockets, and the pipe name is simply the file path.
+                return FileSystems.Default.FileExists(_pipeName);
+            }
+        }
+
+        private void LaunchNode()
+        {
+            string msbuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+            string commandLineArgs = string.Join(" ", ["/nologo", "/nodemode:3"]);
+            _ = _nodeLauncher.Start(msbuildLocation, commandLineArgs, nodeId: 0);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
index 7f5ebcbf243..be283577e10 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/ItemBucket.cs
@@ -74,7 +74,7 @@ private ItemBucket(Dictionary<string, string> metadata)
         /// <param name="lookup">The <see cref="Lookup"/> to use for the items in the bucket.</param>
         /// <param name="bucketSequenceNumber">A sequence number indication what order the buckets were created in.</param>
         internal ItemBucket(
-            ICollection<string> itemNames,
+            Dictionary<string, ICollection<ProjectItemInstance>>.KeyCollection itemNames, // PERF: directly use the KeyCollection to avoid boxing the enumerator.
             Dictionary<string, string> metadata,
             Lookup lookup,
             int bucketSequenceNumber)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index a262028f9f9..0cb83e34bed 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -940,6 +940,8 @@ public override bool LogsMessagesOfImportance(MessageImportance importance)
             /// <inheritdoc/>
             public override bool IsTaskInputLoggingEnabled => _taskHost._host.BuildParameters.LogTaskInputs;
 
+            public override bool IsOutOfProcRarNodeEnabled => _taskHost._host.BuildParameters.EnableRarNode;
+
 #if FEATURE_REPORTFILEACCESSES
             /// <summary>
             /// Reports a file access from a task.
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 6bcb954c1f3..a3141a4dc87 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -2239,49 +2239,55 @@ private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request)
         }
 
         /// <summary>
-        /// Determines if we have a matching request somewhere, and if so, assigns the same request ID.  Otherwise
-        /// assigns a new request id.
+        /// Determines if we have a matching request somewhere, and if so, assigns the same request ID.
+        /// Otherwise assigns a new request id.
         /// </summary>
-        /// <remarks>
-        /// UNDONE: (Performance) This algorithm should be modified so we don't have to iterate over all of the
-        /// requests to find a matching one.  A HashSet with proper equality semantics and a good hash code for the BuildRequest
-        /// would speed this considerably, especially for large numbers of projects in a build.
-        /// </remarks>
         /// <param name="request">The request whose ID should be assigned</param>
         private void AssignGlobalRequestId(BuildRequest request)
         {
-            bool assignNewId = false;
-            if (request.GlobalRequestId == BuildRequest.InvalidGlobalRequestId && _schedulingData.GetRequestsAssignedToConfigurationCount(request.ConfigurationId) > 0)
+            // Quick exit if already assigned or if there are no requests for this configuration
+            if (request.GlobalRequestId != BuildRequest.InvalidGlobalRequestId
+                || _schedulingData.GetRequestsAssignedToConfigurationCount(request.ConfigurationId) == 0)
+            {
+                request.GlobalRequestId = _nextGlobalRequestId++;
+                return;
+            }
+
+            HashSet<string> requestTargetsSet = new(request.Targets, StringComparer.OrdinalIgnoreCase);
+
+            // Look for matching requests in the configuration
+            foreach (SchedulableRequest existingRequest in _schedulingData.GetRequestsAssignedToConfiguration(request.ConfigurationId))
             {
-                foreach (SchedulableRequest existingRequest in _schedulingData.GetRequestsAssignedToConfiguration(request.ConfigurationId))
+                if (TargetsMatch(requestTargetsSet, existingRequest.BuildRequest.Targets))
                 {
-                    if (existingRequest.BuildRequest.Targets.Count == request.Targets.Count)
-                    {
-                        List<string> leftTargets = new List<string>(existingRequest.BuildRequest.Targets);
-                        List<string> rightTargets = new List<string>(request.Targets);
+                    request.GlobalRequestId = existingRequest.BuildRequest.GlobalRequestId;
+                    return;
+                }
+            }
 
-                        leftTargets.Sort(StringComparer.OrdinalIgnoreCase);
-                        rightTargets.Sort(StringComparer.OrdinalIgnoreCase);
-                        for (int i = 0; i < leftTargets.Count; i++)
-                        {
-                            if (!leftTargets[i].Equals(rightTargets[i], StringComparison.OrdinalIgnoreCase))
-                            {
-                                assignNewId = true;
-                                break;
-                            }
-                        }
+            // No matching request found, assign a new ID
+            request.GlobalRequestId = _nextGlobalRequestId++;
+        }
 
-                        if (!assignNewId)
-                        {
-                            request.GlobalRequestId = existingRequest.BuildRequest.GlobalRequestId;
-                            return;
-                        }
-                    }
+        /// <summary>
+        /// Determines if two target collections contain the same targets, ignoring order and case.
+        /// </summary>
+        private bool TargetsMatch(HashSet<string> firstTargetsSet, List<string> secondTargetsList)
+        {
+            if (firstTargetsSet.Count != secondTargetsList.Count)
+            {
+                return false;
+            }
+
+            foreach (string target in secondTargetsList)
+            {
+                if (!firstTargetsSet.Contains(target))
+                {
+                    return false;
                 }
             }
 
-            request.GlobalRequestId = _nextGlobalRequestId;
-            _nextGlobalRequestId++;
+            return true;
         }
 
         /// <summary>
diff --git a/src/Build/Collections/CopyOnReadEnumerable.cs b/src/Build/Collections/CopyOnReadEnumerable.cs
index 056f5804cfd..72da4089325 100644
--- a/src/Build/Collections/CopyOnReadEnumerable.cs
+++ b/src/Build/Collections/CopyOnReadEnumerable.cs
@@ -72,6 +72,10 @@ public IEnumerator<TResult> GetEnumerator()
 #endif
                 list = new List<TResult>(count);
             }
+            else if (_backingEnumerable is IReadOnlyCollection<TSource> readOnlyCollection)
+            {
+                list = new List<TResult>(readOnlyCollection.Count);
+            }
             else
             {
                 list = new List<TResult>();
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 8e8f26a1233..ae6988de3e4 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -7,7 +7,11 @@
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
+#if NET
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Reflection;
 using System.Runtime.CompilerServices;
@@ -1369,7 +1373,7 @@ internal static object ExpandPropertyBody(
                 // if what we have is a function
                 if (!IsValidPropertyName(propertyBody))
                 {
-                    if (propertyBody.Contains(".") || propertyBody[0] == '[')
+                    if (propertyBody.Contains('.') || propertyBody[0] == '[')
                     {
                         if (BuildParameters.DebugExpansion)
                         {
@@ -1400,7 +1404,7 @@ internal static object ExpandPropertyBody(
                             return null;
                         }
                     }
-                    else if (propertyValue == null && propertyBody.Contains("[")) // a single property indexer
+                    else if (propertyValue == null && propertyBody.Contains('[')) // a single property indexer
                     {
                         int indexerStart = propertyBody.IndexOf('[');
                         int indexerEnd = propertyBody.IndexOf(']');
@@ -4092,7 +4096,7 @@ private static object[] CoerceArguments(object[] args, ParameterInfo[] parameter
                         {
                             coercedArguments[n] = args[n].ToString().ToCharArray();
                         }
-                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains("."))
+                        else if (parameters[n].ParameterType.GetTypeInfo().IsEnum && args[n] is string v && v.Contains('.'))
                         {
                             Type enumType = parameters[n].ParameterType;
                             string typeLeafName = $"{enumType.Name}.";
diff --git a/src/Build/Evaluation/Expander/ArgumentParser.cs b/src/Build/Evaluation/Expander/ArgumentParser.cs
index c2dd113d5ff..2d9fa7954a0 100644
--- a/src/Build/Evaluation/Expander/ArgumentParser.cs
+++ b/src/Build/Evaluation/Expander/ArgumentParser.cs
@@ -3,8 +3,9 @@
 
 using System;
 using System.Globalization;
+
 #if NETFRAMEWORK
-using System.Linq;
+using Microsoft.IO;
 #endif
 
 namespace Microsoft.Build.Evaluation.Expander
diff --git a/src/Build/Evaluation/Expander/WellKnownFunctions.cs b/src/Build/Evaluation/Expander/WellKnownFunctions.cs
index d6bd9de96d3..5f75b6cb636 100644
--- a/src/Build/Evaluation/Expander/WellKnownFunctions.cs
+++ b/src/Build/Evaluation/Expander/WellKnownFunctions.cs
@@ -744,6 +744,22 @@ internal static bool TryExecuteIntrinsicFunction(string methodName, out object?
                     return true;
                 }
             }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.FileExists), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.FileExists(arg0);
+                    return true;
+                }
+            }
+            else if (string.Equals(methodName, nameof(IntrinsicFunctions.DirectoryExists), StringComparison.OrdinalIgnoreCase))
+            {
+                if (ParseArgs.TryGetArg(args, out string? arg0))
+                {
+                    returnVal = IntrinsicFunctions.DirectoryExists(arg0);
+                    return true;
+                }
+            }
             return false;
         }
 
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index fc86d54e613..ef8136fa140 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -539,6 +539,26 @@ internal static string NormalizeDirectory(params string[] path)
             return EnsureTrailingSlash(NormalizePath(path));
         }
 
+        /// <summary>
+        /// Returns if the file exists
+        /// </summary>
+        /// <param name="path">The path to check</param>
+        /// <returns></returns>
+        internal static bool FileExists(string path)
+        {
+            return FileUtilities.FileExistsNoThrow(path);
+        }
+
+        /// <summary>
+        /// Returns if the directory exists
+        /// </summary>
+        /// <param name="path">The path to check</param>
+        /// <returns></returns>
+        internal static bool DirectoryExists(string path)
+        {
+            return FileUtilities.DirectoryExistsNoThrow(path);
+        }
+
         /// <summary>
         /// Gets the canonicalized full path of the provided path and ensures it contains the correct directory separator characters for the current operating system.
         /// </summary>
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 182d6213d8c..1cf148fcd65 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1452,20 +1452,7 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                 else if (destinationItem is IMetadataContainer destinationItemAsMetadataContainer)
                 {
                     // The destination implements IMetadataContainer so we can use the ImportMetadata bulk-set operation.
-                    IEnumerable<ProjectMetadataInstance> metadataEnumerable = MetadataCollection;
-                    IEnumerable<KeyValuePair<string, string>> metadataToImport = metadataEnumerable
-                        .Where(metadatum => string.IsNullOrEmpty(destinationItem.GetMetadata(metadatum.Name)))
-                        .Select(metadatum => new KeyValuePair<string, string>(metadatum.Name, GetMetadataEscaped(metadatum.Name)));
-
-#if FEATURE_APPDOMAIN
-                    if (RemotingServices.IsTransparentProxy(destinationItem))
-                    {
-                        // Linq is not serializable so materialize the collection before making the call.
-                        metadataToImport = metadataToImport.ToList();
-                    }
-#endif
-
-                    destinationItemAsMetadataContainer.ImportMetadata(metadataToImport);
+                    BulkImportMetadata(destinationItem, destinationItemAsMetadataContainer);
                 }
                 else
                 {
@@ -1492,6 +1479,25 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                 }
             }
 
+            // PERF: Keep this method extracted to avoid unconditionally allocating a closure object
+            private void BulkImportMetadata(ITaskItem destinationItem, IMetadataContainer destinationItemAsMetadataContainer)
+            {
+                IEnumerable<ProjectMetadataInstance> metadataEnumerable = MetadataCollection;
+                IEnumerable<KeyValuePair<string, string>> metadataToImport = metadataEnumerable
+                    .Where(metadatum => string.IsNullOrEmpty(destinationItem.GetMetadata(metadatum.Name)))
+                    .Select(metadatum => new KeyValuePair<string, string>(metadatum.Name, GetMetadataEscaped(metadatum.Name)));
+
+#if FEATURE_APPDOMAIN
+                if (RemotingServices.IsTransparentProxy(destinationItem))
+                {
+                    // Linq is not serializable so materialize the collection before making the call.
+                    metadataToImport = metadataToImport.ToList();
+                }
+#endif
+
+                destinationItemAsMetadataContainer.ImportMetadata(metadataToImport);
+            }
+
             /// <summary>
             /// ITaskItem implementation which returns a clone of the metadata on this object.
             /// Values returned are unescaped. To get the original escaped values, use ITaskItem2.CloneCustomMetadataEscaped instead.
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index b28ac113cd2..144e09f128a 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -361,6 +361,7 @@
     <Compile Include="BackEnd\Components\Communications\NodeInfo.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeProviderInProc.cs" />
+    <Compile Include="BackEnd\Components\Communications\RarNodeLauncher.cs" />
     <Compile Include="BackEnd\Components\IBuildComponent.cs" />
     <Compile Include="BackEnd\Components\IBuildComponentHost.cs" />
     <Compile Include="BackEnd\Components\Scheduler\IScheduler.cs" />
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index 68a6ab4f4bc..fb0cf5d5376 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -319,11 +319,13 @@ private static void InitializeAvailableMethods()
                         availableStaticMethods.TryAdd("System.Environment::Version", environmentType);
                         availableStaticMethods.TryAdd("System.Environment::WorkingSet", environmentType);
 
+                        availableStaticMethods.TryAdd("System.IO.Directory::Exists", directoryType);
                         availableStaticMethods.TryAdd("System.IO.Directory::GetDirectories", directoryType);
                         availableStaticMethods.TryAdd("System.IO.Directory::GetFiles", directoryType);
                         availableStaticMethods.TryAdd("System.IO.Directory::GetLastAccessTime", directoryType);
                         availableStaticMethods.TryAdd("System.IO.Directory::GetLastWriteTime", directoryType);
-                        availableStaticMethods.TryAdd("System.IO.Directory::GetParent", directoryType);
+                        availableStaticMethods.TryAdd("System.IO.Directory::GetParent", directoryType);                      
+
                         availableStaticMethods.TryAdd("System.IO.File::Exists", fileType);
                         availableStaticMethods.TryAdd("System.IO.File::GetCreationTime", fileType);
                         availableStaticMethods.TryAdd("System.IO.File::GetAttributes", fileType);
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index cf5b6ae383e..3df7fd23a1f 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -5,7 +5,11 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if NET
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 9ac693a6d28..489db4af2c1 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -984,13 +984,6 @@ private void AddCustomDataSourceToNugetConfig(string checkCandidatePath)
             // MSBuild packages are placed in a separate folder, so we need to add it as a package source.
             AddPackageSource(doc, packageSourcesNode, "MSBuildTestPackagesSource", RunnerUtilities.ArtifactsLocationAttribute.ArtifactsLocation);
 
-            // PackageSourceMapping is enabled at the repository level. For the test packages we need to add the PackageSourceMapping as well.
-            XmlNode? packageSourceMapping = doc.CreateElement("packageSourceMapping");
-            string[] packagePatterns = new string[] { "*" };
-            AddPackageSourceMapping(doc, packageSourceMapping, "CustomCheckSource", packagePatterns);
-            AddPackageSourceMapping(doc, packageSourceMapping, "MSBuildTestPackagesSource", packagePatterns);
-            doc.DocumentElement.AppendChild(packageSourceMapping);
-
             doc.Save(Path.Combine(checkCandidatePath, "nuget.config"));
         }
     }
@@ -1008,23 +1001,6 @@ private void AddPackageSource(XmlDocument doc, XmlNode? packageSourcesNode, stri
         }
     }
 
-    private void AddPackageSourceMapping(XmlDocument doc, XmlNode? packageSourceMapping, string key, string[] packagePatterns)
-    {
-        if (packageSourceMapping != null)
-        {
-            XmlElement packageSourceNode = doc.CreateElement("packageSource");
-            PopulateXmlAttribute(doc, packageSourceNode, "key", key);
-            foreach (var pattern in packagePatterns)
-            {
-                XmlElement packageNode = doc.CreateElement("package");
-                PopulateXmlAttribute(doc, packageNode, "pattern", pattern);
-                packageSourceNode.AppendChild(packageNode);
-            }
-            
-            packageSourceMapping.AppendChild(packageSourceNode);
-        }
-    }
-
     private void PopulateXmlAttribute(XmlDocument doc, XmlNode node, string attributeName, string attributeValue)
     {
         node.ShouldNotBeNull($"The attribute {attributeName} can not be populated with {attributeValue}. Xml node is null.");
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 3bbcfe6f6f2..84e325912c2 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -140,7 +140,7 @@ internal static void ApplyChangeWave()
                 ConversionState = ChangeWaveConversionState.InvalidFormat;
                 _cachedWave = ChangeWaves.EnableAllFeatures;
             }
-            else if (_cachedWave == EnableAllFeatures || AllWaves.Contains(_cachedWave))
+            else if (_cachedWave == EnableAllFeatures || Array.IndexOf(AllWaves, _cachedWave) >= 0)
             {
                 ConversionState = ChangeWaveConversionState.Valid;
             }
@@ -172,7 +172,7 @@ internal static bool AreFeaturesEnabled(Version wave)
             ApplyChangeWave();
 
 #if DEBUG
-            Debug.Assert(_runningTests || AllWaves.Contains(wave), $"Change wave version {wave} is invalid");
+            Debug.Assert(_runningTests || Array.IndexOf(AllWaves, wave) >= 0, $"Change wave version {wave} is invalid");
 #endif
 
             return wave < _cachedWave;
diff --git a/src/Framework/EngineServices.cs b/src/Framework/EngineServices.cs
index 491604c7827..76b3ccb839c 100644
--- a/src/Framework/EngineServices.cs
+++ b/src/Framework/EngineServices.cs
@@ -20,6 +20,11 @@ public abstract class EngineServices
         /// </summary>
         public const int Version1 = 1;
 
+        /// <summary>
+        /// Version 2 with IsOutOfProcRarNodeEnabled().
+        /// </summary>
+        public const int Version2 = 2;
+
         /// <summary>
         /// Gets an explicit version of this class.
         /// </summary>
@@ -27,7 +32,7 @@ public abstract class EngineServices
         /// Must be incremented whenever new members are added. Derived classes should override
         /// the property to return the version actually being implemented.
         /// </remarks>
-        public virtual int Version => Version1;
+        public virtual int Version => Version2;
 
         /// <summary>
         /// Returns <see langword="true"/> if the given message importance is not guaranteed to be ignored by registered loggers.
@@ -48,5 +53,7 @@ public abstract class EngineServices
         /// This is a performance optimization allowing tasks to skip expensive double-logging.
         /// </remarks>
         public virtual bool IsTaskInputLoggingEnabled => throw new NotImplementedException();
+
+        public virtual bool IsOutOfProcRarNodeEnabled => throw new NotImplementedException();
     }
 }
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index e355761d9fd..da8da210b3c 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -121,6 +121,12 @@ public Traits()
         /// </summary>
         public readonly int DictionaryBasedItemRemoveThreshold = ParseIntFromEnvironmentVariableOrDefault("MSBUILDDICTIONARYBASEDITEMREMOVETHRESHOLD", 100);
 
+        /// <summary>
+        /// Launches a persistent RAR process.
+        /// </summary>
+        /// TODO: Replace with command line flag when feature is completed. The environment variable is intented to avoid exposing the flag early.
+        public readonly bool EnableRarNode = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildRarNode"));
+
         /// <summary>
         /// Name of environment variables used to enable MSBuild server.
         /// </summary>
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 56c53a3af4d..a21af6ba0a0 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -450,7 +450,7 @@ elementFormDefault="qualified">
             <xs:element name="BasicRuntimeChecks" />
             <xs:element name="RuntimeLibrary" />
             <xs:element name="FunctionLevelLinking" />
-            <xs:element name="FloatingPointModel " />
+            <xs:element name="FloatingPointModel" />
             <xs:element name="IntrinsicFunctions" />
             <xs:element name="PrecompiledHeaderFile"/>
             <xs:element name="MultiProcessorCompilation" />
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 691ded85c3a..17649c98a14 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -712,6 +712,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 17f88bf1e8b..fd23839785c 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -2005,6 +2005,14 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2040,37 +2048,45 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
     </source>
         <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      Serializuje všechny události sestavení do komprimovaného binárního souboru.
-                     Tento soubor se standardně nachází v aktuálním adresáři a má název msbuild.binlog.
-                     Binární protokol je podrobný popis procesu sestavení, který se
-                     dá později použít k rekonstrukci textových protokolů
-                     a který můžou používat jiné nástroje pro analýzu.
-                     Binární protokol má obvykle 10–20krát menší velikost než
-                     nejpodrobnější textový protokol na úrovni diagnostiky, ale obsahuje více informací.
+                     Ve výchozím nastavení se soubor nachází v aktuálním adresáři a má název
+                     "msbuild.binlog". Binární protokol je podrobný popis
+                     procesu sestavení, který se dá později použít k rekonstrukci
+                     textových protokolů a který využívají jiné analytické nástroje. Binární protokol
+                     je obvykle 10–20krát menší než nejpodrobnější textový
+                     protokol na úrovni diagnostiky, ale obsahuje více informací.
                      (Krátký tvar: -bl)
 
-                     Binární protokolovací nástroj standardně shromažďuje
-                     zdrojový text projektových souborů včetně všech
-                     importovaných projektů a cílových souborů zjištěných
-                     při sestavování. Toto chování řídí volitelný parametr ProjectImports:
+                     Nepovinný soubor logFile určuje cestu, kde
+                     je binární protokol uložený. Pro generování samostatného souboru protokolu
+                     pro každé sestavení se dá token {} přidat do
+                     cesty, například: LogFile=output-{}-log.binlog. Každý 
+                     {} v cestě k protokolu se nahradí jedinečným řetězcem
+                     pomocí časového razítka, ID spuštěného procesu a náhodného
+                     razítka řetězce.
+
+                     Binární protokolovací nástroj ve výchozím nastavení shromažďuje zdrojový text
+                     souborů projektu, včetně všech importovaných projektů a cílových
+                     souborů, ke kterým došlo během sestavení. Nepovinný
+                     přepínač ProjectImports řídí toto chování:
 
-                     ProjectImports=None     - Neshromažďovat importované
-                                                 projekty.
-                      ProjectImports=Embed    - Vložit importované projekty
-                     do souboru protokolu.
-                      ProjectImports=ZipFile  - Uložit projektové soubory
-                                                do output.projectimports.zip,
-                                                kde output je stejný název
-                                                jako název souboru binárního protokolu.
+                      ProjectImports=None     – Neshromažďovat importy projektu
+                                                .
+                      ProjectImports=Embed    – Vložit importy projektu do
+                                                souboru protokolu.
+                      ProjectImports=ZipFile  – Uložit soubory projektu do
+                                                output.projectimports.zip
+                                                kde výstup má stejný název
+                                                jako je název binárního souboru protokolu.
 
                      Výchozí nastavení pro ProjectImports je Embed.
-                     Poznámka: Protokolovací nástroj neshromažďuje zdrojové
-                     soubory nepatřící pod MSBuild, jako .cs, .cpp atd.
+                     Poznámka: protokolovací nástroj neshromažďuje zdrojové soubory, které nepocházejí z nástroje MSBuild,
+                     jako například .cs, .cpp atd.
 
-                     Soubor .binlog se dá znovu přehrát“ tak, že se předá
-                     souboru msbuild.exe jako argument místo projektu/řešení.
-                     Jiné protokolovací nástroje obdrží informace obsažené
-                     v souboru protokolu, jako by šlo o původní sestavení.
-                     Více o binárním protokolu a jeho použití si můžete přečíst na stránce:
+                     Soubor .binlog se dá přehrát předáním do
+                     msbuild.exe jako argument místo projektu nebo řešení.
+                     Ostatní protokolovací nástroje obdrží informaci obsaženou
+                     v souboru protokolu, jako by se provádělo původní sestavení.
+                     Další informace o binárním protokolu a jeho použití najdete tady:
                      https://aka.ms/msbuild/binlog
 
                      Příklady:
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 03c2ca750fb..f59cb4260d4 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1993,6 +1993,14 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2036,9 +2044,17 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
                      binäre Protokolle, letztere enthalten jedoch mehr Informationen.
                      (Kurzform: -bl)
 
+                     Die optionale LogFile gibt den Pfad an, in dem das
+                     Binärprotokoll gespeichert wird. Um eine eigene Protokolldatei
+                     für jeden Build zu generieren, kann das Token "{}" zum
+                     Pfad hinzugefügt werden, z. B.: LogFile=output-{}-log.binlog. Jedes 
+                     "{}" im Protokollpfad wird durch eine eindeutige Zeichenfolge ersetzt,
+                     indem Zeitstempel, ID des ausgeführten Prozesses und ein zufälliger
+                     Zeichenfolgenstempel verwendet werden.
+
                      Die binäre Protokollierung erfasst standardmäßig den Quelltext von
-                     Projektdateien, einschließlich aller beim Buildvorgang aufgetretenen importierten
-                     Projekte und Zieldateien. Der optionale Schalter
+                     Projektdateien, einschließlich aller beim Buildvorgang aufgetretenen
+                     importierten Projekte und Zieldateien. Der optionale Schalter
                      ProjectImports steuert dieses Verhalten:
 
                       ProjectImports=None:      – Projektimporte nicht
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index d8d6d837bb7..61b6c952e98 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1999,6 +1999,14 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2033,48 +2041,56 @@ Esta marca es experimental y puede que no funcione según lo previsto.
                        -binaryLogger
     </source>
         <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Serializa todos los eventos de compilación en un archivo                     binario comprimido.
- De manera predeterminada, el archivo se encuentra en el directorio actual y tiene
-                     el nombre "msbuild.binlog". El registro binario es una
-                     descripción detallada del proceso de compilación que
-                     se puede utilizar más adelante para reconstruir registros
-                     de texto y que otras herramientas de análisis pueden emplear. Un registro binario suele ser de 10 a 20 veces
-                     más pequeño que el registro de nivel de diagnóstico de texto más detallado, pero contiene más información
-                    (Forma corta: -bl).
+                     Serializa todos los eventos de compilación en un archivo binario comprimido.
+                     De forma predeterminada, el archivo está en el directorio actual y se denomina
+                     "msbuild.binlog". El registro binario es una descripción detallada
+                     del proceso de compilación que se puede usar más adelante para reconstruir
+                     registros de texto y ser usado por otras herramientas de análisis. Un registro binario
+                     suele ser 10-20 veces menor que el registro de nivel de diagnóstico
+                     de texto más detallado, pero contiene más información.
+                     (Forma corta: -bl)
+
+                     El archivo de registro opcional especifica la ruta de acceso donde el
+                     se guarda el registro binario. Para generar un archivo de registro distinto
+                     para cada compilación, el token "{}" se puede agregar a la
+                     ruta de acceso, por ejemplo: LogFile=output-{}-log.binlog. Cada 
+                     "{}" en la ruta de acceso del registro se reemplaza por una cadena única
+                     mediante la marca de tiempo, el identificador de proceso en ejecución y los id.
+                     y sellos de cadena aleatorios.
 
-                     De manera predeterminada, el registrador binario recopila
-                     el texto de origen de los archivos del proyecto, incluidos
-                     todos los proyectos y archivos de destino importados que se encuentren durante la compilación. El modificador
-                     opcional ProjectImports controla este comportamiento:
+                     De forma predeterminada, el registrador binario recopila el texto de origen de
+                     archivos de proyecto, incluidos todos los proyectos importados y archivos
+                     de destino encontrados durante la compilación. El conmutador opcional
+                     ProjectImports controla este comportamiento:
 
-                      ProjectImports=None     - No recopilar importaciones
-                                                de proyecto.
-                      ProjectImports=Embed    - Insertar importaciones de
-                                                proyecto en el archivo de registro.
-                      ProjectImports=ZipFile  - Guardar los archivos del
-                                                proyecto en salida.projectimports.zip,
-                                                donde "salida" es el mismo nombre que
-                                                el del archivo de registro binario.
+                      ProjectImports=None     - No recopilar las importaciones
+                                                del proyecto.
+                      ProjectImports=Embed    - Inserción de importaciones de proyecto en el
+                                                archivo de registro.
+                      ProjectImports=ZipFile  - Guardar archivos de proyecto en
+                                                output.projectimports.zip
+                                                donde la salida tiene el mismo nombre
+                                                que el nombre del archivo de registro binario.
 
-                     La configuración predeterminada de ProjectImports es Embed.
-                     Nota: El registrador no recopila archivos de código fuente
-                     que no sean de MSBuild, como .cs, .cpp, etc.
+                     El valor predeterminado de ProjectImports es Inserción.
+                     Nota: el registrador no recopila archivos de código fuente que no son de MSBuild
+                     como .cs, .cpp, etc.
 
                      Un archivo .binlog se puede "reproducir" pasándolo a
-                     msbuild.exe como argumento en lugar de proyecto o                     solución.
- Otros registradores recibirán la información
-                     que contiene el archivo de registro como si se estuviera
-                     ejecutando la compilación original. Encontrará más información sobre el registro binario y su uso en:
+                     msbuild.exe como argumento en lugar de como proyecto o solución.
+                     Otros registradores recibirán la información contenida en el
+                     archivo de registro como si se estuviera produciendo la compilación original.
+                     Puede obtener más información sobre el registro binario y sus usos en:
                      https://aka.ms/msbuild/binlog
 
                      Ejemplos:
                        -bl
                        -bl:output.binlog
                        -bl:output.binlog;ProjectImports=None
-                      -bl:output.binlog;ProjectImports=ZipFile
+                       -bl:output.binlog;ProjectImports=ZipFile
                        -bl:..\..\custom.binlog
-                     -binaryLogger
-   </target>
+                       -binaryLogger
+    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "msbuild"
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index ac46ff96a7d..ca4e4e37fdb 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1994,6 +1994,14 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2028,65 +2036,56 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
                        -binaryLogger
     </source>
         <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                     Sérialise tous les événements de build dans un fichier binaire compressé.
-                     Par défaut, le fichier se trouve dans le répertoire actif et se nomme
+                     Sérialise tous les événements de génération dans un fichier binaire compressé.
+                     Par défaut, le fichier se trouve dans le répertoire actuel et son nom est 
                      "msbuild.binlog". Le journal binaire est une description détaillée
-                     du processus de génération, qui peut servir plus tard à reconstruire
-                     les journaux texte et être utilisé par d'autres outils d'analyse. Un journal binaire
-                     est généralement
-10 à 20
-fois plus petit que le journal
-                     de diagnostic de type texte le plus détaillé, mais il contient plus d'informations.
-                     (Forme abrégée
-: -bl)
-
-
-                     Le journaliseur binaire par défaut collecte le texte source
+                     du processus de génération que vous pouvez utiliser plus tard pour reconstruire
+                     des journaux texte et être utilisé par d’autres outils d’analyse. Un journal binaire
+                     est généralement 10 à 20 fois plus petit que le journal au niveau du diagnostic
+                     du texte le plus détaillé, mais il contient d’autres informations.
+                     (Forme abrégée : -bl)
 
-                     des fichiers projet, notamment tous les projets importés et les
+                     Le LogFile facultatif spécifie le chemin d’accès où le
+                     journal binaire est enregistré. Pour générer un fichier journal distinct
+                     pour chaque génération, vous pouvez ajouter le jeton « {} » dans le
+                     chemin d’accès, par exemple : LogFile=output-{}-log.binlog. Chaque 
+                     « {} » dans le chemin d’accès du journal est remplacé par une chaîne unique
+                     en utilisant un timestamp, ce qui exécute l’ID de processus et une
+                     empreinte de chaîne aléatoire.
 
-                     fichiers cibles rencontrés pendant la build. Le commutateur
+                     L’enregistreur binaire collecte par défaut le texte source des
+                     fichiers de projet, notamment tous les projets importés et les
+                     fichiers cibles rencontrés pendant la génération. Le commutateur
+                     ProjectImports facultatif contrôle ce comportement :
 
-                     ProjectImports facultatif contrôle ce comportement
-:
-
-                      ProjectImports=None     - Ne collecte pas les importations
-                                                du projet.
-                      ProjectImports=Embed    - Incorpore les importations du projet dans
-                                                le fichier journal.
-                      ProjectImports=ZipFile  - Enregistre les fichiers projet dans
+                      ProjectImports=None     – Ne collectez pas les
+                                                importations du projet.
+                      ProjectImports=Embed    – Importations du projet incorporées dans le
+                                                fichier journal.
+                      ProjectImports=ZipFile  – Enregistrez les fichiers du projet dans
                                                 output.projectimports.zip
-                                                où la sortie porte le même nom que
-                                                le fichier journal binaire.
-
-                     Le paramètre par défaut de ProjectImports est Embed.
-                     Remarque
-: Le journaliseur ne collecte pas les
-
-                     fichiers sources non MSBuild tels que .cs, .cpp etc.
-
-
-                     Vous pouvez "lire" un fichier .binlog en le passant à
-
-                     msbuild.exe en tant qu'argument plutôt qu'en tant que projet/solution.
-
-                     D'autres enregistreurs d'événements reçoivent les informations
+                                                où la sortie est le même nom
+                                                que le nom du fichier journal binaire.
 
-                     contenues dans le fichier journal comme si la build d'origine était en cours de création.
+                     Le paramètre par défaut pour ProjectImports est Incorporé.
+                     Remarque : l’enregistreur ne collecte pas les fichiers sources non-MSBuild
+                     tels que .cs, .cpp etc.
 
-                     Pour plus d'informations sur le journal binaire et ses usages, consultez
-:
-                    https://aka.ms/msbuild/binlog
-
-                     Exemples
-:
+                     Vous pouvez « lire » un fichier .binlog en le passant à
+                     msbuild.exe en tant qu’argument au lieu d’une solution/d’un projet.
+                     D’autres enregistreurs reçoivent les informations contenues
+                     dans le fichier journal comme si la génération d’origine se produisait.
+                     Vous pouvez lire plus d’informations sur le journal binaire et ses utilisations sur :
+                     https://aka.ms/msbuild/binlog
 
+                     Exemples :
                        -bl
-
                        -bl:output.binlog
-
                        -bl:output.binlog;ProjectImports=None
-                       -bl:output.binlog;ProjectImports=ZipFile                       -bl:..\..\custom.binlog                       -binaryLogger    </target>
+                       -bl:output.binlog;ProjectImports=ZipFile
+                       -bl:..\..\custom.binlog
+                       -binaryLogger
+    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "msbuild"
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 842cdf22a24..4757e078ddb 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -2006,6 +2006,14 @@ Nota: livello di dettaglio dei logger di file
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2047,7 +2055,16 @@ Nota: livello di dettaglio dei logger di file
                      seguito per ricostruire i log di testo e viene usato da altri strumenti di analisi. Un log binario è in genere
                      10-20 volte più piccolo del più dettagliato log di testo
                      di livello diagnostico, ma contiene maggiori informazioni.
-                     (Froma breve: -bl)
+                     (Forma breve: -bl)
+
+                     Il LogFile facoltativo specifica il percorso in cui il
+                     il log binario viene salvato. Per generare un file di log distinto
+                     per ogni compilazione, il token "{}" può essere aggiunto al
+                     percorso, ad esempio: LogFile=output-{}-log.binlog. Ogni 
+                     "{}" nel percorso del log viene sostituito con una stringa univoca
+                     usando il timestamp, l'ID del processo in esecuzione e
+timbro
+                     stringa casuale.
 
                      Per impostazione predefinita, il logger binario raccoglie il testo di origine di
                      file di progetto, inclusi tutti i
@@ -2060,8 +2077,8 @@ Nota: livello di dettaglio dei logger di file
                                                 file di log.
                       ProjectImports=ZipFile  - I file del progetto vengono salvati in
                                                 output.projectimports.zip
-                                                dove output corrisponde allo
-                                                as stesso nome del file di log binario.
+                                                dove output corrisponde allo stesso
+                                                nome del file di log binario.
 
                      L'impostazione predefinita di ProjectImports è Embed.
                      Nota: il logger non raccoglie i file di origine non-MSBuild,
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 4dad67e4fa9..363f80a302a 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2028,38 +2036,46 @@
     </source>
         <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      すべてのビルド イベントを圧縮バイナリ ファイルにシリアル化します。
-                     既定では、このファイルは "msbuild.binlog" という名前で
-                     現在のディレクトリに置かれます。バイナリ ログはビルド プロセスの
-                     詳細な説明であり、後でテキスト ログを再構築するために使用でき、
-                     他の分析ツールでも使用できます。バイナリ ログは通常、
-                     ほとんどの詳細なテキスト診断レベル ログと比べて 10 分の 1 から
-                     20 分の 1 の大きさですが、より多くの情報を含んでいます。
+                     既定では、ファイルは現在のディレクトリにあり、
+                     "msbuild.binlog" という名前が付けられます。バイナリ ログはビルド プロセスの詳細な説明であり、
+                     後でテキスト ログを再構築したり、他の分析ツールで使用
+                     したりするために使用できます。バイナリ ログは通常、
+                     最も詳細なテキスト診断レベルのログの 10 - 20 分の 1 の
+                     大きさですが、より多くの情報が含まれています。
                      (短い形式: -bl)
 
-                     既定では、バイナリ ロガーはプロジェクト ファイルのソース テキストを
-                     収集します。それには、ビルド中に検出された、すべてのインポート済み
-                     プロジェクトとターゲット ファイルが含まれます。オプションの
-                     ProjectImports スイッチは次のように動作を制御します。
+                     省略可能な LogFile は、バイナリ ログが保存される
+                     パスを指定します。ビルドごとに個別のログ ファイルを
+                     生成するには、パスにトークン "{}" を追加します 
+                     (例: LogFile=output-{}-log.binlog)。ログ パス内の
+                     各 "{}" は、タイムスタンプ、実行中のプロセス ID、
+                     ランダム文字列スタンプを使用して一意の文字列に
+                     置き換えられます。
 
-                      ProjectImports=None     - プロジェクト インポートを収集しません。
+                     バイナリ ロガーでは、既定でプロジェクト ファイルのソース 
+                     テキストが収集されます。これには、ビルド中に読み込まれた
+                     すべてのインポート プロジェクトやターゲット ファイルが含まれます。省略可能な
+                     ProjectImports スイッチはこの動作を制御します:
 
-                      ProjectImports=Embed    - プロジェクト インポートをログ ファイルに
-                                                組み込みます。
-                      ProjectImports=ZipFile  - プロジェクト ファイルを
-                                                output.projectimports.zip に保存します。
-                                                ここで、output はバイナリ ログ
-                                                ファイル名と同じ名前です。
+                      ProjectImports=None     - プロジェクトのインポートを
+                                                収集しません。
+                      ProjectImports=Embed    - プロジェクトのインポートを
+                                                ログ ファイルに埋め込みます。
+                      ProjectImports=ZipFile - プロジェクト ファイルを 
+                                                output.projectimports.zip に保存します
+                                                ここで、output はバイナリ ログ ファイル名と
+                                                同じ名前です。
 
                      ProjectImports の既定の設定は Embed です。
-                     メモ: ロガーは、MSBuild 以外のソース ファイルを収集しません
-                     (.cs、.cpp など)。
+                     メモ: このロガーは、.cs、.cpp などの MSBuild 以外のソース 
+                     ファイルを収集しません。
 
-                     プロジェクト/ソリューションの代わりに、引数として .binlog ファイルを
-                     msbuild.exe に渡すと、そのファイルを "再生" することができます。
-                     他のロガーは、オリジナルのビルドが行われたときのように、
-                     ログ ファイルに含まれる情報を受け取ることができます。
-                     バイナリ ログとその使用法の詳細については、以下をお読みください。
-                     https://aka.ms/msbuild/binlog
+                     .binlog ファイルを "再生" するには、プロジェクト/
+                     ソリューションの代わりに引数として msbuild.exe に渡します。
+                     他のロガーは、元のビルドが実行されているかのように、
+                     ログ ファイルに含まれる情報を受け取ります。
+                     バイナリ ログとその使用方法の詳細については、
+                     https://aka.ms/msbuild/binlog を参照してください
 
                      例:
                        -bl
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index b4c9c4b26fe..5da5d3a7cac 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2028,37 +2036,45 @@
     </source>
         <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      모든 빌드 이벤트를 압축된 이진 파일로 직렬화합니다.
-                     기본적으로 이 파일은 현재 디렉터리에 있으며 이름은
-                     "msbuild.binlog"입니다. 이진 로그는 빌드 프로세스를
-                     자세히 설명하는 것으로, 나중에 텍스트 로그를 다시
-                     구성하기 위해 사용할 수 있고 다른 분석 도구에 의해
-                     사용될 수 있습니다. 이진 로그는 일반적으로 가장
-                     상세한 텍스트 진단 수준 로그보다 10~20배 작지만,
-                     더 자세한 정보를 포함하고 있습니다.
+                     기본적으로 파일은 현재 디렉터리에 있으며 이름은
+                     "msbuild.binlog"입니다. 이진 로그는 나중에 텍스트 로그를 재구성하는 데
+                     사용할 수 있고 다른 분석 도구에서 사용할 수 있는 빌드 프로세스의
+                     자세한 설명입니다. 이진 로그는
+                     일반적으로 가장 자세한 텍스트 진단 수준 로그보다 10~20배
+                     작지만 더 많은 정보를 담고 있습니다.
                      (약식: -bl)
 
-                     이진 로거는 기본적으로 빌드 중에 가져온 모든 프로젝트와
-                     발생한 대상 파일을 비롯한 프로젝트 파일의 소스 텍스트를
-                     수집합니다. 선택적 ProjectImports 스위치는 이 동작을 제어합니다.
+                     선택적 LogFile은 이진 로그가 저장되는
+                     경로를 지정합니다. 각 빌드에 고유한 로그 파일을 생성하려면
+                     토큰 "{}"를 경로에 추가할 수 있습니다.
+                     예: LogFile=output-{}-log.binlog. 로그 경로의 
+                     각 "{}"는 타임스탬프, 실행 프로세스 ID 및 임이의 문자열
+                     스탬프를 사용하여 고유한 문자열로
+                     대체됩니다.
+
+                     기본적으로 이진 로거는 빌드하는 동안 발견된
+                     가져온 모든 프로젝트 및 대상 파일을 포함한 프로젝트 파일의
+                     원본 텍스트를 수집합니다. 선택적
+                     ProjectImports 스위치는 다음 동작을 제어합니다.
 
                       ProjectImports=None     - 프로젝트 가져오기를 수집하지
-                                                않습니다.
+                                                마세요.
                       ProjectImports=Embed    - 로그 파일에 프로젝트 가져오기를
                                                 포함합니다.
-                      ProjectImports=ZipFile  - 프로젝트 파일을
-                                                output.projectimports.zip에 저장합니다.
-                                                여기서 output은 이진 로그 파일 이름과
+                      ProjectImports=ZipFile - 프로젝트 파일을
+                                                output.projectimports.zip에
+                                                저장하며 여기서 출력은 이진 로그 파일 이름과
                                                 같은 이름입니다.
 
                      ProjectImports의 기본 설정은 Embed입니다.
-                     참고: 로거는 .cs, .cpp 등과 같은 MSBuild가 아닌 소스 파일은
-                     수집하지 않습니다.
+                     참고: 로거는 MSBuild가 아닌 소스 파일을 수집하지 않습니다.
+                     예: .cs, .cpp 등
 
-                     .binlog 파일을 프로젝트/솔루션 대신 인수로 msbuild.exe에
-                     전달하여 "재생"할 수 있습니다. 다른 로거는 원본 빌드가
-		     발생하고 있는 것처럼 로그 파일에 포함된 정보를 받게 됩니다.
-                     이진 로그 및 해당 사용법에 대한 자세한 내용은
-                     다음 위치에서 확인할 수 있습니다.
+                     .binlog 파일은 프로젝트/솔루션 대신 인수로
+                     msbuild.exe에 전달하여 “재생”될 수 있습니다.
+                     다른 로거는 원래 빌드가 발생하는 것처럼 로그 파일에
+                     포함된 정보를 받습니다.
+                     이진 로그 및 해당 사용에 대한 자세한 내용은 다음에서 확인할 수 있습니다.
                      https://aka.ms/msbuild/binlog
 
                      예:
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 5d20dcb3b21..5e2ee08a6ca 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -2003,6 +2003,14 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2041,11 +2049,19 @@ Ta flaga jest eksperymentalna i może nie działać zgodnie z oczekiwaniami.
                      Domyślnie plik znajduje się w bieżącym katalogu i ma nazwę
                      „msbuild.binlog”. Dziennik binarny to szczegółowy opis procesu
                      kompilacji, którego można później użyć do odtworzenia
-dzienników                     tekstowych i wykorzystać w innych narzędziach do analizy. Dziennik binarny
+                     dzienników tekstowych i wykorzystać w innych narzędziach do analizy. Dziennik binarny
                      jest zwykle 10–20 razy mniejszy od najbardziej szczegółowych
                      tekstowych dzienników na poziomie diagnostycznym, ale zawiera więcej informacji.
                      (Krótka forma: -bl)
 
+                     Opcjonalny LogFile określa ścieżkę, w której
+                     zapisany jest dziennik binarny. Aby wygenerować osobny plik dziennika
+                     dla każdej kompilacji, można dodać token „{}” do
+                     ścieżki, na przykład: LogFile=output-{}-log.binlog. Każdy 
+                     „{}” w ścieżce dziennika zostanie zastąpiony unikalnym ciągiem
+                     utworzonym na podstawie znacznika czasu, identyfikatora procesu i losowego
+                     ciągu znaków.
+
                      Rejestrator binarny domyślnie zbiera tekst źródłowy
                      plików projektu, w tym wszystkie zaimportowane projekty i pliki
                      docelowe napotkane podczas kompilowania. Tym zachowaniem
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 873f8078d9d..d24483156db 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1993,6 +1993,14 @@ arquivo de resposta.
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2036,16 +2044,24 @@ arquivo de resposta.
                      de diagnóstico do texto mais detalhado, mas contém mais informações.
                      (Forma abreviada: -bl)
 
+                     O LogFile opcional especifica o caminho em que o
+                     log binário é salvo. Para gerar um arquivo de log distinto
+                     para cada compilação, o token "{}" pode ser adicionado ao
+                     caminho, por exemplo: LogFile=output-{}-log.binlog. Cada 
+                     "{}" no caminho de log é substituído por uma cadeia de caracteres exclusiva
+                     usando o carimbo de data/hora, executando a ID do processo e aleatoriamente
+                     o aplicar selo de cadeia de caracteres.
+
                      O agente binário, por padrão, coleta o texto fonte dos
                      arquivos de projeto, incluindo todos os projetos importados e arquivos
                      de destino encontrados durante a compilação. A opção
-                     ProjectImports opcional controla este comportamento:
+                     ProjectImports controla este comportamento:
 
-                      ProjectImports=None     - Não coletar as importações
+                      ProjectImports=None     – Não coletar as importações
                                                 do projeto.
-                      ProjectImports=Embed    - Inserir as importações do projeto no
+                      ProjectImports=Embed    – Inserir as importações do projeto no
                                                 arquivo de log.
-                      ProjectImports=ZipFile  - Salvar os arquivos de projeto em
+                      ProjectImports=ZipFile  – Salvar os arquivos de projeto em
                                                 output.projectimports.zip
                                                 em que a saída tem o mesmo nome que o
                                                 nome do arquivo de log binário.
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 53e8695e09b..f0de6f4d4bd 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2031,11 +2039,19 @@
                      По умолчанию файл находится в текущем каталоге и называется
                      "msbuild.binlog". Двоичный журнал включает подробное описание
                      процесса сборки, которое затем можно использовать для воссоздания
-                     текстовых журналов. Он также может использоваться другими средствами анализа. Двоичный журнал
+                     текстовых журналов и может использоваться другими средствами анализа. Двоичный журнал
                      обычно в 10–20 раз меньше самого подробного текстового
                      журнала уровня диагностики, но содержит больше информации.
                      (Краткая форма: -bl)
 
+                     Необязательный параметр LogFile указывает путь, по которому
+                     сохраняется двоичный журнал. Чтобы создать отдельный файл журнала
+                     для каждой сборки, можно добавить токен "{}" в
+                     путь, например: LogFile=output-{}-log.binlog. Каждый 
+                     символ "{}" в пути журнала заменяется уникальной строкой,
+                     использующей временную метку, идентификатор запущенного процесса и случайную
+                     метку строки.
+
                      Средство ведения двоичного журнала по умолчанию собирает исходный текст
                      файлов проекта, включая все импортированные проекты и целевые
                      файлы, найденные во время сборки. Дополнительный
@@ -2051,7 +2067,7 @@
                                                 что и у двоичного файла журнала.
 
                      Значение по умолчанию для ProjectImports — Embed.
-                     Примечание. Средство ведения журнала не собирает исходные файлы, не от MSBuild,
+                     Примечание: средство ведения журнала не собирает исходные файлы, не от MSBuild,
                      например с расширениями CS, CPP и др.
 
                      BINLOG-файл можно "воспроизвести", передав его в
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index f01b080e37d..020b4a91f03 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1996,6 +1996,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2034,28 +2042,36 @@
                      Varsayılan olarak, dosya geçerli dizinde bulunur ve "msbuild.binlog"
                      olarak adlandırılır. Daha sonra metin günlüklerini yeniden
                      yapılandırmak için kullanılabilen ve diğer analiz araçları tarafından
-                     kullanılan ikili günlüğü, derleme işleminin ayrıntılı bir açıklamasıdır.
-                     İkili günlüğü genellikle, en ayrıntılı metin tanılama düzeyi günlüklerden
+                     kullanılan ikili günlüğü, derleme işleminin ayrıntılı bir açıklamasıdır. İkili günlüğü genellikle, en ayrıntılı metin tanılama düzeyi günlüklerden
                      10-20 kat küçüktür ancak daha fazla bilgi içerir.
                      (Kısa biçim: -bl)
+                     
+
+                     İsteğe bağlı LogFile ikili günlüğün kaydedileceği yolu
+                     belirtir. Ayrı bir günlük dosyası oluşturmak için
+                     her derleme için "{}" belirteci
+                     yola eklenebilir, örneğin: LogFile=output-{}-log.binlog. Günlük 
+                     yolundaki her “{}” zaman damgası, çalışan işlem kimliği ve rastgele
+                     dize damgası kullanılarak benzersiz bir dize ile
+                     değiştirilir.
 
-                     İkili günlükçü varsayılan olarak, derleme sırasında karşılaşılan
-                     tüm içeri aktarılmış projeler ve hedef dosyalar dahil olmak üzere
-                     proje dosyalarının kaynak dosyalarını toplar. İsteğe bağlı
+                     İkili günlükçü varsayılan olarak, içe aktarılan
+                     tüm projeler ve derleme sırasında karşılaşılan hedef
+                     dosyalar da dahil olmak üzere proje dosyalarının kaynak metnini toplar. İsteğe bağlı
                      ProjectImports anahtarı bu davranışı denetler:
 
                       ProjectImports=None     - Proje içeri aktarmalarını
                                                 toplama.
-                      ProjectImports=Embed    - Proje içeri aktarmalarını günlük dosyasına
-                                                ekler.
+                      ProjectImports=Embed    - Proje içeri aktarmalarını
+                                                günlük dosyasına ekle.
                       ProjectImports=ZipFile  - Proje dosyalarını
-                                                çıkış.projectimports.zip
-                                                dosyasına kaydeder (burada çıkış, ikili
-                                                günlük dosyası adıyla aynı ada sahiptir).
+                                                output.projectimports.zip dosyasına
+                                                çıkış, ikili günlük dosyası adıyla
+                                                aynı ada sahiptir kaydet.
 
-                     ProjectImports için varsayılan ayar Embed’dir.
-                     Not: Günlükçü .cs, .cpp vb. MSBuild olmayan kaynak
-                     dosyaları toplamaz.
+                     ProjectImports varsayılan ayarı Ekle’dir.
+                     Not: Günlükçü .cs, .cpp vb. gibi MSBuild olmayan kaynak dosyalarını
+                     toplamaz.
 
                      Bir .binlog dosyası msbuild.exe’ye bir proje/çözüm
                      yerine bağımsız değişken olarak geçirilerek “yeniden oynatılabilir”.
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 0968a8a75fb..cd21bf6716b 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1992,6 +1992,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2027,38 +2035,49 @@
     </source>
         <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
                      将所有生成事件序列化为压缩的二进制文件。
-                     默认情况下该文件位于当前目录并且名为 "msbuild.binlog"。
-                     二进制日志是生成过程的详细描述，
-                     以后可将其于重新构建文本日志
-                     并由其他分析工具所使用。
-                     二进制日志通常比大多数详细的文本诊断级日志小 10 到 20 倍，
-                     但它可以包含更多信息。
+                     默认情况下，该文件位于当前目录中，名为
+                     "msbuild.binlog"。二进制日志是生成过程的详细描述
+，
+                     稍后可用于重新构造
+                     文本日志并供其他分析工具使用。二进制日志
+                     大小通常为最详细的文本诊断级别日志的 1/10 至 1/20，
+                     但它包含更多信息。
                      (缩写: -bl)
 
-                     默认情况下，二进制记录器收集项目文件的源文本，
-                     包括生成期间所有导入的
-                     项目和目标文件。可选的
+                     可选的 LogFile 指定保存二进制日志
+                     的路径。要为每个生成产生不同的日志文件
+，
+                     可以将令牌 "{}" 添加到
+                     路径中，例如: LogFile=output-{}-log.binlog。日志路径中的每个
+                     "{}" 都使用时间戳、正在运行的进程 ID 和
+                     随机字符串戳
+                     替换为唯一字符串。
+
+                     二进制记录器默认收集
+                     项目文件的源文本，包括生成期间遇到的
+                     所有导入项目和目标文件。可选
                      ProjectImports 开关控制此行为:
 
                       ProjectImports=None     - 不收集项目
-                                                导入项。
-                     ProjectImports=Embed    - 在日志文件中
-                                                 嵌入项目导入项。
-                    ProjectImports=ZipFile  - 将项目文件保存到
-                                              output.projectimports.zip，
-                                                其中输出的名称
-                                                与二进制日志文件名称相同。
+                                                导入。
+                      ProjectImports=Embed    - 将项目导入嵌入到
+                                                日志文件中。
+                      ProjectImports=ZipFile - 将项目文件保存到
+                                                output.projectimports.zip
+，
+                                                其中输出的名称与
+                                                二进制日志文件名相同。
 
-                    ProjectImports 的默认设置为 Embed。
-                    注意: 记录器不会收集非 MSBuild 源文件，
-                    例如 .cs、.cpp 等。
+                     ProjectImports 的默认设置为 Embed。
+                     注意: 记录器不会收集非 MSBuild 源文件，
+                     例如 .cs、.cpp 等。
 
-                     可将 .binlog 文件以参数(而不是项目/解决方案)的形式传递给
-                   msbuild.exe 对其进行“播放”。
-                     其他记录器将接收日志文件中的信息，
-                    就像原始的生成正在发生一样。
-                    你可以通过以下网址阅读有关二进制文件及其用法的详细信息:
-                    https://aka.ms/msbuild/binlog
+                     可以通过将 .binlog 文件(而不是项目/解决方案)作为自变量传递给
+                     msbuild.exe 来“回放”该文件。
+                     其他记录器将收到日志文件中包含的信息，
+                     就像原始生成正在发生一样。
+                     有关二进制日志及其用法的详细信息，请参阅:
+                     https://aka.ms/msbuild/binlog
 
                      示例:
                        -bl
@@ -2067,7 +2086,7 @@
                        -bl:output.binlog;ProjectImports=ZipFile
                        -bl:..\..\custom.binlog
                        -binaryLogger
-</target>
+    </target>
         <note>
       LOCALIZATION: The following should not be localized:
       1) "msbuild"
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index b2b8fb45067..9fda517625b 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1993,6 +1993,14 @@
                      diagnostic-level log, but it contains more information.
                      (Short form: -bl)
 
+                     The optional LogFile specifies the path where the
+                     binary log is saved. To generate a distinct log file
+                     for each build, the token "{}" can be added into the
+                     path, for example: LogFile=output-{}-log.binlog. Each 
+                     "{}" in the log path is replaced with a unique string
+                     using the timestamp, running process Id and random
+                     string stamp.
+
                      The binary logger by default collects the source text of
                      project files, including all imported projects and target
                      files encountered during the build. The optional
@@ -2027,38 +2035,46 @@
                        -binaryLogger
     </source>
         <target state="translated">  -binaryLogger[:[LogFile=]output.binlog[;ProjectImports={None,Embed,ZipFile}]]
-                    將所有建置事件序列化成壓縮的二進位檔案。
-                     根據預設，此檔案存放在目前的目錄下，並會命名為
-                     「msbuild.binlog」。此二進位記錄檔是
-                     建置程序的詳細描述，之後可用於重建文字記錄，
-                     以及供其他分析工具使用。二進位記錄檔
-                     的大小通常會比大部分的詳細文字
-                     診斷層級記錄小 10-20 倍，但包含了更多資訊。
+                     將所有組建活動序列化為壓縮的二進位檔案。
+                     根據預設，檔案位於目前的目錄中，且名為
+                     "msbuild.binlog"。二進位記錄檔是詳細描述
+                     說明建組程序，這稍後可用來重新建構
+                     文字記錄檔，並用於其他分析工具。二進位記錄檔
+                     通常比最詳細文字診斷層級記錄檔小 10-20x
+                     ，但它包含更多資訊。
                      (簡短形式: -bl)
 
-                     根據預設，二進位記錄器會收集專案檔的
-                     原始程式文字，包括在建置期間遇到的
-                     所有匯入專案及目標檔案。選擇性的 ProjectImports 參數
-                     會控制此行為:
+                     選擇性的 LogFile 會指定儲存
+                     二進位記錄檔位置的路徑。若要針對每個組建，產生不同的記錄檔
+                     ，可以將權杖 "{}" 新增至
+                     路徑，例如: LogFile=output-{}-log.binlog。記錄檔路徑中的
+                     每個 "{}" 會使用時間戳記，取代為唯一字串
+                     執行程序識別碼和隨機
+                     字串戳記。
+
+                     二進位記錄程式預設會收集專案檔案的來源文字
+                     ，包括組建期間所發生的所有匯入的專案和目標
+                     檔案。選擇性
+                     ProjectImports 切換可控制此行為:
 
-                      ProjectImports=None     - 不收集專案
+                      ProjectImports=None     - 不要收集專案
                                                 匯入。
-                      ProjectImports=Embed    - 在記錄檔中內嵌
-                                                專案匯入。
-                      ProjectImports=ZipFile  - 將專案檔儲存到
-                                                output.projectimports.zip，
-                                                其中輸出的名稱與
-                                                二進位記錄檔名稱相同。
+                      ProjectImports=Embed    - 記錄檔中的
+                                                內嵌專案匯入。
+                      ProjectImports=ZipFile  - 將專案檔案儲存至
+                                                output.projectimports.zip
+                                                其中輸出與二進位檔案名稱具有
+                                                相同的名稱。
 
-                     ProjectImports 的預設設定為 Embed。
-                     注意: 記錄器不會收集非 MSBuild 的來源檔案，
+                     ProjectImports 的預設設定為 [內嵌]。
+                     注意: 記錄程式不會收集非 MSBuild 來源檔案
                      例如 .cs、.cpp 等。
 
-                     將 .binlog 檔案傳遞到 msbuild.exe 作為引數而非
-                     專案/解決方案，即可加以「播放」。
-                     其他記錄器會收到記錄檔中包含的資訊，
-                     就如同原始組建發生時的情況。
-                     若要深入閱讀二進位記錄檔及其使用方式，請前往:
+                     .binlog 檔案可以藉由將其傳遞至
+                     msbuild.exe 作為引數 (而不是專案/解決方案) 來 "回放"。
+                     其他記錄程式將會收到記錄檔中包含的資訊，
+                     就像發生原始組建那樣。
+                     您可以在以下位置閱讀更多關於二進位記錄及其使用方式:
                      https://aka.ms/msbuild/binlog
 
                      範例:
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 77637578738..f9006a5b5b2 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -35,6 +35,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Tasks.AssemblyDependency;
 using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
 using ConsoleLogger = Microsoft.Build.Logging.ConsoleLogger;
 using FileLogger = Microsoft.Build.Logging.FileLogger;
@@ -655,6 +656,9 @@ public static ExitType Execute(
         {
             DebuggerLaunchCheck();
 
+            // Resets the build completion event, signaling that a new build process is starting.
+            s_buildComplete.Reset();
+
             // Initialize new build telemetry and record start of this build, if not initialized already
             KnownTelemetry.PartialBuildTelemetry ??= new BuildTelemetry { StartAt = DateTime.UtcNow };
 
@@ -1536,6 +1540,11 @@ internal static bool BuildProject(
                         }
                     }
 
+                    if (Traits.Instance.EnableRarNode)
+                    {
+                        parameters.EnableRarNode = true;
+                    }
+
                     List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
 
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
@@ -3439,6 +3448,21 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches, bool
                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();
                     shutdownReason = node.Run(out nodeException);
                 }
+                else if (nodeModeNumber == 3)
+                {
+                    // The RAR service persists between builds, and will continue to process requests until terminated.
+                    OutOfProcRarNode rarNode = new();
+                    RarNodeShutdownReason rarShutdownReason = rarNode.Run(out nodeException, s_buildCancellationSource.Token);
+
+                    shutdownReason = rarShutdownReason switch
+                    {
+                        RarNodeShutdownReason.Complete => NodeEngineShutdownReason.BuildComplete,
+                        RarNodeShutdownReason.Error => NodeEngineShutdownReason.Error,
+                        RarNodeShutdownReason.AlreadyRunning => NodeEngineShutdownReason.Error,
+                        RarNodeShutdownReason.ConnectionTimedOut => NodeEngineShutdownReason.ConnectionFailed,
+                        _ => throw new ArgumentOutOfRangeException(nameof(rarShutdownReason), $"Unexpected value: {rarShutdownReason}"),
+                    };
+                }
                 else if (nodeModeNumber == 8)
                 {
                     // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 528707c3e22..4540c95d966 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -314,7 +314,7 @@
         <property name="RoslynTargetsPath" value="$([MSBuild]::GetToolsDirectory32())\Roslyn" />
 
         <!-- VC Specific Paths -->
-        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v170\'))" />
+        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v180\'))" />
         <property name="VCTargetsPath14" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath14)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V140\'))" />
         <property name="VCTargetsPath12" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath12)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V120\'))" />
         <property name="VCTargetsPath11" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath11)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V110\'))" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index cd0059bd3db..52cc9fa2af0 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -188,7 +188,7 @@
         <property name="RoslynTargetsPath" value="$([MSBuild]::GetToolsDirectory32())\Roslyn" />
 
         <!-- VC Specific Paths -->
-        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v170\'))" />
+        <property name="VCTargetsPath" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath)','$(MSBuildExtensionsPath32)\Microsoft\VC\v180\'))" />
         <property name="VCTargetsPath14" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath14)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V140\'))" />
         <property name="VCTargetsPath12" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath12)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V120\'))" />
         <property name="VCTargetsPath11" value="$([MSBuild]::ValueOrDefault('$(VCTargetsPath11)','$([MSBuild]::GetProgramFiles32())\MSBuild\Microsoft.Cpp\v4.0\V110\'))" />
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index f93696c6aba..b5071af538e 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -17,7 +17,7 @@ internal sealed class BuildEnvironmentHelper
     {
         // Since this class is added as 'link' to shared source in multiple projects,
         // MSBuildConstants.CurrentVisualStudioVersion is not available in all of them.
-        private const string CurrentVisualStudioVersion = "17.0";
+        private const string CurrentVisualStudioVersion = "18.0";
 
         // MSBuildConstants.CurrentToolsVersion
         private const string CurrentToolsVersion = "Current";
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index fe93672dee4..13d4f1bef25 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -91,7 +91,12 @@ internal class Handshake
         protected readonly int fileVersionPrivate;
         private readonly int sessionId;
 
-        protected internal Handshake(HandshakeOptions nodeType)
+        internal Handshake(HandshakeOptions nodeType)
+            : this(nodeType, includeSessionId: true)
+        {
+        }
+
+        protected Handshake(HandshakeOptions nodeType, bool includeSessionId)
         {
             const int handshakeVersion = (int)CommunicationsUtilities.handshakeVersion;
 
@@ -110,8 +115,13 @@ protected internal Handshake(HandshakeOptions nodeType)
             fileVersionMinor = fileVersion.Minor;
             fileVersionBuild = fileVersion.Build;
             fileVersionPrivate = fileVersion.Revision;
-            using Process currentProcess = Process.GetCurrentProcess();
-            sessionId = currentProcess.SessionId;
+
+            // This reaches out to NtQuerySystemInformation. Due to latency, allow skipping for derived handshake if unused.
+            if (includeSessionId)
+            {
+                using Process currentProcess = Process.GetCurrentProcess();
+                sessionId = currentProcess.SessionId;
+            }
         }
 
         // This is used as a key, so it does not need to be human readable.
@@ -149,7 +159,7 @@ internal sealed class ServerNodeHandshake : Handshake
         public override byte? ExpectedVersionInFirstByte => null;
 
         internal ServerNodeHandshake(HandshakeOptions nodeType)
-            : base(nodeType)
+            : base(nodeType, includeSessionId: false)
         {
         }
 
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 4aa800ef2d2..3418ad8b214 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -63,7 +63,7 @@ internal static class MSBuildConstants
         /// <summary>
         /// The most current Visual Studio Version known to this version of MSBuild.
         /// </summary>
-        internal const string CurrentVisualStudioVersion = "17.0";
+        internal const string CurrentVisualStudioVersion = "18.0";
 
         /// <summary>
         /// The most current ToolsVersion known to this version of MSBuild.
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 9d97c12de8d..56f9e88cba2 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -6,7 +6,11 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
+#if !NETFRAMEWORK
 using System.IO;
+#else
+using Microsoft.IO;
+#endif
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
@@ -2633,13 +2637,13 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
 
             // Ensure that the prefix match wasn't to a distinct directory, so that
             // x\y\prefix doesn't falsely match x\y\prefixmatch.
-            if (directorySeparatorCharacters.Contains(possibleParent[possibleParent.Length - 1]))
+            if (Array.IndexOf(directorySeparatorCharacters, possibleParent[possibleParent.Length - 1]) >= 0)
             {
                 return true;
             }
             else
             {
-                return directorySeparatorCharacters.Contains(possibleChild[possibleParent.Length]);
+                return Array.IndexOf(directorySeparatorCharacters, possibleChild[possibleParent.Length]) >= 0;
             }
         }
 
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 506ba750ab3..cd6e22d4b6f 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -73,9 +73,10 @@ internal static class FrameworkLocationHelper
         internal static readonly Version visualStudioVersion150 = new Version(15, 0);
         internal static readonly Version visualStudioVersion160 = new Version(16, 0);
         internal static readonly Version visualStudioVersion170 = new Version(17, 0);
+        internal static readonly Version visualStudioVersion180 = new Version(18, 0);
 
         // keep this up-to-date; always point to the latest visual studio version.
-        internal static readonly Version visualStudioVersionLatest = visualStudioVersion170;
+        internal static readonly Version visualStudioVersionLatest = visualStudioVersion180;
 
         private const string dotNetFrameworkRegistryPath = "SOFTWARE\\Microsoft\\.NETFramework";
         private const string dotNetFrameworkSetupRegistryPath = "SOFTWARE\\Microsoft\\NET Framework Setup\\NDP";
@@ -335,6 +336,26 @@ private static DotNetFrameworkSpec[] DotNetFrameworkSpecs() =>
                 dotNetFrameworkVersion48,
                 dotNetFrameworkVersion481,
             ]),
+
+             // VS18
+            new VisualStudioSpec(visualStudioVersion180, "NETFXSDK\\{0}", "v10.0", "InstallationFolder",
+            [
+                dotNetFrameworkVersion11,
+                dotNetFrameworkVersion20,
+                dotNetFrameworkVersion35,
+                dotNetFrameworkVersion40,
+                dotNetFrameworkVersion45,
+                dotNetFrameworkVersion451,
+                dotNetFrameworkVersion452,
+                dotNetFrameworkVersion46,
+                dotNetFrameworkVersion461,
+                dotNetFrameworkVersion462,
+                dotNetFrameworkVersion47,
+                dotNetFrameworkVersion471,
+                dotNetFrameworkVersion472,
+                dotNetFrameworkVersion48,
+                dotNetFrameworkVersion481,
+            ]),
         ]);
 
 #if FEATURE_WIN32_REGISTRY
@@ -392,6 +413,18 @@ private static readonly (Version, Version)[,] s_explicitFallbackRulesForPathToDo
             { (dotNetFrameworkVersion472, visualStudioVersion170), (dotNetFrameworkVersion471, visualStudioVersion170) },
             { (dotNetFrameworkVersion48, visualStudioVersion170), (dotNetFrameworkVersion472, visualStudioVersion170) },
             { (dotNetFrameworkVersion481, visualStudioVersion170), (dotNetFrameworkVersion48, visualStudioVersion170) },
+
+            // VS 18
+            { (dotNetFrameworkVersion451, visualStudioVersion180), (dotNetFrameworkVersion45, visualStudioVersion180) },
+            { (dotNetFrameworkVersion452, visualStudioVersion180), (dotNetFrameworkVersion451, visualStudioVersion180) },
+            { (dotNetFrameworkVersion46, visualStudioVersion180), (dotNetFrameworkVersion451, visualStudioVersion180) },
+            { (dotNetFrameworkVersion461, visualStudioVersion180), (dotNetFrameworkVersion46, visualStudioVersion180) },
+            { (dotNetFrameworkVersion462, visualStudioVersion180), (dotNetFrameworkVersion461, visualStudioVersion180) },
+            { (dotNetFrameworkVersion47, visualStudioVersion180), (dotNetFrameworkVersion462, visualStudioVersion180) },
+            { (dotNetFrameworkVersion471, visualStudioVersion180), (dotNetFrameworkVersion47, visualStudioVersion180) },
+            { (dotNetFrameworkVersion472, visualStudioVersion180), (dotNetFrameworkVersion471, visualStudioVersion180) },
+            { (dotNetFrameworkVersion48, visualStudioVersion180), (dotNetFrameworkVersion472, visualStudioVersion180) },
+            { (dotNetFrameworkVersion481, visualStudioVersion180), (dotNetFrameworkVersion48, visualStudioVersion180) },
         };
 #endif // FEATURE_WIN32_REGISTRY
 
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index 42b6a8d6ab6..b72e32efb4c 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -200,6 +200,16 @@ internal enum NodePacketType : byte
         /// </summary>
         ProcessReport,
 
+        /// <summary>
+        /// A request contains the inputs to the RAR task.
+        /// </summary>
+        RarNodeExecuteRequest,
+
+        /// <summary>
+        /// A request contains the outputs and log events of a completed RAR task.
+        /// </summary>
+        RarNodeExecuteResponse,
+
         /// <summary>
         /// Command in form of MSBuild command line for server node - MSBuild Server.
         /// Keep this enum value constant intact as this is part of contract with dotnet CLI
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index 25094e59035..0b85b05bacd 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.IO;
+using Microsoft.Build.Internal;
 
 namespace Microsoft.Build.Shared
 {
@@ -42,5 +43,11 @@ internal static string GetPlatformSpecificPipeName(string pipeName)
                 return pipeName;
             }
         }
+
+        internal static string GetRarNodePipeName(ServerNodeHandshake handshake)
+            => GetPlatformSpecificPipeName($"MSBuildRarNode-{handshake.ComputeHash()}");
+
+        internal static string GetRarNodeEndpointPipeName(ServerNodeHandshake handshake)
+            => GetPlatformSpecificPipeName($"MSBuildRarNodeEndpoint-{handshake.ComputeHash()}");
     }
 }
diff --git a/src/Shared/NodePipeBase.cs b/src/Shared/NodePipeBase.cs
index fd1d08efe9c..2ee91e536c1 100644
--- a/src/Shared/NodePipeBase.cs
+++ b/src/Shared/NodePipeBase.cs
@@ -69,6 +69,14 @@ protected NodePipeBase(string pipeName, Handshake handshake)
             _writeTranslator = BinaryTranslator.GetWriteTranslator(_writeBuffer);
         }
 
+        /// <summary>
+        /// Gets a value indicating whether the pipe is in the connected state. Note that this is not real-time and
+        /// will only be updated when an operation on the pipe fails.
+        /// When a pipe is broken, Disconnect() must be called for the pipe to be reused - otherwise any attempts to
+        /// connect to a new client will throw.
+        /// </summary>
+        internal bool IsConnected => NodeStream.IsConnected;
+
         protected abstract PipeStream NodeStream { get; }
 
         protected string PipeName { get; }
diff --git a/src/Shared/NodePipeServer.cs b/src/Shared/NodePipeServer.cs
index eb932d973aa..0b9855f2a1c 100644
--- a/src/Shared/NodePipeServer.cs
+++ b/src/Shared/NodePipeServer.cs
@@ -47,7 +47,14 @@ internal NodePipeServer(string pipeName, Handshake handshake, int maxNumberOfSer
             // SIDs or the client will reject this server.  This is used to avoid attacks where a
             // hacked server creates a less restricted pipe in an attempt to lure us into using it and
             // then sending build requests to the real pipe client (which is the MSBuild Build Manager.)
-            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, PipeAccessRights.ReadWrite, AccessControlType.Allow);
+            PipeAccessRights pipeAccessRights = PipeAccessRights.ReadWrite;
+            if (maxNumberOfServerInstances > 1)
+            {
+                // Multi-instance pipes will fail without this flag.
+                pipeAccessRights |= PipeAccessRights.CreateNewInstance;
+            }
+
+            PipeAccessRule rule = new(WindowsIdentity.GetCurrent().Owner, pipeAccessRights, AccessControlType.Allow);
             PipeSecurity security = new();
             security.AddAccessRule(rule);
             security.SetOwner(rule.IdentityReference);
diff --git a/src/Tasks.UnitTests/OutputPathTests.cs b/src/Tasks.UnitTests/OutputPathTests.cs
index 1bf85cccef8..b1b897c20dc 100644
--- a/src/Tasks.UnitTests/OutputPathTests.cs
+++ b/src/Tasks.UnitTests/OutputPathTests.cs
@@ -43,19 +43,21 @@ public void BothBaseOutputPathAndOutputPathWereNotSpecified()
             var baseOutputPath = "bin";
 
             var projectFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath,
-$@"<Project DefaultTargets=`Build` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>
+            $"""
+            <Project DefaultTargets="Build" xmlns="msbuildnamespace" ToolsVersion="msbuilddefaulttoolsversion">
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.props`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.props"/>
 
-    <PropertyGroup>
-        <Platform>AnyCPU</Platform>
-        <Configuration>Debug</Configuration>
-    </PropertyGroup>
+                <PropertyGroup>
+                    <Platform>AnyCPU</Platform>
+                    <Configuration>Debug</Configuration>
+                </PropertyGroup>
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.targets`/>
-    <Target Name=`Build`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.targets"/>
+                <Target Name="Build"/>
 
-</Project>");
+            </Project>
+            """);
 
             // Act
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFilePath, touchProject: false);
@@ -78,20 +80,22 @@ public void BaseOutputPathWasSpecifiedAndIsOverridable()
             var baseOutputPath = Path.Combine("build", "bin");
 
             var projectFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath,
-$@"<Project DefaultTargets=`Build` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>
+            $"""
+            <Project DefaultTargets="Build" xmlns="msbuildnamespace" ToolsVersion="msbuilddefaulttoolsversion">
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.props`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.props"/>
 
-    <PropertyGroup>
-        <Platform>AnyCPU</Platform>
-        <Configuration>Debug</Configuration>
-        <BaseOutputPath>{baseOutputPath}</BaseOutputPath>
-    </PropertyGroup>
+                <PropertyGroup>
+                    <Platform>AnyCPU</Platform>
+                    <Configuration>Debug</Configuration>
+                    <BaseOutputPath>{baseOutputPath}</BaseOutputPath>
+                </PropertyGroup>
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.targets`/>
-    <Target Name=`Build`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.targets"/>
+                <Target Name="Build"/>
 
-</Project>");
+            </Project>
+            """);
 
             // Act
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFilePath, touchProject: false);
@@ -116,25 +120,27 @@ public void BothBaseOutputPathAndOutputPathWereSpecified()
             var outputPathAlt = Path.Combine("bin", "Release");
 
             var projectFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath,
-$@"<Project DefaultTargets=`Build` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>
+            $"""
+            <Project DefaultTargets="Build" xmlns="msbuildnamespace" ToolsVersion="msbuilddefaulttoolsversion">
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.props`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.props"/>
 
-    <PropertyGroup>
-        <Platform>AnyCPU</Platform>
-        <Configuration>Debug</Configuration>
-    </PropertyGroup>
+                <PropertyGroup>
+                    <Platform>AnyCPU</Platform>
+                    <Configuration>Debug</Configuration>
+                </PropertyGroup>
 
-    <PropertyGroup>
-        <BaseOutputPath>{baseOutputPath}</BaseOutputPath>
-        <OutputPath Condition=`'$(Platform)|$(Configuration)' == 'AnyCPU|Debug'`>{outputPath}</OutputPath>
-        <OutputPath Condition=`'$(Platform)|$(Configuration)' == 'AnyCPU|Release'`>{outputPathAlt}</OutputPath>
-    </PropertyGroup>
+                <PropertyGroup>
+                    <BaseOutputPath>{baseOutputPath}</BaseOutputPath>
+                    <OutputPath Condition="'$(Platform)|$(Configuration)' == 'AnyCPU|Debug'">{outputPath}</OutputPath>
+                    <OutputPath Condition="'$(Platform)|$(Configuration)' == 'AnyCPU|Release'">{outputPathAlt}</OutputPath>
+                </PropertyGroup>
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.targets`/>
-    <Target Name=`Build`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.targets"/>
+                <Target Name="Build"/>
 
-</Project>");
+            </Project>
+            """);
 
             // Act
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFilePath, touchProject: false);
@@ -159,18 +165,20 @@ public void MSBuildNormalizePathShouldReturnProjectDirectory()
             var baseOutputPath = "bin";
 
             var projectFilePath = ObjectModelHelpers.CreateFileInTempProjectDirectory(_projectRelativePath,
-$@"<Project DefaultTargets=`Build` xmlns=`msbuildnamespace` ToolsVersion=`msbuilddefaulttoolsversion`>
+            $"""
+            <Project DefaultTargets="Build" xmlns="msbuildnamespace" ToolsVersion="msbuilddefaulttoolsversion">
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.props`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.props"/>
 
-    <PropertyGroup Condition=`'$(OutputPath)' == ''`>
-        <OutputPath>$([MSBuild]::NormalizeDirectory('{baseOutputPath}', '{configuration}'))</OutputPath>
-    </PropertyGroup>
+                <PropertyGroup Condition="'$(OutputPath)' == ''">
+                    <OutputPath>$([MSBuild]::NormalizeDirectory('{baseOutputPath}', '{configuration}'))</OutputPath>
+                </PropertyGroup>
 
-    <Import Project=`$(MSBuildToolsPath)\Microsoft.Common.targets`/>
-    <Target Name=`Build`/>
+                <Import Project="$(MSBuildToolsPath)\Microsoft.Common.targets"/>
+                <Target Name="Build"/>
 
-</Project>");
+            </Project>
+            """);
 
             // Act
             Project project = ObjectModelHelpers.LoadProjectFileInTempProjectDirectory(projectFilePath, touchProject: false);
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs
new file mode 100644
index 00000000000..4cfd2f053ee
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarClient.cs
@@ -0,0 +1,70 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a client for sending the ResolveAssemblyReference task to an out-of-proc node.
+    /// This is intended to be reused for all RAR tasks across a single build.
+    /// </summary>
+    internal sealed class OutOfProcRarClient : IDisposable
+    {
+        private readonly NodePipeClient _pipeClient;
+
+        private OutOfProcRarClient()
+        {
+            ServerNodeHandshake handshake = new(HandshakeOptions.None);
+            _pipeClient = new NodePipeClient(NamedPipeUtil.GetRarNodeEndpointPipeName(handshake), handshake);
+
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteResponse, RarNodeExecuteResponse.FactoryForDeserialization, null);
+            _pipeClient.RegisterPacketFactory(packetFactory);
+        }
+
+        public void Dispose() => _pipeClient.Dispose();
+
+        internal static OutOfProcRarClient GetInstance(IBuildEngine10 buildEngine)
+        {
+            // Create a single cached instance for this build.
+            const string OutOfProcRarClientKey = "OutOfProcRarClient";
+
+            // We want to reuse the pipe client across all RAR invocations within a build, but release the connection once
+            // the MSBuild node is idle. Using RegisteredTaskObjectLifetime.Build ensures that the RAR client is disposed between
+            // builds, freeing the server to run other requests.
+            OutOfProcRarClient rarClient = (OutOfProcRarClient)buildEngine.GetRegisteredTaskObject(OutOfProcRarClientKey, RegisteredTaskObjectLifetime.Build);
+
+            if (rarClient == null)
+            {
+                rarClient = new OutOfProcRarClient();
+                buildEngine.RegisterTaskObject(OutOfProcRarClientKey, rarClient, RegisteredTaskObjectLifetime.Build, allowEarlyCollection: false);
+                CommunicationsUtilities.Trace("Initialized new RAR client.");
+            }
+
+            return rarClient;
+        }
+
+        internal bool Execute(ResolveAssemblyReference rarTask)
+        {
+            // This should only be true at the start of a build.
+            if (!_pipeClient.IsConnected)
+            {
+                // Don't set a timeout since the build manager already blocks until the server is running.
+                _pipeClient.ConnectToServer(0);
+            }
+
+            // TODO: Use RAR task to create the request packet.
+            _pipeClient.WritePacket(new RarNodeExecuteRequest());
+
+            // TODO: Use response packet to set RAR task outputs.
+            _ = (RarNodeExecuteResponse)_pipeClient.ReadPacket();
+
+            return true;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs
new file mode 100644
index 00000000000..12d03329609
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNode.cs
@@ -0,0 +1,179 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a persistent node for the ResolveAssemblyReferences task.
+    /// This manages the lifecycle of the multi-instance pipe server which executes RAR requests
+    /// and does not invoke the task itself.
+    /// </summary>
+    public sealed class OutOfProcRarNode
+    {
+        private readonly ServerNodeHandshake _handshake = new(HandshakeOptions.None);
+
+        private readonly int _maxNumberOfConcurrentTasks;
+
+        public OutOfProcRarNode()
+            : this(Environment.ProcessorCount)
+        {
+        }
+
+        public OutOfProcRarNode(int maxNumberOfConcurrentTasks) => _maxNumberOfConcurrentTasks = maxNumberOfConcurrentTasks;
+
+        /// <summary>
+        /// Starts the node and begins processing RAR execution requests until cancelled.
+        /// </summary>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param>
+        /// <param name="cancellationToken">A cancellation token to observe while running the node loop.</param>
+        /// <returns>The reason for the node shutdown.</returns>
+        public RarNodeShutdownReason Run(out Exception? shutdownException, CancellationToken cancellationToken = default)
+        {
+            RarNodeShutdownReason shutdownReason;
+            shutdownException = null;
+
+            try
+            {
+                shutdownReason = RunNodeAsync(cancellationToken).GetAwaiter().GetResult();
+            }
+            catch (OperationCanceledException)
+            {
+                // Consider cancellation as an intentional shutdown of the node.
+                shutdownReason = RarNodeShutdownReason.Complete;
+            }
+            catch (UnauthorizedAccessException ex)
+            {
+                // Access to the path is denied if the named pipe already exists or is owned by a different user.
+                shutdownException = new InvalidOperationException("RAR node is already running.", ex);
+                shutdownReason = RarNodeShutdownReason.AlreadyRunning;
+            }
+            catch (Exception ex)
+            {
+                shutdownException = ex;
+                shutdownReason = RarNodeShutdownReason.Error;
+            }
+
+            if (shutdownException == null)
+            {
+                CommunicationsUtilities.Trace("Shutting down with reason: {0}");
+            }
+            else
+            {
+                CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}", shutdownReason, shutdownException);
+            }
+
+            return shutdownReason;
+        }
+
+        private async Task<RarNodeShutdownReason> RunNodeAsync(CancellationToken cancellationToken)
+        {
+            // The RAR node uses two sets of pipe servers:
+            // 1. A single instance pipe to manage the lifecycle of the node.
+            // 2. A multi-instance pipe to execute concurrent RAR requests.
+            // Because multi-instance pipes can live across multiple processes, we can't rely on the instance cap to preven
+            // multiple nodes from running in the event of a race condition.
+            // This also simplifies tearing down all active pipe servers when shutdown is requested.
+            using NodePipeServer pipeServer = new(NamedPipeUtil.GetRarNodePipeName(_handshake), _handshake);
+
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, null);
+            pipeServer.RegisterPacketFactory(packetFactory);
+
+            using CancellationTokenSource linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
+
+            Task nodeEndpointTasks = Task.Run(() => RunNodeEndpointsAsync(linkedCts.Token), linkedCts.Token);
+
+            // Run any static initializers which will add latency to the first task run.
+            _ = new ResolveAssemblyReference();
+
+            while (!cancellationToken.IsCancellationRequested)
+            {
+                LinkStatus linkStatus = await WaitForConnection(pipeServer, cancellationToken);
+
+                if (linkStatus == LinkStatus.Active)
+                {
+                    NodeBuildComplete buildComplete = (NodeBuildComplete)pipeServer.ReadPacket();
+
+                    if (!buildComplete.PrepareForReuse)
+                    {
+                        break;
+                    }
+                }
+
+                pipeServer.Disconnect();
+            }
+
+            // Gracefully shutdown the node endpoints.
+            linkedCts.Cancel();
+
+            try
+            {
+                await nodeEndpointTasks;
+            }
+            catch (OperationCanceledException)
+            {
+                // Ignore since cancellation is expected.
+            }
+
+            return RarNodeShutdownReason.Complete;
+
+            // WaitForConnection does not currently accept cancellation, so use Wait to watch for cancellation.
+            // Cancellation is only expected when MSBuild is gracefully shutting down the node or running in unit tests.
+            static async Task<LinkStatus> WaitForConnection(NodePipeServer pipeServer, CancellationToken cancellationToken)
+            {
+                Task<LinkStatus> linkStatusTask = Task.Run(pipeServer.WaitForConnection);
+                linkStatusTask.Wait(cancellationToken);
+                return await linkStatusTask;
+            }
+        }
+
+        private async Task RunNodeEndpointsAsync(CancellationToken cancellationToken)
+        {
+            // Setup data shared between all endpoints.
+            string pipeName = NamedPipeUtil.GetRarNodeEndpointPipeName(_handshake);
+            NodePacketFactory packetFactory = new();
+            packetFactory.RegisterPacketHandler(NodePacketType.RarNodeExecuteRequest, RarNodeExecuteRequest.FactoryForDeserialization, null);
+
+            OutOfProcRarNodeEndpoint[] endpoints = new OutOfProcRarNodeEndpoint[_maxNumberOfConcurrentTasks];
+
+            // Validate all endpoint pipe handles successfully initialize before running any read loops.
+            // This allows us to bail out in the event where we can't control every pipe instance.
+            for (int i = 0; i < endpoints.Length; i++)
+            {
+                endpoints[i] = new OutOfProcRarNodeEndpoint(
+                        endpointId: i + 1,
+                        pipeName,
+                        _handshake,
+                        _maxNumberOfConcurrentTasks,
+                        packetFactory);
+            }
+
+            Task[] endpointTasks = new Task[endpoints.Length];
+
+            for (int i = 0; i < endpoints.Length; i++)
+            {
+                // Avoid capturing the indexer in the closure.
+                OutOfProcRarNodeEndpoint endpoint = endpoints[i];
+                endpointTasks[i] = Task.Run(() => endpoint.RunAsync(cancellationToken), cancellationToken);
+            }
+
+            CommunicationsUtilities.Trace("{0} RAR endpoints started.", _maxNumberOfConcurrentTasks);
+
+            await Task.WhenAll(endpointTasks);
+
+            foreach (OutOfProcRarNodeEndpoint endpoint in endpoints)
+            {
+                endpoint.Dispose();
+            }
+
+            CommunicationsUtilities.Trace("All endpoints successfully stopped. Exiting.");
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs
new file mode 100644
index 00000000000..666ce49b5c5
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/OutOfProcRarNodeEndpoint.cs
@@ -0,0 +1,97 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Implements a single instance of a pipe server which executes the ResolveAssemblyReference task.
+    /// </summary>
+    internal sealed class OutOfProcRarNodeEndpoint : IDisposable
+    {
+        private readonly int _endpointId;
+
+        private readonly NodePipeServer _pipeServer;
+
+        internal OutOfProcRarNodeEndpoint(
+            int endpointId,
+            string pipeName,
+            ServerNodeHandshake handshake,
+            int maxNumberOfServerInstances,
+            NodePacketFactory packetFactory)
+        {
+            _endpointId = endpointId;
+            _pipeServer = new NodePipeServer(pipeName, handshake, maxNumberOfServerInstances);
+            _pipeServer.RegisterPacketFactory(packetFactory);
+        }
+
+        public void Dispose() => _pipeServer.Dispose();
+
+        internal async Task RunAsync(CancellationToken cancellationToken = default)
+        {
+            CommunicationsUtilities.Trace("({0}) Starting RAR endpoint.", _endpointId);
+
+            try
+            {
+                await RunInternalAsync(cancellationToken);
+            }
+            catch (OperationCanceledException)
+            {
+                // Swallow cancellation excpetions for now. We're using this as a simple way to gracefully shutdown the
+                // endpoint, instead of having to implement separate Start / Stop methods and deferring to the caller.
+                // Can reevaluate if we need more granular control over cancellation vs shutdown.
+                CommunicationsUtilities.Trace("({0}) RAR endpoint stopped due to cancellation.", _endpointId);
+            }
+        }
+
+        private async Task RunInternalAsync(CancellationToken cancellationToken)
+        {
+            while (!cancellationToken.IsCancellationRequested)
+            {
+                while (!_pipeServer.IsConnected)
+                {
+                    _ = _pipeServer.WaitForConnection();
+                }
+
+                CommunicationsUtilities.Trace("({0}) Received RAR request.", _endpointId);
+
+                try
+                {
+                    INodePacket packet = await _pipeServer.ReadPacketAsync(cancellationToken);
+
+                    if (packet.Type == NodePacketType.NodeShutdown)
+                    {
+                        // Although the client has already disconnected, it is still necessary to Diconnect() so the
+                        // pipe can transition into PipeState.Disonnected, which is treated as an intentional pipe break.
+                        // Otherwise, all future operations on the pipe will throw an exception.
+                        CommunicationsUtilities.Trace("({0}) RAR client disconnected.", _endpointId);
+                        _pipeServer.Disconnect();
+                        continue;
+                    }
+
+                    RarNodeExecuteRequest request = (RarNodeExecuteRequest)packet;
+
+                    // TODO: Use request packet to set inputs on the RAR task.
+                    ResolveAssemblyReference rarTask = new();
+
+                    // TODO: bool success = rarTask.ExecuteInProcess();
+                    // TODO: Use RAR task outputs to create response packet.
+                    await _pipeServer.WritePacketAsync(new RarNodeExecuteResponse(), cancellationToken);
+
+                    CommunicationsUtilities.Trace("({0}) Completed RAR request.", _endpointId);
+                }
+                catch (Exception e) when (e is not OperationCanceledException)
+                {
+                    CommunicationsUtilities.Trace("({0}) Exception while executing RAR request: {1}", _endpointId, e);
+                }
+            }
+
+            _pipeServer.Disconnect();
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs
new file mode 100644
index 00000000000..a129bd56748
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteRequest.cs
@@ -0,0 +1,23 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    internal sealed class RarNodeExecuteRequest : INodePacket
+    {
+        public NodePacketType Type => NodePacketType.RarNodeExecuteRequest;
+
+        public void Translate(ITranslator translator)
+        {
+        }
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            RarNodeExecuteRequest request = new();
+            request.Translate(translator);
+            return request;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs
new file mode 100644
index 00000000000..9611897fc82
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeExecuteResponse.cs
@@ -0,0 +1,23 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Microsoft.Build.BackEnd;
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    internal sealed class RarNodeExecuteResponse : INodePacket
+    {
+        public NodePacketType Type => NodePacketType.RarNodeExecuteResponse;
+
+        public void Translate(ITranslator translator)
+        {
+        }
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            RarNodeExecuteResponse response = new();
+            response.Translate(translator);
+            return response;
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs b/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs
new file mode 100644
index 00000000000..67b37177e4a
--- /dev/null
+++ b/src/Tasks/AssemblyDependency/Node/RarNodeShutdownReason.cs
@@ -0,0 +1,31 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+namespace Microsoft.Build.Tasks.AssemblyDependency
+{
+    /// <summary>
+    /// Reasons why the RAR node shutdown.
+    /// </summary>
+    public enum RarNodeShutdownReason
+    {
+        /// <summary>
+        /// The RAR node was instructed to terminate and gracefully shut down.
+        /// </summary>
+        Complete,
+
+        /// <summary>
+        /// The RAR node is already running.
+        /// </summary>
+        AlreadyRunning,
+
+        /// <summary>
+        /// The RAR node timed out waiting for a connection.
+        /// </summary>
+        ConnectionTimedOut,
+
+        /// <summary>
+        /// The RAR node encountered an unrecoverable error.
+        /// </summary>
+        Error,
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 8a42269ce14..21c3811e476 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -16,6 +16,7 @@
 
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyDependency;
@@ -920,6 +921,11 @@ public string[] FullFrameworkFolders
 
         public bool FailIfNotIncremental { get; set; }
 
+        /// <summary>
+        /// Allow the task to run on the out-of-proc node if enabled for this build.
+        /// </summary>
+        public bool AllowOutOfProcNode { get; set; }
+
         /// <summary>
         /// This is a list of all primary references resolved to full paths.
         ///     bool CopyLocal - whether the given reference should be copied to the output directory.
@@ -3243,6 +3249,25 @@ private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, SystemPr
         /// <returns>True if there was success.</returns>
         public override bool Execute()
         {
+            if (AllowOutOfProcNode
+                && BuildEngine is IBuildEngine10 buildEngine10
+                && buildEngine10.EngineServices.IsOutOfProcRarNodeEnabled)
+            {
+                try
+                {
+#pragma warning disable CA2000 // The OutOfProcRarClient is disposable but its disposal is handled by RegisterTaskObject.
+                    _ = OutOfProcRarClient.GetInstance(buildEngine10).Execute(this);
+#pragma warning restore CA2000 // Dispose objects before losing scope
+                    CommunicationsUtilities.Trace("RAR out-of-proc test connection completed. Executing task in-proc.");
+                }
+                catch (Exception ex)
+                {
+                    // If the out-of-proc connection failed, fall back to in-proc.
+                    // TODO: Disable out-of-proc for the remainder of the build if any connection fails.
+                    CommunicationsUtilities.Trace("RAR out-of-proc connection failed, failing back to in-proc. Exception: {0}", ex);
+                }
+            }
+
             return Execute(
                 p => FileUtilities.FileExistsNoThrow(p),
                 p => FileUtilities.DirectoryExistsNoThrow(p),
@@ -3265,7 +3290,6 @@ public override bool Execute()
                     => AssemblyInformation.IsWinMDFile(fullPath, getAssemblyRuntimeVersion, fileExists, out imageRuntimeVersion, out isManagedWinmd),
                 p => ReferenceTable.ReadMachineTypeFromPEHeader(p));
         }
-
         #endregion
     }
 }
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 9028bd1f386..1e32984bd73 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -169,7 +169,7 @@ private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
 #endif
                     }
 
-                    if (!TryGetFileName(response, out string filename))
+                    if (!TryGetFileName(uri, out string filename))
                     {
                         Log.LogErrorWithCodeFromResources("DownloadFile.ErrorUnknownFileName", SourceUrl, nameof(DestinationFileName));
                         return;
@@ -308,25 +308,24 @@ private static bool IsRetriable(Exception exception, out Exception actualExcepti
         /// <summary>
         /// Attempts to get the file name to use when downloading the file.
         /// </summary>
-        /// <param name="response">The <see cref="HttpResponseMessage"/> with information about the response.</param>
+        /// <param name="requestUri">The uri we sent request to.</param>
         /// <param name="filename">Receives the name of the file.</param>
         /// <returns><code>true</code> if a file name could be determined, otherwise <code>false</code>.</returns>
-        private bool TryGetFileName(HttpResponseMessage response, out string filename)
+        private bool TryGetFileName(Uri requestUri, out string filename)
         {
-            if (response == null)
+            if (requestUri == null)
             {
-                throw new ArgumentNullException(nameof(response));
+                throw new ArgumentNullException(nameof(requestUri));
             }
 
             // Not all URIs contain a file name so users will have to specify one
             // Example: http://www.download.com/file/1/
 
-            filename = !String.IsNullOrWhiteSpace(DestinationFileName?.ItemSpec)
+            filename = !string.IsNullOrWhiteSpace(DestinationFileName?.ItemSpec)
                 ? DestinationFileName.ItemSpec // Get the file name from what the user specified
-                : response.Content?.Headers?.ContentDisposition?.FileName // Attempt to get the file name from the content-disposition header value
-                  ?? Path.GetFileName(response.RequestMessage.RequestUri.LocalPath); // Otherwise attempt to get a file name from the URI
+                : Path.GetFileName(requestUri.LocalPath); // Otherwise attempt to get a file name from the URI
 
-            return !String.IsNullOrWhiteSpace(filename);
+            return !string.IsNullOrWhiteSpace(filename);
         }
 
 #if !NET
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index a518f22fe8b..48d3df90c79 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -34,6 +34,20 @@
     <!-- Binary serialization by ITranslatable -->
     <Compile Include="..\Shared\InterningBinaryReader.cs" />
     <Compile Include="..\Shared\TranslatorHelpers.cs" />
+
+    <!-- Node communication -->
+    <Compile Include="..\Shared\CommunicationsUtilities.cs" />
+    <Compile Include="..\Shared\INodeEndpoint.cs" />
+    <Compile Include="..\Shared\INodePacket.cs" />
+    <Compile Include="..\Shared\INodePacketFactory.cs" />
+    <Compile Include="..\Shared\INodePacketHandler.cs" />
+    <Compile Include="..\Shared\NodeBuildComplete.cs" />
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
+    <Compile Include="..\Shared\NodePacketFactory.cs" />
+    <Compile Include="..\Shared\NodePipeBase.cs" />
+    <Compile Include="..\Shared\NodePipeClient.cs" />
+    <Compile Include="..\Shared\NodePipeServer.cs" />
+    <Compile Include="..\Shared\NodeShutdown.cs" />
   </ItemGroup>
   <ItemGroup>
     <!-- Source Files -->
@@ -183,6 +197,12 @@
     <Compile Include="AssemblyDependency\UnificationVersion.cs" />
     <Compile Include="AssemblyDependency\UnifiedAssemblyName.cs" />
     <Compile Include="AssemblyDependency\WarnOrErrorOnTargetArchitectureMismatchBehavior.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarClient.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarNode.cs" />
+    <Compile Include="AssemblyDependency\Node\OutOfProcRarNodeEndpoint.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeExecuteRequest.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeExecuteResponse.cs" />
+    <Compile Include="AssemblyDependency\Node\RarNodeShutdownReason.cs" />
     <Compile Include="AssemblyFolder.cs" />
     <Compile Include="AssemblyInfo.cs" />
     <Compile Include="AssemblyRemapping.cs" />
@@ -676,6 +696,7 @@
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
     <PackageReference Include="Microsoft.Win32.Registry" />
     <PackageReference Include="System.Reflection.Metadata" />
+    <PackageReference Include="System.Threading.Channels" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 0c4ce55ad13..bc197ee04a5 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -2385,6 +2385,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <ResolveAssemblyReferencesStateFile Condition="'$(DisableRarCache)'!='true' and '$(ResolveAssemblyReferencesStateFile)' == ''">$(IntermediateOutputPath)$(MSBuildProjectFile).AssemblyReference.cache</ResolveAssemblyReferencesStateFile>
     </PropertyGroup>
 
+    <PropertyGroup>
+      <AllowResolveAssemblyReferencesOutOfProcNode Condition="'$(AllowResolveAssemblyReferencesOutOfProcNode)' == ''">false</AllowResolveAssemblyReferencesOutOfProcNode>
+    </PropertyGroup>
+
     <!-- Make an App.Config item that exists when AutoUnify is false. -->
     <ItemGroup>
       <_ResolveAssemblyReferencesApplicationConfigFileForExes Include="@(AppConfigWithTargetPath)" Condition="'$(AutoGenerateBindingRedirects)'=='true' or '$(AutoUnifyAssemblyReferences)'=='false'"/>
@@ -2476,6 +2480,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         OutputUnresolvedAssemblyConflicts="$(ResolveAssemblyReferenceOutputUnresolvedAssemblyConflicts)"
         NonCultureResourceDirectories="@(NonCultureResourceDirectory)"
         EnableCustomCulture="$(EnableCustomCulture)"
+        AllowOutOfProcNode="$(AllowResolveAssemblyReferencesOutOfProcNode)"
         Condition="'@(Reference)'!='' or '@(_ResolvedProjectReferencePaths)'!='' or '@(_ExplicitReference)' != ''"
         >
 
@@ -2580,24 +2585,6 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <AppConfig Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">$(_GenerateBindingRedirectsIntermediateAppConfig)</AppConfig>
     </PropertyGroup>
 
-    <PropertyGroup>
-      <ConfigFileExists Condition="Exists('@(AppConfigWithTargetPath->'$(OutDir)%(TargetPath)')')">true</ConfigFileExists>
-      <HasNoBindingRedirects Condition="'@(SuggestedBindingRedirects)' == ''">true</HasNoBindingRedirects>
-    </PropertyGroup>
-
-    <!-- Overwrites .config file with a App.config content if RAR returned empty @(SuggestedBindingRedirects). -->
-    <Copy
-      SourceFiles="@(AppConfigWithTargetPath->'%(FullPath)')"
-      DestinationFiles="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-      SkipUnchangedFiles="true"
-      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'">
-      <Output TaskParameter="CopiedFiles" ItemName="FileWrites"/>
-    </Copy>
-    <Touch
-      Files="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-      AlwaysCreate="true"
-      Condition="'$(ConfigFileExists)' == 'true' and '$(HasNoBindingRedirects)' == 'true' and '$(DesignTimeBuild)' != 'true'"/>
-
     <ItemGroup Condition="$(_NewGenerateBindingRedirectsIntermediateAppConfig) == 'true'">
       <AppConfigWithTargetPath Remove="@(AppConfigWithTargetPath)" />
       <AppConfigWithTargetPath Include="$(AppConfig)">
@@ -3203,7 +3190,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       AssignTargetPaths;
       SplitResourcesByCulture;
       CreateManifestResourceNames;
-      CreateCustomManifestResourceNames
+      CreateCustomManifestResourceNames;
+      AssignEmbeddedResourceOutputPaths;
     </PrepareResourceNamesDependsOn>
   </PropertyGroup>
 
@@ -3261,6 +3249,17 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   </Target>
 
+  <!--
+    Sets OutputResource metadata on EmbeddedResource items. This metadata is used in design time build without running ResGen target.
+  -->
+  <Target Name="AssignEmbeddedResourceOutputPaths">
+    <ItemGroup>
+      <EmbeddedResource>
+        <OutputResource>$(IntermediateOutputPath)%(EmbeddedResource.ManifestResourceName).resources</OutputResource>
+      </EmbeddedResource>
+    </ItemGroup>
+  </Target>
+
   <!--
     ============================================================
                                         GetItemTargetPaths
@@ -3467,7 +3466,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         StronglyTypedNamespace="%(EmbeddedResource.StronglyTypedNamespace)"
         StronglyTypedManifestPrefix="%(EmbeddedResource.StronglyTypedManifestPrefix)"
         PublicClass="%(EmbeddedResource.PublicClass)"
-        OutputResources="@(EmbeddedResource->'$(IntermediateOutputPath)%(ManifestResourceName).resources')"
+        OutputResources="@(EmbeddedResource->'%(OutputResource)')"
         Condition="'%(EmbeddedResource.Type)' == 'Resx' and '%(EmbeddedResource.GenerateResource)' != 'false' and '$(GenerateResourceMSBuildRuntime)' != 'CLR2'"
         SdkToolsPath="$(ResgenToolPath)"
         ExecuteAsTool="$(ResGenExecuteAsTool)"
@@ -3677,7 +3676,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     Create the _CoreCompileResourceInputs list of inputs to the CoreCompile target.
     ============================================================
     -->
-  <Target Name="_GenerateCompileInputs">
+  <Target Name="_GenerateCompileInputs" DependsOnTargets="PrepareResourceNames">
 
     <MSBuildInternalMessage
       Condition="'@(ManifestResourceWithNoCulture)'!='' and '%(ManifestResourceWithNoCulture.EmittedForCompatibilityOnly)'==''"
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index f2fbe04a6b2..f9eb9441801 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -6,6 +6,11 @@
 using System.Linq;
 using System.Text;
 using System.Text.RegularExpressions;
+
+#if NETFRAMEWORK
+using Microsoft.IO;
+#endif
+
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.XamlTypes;
 using Microsoft.Build.Shared;
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 038c1fc2b9b..a6ebead50e0 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -19,6 +19,10 @@ public static class RunnerUtilities
 
         public static ArtifactsLocationAttribute ArtifactsLocationAttribute = Assembly.GetExecutingAssembly().GetCustomAttribute<ArtifactsLocationAttribute>()
                                                    ?? throw new InvalidOperationException("This test assembly does not have the ArtifactsLocationAttribute");
+
+        internal static BootstrapLocationAttribute BootstrapLocationAttribute = Assembly.GetExecutingAssembly().GetCustomAttribute<BootstrapLocationAttribute>()
+                                                   ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
+        public static string BootstrapMsBuildBinaryLocation => BootstrapLocationAttribute.BootstrapMsBuildBinaryLocation;
 #if !FEATURE_RUN_EXE_IN_TESTS
         private static readonly string s_dotnetExePath = EnvironmentProvider.GetDotnetExePath();
 
@@ -62,15 +66,11 @@ public static string ExecBootstrapedMSBuild(
             bool attachProcessId = true,
             int timeoutMilliseconds = 30_000)
         {
-            BootstrapLocationAttribute attribute = Assembly.GetExecutingAssembly().GetCustomAttribute<BootstrapLocationAttribute>()
-                                                   ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
-
-            string binaryFolder = attribute.BootstrapMsBuildBinaryLocation;
 #if NET
-            string pathToExecutable = EnvironmentProvider.GetDotnetExePathFromFolder(binaryFolder);
-            msbuildParameters = Path.Combine(binaryFolder, "sdk", attribute.BootstrapSdkVersion, "MSBuild.dll") + " " + msbuildParameters;
+            string pathToExecutable = EnvironmentProvider.GetDotnetExePathFromFolder(BootstrapMsBuildBinaryLocation);
+            msbuildParameters = Path.Combine(BootstrapMsBuildBinaryLocation, "sdk", BootstrapLocationAttribute.BootstrapSdkVersion, "MSBuild.dll") + " " + msbuildParameters;
 #else
-            string pathToExecutable = Path.Combine(binaryFolder, "MSBuild.exe");
+            string pathToExecutable = Path.Combine(BootstrapMsBuildBinaryLocation, "MSBuild.exe");
 #endif
             return RunProcessAndGetOutput(pathToExecutable, msbuildParameters, out successfulExit, shellExecute, outputHelper, attachProcessId, timeoutMilliseconds);
         }
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 25ae27e63d0..59385e6446b 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -168,6 +168,11 @@ public enum VisualStudioVersion
         /// </summary>
         Version170,
 
+        /// <summary>
+        /// Dev18
+        /// </summary>
+        Version180,
+
         // keep this up-to-date; always point to the last entry.
         /// <summary>
         /// The latest version available at the time of release
@@ -2067,6 +2072,7 @@ private static Version VisualStudioVersionToSystemVersion(VisualStudioVersion ve
                 VisualStudioVersion.Version150 => FrameworkLocationHelper.visualStudioVersion150,
                 VisualStudioVersion.Version160 => FrameworkLocationHelper.visualStudioVersion160,
                 VisualStudioVersion.Version170 => FrameworkLocationHelper.visualStudioVersion170,
+                VisualStudioVersion.Version180 => FrameworkLocationHelper.visualStudioVersion180,
                 _ => Unsupported()
             };
 
@@ -3583,7 +3589,7 @@ public static string GetPathToBuildToolsFile(string fileName, string toolsVersio
             {
                 toolPath = Path.Combine(toolPath, fileName);
 
-                // Rollback see https://developercommunity.visualstudio.com/t/Unable-to-locate-MSBuild-path-with-Lates/10824132 
+                // Rollback see https://developercommunity.visualstudio.com/t/Unable-to-locate-MSBuild-path-with-Lates/10824132
                 if (!File.Exists(toolPath))
                 {
                     toolPath = null;
