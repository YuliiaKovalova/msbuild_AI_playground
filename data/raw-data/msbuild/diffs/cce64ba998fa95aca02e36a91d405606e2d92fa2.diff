diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index dd80dc8c80d..145b6b67a88 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -100,7 +100,7 @@ stages:
       displayName: 'Install OptProf Plugin'
 
     # Required by MicroBuildBuildVSBootstrapper
-    - task: ms-vseng.MicroBuildTasks.32f78468-e895-4f47-962c-58a699361df8.MicroBuildSwixPlugin@1
+    - task: MicroBuildSwixPlugin@4
       inputs:
         dropName: $(VisualStudio.DropName)
 
diff --git a/MSBuild.sln b/MSBuild.sln
index eaedd997db8..cb3f5c85d02 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -78,918 +78,1263 @@ EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
+		Debug|ARM64 = Debug|ARM64
 		Debug|x64 = Debug|x64
 		Debug|x86 = Debug|x86
 		Debug-MONO|Any CPU = Debug-MONO|Any CPU
+		Debug-MONO|ARM64 = Debug-MONO|ARM64
 		Debug-MONO|x64 = Debug-MONO|x64
 		Debug-MONO|x86 = Debug-MONO|x86
 		MachineIndependent|Any CPU = MachineIndependent|Any CPU
+		MachineIndependent|ARM64 = MachineIndependent|ARM64
 		MachineIndependent|x64 = MachineIndependent|x64
 		MachineIndependent|x86 = MachineIndependent|x86
 		Release|Any CPU = Release|Any CPU
+		Release|ARM64 = Release|ARM64
 		Release|x64 = Release|x64
 		Release|x86 = Release|x86
 		Release-MONO|Any CPU = Release-MONO|Any CPU
+		Release-MONO|ARM64 = Release-MONO|ARM64
 		Release-MONO|x64 = Release-MONO|x64
 		Release-MONO|x86 = Release-MONO|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x64.ActiveCfg = Debug|x64
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x64.Build.0 = Debug|x64
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug|x86.Build.0 = Debug|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|Any CPU.Build.0 = Release|Any CPU
+		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|ARM64.Build.0 = Release|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x64.ActiveCfg = Release|x64
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x64.Build.0 = Release|x64
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x86.ActiveCfg = Release|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release|x86.Build.0 = Release|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{69BE05E2-CBDA-4D27-9733-44E12B0F5627}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|x64.ActiveCfg = Debug|x64
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|x64.Build.0 = Debug|x64
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug|x86.Build.0 = Debug|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|Any CPU.Build.0 = Release|Any CPU
+		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|ARM64.Build.0 = Release|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|x64.ActiveCfg = Release|x64
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|x64.Build.0 = Release|x64
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|x86.ActiveCfg = Release|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release|x86.Build.0 = Release|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{5C53E4FD-0985-432D-B9E4-7BC354A057E5}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|x64.ActiveCfg = Debug|x64
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|x64.Build.0 = Debug|x64
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug|x86.Build.0 = Debug|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|Any CPU.Build.0 = Release|Any CPU
+		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|ARM64.Build.0 = Release|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|x64.ActiveCfg = Release|x64
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|x64.Build.0 = Release|x64
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|x86.ActiveCfg = Release|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release|x86.Build.0 = Release|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{774DCE9B-F775-4B6D-943D-C841F755DBDE}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x64.ActiveCfg = Debug|x64
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x64.Build.0 = Debug|x64
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug|x86.Build.0 = Debug|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|Any CPU.Build.0 = Release|Any CPU
+		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|ARM64.Build.0 = Release|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x64.ActiveCfg = Release|x64
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x64.Build.0 = Release|x64
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x86.ActiveCfg = Release|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release|x86.Build.0 = Release|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{69C7E5AF-5D29-42B3-BA76-F7C4F0EDF251}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|x64.ActiveCfg = Debug|x64
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|x64.Build.0 = Debug|x64
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug|x86.Build.0 = Debug|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|Any CPU.Build.0 = Release|Any CPU
+		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|ARM64.Build.0 = Release|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|x64.ActiveCfg = Release|x64
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|x64.Build.0 = Release|x64
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|x86.ActiveCfg = Release|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release|x86.Build.0 = Release|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{C400412A-E7BD-4B8D-B6F5-B2135C481A4E}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|ARM64.Build.0 = Debug|ARM64
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x64.ActiveCfg = Debug|x64
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x64.Build.0 = Debug|x64
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug|x86.Build.0 = Debug|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|Any CPU.Build.0 = Release|Any CPU
+		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|ARM64.Build.0 = Release|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x64.ActiveCfg = Release|x64
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x64.Build.0 = Release|x64
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x86.ActiveCfg = Release|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release|x86.Build.0 = Release|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|x64.ActiveCfg = Debug|x64
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|x64.Build.0 = Debug|x64
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug|x86.Build.0 = Debug|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|Any CPU.Build.0 = Release|Any CPU
+		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|ARM64.Build.0 = Release|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|x64.ActiveCfg = Release|x64
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|x64.Build.0 = Release|x64
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|x86.ActiveCfg = Release|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release|x86.Build.0 = Release|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{0ADDBC02-0076-4159-B351-2BF33FAA46B2}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x64.ActiveCfg = Debug|x64
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x64.Build.0 = Debug|x64
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug|x86.Build.0 = Debug|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|Any CPU.Build.0 = Release|Any CPU
+		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|ARM64.Build.0 = Release|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x64.ActiveCfg = Release|x64
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x64.Build.0 = Release|x64
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x86.ActiveCfg = Release|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release|x86.Build.0 = Release|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{2AB5D52E-3C4D-4572-B140-9EED600ECE59}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|x64.ActiveCfg = Debug|x64
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|x64.Build.0 = Debug|x64
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug|x86.Build.0 = Debug|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|x64.Build.0 = Debug|x64
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|Any CPU.Build.0 = Release|Any CPU
+		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|ARM64.Build.0 = Release|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|x64.ActiveCfg = Release|x64
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|x64.Build.0 = Release|x64
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|x86.ActiveCfg = Release|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release|x86.Build.0 = Release|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{CF999BDE-02B3-431B-95E6-E88D621D9CBF}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x64.ActiveCfg = Debug|x64
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x64.Build.0 = Debug|x64
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug|x86.Build.0 = Debug|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x64.Build.0 = Debug|x64
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|Any CPU.Build.0 = Release|Any CPU
+		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|ARM64.Build.0 = Release|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x64.ActiveCfg = Release|x64
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x64.Build.0 = Release|x64
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x86.ActiveCfg = Release|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release|x86.Build.0 = Release|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{C51C04F6-D35B-4211-B0F2-9D69F63AC0BC}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|x64.ActiveCfg = Debug|x64
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|x64.Build.0 = Debug|x64
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug|x86.Build.0 = Debug|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|x64.Build.0 = Debug|x64
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|Any CPU.Build.0 = Release|Any CPU
+		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|ARM64.Build.0 = Release|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|x64.ActiveCfg = Release|x64
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|x64.Build.0 = Release|x64
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|x86.ActiveCfg = Release|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release|x86.Build.0 = Release|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{EEFE7E34-B3C6-473E-9F4D-4D64DB63F0C4}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|x64.ActiveCfg = Debug|x64
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|x64.Build.0 = Debug|x64
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug|x86.Build.0 = Debug|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|x64.Build.0 = Debug|x64
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|Any CPU.Build.0 = Release|Any CPU
+		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|ARM64.Build.0 = Release|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|x64.ActiveCfg = Release|x64
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|x64.Build.0 = Release|x64
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|x86.ActiveCfg = Release|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release|x86.Build.0 = Release|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{66C6C1ED-30E7-45DD-9F73-2FBB7889CDBA}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug|x64.ActiveCfg = Debug|x64
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug|x64.Build.0 = Debug|x64
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug|x86.Build.0 = Debug|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug-MONO|x64.Build.0 = Debug|x64
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release|Any CPU.Build.0 = Release|Any CPU
+		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release|ARM64.Build.0 = Release|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release|x64.ActiveCfg = Release|x64
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release|x64.Build.0 = Release|x64
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release|x86.ActiveCfg = Release|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release|x86.Build.0 = Release|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{F1A7AA75-72EE-44FE-8493-7FD99F6F42B0}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug|x64.ActiveCfg = Debug|x64
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug|x64.Build.0 = Debug|x64
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug|x86.Build.0 = Debug|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug-MONO|x64.Build.0 = Debug|x64
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release|Any CPU.Build.0 = Release|Any CPU
+		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release|ARM64.Build.0 = Release|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release|x64.ActiveCfg = Release|x64
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release|x64.Build.0 = Release|x64
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release|x86.ActiveCfg = Release|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release|x86.Build.0 = Release|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{77849E6E-FE6B-43BA-A48D-EF75BD2279F8}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug|x64.ActiveCfg = Debug|x64
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug|x64.Build.0 = Debug|x64
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug|x86.Build.0 = Debug|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug-MONO|x64.Build.0 = Debug|x64
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release|Any CPU.Build.0 = Release|Any CPU
+		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release|ARM64.Build.0 = Release|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release|x64.ActiveCfg = Release|x64
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release|x64.Build.0 = Release|x64
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release|x86.ActiveCfg = Release|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release|x86.Build.0 = Release|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{2D515229-D44B-4625-A1B2-ED88153D0ECF}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{F45DBA88-C833-434A-8F68-087124540303}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{F45DBA88-C833-434A-8F68-087124540303}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug|x64.ActiveCfg = Debug|x64
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug|x64.Build.0 = Debug|x64
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug|x86.Build.0 = Debug|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{F45DBA88-C833-434A-8F68-087124540303}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{F45DBA88-C833-434A-8F68-087124540303}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug-MONO|x64.Build.0 = Debug|x64
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{F45DBA88-C833-434A-8F68-087124540303}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{F45DBA88-C833-434A-8F68-087124540303}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{F45DBA88-C833-434A-8F68-087124540303}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{F45DBA88-C833-434A-8F68-087124540303}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Release|Any CPU.Build.0 = Release|Any CPU
+		{F45DBA88-C833-434A-8F68-087124540303}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{F45DBA88-C833-434A-8F68-087124540303}.Release|ARM64.Build.0 = Release|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Release|x64.ActiveCfg = Release|x64
 		{F45DBA88-C833-434A-8F68-087124540303}.Release|x64.Build.0 = Release|x64
 		{F45DBA88-C833-434A-8F68-087124540303}.Release|x86.ActiveCfg = Release|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Release|x86.Build.0 = Release|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{F45DBA88-C833-434A-8F68-087124540303}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{F45DBA88-C833-434A-8F68-087124540303}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{F45DBA88-C833-434A-8F68-087124540303}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{F45DBA88-C833-434A-8F68-087124540303}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{F45DBA88-C833-434A-8F68-087124540303}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug|x64.ActiveCfg = Debug|x64
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug|x64.Build.0 = Debug|x64
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug|x86.Build.0 = Debug|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug-MONO|x64.Build.0 = Debug|x64
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release|Any CPU.Build.0 = Release|Any CPU
+		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release|ARM64.Build.0 = Release|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release|x64.ActiveCfg = Release|x64
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release|x64.Build.0 = Release|x64
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release|x86.ActiveCfg = Release|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release|x86.Build.0 = Release|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{523E1555-DB60-4FD4-8CDF-3C159710CAED}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug|x64.ActiveCfg = Debug|x64
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug|x64.Build.0 = Debug|x64
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug|x86.Build.0 = Debug|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug-MONO|x64.Build.0 = Debug|x64
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release|Any CPU.Build.0 = Release|Any CPU
+		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release|ARM64.Build.0 = Release|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release|x64.ActiveCfg = Release|x64
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release|x64.Build.0 = Release|x64
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release|x86.ActiveCfg = Release|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release|x86.Build.0 = Release|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{475DDCAC-12F6-4562-A74B-FB64F11100EE}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug|x64.ActiveCfg = Debug|x64
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug|x64.Build.0 = Debug|x64
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug|x86.Build.0 = Debug|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug-MONO|x64.Build.0 = Debug|x64
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{136C8713-3103-4AF9-B7CB-9619E87249C1}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{136C8713-3103-4AF9-B7CB-9619E87249C1}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release|Any CPU.Build.0 = Release|Any CPU
+		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release|ARM64.Build.0 = Release|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release|x64.ActiveCfg = Release|x64
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release|x64.Build.0 = Release|x64
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release|x86.ActiveCfg = Release|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release|x86.Build.0 = Release|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{136C8713-3103-4AF9-B7CB-9619E87249C1}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug|x64.ActiveCfg = Debug|x64
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug|x64.Build.0 = Debug|x64
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug|x86.Build.0 = Debug|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug-MONO|x64.Build.0 = Debug|x64
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release|Any CPU.Build.0 = Release|Any CPU
+		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release|ARM64.Build.0 = Release|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release|x64.ActiveCfg = Release|x64
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release|x64.Build.0 = Release|x64
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release|x86.ActiveCfg = Release|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release|x86.Build.0 = Release|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{586C55EE-4003-4A20-AAE2-76DBDA421BB3}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug|x64.ActiveCfg = Debug|x64
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug|x64.Build.0 = Debug|x64
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug|x86.Build.0 = Debug|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug-MONO|x64.Build.0 = Debug|x64
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release|Any CPU.Build.0 = Release|Any CPU
+		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release|ARM64.Build.0 = Release|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release|x64.ActiveCfg = Release|x64
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release|x64.Build.0 = Release|x64
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release|x86.ActiveCfg = Release|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release|x86.Build.0 = Release|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{8AE12A8B-D64C-48CF-AD00-9A0C35884DFA}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug|x64.ActiveCfg = Debug|x64
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug|x64.Build.0 = Debug|x64
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug|x86.Build.0 = Debug|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug-MONO|x64.Build.0 = Debug|x64
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{16DBDF17-3E0E-4140-989A-B42638126A40}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{16DBDF17-3E0E-4140-989A-B42638126A40}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release|Any CPU.Build.0 = Release|Any CPU
+		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release|ARM64.Build.0 = Release|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release|x64.ActiveCfg = Release|x64
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release|x64.Build.0 = Release|x64
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release|x86.ActiveCfg = Release|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release|x86.Build.0 = Release|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{16DBDF17-3E0E-4140-989A-B42638126A40}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug|x64.ActiveCfg = Debug|x64
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug|x64.Build.0 = Debug|x64
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug|x86.Build.0 = Debug|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug-MONO|x64.ActiveCfg = Debug|x64
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug-MONO|x64.Build.0 = Debug|x64
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Debug-MONO|x86.Build.0 = Debug|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release|Any CPU.Build.0 = Release|Any CPU
+		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release|ARM64.Build.0 = Release|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release|x64.ActiveCfg = Release|x64
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release|x64.Build.0 = Release|x64
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release|x86.ActiveCfg = Release|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release|x86.Build.0 = Release|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{EDBFE32E-F264-4F01-97C3-B58F8B9165C9}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|ARM64.Build.0 = Debug|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|x64.ActiveCfg = Debug|x64
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|x64.Build.0 = Debug|x64
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug|x86.Build.0 = Debug|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|x64.ActiveCfg = Debug|x64
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|x64.Build.0 = Debug|x64
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|x86.ActiveCfg = Debug|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Debug-MONO|x86.Build.0 = Debug|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|Any CPU.Build.0 = Release|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|ARM64.Build.0 = Release|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|x64.ActiveCfg = Release|x64
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|x64.Build.0 = Release|x64
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|x86.ActiveCfg = Release|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release|x86.Build.0 = Release|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|x64.Build.0 = Release-MONO|x64
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
+		{3D67E4FF-6EC6-4FE7-82F1-0DACE1E399A7}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug|x64.ActiveCfg = Debug|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug|x64.Build.0 = Debug|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug|x86.Build.0 = Debug|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release|Any CPU.Build.0 = Release|Any CPU
+		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release|ARM64.Build.0 = Release|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release|x64.ActiveCfg = Release|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release|x64.Build.0 = Release|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release|x86.ActiveCfg = Release|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release|x86.Build.0 = Release|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{CEAEE4FE-9298-443B-AFC5-0F72472484B6}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|x64.ActiveCfg = Debug|x64
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|x64.Build.0 = Debug|x64
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug|x86.Build.0 = Debug|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|Any CPU.Build.0 = Release|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|ARM64.Build.0 = Release|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|x64.ActiveCfg = Release|x64
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|x64.Build.0 = Release|x64
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|x86.ActiveCfg = Release|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release|x86.Build.0 = Release|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{639C178E-368F-4384-869E-7C6D18B4CC1F}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|x64.ActiveCfg = Debug|x64
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|x64.Build.0 = Debug|x64
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug|x86.Build.0 = Debug|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|Any CPU.Build.0 = Release|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|ARM64.Build.0 = Release|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|x64.ActiveCfg = Release|x64
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|x64.Build.0 = Release|x64
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|x86.ActiveCfg = Release|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release|x86.Build.0 = Release|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{A1FF7E97-F98F-4C5C-AD09-0E1CF4A7A4DB}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|x64.ActiveCfg = Debug|x64
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|x64.Build.0 = Debug|x64
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug|x86.Build.0 = Debug|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|Any CPU.Build.0 = Release|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|ARM64.Build.0 = Release|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|x64.ActiveCfg = Release|x64
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|x64.Build.0 = Release|x64
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|x86.ActiveCfg = Release|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release|x86.Build.0 = Release|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{D05E5FAF-3E05-48D2-8DEF-FD1A18EB1349}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x64.ActiveCfg = Debug|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x64.Build.0 = Debug|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug|x86.Build.0 = Debug|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|Any CPU.Build.0 = Release|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|ARM64.Build.0 = Release|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x64.ActiveCfg = Release|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x64.Build.0 = Release|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x86.ActiveCfg = Release|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release|x86.Build.0 = Release|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{B60173F0-F9F0-4688-9DF8-9ADDD57BD45F}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x64.ActiveCfg = Debug|x64
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x64.Build.0 = Debug|x64
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug|x86.Build.0 = Debug|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|Any CPU.Build.0 = Release|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|ARM64.Build.0 = Release|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x64.ActiveCfg = Release|x64
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x64.Build.0 = Release|x64
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x86.ActiveCfg = Release|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release|x86.Build.0 = Release|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
 		{F47E1A0A-7D81-40CF-B8B3-A0F4B5ADE943}.Release-MONO|x86.Build.0 = Release-MONO|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|ARM64.ActiveCfg = Debug|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|ARM64.Build.0 = Debug|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|x64.ActiveCfg = Debug|x64
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|x64.Build.0 = Debug|x64
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|x86.ActiveCfg = Debug|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug|x86.Build.0 = Debug|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|Any CPU.ActiveCfg = Debug-MONO|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|Any CPU.Build.0 = Debug-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|ARM64.ActiveCfg = Debug-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|ARM64.Build.0 = Debug-MONO|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|x64.ActiveCfg = Debug-MONO|x64
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|x64.Build.0 = Debug-MONO|x64
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|x86.ActiveCfg = Debug-MONO|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Debug-MONO|x86.Build.0 = Debug-MONO|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|Any CPU.ActiveCfg = MachineIndependent|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|Any CPU.Build.0 = MachineIndependent|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|ARM64.ActiveCfg = MachineIndependent|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|ARM64.Build.0 = MachineIndependent|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|x64.ActiveCfg = MachineIndependent|x64
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|x64.Build.0 = MachineIndependent|x64
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|x86.ActiveCfg = MachineIndependent|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.MachineIndependent|x86.Build.0 = MachineIndependent|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|Any CPU.Build.0 = Release|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|ARM64.ActiveCfg = Release|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|ARM64.Build.0 = Release|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|x64.ActiveCfg = Release|x64
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|x64.Build.0 = Release|x64
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|x86.ActiveCfg = Release|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release|x86.Build.0 = Release|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|Any CPU.ActiveCfg = Release-MONO|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|Any CPU.Build.0 = Release-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|ARM64.ActiveCfg = Release-MONO|Any CPU
+		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|ARM64.Build.0 = Release-MONO|Any CPU
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|x64.ActiveCfg = Release-MONO|x64
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|x64.Build.0 = Release-MONO|x64
 		{65749C80-47E7-42FE-B441-7A86289D46AA}.Release-MONO|x86.ActiveCfg = Release-MONO|Any CPU
diff --git a/README.md b/README.md
index 20d68bf2708..d96c05bcda0 100644
--- a/README.md
+++ b/README.md
@@ -12,9 +12,9 @@ The current development branch is `main`. Changes in `main` will go into a futur
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=main)
 
-We have forked for MSBuild 17.1 in the branch [`vs17.1`](https://github.com/Microsoft/msbuild/tree/vs17.1). Changes to that branch need special approval.
+We have forked for MSBuild 17.2 in the branch [`vs17.2`](https://github.com/Microsoft/msbuild/tree/vs17.2). Changes to that branch need special approval.
 
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.1)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.1)
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.2)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.2)
 
 17.0 builds from the branch [`vs17.0`](https://github.com/Microsoft/msbuild/tree/vs17.0). Only high-priority bugfixes will be considered for servicing 17.0.
 
@@ -24,14 +24,10 @@ We have forked for MSBuild 17.1 in the branch [`vs17.1`](https://github.com/Micr
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.11)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.11)
 
-MSBuild 16.9 builds from the branch [`vs16.9`](https://github.com/dotnet/msbuild/tree/vs16.9). Only high-priority bugfixes will be considered for servicing 16.9.
+MSBuild 16.9 builds from the branch [`vs16.9`](https://github.com/dotnet/msbuild/tree/vs16.9). Only very-high-priority bugfixes will be considered for servicing 16.9.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.9)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.9)
 
-MSBuild 16.7 builds from the branch [`vs16.7`](https://github.com/dotnet/msbuild/tree/vs16.7). Only high-priority bugfixes will be considered for servicing 16.7.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.7)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.7)
-
 MSBuild 15.9 builds from the branch [`vs15.9`](https://github.com/dotnet/msbuild/tree/vs15.9). Only very-high-priority bugfixes will be considered for servicing 15.9.
 
 ## Building
diff --git a/documentation/MSBuild-Server.md b/documentation/MSBuild-Server.md
new file mode 100644
index 00000000000..355cd8e1383
--- /dev/null
+++ b/documentation/MSBuild-Server.md
@@ -0,0 +1,54 @@
+# MSBuild Server
+
+MSBuild Server is basically an another type of node which can accept build request from clients and utilize worker nodes in current fashion to build projects. Main purpose of the server node is to avoid expensive MSBuild process start during build from tools like .NET SDK.
+
+## Communication protocol
+
+The server node uses same IPC approach as current worker nodes - named pipes. This solution allows to reuse existing code. When process starts, pipe with deterministic name is opened and waiting for commands. Client has following worfklow:
+
+1. Try to connect to server
+   - If server is not running, start new instance
+   - If server is busy, fallback to classic build 
+2. Initiate handshake
+2. Issue build command with `EntryNodeCommand` packet
+3. Read packets from pipe
+   - When `EntryNodeConsoleWrite` packet type is recieved, write content to appropriate output stream with respected coloring
+   - When `EntryNodeResponse` packet type is recieved, build is done and client writes trace message with exit code
+
+### Pipe name convention & handshake
+
+There might be multiple server processes started with different architecture, associated user, MSBuild version and another options. To quickly identify the appropriate one, server uses convention that includes these options in the name of the pipe. Name has format `MSBuildServer-{hash}` where `{hash}` is a SHA256 hashed value identifying these options.
+
+Handshake is a procedure ensuring that client is connecting to a compatible server instance. It uses same logic and security guarantees as current connection between entry node and worker nodes. Hash in the pipe name is basically hash of the handshake object.
+
+### Packets for client-server communication
+
+Server requires to introduce new packet types for IPC.
+
+`EntryNodeCommand` contains all of the information necessary for a server to run a build.
+
+| Property name            | Type                         | Description |
+|---|---|---|
+| CommandLine              | String                       | The MSBuild command line with arguments for build |
+| StartupDirectory         | String                       | The startup directory path |
+| BuildProcessEnvironment  | IDictionary<String, String>  | Environment variables for current build |
+| Culture                  | CultureInfo                  | The culture value for current build |
+| UICulture                | CultureInfo                  | The UI culture value for current build |
+
+`EntryNodeConsoleWrite` contains information for console output.
+
+| Property name            | Type          | Description |
+|---|---|---|
+| Text                     | String        | The text that is written to the output stream. It includes ANSI escape codes for formatting. |
+| OutputType               | Byte          | Identification of the output stream (1 = standard output, 2 = error output) |
+
+`EntryNodeResponse` informs about finished build.
+
+| Property name            | Type          | Description |
+|---|---|---|
+| ExitCode                 | Int32         | The exit code of the build |
+| ExitType                 | String        | The exit type of the build |
+
+`EntryNodeCancel` cancels the current build.
+
+This type is intentionally empty and properties for build cancelation could be added in future.
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 812d28fe413..18936da2249 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -34,6 +34,7 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 | Save | Saves a project to the file system if dirty, creating directories as necessary. |
 | SdkResolverResolveSdk | A single SDK resolver is called. |
 | SdkResolverServiceInitialize | Initializes SDK resolvers. |
+| SdkResolverEvent | An SDK resolver logs an event. |
 | Target | Executes a target. |
 | TargetUpToDate | Checks whether a particular target needs to run or is up-to-date. |
 | WriteLinesToFile | Checks whether the WriteLinesToFile task needs to execute. |
diff --git a/documentation/specs/low-priority-switch.md b/documentation/specs/low-priority-switch.md
new file mode 100644
index 00000000000..ba33826a89e
--- /dev/null
+++ b/documentation/specs/low-priority-switch.md
@@ -0,0 +1,35 @@
+
+# Low Priority Nodes in MSBuild and Visual Studio
+
+## Problem Summary
+
+When doing other work, it can be useful for builds (which often take a long time and consume a lot of resources) to happen in the background, allowing other work to happen in the interim. This is true for both command line builds and builds within Visual Studio.
+
+Visual Studio, on the other hand, should always run at normal priority. This ensures that users can continue to interact with its other features, most notably editing code and seeing intellisense and autocomplete pop up.
+
+## High Level Design
+
+### Requirements
+
+1. A long-lived process can execute a series of builds divided between Normal and BelowNormal priority.
+2. Transitions between a build at Normal priority and one at BelowNormal priority (and vice versa) are fairly efficient, at least on Windows but ideally on all operating systems.
+3. NodeReuse is still possible. That is, another process can (often) use nodes from the long-lived process if NodeReuse is true.
+4. Any reused nodes are at the priority they themselves specify. Normal priority nodes are actually at normal priority, and low priority nodes are actually at BelowNormal priority.
+5. All nodes are at the priority they should be when being used to build even if a normal priority process had connected to them as normal priority worker nodes, and they are now executing a low priority build.
+
+
+## Non-goals
+
+Perfect parity between windows and mac or linux. Windows permits processes to raise their own priority or that of another process, whereas other operating systems do not. This is very efficient, so we should use it. As we expect this feature to be used in Visual Studio, we anticipate it being less used on mac and linux, hence not being as high priority to make it just as efficient.
+
+## Details
+
+Each node (including worker nodes) initially takes its priority from its parent process. Since we now need the priority to align with what it is passed instead of its parent, attempt to adjust priority afterwards if necessary as part of node startup.
+
+BuildManager.cs remembers the priority of the previous build it had executed. If that was set to a value that differs from the priority of the current build:
+1. On windows or when decreasing the priority: lowers the priority of all connected nodes
+2. On linux and mac when increasing the priority: disconnects from all nodes.
+
+When a worker node disconnects from the entrypoint node, it should ensure that it is the priority that would be expected by nodes that successfully connect to it. That means that it should be normal priority if lowPriority is false and BelowNormal priority otherwise.
+
+For this reason, if we intend to reuse a node, we check its priority and adjust it to the expected value if possible. If it proves impossible to adjust to the correct priority, the node shuts down.
diff --git a/documentation/wiki/ChangeWaves-Dev.md b/documentation/wiki/ChangeWaves-Dev.md
index a3cfdbcd93f..5158535340c 100644
--- a/documentation/wiki/ChangeWaves-Dev.md
+++ b/documentation/wiki/ChangeWaves-Dev.md
@@ -12,8 +12,11 @@ The opt-out comes in the form of setting the environment variable `MSBuildDisabl
 ## Choosing a Change Wave for a New Feature
 This is determined on a case by case basis and should be discussed with the MSBuild team. A safe bet would be to check our [currently active Change Waves](ChangeWaves.md#change-waves-&-associated-features) and pick the version after the latest MSBuild version. This version corresponds to the latest version of Visual Studio.
 
+### Change Wave Versioning
+Change Wave features should match the LTS version of VS they were released with. Any feature requiring a changewave during a non-LTS release of VS should use the **NEXT** version number.
+
 # Developing With Change Waves in Mind
-For the purpose of providing an example, the rest of this document assumes we're developing a feature for MSBuild version **17.4**.
+For the purpose of providing an example, the rest of this document assumes we're developing a feature for MSBuild version **17.3**.
 
 The Process:
 1. Develop your feature.
@@ -32,7 +35,7 @@ public static readonly Version Wave17_4 = new Version(17, 4);
 3. You may need to delete the lowest wave as new waves get added.
 4. Update the AllWaves array appropriately.
 ```c#
-public static readonly Version[] AllWaves = { Wave16_10, Wave17_0, Wave17_4 };
+public static readonly Version[] AllWaves = { Wave17_0, Wave17_2, Wave17_4 };
 ```
 
 ## Condition Your Feature On A Change Wave
@@ -96,4 +99,4 @@ These features will eventually become standard functionality. When a change wave
 1. Start by deleting the readonly `Wave17_4` that was created in [Creating a Change Wave](#creating-a-change-wave).
 2. Remove `ChangeWave.AreFeaturesEnabled` or `[MSBuild]::AreFeaturesEnabled` conditions surrounding features that were assigned that change wave.
 3. Remove tests associated with ensuring features would not run if this wave were set.
-4. Clear all other issues that arose from deleting the version.
+4. Clear all other issues that arose from deleting the version.
\ No newline at end of file
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 84e2c7fcb2b..1a778f77493 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -22,12 +22,10 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 # Change Waves & Associated Features
 
 ## Current Rotation of Change Waves
-### 16.10
-- [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
-- [Allow Custom CopyToOutputDirectory Location With TargetPath](https://github.com/dotnet/msbuild/pull/6237)
-- [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
-- [Fail restore operations when an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6430)
-- [Optimize glob evaluation](https://github.com/dotnet/msbuild/pull/6151)
+
+### 17.4
+- [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
+- [Remove opt in for new schema for CombineTargetFrameworkInfoProperties](https://github.com/dotnet/msbuild/pull/6928)
 
 ### 17.0
 - [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
@@ -47,3 +45,10 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
 - [Truncate Target/Task skipped log messages to 1024 chars](https://github.com/dotnet/msbuild/pull/5553)
 - [Don't expand full drive globs with false condition](https://github.com/dotnet/msbuild/pull/5669)
+
+### 16.10
+- [Error when a property expansion in a condition has whitespace](https://github.com/dotnet/msbuild/pull/5672)
+- [Allow Custom CopyToOutputDirectory Location With TargetPath](https://github.com/dotnet/msbuild/pull/6237)
+- [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
+- [Fail restore operations when an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6430)
+- [Optimize glob evaluation](https://github.com/dotnet/msbuild/pull/6151)
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index 52c0b7ec043..288c062da35 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -8,7 +8,7 @@
 
   <PropertyGroup>
     <BootstrapDestination>$(ArtifactsBinDir)bootstrap\</BootstrapDestination>
-    <BootstrapDestination Condition="'$(Platform)' == 'x64'">$(BootstrapDestination)$(Platform)\</BootstrapDestination>
+    <BootstrapDestination Condition="'$(Platform)' == 'x64' or '$(Platform)' == 'arm64'">$(BootstrapDestination)$(Platform)\</BootstrapDestination>
     <BootstrapDestination>$(BootstrapDestination)$(TargetFramework.ToLowerInvariant())\MSBuild\</BootstrapDestination>
 
     <!-- TODO: Mono build should use BootstrapNetCore logic -->
@@ -21,7 +21,7 @@
 
   <Target Name="Bootstrap" DependsOnTargets="$(BootstrapDependsOn)"
           AfterTargets="AfterBuild"
-          Condition="'$(CreateBootstrap)' == 'true'"/>
+          Condition="'$(CreateBootstrap)' != 'false'"/>
 
   <Target Name="CleanBootstrapFolder">
     <!-- This sometimes fails so it might need be retried. -->
@@ -79,7 +79,8 @@
       <ShimTargets Include="Workflow.Targets" />
       <ShimTargets Include="Workflow.VisualBasic.Targets" />
 
-      <InstalledMicrosoftExtensions Include="$(MSBuildExtensionsPath)\Microsoft\**\*.*" />
+      <InstalledMicrosoftExtensions Include="$(MSBuildExtensionsPath)\Microsoft\**\*.*"
+                                    Exclude="$(MSBuildExtensionsPath)\Microsoft\VisualStudio\NodeJs\**" />
 
       <InstalledNuGetFiles Include="$(MSBuildExtensionsPath)\Microsoft\NuGet\*" />
 
@@ -100,6 +101,13 @@
       <FreshlyBuiltBinariesx64 Include="$(MSBuildTaskHostX64BinPath)**\*.exe.config" />
       <FreshlyBuiltBinariesx64 Include="$(X64BinPath)**\*.dll.config" />
 
+      <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.Tasks.Core.dll" />
+      <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.exe" />
+      <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.tlb" />
+      <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.pdb" />
+      <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.exe.config" />
+      <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.dll.config" />
+
       <FreshlyBuiltRootProjects Include="$(OutputPath)Microsoft.Common.props" />
       <FreshlyBuiltRootProjects Include="$(OutputPath)Microsoft.VisualStudioVersion.*.Common.props" />
       <FreshlyBuiltProjects Include="$(OutputPath)**\*props" Exclude="@(FreshlyBuiltRootProjects)" />
@@ -155,6 +163,10 @@
      <Copy SourceFiles="@(FreshlyBuiltBinariesx64)"
           DestinationFiles="@(FreshlyBuiltBinariesx64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')" />
 
+    <!-- Copy our binaries to the arm64 location. -->
+     <Copy SourceFiles="@(FreshlyBuiltBinariesArm64)"
+          DestinationFiles="@(FreshlyBuiltBinariesArm64 -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')" />
+
     <!-- Copy our freshly-built props and targets, overwriting anything we copied from the machine -->
     <Copy SourceFiles="@(FreshlyBuiltRootProjects)"
           DestinationFiles="@(FreshlyBuiltRootProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\%(Filename)%(Extension)')" />
@@ -162,6 +174,8 @@
           DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\%(RecursiveDir)%(Filename)%(Extension)')" />
     <Copy SourceFiles="@(FreshlyBuiltProjects)"
           DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\amd64\%(RecursiveDir)%(Filename)%(Extension)')" />
+    <Copy SourceFiles="@(FreshlyBuiltProjects)"
+          DestinationFiles="@(FreshlyBuiltProjects -> '$(BootstrapDestination)$(TargetMSBuildToolsVersion)\Bin\arm64\%(RecursiveDir)%(Filename)%(Extension)')" />
 
   </Target>
 
diff --git a/eng/Packages.props b/eng/Packages.props
index 7334fbeb8d7..4208a911570 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -12,26 +12,22 @@
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="4.2.0-1.22102.8" />
     <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
-    <PackageReference Update="Microsoft.IO.Redist" Version="6.0.0" />
+    <PackageReference Update="Microsoft.IO.Redist" Version="$(MicrosoftIORedistVersion)" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
-    <PackageReference Update="Microsoft.Win32.Registry" Version="4.3.0" />
     <PackageReference Update="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="System.CodeDom" Version="4.4.0" />
     <PackageReference Update="System.Collections.Immutable" Version="5.0.0" />
     <PackageReference Update="System.Configuration.ConfigurationManager" Version="4.7.0" />
     <PackageReference Update="System.Net.Http" Version="4.3.4" />
     <PackageReference Update="System.Memory" Version="4.5.4" />
     <PackageReference Update="System.Reflection.Metadata" Version="1.6.0" />
     <PackageReference Update="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
-    <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="6.0.0" />
-    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="4.7.0" />
-    <PackageReference Update="System.Security.Cryptography.Xml" Version="4.7.0" />
+    <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
     <PackageReference Update="System.Security.Permissions" Version="4.7.0" />
-    <PackageReference Update="System.Security.Principal.Windows" Version="4.7.0" />
+    <PackageReference Update="System.Security.Principal.Windows" Version="5.0.0" />
     <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
-    <PackageReference Update="System.Text.Json" Version="6.0.0" />
-    <PackageReference Update="System.Threading.Tasks.Dataflow" Version="6.0.0" />
+    <PackageReference Update="System.Text.Json" Version="$(SystemTextJsonVersion)" />
+    <PackageReference Update="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
     <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.console" Version="$(XUnitVersion)" />
     <PackageReference Update="xunit.core" Version="$(XUnitVersion)" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 979d04de7a6..133441c6169 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22116.15">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22212.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>40eacd2afc9cfd2ba892b5eadb3e728c1008fa38</Sha>
+      <Sha>1a6b24397e50146d0fece9cfb9c0b87275691e6f</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.1.0-rc.103">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.2.0-preview.2.109">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>f1906d3d581e0ea0bdd282134208d654f8447880</Sha>
+      <Sha>919c7e10ebdcc43235c36cf0b72c389d741835a8</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.1.0-3.22075.3">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.2.0-4.22212.4">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>592501cbb9c9394072a245c15b3458ff88155d85</Sha>
+      <Sha>f2d278f9a5131b7944d6ac5fecf2ce5b0a98195f</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22116.15">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22212.5">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>40eacd2afc9cfd2ba892b5eadb3e728c1008fa38</Sha>
+      <Sha>1a6b24397e50146d0fece9cfb9c0b87275691e6f</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 1e28bd46324..2c0103f8901 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,7 +2,7 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.2.0</VersionPrefix>
+    <VersionPrefix>17.3.0</VersionPrefix>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -32,10 +32,14 @@
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22116.15</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22212.5</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.1.0-3.22075.3</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.1.0-rc.103</NuGetBuildTasksVersion>
+    <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.2.0-4.22212.4</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.2.0-preview.2.109</NuGetBuildTasksVersion>
+    <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
+    <SystemTextJsonVersion>6.0.0</SystemTextJsonVersion>
+    <SystemThreadingTasksDataflowVersion>6.0.0</SystemThreadingTasksDataflowVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/common/templates/job/execute-sdl.yml b/eng/common/templates/job/execute-sdl.yml
index d0a1ea8b0f2..24cec0424e5 100644
--- a/eng/common/templates/job/execute-sdl.yml
+++ b/eng/common/templates/job/execute-sdl.yml
@@ -43,14 +43,9 @@ jobs:
       value: ${{ parameters.AzDOPipelineId }}
     - name: AzDOBuildId
       value: ${{ parameters.AzDOBuildId }}
-    # The Guardian version specified in 'eng/common/sdl/packages.config'. This value must be kept in
-    # sync with the packages.config file.
-    - name: DefaultGuardianVersion
-      value: 0.110.1
+    - template: /eng/common/templates/variables/sdl-variables.yml
     - name: GuardianVersion
       value: ${{ coalesce(parameters.overrideGuardianVersion, '$(DefaultGuardianVersion)') }}
-    - name: GuardianPackagesConfigFile
-      value: $(Build.SourcesDirectory)\eng\common\sdl\packages.config
   pool:
     # We don't use the collection uri here because it might vary (.visualstudio.com vs. dev.azure.com)
     ${{ if eq(variables['System.TeamProject'], 'DevDiv') }}:
@@ -126,57 +121,11 @@ jobs:
       displayName: Extract Archive Artifacts
       continueOnError: ${{ parameters.sdlContinueOnError }}
   
-  - ${{ if ne(parameters.overrideGuardianVersion, '') }}:
-    - powershell: |
-        $content = Get-Content $(GuardianPackagesConfigFile)
-
-        Write-Host "packages.config content was:`n$content"
-
-        $content = $content.Replace('$(DefaultGuardianVersion)', '$(GuardianVersion)')
-        $content | Set-Content $(GuardianPackagesConfigFile)
-
-        Write-Host "packages.config content updated to:`n$content"
-      displayName: Use overridden Guardian version ${{ parameters.overrideGuardianVersion }}
-
-  - task: NuGetToolInstaller@1
-    displayName: 'Install NuGet.exe'
-  - task: NuGetCommand@2
-    displayName: 'Install Guardian'
-    inputs:
-      restoreSolution: $(Build.SourcesDirectory)\eng\common\sdl\packages.config
-      feedsToUse: config
-      nugetConfigPath: $(Build.SourcesDirectory)\eng\common\sdl\NuGet.config
-      externalFeedCredentials: GuardianConnect
-      restoreDirectory: $(Build.SourcesDirectory)\.packages
-
-  - ${{ if ne(parameters.overrideParameters, '') }}:
-    - powershell: ${{ parameters.executeAllSdlToolsScript }} ${{ parameters.overrideParameters }}
-      displayName: Execute SDL
-      continueOnError: ${{ parameters.sdlContinueOnError }}
-  - ${{ if eq(parameters.overrideParameters, '') }}:
-    - powershell: ${{ parameters.executeAllSdlToolsScript }}
-        -GuardianPackageName Microsoft.Guardian.Cli.$(GuardianVersion)
-        -NugetPackageDirectory $(Build.SourcesDirectory)\.packages
-        -AzureDevOpsAccessToken $(dn-bot-dotnet-build-rw-code-rw)
-        ${{ parameters.additionalParameters }}
-      displayName: Execute SDL
-      continueOnError: ${{ parameters.sdlContinueOnError }}
-
-  - ${{ if ne(parameters.publishGuardianDirectoryToPipeline, 'false') }}:
-    # We want to publish the Guardian results and configuration for easy diagnosis. However, the
-    # '.gdn' dir is a mix of configuration, results, extracted dependencies, and Guardian default
-    # tooling files. Some of these files are large and aren't useful during an investigation, so
-    # exclude them by simply deleting them before publishing. (As of writing, there is no documented
-    # way to selectively exclude a dir from the pipeline artifact publish task.)
-    - task: DeleteFiles@1
-      displayName: Delete Guardian dependencies to avoid uploading
-      inputs:
-        SourceFolder: $(Agent.BuildDirectory)/.gdn
-        Contents: |
-          c
-          i
-      condition: succeededOrFailed()
-    - publish: $(Agent.BuildDirectory)/.gdn
-      artifact: GuardianConfiguration
-      displayName: Publish GuardianConfiguration
-      condition: succeededOrFailed()
+  - template: /eng/common/templates/steps/execute-sdl.yml
+    parameters:
+      overrideGuardianVersion: ${{ parameters.overrideGuardianVersion }}
+      executeAllSdlToolsScript: ${{ parameters.executeAllSdlToolsScript }}
+      overrideParameters: ${{ parameters.overrideParameters }}
+      additionalParameters: ${{ parameters.additionalParameters }}
+      publishGuardianDirectoryToPipeline: ${{ parameters.publishGuardianDirectoryToPipeline }}
+      sdlContinueOnError: ${{ parameters.sdlContinueOnError }}
diff --git a/eng/common/templates/jobs/codeql-build.yml b/eng/common/templates/jobs/codeql-build.yml
index f7dc5ea4aaa..54c393af440 100644
--- a/eng/common/templates/jobs/codeql-build.yml
+++ b/eng/common/templates/jobs/codeql-build.yml
@@ -21,7 +21,7 @@ jobs:
       # The Guardian version specified in 'eng/common/sdl/packages.config'. This value must be kept in
       # sync with the packages.config file.
       - name: DefaultGuardianVersion
-        value: 0.109.0
+        value: 0.110.1
       - name: GuardianPackagesConfigFile
         value: $(Build.SourcesDirectory)\eng\common\sdl\packages.config
       - name: GuardianVersion
diff --git a/eng/common/templates/jobs/jobs.yml b/eng/common/templates/jobs/jobs.yml
index 70d44735ace..554e71cfc43 100644
--- a/eng/common/templates/jobs/jobs.yml
+++ b/eng/common/templates/jobs/jobs.yml
@@ -8,10 +8,6 @@ parameters:
   # Optional: Enable publishing using release pipelines
   enablePublishUsingPipelines: false
 
-  # Optional: Disable component governance detection. In general, component governance
-  # should be on for all jobs. Use only in the event of issues.
-  disableComponentGovernance: false
-
   # Optional: Enable running the source-build jobs to build repo from source
   enableSourceBuild: false
 
diff --git a/eng/common/templates/steps/execute-sdl.yml b/eng/common/templates/steps/execute-sdl.yml
new file mode 100644
index 00000000000..7b8ee18a28d
--- /dev/null
+++ b/eng/common/templates/steps/execute-sdl.yml
@@ -0,0 +1,68 @@
+parameters:
+  overrideGuardianVersion: ''
+  executeAllSdlToolsScript: ''
+  overrideParameters: ''
+  additionalParameters: ''
+  publishGuardianDirectoryToPipeline: false
+  sdlContinueOnError: false
+  condition: ''
+
+steps:
+- ${{ if ne(parameters.overrideGuardianVersion, '') }}:
+  - powershell: |
+      $content = Get-Content $(GuardianPackagesConfigFile)
+
+      Write-Host "packages.config content was:`n$content"
+
+      $content = $content.Replace('$(DefaultGuardianVersion)', '$(GuardianVersion)')
+      $content | Set-Content $(GuardianPackagesConfigFile)
+
+      Write-Host "packages.config content updated to:`n$content"
+    displayName: Use overridden Guardian version ${{ parameters.overrideGuardianVersion }}
+
+- task: NuGetToolInstaller@1
+  displayName: 'Install NuGet.exe'
+  
+- task: NuGetCommand@2
+  displayName: 'Install Guardian'
+  inputs:
+    restoreSolution: $(Build.SourcesDirectory)\eng\common\sdl\packages.config
+    feedsToUse: config
+    nugetConfigPath: $(Build.SourcesDirectory)\eng\common\sdl\NuGet.config
+    externalFeedCredentials: GuardianConnect
+    restoreDirectory: $(Build.SourcesDirectory)\.packages
+
+- ${{ if ne(parameters.overrideParameters, '') }}:
+  - powershell: ${{ parameters.executeAllSdlToolsScript }} ${{ parameters.overrideParameters }}
+    displayName: Execute SDL
+    continueOnError: ${{ parameters.sdlContinueOnError }}
+    condition: ${{ parameters.condition }}
+
+- ${{ if eq(parameters.overrideParameters, '') }}:
+  - powershell: ${{ parameters.executeAllSdlToolsScript }}
+      -GuardianPackageName Microsoft.Guardian.Cli.$(GuardianVersion)
+      -NugetPackageDirectory $(Build.SourcesDirectory)\.packages
+      -AzureDevOpsAccessToken $(dn-bot-dotnet-build-rw-code-rw)
+      ${{ parameters.additionalParameters }}
+    displayName: Execute SDL
+    continueOnError: ${{ parameters.sdlContinueOnError }}
+    condition: ${{ parameters.condition }}
+
+- ${{ if ne(parameters.publishGuardianDirectoryToPipeline, 'false') }}:
+  # We want to publish the Guardian results and configuration for easy diagnosis. However, the
+  # '.gdn' dir is a mix of configuration, results, extracted dependencies, and Guardian default
+  # tooling files. Some of these files are large and aren't useful during an investigation, so
+  # exclude them by simply deleting them before publishing. (As of writing, there is no documented
+  # way to selectively exclude a dir from the pipeline artifact publish task.)
+  - task: DeleteFiles@1
+    displayName: Delete Guardian dependencies to avoid uploading
+    inputs:
+      SourceFolder: $(Agent.BuildDirectory)/.gdn
+      Contents: |
+        c
+        i
+    condition: succeededOrFailed()
+  - publish: $(Agent.BuildDirectory)/.gdn
+    artifact: GuardianConfiguration
+    displayName: Publish GuardianConfiguration
+    condition: succeededOrFailed()
\ No newline at end of file
diff --git a/eng/common/templates/steps/source-build.yml b/eng/common/templates/steps/source-build.yml
index ba40dc82f14..abb1b2bcda4 100644
--- a/eng/common/templates/steps/source-build.yml
+++ b/eng/common/templates/steps/source-build.yml
@@ -43,8 +43,8 @@ steps:
     # In that case, add variables to allow the download of internal runtimes if the specified versions are not found
     # in the default public locations.
     internalRuntimeDownloadArgs=
-    if [ '$(dotnetclimsrc-read-sas-token-base64)' != '$''(dotnetclimsrc-read-sas-token-base64)' ]; then
-      internalRuntimeDownloadArgs='/p:DotNetRuntimeSourceFeed=https://dotnetclimsrc.blob.core.windows.net/dotnet /p:DotNetRuntimeSourceFeedKey=$(dotnetclimsrc-read-sas-token-base64) --runtimesourcefeed https://dotnetclimsrc.blob.core.windows.net/dotnet --runtimesourcefeedkey $(dotnetclimsrc-read-sas-token-base64)'
+    if [ '$(dotnetbuilds-internal-container-read-token-base64)' != '$''(dotnetbuilds-internal-container-read-token-base64)' ]; then
+      internalRuntimeDownloadArgs='/p:DotNetRuntimeSourceFeed=https://dotnetbuilds.blob.core.windows.net/internal /p:DotNetRuntimeSourceFeedKey=$(dotnetbuilds-internal-container-read-token-base64) --runtimesourcefeed https://dotnetbuilds.blob.core.windows.net/internal --runtimesourcefeedkey $(dotnetbuilds-internal-container-read-token-base64)'
     fi
 
     buildConfig=Release
diff --git a/eng/common/templates/variables/sdl-variables.yml b/eng/common/templates/variables/sdl-variables.yml
new file mode 100644
index 00000000000..1a860bd0406
--- /dev/null
+++ b/eng/common/templates/variables/sdl-variables.yml
@@ -0,0 +1,7 @@
+variables:
+# The Guardian version specified in 'eng/common/sdl/packages.config'. This value must be kept in
+# sync with the packages.config file.
+- name: DefaultGuardianVersion
+  value: 0.110.1
+- name: GuardianPackagesConfigFile
+  value: $(Build.SourcesDirectory)\eng\common\sdl\packages.config
\ No newline at end of file
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 3b471cecb99..7eeacbf3444 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -12,14 +12,21 @@
     <PackageReference Update="LargeAddressAware" Version="1.0.5" />
     <PackageReference Update="Microsoft.CodeAnalysis.PublicApiAnalyzers" Version="3.3.3" />
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" />
-    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.0.4496" PrivateAssets="All" />
+    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.1.2196" PrivateAssets="All" />
+    <PackageReference Update="Microsoft.Win32.Registry" Version="5.0.0" />
     <PackageReference Update="PdbGit" Version="3.0.41" />
     <PackageReference Update="Shouldly" Version="3.0.0" />
+    <PackageReference Update="System.CodeDom" Version="4.4.0" />
+    <PackageReference Update="System.Private.Uri" Version="4.3.2" />
+    <PackageReference Update="System.Runtime" Version="4.3.1" />
+    <PackageReference Update="System.Security.Cryptography.Pkcs" Version="6.0.0" />
+    <PackageReference Update="System.Security.Cryptography.Xml" Version="6.0.0" />
+    <PackageReference Update="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
     <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="3.3.3" />
-    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.354" PrivateAssets="all"/>
+    <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.406" PrivateAssets="all"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/global.json b/global.json
index 853a648e358..02afe6e7bef 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22116.15"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22212.5"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs b/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
index 05fa6347ad6..db06dd22a74 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectItemGroupElement_tests.cs
@@ -5,6 +5,7 @@
 using System.Xml;
 
 using Microsoft.Build.Construction;
+using Shouldly;
 using Xunit;
 
 #nullable disable
@@ -70,6 +71,49 @@ public void ReadItemGroupTwoItems()
             Assert.Equal("i2", items[1].Include);
         }
 
+        [Fact]
+        public void DeepCopyFromItemGroupWithMetadata()
+        {
+            string content = @"
+                    <Project>
+                        <ItemGroup>
+                            <i Include='i1'>
+                              <M>metadataValue</M>
+                            </i>
+                            <i Include='i2'>
+                              <M>
+                                <Some>
+                                    <Xml With='Nesting' />
+                                </Some>
+                              </M>
+                            </i>
+                        </ItemGroup>
+                    </Project>
+                ";
+
+            ProjectRootElement project = ProjectRootElement.Create(XmlReader.Create(new StringReader(content)));
+            ProjectItemGroupElement group = (ProjectItemGroupElement)Helpers.GetFirst(project.Children);
+
+            ProjectRootElement newProject = ProjectRootElement.Create();
+            ProjectItemGroupElement newItemGroup = project.AddItemGroup();
+
+            newItemGroup.DeepCopyFrom(group);
+
+            var items = Helpers.MakeList(newItemGroup.Items);
+
+            items.Count.ShouldBe(2);
+
+            items[0].Include.ShouldBe("i1");
+            ProjectMetadataElement metadataElement = items[0].Metadata.ShouldHaveSingleItem();
+            metadataElement.Name.ShouldBe("M");
+            metadataElement.Value.ShouldBe("metadataValue");
+
+            items[1].Include.ShouldBe("i2");
+            metadataElement = items[1].Metadata.ShouldHaveSingleItem();
+            metadataElement.Name.ShouldBe("M");
+            metadataElement.Value.ShouldBe("<Some><Xml With=\"Nesting\" /></Some>");
+        }
+
         /// <summary>
         /// Set the condition value
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index 42ff3d408de..c39946e0c80 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -7,9 +7,11 @@
 using System.Linq;
 using System.Xml;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Engine.UnitTests.Globbing;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Shouldly;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
@@ -31,6 +33,7 @@ public class ProjectItem_Tests : IDisposable
                         </ItemGroup>
                     </Project>
                 ";
+
         internal const string ItemWithIncludeUpdateAndRemove = @"
                     <Project>
                         <ItemGroup>
@@ -45,6 +48,12 @@ public class ProjectItem_Tests : IDisposable
                     </Project>
                 ";
 
+        internal const string ImportProjectElement = @"
+                    <Project>
+                        <Import Project='{0}'/>
+                    </Project>
+                ";
+
         protected TestEnvironment _env;
 
         public ProjectItem_Tests()
@@ -755,6 +764,220 @@ public void IncludeWithWildcardShouldNotPreserveUserSlashesInFixedDirectoryPart(
             TestIncludeExclude(projectContents, inputFiles, expectedInclude, includeString, "");
         }
 
+        /// <summary>
+        /// Project getter that renames an item to a drive enumerating wildcard that results in an exception.
+        /// </summary>
+        [Theory]
+        [InlineData(@"\**\*.log")]
+        [InlineData(@"$(empty)\**\*.log")]
+        [InlineData(@"\$(empty)**\*.log")]
+        [InlineData(@"\*$(empty)*\*.log")]
+        public void ProjectGetterResultsInDriveEnumerationException(string unevaluatedInclude)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                try
+                {
+                    // Setup
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "1");
+                    Project project = new Project();
+
+                    // Add item and verify
+                    Should.Throw<InvalidProjectFileException>(() => { _ = project.AddItem("i", unevaluatedInclude); });
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
+
+        /// <summary>
+        /// Project getter that renames an item to a drive enumerating wildcard that results in a logged warning.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"z:\**\*.log")]
+        [InlineData(@"z:$(empty)\**\*.log")]
+        [InlineData(@"z:\**")]
+        [InlineData(@"z:\\**")]
+        [InlineData(@"z:\\\\\\\\**")]
+        [InlineData(@"z:\**\*.cs")]
+        public void ProjectGetterResultsInWindowsDriveEnumerationWarning(string unevaluatedInclude)
+        {
+            ProjectGetterResultsInDriveEnumerationWarning(unevaluatedInclude);
+        }
+
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"/**/*.log")]
+        [InlineData(@"$(empty)/**/*.log")]
+        [InlineData(@"/$(empty)**/*.log")]
+        [InlineData(@"/*$(empty)*/*.log")]
+        public void ProjectGetterResultsInUnixDriveEnumerationWarning(string unevaluatedInclude)
+        {
+            ProjectGetterResultsInDriveEnumerationWarning(unevaluatedInclude);
+        }
+
+        private static void ProjectGetterResultsInDriveEnumerationWarning(string unevaluatedInclude)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                try
+                {
+                    // Reset state
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "0");
+
+                    // Setup
+                    ProjectCollection projectCollection = new ProjectCollection();
+                    MockLogger collectionLogger = new MockLogger();
+                    projectCollection.RegisterLogger(collectionLogger);
+                    Project project = new Project(projectCollection);
+
+                    // Add item
+                    _= project.AddItem("i", unevaluatedInclude);
+
+                    // Verify
+                    collectionLogger.WarningCount.ShouldBe(1);
+                    collectionLogger.AssertLogContains("MSB5029");
+                    projectCollection.UnregisterAllLoggers();
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
+
+        /// <summary>
+        /// Project instance created from a file that contains a drive enumerating wildcard results in a thrown exception.
+        /// </summary>
+        [Theory]
+        [InlineData(
+            ImportProjectElement,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            null)]
+
+        // LazyItem.IncludeOperation
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        // LazyItem.IncludeOperation for Exclude
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(EmptyProperty)\*.cs",
+            @"$(Microsoft_WindowsAzure_EngSys)\**")]
+        public void ThrowExceptionUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
+        {
+            content = string.Format(content, placeHolder, excludePlaceHolder);
+            CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, true);
+        }
+
+        /// <summary>
+        /// Project instance created from a file that contains a drive enumerating wildcard results in a logged warning on the Windows platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            ImportProjectElement,
+            @"z:\**\*.targets",
+            null)]
+
+        // LazyItem.IncludeOperation
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        // LazyItem.IncludeOperation for Exclude
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(EmptyProperty)\*.cs",
+            @"z:\$(Microsoft_WindowsAzure_EngSys)**")]
+        public void LogWindowsWarningUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
+        {
+            content = string.Format(content, placeHolder, excludePlaceHolder);
+            CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, false);
+        }
+
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(
+            ImportProjectElement,
+            @"\**\*.targets",
+            null)]
+
+        // LazyItem.IncludeOperation
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        // LazyItem.IncludeOperation for Exclude
+        [InlineData(
+            ItemWithIncludeAndExclude,
+            @"$(EmptyProperty)\*.cs",
+            @"$(Microsoft_WindowsAzure_EngSys)\**")]
+        public void LogWarningUponProjectInstanceCreationFromDriveEnumeratingContent(string content, string placeHolder, string excludePlaceHolder = null)
+        {
+            content = string.Format(content, placeHolder, excludePlaceHolder);
+                CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(content, false);
+        }
+
+        private static void CleanContentsAndCreateProjectInstanceFromFileWithDriveEnumeratingWildcard(string content, bool throwException)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                // Clean file contents by replacing single quotes with double quotes, etc.
+                content = ObjectModelHelpers.CleanupFileContents(content);
+                var testProject = env.CreateTestProjectWithFiles(content.Cleanup());
+
+                // Setup and create project instance from file
+                CreateProjectInstanceFromFileWithDriveEnumeratingWildcard(env, testProject.ProjectFile, throwException);
+            }
+        }
+
+        private static void CreateProjectInstanceFromFileWithDriveEnumeratingWildcard(TestEnvironment env, string testProjectFile, bool throwException)
+        {
+            try
+            {
+                // Reset state 
+                Helpers.ResetStateForDriveEnumeratingWildcardTests(env, throwException ? "1" : "0");
+
+                if (throwException)
+                {
+                    // Verify
+                    Should.Throw<InvalidProjectFileException>(() => { ProjectInstance.FromFile(testProjectFile, new ProjectOptions()); });
+                }
+                else
+                {
+                    // Setup
+                    MockLogger collectionLogger = new MockLogger();
+                    ProjectOptions options = new ProjectOptions();
+                    options.ProjectCollection = new ProjectCollection();
+                    options.ProjectCollection.RegisterLogger(collectionLogger);
+
+                    // Action
+                    ProjectInstance.FromFile(testProjectFile, options);
+
+                    // Verify
+                    collectionLogger.WarningCount.ShouldBe(1);
+                    collectionLogger.AssertLogContains("MSB5029");
+                    options.ProjectCollection.UnregisterAllLoggers();
+                }
+            }
+            finally
+            {
+                ChangeWaves.ResetStateForTests();
+            }
+        }
+
         private static void TestIncludeExcludeWithDifferentSlashes(string projectContents, string includeString, string excludeString, string[] inputFiles, string[] expectedInclude, bool makeExpectedIncludeAbsolute = false)
         {
             Action<string, string> runTest = (include, exclude) =>
@@ -909,7 +1132,7 @@ public void IncludeAndExcludeWorkWithRelativeAndAbsolutePaths(
         [InlineData(
             "../a.cs;b.cs", // include string
             "**/*.cs", // exclude string
-            new[] { "a.cs", "ProjectDir/b.cs" }, // files to create relative to the test root dir
+            new[] {"a.cs", "ProjectDir/b.cs"}, // files to create relative to the test root dir
             "ProjectDir", // relative path from test root to project
             new[] { "../a.cs" } // expected items
             )]
diff --git a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
index 02e91aa5a06..c3316bb2267 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectItemInstance_Tests.cs
@@ -7,6 +7,7 @@
 using System.Xml;
 
 using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -14,6 +15,7 @@
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Xunit;
+using Shouldly;
 using System.Linq;
 
 #nullable disable
@@ -30,6 +32,39 @@ public class ProjectItemInstance_Tests
         /// </summary>
         public const int BuiltInMetadataCount = 15;
 
+        internal const string TargetItemWithInclude = @"
+            <Project>
+                <Target Name='TestTarget'>
+                    <ItemGroup>
+                        <i Include='{0}'/>
+                    </ItemGroup>
+                </Target>
+            </Project>
+            ";
+
+        internal const string TargetItemWithIncludeAndExclude = @"
+            <Project>
+                <Target Name='TestTarget'>
+                    <ItemGroup>
+                        <i Include='{0}' Exclude='{1}'/>
+                    </ItemGroup>
+                </Target>
+            </Project>
+            ";
+
+        internal const string TargetWithDefinedPropertyAndItemWithInclude = @"
+            <Project>
+                <PropertyGroup>
+                    <{0}>{1}</{0}>
+                </PropertyGroup>
+                <Target Name='TestTarget'>
+                    <ItemGroup>
+                        <i Include='{2}' />
+                    </ItemGroup>
+                </Target>
+            </Project>
+            ";
+
         /// <summary>
         /// Basic ProjectItemInstance without metadata
         /// </summary>
@@ -837,6 +872,162 @@ public void MetadataConditionReferringToMetadataOnSameItem()
             Assert.Equal(String.Empty, items[0].GetMetadataValue("m2"));
         }
 
+        /// <summary>
+        /// Fail build for drive enumerating wildcards that exist in projects on any platform.
+        /// </summary>
+        [Theory]
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb",
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*")]
+
+        [InlineData(
+            TargetItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            "$(Microsoft_WindowsAzure_EngSys)**",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"\")]
+        public void ThrowExceptionUponBuildingProjectWithDriveEnumeration(string content, string include, string exclude = null, string property = null, string propertyValue = null)
+        {
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                string.Format(content, include, exclude) :
+                string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "1",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.FailWithError);
+        }
+
+        /// <summary>
+        /// Log warning for drive enumerating wildcards that exist in projects on Windows platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*",
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb;$(Microsoft_WindowsAzure_EngSys)\Microsoft.WindowsAzure.Storage.dll;$(Microsoft_WindowsAzure_EngSys)\Certificates\**\*")]
+
+        [InlineData(
+            TargetItemWithIncludeAndExclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\*.pdb",
+            @"z:$(Microsoft_WindowsAzure_EngSys)\**\*")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)**",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"z:\")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)\**\*",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"z:")]
+        public void LogWindowsWarningUponBuildingProjectWithDriveEnumeration(string content, string include, string exclude = null, string property = null, string propertyValue = null)
+        {
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                string.Format(content, include, exclude) :
+                string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "0",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.SucceedWithWarning);
+        }
+
+        /// <summary>
+        /// Log warning for drive enumerating wildcards that exist in projects on Unix platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)**",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"/")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)*/*.log",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"/*")]
+        public void LogUnixWarningUponBuildingProjectWithDriveEnumeration(string content, string include, string exclude = null, string property = null, string propertyValue = null)
+        {
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                    string.Format(content, include, exclude) :
+                    string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                    content,
+                    "0",
+                    "TestTarget",
+                    Helpers.ExpectedBuildResult.SucceedWithWarning);
+        }
+
+        /// <summary>
+        /// Tests target item evaluation resulting in no build failures.
+        /// </summary>
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)*.cs",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"c:\*\")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"\$(Microsoft_WindowsAzure_EngSys)*\*.cs",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"c:")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @":\$(Microsoft_WindowsAzure_EngSys)*\*.log",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"c")]
+
+        [InlineData(
+            TargetWithDefinedPropertyAndItemWithInclude,
+            @"$(Microsoft_WindowsAzure_EngSys)*\*.log",
+            null,
+            "Microsoft_WindowsAzure_EngSys",
+            @"\")]
+        public void NoErrorsAndWarningsUponBuildingProject(string content, string include, string exclude = null, string property = null, string propertyValue = null)
+        {
+            content = (string.IsNullOrEmpty(property) && string.IsNullOrEmpty(propertyValue)) ?
+                    string.Format(content, include, exclude) :
+                    string.Format(content, property, propertyValue, include);
+
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "0",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.SucceedWithNoErrorsAndWarnings);
+        }
+
         [Fact]
         public void UpdateShouldRespectConditions()
         {
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 00221821ec4..9760dcf7a92 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -31,11 +31,6 @@
     <Content Condition="'$(MSBuildRuntimeType)' != 'Core' and '$(Configuration)' == 'Release'" Include="$(NuGetPackageRoot)\nuget.commandline\$(NuGetCommandLinePackageVersion)\tools\NuGet.exe" CopyToOutputDirectory="PreserveNewest" Link="nuget\NuGet.exe" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-  </ItemGroup>
-
   <ItemGroup>
     <Compile Include="..\Shared\EncodingStringWriter.cs">
       <Link>EncodingStringWriter.cs</Link>
diff --git a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
index f1e11354289..023b16eb686 100644
--- a/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
+++ b/src/Build.UnitTests/BuildEnvironmentHelper_Tests.cs
@@ -369,6 +369,7 @@ public void BuildEnvironmentFindsAmd64()
         }
 
         [Fact]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
         [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentFindsAmd64RunningInAmd64NoVS()
         {
@@ -386,6 +387,7 @@ public void BuildEnvironmentFindsAmd64RunningInAmd64NoVS()
         }
 
         [Fact]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
         [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentFindsAmd64NoVS()
         {
@@ -401,6 +403,7 @@ public void BuildEnvironmentFindsAmd64NoVS()
         }
 
         [Fact]
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7552", TargetFrameworkMonikers.Any)]
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "No Visual Studio install for netcore")]
         [PlatformSpecific(TestPlatforms.Windows)]
         public void BuildEnvironmentFindsAmd64RunningInAmd64()
diff --git a/src/Build.UnitTests/Scanner_Tests.cs b/src/Build.UnitTests/Scanner_Tests.cs
index 2f7c912bf71..ae6880ac5bd 100644
--- a/src/Build.UnitTests/Scanner_Tests.cs
+++ b/src/Build.UnitTests/Scanner_Tests.cs
@@ -133,24 +133,6 @@ public void SpaceInMiddleOfProperty(string pattern)
             lexer._errorState.ShouldBeFalse();
         }
 
-        [Fact]
-        public void SpacePropertyOptOutWave16_10()
-        {
-            using TestEnvironment env = TestEnvironment.Create();
-            ChangeWaves.ResetStateForTests();
-            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
-            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-            Scanner lexer = new Scanner("$(x )", ParserOptions.AllowProperties);
-            AdvanceToScannerError(lexer);
-            Assert.Null(lexer.UnexpectedlyFound);
-
-            lexer = new Scanner("$( x)", ParserOptions.AllowProperties);
-            AdvanceToScannerError(lexer);
-            Assert.Null(lexer.UnexpectedlyFound);
-            ChangeWaves.ResetStateForTests();
-        }
-
         /// <summary>
         /// Tests the special errors for "@(" and "@x" and similar cases.
         /// </summary>
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 1c08e288d57..50062bec8cf 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -34,6 +34,7 @@
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 
 using Microsoft.NET.StringTools;
+using System.ComponentModel;
 
 #nullable disable
 
@@ -176,6 +177,11 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private int _nextBuildSubmissionId;
 
+        /// <summary>
+        /// The last BuildParameters used for building.
+        /// </summary>
+        private bool? _previousLowPriority = null;
+
         /// <summary>
         /// Mapping of unnamed project instances to the file names assigned to them.
         /// </summary>
@@ -404,6 +410,15 @@ public void BeginBuild(BuildParameters parameters, IEnumerable<DeferredBuildMess
             _deferredBuildMessages = null;
         }
 
+        private void UpdatePriority(Process p, ProcessPriorityClass priority)
+        {
+            try
+            {
+                p.PriorityClass = priority;
+            }
+            catch (Win32Exception) { }
+        }
+
         /// <summary>
         /// Prepares the BuildManager to receive build requests.
         /// </summary>
@@ -411,6 +426,41 @@ public void BeginBuild(BuildParameters parameters, IEnumerable<DeferredBuildMess
         /// <exception cref="InvalidOperationException">Thrown if a build is already in progress.</exception>
         public void BeginBuild(BuildParameters parameters)
         {
+            if (_previousLowPriority != null)
+            {
+                if (parameters.LowPriority != _previousLowPriority)
+                {
+                    if (NativeMethodsShared.IsWindows || parameters.LowPriority)
+                    {
+                        ProcessPriorityClass priority = parameters.LowPriority ? ProcessPriorityClass.BelowNormal : ProcessPriorityClass.Normal;
+                        IEnumerable<Process> processes = _nodeManager?.GetProcesses();
+                        if (processes is not null)
+                        {
+                            foreach (Process p in processes)
+                            {
+                                UpdatePriority(p, priority);
+                            }
+                        }
+
+                        processes = _taskHostNodeManager?.GetProcesses();
+                        if (processes is not null)
+                        {
+                            foreach (Process p in processes)
+                            {
+                                UpdatePriority(p, priority);
+                            }
+                        }
+                    }
+                    else
+                    {
+                        _nodeManager?.ShutdownAllNodes();
+                        _taskHostNodeManager?.ShutdownAllNodes();
+                    }
+               }
+            }
+
+            _previousLowPriority = parameters.LowPriority;
+
             lock (_syncLock)
             {
                 AttachDebugger();
diff --git a/src/Build/BackEnd/Components/Communications/INodeManager.cs b/src/Build/BackEnd/Components/Communications/INodeManager.cs
index 161fb779341..e1562a6d20a 100644
--- a/src/Build/BackEnd/Components/Communications/INodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeManager.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
+using System.Diagnostics;
 using Microsoft.Build.Execution;
 
 #nullable disable
@@ -51,6 +53,8 @@ internal interface INodeManager : IBuildComponent,
         /// The node manager contains state which is not supposed to persist between builds, make sure this is cleared.
         /// </summary>
         void ClearPerBuildState();
+
+        IEnumerable<Process> GetProcesses();
         #endregion
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/INodeProvider.cs b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
index 1a3f6b84ade..acb65f7681f 100644
--- a/src/Build/BackEnd/Components/Communications/INodeProvider.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
@@ -3,6 +3,10 @@
 
 #nullable disable
 
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+
 namespace Microsoft.Build.BackEnd
 {
     /// <summary>
@@ -83,6 +87,8 @@ int AvailableNodes
         /// Shuts down all of the managed nodes.  This call will not return until all nodes are shut down.
         /// </summary>
         void ShutdownAllNodes();
+
+        IEnumerable<Process> GetProcesses();
         #endregion
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index 491724c630d..6881debdae2 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -24,6 +24,8 @@ internal class NodeEndpointOutOfProc : NodeEndpointOutOfProcBase
 
         private readonly bool _lowPriority;
 
+        internal bool LowPriority { get { return _lowPriority; } }
+
         #endregion
 
         #region Constructors and Factories
@@ -54,7 +56,7 @@ internal NodeEndpointOutOfProc(
         /// </summary>
         protected override IHandshake GetHandshake()
         {
-            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, is64Bit: EnvironmentUtilities.Is64BitProcess, nodeReuse: _enableReuse, lowPriority: _lowPriority));
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture(), nodeReuse: _enableReuse, lowPriority: _lowPriority));
         }
 
         #region Structs
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index bd6dd68088c..e63ab105bfd 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -5,6 +5,8 @@
 using System.Collections.Generic;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
+using System.Diagnostics;
+using System.Linq;
 
 #nullable disable
 
@@ -347,5 +349,10 @@ private int AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration node
             _nodeIdToProvider.Add(nodeId, nodeProvider);
             return nodeId;
         }
+
+        public IEnumerable<Process> GetProcesses()
+        {
+            return _outOfProcNodeProvider.GetProcesses();
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 18e965c027b..8d221aaa2b0 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -2,6 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Generic;
+using System.Diagnostics;
 using System.Globalization;
 using System.Threading;
 using Microsoft.Build.Internal;
@@ -439,6 +441,9 @@ private void Dispose(bool disposing)
             }
         }
 
+        // The process here is the same as in the main node.
+        public IEnumerable<Process> GetProcesses() => throw new NotImplementedException();
+
         #endregion
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 2430e450cac..b27d5ee93e0 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -8,7 +8,7 @@
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
-using Microsoft.Build.Utilities;
+using System.Linq;
 
 #nullable disable
 
@@ -69,7 +69,7 @@ public int AvailableNodes
         internal static Handshake GetHandshake(bool enableNodeReuse, bool enableLowPriority)
         {
             CommunicationsUtilities.Trace("MSBUILDNODEHANDSHAKESALT=\"{0}\", msbuildDirectory=\"{1}\", enableNodeReuse={2}, enableLowPriority={3}", Traits.MSBuildNodeHandshakeSalt, BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32, enableNodeReuse, enableLowPriority);
-            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: enableNodeReuse, lowPriority: enableLowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
+            return new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture(), nodeReuse: enableNodeReuse, lowPriority: enableLowPriority));
         }
 
         /// <summary>
@@ -94,7 +94,7 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
             // Make it here.
             CommunicationsUtilities.Trace("Starting to acquire a new or existing node to establish node ID {0}...", nodeId);
 
-            Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority, is64Bit: EnvironmentUtilities.Is64BitProcess));
+            Handshake hostHandshake = new Handshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture(), nodeReuse: ComponentHost.BuildParameters.EnableNodeReuse, lowPriority: ComponentHost.BuildParameters.LowPriority));
             NodeContext context = GetNode(null, commandLineArgs, nodeId, factory, hostHandshake, NodeContextTerminated);
 
             if (context != null)
@@ -202,5 +202,10 @@ private void NodeContextTerminated(int nodeId)
                 _nodeContexts.Remove(nodeId);
             }
         }
+
+        public IEnumerable<Process> GetProcesses()
+        {
+            return _nodeContexts.Values.Select(context => context.Process);
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 07210e39621..ec334e698b5 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -665,6 +665,8 @@ enum ExitPacketState
             /// </summary>
             private readonly Process _process;
 
+            internal Process Process { get { return _process; } }
+
             /// <summary>
             /// An array used to store the header byte for each packet when read.
             /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 7ac00b41d4d..453bd4346fc 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -9,6 +9,7 @@
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Internal;
+using System.Linq;
 
 #nullable disable
 
@@ -37,6 +38,11 @@ internal class NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase, INodeP
         /// </summary>
         private static string s_baseTaskHostPath64;
 
+        /// <summary>
+        /// Store the 64-bit path for MSBuild / MSBuildTaskHost so that we don't have to keep recalculating it.
+        /// </summary>
+        private static string s_baseTaskHostPathArm64;
+
         /// <summary>
         /// Store the path for the 32-bit MSBuildTaskHost so that we don't have to keep re-calculating it.
         /// </summary>
@@ -57,6 +63,11 @@ internal class NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase, INodeP
         /// </summary>
         private static string s_pathToX64Clr4;
 
+        /// <summary>
+        /// Store the path for the 64-bit MSBuild so that we don't have to keep re-calculating it.
+        /// </summary>
+        private static string s_pathToArm64Clr4;
+
         /// <summary>
         /// Name for MSBuild.exe
         /// </summary>
@@ -353,8 +364,10 @@ internal static void ClearCachedTaskHostPaths()
             s_pathToX32Clr4 = null;
             s_pathToX64Clr2 = null;
             s_pathToX64Clr4 = null;
+            s_pathToArm64Clr4 = null;
             s_baseTaskHostPath = null;
             s_baseTaskHostPath64 = null;
+            s_baseTaskHostPathArm64 = null;
         }
 
         /// <summary>
@@ -392,13 +405,20 @@ internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostConte
         internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostContext)
         {
             string toolName = GetTaskHostNameFromHostContext(hostContext);
-            string toolPath;
+            string toolPath = null;
 
             s_baseTaskHostPath = BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
             s_baseTaskHostPath64 = BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64;
+            s_baseTaskHostPathArm64 = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryArm64;
+
             ErrorUtilities.VerifyThrowInternalErrorUnreachable((hostContext & HandshakeOptions.TaskHost) == HandshakeOptions.TaskHost);
 
-            if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64 && (hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
+            if ((hostContext & HandshakeOptions.Arm64) == HandshakeOptions.Arm64 && (hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
+            {
+                // Unsupported, throw.
+                ErrorUtilities.ThrowInternalError("ARM64 CLR2 task hosts are not supported.");
+            }
+            else if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64 && (hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
             {
                 if (s_pathToX64Clr2 == null)
                 {
@@ -434,6 +454,15 @@ internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostCo
 
                 toolPath = s_pathToX64Clr4;
             }
+            else if ((hostContext & HandshakeOptions.Arm64) == HandshakeOptions.Arm64)
+            {
+                if (s_pathToArm64Clr4 == null)
+                {
+                    s_pathToArm64Clr4 = s_baseTaskHostPathArm64;
+                }
+
+                toolPath = s_pathToArm64Clr4;
+            }
             else
             {
                 if (s_pathToX32Clr4 == null)
@@ -509,7 +538,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
 
             // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we
             // want to start up an MSBuild task host node.
-            string commandLineArgs = $" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} ";
+            string commandLineArgs = $" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority} ";
 
             string msbuildLocation = GetMSBuildLocationFromHostContext(hostContext);
 
@@ -572,5 +601,10 @@ private void NodeContextTerminated(int nodeId)
                 }
             }
         }
+
+        public IEnumerable<Process> GetProcesses()
+        {
+            return _nodeContexts.Values.Select(context => context.Process);
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index 7c539f906e9..91eb535887d 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -4,6 +4,8 @@
 using System;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Execution;
+using System.Collections.Generic;
+using System.Diagnostics;
 
 #nullable disable
 
@@ -171,5 +173,10 @@ static internal IBuildComponent CreateComponent(BuildComponentType type)
             ErrorUtilities.VerifyThrow(type == BuildComponentType.TaskHostNodeManager, "Cannot create component of type {0}", type);
             return new TaskHostNodeManager();
         }
+
+        IEnumerable<Process> INodeManager.GetProcesses()
+        {
+            return _outOfProcTaskHostNodeProvider.GetProcesses();
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index d39ce74cb49..505bc1d2df1 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -372,7 +372,6 @@ ISet<string> removeMetadata
         )
         {
             // todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
-
             ProjectErrorUtilities.VerifyThrowInvalidProject(!(keepMetadata != null && removeMetadata != null), originalItem.KeepMetadataLocation, "KeepAndRemoveMetadataMutuallyExclusive");
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
@@ -433,7 +432,11 @@ ISet<string> removeMetadata
                     string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(
                         Project.Directory,
                         includeSplit,
-                        excludes);
+                        excludes,
+                        loggingMechanism: LoggingContext,
+                        includeLocation: originalItem.IncludeLocation,
+                        excludeLocation: originalItem.ExcludeLocation,
+                        disableExcludeDriveEnumerationWarning: true);
 
                     foreach (string includeSplitFile in includeSplitFiles)
                     {
@@ -454,7 +457,11 @@ ISet<string> removeMetadata
 
             foreach (string excludeSplit in excludes)
             {
-                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(Project.Directory, excludeSplit);
+                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(
+                    Project.Directory,
+                    excludeSplit,
+                    loggingMechanism: LoggingContext,
+                    excludeLocation: originalItem.ExcludeLocation);
 
                 foreach (string excludeSplitFile in excludeSplitFiles)
                 {
@@ -539,7 +546,12 @@ Expander<ProjectPropertyInstance, ProjectItemInstance> expander
                 // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them
                 // as literals. Everything else is safe to unescape at this point, since we're only matching
                 // against the file system.
-                string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);
+                string[] fileList = EngineFileUtilities.GetFileListEscaped(
+                    Project.Directory,
+                    piece,
+                    loggingMechanism: LoggingContext,
+                    includeLocation: specificationLocation,
+                    excludeLocation: specificationLocation);
 
                 foreach (string file in fileList)
                 {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index b5c40b3cc79..ec05dfd174f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -399,8 +399,19 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
             // If this is an Intrinsic task, it gets handled in a special fashion.
             if (_taskNode == null)
             {
-                ExecuteIntrinsicTask(bucket);
-                taskResult = new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null);
+                try
+                {
+                    ExecuteIntrinsicTask(bucket);
+                    taskResult = new WorkUnitResult(WorkUnitResultCode.Success, WorkUnitActionCode.Continue, null);
+                }
+                catch (InvalidProjectFileException e)
+                {
+                    // Make sure the Invalid Project error gets logged *before* TaskFinished.  Otherwise,
+                    // the log is confusing.
+                    _targetLoggingContext.LogInvalidProjectFileError(e);
+                    _continueOnError = ContinueOnError.ErrorAndStop;
+                    taskResult = new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, e);
+                }
             }
             else
             {
@@ -461,6 +472,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                             // the log is confusing.
                             taskLoggingContext.LogInvalidProjectFileError(e);
                             _continueOnError = ContinueOnError.ErrorAndStop;
+                            taskResult = new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, e);
                         }
                         finally
                         {
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 87666f95341..4ec872e6718 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -38,10 +38,12 @@ public override void ClearCaches()
 
         public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
-            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStart(sdk.Name, solutionPath, projectPath);
-
             SdkResult result;
 
+            bool wasResultCached = true;
+
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStart(sdk.Name, solutionPath, projectPath);
+
             if (Traits.Instance.EscapeHatches.DisableSdkResolutionCache)
             {
                 result = base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
@@ -59,7 +61,12 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                  */
                 Lazy<SdkResult> resultLazy = cached.GetOrAdd(
                     sdk.Name,
-                    key => new Lazy<SdkResult>(() => base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio)));
+                    key => new Lazy<SdkResult>(() =>
+                    {
+                        wasResultCached = false;
+
+                        return base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                    }));
 
                 // Get the lazy value which will block all waiting threads until the SDK is resolved at least once while subsequent calls get cached results.
                 result = resultLazy.Value;
@@ -73,7 +80,7 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                 loggingContext.LogWarning(null, new BuildEventFileInfo(sdkReferenceLocation), "ReferencingMultipleVersionsOfTheSameSdk", sdk.Name, result.Version, result.ElementLocation, sdk.Version);
             }
 
-            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStop(sdk.Name, solutionPath, projectPath, result.Success);
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStop(sdk.Name, solutionPath, projectPath, result.Success, wasResultCached);
 
             return result;
         }
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 1a449cf0c44..9db962d2a21 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -4,6 +4,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System;
@@ -28,7 +29,7 @@ internal sealed class OutOfProcNodeSdkResolverService : HostedSdkResolverService
         /// <summary>
         /// The cache of responses which is cleared between builds.
         /// </summary>
-        private readonly ConcurrentDictionary<string, SdkResult> _responseCache = new ConcurrentDictionary<string, SdkResult>(MSBuildNameIgnoreCaseComparer.Default);
+        private readonly ConcurrentDictionary<string, Lazy<SdkResult>> _responseCache = new ConcurrentDictionary<string, Lazy<SdkResult>>(MSBuildNameIgnoreCaseComparer.Default);
 
         /// <summary>
         /// An event to signal when a response has been received.
@@ -65,14 +66,21 @@ public override void PacketReceived(int node, INodePacket packet)
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
         public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
+            bool wasResultCached = true;
+
+            MSBuildEventSource.Log.OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStart(submissionId, sdk.Name, solutionPath, projectPath);
+
             // Get a cached response if possible, otherwise send the request
-            var sdkResult = _responseCache.GetOrAdd(
+            Lazy<SdkResult> sdkResultLazy = _responseCache.GetOrAdd(
                 sdk.Name,
-                key =>
+                key => new Lazy<SdkResult>(() =>
                 {
-                    var result = RequestSdkPathFromMainNode(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
-                    return result;
-                });
+                    wasResultCached = false;
+
+                    return RequestSdkPathFromMainNode(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                }));
+
+            SdkResult sdkResult = sdkResultLazy.Value;
 
             if (sdkResult.Version != null && !SdkResolverService.IsReferenceSameVersion(sdk, sdkResult.Version))
             {
@@ -80,6 +88,8 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                 loggingContext.LogWarning(null, new BuildEventFileInfo(sdkReferenceLocation), "ReferencingMultipleVersionsOfTheSameSdk", sdk.Name, sdkResult.Version, sdkResult.ElementLocation, sdk.Version);
             }
 
+            MSBuildEventSource.Log.OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(submissionId, sdk.Name, solutionPath, projectPath, _lastResponse.Success, wasResultCached);
+
             return sdkResult;
         }
 
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 2eb464830ff..60838dd3f20 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -17,6 +17,7 @@
 using Microsoft.Build.BackEnd.Components.Caching;
 using Microsoft.Build.BackEnd.SdkResolution;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
+using System.Diagnostics;
 
 #nullable disable
 
@@ -809,6 +810,32 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
         private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
         {
             _shutdownReason = buildComplete.PrepareForReuse ? NodeEngineShutdownReason.BuildCompleteReuse : NodeEngineShutdownReason.BuildComplete;
+            if (_shutdownReason == NodeEngineShutdownReason.BuildCompleteReuse)
+            {
+                ProcessPriorityClass priorityClass = Process.GetCurrentProcess().PriorityClass;
+                if (priorityClass != ProcessPriorityClass.Normal && priorityClass != ProcessPriorityClass.BelowNormal)
+                {
+                    // This isn't a priority class known by MSBuild. We should avoid connecting to this node.
+                    _shutdownReason = NodeEngineShutdownReason.BuildComplete;
+                }
+                else
+                {
+                    bool lowPriority = priorityClass == ProcessPriorityClass.BelowNormal;
+                    if (_nodeEndpoint.LowPriority != lowPriority)
+                    {
+                        if (!lowPriority || NativeMethodsShared.IsWindows)
+                        {
+                            Process.GetCurrentProcess().PriorityClass = lowPriority ? ProcessPriorityClass.Normal : ProcessPriorityClass.BelowNormal;
+                        }
+                        else
+                        {
+                            // On *nix, we can't adjust the priority up, so to avoid using this node at the wrong priority, we should not be reused.
+                            _shutdownReason = NodeEngineShutdownReason.BuildComplete;
+                        }
+                    }
+                }
+            }
+            
             _shutdownEvent.Set();
         }
     }
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 3de6bee0c32..5a2d0da07c9 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -407,13 +407,46 @@ protected internal virtual ProjectElementContainer DeepClone(ProjectRootElement
                 }
                 else
                 {
-                    clone.AppendChild(child.Clone(clone.ContainingProject));
+                    ProjectElement childClone = child.Clone(clone.ContainingProject);
+                    clone.AppendChild(childClone);
+                    if (childClone.XmlElement is not null)
+                    {
+                        AppendAttributesAndChildren(childClone.XmlElement, child.XmlElement);
+                    }
                 }
             }
 
             return clone;
         }
 
+        private void AppendAttributesAndChildren(XmlNode appendTo, XmlNode appendFrom)
+        {
+            appendTo.RemoveAll();
+            // Copy over the attributes from the template element.
+            if (appendFrom.Attributes is not null)
+            {
+                foreach (XmlAttribute attribute in appendFrom.Attributes)
+                {
+                    XmlAttribute attr = appendTo.OwnerDocument.CreateAttribute(attribute.LocalName, attribute.NamespaceURI);
+                    attr.Value = attribute.Value;
+                    appendTo.Attributes.Append(attr);
+                }
+            }
+
+            // If this element has pure text content, copy that over.
+            if (appendFrom.ChildNodes.Count == 1 && appendFrom.FirstChild.NodeType == XmlNodeType.Text)
+            {
+                appendTo.AppendChild(appendTo.OwnerDocument.CreateTextNode(appendFrom.FirstChild.Value));
+            }
+
+            foreach (XmlNode child in appendFrom.ChildNodes)
+            {
+                XmlNode childClone = appendTo.OwnerDocument.CreateNode(child.NodeType, child.Prefix, child.Name, child.NamespaceURI);
+                appendTo.AppendChild(childClone);
+                AppendAttributesAndChildren(childClone, child);
+            }
+        }
+
         internal static ProjectElementContainer DeepClone(ProjectElementContainer xml, ProjectRootElement factory, ProjectElementContainer parent)
         {
             return xml.DeepClone(factory, parent);
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 661397bad26..0adf9e61756 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -3477,7 +3477,15 @@ public string ExpandItemIncludeBestEffortLeaveEscaped(ProjectItemElement renamed
 
                 var itemFactory = new ProjectItemFactory(Owner, renamedItemElement);
 
-                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, renamedItemElement, itemFactory, renamedItemElement.Include, _data.Expander);
+                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(
+                    DirectoryPath,
+                    renamedItemElement,
+                    itemFactory,
+                    renamedItemElement.Include,
+                    _data.Expander,
+                    LoggingService,
+                    FullPath,
+                    s_buildEventContext);
 
                 if (items.Count != 1)
                 {
@@ -3537,7 +3545,15 @@ private List<ProjectItem> AddItemHelper(ProjectItemElement itemElement, string u
             {
                 var itemFactory = new ProjectItemFactory(Owner, itemElement);
 
-                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(DirectoryPath, itemElement, itemFactory, unevaluatedInclude, _data.Expander);
+                List<ProjectItem> items = Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.CreateItemsFromInclude(
+                    DirectoryPath,
+                    itemElement,
+                    itemFactory,
+                    unevaluatedInclude,
+                    _data.Expander,
+                    LoggingService,
+                    FullPath,
+                    s_buildEventContext);
 
                 foreach (ProjectItem item in items)
                 {
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index acdf7f6caf4..aed480e2f4e 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -921,7 +921,7 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
 
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.msbuildRuntimeType,
 #if RUNTIME_TYPE_NETCORE
-                        "Core",
+                        Traits.Instance.ForceEvaluateAsFullFramework ? "Full" : "Core",
 #elif MONO
                         NativeMethodsShared.IsMono ? "Mono" : "Full");
 #else
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 8a711257b2f..645181ce8f7 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -366,7 +366,7 @@ private static bool ScanForPropertyExpressionEnd(string expression, int index, o
                         // If it is not then the calling code will determine that
                         if (nestLevel == 0)
                         {
-                            if (whitespaceFound && !nonIdentifierCharacterFound && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
+                            if (whitespaceFound && !nonIdentifierCharacterFound)
                             {
                                 return false;
                             }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 19f4c800414..b3154221e9f 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -341,7 +341,7 @@ internal static void Evaluate(
         /// Helper that creates a list of ProjectItem's given an unevaluated Include and a ProjectRootElement.
         /// Used by both Evaluator.EvaluateItemElement and by Project.AddItem.
         /// </summary>
-        internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander<P, I> expander)
+        internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander<P, I> expander, ILoggingService loggingService, string buildEventFileInfoFullPath, BuildEventContext buildEventContext)
         {
             ErrorUtilities.VerifyThrowArgumentLength(unevaluatedIncludeEscaped, nameof(unevaluatedIncludeEscaped));
 
@@ -373,7 +373,16 @@ internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItem
                     else
                     {
                         // The expression is not of the form "@(X)". Treat as string
-                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);
+                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
+                            rootDirectory,
+                            includeSplitEscaped,
+                            excludeSpecsEscaped: null,
+                            forceEvaluate: false,
+                            fileMatcher: expander.EvaluationContext?.FileMatcher,
+                            loggingMechanism: loggingService,
+                            includeLocation: itemElement.IncludeLocation,
+                            buildEventFileInfoFullPath: buildEventFileInfoFullPath,
+                            buildEventContext: buildEventContext);
 
                         if (includeSplitFilesEscaped.Length > 0)
                         {
@@ -1139,7 +1148,8 @@ private void AddBuiltInProperties()
             }
 
 #if RUNTIME_TYPE_NETCORE
-            SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType, "Core");
+            SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType,
+                Traits.Instance.ForceEvaluateAsFullFramework ? "Full" : "Core");
 #elif MONO
             SetBuiltInProperty(ReservedPropertyNames.msbuildRuntimeType,
                                                         NativeMethodsShared.IsMono ? "Mono" : "Full");
@@ -1823,7 +1833,7 @@ static string EvaluateProperty(string value, IElementLocation location,
 
                 if (!sdkResult.Success)
                 {
-                    if (_loadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) && (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10) || !_loadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk)))
+                    if (_loadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) && !_loadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk))
                     {
                         ProjectImportedEventArgs eventArgs = new ProjectImportedEventArgs(
                             importElement.Location.Line,
@@ -2042,7 +2052,13 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                     }
 
                     // Expand the wildcards and provide an alphabetical order list of import statements.
-                    importFilesEscaped = EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true, fileMatcher: _evaluationContext.FileMatcher);
+                    importFilesEscaped = EngineFileUtilities.GetFileListEscaped(
+                        directoryOfImportingFile,
+                        importExpressionEscapedItem,
+                        forceEvaluate: true,
+                        fileMatcher: _evaluationContext.FileMatcher,
+                        loggingMechanism: _evaluationLoggingContext,
+                        importLocation: importLocationInProject);
                 }
                 catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
                 {
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 88d911a7b4a..1bacf84bbe7 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -2241,8 +2241,7 @@ internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S
                     {
                         if (Traits.Instance.UseLazyWildCardEvaluation)
                         {
-                            foreach (
-                                var resultantItem in
+                            foreach (var resultantItem in
                                 EngineFileUtilities.GetFileListEscaped(
                                     item.ProjectDirectory,
                                     item.EvaluatedIncludeEscaped,
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 0fe765844fa..ce0dc977426 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -111,15 +111,19 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                             {
                                 MSBuildEventSource.Log.ExpandGlobStart(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
                             }
+
                             using (_lazyEvaluator._evaluationProfiler.TrackGlob(_rootDirectory, glob, excludePatternsForGlobs))
                             {
                                 includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
                                     _rootDirectory,
                                     glob,
                                     excludePatternsForGlobs,
-                                    fileMatcher: FileMatcher
-                                );
+                                    fileMatcher: FileMatcher,
+                                    loggingMechanism: _lazyEvaluator._loggingContext,
+                                    includeLocation: _itemElement.IncludeLocation,
+                                    excludeLocation: _itemElement.ExcludeLocation);
                             }
+
                             if (MSBuildEventSource.Log.IsEnabled())
                             {
                                 MSBuildEventSource.Log.ExpandGlobStop(_rootDirectory, glob, string.Join(", ", excludePatternsForGlobs));
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index b3663b72015..c419203fb47 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -126,7 +126,7 @@ private void AddEdges(Dictionary<ConfigurationMetadata, ParsedProject> allParsed
 
         private void AddEdgesFromProjectReferenceItems(Dictionary<ConfigurationMetadata, ParsedProject> allParsedProjects, GraphEdges edges)
         {
-            var transitiveReferenceCache = new Dictionary<ProjectGraphNode, HashSet<ProjectGraphNode>>(allParsedProjects.Count);
+            Dictionary<ProjectGraphNode, HashSet<ProjectGraphNode>> transitiveReferenceCache = new(allParsedProjects.Count);
 
             foreach (var parsedProject in allParsedProjects)
             {
@@ -164,52 +164,30 @@ private void AddEdgesFromProjectReferenceItems(Dictionary<ConfigurationMetadata,
 
             HashSet<ProjectGraphNode> GetTransitiveProjectReferencesExcludingSelf(ParsedProject parsedProject)
             {
-                HashSet<ProjectGraphNode> references = new();
-                GetTransitiveProjectReferencesExcludingSelfHelper(parsedProject, references, null);
-                return references;
-            }
-
-            // transitiveReferences contains all of the references we've found so far from the initial GetTransitiveProjectReferencesExcludingSelf call.
-            // referencesFromHere is essentially "reset" at each level of the recursion.
-            // The first is important because if we find a cycle at some point, we need to know not to keep recursing. We wouldn't have added to transitiveReferenceCache yet, since we haven't finished
-            // finding all the transitive references yet.
-            // On the other hand, the second is important to help us fill that cache afterwards. The cache is from a particular node to all of its references, including transitive references
-            // but not including itself, which means we can't include parents as we would if we used transitiveReferences. You can see that for any particular call, it creates a new "toCache"
-            // HashSet that we fill with direct references and pass as referencesFromHere in recursive calls to fill it with transitive references. It is then used to populate the cache.
-            // Meanwhile, we avoid going into the recursive step at all if transitiveReferences already includes a particular node to avoid a StackOverflowException if there's a loop.
-            void GetTransitiveProjectReferencesExcludingSelfHelper(ParsedProject parsedProject, HashSet<ProjectGraphNode> traversedReferences, HashSet<ProjectGraphNode> incompleteReferencesOfDirectlyReferencingNode)
-            {
-                if (transitiveReferenceCache.TryGetValue(parsedProject.GraphNode, out HashSet<ProjectGraphNode> cachedTransitiveReferences))
+                if (transitiveReferenceCache.TryGetValue(parsedProject.GraphNode, out HashSet<ProjectGraphNode> transitiveReferences))
                 {
-                    traversedReferences.UnionWith(cachedTransitiveReferences);
+                    return transitiveReferences;
                 }
-                else
+
+                transitiveReferences = new();
+
+                // Add the results to the cache early, even though it'll be incomplete until the loop below finishes. This helps handle cycles by not allowing them to recurse infinitely.
+                // Note that this makes transitive references incomplete in the case of a cycle, but direct dependencies are always added so a cycle will still be detected and an exception will still be thrown.
+                transitiveReferenceCache[parsedProject.GraphNode] = transitiveReferences;
+
+                foreach (ProjectInterpretation.ReferenceInfo referenceInfo in parsedProject.ReferenceInfos)
                 {
-                    HashSet<ProjectGraphNode> referencesFromThisNode = new();
-                    foreach (ProjectInterpretation.ReferenceInfo referenceInfo in parsedProject.ReferenceInfos)
-                    {
-                        ParsedProject reference = allParsedProjects[referenceInfo.ReferenceConfiguration];
-                        if (traversedReferences.Add(reference.GraphNode))
-                        {
-                            GetTransitiveProjectReferencesExcludingSelfHelper(reference, traversedReferences, referencesFromThisNode);
-                        }
-                        else if (transitiveReferenceCache.TryGetValue(reference.GraphNode, out cachedTransitiveReferences))
-                        {
-                            referencesFromThisNode.UnionWith(cachedTransitiveReferences);
-                        }
-                        referencesFromThisNode.Add(reference.GraphNode);
-                    }
+                    ParsedProject reference = allParsedProjects[referenceInfo.ReferenceConfiguration];
+                    transitiveReferences.Add(reference.GraphNode);
 
-                    // We've returned from recursing through all transitive references
-                    // of this node, so add that set to the cache
-                    transitiveReferenceCache[parsedProject.GraphNode] = referencesFromThisNode;
-                    if (incompleteReferencesOfDirectlyReferencingNode is not null)
+                    // Perf note: avoiding UnionWith to avoid boxing the HashSet enumerator.
+                    foreach (ProjectGraphNode transitiveReference in GetTransitiveProjectReferencesExcludingSelf(reference))
                     {
-                        // Also add it to the set of transitive dependencies of
-                        // the referencing node (which are probably still incomplete)
-                        incompleteReferencesOfDirectlyReferencingNode.UnionWith(referencesFromThisNode);
+                        transitiveReferences.Add(transitiveReference);
                     }
                 }
+
+                return transitiveReferences;
             }
         }
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index c47eaaa70a8..74bfcc670aa 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -51,8 +51,6 @@
     <PackageReference Include="System.Reflection.Metadata" />
     <PackageReference Include="System.Security.Principal.Windows" />
     <PackageReference Include="System.Text.Encoding.CodePages" />
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
index 03d0963d09f..a4ec0aaf92d 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
@@ -528,6 +528,9 @@ Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFileLocation.get ->
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.get -> string
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.set -> void
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
 Microsoft.Build.Construction.ProjectUsingTaskElement.ParameterGroup.get -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
 Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.get -> string
 Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.set -> void
@@ -1031,6 +1034,8 @@ Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.get -> System.Collect
 Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.set -> void
 Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.get -> System.Collections.Generic.ISet<string>
 Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.set -> void
+Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
+Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
 Microsoft.Build.Execution.BuildRequestData
 Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) -> void
 Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
index 6e53fab9256..6a1467598ac 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -1,8 +1,3 @@
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
 Microsoft.Build.Execution.OutOfProcServerNode
 Microsoft.Build.Execution.OutOfProcServerNode.OutOfProcServerNode(System.Func<string, (int exitCode, string exitType)> buildFunction) -> void
 Microsoft.Build.Execution.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
index f34fab4b645..ecaad75bd4e 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -528,6 +528,9 @@ Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFileLocation.get ->
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.get -> string
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.set -> void
 Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
+Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
+Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
+Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
 Microsoft.Build.Construction.ProjectUsingTaskElement.ParameterGroup.get -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
 Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.get -> string
 Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.set -> void
@@ -961,6 +964,8 @@ Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.set -> void
 Microsoft.Build.Execution.BuildParameters.BuildParameters() -> void
 Microsoft.Build.Execution.BuildParameters.BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
 Microsoft.Build.Execution.BuildParameters.BuildProcessEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
+Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.get -> System.Threading.ThreadPriority
+Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.set -> void
 Microsoft.Build.Execution.BuildParameters.Clone() -> Microsoft.Build.Execution.BuildParameters
 Microsoft.Build.Execution.BuildParameters.Culture.get -> System.Globalization.CultureInfo
 Microsoft.Build.Execution.BuildParameters.Culture.set -> void
@@ -1029,6 +1034,8 @@ Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.get -> System.Collect
 Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.set -> void
 Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.get -> System.Collections.Generic.ISet<string>
 Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.set -> void
+Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
+Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
 Microsoft.Build.Execution.BuildRequestData
 Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) -> void
 Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index 487fd0465b1..6cdbdc2bcc1 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,10 +1,4 @@
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.get -> System.Threading.ThreadPriority
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
+
 Microsoft.Build.Execution.OutOfProcServerNode
 Microsoft.Build.Execution.OutOfProcServerNode.OutOfProcServerNode(System.Func<string, (int exitCode, string exitType)> buildFunction) -> void
 Microsoft.Build.Execution.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
\ No newline at end of file
diff --git a/src/Build/Resources/Constants.cs b/src/Build/Resources/Constants.cs
index 9ff21f01413..211f8cd00fa 100644
--- a/src/Build/Resources/Constants.cs
+++ b/src/Build/Resources/Constants.cs
@@ -301,12 +301,12 @@ private static void InitializeAvailableMethods()
                         availableStaticMethods.TryAdd("System.Environment::GetFolderPath", environmentType);
                         availableStaticMethods.TryAdd("System.Environment::GetLogicalDrives", environmentType);
 
-// All the following properties only have getters
+                        // All the following properties only have getters
                         availableStaticMethods.TryAdd("System.Environment::CommandLine", environmentType);
                         availableStaticMethods.TryAdd("System.Environment::Is64BitOperatingSystem", environmentType);
                         availableStaticMethods.TryAdd("System.Environment::Is64BitProcess", environmentType);
-
                         availableStaticMethods.TryAdd("System.Environment::MachineName", environmentType);
+                        availableStaticMethods.TryAdd("System.Environment::NewLine", environmentType);
                         availableStaticMethods.TryAdd("System.Environment::OSVersion", environmentType);
                         availableStaticMethods.TryAdd("System.Environment::ProcessorCount", environmentType);
                         availableStaticMethods.TryAdd("System.Environment::StackTrace", environmentType);
@@ -341,6 +341,7 @@ private static void InitializeAvailableMethods()
                         availableStaticMethods.TryAdd("System.Char", new Tuple<string, Type>(null, typeof(Char)));
                         availableStaticMethods.TryAdd("System.Convert", new Tuple<string, Type>(null, typeof(Convert)));
                         availableStaticMethods.TryAdd("System.DateTime", new Tuple<string, Type>(null, typeof(DateTime)));
+                        availableStaticMethods.TryAdd("System.DateTimeOffset", new Tuple<string, Type>(null, typeof(DateTimeOffset)));
                         availableStaticMethods.TryAdd("System.Decimal", new Tuple<string, Type>(null, typeof(Decimal)));
                         availableStaticMethods.TryAdd("System.Double", new Tuple<string, Type>(null, typeof(Double)));
                         availableStaticMethods.TryAdd("System.Enum", new Tuple<string, Type>(null, typeof(Enum)));
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index 2f53f2b6a71..9fc047c95c1 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -6,10 +6,11 @@
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Text.RegularExpressions;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -17,6 +18,8 @@ namespace Microsoft.Build.Internal
 {
     internal static class EngineFileUtilities
     {
+        private const string DriveEnumeratingWildcardMessageResourceName = "WildcardResultsInDriveEnumeration";
+
         // Regexes for wildcard filespecs that should not get expanded
         // By default all wildcards are expanded.
         private static List<Regex> s_lazyWildCardExpansionRegexes;
@@ -47,14 +50,27 @@ internal static void CaptureLazyWildcardRegexes()
         /// </summary>
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
+        /// <param name="loggingMechanism">Accepted loggers for drive enumeration: TargetLoggingContext, ILoggingService,
+        /// and EvaluationLoggingContext.</param>
+        /// <param name="excludeLocation">Location of Exclude element in file, used after drive enumeration detection.</param>
         /// <returns>Array of file paths, unescaped.</returns>
         internal static string[] GetFileListUnescaped
             (
             string directoryEscaped,
-            string filespecEscaped
+            string filespecEscaped,
+            object loggingMechanism = null,
+            IElementLocation excludeLocation = null
             )
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: false, forceEvaluateWildCards: false, excludeSpecsEscaped: null, fileMatcher: FileMatcher.Default);
+            return GetFileList(
+                directoryEscaped,
+                filespecEscaped,
+                returnEscaped: false,
+                forceEvaluateWildCards: false,
+                excludeSpecsEscaped: null,
+                fileMatcher: FileMatcher.Default,
+                loggingMechanism: loggingMechanism,
+                excludeLocation: excludeLocation);
         }
 
         /// <summary>
@@ -70,8 +86,18 @@ string filespecEscaped
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <param name="excludeSpecsEscaped">Filespecs to exclude, escaped.</param>
-        /// <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off</param>
-        /// <param name="fileMatcher"></param>
+        /// <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off.</param>
+        /// <param name="fileMatcher">Class that contains functions for matching filenames with patterns.</param>
+        /// <param name="loggingMechanism">Accepted loggers for drive enumeration: TargetLoggingContext, ILoggingService,
+        /// and EvaluationLoggingContext.</param>
+        /// <param name="includeLocation">Location of Include element in file, used after drive enumeration detection.</param>
+        /// <param name="excludeLocation">Location of Exclude element in file, used after drive enumeration detection.</param>
+        /// <param name="importLocation">Location of Import element in file, used after drive enumeration detection.</param>
+        /// <param name="buildEventContext">Context to log a warning, used after drive enumeration detection.</param>
+        /// <param name="buildEventFileInfoFullPath">Full path to project file to create BuildEventFileInfo,
+        /// used after drive enumeration detection.</param>
+        /// <param name="disableExcludeDriveEnumerationWarning">Flag used to detect when to properly log a warning
+        /// for the Exclude attribute after detecting a drive enumerating wildcard.</param>
         /// <returns>Array of file paths, escaped.</returns>
         internal static string[] GetFileListEscaped
             (
@@ -79,10 +105,30 @@ internal static string[] GetFileListEscaped
             string filespecEscaped,
             IEnumerable<string> excludeSpecsEscaped = null,
             bool forceEvaluate = false,
-            FileMatcher fileMatcher = null
+            FileMatcher fileMatcher = null,
+            object loggingMechanism = null,
+            IElementLocation includeLocation = null,
+            IElementLocation excludeLocation = null,
+            IElementLocation importLocation = null,
+            BuildEventContext buildEventContext = null,
+            string buildEventFileInfoFullPath = null,
+            bool disableExcludeDriveEnumerationWarning = false
             )
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: true, forceEvaluate, excludeSpecsEscaped, fileMatcher ?? FileMatcher.Default);
+            return GetFileList(
+                directoryEscaped,
+                filespecEscaped,
+                returnEscaped: true,
+                forceEvaluate,
+                excludeSpecsEscaped,
+                fileMatcher ?? FileMatcher.Default,
+                loggingMechanism: loggingMechanism,
+                includeLocation: includeLocation,
+                excludeLocation: excludeLocation,
+                importLocation: importLocation,
+                buildEventFileInfoFullPath: buildEventFileInfoFullPath,
+                buildEventContext: buildEventContext,
+                disableExcludeDriveEnumerationWarning: disableExcludeDriveEnumerationWarning);
         }
 
         internal static bool FilespecHasWildcards(string filespecEscaped)
@@ -112,9 +158,19 @@ internal static bool FilespecHasWildcards(string filespecEscaped)
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <param name="returnEscaped"><code>true</code> to return escaped specs.</param>
-        /// <param name="forceEvaluateWildCards">Whether to force file glob expansion when eager expansion is turned off</param>
+        /// <param name="forceEvaluateWildCards">Whether to force file glob expansion when eager expansion is turned off.</param>
         /// <param name="excludeSpecsEscaped">The exclude specification, escaped.</param>
-        /// <param name="fileMatcher"></param>
+        /// <param name="fileMatcher">Class that contains functions for matching filenames with patterns.</param>
+        /// <param name="loggingMechanism">Accepted loggers for drive enumeration: TargetLoggingContext, ILoggingService,
+        /// and EvaluationLoggingContext.</param>
+        /// <param name="includeLocation">Location of Include element in file, used after drive enumeration detection.</param>
+        /// <param name="excludeLocation">Location of Exclude element in file, used after drive enumeration detection.</param>
+        /// <param name="importLocation">Location of Import element in file, used after drive enumeration detection.</param>
+        /// <param name="buildEventContext">Context to log a warning, used after drive enumeration detection.</param>
+        /// <param name="buildEventFileInfoFullPath">Full path to project file to create BuildEventFileInfo,
+        /// used after drive enumeration detection.</param>
+        /// <param name="disableExcludeDriveEnumerationWarning">Flag used to detect when to properly log a warning
+        /// for the Exclude attribute after detecting a drive enumerating wildcard.</param>
         /// <returns>Array of file paths.</returns>
         private static string[] GetFileList
             (
@@ -123,13 +179,24 @@ private static string[] GetFileList
             bool returnEscaped,
             bool forceEvaluateWildCards,
             IEnumerable<string> excludeSpecsEscaped,
-            FileMatcher fileMatcher
+            FileMatcher fileMatcher,
+            object loggingMechanism = null,
+            IElementLocation includeLocation = null,
+            IElementLocation excludeLocation = null,
+            IElementLocation importLocation = null,
+            BuildEventContext buildEventContext = null,
+            string buildEventFileInfoFullPath = null,
+            bool disableExcludeDriveEnumerationWarning = false
             )
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
 
             string[] fileList;
 
+            // Used to properly detect and log drive enumerating wildcards when applicable.
+            FileMatcher.SearchAction action = FileMatcher.SearchAction.None;
+            string excludeFileSpec = string.Empty;
+
             if (!FilespecHasWildcards(filespecEscaped) ||
                 FilespecMatchesLazyWildcard(filespecEscaped, forceEvaluateWildCards))
             {
@@ -152,8 +219,98 @@ FileMatcher fileMatcher
                 // the list into a string array.  If the filespec started out
                 // as a relative path, we will get back a bunch of relative paths.
                 // If the filespec started out as an absolute path, we will get
-                // back a bunch of absolute paths.
-                fileList = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
+                // back a bunch of absolute paths. Also retrieves the search action
+                // and relevant Exclude filespec for drive enumerating wildcard detection.
+                (fileList, action, excludeFileSpec) = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
+
+                // Determines whether Exclude filespec or passed in file spec should be
+                // used in drive enumeration warning or exception.
+                bool excludeFileSpecIsEmpty = string.IsNullOrWhiteSpace(excludeFileSpec);
+                string fileSpec = excludeFileSpecIsEmpty ? filespecUnescaped : excludeFileSpec;
+
+                switch (action)
+                {
+                    case (FileMatcher.SearchAction.LogDriveEnumeratingWildcard):
+                        switch (loggingMechanism)
+                        {
+                            // Logging mechanism received from ItemGroupIntrinsicTask.
+                            case TargetLoggingContext targetLoggingContext:
+                                LogDriveEnumerationWarningWithTargetLoggingContext(
+                                    targetLoggingContext,
+                                    includeLocation,
+                                    excludeFileSpecIsEmpty,
+                                    disableExcludeDriveEnumerationWarning,                                
+                                    fileSpec);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator.
+                            case ILoggingService loggingService:
+                                LogDriveEnumerationWarningWithLoggingService(
+                                    loggingService,
+                                    buildEventContext,
+                                    buildEventFileInfoFullPath,
+                                    filespecUnescaped);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator and LazyItemEvaluator.IncludeOperation.
+                            case EvaluationLoggingContext evaluationLoggingContext:
+                                LogDriveEnumerationWarningWithEvaluationLoggingContext(
+                                    evaluationLoggingContext,
+                                    importLocation,
+                                    excludeFileSpecIsEmpty,
+                                    filespecUnescaped,
+                                    fileSpec);
+
+                                break;
+
+                            default:
+                                throw new InternalErrorException($"Logging type {loggingMechanism.GetType()} is not understood by {nameof(GetFileList)}.");
+                        }
+
+                        break;
+
+                    case (FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard):
+                        switch (loggingMechanism)
+                        {
+                            // Logging mechanism received from ItemGroupIntrinsicTask.
+                            case TargetLoggingContext targetLoggingContext:
+                                ThrowDriveEnumerationExceptionWithTargetLoggingContext(
+                                    includeLocation,
+                                    excludeLocation,
+                                    excludeFileSpecIsEmpty,
+                                    filespecUnescaped,
+                                    fileSpec);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator.
+                            case ILoggingService loggingService:
+                                ThrowDriveEnumerationExceptionWithLoggingService(includeLocation, filespecUnescaped);
+
+                                break;
+
+                            // Logging mechanism received from Evaluator and LazyItemEvaluator.IncludeOperation.
+                            case EvaluationLoggingContext evaluationLoggingContext:
+                                ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(
+                                    importLocation,
+                                    includeLocation,
+                                    excludeLocation,
+                                    filespecUnescaped,
+                                    fileSpec,
+                                    excludeFileSpecIsEmpty);
+
+                                break;
+
+                            default:
+                                throw new InternalErrorException($"Logging type {loggingMechanism.GetType()} is not understood by {nameof(GetFileList)}.");
+                        }
+
+                        break;
+
+                    default: break;
+                }
 
                 ErrorUtilities.VerifyThrow(fileList != null, "We must have a list of files here, even if it's empty.");
 
@@ -179,6 +336,152 @@ FileMatcher fileMatcher
             return fileList;
         }
 
+        private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLoggingContext targetLoggingContext, IElementLocation includeLocation, bool excludeFileSpecIsEmpty, bool disableExcludeDriveEnumerationWarning, string fileSpec)
+        {
+            // Both condition lines are necessary to skip for the first GetFileListEscaped call
+            // and reach for the GetFileListUnescaped call when the wildcarded Exclude attribute results
+            // in a drive enumeration. Since we only want to check for the Exclude
+            // attribute here, we want to ensure that includeLocation is null - otherwise,
+            // Include wildcard attributes for the GetFileListEscaped calls would falsely appear
+            // with the Exclude attribute in the logged warning.
+            if (((!excludeFileSpecIsEmpty) && (!disableExcludeDriveEnumerationWarning)) ||
+                (includeLocation == null))
+            {
+                targetLoggingContext.LogWarning(
+                        DriveEnumeratingWildcardMessageResourceName,
+                        fileSpec,
+                        XMakeAttributes.exclude,
+                        XMakeElements.itemGroup);
+            }
+
+            // Both conditions are necessary to reach for both GetFileListEscaped calls
+            // and skip for the GetFileListUnescaped call when the wildcarded Include attribute
+            // results in drive enumeration.
+            else if (excludeFileSpecIsEmpty && (includeLocation != null))
+            {
+                targetLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+        }
+
+        private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService loggingService, BuildEventContext buildEventContext, string buildEventFileInfoFullPath, string filespecUnescaped)
+        {
+            if (buildEventContext != null)
+            {
+                loggingService.LogWarning(
+                    buildEventContext,
+                    string.Empty,
+                    new BuildEventFileInfo(buildEventFileInfoFullPath),
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+        }
+
+        private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(EvaluationLoggingContext evaluationLoggingContext, IElementLocation importLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
+        {
+            if (importLocation != null)
+            {
+                evaluationLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.project,
+                    XMakeElements.import);
+            }
+            else if (excludeFileSpecIsEmpty)
+            {
+                evaluationLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+            else
+            {
+                evaluationLoggingContext.LogWarning(
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.exclude,
+                    XMakeElements.itemGroup);
+            }
+        }
+
+        private static void ThrowDriveEnumerationExceptionWithTargetLoggingContext(IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec)
+        {
+            // The first condition is necessary to reach for both GetFileListEscaped calls
+            // whenever the wildcarded Include attribute results in drive enumeration, and
+            // the second condition is necessary to skip for the GetFileListUnescaped call
+            // whenever the wildcarded Exclude attribute results in drive enumeration.
+            if (excludeFileSpecIsEmpty && (includeLocation != null))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    includeLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+
+            // The first condition is necessary to reach for both GetFileListEscaped calls
+            // whenever the wildcarded Exclude attribute results in drive enumeration, and
+            // the second condition is necessary to reach for the GetFileListUnescaped call
+            // (also when the wildcarded Exclude attribute results in drive enumeration).
+            else if ((!excludeFileSpecIsEmpty) || (includeLocation == null))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                        excludeLocation,
+                        DriveEnumeratingWildcardMessageResourceName,
+                        fileSpec,
+                        XMakeAttributes.exclude,
+                        XMakeElements.itemGroup);
+            }
+        }
+
+        private static void ThrowDriveEnumerationExceptionWithLoggingService(IElementLocation includeLocation, string filespecUnescaped)
+        {
+            ProjectErrorUtilities.ThrowInvalidProject(
+                includeLocation,
+                DriveEnumeratingWildcardMessageResourceName,
+                filespecUnescaped,
+                XMakeAttributes.include,
+                XMakeElements.itemGroup);
+        }
+
+        private static void ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(IElementLocation importLocation, IElementLocation includeLocation, IElementLocation excludeLocation, string filespecUnescaped, string fileSpec, bool excludeFileSpecIsEmpty)
+        {
+            if (importLocation != null)
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    importLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    filespecUnescaped,
+                    XMakeAttributes.project,
+                    XMakeElements.import);
+            }
+            else if (excludeFileSpecIsEmpty)
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    includeLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.include,
+                    XMakeElements.itemGroup);
+            }
+            else
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    excludeLocation,
+                    DriveEnumeratingWildcardMessageResourceName,
+                    fileSpec,
+                    XMakeAttributes.exclude,
+                    XMakeElements.itemGroup);
+            }
+        }
+
         private static bool FilespecMatchesLazyWildcard(string filespecEscaped, bool forceEvaluateWildCards)
         {
             return Traits.Instance.UseLazyWildCardEvaluation && !forceEvaluateWildCards && MatchesLazyWildcard(filespecEscaped);
diff --git a/src/Build/Xml/XmlReaderExtension.cs b/src/Build/Xml/XmlReaderExtension.cs
index 56b29744664..8cfd9b6497e 100644
--- a/src/Build/Xml/XmlReaderExtension.cs
+++ b/src/Build/Xml/XmlReaderExtension.cs
@@ -40,6 +40,12 @@ private XmlReaderExtension(string file, bool loadAsReadOnly)
                 _streamReader = new StreamReader(_stream, s_utf8NoBom, detectEncodingFromByteOrderMarks: true);
                 Encoding detectedEncoding;
 
+#if RUNTIME_TYPE_NETCORE
+                // Ensure that all Windows codepages are available.
+                // Safe to call multiple times per https://docs.microsoft.com/en-us/dotnet/api/system.text.encoding.registerprovider
+                Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
+#endif
+
                 // The XmlDocumentWithWithLocation class relies on the reader's BaseURI property to be set,
                 // thus we pass the document's file path to the appropriate xml reader constructor.
                 Reader = GetXmlReader(file, _streamReader, loadAsReadOnly, out detectedEncoding);
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index de2ef19eb31..ccffd9b5c05 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -27,7 +27,7 @@
     <!-- Set up BeforeCommon.targets -->
     <CustomBeforeMicrosoftCommonTargets>$(MSBuildThisFileDirectory)Directory.BeforeCommon.targets</CustomBeforeMicrosoftCommonTargets>
 
-    <Platforms>AnyCPU;x64</Platforms>
+    <Platforms>AnyCPU;x64;arm64</Platforms>
 
     <!-- Defaults for target frameworks and architecture -->
     <LibraryTargetFrameworks>$(FullFrameworkTFM);net6.0;netstandard2.0</LibraryTargetFrameworks>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 2dbbe6d8ace..de6fe3137d5 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -55,6 +55,10 @@
     <PackageReference Include="xunit.core" />
     <PackageReference Include="xunit.assert" />
 
+    <!-- Force updated reference to this package because xunit and shouldly
+         are netstandard1.6 and transitively bring in an old reference -->
+    <PackageReference Include="System.Security.Cryptography.X509Certificates" />
+
     <PackageReference Include="Microsoft.DotNet.XUnitExtensions" />
 
     <!-- Don't localize unit test projects -->
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index da03486b433..b66f3a66b80 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -23,11 +23,6 @@
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-  </ItemGroup>
-
   <ItemGroup>
     <Service Include="{82a7f48d-3b50-4b1e-b82e-3ada8210c358}" />
   </ItemGroup>
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 3ebe0b75ef8..ca49aaf226a 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -24,9 +24,10 @@ internal enum ChangeWaveConversionState
     /// For dev docs: https://github.com/dotnet/msbuild/blob/master/documentation/wiki/ChangeWaves-Dev.md
     internal class ChangeWaves
     {
-        internal static readonly Version Wave16_10 = new Version(16, 10);
         internal static readonly Version Wave17_0 = new Version(17, 0);
-        internal static readonly Version[] AllWaves = { Wave16_10, Wave17_0 };
+        internal static readonly Version Wave17_2 = new Version(17, 2);
+        internal static readonly Version Wave17_4 = new Version(17, 4);
+        internal static readonly Version[] AllWaves = { Wave17_0, Wave17_2, Wave17_4 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index da912a435c7..b4e335f7849 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -7,6 +7,9 @@ namespace Microsoft.Build.Eventing
     /// <summary>
     /// This captures information of how various key methods of building with MSBuild ran.
     /// </summary>
+    /// <remarks>
+    /// Changes to existing event method signatures will not be reflected unless you update the <see cref="EventAttribute.Version" /> property or assign a new event ID.
+    /// </remarks>
     [EventSource(Name = "Microsoft-Build")]
     internal sealed class MSBuildEventSource : EventSource
     {
@@ -501,10 +504,10 @@ public void CachedSdkResolverServiceResolveSdkStart(string sdkName, string solut
             WriteEvent(66, sdkName, solutionPath, projectPath);
         }
 
-        [Event(67, Keywords = Keywords.All)]
-        public void CachedSdkResolverServiceResolveSdkStop(string sdkName, string solutionPath, string projectPath, bool success)
+        [Event(67, Keywords = Keywords.All, Version = 2)]
+        public void CachedSdkResolverServiceResolveSdkStop(string sdkName, string solutionPath, string projectPath, bool success, bool wasResultCached)
         {
-            WriteEvent(67, sdkName, solutionPath, projectPath, success);
+            WriteEvent(67, sdkName, solutionPath, projectPath, success, wasResultCached);
         }
 
         /// <remarks>
@@ -584,6 +587,18 @@ public void ProjectCacheEndBuildStop(string pluginTypeName)
             WriteEvent(78, pluginTypeName);
         }
 
+        [Event(79, Keywords = Keywords.All)]
+        public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStart(int submissionId, string sdkName, string solutionPath, string projectPath)
+        {
+            WriteEvent(79, submissionId, sdkName, solutionPath, projectPath);
+        }
+
+        [Event(80, Keywords = Keywords.All)]
+        public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(int submissionId, string sdkName, string solutionPath, string projectPath, bool success, bool wasResultCached)
+        {
+            WriteEvent(80, submissionId, sdkName, solutionPath, projectPath, success, wasResultCached);
+        }
+
         #endregion
     }
 }
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index 9648dd397a8..e24a13ff151 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -16,8 +16,6 @@
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <PackageReference Include="System.Security.Permissions" />
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 44670733c34..9e68fc71c4e 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -624,9 +624,7 @@ internal static bool IsMaxPathLegacyWindows()
         }
     }
 
-    // CA1416 warns about code that can only run on Windows, but we verified we're running on Windows before this.
-    // This is the most reasonable way to resolve this part because other ways would require ifdef'ing on NET472.
-#pragma warning disable CA1416
+    [SupportedOSPlatform("windows")]
     private static bool IsLongPathsEnabledRegistry()
     {
         using (RegistryKey fileSystemKey = Registry.LocalMachine.OpenSubKey(WINDOWS_FILE_SYSTEM_REGISTRY_KEY))
@@ -635,7 +633,6 @@ private static bool IsLongPathsEnabledRegistry()
             return fileSystemKey != null && Convert.ToInt32(longPathsEnabledValue) == 1;
         }
     }
-#pragma warning restore CA1416
 
     /// <summary>
     /// Cached value for IsUnixLike (this method is called frequently during evaluation).
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 3c3d850d7c6..cf60eb140c9 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -43,6 +43,7 @@ public Traits()
         /// </summary>
         public readonly bool UseLazyWildCardEvaluation = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildSkipEagerWildCardEvaluationRegexes"));
         public readonly bool LogExpandedWildcards = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGEXPANDEDWILDCARDS"));
+        public readonly bool ThrowOnDriveEnumeratingWildcard = Environment.GetEnvironmentVariable("MSBUILDFAILONDRIVEENUMERATINGWILDCARD") == "1";
 
         /// <summary>
         /// Cache file existence for the entire process
@@ -68,6 +69,11 @@ public Traits()
         /// </summary>
         public static readonly string MSBuildNodeHandshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
 
+        /// <summary>
+        /// Override property "MSBuildRuntimeType" to "Full", ignoring the actual runtime type of MSBuild.
+        /// </summary>
+        public readonly bool ForceEvaluateAsFullFramework = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MsBuildForceEvaluateAsFullFramework"));
+
         /// <summary>
         /// Setting the associated environment variable to 1 restores the pre-15.8 single
         /// threaded (slower) copy behavior. Zero implies Int32.MaxValue, less than zero
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 5a77fd75bdd..5849fb8f3c8 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -868,7 +868,7 @@ public void GetCommandLine()
             var msbuildParameters = "\"" + _pathToArbitraryBogusFile + "\"" + (NativeMethodsShared.IsWindows ? " /v:diag" : " -v:diag");
             File.Exists(_pathToArbitraryBogusFile).ShouldBeTrue();
 
-            string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
+            string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit, _output);
             successfulExit.ShouldBeFalse();
 
             output.ShouldContain(RunnerUtilities.PathToCurrentlyRunningMsBuildExe + (NativeMethodsShared.IsWindows ? " /v:diag " : " -v:diag ") + _pathToArbitraryBogusFile, Case.Insensitive);
@@ -891,7 +891,7 @@ public void GetCommandLineQuotedExe()
                 pathToMSBuildExe = "\"" + pathToMSBuildExe + "\"";
             }
 
-            string output = RunnerUtilities.ExecMSBuild(pathToMSBuildExe, msbuildParameters, out var successfulExit);
+            string output = RunnerUtilities.ExecMSBuild(pathToMSBuildExe, msbuildParameters, out var successfulExit, outputHelper: _output);
             successfulExit.ShouldBeFalse();
 
             output.ShouldContain(RunnerUtilities.PathToCurrentlyRunningMsBuildExe + (NativeMethodsShared.IsWindows ? " /v:diag " : " -v:diag ") + _pathToArbitraryBogusFile, Case.Insensitive);
@@ -912,7 +912,7 @@ public void GetCommandLineQuotedExeOnPath()
 
                 var msbuildParameters = "\"" + _pathToArbitraryBogusFile + "\"" + (NativeMethodsShared.IsWindows ? " /v:diag" : " -v:diag");
 
-                output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
+                output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit, _output);
                 successfulExit.ShouldBeFalse();
             }
             finally
@@ -943,7 +943,7 @@ public void ResponseFileInProjectDirectoryFoundImplicitly()
             // Find the project in the current directory
             _env.SetCurrentDirectory(directory);
 
-            string output = RunnerUtilities.ExecMSBuild(string.Empty, out var successfulExit);
+            string output = RunnerUtilities.ExecMSBuild(string.Empty, out var successfulExit, _output);
             successfulExit.ShouldBeTrue();
 
             output.ShouldContain("[A=1]");
@@ -959,7 +959,7 @@ public void ResponseFileSwitchesAppearInCommandLine()
                 TransientTestFile projectFile = env.CreateFile(folder, "project.proj", "<Project><Target Name=\"T\"><Message Text=\"Text\"/></Target></Project>");
                 TransientTestFile rpsFile = env.CreateFile(folder, "myRsp.rsp", "-nr:false -m:2");
                 env.SetCurrentDirectory(folder.Path);
-                string output = RunnerUtilities.ExecMSBuild("project.proj -nologo", out bool success);
+                string output = RunnerUtilities.ExecMSBuild("project.proj -nologo", out bool success, _output);
                 success.ShouldBeFalse();
                 output.ShouldContain("-nr:false -m:2");
                 output.ShouldContain("-nowarn:MSB1001 @myRsp.rsp %NONEXISTENTENVIRONMENTVARIABLE%");
@@ -991,7 +991,7 @@ public void ResponseFileInProjectDirectoryExplicit()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit, _output);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=1]");
@@ -1026,7 +1026,7 @@ public void ResponseFileInProjectDirectoryRandomName()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit, _output);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=]");
@@ -1062,7 +1062,7 @@ public void ResponseFileInProjectDirectoryCommandLineWins()
 
                 var msbuildParameters = "\"" + projectPath + "\"" + " /p:A=2";
 
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit, _output);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=2]");
@@ -1175,7 +1175,7 @@ public void ResponseFileInProjectDirectoryItselfWithNoAutoResponseSwitch()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit, _output);
                 successfulExit.ShouldBeFalse();
 
                 output.ShouldContain("MSB1027"); // msbuild.rsp cannot have /noautoresponse in it
@@ -1210,7 +1210,7 @@ public void ResponseFileInProjectDirectoryButCommandLineNoAutoResponseSwitch()
 
                 var msbuildParameters = "\"" + projectPath + "\" /noautoresponse";
 
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit, _output);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=]");
@@ -1242,7 +1242,7 @@ public void ResponseFileInProjectDirectoryNullCase()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit, _output);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=]");
@@ -1270,7 +1270,7 @@ public void ResponseFileSupportsThisFileDirectory()
 
             var msbuildParameters = "\"" + projectPath + "\"";
 
-            string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
+            string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit, _output);
             successfulExit.ShouldBeTrue();
 
             output.ShouldContain($"[A={directory.Path}{Path.DirectorySeparatorChar}]");
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 337e3260d18..9ea8cc2fcf8 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -7,6 +7,9 @@
     <OutputType>Exe</OutputType>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
+    <!-- MSBuild.exe needs to be architecture specific, the rest of the .dlls can be AnyCPU. -->
+    <PlatformTarget Condition="'$(Platform)' == 'arm64'">arm64</PlatformTarget>
+
     <!-- MSBuild.csproj no longer uses apphost. This fixes an issue where certain tests would find
          MSBuild.exe AND MSBuild.dll when they should only find MSBuild.dll. -->
     <UseAppHost>false</UseAppHost>
@@ -30,7 +33,7 @@
     <!-- Temporary solution for
          https://github.com/dotnet/msbuild/issues/834 Long term
          two files should be generated from a single source. -->
-    <AppConfig Condition="'$(Platform)' == 'x64'">app.amd64.config</AppConfig>
+    <AppConfig Condition="'$(Platform)' == 'x64' or '$(Platform)' == 'arm64'">app.amd64.config</AppConfig>
     <!-- Disable binding redirect generation: we want to be deliberate
          about the redirects we expose plugins to, and we explicitly
          redirect ValueTuple _down_ to match VS. -->
@@ -226,8 +229,9 @@
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
+    <!-- Bump these to the latest version despite transitive references to older -->
+    <PackageReference Include="System.Private.Uri" />
+    <PackageReference Include="System.Runtime" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
@@ -337,6 +341,8 @@
 
   </Target>
 
+  <!-- Note: Keep the `AssemblyFile=` usage here instead of using `AssemblyName`. It acts as a regression test for folks who have been using it this way,
+             which has been in the official docs for some time. -->
   <UsingTask TaskName="ValidateMSBuildPackageDependencyVersions" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
     <Task>
       <Code Source="ValidateMSBuildPackageDependencyVersions.cs" Language="cs" />
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 342bd0b7d5d..132326e7230 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -6078,6 +6078,7 @@ elementFormDefault="qualified">
                     <xs:attribute name="RetryDelayMilliseconds" />
                     <xs:attribute name="SkipUnchangedFiles" />
                     <xs:attribute name="SourceUrl" use="required" />
+                    <xs:attribute name="Timeout" />
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index e344e3abb44..c69053daa0c 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1323,6 +1323,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <data name="MSBVersion" UESanitized="true" Visibility="Public">
     <value>MSBuild version = "{0}"</value>
   </data>
+  <data name="MSBuildDebugPath" Visibility="Public">
+    <value>MSBuild logs and debug information will be at "{0}"</value>
+  </data>
   <data name="SwitchErrorWithArguments" Visibility="Public">
     <value>{0}
     Full command line: '{1}'
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index c44516a6bf5..7ccdc9ab43e 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -1176,6 +1176,11 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
         <target state="translated">Verze MSBuild = {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">Protokoly MSBuild a informace o ladění budou dostupné v „{0}“</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Zadejte protokolovací nástroj.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index f79253774c2..e2c30e3ac4f 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1168,6 +1168,11 @@ Beispiel:
         <target state="translated">MSBuild-Version = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">MSBuild-Protokolle und Debuginformationen befinden sich auf "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Geben Sie eine Protokollierung an.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 5c04132fae5..0195e35549f 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1177,6 +1177,11 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
         <target state="translated">Versión de MSBuild: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">Los registros de MSBuild y la información de depuración estarán en "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Especifique un registrador.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 995bffa6350..3065aadd997 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1168,6 +1168,11 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
         <target state="translated">Version de MSBuild = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">Les journaux MSBuild et les informations de débogage seront au "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Spécifiez un journal.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index ab0acb73e22..9c59271398b 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -1190,6 +1190,11 @@ Esempio:
         <target state="translated">Versione di MSBuild = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">I log e le informazioni di debug di MSBuild sono contenuti in "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: specificare un logger.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 41444e220b0..9c2bee6bc61 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1168,6 +1168,11 @@ Copyright (C) Microsoft Corporation.All rights reserved.
         <target state="translated">MSBuild バージョン = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">MSBuild のログとデバッグ情報は、"{0}" にあります。</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Logger を指定してください。</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 38e5e44c459..3d3b611cc74 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1168,6 +1168,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <target state="translated">MSBuild 버전 = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">MSBuild 로그 및 디버그 정보는 "{0}"에 있습니다.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 로거를 지정하십시오.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index a0301139fb7..2c2f7464b68 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -1182,6 +1182,11 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
         <target state="translated">Wersja programu MSBuild = „{0}”</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">Dzienniki i informacje debugowania programu MSBuild będą znajdować się w lokalizacji „{0}”</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: określ rejestrator.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 65bb4fa8ef0..6dc052fc5bd 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1169,6 +1169,11 @@ isoladamente.
         <target state="translated">Versão do MSBuild = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">Os logs e as informações de depuração do MSBuild estarão no "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Especificar um agente de log.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index afe39bd1474..b39acf70142 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1167,6 +1167,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <target state="translated">Версия MSBuild = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">Журналы MSBuild и отладочные сведения будут доступны по адресу "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: укажите журнал.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index f0d21717f61..eb65858ec3a 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1172,6 +1172,11 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
         <target state="translated">MSBuild sürümü = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">MSBuild günlükleri ve hata ayıklama bilgileri "{0}" yolunda olacak</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: Günlükçü belirtin.</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 71e98f61fd7..a4fc1ecdd32 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1168,6 +1168,11 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <target state="translated">MSBuild 版本 = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">MSBuild 日志和调试信息将位于"{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 请指定记录器。</target>
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index cf86b834dd9..2dc040b10b9 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1168,6 +1168,11 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
         <target state="translated">MSBuild 版本 = "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="MSBuildDebugPath">
+        <source>MSBuild logs and debug information will be at "{0}"</source>
+        <target state="translated">MSBuild 記錄和偵錯工具資訊將位於 "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="MissingLoggerError">
         <source>MSBUILD : error MSB1007: Specify a logger.</source>
         <target state="translated">MSBUILD : error MSB1007: 指定記錄器。</target>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 19c98820950..83c62ace30a 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -34,6 +34,7 @@
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
+using Microsoft.Build.Shared.Debugging;
 
 #nullable disable
 
@@ -628,20 +629,6 @@ string[] commandLine
                         Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
                     }
 
-                    // Honor the low priority flag, we place our selves below normal priority and let sub processes inherit
-                    // that priority. Idle priority would prevent the build from proceeding as the user does normal actions.
-                    try
-                    {
-                        if (lowPriority && Process.GetCurrentProcess().PriorityClass != ProcessPriorityClass.Idle && !s_isServerNode)
-                        {
-                            Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.BelowNormal;
-                        }
-                    }
-                    // We avoid increasing priority because that causes failures on mac/linux, but there is no good way to
-                    // verify that a particular priority is lower than "BelowNormal." If the error appears, ignore it and
-                    // leave priority where it was.
-                    catch (Win32Exception) { }
-
                     DateTime t1 = DateTime.Now;
 
                     // If the primary file passed to MSBuild is a .binlog file, play it back into passed loggers
@@ -1337,7 +1324,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
 
         private static IEnumerable<BuildManager.DeferredBuildMessage> GetMessagesToLogInBuildLoggers(string commandLineString)
         {
-            return new[]
+            List<BuildManager.DeferredBuildMessage> messages = new()
             {
                 new BuildManager.DeferredBuildMessage(
                     ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
@@ -1363,8 +1350,20 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
                     ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                         "MSBVersion",
                         ProjectCollection.DisplayVersion),
-                    MessageImportance.Low)
+                    MessageImportance.Low),
             };
+
+            if (Traits.Instance.DebugEngine)
+            {
+                messages.Add(
+                    new BuildManager.DeferredBuildMessage(
+                        ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                        "MSBuildDebugPath",
+                        DebugUtils.DebugPath),
+                        MessageImportance.High));
+            }
+
+            return messages;
         }
 
         private static (BuildResultCode result, Exception exception) ExecuteBuild(BuildManager buildManager, BuildRequestData request)
@@ -2083,6 +2082,27 @@ string commandLine
                 DisplayCopyrightMessage();
             }
 
+
+            // Idle priority would prevent the build from proceeding as the user does normal actions.
+            // This switch is processed early to capture both the command line case (main node should
+            // also be low priority) and the Visual Studio case in which the main node starts and stays
+            // at normal priority (not through XMake.cs) but worker nodes still need to honor this switch.
+            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.LowPriority))
+            {
+                lowPriority = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority], defaultValue: true, resourceName: "InvalidLowPriorityValue");
+            }
+            try
+            {
+                if (lowPriority && Process.GetCurrentProcess().PriorityClass != ProcessPriorityClass.Idle)
+                {
+                    Process.GetCurrentProcess().PriorityClass = ProcessPriorityClass.BelowNormal;
+                }
+            }
+            // We avoid increasing priority because that causes failures on mac/linux, but there is no good way to
+            // verify that a particular priority is lower than "BelowNormal." If the error appears, ignore it and
+            // leave priority where it was.
+            catch (Win32Exception) { }
+
             // if help switch is set (regardless of switch errors), show the help message and ignore the other switches
             if (commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Help])
             {
@@ -2090,7 +2110,7 @@ string commandLine
             }
             else if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.NodeMode))
             {
-                StartLocalNode(commandLineSwitches);
+                StartLocalNode(commandLineSwitches, lowPriority);
             }
             else
             {
@@ -2228,11 +2248,6 @@ string commandLine
                         graphBuild = ProcessGraphBuildSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.GraphBuild]);
                     }
 
-                    if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.LowPriority))
-                    {
-                        lowPriority = ProcessBooleanSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority], defaultValue: true, resourceName: "InvalidLowPriorityValue");
-                    }
-
                     inputResultsCaches = ProcessInputResultsCaches(commandLineSwitches);
 
                     outputResultsCache = ProcessOutputResultsCache(commandLineSwitches);
@@ -2572,7 +2587,7 @@ internal static ProfilerLogger ProcessProfileEvaluationSwitch(string[] parameter
         /// Uses the input from thinNodeMode switch to start a local node server
         /// </summary>
         /// <param name="commandLineSwitches"></param>
-        private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
+        private static void StartLocalNode(CommandLineSwitches commandLineSwitches, bool lowpriority)
         {
             string[] input = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeMode];
             int nodeModeNumber = 0;
@@ -2600,22 +2615,22 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches)
             {
                 Exception nodeException = null;
                 NodeEngineShutdownReason shutdownReason = NodeEngineShutdownReason.Error;
+
                 // normal OOP node case
                 if (nodeModeNumber == 1)
                 {
-                    OutOfProcNode node = new OutOfProcNode();
-
                     // If FEATURE_NODE_REUSE is OFF, just validates that the switch is OK, and always returns False
                     bool nodeReuse = ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]);
-                    string[] lowPriorityInput = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.LowPriority];
-                    bool lowpriority = lowPriorityInput.Length > 0 && lowPriorityInput[0].Equals("true");
-
+                    OutOfProcNode node = new OutOfProcNode();
                     shutdownReason = node.Run(nodeReuse, lowpriority, out nodeException);
 
                     FileUtilities.ClearCacheDirectory();
                 }
                 else if (nodeModeNumber == 2)
                 {
+                    // TaskHost nodes don't need to worry about node reuse or low priority. Node reuse is always off, and TaskHosts
+                    // receive a connection immediately after being launched and shut down as soon as their work is over, so
+                    // whatever our priority is is correct.
                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();
                     shutdownReason = node.Run(out nodeException);
                 }
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 517c74df63f..808d572d30a 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -26,10 +26,6 @@
           <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="15.1.0.0" />
           <codeBase version="15.1.0.0" href="..\Microsoft.Build.dll"/>
         </dependentAssembly>
-        <dependentAssembly>
-          <assemblyIdentity name="Microsoft.Build.Conversion.Core" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="15.1.0.0" />
-        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.Tasks.Core" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
           <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="15.1.0.0" />
@@ -51,60 +47,79 @@
           <codeBase version="15.1.0.0" href="..\Microsoft.Build.Conversion.Core.dll"/>
         </dependentAssembly>
 
+        <dependentAssembly>
+          <assemblyIdentity name="Microsoft.IO.Redist" culture="neutral" publicKeyToken="cc7b13ffcd2ddd51" />
+          <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\Microsoft.IO.Redist.dll"/>
+        </dependentAssembly>
+        
         <!-- Redirects for assemblies redistributed by MSBuild (in the .vsix). -->
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\Microsoft.Bcl.AsyncInterfaces.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+          <codeBase version="1.0.0.0" href="..\Microsoft.NET.StringTools.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.NET.StringTools.net35" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-1.0.0.0" newVersion="1.0.0.0" />
+          <codeBase version="1.0.0.0" href="..\Microsoft.NET.StringTools.net35.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.3.0" />
+          <codeBase version="4.0.3.0" href="..\System.Buffers.dll"/>
         </dependentAssembly>
 
         <!-- Pull plugins that reference SCI up to our version in case they depended on our copy of the older version -->
         <dependentAssembly>
           <assemblyIdentity name="System.Collections.Immutable" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-5.0.0.0" newVersion="5.0.0.0" />
+          <codeBase version="5.0.0.0" href="..\System.Collections.Immutable.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-4.0.1.1" newVersion="4.0.1.1" />
+          <codeBase version="4.0.1.1" href="..\System.Memory.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
+          <codeBase version="4.1.4.0" href="..\System.Numerics.Vectors.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-4.0.0.0" newVersion="4.0.0.0" />
+          <codeBase version="4.0.0.0" href="..\System.Resources.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Runtime.CompilerServices.Unsafe.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Encodings.Web" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Text.Encodings.Web.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Text.Json.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Dataflow" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Threading.Tasks.Dataflow.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Threading.Tasks.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-4.2.0.1" newVersion="4.2.0.1" />
+          <codeBase version="4.2.0.1" href="..\System.Threading.Tasks.Extensions.dll"/>
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.ValueTuple" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
@@ -112,6 +127,7 @@
                to 4.0.0.0 in the GAC, so this just removes the need to redistribute a file
                and makes that resolution faster. -->
           <bindingRedirect oldVersion="0.0.0.0-4.0.3.0" newVersion="4.0.0.0" />
+          <codeBase version="4.0.3.0" href="..\System.ValueTuple.dll"/>
         </dependentAssembly>
 
         <!-- Redirects for components dropped by Visual Studio -->
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index f22bacc449e..915c11c69f0 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -21,10 +21,6 @@
           <assemblyIdentity name="Microsoft.Build" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
           <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="15.1.0.0" />
         </dependentAssembly>
-        <dependentAssembly>
-          <assemblyIdentity name="Microsoft.Build.Conversion.Core" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="15.1.0.0" />
-        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.Tasks.Core" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
           <bindingRedirect oldVersion="0.0.0.0-99.9.9.9" newVersion="15.1.0.0" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index e7dba840e1a..beca5404f56 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -215,8 +215,4 @@
     <PackageReference Include="PdbGit" /> -->
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-  </ItemGroup>
 </Project>
diff --git a/src/MSBuildTaskHost/OutOfProcTaskHost.cs b/src/MSBuildTaskHost/OutOfProcTaskHost.cs
index c7afd19c8db..4f4b2ab02da 100644
--- a/src/MSBuildTaskHost/OutOfProcTaskHost.cs
+++ b/src/MSBuildTaskHost/OutOfProcTaskHost.cs
@@ -68,7 +68,7 @@ internal enum ExitType
         [MTAThread]
         public static int Main()
         {
-            int exitCode = (Execute() == ExitType.Success ? 0 : 1);
+            int exitCode = Execute() == ExitType.Success ? 0 : 1;
             return exitCode;
         }
 
diff --git a/src/Package/GetBinPaths.targets b/src/Package/GetBinPaths.targets
index f3b734eceb9..b6254cc0d1c 100644
--- a/src/Package/GetBinPaths.targets
+++ b/src/Package/GetBinPaths.targets
@@ -37,6 +37,10 @@
                          OutputItemType="MSBuildTaskHostX64ResolvedProjectReferencePath"
                          GlobalPropertiesToRemove="TargetFramework" />
 
+    <Arm64ProjectReference Include="$(MSBuildThisFileDirectory)\..\MSBuild\MSBuild.csproj"
+                         SetPlatform="Platform=arm64"
+                         SetTargetFramework="TargetFramework=$(FullFrameworkTFM)"
+                         OutputItemType="MSBuildArm64ResolvedProjectReferencePath" />
   </ItemGroup>
 
   <Target Name="SetBinPaths" DependsOnTargets="ResolveProjectReferences">
@@ -48,13 +52,24 @@
 
       <Output TaskParameter="TargetOutputs" ItemName="%(X64ProjectReference.OutputItemType)" />
     </MSBuild>
+
+    <MSBuild
+        Projects="@(Arm64ProjectReference)"
+        BuildInParallel="$(BuildInParallel)"
+        Properties="Configuration=$(Configuration); %(Arm64ProjectReference.SetPlatform); %(Arm64ProjectReference.SetTargetFramework)"
+        RemoveProperties="%(Arm64ProjectReference.GlobalPropertiesToRemove)">
+
+      <Output TaskParameter="TargetOutputs" ItemName="%(Arm64ProjectReference.OutputItemType)" />
+    </MSBuild>
     
     <PropertyGroup>
       <X86BinPath>@(MSBuildResolvedProjectReferencePath->'%(RootDir)%(Directory)')</X86BinPath>
       <X64BinPath>@(MSBuildX64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</X64BinPath>
+      <Arm64BinPath>@(MSBuildArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</Arm64BinPath>
       <FrameworkBinPath>@(FrameworkResolvedProjectReferencePath->'%(RootDir)%(Directory)')</FrameworkBinPath>
       <MSBuildTaskHostBinPath>@(MSBuildTaskHostResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildTaskHostBinPath>
       <MSBuildTaskHostX64BinPath>@(MSBuildTaskHostX64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildTaskHostX64BinPath>
+      <MSBuildTaskHostArm64BinPath>@(MSBuildTaskHostArm64ResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildTaskHostArm64BinPath>
       <MSBuildConversionBinPath>@(MSBuildConversionResolvedProjectReferencePath->'%(RootDir)%(Directory)')</MSBuildConversionBinPath>
     </PropertyGroup>
   </Target>
diff --git a/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj b/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj
index ed375f4b0e7..d28478dfa1b 100644
--- a/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj
+++ b/src/Package/MSBuild.VSSetup/MSBuild.VSSetup.csproj
@@ -34,9 +34,11 @@
       <SwrProperty Include="Version=$(VsixVersion)" />
       <SwrProperty Include="X86BinPath=$(X86BinPath)" />
       <SwrProperty Include="X64BinPath=$(X64BinPath)" />
+      <SwrProperty Include="Arm64BinPath=$(Arm64BinPath)" />
       <SwrProperty Include="FrameworkBinPath=$(FrameworkBinPath)" />
       <SwrProperty Include="TaskHostBinPath=$(MSBuildTaskHostBinPath)" />
       <SwrProperty Include="TaskHostX64BinPath=$(MSBuildTaskHostX64BinPath)" />
+      <SwrProperty Include="TaskHostArm64BinPath=$(MSBuildTaskHostArm64BinPath)" />
       <SwrProperty Include="MSBuildConversionBinPath=$(MSBuildConversionBinPath)" />
     </ItemGroup>
   </Target>
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 8de7164fde5..35e47db3ab7 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -18,6 +18,7 @@ vs.relatedProcessFiles
   vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\amd64\Microsoft.Build.Framework.dll"
   vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\amd64\Microsoft.Build.Tasks.Core.dll"
   vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\amd64\Microsoft.Build.Utilities.Core.dll"
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\arm64\Microsoft.Build.Tasks.Core.dll"
 
 folder InstallDir:\MSBuild\Current
   file source=$(X86BinPath)Microsoft.Common.props
@@ -308,6 +309,70 @@ folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hant
   file source=$(X64BinPath)zh-Hant\MSBuild.resources.dll vs.file.ngenArchitecture=all
   file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
 
+folder InstallDir:\MSBuild\Current\Bin\arm64
+  file source=$(Arm64BinPath)MSBuild.exe vs.file.ngenArchitecture=x64
+  file source=$(Arm64BinPath)MSBuild.exe.config
+
+  file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.Common.CurrentVersion.targets
+  file source=$(X86BinPath)Microsoft.Common.CrossTargeting.targets
+  file source=$(X86BinPath)Microsoft.Common.overridetasks
+  file source=$(X86BinPath)Microsoft.Common.targets
+  file source=$(X86BinPath)Microsoft.Common.tasks
+  file source=$(X86BinPath)Microsoft.Managed.targets
+  file source=$(X86BinPath)Microsoft.Managed.Before.targets
+  file source=$(X86BinPath)Microsoft.Managed.After.targets
+  file source=$(X86BinPath)Microsoft.CSharp.CurrentVersion.targets
+  file source=$(X86BinPath)Microsoft.CSharp.CrossTargeting.targets
+  file source=$(X86BinPath)Microsoft.CSharp.targets
+  file source=$(X86BinPath)Microsoft.Net.props
+  file source=$(X86BinPath)Microsoft.NetFramework.CurrentVersion.props
+  file source=$(X86BinPath)Microsoft.NetFramework.CurrentVersion.targets
+  file source=$(X86BinPath)Microsoft.NetFramework.props
+  file source=$(X86BinPath)Microsoft.NetFramework.targets
+  file source=$(X86BinPath)Microsoft.VisualBasic.CurrentVersion.targets
+  file source=$(X86BinPath)Microsoft.VisualBasic.CrossTargeting.targets
+  file source=$(X86BinPath)Microsoft.VisualBasic.targets
+  file source=$(X86BinPath)MSBuild.rsp
+  file source=$(X86BinPath)Workflow.targets
+  file source=$(X86BinPath)Workflow.VisualBasic.targets
+  file source=$(X86BinPath)Microsoft.Xaml.targets
+  file source=$(X86BinPath)Microsoft.Data.Entity.targets
+  file source=$(X86BinPath)Microsoft.ServiceModel.targets
+  file source=$(X86BinPath)Microsoft.WinFx.targets
+  file source=$(X86BinPath)Microsoft.WorkflowBuildExtensions.targets
+
+folder InstallDir:\MSBuild\Current\Bin\arm64\MSBuild
+  file source=$(X86BinPath)\MSBuild\Microsoft.Build.Core.xsd
+  file source=$(X86BinPath)\MSBuild\Microsoft.Build.CommonTypes.xsd
+
+folder InstallDir:\MSBuild\Current\Bin\arm64\cs
+  file source=$(Arm64BinPath)cs\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\de
+  file source=$(Arm64BinPath)de\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\es
+  file source=$(Arm64BinPath)es\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\fr
+  file source=$(Arm64BinPath)fr\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\it
+  file source=$(Arm64BinPath)it\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\ja
+  file source=$(Arm64BinPath)ja\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\ko
+  file source=$(Arm64BinPath)ko\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\pl
+  file source=$(Arm64BinPath)pl\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\pt-BR
+  file source=$(Arm64BinPath)pt-BR\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\ru
+  file source=$(Arm64BinPath)ru\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\tr
+  file source=$(Arm64BinPath)tr\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hans
+  file source=$(Arm64BinPath)zh-Hans\MSBuild.resources.dll vs.file.ngenArchitecture=all
+folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hant
+  file source=$(Arm64BinPath)zh-Hant\MSBuild.resources.dll vs.file.ngenArchitecture=all
+
 folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
   file source=$(SourceDir)Package\MSBuild.VSSetup\MSBuild.clientenabledpkg
   file source=$(SourceDir)Framework\Microsoft.Build.Framework.pkgdef
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index d0ad67ed140..0bf416196af 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -8,7 +8,9 @@
 using System.Collections.Generic;
 using System.Text.RegularExpressions;
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
+using System.Reflection;
 
 #nullable disable
 
@@ -319,9 +321,10 @@ private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePat
 
         private static string GetVsRootFromMSBuildAssembly(string msBuildAssembly)
         {
+            string directory = Path.GetDirectoryName(msBuildAssembly);
             return FileUtilities.GetFolderAbove(msBuildAssembly,
-                Path.GetDirectoryName(msBuildAssembly)
-                  .EndsWith(@"\amd64", StringComparison.OrdinalIgnoreCase)
+                directory.EndsWith(@"\amd64", StringComparison.OrdinalIgnoreCase) ||
+                directory.EndsWith(@"\arm64", StringComparison.OrdinalIgnoreCase)
                     ? 5
                     : 4);
         }
@@ -333,7 +336,8 @@ private static string GetMSBuildExeFromVsRoot(string visualStudioRoot)
                 "MSBuild",
                 CurrentToolsVersion,
                 "Bin",
-                IntPtr.Size == 8 ? "amd64" : string.Empty,
+                NativeMethodsShared.ProcessorArchitecture == Framework.NativeMethods.ProcessorArchitectures.X64 ? "amd64" :
+                NativeMethodsShared.ProcessorArchitecture == Framework.NativeMethods.ProcessorArchitectures.ARM64 ? "arm64" : string.Empty,
                 "MSBuild.exe");
         }
 
@@ -528,34 +532,38 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
             if (mode == BuildEnvironmentMode.None || currentMSBuildExeFile == null || currentToolsDirectory == null)
                 return;
 
-            // Check to see if our current folder is 'amd64'
-            bool runningInAmd64 = string.Equals(currentToolsDirectory.Name, "amd64", StringComparison.OrdinalIgnoreCase);
-
             var msBuildExeName = currentMSBuildExeFile.Name;
-            var folderAbove = currentToolsDirectory.Parent?.FullName;
 
-            if (folderAbove != null)
+            if (mode == BuildEnvironmentMode.VisualStudio)
+            {
+                // In Visual Studio, the entry-point MSBuild.exe is often from an arch-specific subfolder
+                MSBuildToolsDirectoryRoot = NativeMethodsShared.ProcessorArchitecture switch
+                {
+                    NativeMethodsShared.ProcessorArchitectures.X86 => CurrentMSBuildToolsDirectory,
+                    NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorArchitectures.ARM64
+                        => currentToolsDirectory.Parent?.FullName,
+                    _ => throw new InternalErrorException("Unknown processor architecture " + NativeMethodsShared.ProcessorArchitecture),
+                };
+            }
+            else
+            {
+                // In the .NET SDK, there's one copy of MSBuild.dll and it's in the root folder.
+                MSBuildToolsDirectoryRoot = CurrentMSBuildToolsDirectory;
+            }
+
+            if (mode == BuildEnvironmentMode.VisualStudio && MSBuildToolsDirectoryRoot != null)
             {
                 // Calculate potential paths to other architecture MSBuild.exe
-                var potentialAmd64FromX86 = FileUtilities.CombinePaths(CurrentMSBuildToolsDirectory, "amd64", msBuildExeName);
-                var potentialX86FromAmd64 = Path.Combine(folderAbove, msBuildExeName);
+                var potentialAmd64FromX86 = FileUtilities.CombinePaths(MSBuildToolsDirectoryRoot, "amd64", msBuildExeName);
+                var potentialARM64FromX86 = FileUtilities.CombinePaths(MSBuildToolsDirectoryRoot, "arm64", msBuildExeName);
 
                 // Check for existence of an MSBuild file. Note this is not necessary in a VS installation where we always want to
                 // assume the correct layout.
                 var existsCheck = mode == BuildEnvironmentMode.VisualStudio ? new Func<string, bool>(_ => true) : File.Exists;
 
-                // Running in amd64 folder and the X86 path is valid
-                if (runningInAmd64 && existsCheck(potentialX86FromAmd64))
-                {
-                    MSBuildToolsDirectory32 = folderAbove;
-                    MSBuildToolsDirectory64 = CurrentMSBuildToolsDirectory;
-                }
-                // Not running in amd64 folder and the amd64 path is valid
-                else if (!runningInAmd64 && existsCheck(potentialAmd64FromX86))
-                {
-                    MSBuildToolsDirectory32 = CurrentMSBuildToolsDirectory;
-                    MSBuildToolsDirectory64 = Path.Combine(CurrentMSBuildToolsDirectory, "amd64");
-                }
+                MSBuildToolsDirectory32 = MSBuildToolsDirectoryRoot;
+                MSBuildToolsDirectory64 = Path.Combine(MSBuildToolsDirectoryRoot, "amd64");
+                MSBuildToolsDirectoryArm64 = File.Exists(potentialARM64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "arm64") : null;
             }
 
             MSBuildExtensionsPath = mode == BuildEnvironmentMode.VisualStudio
@@ -575,6 +583,11 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
         /// </summary>
         internal bool RunningInVisualStudio { get; }
 
+        /// <summary>
+        /// Path to the root of the MSBuild folder (in VS scenarios, <c>MSBuild\Current\bin</c>).
+        /// </summary>
+        internal string MSBuildToolsDirectoryRoot { get; }
+
         /// <summary>
         /// Path to the MSBuild 32-bit tools directory.
         /// </summary>
@@ -585,6 +598,12 @@ public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath,
         /// </summary>
         internal string MSBuildToolsDirectory64 { get; }
 
+        /// <summary>
+        /// Path to the ARM64 tools directory.
+        /// <see langword="null" /> if ARM64 tools are not installed.
+        /// </summary>
+        internal string MSBuildToolsDirectoryArm64 { get; }
+
         /// <summary>
         /// Path to the Sdks folder for this MSBuild instance.
         /// </summary>
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 62a65273ad5..7e86ff4ee03 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -70,6 +70,11 @@ internal enum HandshakeOptions
         /// Using the .NET Core/.NET 5.0+ runtime
         /// </summary>
         NET = 64,
+
+        /// <summary>
+        /// ARM64 process
+        /// </summary>
+        Arm64 = 128,
     }
 
     internal interface IHandshake
@@ -101,13 +106,17 @@ internal interface IHandshake
 
         internal Handshake(HandshakeOptions nodeType)
         {
+            const int handshakeVersion = (int)CommunicationsUtilities.handshakeVersion;
+
             // We currently use 7 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
             // This indicates in the first byte that we are a modern build.
-            options = (int)nodeType | (((int)CommunicationsUtilities.handshakeVersion) << 24);
+            options = (int)nodeType | (handshakeVersion << 24);
+            CommunicationsUtilities.Trace("Building handshake for node type {0}, (version {1}): options {2}.", nodeType, handshakeVersion, options);
+
             string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
             CommunicationsUtilities.Trace("Handshake salt is " + handshakeSalt);
-            string toolsDirectory = (nodeType & HandshakeOptions.X64) == HandshakeOptions.X64 ? BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64 : BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
-            CommunicationsUtilities.Trace("Tools directory is " + toolsDirectory);
+            string toolsDirectory = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;
+            CommunicationsUtilities.Trace("Tools directory root is " + toolsDirectory);
             salt = CommunicationsUtilities.GetHashCode(handshakeSalt + toolsDirectory);
             Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion);
             fileVersionMajor = fileVersion.Major;
@@ -580,22 +589,22 @@ internal static async Task<int> ReadAsync(Stream stream, byte[] buffer, int byte
         /// <summary>
         /// Given the appropriate information, return the equivalent HandshakeOptions.
         /// </summary>
-        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit = false, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
+        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, string architectureFlagToSet = null, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
         {
             HandshakeOptions context = taskHost ? HandshakeOptions.TaskHost : HandshakeOptions.None;
 
             int clrVersion = 0;
 
-            // We don't know about the TaskHost. Figure it out.
+            // We don't know about the TaskHost.
             if (taskHost)
             {
-                // Take the current TaskHost context
+                // No parameters given, default to current
                 if (taskHostParameters == null)
                 {
                     clrVersion = typeof(bool).GetTypeInfo().Assembly.GetName().Version.Major;
-                    is64Bit = XMakeAttributes.GetCurrentMSBuildArchitecture().Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
+                    architectureFlagToSet = XMakeAttributes.GetCurrentMSBuildArchitecture();
                 }
-                else
+                else // Figure out flags based on parameters given
                 {
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), "Should always have an explicit runtime when we call this method.");
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), "Should always have an explicit architecture when we call this method.");
@@ -603,7 +612,7 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                     if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))
                     {
                         clrVersion = 2;
-                    } 
+                    }
                     else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))
                     {
                         clrVersion = 4;
@@ -617,13 +626,20 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                         ErrorUtilities.ThrowInternalErrorUnreachable();
                     }
 
-                    is64Bit = architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
+                    architectureFlagToSet = architecture;
                 }
             }
 
-            if (is64Bit)
+            if (!string.IsNullOrEmpty(architectureFlagToSet))
             {
-                context |= HandshakeOptions.X64;
+                if (architectureFlagToSet.Equals(XMakeAttributes.MSBuildArchitectureValues.x64, StringComparison.OrdinalIgnoreCase))
+                {
+                    context |= HandshakeOptions.X64;
+                }
+                else if (architectureFlagToSet.Equals(XMakeAttributes.MSBuildArchitectureValues.arm64, StringComparison.OrdinalIgnoreCase))
+                {
+                    context |= HandshakeOptions.Arm64;
+                }
             }
 
             switch (clrVersion)
diff --git a/src/Shared/Debugging/DebugUtils.cs b/src/Shared/Debugging/DebugUtils.cs
index 0d4975586ab..74a3a7b9e79 100644
--- a/src/Shared/Debugging/DebugUtils.cs
+++ b/src/Shared/Debugging/DebugUtils.cs
@@ -5,6 +5,7 @@
 using System;
 using System.Diagnostics;
 using System.IO;
+using System.Security;
 using System.Text.RegularExpressions;
 
 #nullable disable
@@ -22,12 +23,23 @@ private enum NodeMode
 
         static DebugUtils()
         {
-            string environmentDebugPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
-            var debugDirectory = environmentDebugPath;
+            string environmentDebugPath = FileUtilities.TrimAndStripAnyQuotes(Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH"));
+            string debugDirectory = environmentDebugPath;
 
             if (Traits.Instance.DebugEngine)
             {
-                debugDirectory ??= Path.Combine(Directory.GetCurrentDirectory(), "MSBuild_Logs");
+                if (!string.IsNullOrWhiteSpace(debugDirectory) && FileUtilities.CanWriteToDirectory(debugDirectory))
+                {
+                    // Debug directory is writable; no need for fallbacks
+                }
+                else if (FileUtilities.CanWriteToDirectory(Directory.GetCurrentDirectory()))
+                {
+                    debugDirectory = Path.Combine(Directory.GetCurrentDirectory(), "MSBuild_Logs");
+                }
+                else
+                {
+                    debugDirectory = Path.Combine(Path.GetTempPath(), "MSBuild_Logs");
+                }
 
                 // Out of proc nodes do not know the startup directory so set the environment variable for them.
                 if (string.IsNullOrWhiteSpace(environmentDebugPath))
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 7af174db82b..1fb4dd23850 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -114,49 +114,28 @@ internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemE
                 ? getFileSystemEntries
                 : (type, path, pattern, directory, stripProjectDirectory) =>
                 {
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
+                    // Always hit the filesystem with "*" pattern, cache the results, and do the filtering here.
+                    string cacheKey = type switch
                     {
-                        // New behavior:
-                        // Always hit the filesystem with "*" pattern, cache the results, and do the filtering here.
-                        string cacheKey = type switch
-                        {
-                            FileSystemEntity.Files => "F",
-                            FileSystemEntity.Directories => "D",
-                            FileSystemEntity.FilesAndDirectories => "A",
-                            _ => throw new NotImplementedException()
-                        } + ";" + path;
-                        IReadOnlyList<string> allEntriesForPath = getFileSystemDirectoryEntriesCache.GetOrAdd(
-                                cacheKey,
-                                s => getFileSystemEntries(
-                                    type,
-                                    path,
-                                    "*",
-                                    directory,
-                                    false));
-                        IEnumerable<string> filteredEntriesForPath = (pattern != null && !IsAllFilesWildcard(pattern))
-                            ? allEntriesForPath.Where(o => IsFileNameMatch(o, pattern))
-                            : allEntriesForPath;
-                        return stripProjectDirectory
-                            ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToArray()
-                            : filteredEntriesForPath.ToArray();
-                    }
-                    else
-                    {
-                        // Legacy behavior:
-                        // Cache only directories, for files we won't hit the cache because the file name patterns tend to be unique
-                        if (type == FileSystemEntity.Directories)
-                        {
-                            return getFileSystemDirectoryEntriesCache.GetOrAdd(
-                                $"D;{path};{pattern ?? "*"}",
-                                s => getFileSystemEntries(
-                                    type,
-                                    path,
-                                    pattern,
-                                    directory,
-                                    stripProjectDirectory).ToArray());
-                        }
-                    }
-                    return getFileSystemEntries(type, path, pattern, directory, stripProjectDirectory);
+                        FileSystemEntity.Files => "F",
+                        FileSystemEntity.Directories => "D",
+                        FileSystemEntity.FilesAndDirectories => "A",
+                        _ => throw new NotImplementedException()
+                    } + ";" + path;
+                    IReadOnlyList<string> allEntriesForPath = getFileSystemDirectoryEntriesCache.GetOrAdd(
+                            cacheKey,
+                            s => getFileSystemEntries(
+                                type,
+                                path,
+                                "*",
+                                directory,
+                                false));
+                    IEnumerable<string> filteredEntriesForPath = (pattern != null && !IsAllFilesWildcard(pattern))
+                        ? allEntriesForPath.Where(o => IsFileNameMatch(o, pattern))
+                        : allEntriesForPath;
+                    return stripProjectDirectory
+                        ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToArray()
+                        : filteredEntriesForPath.ToArray();
                 };
         }
 
@@ -857,7 +836,7 @@ private void GetFilesRecursive(
             Dictionary<string, List<RecursionState>> searchesToExcludeInSubdirs,
             TaskOptions taskOptions)
         {
-            ErrorUtilities.VerifyThrow((recursionState.SearchData.Filespec== null) || (recursionState.SearchData.RegexFileMatch == null),
+            ErrorUtilities.VerifyThrow((recursionState.SearchData.Filespec == null) || (recursionState.SearchData.RegexFileMatch == null),
                 "File-spec overrides the regular expression -- pass null for file-spec if you want to use the regular expression.");
 
             ErrorUtilities.VerifyThrow((recursionState.SearchData.Filespec != null) || (recursionState.SearchData.RegexFileMatch != null),
@@ -1034,7 +1013,7 @@ private void GetFilesRecursive(
             {
                 Parallel.ForEach(
                     _getFileSystemEntries(FileSystemEntity.Directories, recursionState.BaseDirectory, nextStep.DirectoryPattern, null, false),
-                    new ParallelOptions {MaxDegreeOfParallelism = dop},
+                    new ParallelOptions { MaxDegreeOfParallelism = dop },
                     processSubdirectory);
             }
             if (dop <= 0)
@@ -1941,8 +1920,8 @@ public TaskOptions(int maxTasks)
         /// <param name="projectDirectoryUnescaped">The project directory.</param>
         /// <param name="filespecUnescaped">Get files that match the given file spec.</param>
         /// <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
-        /// <returns>The array of files.</returns>
-        internal string[] GetFiles
+        /// <returns>The search action, array of files, and Exclude file spec (if applicable).</returns>
+        internal (string[] FileList, SearchAction Action, string ExcludeFileSpec) GetFiles
             (
             string projectDirectoryUnescaped,
             string filespecUnescaped,
@@ -1952,7 +1931,7 @@ internal string[] GetFiles
             // For performance. Short-circuit iff there is no wildcard.
             if (!HasWildcards(filespecUnescaped))
             {
-                return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);
+                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), SearchAction.None, string.Empty);
             }
 
             if (_cachedGlobExpansions == null)
@@ -1966,6 +1945,9 @@ internal string[] GetFiles
             var enumerationKey = ComputeFileEnumerationCacheKey(projectDirectoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
 
             IReadOnlyList<string> files;
+            string[] fileList;
+            SearchAction action = SearchAction.None;
+            string excludeFileSpec = string.Empty;
             if (!_cachedGlobExpansions.TryGetValue(enumerationKey, out files))
             {
                 // avoid parallel evaluations of the same wildcard by using a unique lock for each wildcard
@@ -1974,14 +1956,17 @@ internal string[] GetFiles
                 {
                     if (!_cachedGlobExpansions.TryGetValue(enumerationKey, out files))
                     {
-                        files =
-                            _cachedGlobExpansions.GetOrAdd(
+                        files = _cachedGlobExpansions.GetOrAdd(
                                 enumerationKey,
                                 (_) =>
-                                    GetFilesImplementation(
+                                {
+                                    (fileList, action, excludeFileSpec) = GetFilesImplementation(
                                         projectDirectoryUnescaped,
                                         filespecUnescaped,
-                                        excludeSpecsUnescaped));
+                                        excludeSpecsUnescaped);
+
+                                    return fileList;
+                                });
                     }
                 }
             }
@@ -1989,7 +1974,7 @@ internal string[] GetFiles
             // Copy the file enumerations to prevent outside modifications of the cache (e.g. sorting, escaping) and to maintain the original method contract that a new array is created on each call.
             var filesToReturn = files.ToArray();
 
-            return filesToReturn;
+            return (filesToReturn, action, excludeFileSpec);
         }
 
         private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnescaped, string filespecUnescaped, List<string> excludes)
@@ -2067,11 +2052,14 @@ private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnes
             }
         }
 
-        enum SearchAction
+        public enum SearchAction
         {
+            None,
             RunSearch,
             ReturnFileSpec,
             ReturnEmptyList,
+            FailOnDriveEnumeratingWildcard,
+            LogDriveEnumeratingWildcard
         }
 
         private SearchAction GetFileSearchData(
@@ -2135,6 +2123,16 @@ out bool isLegalFileSpec
                 return SearchAction.ReturnEmptyList;
             }
 
+            /*
+             * If a drive enumerating wildcard pattern is detected with the fixed directory and wildcard parts, then
+             * this should either be logged or an exception should be thrown.
+             */
+            bool logDriveEnumeratingWildcard = IsDriveEnumeratingWildcardPattern(fixedDirectoryPart, wildcardDirectoryPart);
+            if (logDriveEnumeratingWildcard && Traits.Instance.ThrowOnDriveEnumeratingWildcard)
+            {
+                return SearchAction.FailOnDriveEnumeratingWildcard;
+            }
+
             string directoryPattern = null;
             if (wildcardDirectoryPart.Length > 0)
             {
@@ -2143,6 +2141,7 @@ out bool isLegalFileSpec
                 // "**/.*/**" for example, and is worth special-casing so it doesn't fall into the slow regex logic.
                 string wildcard = wildcardDirectoryPart.TrimTrailingSlashes();
                 int wildcardLength = wildcard.Length;
+
                 if (wildcardLength > 6 &&
                     wildcard[0] == '*' &&
                     wildcard[1] == '*' &&
@@ -2182,6 +2181,11 @@ out bool isLegalFileSpec
             result.BaseDirectory = Normalize(fixedDirectoryPart);
             result.RemainingWildcardDirectory = Normalize(wildcardDirectoryPart);
 
+            if (logDriveEnumeratingWildcard)
+            {
+                return SearchAction.LogDriveEnumeratingWildcard;
+            }
+
             return SearchAction.RunSearch;
         }
 
@@ -2258,6 +2262,76 @@ internal static string Normalize(string aString)
             return sb.ToString();
         }
 
+        /// <summary>
+        /// Returns true if drive enumerating wildcard patterns are detected using the directory and wildcard parts.
+        /// </summary>
+        /// <param name="directoryPart">Fixed directory string, portion of file spec info.</param>
+        /// <param name="wildcardPart">Wildcard string, portion of file spec info.</param>
+        internal static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart)
+        {
+            int directoryPartLength = directoryPart.Length;
+            int wildcardPartLength = wildcardPart.Length;
+
+            // Handles detection of <drive letter>:<slashes>** pattern for Windows.
+            if (NativeMethodsShared.IsWindows &&
+                directoryPartLength >= 3 &&
+                wildcardPartLength >= 2 &&
+                IsDrivePatternWithoutSlash(directoryPart[0], directoryPart[1]))
+            {
+                return IsFullFileSystemScan(2, directoryPartLength, directoryPart, wildcardPart);
+            }
+
+            // Handles detection of <slashes>** pattern for any platform.
+            else if (directoryPartLength >= 1 &&
+                     wildcardPartLength >= 2)
+            {
+                return IsFullFileSystemScan(0, directoryPartLength, directoryPart, wildcardPart);
+            }
+
+            return false;
+        }
+
+        /// <summary>
+        /// Returns true if given characters follow a drive pattern without the slash (ex: C:).
+        /// </summary>
+        /// <param name="firstValue">First char from directory part of file spec string.</param>
+        /// <param name="secondValue">Second char from directory part of file spec string.</param>
+        private static bool IsDrivePatternWithoutSlash(char firstValue, char secondValue)
+        {
+            return IsValidDriveChar(firstValue) && (secondValue == ':');
+        }
+
+        /// <summary>
+        /// Returns true if selected characters from the fixed directory and wildcard pattern make up the "{any number of slashes}**" pattern.
+        /// </summary>
+        /// <param name="directoryPartIndex">Starting index to begin detecting slashes in directory part of file spec string.</param>
+        /// <param name="directoryPartLength">Length of directory part of file spec string.</param>
+        /// <param name="directoryPart">Fixed directory string, portion of file spec info.</param>
+        /// <param name="wildcardPart">Wildcard string, portion of file spec info.</param>
+        private static bool IsFullFileSystemScan(int directoryPartIndex, int directoryPartLength, string directoryPart, string wildcardPart)
+        {
+            for (int i = directoryPartIndex; i < directoryPartLength; i++)
+            {
+                if (!FileUtilities.IsAnySlash(directoryPart[i]))
+                {
+                    return false;
+                }
+            }
+
+            return (wildcardPart[0] == '*') && (wildcardPart[1] == '*');
+        }
+
+        /// <summary>
+        /// Returns true if the given character is a valid drive letter.
+        /// </summary>
+        /// <remarks>
+        /// Copied from https://github.com/dotnet/corefx/blob/master/src/Common/src/System/IO/PathInternal.Windows.cs#L77-L83
+        /// </remarks>
+        private static bool IsValidDriveChar(char value)
+        {
+            return (value >= 'A' && value <= 'Z') || (value >= 'a' && value <= 'z');
+        }
+
         /// <summary>
         /// Skips slash characters in a string.
         /// </summary>
@@ -2276,15 +2350,6 @@ private static int SkipSlashes(string aString, int startingIndex)
             return index;
         }
 
-        // copied from https://github.com/dotnet/corefx/blob/master/src/Common/src/System/IO/PathInternal.Windows.cs#L77-L83
-        /// <summary>
-        /// Returns true if the given character is a valid drive letter
-        /// </summary>
-        private static bool IsValidDriveChar(char value)
-        {
-            return (value >= 'A' && value <= 'Z') || (value >= 'a' && value <= 'z');
-        }
-
         private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List<string> excludeSpecsUnescaped)
         {
             if (excludeSpecsUnescaped != null)
@@ -2317,8 +2382,8 @@ private static string[] CreateArrayWithSingleItemIfNotExcluded(string filespecUn
         /// <param name="projectDirectoryUnescaped">The project directory.</param>
         /// <param name="filespecUnescaped">Get files that match the given file spec.</param>
         /// <param name="excludeSpecsUnescaped">Exclude files that match this file spec.</param>
-        /// <returns>The array of files.</returns>
-        private string[] GetFilesImplementation(
+        /// <returns>The search action, array of files, and Exclude file spec (if applicable).</returns>
+        private (string[] FileList, SearchAction Action, string ExcludeFileSpec) GetFilesImplementation(
             string projectDirectoryUnescaped,
             string filespecUnescaped,
             List<string> excludeSpecsUnescaped)
@@ -2333,13 +2398,17 @@ private string[] GetFilesImplementation(
 
             if (action == SearchAction.ReturnEmptyList)
             {
-                return Array.Empty<string>();
+                return (Array.Empty<string>(), action, string.Empty);
             }
             else if (action == SearchAction.ReturnFileSpec)
             {
-                return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);
+                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), action, string.Empty);
             }
-            else if (action != SearchAction.RunSearch)
+            else if (action == SearchAction.FailOnDriveEnumeratingWildcard)
+            {
+                return (Array.Empty<string>(), action, string.Empty);
+            }
+            else if ((action != SearchAction.RunSearch) && (action != SearchAction.LogDriveEnumeratingWildcard))
             {
                 // This means the enum value wasn't valid (or a new one was added without updating code correctly)
                 throw new NotSupportedException(action.ToString());
@@ -2351,6 +2420,10 @@ private string[] GetFilesImplementation(
             //  The BaseDirectory of the exclude search is the key for this dictionary.
             Dictionary<string, List<RecursionState>> searchesToExcludeInSubdirs = null;
 
+            // Track the search action and exclude file spec for proper detection and logging of drive enumerating wildcards.
+            SearchAction trackSearchAction = action;
+            string trackExcludeFileSpec = string.Empty;
+
             HashSet<string> resultsToExclude = null;
             if (excludeSpecsUnescaped != null)
             {
@@ -2376,7 +2449,16 @@ private string[] GetFilesImplementation(
                         // Nothing to do
                         continue;
                     }
-                    else if (excludeAction != SearchAction.RunSearch)
+                    else if (excludeAction == SearchAction.FailOnDriveEnumeratingWildcard)
+                    {
+                        return (Array.Empty<string>(), excludeAction, excludeSpec);
+                    }
+                    else if (excludeAction == SearchAction.LogDriveEnumeratingWildcard)
+                    {
+                        trackSearchAction = excludeAction;
+                        trackExcludeFileSpec = excludeSpec;
+                    }
+                    else if ((excludeAction != SearchAction.RunSearch) && (excludeAction != SearchAction.LogDriveEnumeratingWildcard))
                     {
                         // This means the enum value wasn't valid (or a new one was added without updating code correctly)
                         throw new NotSupportedException(excludeAction.ToString());
@@ -2530,12 +2612,17 @@ private string[] GetFilesImplementation(
             // Catch exceptions that are thrown inside the Parallel.ForEach
             catch (AggregateException ex) when (InnerExceptionsAreAllIoRelated(ex))
             {
-                return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);
+                // Flatten to get exceptions than are thrown inside a nested Parallel.ForEach
+                if (ex.Flatten().InnerExceptions.All(ExceptionHandling.IsIoRelatedException))
+                {
+                    return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), trackSearchAction, trackExcludeFileSpec);
+                }
+                throw;
             }
             catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
             {
                 // Assume it's not meant to be a path
-                return CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped);
+                return (CreateArrayWithSingleItemIfNotExcluded(filespecUnescaped, excludeSpecsUnescaped), trackSearchAction, trackExcludeFileSpec);
             }
 
             /*
@@ -2545,7 +2632,7 @@ private string[] GetFilesImplementation(
                 ? listOfFiles.SelectMany(list => list).Where(f => !resultsToExclude.Contains(f)).ToArray()
                 : listOfFiles.SelectMany(list => list).ToArray();
 
-            return files;
+            return (files, trackSearchAction, trackExcludeFileSpec);
         }
 
         private bool InnerExceptionsAreAllIoRelated(AggregateException ex)
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index 4ae81fc5ada..894249cbd64 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -24,7 +24,7 @@ private static bool ShouldUseMicrosoftIO
             get
             {
 #if !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
-                return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0);
+                return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0) && NativeMethodsShared.IsWindows;
 #else
                 // We need to mock usage of ChangeWaves class,
                 // because Microsoft.Build.Engine.OM.UnitTests should not have access to internals of Microsoft.Build.Framework.
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index fa653803c61..9628a41db61 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -165,6 +165,30 @@ internal static int GetPathsHash(IEnumerable<string> assemblyPaths)
             return builder.ToString().GetHashCode();
         }
 
+        /// <summary>
+        /// Returns whether MSBuild can write to the given directory. Throws for PathTooLongExceptions
+        /// but not other exceptions.
+        /// </summary>
+        internal static bool CanWriteToDirectory(string directory)
+        {
+            try
+            {
+                string testFilePath = Path.Combine(directory, $"MSBuild_{Guid.NewGuid().ToString("N")}_testFile.txt");
+                File.WriteAllText(testFilePath, $"MSBuild process {Process.GetCurrentProcess().Id} successfully wrote to file.");
+                File.Delete(testFilePath);
+                return true;
+            }
+            catch (PathTooLongException)
+            {
+                ErrorUtilities.ThrowArgument("DebugPathTooLong", directory);
+                return false; // Should never reach here.
+            }
+            catch (Exception)
+            {
+                return false;
+            }
+        }
+
         /// <summary>
         /// Clears the MSBuild runtime cache
         /// </summary>
@@ -322,6 +346,11 @@ internal static bool IsSlash(char c)
         /// </summary>
         internal static string TrimAndStripAnyQuotes(string path)
         {
+            if (path is null)
+            {
+                return path;
+            }
+
             // Trim returns the same string if trimming isn't needed
             path = path.Trim();
             path = path.Trim(new char[] { '"' });
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
index fbe9d5e00fb..b9d063a4be9 100644
--- a/src/Shared/MSBuildLoadContext.cs
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -1,7 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
+
+using System;
 using System.Collections.Immutable;
 using System.IO;
 using System.Reflection;
@@ -15,6 +18,8 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal class MSBuildLoadContext : AssemblyLoadContext
     {
+        private AssemblyDependencyResolver? _resolver;
+
         private readonly string _directory;
 
         internal static readonly ImmutableHashSet<string> WellKnownAssemblyNames =
@@ -31,6 +36,8 @@ public MSBuildLoadContext(string assemblyPath)
             : base($"MSBuild plugin {assemblyPath}")
         {
             _directory = Directory.GetParent(assemblyPath)!.FullName;
+
+            _resolver = File.Exists(assemblyPath) ? new AssemblyDependencyResolver(assemblyPath) : null;
         }
 
         protected override Assembly? Load(AssemblyName assemblyName)
@@ -42,6 +49,19 @@ public MSBuildLoadContext(string assemblyPath)
                 return null;
             }
 
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                // respect plugin.dll.json with the AssemblyDependencyResolver
+                string? assemblyPath = _resolver?.ResolveAssemblyToPath(assemblyName);
+                if (assemblyPath != null)
+                {
+                    return LoadFromAssemblyPath(assemblyPath);
+                }
+            }
+
+            // Fall back to the older MSBuild-on-Core behavior to continue to support
+            // plugins that don't ship a .deps.json
+
             foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
                 // If no culture is specified, attempt to load directly from
                 // the known dependency paths.
@@ -73,7 +93,6 @@ public MSBuildLoadContext(string assemblyPath)
             // - the assembly from the user specified path is loaded, if it exists, into the custom ALC, or
             // - if the simple name of the assembly exists in the same folder as msbuild.exe, then that assembly gets loaded
             //   into the default ALC (so it's shared with other uses).
-
             var assemblyNameInExecutableDirectory = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
                 $"{assemblyName.Name}.dll");
 
@@ -84,5 +103,19 @@ public MSBuildLoadContext(string assemblyPath)
 
             return null;
         }
+
+        protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
+        {
+            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
+            {
+                string? libraryPath = _resolver?.ResolveUnmanagedDllToPath(unmanagedDllName);
+                if (libraryPath != null)
+                {
+                    return LoadUnmanagedDllFromPath(libraryPath);
+                }
+            }
+
+            return base.LoadUnmanagedDll(unmanagedDllName);
+        }
     }
 }
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index 4a2ab0dd185..b1c884da6fd 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -278,10 +278,15 @@
     <value>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</value>
     <comment>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</comment>
   </data>
+  <data name="WildcardResultsInDriveEnumeration" xml:space="preserve">
+    <value>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</value>
+    <comment>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</comment>
+  </data>
   <!--
         The shared message bucket is: MSB5001 - MSB5999
 
-        Next message code should be MSB5029
+        Next message code should be MSB5030
 
         Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
             <none>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 80de31cf354..28db153e941 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Parametr {0} s přiřazenou hodnotou {1} nesmí obsahovat neplatnou cestu nebo neplatné znaky souboru.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: Hodnota {0} atributu {1} v elementu &lt;{2}&gt; je zástupný znak, jehož výsledkem je výčet všech souborů na jednotce, což pravděpodobně nebylo zamýšleno. Zkontrolujte, jestli jsou odkazované vlastnosti vždy definovány.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index 28e73b49c1a..e304bd152ac 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Der Parameter "{0}" mit dem zugewiesenen Wert "{1}" darf keinen ungültigen Pfad und keine ungültigen Dateizeichen haben.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: Der Wert „{0}“ des Attributs „{1}“ im Element &lt;{2}&gt; ist ein Platzhalter, der dazu führt, dass alle Dateien auf dem Laufwerk aufgezählt werden, was wahrscheinlich nicht beabsichtigt war. Überprüfen Sie, ob Eigenschaften, auf die verwiesen wird, immer definiert sind.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 332d51f7961..c6979fa1689 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -308,6 +308,12 @@
         <target state="translated">El parámetro "{0}" con el valor asignado "{1}" no puede tener una ruta de acceso no válida o caracteres de archivo no válidos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: El valor “{0}” del atributo “{1}” en el elemento &lt;{2}&gt; es un carácter comodín que da como resultado la enumeración de todos los archivos de la unidad, lo que probablemente no estaba previsto. Compruebe que siempre se definan las propiedades a las que se hace referencia.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 98d0ecd2344..37399b16f44 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Le paramètre "{0}" avec la valeur assignée "{1}" ne peut pas avoir un chemin non valide ou des caractères de fichier non valides.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: La valeur "{0}" de l'attribut "{1}" de l'élément &lt;{2}&gt; est un caractère générique qui entraîne l'énumération de tous les fichiers du lecteur, ce qui n'était probablement pas prévu. Vérifiez que les propriétés référencées sont toujours définies.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 31c10bd56ca..5bb8c7eebfb 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Il parametro "{0}" con valore assegnato "{1}" non può contenere un percorso non valido o caratteri di file non validi.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: il valore "{0}" dell'attributo "{1}" nell'elemento &lt;{2}&gt; è un carattere jolly che determina l'enumerazione di tutti i file nell'unità, che probabilmente non era previsto. Verificare che le proprietà di riferimento siano sempre definite.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index 762d7780a9b..ca851b2b211 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -308,6 +308,12 @@
         <target state="translated">値 "{1}" が割り当てられたパラメーター "{0}" には、無効なパスまたは無効なファイル内の文字を指定することはできません。</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: 要素 &lt;{2}&gt; の "{1}" 属性の値 "{0}" はワイルドカードであり、ドライブ上のすべてのファイルが列挙され、それは意図されていない模様です。参照されるプロパティが常に定義されていることを確認してください。</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 7cd5d631a66..2832de50cd7 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -308,6 +308,12 @@
         <target state="translated">"{1}" 값이 할당된 "{0}" 매개 변수는 유효하지 않은 경로 또는 파일 문자를 포함할 수 없습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: &lt;{2}&gt; 요소의 "{1}" 특성의 값 "{0}"은(는) 의도하지 않은 드라이브의 모든 파일을 열거하는 와일드카드입니다. 참조된 속성이 항상 정의되어 있는지 확인하세요.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 3755284c24a..c0cd32ad0a0 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Parametr „{0}” z przypisaną wartością „{1}” nie może mieć nieprawidłowej ścieżki ani zawierać nieprawidłowych znaków w pliku.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: Wartość „{0}” atrybutu „{1}” w elemencie &lt;{2}&gt; jest symbolem wieloznacznym, który powoduje wyliczenie wszystkich plików na dysku, co prawdopodobnie nie było zamierzone. Sprawdź, czy przywoływane właściwości są zawsze zdefiniowane.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 6fd1b77903b..ff7be552a3d 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -308,6 +308,12 @@
         <target state="translated">O parâmetro "{0}" com o valor "{1}" atribuído não pode ter um caminho inválido ou caracteres de arquivo inválidos.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: O valor "{0}" do atributo "{1}" no elemento &lt;{2}&gt; é um curinga que resulta na enumeração de todos os arquivos na unidade, o que provavelmente não foi pretendido. Verifique se as propriedades referenciadas estão sempre definidas.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index 3570539b1f8..9d957db25d5 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -308,6 +308,12 @@
         <target state="translated">Параметр "{0}" с назначенным значением "{1}" не может иметь недопустимый путь или недопустимые символы файлов.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: значение "{0}" атрибута "{1}" в элементе &lt;{2}&gt; является подстановочным знаком, который приводит к перечислению всех файлов на диске, что, скорее всего, не предполагалось. Убедитесь, что свойства, на которые имеются ссылки, всегда определены.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index d6831788b90..ba298b18d89 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -308,6 +308,12 @@
         <target state="translated">"{1}" değeri atanan "{0}" parametresinde geçersiz yol veya geçersiz dosya karakterleri bulunamaz.</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: &lt;{2}&gt; öğesindeki "{1}" özniteliğinin "{0}" değeri, sürücüdeki tüm dosyaların numaralandırılmasıyla sonuçlanan (büyük olasılıkla bunun olması amaçlanmıyordu) bir joker karakterdir. Başvurulan özelliklerin her zaman tanımlı olduğundan emin olun.</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index b5468e75bcb..fd15f148422 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -308,6 +308,12 @@
         <target state="translated">分配有值“{1}”的参数“{0}”不可具有无效路径或无效的文件字符。</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: 元素 &lt;{2}&gt; 中“{1}”属性的值“{0}”是通配符，可导致枚举驱动器上的所有文件，这可能不是预期的行为。请检查是否始终定义了所引用的属性。</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 893e286184a..849ed85ed79 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -308,6 +308,12 @@
         <target state="translated">指派值為 "{1}" 的參數 "{0}" 不得具有無效的路徑或檔案字元。</target>
         <note />
       </trans-unit>
+      <trans-unit id="WildcardResultsInDriveEnumeration">
+        <source>MSB5029: The value "{0}" of the "{1}" attribute in element &lt;{2}&gt; is a wildcard that results in enumerating all files on the drive, which was likely not intended. Check that referenced properties are always defined.</source>
+        <target state="translated">MSB5029: 元素 &lt;{2}&gt; 中「{1}」屬性的值「{0}」是萬用字元，導致列舉磁碟機上的所有檔案，這很可能不是預期的結果。檢查是否一直定義參考屬性。</target>
+        <note>{StrBegin="MSB5029: "}UE: This is a generic message that is displayed when we find a project element that has a drive enumerating wildcard value for one of its
+      attributes e.g. &lt;Compile Include="$(NotAlwaysDefined)\**\*.cs"&gt; -- if the property is undefined, the value of Include should not result in enumerating all files on drive.</note>
+      </trans-unit>
     </body>
   </file>
 </xliff>
\ No newline at end of file
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index bca3773e17a..e83e0c56d1b 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -62,7 +62,7 @@ public void GetFilesPatternMatching(string pattern, int expectedMatchCount)
                 File.WriteAllBytes(Path.Combine(testFolder.Path, file), new byte[1]);
             }
 
-            string[] fileMatches = FileMatcher.Default.GetFiles(testFolder.Path, pattern);
+            string[] fileMatches = FileMatcher.Default.GetFiles(testFolder.Path, pattern).FileList;
 
             fileMatches.Length.ShouldBe(expectedMatchCount, $"Matches: '{String.Join("', '", fileMatches)}'");
         }
@@ -83,7 +83,7 @@ public void GetFilesComplexGlobbingMatching(GetFilesComplexGlobbingMatchingInfo
 
             void VerifyImpl(FileMatcher fileMatcher, string include, string[] excludes, bool shouldHaveNoMatches = false, string customMessage = null)
             {
-                string[] matchedFiles = fileMatcher.GetFiles(testFolder.Path, include, excludes?.ToList());
+                string[] matchedFiles = fileMatcher.GetFiles(testFolder.Path, include, excludes?.ToList()).FileList;
 
                 if (shouldHaveNoMatches)
                 {
@@ -1042,8 +1042,8 @@ public void DotDotForParentDirectory()
                 // On Linux *. * does not pick up files with no extension
                 ValidateFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine("..", "..", "File"), false);
             }
-            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new [] {"..", "..", "dir1", "dir2", "File.txt"}), false);
-            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new [] {"..", "..", "dir1", "dir2", "File"}), false);
+            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new[] { "..", "..", "dir1", "dir2", "File.txt" }), false);
+            ValidateNoFileMatch(Path.Combine("..", "..", "*.*"), Path.Combine(new[] { "..", "..", "dir1", "dir2", "File" }), false);
         }
 
         [Fact]
@@ -1256,7 +1256,7 @@ public void IllegalTooLongPathOptOutWave17_0()
                 BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
                 string longString = new string('X', 500) + "*"; // need a wildcard to do anything
-                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString);
+                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString).FileList;
 
                 Assert.Equal(longString, result[0]); // Does not throw
                 ChangeWaves.ResetStateForTests();
@@ -1298,7 +1298,7 @@ public void Regress367780_CrashOnStarDotDot()
             Directory.CreateDirectory(workingPath);
             Directory.CreateDirectory(workingPathSubfolder);
 
-            files = FileMatcher.Default.GetFiles(workingPath, offendingPattern);
+            files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).FileList;
         }
 
         [Fact]
@@ -1310,7 +1310,7 @@ public void Regress141071_StarStarSlashStarStarIsLiteral()
 
             Directory.CreateDirectory(workingPath);
             File.WriteAllText(fileName, "Hello there.");
-            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern);
+            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).FileList;
 
             string result = String.Join(", ", files);
             Console.WriteLine(result);
@@ -1330,7 +1330,7 @@ public void Regress14090_TrailingDotMatchesNoExtension()
             Directory.CreateDirectory(workingPath);
             Directory.CreateDirectory(workingPathSubdir);
             File.AppendAllText(workingPathSubdirBing, "y");
-            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern);
+            var files = FileMatcher.Default.GetFiles(workingPath, offendingPattern).FileList;
 
             string result = String.Join(", ", files);
             Console.WriteLine(result);
@@ -1353,19 +1353,19 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
                 {
                     env.SetEnvironmentVariable("MsBuildCacheFileEnumerations", "1");
 
-                    var testProject = env.CreateTestProjectWithFiles(string.Empty, new[] {"a.cs", "b.cs", "c.cs"});
+                    var testProject = env.CreateTestProjectWithFiles(string.Empty, new[] { "a.cs", "b.cs", "c.cs" });
 
-                    var files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs");
+                    var files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs").FileList;
                     Array.Sort(files);
-                    Assert.Equal(new []{"a.cs", "b.cs", "c.cs"}, files);
+                    Assert.Equal(new[] { "a.cs", "b.cs", "c.cs" }, files);
 
-                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string> {"a.cs"});
+                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string> { "a.cs" }).FileList;
                     Array.Sort(files);
-                    Assert.Equal(new[] {"b.cs", "c.cs" }, files);
+                    Assert.Equal(new[] { "b.cs", "c.cs" }, files);
 
-                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string> {"a.cs", "c.cs"});
+                    files = FileMatcher.Default.GetFiles(testProject.TestRoot, "**/*.cs", new List<string> { "a.cs", "c.cs" }).FileList;
                     Array.Sort(files);
-                    Assert.Equal(new[] {"b.cs" }, files);
+                    Assert.Equal(new[] { "b.cs" }, files);
                 }
             }
             finally
@@ -1374,6 +1374,146 @@ public void FileEnumerationCacheTakesExcludesIntoAccount()
             }
         }
 
+        [PlatformSpecific(TestPlatforms.Any)]
+        [Theory]
+        [InlineData(@"\", "**")]
+        [InlineData(@"\\", "**")]
+        [InlineData(@"\\\\\\\\", "**")]
+        [InlineData("/", "**/*.cs")]
+        [InlineData("/", "**")]
+        [InlineData("//", "**")]
+        [InlineData("////////", "**")]
+        public void DriveEnumeratingWildcardIsObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
+            DriveEnumeratingWildcardIsObserved(directoryPart, wildcardPart);
+
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"\", "**")]
+        [InlineData(@"c:\", "**")]
+        [InlineData(@"c:\\", "**")]
+        [InlineData(@"c:\\\\\\\\", "**")]
+        [InlineData(@"c:\", @"**\*.cs")]
+        public void DriveEnumeratingWildcardIsObservedOnWindows(string directoryPart, string wildcardPart)
+        {
+            DriveEnumeratingWildcardIsObserved(directoryPart, wildcardPart);
+            DriveEnumeratingWildcardFailsAndReturns(directoryPart, wildcardPart);
+        }
+
+        private void DriveEnumeratingWildcardIsObserved(string directoryPart, string wildcardPart) =>
+            FileMatcher.IsDriveEnumeratingWildcardPattern(directoryPart, wildcardPart).ShouldBeTrue();
+
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"\", "**")]
+        [InlineData("/", "**/*.cs")]
+        [InlineData("/", "**")]
+        [InlineData("//", "**")]
+        [InlineData("////////", "**")]
+        public void DriveEnumeratingWildcardFailsAndReturnsOnUnix(string directoryPart, string wildcardPart)
+        {
+            DriveEnumeratingWildcardFailsAndReturns(directoryPart, wildcardPart);
+        }
+
+        private void DriveEnumeratingWildcardFailsAndReturns(string directoryPart, string wildcardPart)
+        {
+            string driveEnumeratingWildcard = string.Concat(directoryPart, wildcardPart);
+
+            using (var env = TestEnvironment.Create())
+            {
+                try
+                {
+                    // Set env var to fail on drive enumerating wildcard detection
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "1");
+
+                    (string[] fileList, FileMatcher.SearchAction action, string excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        driveEnumeratingWildcard);
+
+                    action.ShouldBe(FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard);
+                    fileList.ShouldBeEmpty();
+                    excludeFileSpec.ShouldBe(string.Empty);
+
+                    // Handle failing with drive enumerating exclude
+                    (fileList, action, excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        @"/*/*.cs",
+                        new List<string> { driveEnumeratingWildcard });
+
+                    action.ShouldBe(FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard);
+                    fileList.ShouldBeEmpty();
+                    excludeFileSpec.ShouldBe(driveEnumeratingWildcard);
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
+
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"z:\**")]
+        [InlineData(@"z:\\**")]
+        [InlineData(@"z:\\\\\\\\**")]
+        [InlineData(@"z:\**\*.cs")]
+        public void DriveEnumeratingWildcardIsLoggedOnWindows(string driveEnumeratingWildcard)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                try
+                {
+                    // Set env var to log on drive enumerating wildcard detection
+                    Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "0");
+
+                    (_, FileMatcher.SearchAction action, string excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        driveEnumeratingWildcard);
+
+                    action.ShouldBe(FileMatcher.SearchAction.LogDriveEnumeratingWildcard);
+                    excludeFileSpec.ShouldBe(string.Empty);
+
+                    // Handle logging with drive enumerating exclude
+                    (_, action, excludeFileSpec) = FileMatcher.Default.GetFiles(
+                        string.Empty,
+                        @"/*/*.cs",
+                        new List<string> { driveEnumeratingWildcard });
+
+                    action.ShouldBe(FileMatcher.SearchAction.LogDriveEnumeratingWildcard);
+                    excludeFileSpec.ShouldBe(driveEnumeratingWildcard);
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
+
+        [PlatformSpecific(TestPlatforms.Any)]
+        [Theory]
+        [InlineData(@"\", @"*\*.cs")]
+        [InlineData(@"\\", @"*\*.cs")]
+        [InlineData(@"\", @"*\*.*")]
+        [InlineData(@"/", @"*/*.cs")]
+        [InlineData(@"//", @"*/*.cs")]
+        [InlineData(@"/", @"*/*.*")]
+        public void DriveEnumeratingWildcardIsNotObservedOnAnyPlatform(string directoryPart, string wildcardPart) =>
+            DriveEnumeratingWildcardIsNotObserved(directoryPart, wildcardPart);
+
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"c:\", "**")]
+        [InlineData(@"c:\\", "**")]
+        [InlineData(@"c:\\\\\\\\", "**")]
+        [InlineData(@"c:\", @"**\*.cs")]
+        public void DriveEnumeratingWildcardIsNotObservedOnUnix(string directoryPart, string wildcardPart)
+        {
+            DriveEnumeratingWildcardIsNotObserved(directoryPart, wildcardPart);
+        }
+
+        private void DriveEnumeratingWildcardIsNotObserved(string directoryPart, string wildcardPart) =>
+            FileMatcher.IsDriveEnumeratingWildcardPattern(directoryPart, wildcardPart).ShouldBeFalse();
+
         [Fact]
         public void RemoveProjectDirectory()
         {
@@ -2383,7 +2523,7 @@ private static void MatchDriver(string filespec, string[] excludeFilespecs, stri
                 String.Empty, /* we don't need project directory as we use mock filesystem */
                 filespec,
                 excludeFilespecs?.ToList()
-            );
+            ).FileList;
 
             Func<string[], string[]> normalizeAllFunc = (paths => normalizeAllPaths ? paths.Select(MockFileSystem.Normalize).ToArray() : paths);
             Func<string[], string[]> normalizeMatching = (paths => normalizeExpectedMatchingFiles ? paths.Select(MockFileSystem.Normalize).ToArray() : paths);
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index d6c10b453e0..d4d5b8e3d1e 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -13,7 +13,9 @@
 using System.Threading.Tasks;
 using System.Xml;
 
+using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.FileSystem;
@@ -1403,6 +1405,107 @@ public static BuildResult BuildProjectFileUsingBuildManager(string projectFile,
             }
         }
 
+        internal enum ExpectedBuildResult
+        {
+            // The build should fail with a logged error upon drive enumerationg wildcard detection and setting of environment variable.
+            FailWithError,
+            // The build should succeed with a logged warning upon drive enumerating wildcard detection (regardless of environment variable value).
+            SucceedWithWarning,
+            // The build should succeed with no logged warnings and errors, as there are no drive enumerating wildcards.
+            SucceedWithNoErrorsAndWarnings
+        }
+
+        /// <summary>
+        /// Verify that a drive enumerating wildcard warning is logged or exception is thrown. 
+        /// </summary>
+        internal static void CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(string content, string failOnDriveEnumerationEnvVar, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
+        {
+            using (var env = TestEnvironment.Create(testOutput))
+            {
+                // Clean file contents by replacing single quotes with double quotes, etc.
+                content = ObjectModelHelpers.CleanupFileContents(content);
+                var testProject = env.CreateTestProjectWithFiles(content.Cleanup());
+
+                // Reset state
+                ResetStateForDriveEnumeratingWildcardTests(env, failOnDriveEnumerationEnvVar);
+
+                // Setup and build test target
+                BuildTargetWithDriveEnumeratingWildcardUsingBuildManager(env, testProject.ProjectFile, targetName, expectedBuildResult, testOutput);
+            }
+        }
+
+        internal static void ResetStateForDriveEnumeratingWildcardTests(TestEnvironment env, string setEnvVar)
+        {
+            ChangeWaves.ResetStateForTests();
+            env.SetEnvironmentVariable("MSBUILDFAILONDRIVEENUMERATINGWILDCARD", setEnvVar);
+            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+        }
+
+        internal static void BuildTargetWithDriveEnumeratingWildcardUsingBuildManager(TestEnvironment env, string testProjectFile, string targetName, ExpectedBuildResult expectedBuildResult, ITestOutputHelper testOutput = null)
+        {
+            try
+            {
+                // Setup build
+                MockLogger mockLogger = (testOutput == null) ? new MockLogger() : new MockLogger(testOutput);
+                var p = ProjectInstance.FromFile(testProjectFile, new ProjectOptions());
+                BuildManager buildManager = BuildManager.DefaultBuildManager;
+                BuildRequestData data = new BuildRequestData(p, new[] { targetName });
+                BuildParameters parameters = new BuildParameters()
+                {
+                    Loggers = new ILogger[] { mockLogger },
+                };
+
+                // Perform build using build manager
+                BuildResult buildResult = buildManager.Build(parameters, data);
+
+                // Verify result based on value of ExpectedBuildResult
+                if (expectedBuildResult == ExpectedBuildResult.FailWithError)
+                {
+                    VerifyErrorLoggedForDriveEnumeratingWildcard(buildResult, mockLogger, targetName);
+                }
+                else if (expectedBuildResult == ExpectedBuildResult.SucceedWithWarning)
+                {
+                    VerifyWarningLoggedForDriveEnumeratingWildcard(buildResult, mockLogger, targetName);
+                }
+                else if (expectedBuildResult == ExpectedBuildResult.SucceedWithNoErrorsAndWarnings)
+                {
+                    VerifyNoErrorsAndWarningsForDriveEnumeratingWildcard(buildResult, mockLogger, targetName);
+                }
+            }
+            finally
+            {
+                ChangeWaves.ResetStateForTests();
+            }
+        }
+
+        private static void VerifyErrorLoggedForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
+        {
+            buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+            buildResult[targetName].ResultCode.ShouldBe(TargetResultCode.Failure);
+            mockLogger.ErrorCount.ShouldBe(1);
+            mockLogger.Errors[0].Code.ShouldBe("MSB5029");
+        }
+
+        private static void VerifyWarningLoggedForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
+        {
+            VerifySuccessOfBuildAndTargetResults(buildResult, targetName);
+            mockLogger.WarningCount.ShouldBe(1);
+            mockLogger.Warnings[0].Code.ShouldBe("MSB5029");
+        }
+
+        private static void VerifyNoErrorsAndWarningsForDriveEnumeratingWildcard(BuildResult buildResult, MockLogger mockLogger, string targetName)
+        {
+            VerifySuccessOfBuildAndTargetResults(buildResult, targetName);
+            mockLogger.WarningCount.ShouldBe(0);
+            mockLogger.ErrorCount.ShouldBe(0);
+        }
+
+        private static void VerifySuccessOfBuildAndTargetResults(BuildResult buildResult, string targetName)
+        {
+            buildResult.OverallResult.ShouldBe(BuildResultCode.Success);
+            buildResult[targetName].ResultCode.ShouldBe(TargetResultCode.Success);
+        }
+
         /// <summary>
         /// Build a project with the provided content in memory.
         /// Assert that it fails, and return the mock logger with the output.
diff --git a/src/Shared/UnitTests/TypeLoader_Tests.cs b/src/Shared/UnitTests/TypeLoader_Tests.cs
index 9fb112d8c03..cb820d22e61 100644
--- a/src/Shared/UnitTests/TypeLoader_Tests.cs
+++ b/src/Shared/UnitTests/TypeLoader_Tests.cs
@@ -6,8 +6,10 @@
 using System.IO;
 using Microsoft.Build.Shared;
 using System.Reflection;
-using Xunit;
 using Microsoft.Build.UnitTests.Shared;
+using Xunit;
+using Xunit.Abstractions;
+using Shouldly;
 
 #nullable disable
 
@@ -19,6 +21,13 @@ public class TypeLoader_Tests
         private const string ProjectFileName = "portableTaskTest.proj";
         private const string DLLFileName = "PortableTask.dll";
 
+        private readonly ITestOutputHelper _output;
+
+        public TypeLoader_Tests(ITestOutputHelper testOutputHelper)
+        {
+            _output = testOutputHelper;
+        }
+
         [Fact]
         public void Basic()
         {
@@ -50,19 +59,18 @@ public void Regress_Mutation_ParameterOrderDoesntMatter()
         [Fact]
         public void LoadNonExistingAssembly()
         {
-            using (var dir = new FileUtilities.TempWorkingDirectory(ProjectFileFolder))
-            {
-                string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
+            using var dir = new FileUtilities.TempWorkingDirectory(ProjectFileFolder);
 
-                string dllName = "NonExistent.dll";
+            string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + dllName, out successfulExit);
-                Assert.False(successfulExit);
+            string dllName = "NonExistent.dll";
 
-                string dllPath = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, dllName);
-                CheckIfCorrectAssemblyLoaded(output, dllPath, false);
-            }
+            bool successfulExit;
+            string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + dllName, out successfulExit, _output);
+            successfulExit.ShouldBeFalse();
+
+            string dllPath = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, dllName);
+            CheckIfCorrectAssemblyLoaded(output, dllPath, false);
         }
 
         [Fact]
@@ -73,7 +81,7 @@ public void LoadInsideAsssembly()
                 string projectFilePath = Path.Combine(dir.Path, ProjectFileName);
 
                 bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag", out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag", out successfulExit, _output);
                 Assert.True(successfulExit);
 
                 string dllPath = Path.Combine(dir.Path, DLLFileName);
@@ -95,7 +103,7 @@ public void LoadOutsideAssembly()
                 try
                 {
                     bool successfulExit;
-                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + movedDLLPath, out successfulExit);
+                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + movedDLLPath, out successfulExit, _output);
                     Assert.True(successfulExit);
 
                     CheckIfCorrectAssemblyLoaded(output, movedDLLPath);
@@ -119,7 +127,7 @@ public void LoadInsideAssemblyWhenGivenOutsideAssemblyWithSameName()
                 try
                 {
                     bool successfulExit;
-                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + copiedDllPath, out successfulExit);
+                    string output = RunnerUtilities.ExecMSBuild(projectFilePath + " /v:diag /p:AssemblyPath=" + copiedDllPath, out successfulExit, _output);
                     Assert.True(successfulExit);
 
                     CheckIfCorrectAssemblyLoaded(output, originalDLLPath);
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index c7a3e3752fc..7a4d501e09c 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -3,6 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+#if !CLR2COMPATIBILITY
+using System.Runtime.InteropServices;
+#endif
 using System.Runtime.CompilerServices;
 
 #nullable disable
@@ -88,6 +91,7 @@ internal struct MSBuildArchitectureValues
         {
             internal const string x86 = "x86";
             internal const string x64 = "x64";
+            internal const string arm64 = "arm64";
             internal const string currentArchitecture = "CurrentArchitecture";
             internal const string any = "*";
         }
@@ -106,7 +110,7 @@ internal struct MSBuildArchitectureValues
 
         private static readonly HashSet<string> ValidMSBuildRuntimeValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildRuntimeValues.clr2, MSBuildRuntimeValues.clr4, MSBuildRuntimeValues.currentRuntime, MSBuildRuntimeValues.net, MSBuildRuntimeValues.any };
 
-        private static readonly HashSet<string> ValidMSBuildArchitectureValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildArchitectureValues.x86, MSBuildArchitectureValues.x64, MSBuildArchitectureValues.currentArchitecture, MSBuildArchitectureValues.any };
+        private static readonly HashSet<string> ValidMSBuildArchitectureValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildArchitectureValues.x86, MSBuildArchitectureValues.x64, MSBuildArchitectureValues.arm64, MSBuildArchitectureValues.currentArchitecture, MSBuildArchitectureValues.any };
 
         /// <summary>
         /// Returns true if and only if the specified attribute is one of the attributes that the engine specifically recognizes
@@ -429,7 +433,25 @@ internal static bool TryMergeArchitectureValues(string architectureA, string arc
         /// </comments>
         internal static string GetCurrentMSBuildArchitecture()
         {
+#if !CLR2COMPATIBILITY
+            string currentArchitecture = string.Empty;
+            switch (RuntimeInformation.ProcessArchitecture)
+            {
+                case Architecture.X86:
+                    currentArchitecture = MSBuildArchitectureValues.x86;
+                    break;
+                case Architecture.X64:
+                    currentArchitecture = MSBuildArchitectureValues.x64;
+                    break;
+                case Architecture.Arm64:
+                    currentArchitecture = MSBuildArchitectureValues.arm64;
+                    break;
+                default:
+                    throw new PlatformNotSupportedException(string.Format("{0} is not a supported architecture.", RuntimeInformation.ProcessArchitecture));
+            }
+#else
             string currentArchitecture = (IntPtr.Size == sizeof(Int64)) ? MSBuildArchitectureValues.x64 : MSBuildArchitectureValues.x86;
+#endif
             return currentArchitecture;
         }
 
diff --git a/src/StringTools.Benchmark/StringTools.Benchmark.csproj b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
index eb1bf1347f3..92f0e8e82eb 100644
--- a/src/StringTools.Benchmark/StringTools.Benchmark.csproj
+++ b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
@@ -4,7 +4,7 @@
     <UseAppHost>false</UseAppHost>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
+
     <IsPackable>false</IsPackable>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
 
@@ -14,6 +14,9 @@
 
   <ItemGroup>
     <PackageReference Include="BenchmarkDotNet" />
+    <!-- Bump these to the latest version despite transitive references to older -->
+    <PackageReference Include="System.Private.Uri" />
+    <PackageReference Include="System.Runtime" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index f7aef1ac162..2d572ebf1dc 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -15,6 +15,7 @@
 using Xunit.Abstractions;
 
 using NativeMethods = Microsoft.Build.Tasks.NativeMethods;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -2491,10 +2492,10 @@ internal static AssemblyNameExtension[] GetDependencies(string path)
             };
         }
 
-#pragma warning disable CA1416
         /// <summary>
         /// Registry access delegate. Given a hive and a view, return the registry base key.
         /// </summary>
+        [SupportedOSPlatform("windows")]
         private static RegistryKey GetBaseKey(RegistryHive hive, RegistryView view)
         {
             if (hive == RegistryHive.CurrentUser)
@@ -2516,6 +2517,7 @@ private static RegistryKey GetBaseKey(RegistryHive hive, RegistryView view)
         /// <param name="baseKey">The base registry key.</param>
         /// <param name="subKey">The subkey</param>
         /// <returns>An enumeration of strings.</returns>
+        [SupportedOSPlatform("windows")]
         private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, string subKey)
         {
             if (baseKey == Registry.CurrentUser)
@@ -2765,6 +2767,7 @@ private static IEnumerable<string> GetRegistrySubKeyNames(RegistryKey baseKey, s
         /// <param name="baseKey">The base registry key.</param>
         /// <param name="subKey">The subkey</param>
         /// <returns>A string containing the default value.</returns>
+        [SupportedOSPlatform("windows")]
         private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string subKey)
         {
             if (baseKey == Registry.CurrentUser)
@@ -2900,7 +2903,6 @@ private static string GetRegistrySubKeyDefaultValue(RegistryKey baseKey, string
             Assert.True(false, $"New GetRegistrySubKeyDefaultValue parameters encountered, need to add unittesting support for subKey={subKey}");
             return null;
         }
-#pragma warning restore CA1416
 
         /// <summary>
         /// Delegate for System.IO.File.GetLastWriteTime
diff --git a/src/Tasks.UnitTests/AssignTargetPath_Tests.cs b/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
index 76ceb607817..ace9870ffe6 100644
--- a/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
+++ b/src/Tasks.UnitTests/AssignTargetPath_Tests.cs
@@ -107,40 +107,6 @@ public void TargetPathAlreadySet(string targetPath)
             t.AssignedFiles.Length.ShouldBe(1);
             t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe(targetPath);
         }
-
-        [Theory]
-        [InlineData("c:/fully/qualified/path.txt")]
-        [InlineData("test/output/file.txt")]
-        [InlineData(@"some\dir\to\file.txt")]
-        [InlineData("file.txt")]
-        [InlineData("file")]
-        public void TargetPathAlreadySet_DisabledUnderChangeWave16_10(string targetPath)
-        {
-            using TestEnvironment env = TestEnvironment.Create();
-            string link = "c:/some/path";
-
-            ChangeWaves.ResetStateForTests();
-            env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
-            BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-            AssignTargetPath t = new AssignTargetPath();
-            t.BuildEngine = new MockEngine();
-            Dictionary<string, string> metaData = new Dictionary<string, string>();
-            metaData.Add("TargetPath", targetPath);
-            metaData.Add("Link", link);
-            t.Files = new ITaskItem[]
-                          {
-                              new TaskItem(
-                                  itemSpec: NativeMethodsShared.IsWindows ? @"c:\f1\f2\file.txt" : "/f1/f2/file.txt",
-                                  itemMetadata: metaData)
-                          };
-            t.RootFolder = NativeMethodsShared.IsWindows ? @"c:\f1\f2" : "/f1/f2";
-
-            t.Execute().ShouldBeTrue();
-            t.AssignedFiles.Length.ShouldBe(1);
-            t.AssignedFiles[0].GetMetadata("TargetPath").ShouldBe(link);
-            ChangeWaves.ResetStateForTests();
-        }
     }
 }
 
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index a3d57998984..997076c3bee 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -2399,9 +2399,7 @@ public void CopyToDestinationFolderWithSymbolicLinkCheck()
 
             if (NativeMethodsShared.IsWindows)
             {
-#pragma warning disable CA1416 // Suppress Warning saying that WindowsPrincipal might not be compatible on Windows (Which shouldn't be an issue...)
                 if (!new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(new SecurityIdentifier(WellKnownSidType.BuiltinAdministratorsSid, null)))
-#pragma warning restore CA1416 // Suppress Warning saying that WindowsPrincipal might not be compatible on Windows (Which shouldn't be an issue...)
                 {
                     isPrivileged = false;
                     Assert.True(true, "It seems that you don't have the permission to create symbolic links. Try to run this test again with higher privileges");
diff --git a/src/Tasks.UnitTests/CreateItem_Tests.cs b/src/Tasks.UnitTests/CreateItem_Tests.cs
index 0c422b67892..3092c041e8a 100644
--- a/src/Tasks.UnitTests/CreateItem_Tests.cs
+++ b/src/Tasks.UnitTests/CreateItem_Tests.cs
@@ -3,8 +3,11 @@
 
 using System.IO;
 using System.Collections.Generic;
+using Microsoft.Build.Definition;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 using Xunit;
@@ -17,6 +20,16 @@ namespace Microsoft.Build.UnitTests
 {
     sealed public class CreateItem_Tests
     {
+        internal const string CreateItemWithInclude = @"
+            <Project>
+                <Target Name='TestTarget' Returns='@(Text)'>
+                    <CreateItem Include='{0}'>
+                        <Output TaskParameter='Include' ItemName='Text'/>
+                    </CreateItem>
+                </Target>
+            </Project>
+            ";
+
         private readonly ITestOutputHelper _testOutput;
 
         public CreateItem_Tests(ITestOutputHelper output)
@@ -261,8 +274,173 @@ public void AdditionalMetaDataOverwriteExisting()
             Assert.True(success);
             Assert.Equal("SomeOverwriteValue", t.Include[0].GetMetadata("MyMetaData"));
         }
-    }
-}
 
+        /// <summary>
+        /// Logs error when encountering wildcard drive enumeration during task item creation.
+        /// </summary>
+        [Theory]
+        [InlineData(@"/**")]
+        [InlineData(@"/**/*.cs")]
+        [InlineData(@"/**/*/*.cs")]
+        public void WildcardDriveEnumerationTaskItemLogsError(string itemSpec)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "1");
+
+                try
+                {
+                    MockEngine engine = new MockEngine();
+                    CreateItem t = new CreateItem()
+                    {
+                        BuildEngine = engine,
+                        Include = new ITaskItem[] { new TaskItem(itemSpec) },
+                    };
+
+                    t.Execute().ShouldBeFalse();
+                    engine.Errors.ShouldBe(1);
+                    engine.AssertLogContains("MSB5029");
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
+
+        /// <summary>
+        /// Logs warning when encountering wildcard drive enumeration during task item creation on Windows platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(@"z:\**")]
+        [InlineData(@"z:\**\*.log")]
+        [InlineData(@"z:\\\\**\*.log")]
+        public void LogWindowsWarningUponCreateItemExecution(string itemSpec)
+        {
+            VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(itemSpec);
+        }
+
+        /// <summary>
+        /// Logs warning when encountering wildcard drive enumeration during task item creation on Unix platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(@"\**")]
+        [InlineData(@"\**\*.log")]
+        public void LogUnixWarningUponCreateItemExecution(string itemSpec)
+        {
+            VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(itemSpec);
+        }
+
+        private static void VerifyDriveEnumerationWarningLoggedUponCreateItemExecution(string itemSpec)
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                Helpers.ResetStateForDriveEnumeratingWildcardTests(env, "0");
+
+                try
+                {
+                    MockEngine engine = new MockEngine();
+                    CreateItem t = new CreateItem()
+                    {
+                        BuildEngine = engine,
+                        Include = new ITaskItem[] { new TaskItem(itemSpec) },
+                    };
+
+                    t.Execute().ShouldBeTrue();
+                    engine.Warnings.ShouldBe(1);
+                    engine.AssertLogContains("MSB5029");
+                }
+                finally
+                {
+                    ChangeWaves.ResetStateForTests();
+                }
+            }
+        }
 
+        /// <summary>
+        /// Throws exception when encountering wildcard drive enumeration during CreateItem task execution.
+        /// </summary>
+        [Theory]
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**\*.txt")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"$(empty)\**\*.cs")]
+        public void ThrowExceptionUponItemCreationWithDriveEnumeration(string content, string include)
+        {
+            content = string.Format(content, include);
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "1",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.FailWithError,
+                _testOutput);
+        }
 
+        /// <summary>
+        /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Windows platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        [Theory]
+        [InlineData(
+            CreateItemWithInclude,
+            @"z:\**")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"z:\**\*.txt")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"z:$(empty)\**\*.cs")]
+        public void LogWindowsWarningUponItemCreationWithDriveEnumeration(string content, string include)
+        {
+            content = string.Format(content, include);
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                content,
+                "0",
+                "TestTarget",
+                Helpers.ExpectedBuildResult.SucceedWithWarning,
+                _testOutput);
+        }
+
+        /// <summary>
+        /// Logs warning when encountering wildcard drive enumeration during CreateItem task execution on Unix platform.
+        /// </summary>
+        [ActiveIssue("https://github.com/dotnet/msbuild/issues/7330")]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        [Theory]
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"\**\*.txt")]
+
+        [InlineData(
+            CreateItemWithInclude,
+            @"$(empty)\**\*.cs")]
+        public void LogUnixWarningUponItemCreationWithDriveEnumeration(string content, string include)
+        {
+            content = string.Format(content, include);
+            Helpers.CleanContentsAndBuildTargetWithDriveEnumeratingWildcard(
+                    content,
+                    "0",
+                    "TestTarget",
+                    Helpers.ExpectedBuildResult.SucceedWithWarning,
+                    _testOutput);
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 72fe8006abd..ae4f8f1a92b 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -69,31 +69,6 @@ public void EscapeSpecifiedCharactersInPathToGeneratedBatchFile()
             }
         }
 
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void EscapeSpecifiedCharactersInPathToGeneratedBatchFile_DisabledUnderChangeWave16_10()
-        {
-            using (var testEnvironment = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                testEnvironment.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                var newTempPath = testEnvironment.CreateNewTempPathWithSubfolder("hello()w]o(rld)").TempPath;
-
-                string tempPath = Path.GetTempPath();
-                Assert.StartsWith(newTempPath, tempPath);
-
-                // Now run the Exec task on a simple command.
-                Exec exec = PrepareExec("echo Hello World!");
-                exec.Execute().ShouldBeFalse();
-
-                ChangeWaves.ResetStateForTests();
-            }
-        }
-
         /// <summary>
         /// Ensures that calling the Exec task does not leave any extra TEMP files
         /// lying around.
@@ -1017,64 +992,6 @@ public void EndToEndMultilineExec_EscapeSpecialCharacters()
                 }
             }
         }
-
-        [Fact]
-        [Trait("Category", "mono-osx-failing")]
-        [Trait("Category", "netcore-osx-failing")]
-        [Trait("Category", "netcore-linux-failing")]
-        public void EndToEndMultilineExec_EscapeSpecialCharacters_DisabledUnderChangeWave16_10()
-        {
-            using (var env = TestEnvironment.Create(_output))
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave16_10.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                var testProject = env.CreateTestProjectWithFiles(@"<Project>
-<Target Name=""ExecCommand"">
-  <Exec Command=""echo Hello, World!"" />
-   </Target>
-</Project>");
-
-                // Ensure path has subfolders
-                var newTempPath = env.CreateNewTempPathWithSubfolder("hello()wo(rld)").TempPath;
-                string tempPath = Path.GetTempPath();
-                Assert.StartsWith(newTempPath, tempPath);
-
-                using (var buildManager = new BuildManager())
-                {
-                    MockLogger logger = new MockLogger(_output, profileEvaluation: false, printEventsToStdout: false);
-
-                    var parameters = new BuildParameters()
-                    {
-                        Loggers = new[] { logger },
-                    };
-
-                    var collection = new ProjectCollection(
-                        new Dictionary<string, string>(),
-                        new[] { logger },
-                        remoteLoggers: null,
-                        ToolsetDefinitionLocations.Default,
-                        maxNodeCount: 1,
-                        onlyLogCriticalEvents: false,
-                        loadProjectsReadOnly: true);
-
-                    var project = collection.LoadProject(testProject.ProjectFile).CreateProjectInstance();
-
-                    var request = new BuildRequestData(
-                        project,
-                        targetsToBuild: new[] { "ExecCommand" },
-                        hostServices: null);
-
-                    var result = buildManager.Build(parameters, request);
-
-                    logger.AssertLogContains("Hello, World!");
-
-                    result.OverallResult.ShouldBe(BuildResultCode.Failure);
-                }
-                ChangeWaves.ResetStateForTests();
-            }
-        }
     }
 
     internal class ExecWrapper : Exec
diff --git a/src/Tasks.UnitTests/FormatUrl_Tests.cs b/src/Tasks.UnitTests/FormatUrl_Tests.cs
new file mode 100644
index 00000000000..0a5b5ca0b96
--- /dev/null
+++ b/src/Tasks.UnitTests/FormatUrl_Tests.cs
@@ -0,0 +1,211 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.IO;
+using Microsoft.Build.Tasks;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.UnitTests
+{
+    sealed public class FormatUrl_Tests
+    {
+        private readonly ITestOutputHelper _out;
+
+        public FormatUrl_Tests(ITestOutputHelper testOutputHelper)
+        {
+            _out = testOutputHelper;
+        }
+
+        /// <summary>
+        /// The URL to format is null.
+        /// </summary>
+        [Fact]
+        public void NullTest()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = null;
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(string.Empty);
+        }
+
+        /// <summary>
+        /// The URL to format is empty.
+        /// </summary>
+        [Fact]
+        public void EmptyTest()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = string.Empty;
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(t.InputUrl);
+        }
+
+        /// <summary>
+        /// No InputUrl value is provided. InputUrl is not a required parameter for the task.
+        /// </summary>
+        [Fact]
+        public void NoInputTest()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(string.Empty);
+        }
+
+        /// <summary>
+        /// The URL to format is white space.
+        /// FormatUrl depends on Path.GetFullPath.
+        /// From the documentation, Path.GetFullPath(" ") should throw an ArgumentException, but it doesn't on macOS and Linux
+        /// where whitespace characters are valid characters for filenames.
+        /// </summary>
+        [Fact]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        public void WhitespaceTestOnUnix()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = " ";
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(new Uri(Path.Combine(Environment.CurrentDirectory, t.InputUrl)).AbsoluteUri);
+        }
+
+        /// <summary>
+        /// The URL to format is white space.
+        /// </summary>
+        [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        public void WhitespaceTestOnWindows()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = " ";
+            Should.Throw<ArgumentException>(() => t.Execute());
+        }
+
+        /// <summary>
+        /// The URL to format is a UNC.
+        /// </summary>
+        [Fact]
+        public void UncPathTest()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = @"\\server\filename.ext";
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(@"file://server/filename.ext");
+        }
+
+        /// <summary>
+        /// The URL to format is a local absolute file path.
+        /// This test uses Environment.CurrentDirectory to have a file path value appropriate to the current OS/filesystem. 
+        /// </summary>
+        [Fact]
+        public void LocalAbsolutePathTest()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = Environment.CurrentDirectory;
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(new Uri(t.InputUrl).AbsoluteUri);
+        }
+
+        /// <summary>
+        /// The URL to format is a local relative file path.
+        /// This test uses Environment.CurrentDirectory to have a file path value appropriate to the current OS/filesystem. 
+        /// </summary>
+        [Fact]
+        public void LocalRelativePathTest()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = @".";
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(new Uri(Environment.CurrentDirectory).AbsoluteUri);
+        }
+
+        /// <summary>
+        /// The URL to format is a *nix-style (macOS, Linux) local absolute file path.
+        /// </summary>
+        [Fact]
+        [PlatformSpecific(TestPlatforms.AnyUnix)]
+        public void LocalUnixAbsolutePathTest()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = @"/usr/local/share";
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(@"file:///usr/local/share");
+        }
+
+        /// <summary>
+        /// The URL to format is a Windows-style local absolute file path.
+        /// </summary>
+        [Fact]
+        [PlatformSpecific(TestPlatforms.Windows)]
+        public void LocalWindowsAbsolutePathTest()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = @"c:\folder\filename.ext";
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(@"file:///c:/folder/filename.ext");
+        }
+
+        /// <summary>
+        /// The URL to format is a URL using localhost.
+        /// </summary>
+        [Fact]
+        public void UrlLocalHostTest()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = @"https://localhost/Example/Path";
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(@"https://" + Environment.MachineName.ToLowerInvariant() + "/Example/Path");
+        }
+
+        /// <summary>
+        /// The URL to format is a URL.
+        /// </summary>
+        [Fact]
+        public void UrlTest()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = @"https://example.com/Example/Path";
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(t.InputUrl);
+        }
+
+        /// <summary>
+        /// The URL to format is a URL with a 'parent' element (..) in the path.
+        /// </summary>
+        [Fact]
+        public void UrlParentPathTest()
+        {
+            var t = new FormatUrl();
+            t.BuildEngine = new MockEngine(_out);
+
+            t.InputUrl = @"https://example.com/Example/../Path";
+            t.Execute().ShouldBeTrue();
+            t.OutputUrl.ShouldBe(@"https://example.com/Path");
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 4bf53a812a9..e0f20bd2eec 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -26,6 +26,7 @@
     <ProjectReference Include="..\Utilities\Microsoft.Build.Utilities.csproj" />
     <ProjectReference Include="..\Xunit.NetCore.Extensions\Xunit.NetCore.Extensions.csproj" />
     <ProjectReference Include="..\Samples\PortableTask\PortableTask.csproj" ReferenceOutputAssembly="false" Private="false" />
+    <ProjectReference Include="..\Samples\Dependency\Dependency.csproj" ReferenceOutputAssembly="false" Private="false" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index a87f30daff6..b703b8c1bbc 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -4,10 +4,18 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Reflection;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.Utilities;
+#if NETFRAMEWORK
+using Microsoft.IO;
+#else
+using System.IO;
+#endif
 using Shouldly;
 using Xunit;
 
@@ -19,6 +27,108 @@ public class RoslynCodeTaskFactory_Tests
     {
         private const string TaskName = "MyInlineTask";
 
+        [Fact]
+        public void InlineTaskWithAssemblyPlatformAgnostic()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = env.CreateFolder(createFolder: true);
+                string location = Assembly.GetExecutingAssembly().Location;
+                TransientTestFile inlineTask = env.CreateFile(folder, "5106.proj", @$"
+<Project>
+
+  <UsingTask TaskName=""MyInlineTask"" TaskFactory=""RoslynCodeTaskFactory"" AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"">
+    <Task>
+      <Reference Include=""" + Path.Combine(Path.GetDirectoryName(location), "..", "..", "..", "Samples", "Dependency",
+#if DEBUG
+      "Debug"
+#else
+      "Release"
+#endif
+      , "net472", "Dependency.dll") + @""" />
+      <Using Namespace=""Dependency"" />
+      <Code Type=""Fragment"" Language=""cs"" >
+<![CDATA[
+Log.LogError(Alpha.GetString());
+]]>
+      </Code>
+    </Task>
+  </UsingTask>
+
+<Target Name=""ToRun"">
+  <MyInlineTask/>
+</Target>
+
+</Project>
+");
+                string output = RunnerUtilities.ExecMSBuild(inlineTask.Path, out bool success);
+                success.ShouldBeTrue(output);
+                output.ShouldContain("Alpha.GetString");
+            }
+        }
+
+        [Fact]
+        [SkipOnPlatform(TestPlatforms.AnyUnix, ".NETFramework 4.0 isn't on unix machines.")]
+        public void InlineTaskWithAssembly()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = env.CreateFolder(createFolder: true);
+                TransientTestFile assemblyProj = env.CreateFile(folder, "5106.csproj", @$"
+                    <Project DefaultTargets=""Build"">
+                        <PropertyGroup>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
+                            <OutputType>Library</OutputType>
+                        </PropertyGroup>
+                        <ItemGroup>
+                            <Reference Include=""System""/>
+                            <Compile Include=""Class1.cs""/>
+                        </ItemGroup>
+                        <Import Project=""$(MSBuildBinPath)\Microsoft.CSharp.targets"" />
+                    </Project>
+");
+                TransientTestFile csFile = env.CreateFile(folder, "Class1.cs", @"
+using System;
+
+namespace _5106 {
+    public class Class1 {
+        public static string ToPrint() {
+            return ""Hello!"";
+        }
+    }
+}
+");
+                string output = RunnerUtilities.ExecMSBuild(assemblyProj.Path + $" /p:OutDir={Path.Combine(folder.Path, "subFolder")} /restore", out bool success);
+                success.ShouldBeTrue(output);
+
+                TransientTestFile inlineTask = env.CreateFile(folder, "5106.proj", @$"
+<Project>
+
+  <UsingTask TaskName=""MyInlineTask"" TaskFactory=""RoslynCodeTaskFactory"" AssemblyFile=""$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll"">
+    <Task>
+      <Reference Include=""{Path.Combine(folder.Path, "subFolder", "5106.dll")}"" />
+      <Reference Include=""netstandard"" />
+      <Using Namespace=""_5106"" />
+      <Code Type=""Fragment"" Language=""cs"" >
+<![CDATA[
+Log.LogError(Class1.ToPrint());
+]]>
+      </Code>
+    </Task>
+  </UsingTask>
+
+<Target Name=""ToRun"">
+  <MyInlineTask/>
+</Target>
+
+</Project>
+");
+                output = RunnerUtilities.ExecMSBuild(inlineTask.Path, out success);
+                success.ShouldBeTrue();
+                output.ShouldContain("Hello!");
+            }
+        }
+
         [Fact]
         public void RoslynCodeTaskFactory_ReuseCompilation()
         {
diff --git a/src/Tasks/AssignTargetPath.cs b/src/Tasks/AssignTargetPath.cs
index 10ede5e6a1a..48079383cd6 100644
--- a/src/Tasks/AssignTargetPath.cs
+++ b/src/Tasks/AssignTargetPath.cs
@@ -77,7 +77,7 @@ public override bool Execute()
 
                     // If TargetPath is already set, it takes priority.
                     // https://github.com/dotnet/msbuild/issues/2795
-                    string targetPath =  ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10) ? Files[i].GetMetadata(ItemMetadataNames.targetPath) : null;
+                    string targetPath = Files[i].GetMetadata(ItemMetadataNames.targetPath);
 
                     // If TargetPath not already set, fall back to default behavior.
                     if (string.IsNullOrEmpty(targetPath))
diff --git a/src/Tasks/CombineTargetFrameworkInfoProperties.cs b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
index 4108feb5246..2db3b55580b 100644
--- a/src/Tasks/CombineTargetFrameworkInfoProperties.cs
+++ b/src/Tasks/CombineTargetFrameworkInfoProperties.cs
@@ -39,7 +39,8 @@ public override bool Execute()
         {
             if (PropertiesAndValues != null)
             {
-                XElement root = UseAttributeForTargetFrameworkInfoPropertyNames ?
+                // When removing the change wave, also remove UseAttributeForTargetFrameworkInfoPropertyNames.
+                XElement root = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) || UseAttributeForTargetFrameworkInfoPropertyNames ?
                     new("TargetFramework", new XAttribute("Name", EscapingUtilities.Escape(RootElementName))) :
                     new(RootElementName);
 
diff --git a/src/Tasks/CreateItem.cs b/src/Tasks/CreateItem.cs
index f386549f525..8f2ef0163ff 100644
--- a/src/Tasks/CreateItem.cs
+++ b/src/Tasks/CreateItem.cs
@@ -61,8 +61,14 @@ public override bool Execute()
             }
 
             // Expand wild cards.
-            Include = ExpandWildcards(Include);
-            Exclude = ExpandWildcards(Exclude);
+            (Include, bool expandedInclude) = TryExpandingWildcards(Include, XMakeAttributes.include);
+            (Exclude, bool expandedExclude) = TryExpandingWildcards(Exclude, XMakeAttributes.exclude);
+
+            // Execution stops if wildcard expansion fails due to drive enumeration and related env var is set.
+            if (!(expandedInclude && expandedExclude))
+            {
+                return false;
+            }
 
             // Simple case:  no additional attribute to add and no Exclude.  In this case the
             // ouptuts are simply the inputs.
@@ -128,14 +134,52 @@ private List<ITaskItem> CreateOutputItems(Dictionary<string, string> metadataTab
             return outputItems;
         }
 
+        /// <summary>
+        /// Attempts to expand wildcards and logs warnings or errors for attempted drive enumeration.
+        /// </summary>
+        private (ITaskItem[] Element, bool NoLoggedErrors) TryExpandingWildcards(ITaskItem[] expand, string attributeType)
+        {
+            const string CreateItemTask = nameof(CreateItem);
+
+            string fileSpec;
+            FileMatcher.SearchAction searchAction;
+
+            (expand, searchAction, fileSpec) = ExpandWildcards(expand);
+
+            // Log potential drive enumeration glob anomalies when applicable.
+            if (searchAction == FileMatcher.SearchAction.LogDriveEnumeratingWildcard)
+            {
+                Log.LogWarningWithCodeFromResources(
+                    "WildcardResultsInDriveEnumeration",
+                    EscapingUtilities.UnescapeAll(fileSpec),
+                    attributeType,
+                    CreateItemTask);
+            }
+            else if (searchAction == FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard)
+            {
+                Log.LogErrorWithCodeFromResources(
+                    "WildcardResultsInDriveEnumeration",
+                    EscapingUtilities.UnescapeAll(fileSpec),
+                    attributeType,
+                    CreateItemTask);
+            }
+
+            return (expand, !Log.HasLoggedErrors);
+        }
+
         /// <summary>
         /// Expand wildcards in the item list.
         /// </summary>
-        private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
+        private static (ITaskItem[] Element, FileMatcher.SearchAction Action, string FileSpec) ExpandWildcards(ITaskItem[] expand)
         {
+            // Used to detect and log drive enumerating wildcard patterns.
+            string[] files;
+            FileMatcher.SearchAction action = FileMatcher.SearchAction.None;
+            string itemSpec = string.Empty;
+
             if (expand == null)
             {
-                return null;
+                return (null, action, itemSpec);
             }
             else
             {
@@ -144,7 +188,13 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
                 {
                     if (FileMatcher.HasWildcards(i.ItemSpec))
                     {
-                        string[] files = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);
+                        (files, action, _) = FileMatcher.Default.GetFiles(null /* use current directory */, i.ItemSpec);
+                        itemSpec = i.ItemSpec;
+                        if (action == FileMatcher.SearchAction.FailOnDriveEnumeratingWildcard)
+                        {
+                            return (expanded.ToArray(), action, itemSpec);
+                        }
+
                         foreach (string file in files)
                         {
                             TaskItem newItem = new TaskItem(i) { ItemSpec = file };
@@ -167,7 +217,7 @@ private static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
                         expanded.Add(i);
                     }
                 }
-                return expanded.ToArray();
+                return (expanded.ToArray(), action, itemSpec);
             }
         }
 
diff --git a/src/Tasks/DownloadFile.cs b/src/Tasks/DownloadFile.cs
index 5192719aa13..c36685242c8 100644
--- a/src/Tasks/DownloadFile.cs
+++ b/src/Tasks/DownloadFile.cs
@@ -60,6 +60,11 @@ public sealed class DownloadFile : TaskExtension, ICancelableTask
         [Required]
         public string SourceUrl { get; set; }
 
+        /// <summary>
+        /// Gets or sets the number of milliseconds to wait before the request times out.
+        /// </summary>
+        public int Timeout { get; set; } = 100_000;
+
         /// <summary>
         /// Gets or sets a <see cref="HttpMessageHandler"/> to use.  This is used by unit tests to mock a connection to a remote server.
         /// </summary>
@@ -137,7 +142,7 @@ private async Task<bool> ExecuteAsync()
         private async Task DownloadAsync(Uri uri, CancellationToken cancellationToken)
         {
             // The main reason to use HttpClient vs WebClient is because we can pass a message handler for unit tests to mock
-            using (var client = new HttpClient(HttpMessageHandler ?? new HttpClientHandler(), disposeHandler: true))
+            using (var client = new HttpClient(HttpMessageHandler ?? new HttpClientHandler(), disposeHandler: true) { Timeout = TimeSpan.FromMilliseconds(Timeout) })
             {
                 // Only get the response without downloading the file so we can determine if the file is already up-to-date
                 using (HttpResponseMessage response = await client.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false))
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index d4773311288..c05a3afb682 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -606,45 +606,31 @@ protected internal override void AddCommandLineCommands(CommandLineBuilderExtens
                     }
                     commandLine.AppendSwitch("/C"); // run then terminate
 
-                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave16_10))
+                    StringBuilder fileName = null;
+
+                    // Escape special characters that need to be escaped.
+                    for (int i = 0; i < batchFileForCommandLine.Length; i++)
                     {
-                        StringBuilder fileName = null;
+                        char c = batchFileForCommandLine[i];
 
-                        // Escape special characters that need to be escaped.
-                        for (int i = 0; i < batchFileForCommandLine.Length; i++)
+                        if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))
                         {
-                            char c = batchFileForCommandLine[i];
-
-                            if (ShouldEscapeCharacter(c) && (i == 0 || batchFileForCommandLine[i - 1] != '^'))
+                            // Avoid allocating a new string until we know we have something to escape.
+                            if (fileName == null)
                             {
-                                // Avoid allocating a new string until we know we have something to escape.
-                                if (fileName == null)
-                                {
-                                    fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);
-                                    fileName.Append(batchFileForCommandLine, 0, i);
-                                }
-
-                                fileName.Append('^');
+                                fileName = StringBuilderCache.Acquire(batchFileForCommandLine.Length);
+                                fileName.Append(batchFileForCommandLine, 0, i);
                             }
 
-                            fileName?.Append(c);
+                            fileName.Append('^');
                         }
 
-                        if (fileName != null)
-                        {
-                            batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);
-                        }
+                        fileName?.Append(c);
                     }
-                    else
+
+                    if (fileName != null)
                     {
-                        // If for some crazy reason the path has a & character and a space in it
-                        // then get the short path of the temp path, which should not have spaces in it
-                        // and then escape the &
-                        if (batchFileForCommandLine.Contains("&") && !batchFileForCommandLine.Contains("^&"))
-                        {
-                            batchFileForCommandLine = NativeMethodsShared.GetShortFilePath(batchFileForCommandLine);
-                            batchFileForCommandLine = batchFileForCommandLine.Replace("&", "^&");
-                        }
+                        batchFileForCommandLine = StringBuilderCache.GetStringAndRelease(fileName);
                     }
                 }
 
diff --git a/src/Tasks/FormatUrl.cs b/src/Tasks/FormatUrl.cs
index 4b600c49ef9..d6d344db19e 100644
--- a/src/Tasks/FormatUrl.cs
+++ b/src/Tasks/FormatUrl.cs
@@ -1,11 +1,9 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-#if !RUNTIME_TYPE_NETCORE
 using System;
-using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
-#endif
 using Microsoft.Build.Framework;
+using Microsoft.Build.Tasks.Deployment.ManifestUtilities;
 
 #nullable disable
 
@@ -23,13 +21,8 @@ public sealed class FormatUrl : TaskExtension
 
         public override bool Execute()
         {
-#if RUNTIME_TYPE_NETCORE
-            Log.LogErrorFromResources("TaskRequiresFrameworkFailure", nameof(FormatUrl));
-            return false;
-#else
             OutputUrl = InputUrl != null ? PathUtil.Format(InputUrl) : String.Empty;
             return true;
-#endif
         }
     }
 }
diff --git a/src/Tasks/LC.cs b/src/Tasks/LC.cs
index c12aa042a2c..d219536f01d 100644
--- a/src/Tasks/LC.cs
+++ b/src/Tasks/LC.cs
@@ -101,7 +101,7 @@ public string SdkToolsPath
         /// </remarks>
         public override bool Execute()
         {
-            Log.LogErrorFromResources("TaskRequiresFrameworkFailure", nameof(LC));
+            Log.LogErrorWithCodeFromResources("TaskRequiresFrameworkFailure", nameof(LC));
             return false;
         }
 #endif
diff --git a/src/Tasks/ManifestUtil/PathUtil.cs b/src/Tasks/ManifestUtil/PathUtil.cs
index e87d1a84d0b..a9136b0f290 100644
--- a/src/Tasks/ManifestUtil/PathUtil.cs
+++ b/src/Tasks/ManifestUtil/PathUtil.cs
@@ -140,7 +140,7 @@ public static string Resolve(string path)
                 var u = new Uri(path);
                 if (String.Equals(u.Host, localHost, StringComparison.OrdinalIgnoreCase))
                 {
-                    // Unfortunatly Uri.Host is read-only, so we need to reconstruct it manually...
+                    // Unfortunately Uri.Host is read-only, so we need to reconstruct it manually...
                     int i = path.IndexOf(localHost, StringComparison.OrdinalIgnoreCase);
                     return i >= 0 ? path.Substring(0, i) + Environment.MachineName.ToLowerInvariant() + path.Substring(i + localHost.Length) : path;
                 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index d85daf277ed..e8e3b69f527 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -191,6 +191,12 @@
     <Compile Include="..\Shared\LanguageParser\VisualBasictokenizer.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Shared\XMakeAttributes.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
+    <Compile Include="..\Shared\XMakeElements.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="AppConfig\*.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -970,7 +976,7 @@
   </ItemGroup>
 
   <!-- Mimics AddRefAssemblies from MSBuild.csproj -->
-  <Target Name="AddRefAssemblies" 
+  <Target Name="AddRefAssemblies"
           DependsOnTargets="ResolveAssemblyReferences"
           BeforeTargets="AssignTargetPaths">
     <ItemGroup>
@@ -993,6 +999,10 @@
     <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\net472\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
 
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
+    <PackageReference Include="Microsoft.Win32.Registry" />
+  </ItemGroup>
+
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <PackageReference Include="System.CodeDom" />
     <PackageReference Include="System.Reflection.Metadata" />
@@ -1001,9 +1011,6 @@
     <PackageReference Include="System.Security.Permissions" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
 
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-
     <Content Include="$(NuGetPackageRoot)microsoft.net.compilers.toolset\$(MicrosoftNetCompilersToolsetVersion)\tasks\net6.0\**\*" CopyToOutputDirectory="PreserveNewest" LinkBase="Roslyn" />
   </ItemGroup>
 
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 12228153f6d..3410e8d85b4 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -648,6 +648,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <PropertyGroup>
     <MSBuildWarningsAsMessages Condition="'$(MSBuildWarningsAsMessages)'==''">$(NoWarn)</MSBuildWarningsAsMessages>
     <MSBuildWarningsAsErrors Condition="'$(MSBuildWarningsAsErrors)'==''">$(WarningsAsErrors)</MSBuildWarningsAsErrors>
+    <MSBuildWarningsNotAsErrors Condition="'$(MSBuildWarningsNotAsErrors)'==''">$(WarningsNotAsErrors)</MSBuildWarningsNotAsErrors>
   </PropertyGroup>
 
   <!-- Common Project System support -->
@@ -1905,14 +1906,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       </_AdditionalTargetFrameworkInfoPropertyWithValue>
     </ItemGroup>
 
-    <PropertyGroup>
-      <_UseAttributeForTargetFrameworkInfoPropertyNames Condition="'$(_UseAttributeForTargetFrameworkInfoPropertyNames)' == ''">false</_UseAttributeForTargetFrameworkInfoPropertyNames>
-    </PropertyGroup>
-
     <CombineTargetFrameworkInfoProperties
         RootElementName="$(TargetFramework)"
-        PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)"
-        UseAttributeForTargetFrameworkInfoPropertyNames="$(_UseAttributeForTargetFrameworkInfoPropertyNames)">
+        PropertiesAndValues="@(_AdditionalTargetFrameworkInfoPropertyWithValue)">
       <Output TaskParameter="Result"
               PropertyName="_AdditionalTargetFrameworkInfoProperties"/>
     </CombineTargetFrameworkInfoProperties>
diff --git a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
index 2caf4326b7a..f08677fe9b8 100644
--- a/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
+++ b/src/Tasks/Microsoft.NETFramework.CurrentVersion.props
@@ -114,6 +114,10 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <ImplicitlyExpandDesignTimeFacades Condition="'$(ImplicitlyExpandDesignTimeFacades)' == '' and ('$(TargetFrameworkIdentifier)' == '.NETFramework' and '$(TargetingClr2Framework)' != 'true' and '$(TargetFrameworkVersion)' != 'v4.0')">true</ImplicitlyExpandDesignTimeFacades>
   </PropertyGroup>
 
+  <PropertyGroup>
+    <AvailablePlatforms Condition="!$(AvailablePlatforms.Contains('ARM64')) and '$(TargetFrameworkIdentifier)' == '.NETFramework' and $([MSBuild]::VersionGreaterThanOrEquals($(TargetFrameworkVersion), '4.0'))">$(AvailablePlatforms),ARM64</AvailablePlatforms>
+  </PropertyGroup>
+
   <!--Import props that are common for both full framework and core.
     And before the ImportAfter\* , so users can override it-->
   <Import Project="$(MSBuildToolsPath)\Microsoft.NET.props" />
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
index 85f6da6f74e..1cc4f59b5e8 100644
--- a/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
+++ b/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
@@ -884,6 +884,8 @@ Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.get -> bool
 Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.set -> void
 Microsoft.Build.Tasks.DownloadFile.SourceUrl.get -> string
 Microsoft.Build.Tasks.DownloadFile.SourceUrl.set -> void
+Microsoft.Build.Tasks.DownloadFile.Timeout.get -> int
+Microsoft.Build.Tasks.DownloadFile.Timeout.set -> void
 Microsoft.Build.Tasks.Error
 Microsoft.Build.Tasks.Error.Code.get -> string
 Microsoft.Build.Tasks.Error.Code.set -> void
@@ -1956,6 +1958,8 @@ Microsoft.Build.Tasks.SGen.UseProxyTypes.set -> void
 Microsoft.Build.Tasks.SignFile
 Microsoft.Build.Tasks.SignFile.CertificateThumbprint.get -> string
 Microsoft.Build.Tasks.SignFile.CertificateThumbprint.set -> void
+Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
+Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
 Microsoft.Build.Tasks.SignFile.SignFile() -> void
 Microsoft.Build.Tasks.SignFile.SigningTarget.get -> Microsoft.Build.Framework.ITaskItem
 Microsoft.Build.Tasks.SignFile.SigningTarget.set -> void
@@ -2313,8 +2317,10 @@ override Microsoft.Build.Tasks.FindInvalidProjectReferences.Execute() -> bool
 override Microsoft.Build.Tasks.FindUnderPath.Execute() -> bool
 override Microsoft.Build.Tasks.FormatUrl.Execute() -> bool
 override Microsoft.Build.Tasks.FormatVersion.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateBindingRedirects.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateBootstrapper.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateLauncher.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateManifestBase.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateResource.Execute() -> bool
@@ -2409,6 +2415,7 @@ static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.Sign
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.XmlToPermissionSet(System.Xml.XmlElement element) -> System.Security.PermissionSet
 System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
index 5f9ec5dc2a5..e69de29bb2d 100644
--- a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -1,5 +0,0 @@
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
-override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
index 092772496e2..8f3cbf42ee6 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -783,6 +783,8 @@ Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.get -> bool
 Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.set -> void
 Microsoft.Build.Tasks.DownloadFile.SourceUrl.get -> string
 Microsoft.Build.Tasks.DownloadFile.SourceUrl.set -> void
+Microsoft.Build.Tasks.DownloadFile.Timeout.get -> int
+Microsoft.Build.Tasks.DownloadFile.Timeout.set -> void
 Microsoft.Build.Tasks.Error
 Microsoft.Build.Tasks.Error.Code.get -> string
 Microsoft.Build.Tasks.Error.Code.set -> void
@@ -1642,6 +1644,8 @@ Microsoft.Build.Tasks.SGen.UseProxyTypes.set -> void
 Microsoft.Build.Tasks.SignFile
 Microsoft.Build.Tasks.SignFile.CertificateThumbprint.get -> string
 Microsoft.Build.Tasks.SignFile.CertificateThumbprint.set -> void
+Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
+Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
 Microsoft.Build.Tasks.SignFile.SignFile() -> void
 Microsoft.Build.Tasks.SignFile.SigningTarget.get -> Microsoft.Build.Framework.ITaskItem
 Microsoft.Build.Tasks.SignFile.SigningTarget.set -> void
@@ -1848,7 +1852,9 @@ override Microsoft.Build.Tasks.FindInvalidProjectReferences.Execute() -> bool
 override Microsoft.Build.Tasks.FindUnderPath.Execute() -> bool
 override Microsoft.Build.Tasks.FormatUrl.Execute() -> bool
 override Microsoft.Build.Tasks.FormatVersion.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateBindingRedirects.Execute() -> bool
+override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateLauncher.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateManifestBase.Execute() -> bool
 override Microsoft.Build.Tasks.GenerateResource.Execute() -> bool
@@ -1914,6 +1920,7 @@ static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.Sign
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) -> void
+static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
 static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) -> void
 System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription
 System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.RSAPKCS1SHA256SignatureDescription() -> void
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index 5f9ec5dc2a5..e69de29bb2d 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,5 +0,0 @@
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
-override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 911d84afb0b..c39a2eb609b 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -187,7 +187,7 @@ public sealed partial class ResolveComReference : Microsoft.Build.Tasks.TaskExte
         /// <returns></returns>
         public override bool Execute()
         {
-            Log.LogErrorFromResources("TaskRequiresFrameworkFailure", nameof(ResolveComReference));
+            Log.LogErrorWithCodeFromResources("TaskRequiresFrameworkFailure", nameof(ResolveComReference));
             return false;
         }
 
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 632d5d42323..67a661cae66 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: Úloha {0} se podporuje pouze při sestavování v systému Windows.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 81c057f5e8e..85c2e0e3410 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: Die Aufgabe „{0}“ wird nur beim Erstellen unter Windows unterstützt.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index e270e6039eb..6edbd27b1be 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: La tarea “{0}” solo se admite cuando se compila en Windows.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 401d40dffdb..30e7409e31e 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: La tâche "{0}" n’est prise en charge que lors de la génération sur Windows.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 40a44c86be9..545b88ce4d0 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: l'attività "{0}" è supportata solo durante la compilazione in Windows.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 2fa257164bb..e68abe95648 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: タスク "{0}" は、Windows 上でビルドする場合にのみサポートされます。</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index ee1ea74d0d1..bc955da3f74 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: 작업 "{0}"은(는) Windows에서 빌드할 때만 지원됩니다.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
@@ -1146,7 +1146,7 @@
       </trans-unit>
       <trans-unit id="GenerateResource.InvalidHexEscapeValue">
         <source>MSB3569: Invalid hex value after '\u' in resource "{0}", value '{1}'.</source>
-        <target state="translated">MSB3569: "{0}" 리소스에서 '\u' 뒤의 16진수가 잘못되었습니다. '{1}' 값</target>
+        <target state="translated">MSB3569: 리소스 "{0}", 값 '{1}'에서 '\u' 뒤의 16진수 값이 잘못되었습니다.</target>
         <note>{StrBegin="MSB3569: "}</note>
       </trans-unit>
       <trans-unit id="GenerateResource.CannotWriteSTRFile">
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index bb801b70a60..4da67b53fb2 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: zadanie „{0}“ jest obsługiwane tylko podczas kompilowania w systemie Windows.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 47364541ad1..a8b323131f8 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: A tarefa "{0}" só é suportada quando compilada no Windows.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 74137408038..a4082b93a2b 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: задача "{0}" поддерживается только при сборке в Windows.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 0ed6814b589..4e6febbd0f6 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: "{0}" görevi yalnızca Windows üzerinde derlendiğinde desteklenir.</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index ac772ecf0bf..f979f200cfb 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: 仅在 Windows 上生成时才支持任务 "{0}"。</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 3ba672a7452..659ab09c3bf 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -516,7 +516,7 @@
       </trans-unit>
       <trans-unit id="General.TaskRequiresWindows">
         <source>MSB3096: Task "{0}" is only supported when building on Windows.</source>
-        <target state="new">MSB3096: Task "{0}" is only supported when building on Windows.</target>
+        <target state="translated">MSB3096: 只有在 Windows 上建置時，才支援工作 "{0}"。</target>
         <note>{StrBegin="MSB3096: "}</note>
       </trans-unit>
       <trans-unit id="General.UndefineProperties">
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 5feeb67170f..004d2f8067d 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -102,6 +102,11 @@ public sealed class RoslynCodeTaskFactory : ITaskFactory
         /// </summary>
         private TaskLoggingHelper _log;
 
+        /// <summary>
+        /// Stores functions that were added to the current app domain. Should be removed once we're finished.
+        /// </summary>
+        private ResolveEventHandler handlerAddedToAppDomain = null;
+
         /// <summary>
         /// Stores the parameters parsed in the &lt;UsingTask /&gt;.
         /// </summary>
@@ -123,6 +128,10 @@ public sealed class RoslynCodeTaskFactory : ITaskFactory
         /// <inheritdoc cref="ITaskFactory.CleanupTask(ITask)"/>
         public void CleanupTask(ITask task)
         {
+            if (handlerAddedToAppDomain is not null)
+            {
+                AppDomain.CurrentDomain.AssemblyResolve -= handlerAddedToAppDomain;
+            }
         }
 
         /// <inheritdoc cref="ITaskFactory.CreateTask(IBuildEngine)"/>
@@ -515,7 +524,7 @@ internal static bool TryLoadTaskBody(TaskLoggingHelper log, string taskName, str
         /// Perhaps in the future this could be more powerful by using NuGet to resolve assemblies but we think
         /// that is too complicated for a simple in-line task.  If users have more complex requirements, they
         /// can compile their own task library.</remarks>
-        internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynCodeTaskFactoryTaskInfo taskInfo, out ITaskItem[] items)
+        internal bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynCodeTaskFactoryTaskInfo taskInfo, out ITaskItem[] items)
         {
             // Store the list of resolved assemblies because a user can specify a short name or a full path
             ISet<string> resolvedAssemblyReferences = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
@@ -532,6 +541,8 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC
                 references = references.Union(DefaultReferences[taskInfo.CodeLanguage]);
             }
 
+            List<string> directoriesToAddToAppDomain = new();
+
             // Loop through the user specified references as well as the default references
             foreach (string reference in references)
             {
@@ -539,7 +550,9 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC
                 if (FileSystems.Default.FileExists(reference))
                 {
                     // The path could be relative like ..\Assembly.dll so we need to get the full path
-                    resolvedAssemblyReferences.Add(Path.GetFullPath(reference));
+                    string fullPath = Path.GetFullPath(reference);
+                    directoriesToAddToAppDomain.Add(Path.GetDirectoryName(fullPath));
+                    resolvedAssemblyReferences.Add(fullPath);
                     continue;
                 }
 
@@ -572,7 +585,34 @@ internal static bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynC
             // Transform the list of resolved assemblies to TaskItems if they were all resolved
             items = hasInvalidReference ? null : resolvedAssemblyReferences.Select(i => (ITaskItem)new TaskItem(i)).ToArray();
 
+            handlerAddedToAppDomain = (_, eventArgs) => TryLoadAssembly(directoriesToAddToAppDomain, new AssemblyName(eventArgs.Name));
+            AppDomain.CurrentDomain.AssemblyResolve += handlerAddedToAppDomain;
+
             return !hasInvalidReference;
+
+            static Assembly TryLoadAssembly(List<string> directories, AssemblyName name)
+            {
+                foreach (string directory in directories)
+                {
+                    string path;
+                    if (!string.IsNullOrEmpty(name.CultureName))
+                    {
+                        path = Path.Combine(directory, name.CultureName, name.Name + ".dll");
+                        if (File.Exists(path))
+                        {
+                            return Assembly.LoadFrom(path);
+                        }
+                    }
+
+                    path = Path.Combine(directory, name.Name + ".dll");
+                    if (File.Exists(path))
+                    {
+                        return Assembly.LoadFrom(path);
+                    }
+                }
+
+                return null;
+            }
         }
 
         private static CodeMemberProperty CreateProperty(CodeTypeDeclaration codeTypeDeclaration, string name, Type type, object defaultValue = null)
diff --git a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
index 9221c73a0e0..438cb91ff75 100644
--- a/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
+++ b/src/UnitTests.Shared/Microsoft.Build.UnitTests.Shared.csproj
@@ -25,10 +25,6 @@
     <Reference Include="System.Core" />
     <Reference Include="System.Xml" />
   </ItemGroup>
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-  </ItemGroup>
   <ItemGroup>
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
diff --git a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
index 01cfda5a33f..a9b45f36e8b 100644
--- a/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
+++ b/src/Utilities.UnitTests/CommandLineBuilder_Tests.cs
@@ -2,7 +2,9 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Globalization;
 using System.IO;
+using System.Threading;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using Shouldly;
@@ -54,6 +56,24 @@ public void AppendSwitchWithSpacesInParameter()
             c.ShouldBe("/animal:\"dog and pony\"");
         }
 
+        [Fact]
+        public void AppendSwitchWithIShouldNotNeedQuotingInTurkishLocale()
+        {
+            var currentCulture = Thread.CurrentThread.CurrentCulture;
+            try
+            {
+                Thread.CurrentThread.CurrentCulture = new CultureInfo("tr-TR"); // Turkish
+
+                CommandLineBuilder c = new CommandLineBuilder();
+                c.AppendSwitchIfNotNull("/i:", "iI");
+                c.ShouldBe("/i:iI");
+            }
+            finally
+            {
+                Thread.CurrentThread.CurrentCulture = currentCulture;
+            }
+        }
+
         /// <summary>
         /// Test for AppendSwitchIfNotNull for the ITaskItem version
         /// </summary>
diff --git a/src/Utilities/CommandLineBuilder.cs b/src/Utilities/CommandLineBuilder.cs
index 4f4cb1ab3bd..6baa7da046b 100644
--- a/src/Utilities/CommandLineBuilder.cs
+++ b/src/Utilities/CommandLineBuilder.cs
@@ -156,13 +156,13 @@ public CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparat
         /// Use a private property so that we can lazy initialize the regex
         /// </summary>
         private Regex DefinitelyNeedQuotes => _definitelyNeedQuotes
-            ?? (_definitelyNeedQuotes = new Regex(_quoteHyphens ? s_definitelyNeedQuotesRegexWithHyphen : s_definitelyNeedQuotesRegexNoHyphen, RegexOptions.None));
+            ?? (_definitelyNeedQuotes = new Regex(_quoteHyphens ? s_definitelyNeedQuotesRegexWithHyphen : s_definitelyNeedQuotesRegexNoHyphen, RegexOptions.CultureInvariant));
 
         /// <summary>
         /// Use a private getter property to we can lazy initialize the regex
         /// </summary>
         private Regex AllowedUnquoted => _allowedUnquoted
-            ?? (_allowedUnquoted = new Regex(_quoteHyphens ? s_allowedUnquotedRegexNoHyphen : s_allowedUnquotedRegexWithHyphen, RegexOptions.IgnoreCase));
+            ?? (_allowedUnquoted = new Regex(_quoteHyphens ? s_allowedUnquotedRegexNoHyphen : s_allowedUnquotedRegexWithHyphen, RegexOptions.IgnoreCase | RegexOptions.CultureInvariant));
 
         /// <summary>
         /// Checks the given switch parameter to see if it must/can be quoted.
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 5e5bcafb605..b71362f540d 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -35,11 +35,6 @@
     <PackageReference Include="System.Text.Encoding.CodePages" />
   </ItemGroup>
 
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
-    <!-- Need Win32 API on .NET Core to ping registry to determine long path support -->
-    <PackageReference Include="Microsoft.Win32.Registry" />
-  </ItemGroup>
-
   <ItemGroup Label="Shared Code">
     <Compile Include="..\Shared\AssemblyFolders\AssemblyFoldersEx.cs">
       <Link>Shared\AssemblyFolders\AssemblyFoldersEx.cs</Link>
diff --git a/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt b/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
index e85d5954bfd..0c8ceeed580 100644
--- a/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
+++ b/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
@@ -136,9 +136,11 @@ Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Current = 0 -> Microsoft.B
 Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.Managed32Bit = 3 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.Managed64Bit = 4 -> Microsoft.Build.Utilities.ExecutableType
+Microsoft.Build.Utilities.ExecutableType.ManagedARM64 = 7 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.ManagedIL = 2 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.Native32Bit = 0 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.Native64Bit = 1 -> Microsoft.Build.Utilities.ExecutableType
+Microsoft.Build.Utilities.ExecutableType.NativeARM64 = 6 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.ExecutableType.SameAsCurrentProcess = 5 -> Microsoft.Build.Utilities.ExecutableType
 Microsoft.Build.Utilities.FileTracker
 Microsoft.Build.Utilities.FlatTrackingData
diff --git a/src/Utilities/Resources/Strings.resx b/src/Utilities/Resources/Strings.resx
index 844caf29c0f..452897f1deb 100644
--- a/src/Utilities/Resources/Strings.resx
+++ b/src/Utilities/Resources/Strings.resx
@@ -287,11 +287,14 @@
   <data name="MuxLogger_BuildFinishedSuccess">
     <value xml:space="preserve">Build succeeded.</value>
   </data>
-
+  <data name="DebugPathTooLong" Visibility="Public">
+    <value>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</value>
+    <comment>{StrBegin="MSB6012: "}</comment>
+  </data>
   <!--
         The Utilities message bucket is: MSB6001 - MSB6200
 
-        Next message code should be MSB6012
+        Next message code should be MSB6013
 
         Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
             <none>
diff --git a/src/Utilities/Resources/xlf/Strings.cs.xlf b/src/Utilities/Resources/xlf/Strings.cs.xlf
index 360283f57db..a8bfb9f8d72 100644
--- a/src/Utilities/Resources/xlf/Strings.cs.xlf
+++ b/src/Utilities/Resources/xlf/Strings.cs.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="cs" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: Cesta „{0}“ použitá pro protokoly ladění je příliš dlouhá. Nastavte ji na kratší hodnotu pomocí proměnné prostředí MSBUILDDEBUGPATH nebo změňte konfigurace vašeho systému, aby povolovala dlouhé cesty.</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: Přepínač příkazového řádku pro {0} je neplatný. {1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.de.xlf b/src/Utilities/Resources/xlf/Strings.de.xlf
index 41f19b468c6..df6e3dfda00 100644
--- a/src/Utilities/Resources/xlf/Strings.de.xlf
+++ b/src/Utilities/Resources/xlf/Strings.de.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="de" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: Der für Debugprotokolle verwendete Pfad "{0}" ist zu lang. Legen Sie den Wert mithilfe der Umgebungsvariablen MSBUILDDEBUGPATH auf einen kürzeren Wert fest, oder ändern Sie die Systemkonfiguration so, dass lange Pfade zulässig sind.</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: Ungültige Befehlszeilenoption für "{0}". {1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.es.xlf b/src/Utilities/Resources/xlf/Strings.es.xlf
index 336a4bf92f9..71a0cc32f88 100644
--- a/src/Utilities/Resources/xlf/Strings.es.xlf
+++ b/src/Utilities/Resources/xlf/Strings.es.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="es" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: La ruta de acceso "{0}" usada para los registros de depuración es demasiado larga. Establézcalo en un valor más corto con la variable de entorno MSBUILDDEBUGPATH o cambie la configuración del sistema para permitir rutas de acceso largas.</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: Modificador de línea de comandos no válido para "{0}". {1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.fr.xlf b/src/Utilities/Resources/xlf/Strings.fr.xlf
index 28e1d87d3d2..2924d87cb1a 100644
--- a/src/Utilities/Resources/xlf/Strings.fr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.fr.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="fr" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: Le chemin d’accès "{0}" utilisé pour les journaux de débogage est trop long. Définissez-la sur une valeur plus courte à l’aide de la variable d’environnement MSBUILDDEBUGPATH ou modifiez votre configuration système pour autoriser les chemins longs.</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: Commutateur de ligne de commande non valide pour "{0}". {1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.it.xlf b/src/Utilities/Resources/xlf/Strings.it.xlf
index e9a5e77d267..ea4e723c61a 100644
--- a/src/Utilities/Resources/xlf/Strings.it.xlf
+++ b/src/Utilities/Resources/xlf/Strings.it.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="it" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: il percorso "{0}" usato per i log di debug è troppo lungo. Impostarlo su un valore più breve usando la variabile dell'ambiente MSBUILDDEBUGPATH o modificare la configurazione del sistema per consentire percorsi lunghi.</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: opzione della riga di comando non valida per "{0}". {1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ja.xlf b/src/Utilities/Resources/xlf/Strings.ja.xlf
index 2a40fcbc8a8..77b2163cf7a 100644
--- a/src/Utilities/Resources/xlf/Strings.ja.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ja.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ja" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: デバッグ ログに使用されるパス "{0}" が長すぎます。MSBUILDDEBUGPATH 環境変数を使用して短い値に設定するか、長いパスを許可するようにシステム構成を変更してください。</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: "{0}" のコマンド ライン スイッチが無効です。{1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ko.xlf b/src/Utilities/Resources/xlf/Strings.ko.xlf
index bf7f4d789a2..937d12bd39a 100644
--- a/src/Utilities/Resources/xlf/Strings.ko.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ko.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ko" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: 디버그 로그에 사용된 경로 "{0}"이(가) 너무 깁니다. MSBUILDDEBUGPATH 환경 변수를 사용하여 값을 더 짧게 설정하거나 긴 경로를 허용하도록 시스템 구성을 변경합니다.</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: "{0}"의 명령줄 스위치가 잘못되었습니다. {1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pl.xlf b/src/Utilities/Resources/xlf/Strings.pl.xlf
index 2189f7d3a20..9cb15be1f03 100644
--- a/src/Utilities/Resources/xlf/Strings.pl.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pl.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pl" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: Ścieżka „{0}” używana w dziennikach debugowania jest za długa. Ustaw ją na krótszą wartość przy użyciu zmiennej środowiskowej MSBUILDEBUGPATH lub zmień konfigurację systemu, aby zezwolić na długie ścieżki.</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: Nieprawidłowy przełącznik wiersza polecenia dla „{0}”. {1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
index b54d2b7acf6..19e23f9ecdd 100644
--- a/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Utilities/Resources/xlf/Strings.pt-BR.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="pt-BR" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: O caminho "{0}" usado para logs de depuração é muito longo. Defina-o para um valor mais curto usando a variável de ambiente MSBUILDDEBUGPATH ou altere a configuração do sistema para permitir caminhos longos.</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: Opção de linha de comando inválida para "{0}". {1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.ru.xlf b/src/Utilities/Resources/xlf/Strings.ru.xlf
index 368b83f2540..c11d3a50afd 100644
--- a/src/Utilities/Resources/xlf/Strings.ru.xlf
+++ b/src/Utilities/Resources/xlf/Strings.ru.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="ru" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: слишком длинный путь "{0}" для журналов отладки. Установите более короткое значение, используя переменную среду MSBUILDDEBUGPATH, или измените конфигурацию системы, чтобы разрешить длинные пути.</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: Недопустимый переключатель командной строки для "{0}". {1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.tr.xlf b/src/Utilities/Resources/xlf/Strings.tr.xlf
index 44ffff6ac3e..faf2fbb9512 100644
--- a/src/Utilities/Resources/xlf/Strings.tr.xlf
+++ b/src/Utilities/Resources/xlf/Strings.tr.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="tr" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: Hata ayıklama günlükleri için kullanılan "{0}" yolu çok uzun. MSBUILDDEBUGPATH ortam değişkenini kullanarak yolu daha kısa bir değere ayarlayın veya sistem yapılandırmanızı uzun yollara izin verecek şekilde değiştirin.</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: "{0}" için geçersiz komut satırı anahtarı. {1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
index b9816891b01..65e9de502ba 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hans.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hans" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: 用于调试日志的路径"{0}"太长。使用 MSBUILDDEBUGPATH 环境变量将其设置为较短值，或更改系统配置以允许长路径。</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: “{0}”的命令行开关无效。{1}</target>
diff --git a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
index 3feb3149cf9..6d773c29ed9 100644
--- a/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Utilities/Resources/xlf/Strings.zh-Hant.xlf
@@ -2,6 +2,11 @@
 <xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
   <file datatype="xml" source-language="en" target-language="zh-Hant" original="../Strings.resx">
     <body>
+      <trans-unit id="DebugPathTooLong">
+        <source>MSB6012: The path "{0}" used for debug logs is too long. Set it to a shorter value using the MSBUILDDEBUGPATH environment variable or change your system configuration to allow long paths.</source>
+        <target state="translated">MSB6012: 用於偵錯記錄檔 "{0}" 的路徑太長。使用 MSBUILDDEBUGPATH 環境變數將它設定為較短的值，或變更您的系統設定以允許長路徑。</target>
+        <note>{StrBegin="MSB6012: "}</note>
+      </trans-unit>
       <trans-unit id="General.InvalidToolSwitch">
         <source>MSB6001: Invalid command line switch for "{0}". {1}</source>
         <target state="translated">MSB6001: "{0}" 的命令列參數無效。{1}</target>
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index b3c775b9642..7eb6306f4a1 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -20,39 +20,49 @@
 namespace Microsoft.Build.Utilities
 {
     /// <summary>
-    /// Enumeration to express the type of executable being wrapped by Tracker.exe
+    /// Enumeration to express the type of executable being wrapped by Tracker.exe.
     /// </summary>
     public enum ExecutableType
     {
         /// <summary>
-        /// 32-bit native executable
+        /// 32-bit native executable.
         /// </summary>
         Native32Bit = 0,
 
         /// <summary>
-        /// 64-bit native executable 
+        /// 64-bit native executable.
         /// </summary>
         Native64Bit = 1,
 
         /// <summary>
-        /// A managed executable without a specified bitness
+        /// A managed executable without a specified bitness.
         /// </summary>
         ManagedIL = 2,
 
         /// <summary>
-        /// A managed executable specifically marked as 32-bit
+        /// A managed executable specifically marked as 32-bit.
         /// </summary>
         Managed32Bit = 3,
 
         /// <summary>
-        /// A managed executable specifically marked as 64-bit
+        /// A managed executable specifically marked as 64-bit.
         /// </summary>
         Managed64Bit = 4,
 
         /// <summary>
         /// Use the same bitness as the currently running executable. 
         /// </summary>
-        SameAsCurrentProcess = 5
+        SameAsCurrentProcess = 5,
+
+        /// <summary>
+        /// 64-bit native ARM64 executable.
+        /// </summary>
+        NativeARM64 = 6,
+
+        /// <summary>
+        /// 64-bit managed ARM64 executable.
+        /// </summary>
+        ManagedARM64 = 7
     }
 
     /// <summary>
diff --git a/src/Utilities/TrackedDependencies/TrackedDependencies.cs b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
index de261ee538e..ccc53acd3ae 100644
--- a/src/Utilities/TrackedDependencies/TrackedDependencies.cs
+++ b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
@@ -48,7 +48,7 @@ public static ITaskItem[] ExpandWildcards(ITaskItem[] expand)
                     }
                     else
                     {
-                        files = FileMatcher.Default.GetFiles(null, item.ItemSpec);
+                        files = FileMatcher.Default.GetFiles(null, item.ItemSpec).FileList;
                     }
 
                     foreach (string file in files)
