diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 00000000000..2909e3ff6cd
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,80 @@
+{
+    // See https://go.microsoft.com/fwlink/?LinkId=733558
+    // for the documentation about the tasks.json format
+    "version": "2.0.0",
+    "tasks": [
+        {
+            "label": "dotnet msbuild MSBuild.Dev.slnf",
+            "command": "dotnet",
+            "type": "process",
+            "args": [
+                "msbuild",
+                // Ask MSBuild to generate full paths for file names.
+                "/property:GenerateFullPaths=true",
+                // Do not generate summary otherwise it leads to duplicate errors in Problems panel
+                "/consoleloggerparameters:NoSummary",
+                "${workspaceFolder}/MSBuild.Dev.slnf"
+            ],
+            "group": "build",
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        },
+        {
+            "label": "full build",
+            "command": "${workspaceFolder}/build.sh",
+            "type": "shell",
+            "windows": {
+                "command": "cmd.exe",
+                "type": "process",
+                "args": [
+                    "/d",
+                    "/c",
+                    "${workspaceFolder}/build.cmd"
+                ]
+            },
+            "args": [
+                "-bl",
+                "/property:CreateBootstrap=true",
+                "/property:GenerateFullPaths=true",
+                "/consoleloggerparameters:NoSummary"
+            ],
+            "group": "build",
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        },
+        {
+            "label": "build -test",
+            "command": "${workspaceFolder}/build.sh",
+            "type": "shell",
+            "windows": {
+                "command": "cmd.exe",
+                "type": "process",
+                "args": [
+                    "/d",
+                    "/c",
+                    "${workspaceFolder}/build.cmd"
+                ]
+            },
+            "args": [
+                "-test",
+                "/property:GenerateFullPaths=true",
+                "/consoleloggerparameters:NoSummary"
+            ],
+            "group": {
+                "kind": "test",
+                "isDefault": true
+            },
+            "presentation": {
+                "reveal": "always",
+                "revealProblems": "onProblem"
+            },
+            "problemMatcher": "$msCompile"
+        }
+    ]
+}
diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index bbbf0897830..3d9fff4f089 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -7,7 +7,7 @@ jobs:
 - job: BootstrapMSBuildOnFullFrameworkWindows
   displayName: "Windows Full"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild_bootstrapped_msbuild.cmd
@@ -53,7 +53,7 @@ jobs:
 - job: BootstrapMSBuildOnCoreWindows
   displayName: "Windows Core"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild_bootstrapped_msbuild.cmd
@@ -100,7 +100,7 @@ jobs:
 - job: FullReleaseOnWindows
   displayName: "Windows Full Release (no bootstrap)"
   pool:
-    vmImage: 'windows-2019'
+    vmImage: 'windows-2022'
   steps:
   - task: BatchScript@1
     displayName: cibuild.cmd
@@ -197,7 +197,7 @@ jobs:
 - job: CoreOnMac
   displayName: "macOS Core"
   pool:
-    vmImage: 'macOS-10.14'
+    vmImage: 'macOS-latest'
   steps:
   - bash: . 'eng/cibuild_bootstrapped_msbuild.sh'
     displayName: CI Build
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 415fa36b412..c6ed508dfc8 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -52,7 +52,7 @@ stages:
 
   - job: Windows_NT
     pool:
-      name: VSEngSS-MicroBuild2019-1ES
+      name: VSEngSS-MicroBuild2022-1ES
       demands:
       - agent.os -equals Windows_NT
 
@@ -90,14 +90,14 @@ stages:
         signType: $(SignType)
         zipSources: false
       condition: and(succeeded(), in(variables['SignType'], 'test', 'real'))
-      
+
     - task: MicroBuildOptProfPlugin@6
       inputs:
         ProfilingInputsDropName: '$(VisualStudio.DropName)'
         ShouldSkipOptimize: true
         AccessToken: '$(System.AccessToken)'
         feedSource: 'https://devdiv.pkgs.visualstudio.com/DefaultCollection/_packaging/MicroBuildToolset/nuget/v3/index.json'
-      displayName: 'Install OptProf Plugin'      
+      displayName: 'Install OptProf Plugin'
 
     # Required by MicroBuildBuildVSBootstrapper
     - task: ms-vseng.MicroBuildTasks.32f78468-e895-4f47-962c-58a699361df8.MicroBuildSwixPlugin@1
diff --git a/Directory.Build.props b/Directory.Build.props
index 35246a8e8ec..93150ee88bd 100644
--- a/Directory.Build.props
+++ b/Directory.Build.props
@@ -1,4 +1,4 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
+<?xml version="1.0" encoding="utf-8"?>
 <Project>
   <Import Project="Sdk.props" Sdk="Microsoft.DotNet.Arcade.Sdk" />
 
@@ -35,11 +35,10 @@
          NU5105: we're explicitly opting in to semver2, as is most of .NET Core
         CS1701 and CS1702 are by default ignored by Microsoft.NET.Sdk, but if you define the NoWarn property in Directory.Build.props,
         you don't get those defaults.
-        NU5125: Arcade uses licenseUrl when doing pack, which now causes NU5125 warning. This disables that warning until arcade can switch over.
         SYSLIB0011: Removing binary formatter will happen as part of a larger .NET-wide effort.
     -->
 
-    <NoWarn>$(NoWarn);NU1603;NU5105;NU5125;1701;1702;SYSLIB0011</NoWarn>
+    <NoWarn>$(NoWarn);NU1603;NU5105;1701;1702;SYSLIB0011</NoWarn>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(Configuration)' == 'Debug-MONO'">
diff --git a/README.md b/README.md
index 9fc80163443..66ce222ad7e 100644
--- a/README.md
+++ b/README.md
@@ -8,11 +8,15 @@ The [changelog](documentation/Changelog.md) has detailed information about chang
 
 ### Build Status
 
-The current development branch is `main`. Changes in `main` will go into a future update of MSBuild, which will release with Visual Studio 17.0 and a corresponding version of the .NET Core SDK.
+The current development branch is `main`. Changes in `main` will go into a future update of MSBuild, which will release with Visual Studio 17.1 and a corresponding version of the .NET Core SDK.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=main)
 
-We have forked for MSBuild 16.11 in the branch [`vs16.11`](https://github.com/Microsoft/msbuild/tree/vs16.11). Changes to that branch need special approval.
+We have forked for MSBuild 17.0 in the branch [`vs17.0`](https://github.com/Microsoft/msbuild/tree/vs17.0). Changes to that branch need special approval.
+
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.0)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.0)
+
+16.11 builds from the branch [`vs16.11`](https://github.com/Microsoft/msbuild/tree/vs16.11). Only high-priority bugfixes will be considered for servicing 16.11.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.11)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.11)
 
@@ -24,10 +28,6 @@ MSBuild 16.7 builds from the branch [`vs16.7`](https://github.com/dotnet/msbuild
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.7)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.7)
 
-MSBuild 16.4 builds from the branch [`vs16.4`](https://github.com/dotnet/msbuild/tree/vs16.4). Only high-priority bugfixes will be considered for servicing 16.4.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.4)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.4)
-
 MSBuild 15.9 builds from the branch [`vs15.9`](https://github.com/dotnet/msbuild/tree/vs15.9). Only very-high-priority bugfixes will be considered for servicing 15.9.
 
 ## Building
diff --git a/documentation/Built-in-Propeties.md b/documentation/Built-in-Propeties.md
new file mode 100644
index 00000000000..01c880aeb56
--- /dev/null
+++ b/documentation/Built-in-Propeties.md
@@ -0,0 +1,21 @@
+# MSBuild's reserved and built-in properties
+
+The MSBuild engine itself sets some properties for all projects. There is normal documentation for the [reserved properties and their meanings](https://docs.microsoft.com/visualstudio/msbuild/msbuild-reserved-and-well-known-properties). This document describes the implementation of these properties in MSBuild itself.
+
+There are actually two different implementations of this functionality in MSBuild.
+
+## Built-in properties
+
+When evaluating an individual project, Pass 0 of the evaluation calls [`AddBuiltInProperties()`][addbuiltinproperties] which in turn calls [`SetBuiltInProperty()`][setbuiltinproperty] which sets the property basically as normal.
+
+However, properties set there are not available at all parts of execution, and specifically they're not available when evaluating the `.tasks` file that makes MSBuild's built-in tasks available by default to all projects.
+
+## Reserved properties
+
+Reserved properties are [set by the toolset][toolset_reservedproperties] and are available _only_ in the `.tasks` and `.overridetasks` cases. Properties set there are not available in normal project evaluation.
+
+[addbuiltinproperties]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Evaluation/Evaluator.cs#L609-L612
+
+[setbuiltinproperty]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Evaluation/Evaluator.cs#L1257
+
+[toolset_reservedproperties]: https://github.com/dotnet/msbuild/blob/24b33188f385cee07804cc63ec805216b3f8b72f/src/Build/Definition/Toolset.cs#L914-L921
diff --git a/documentation/Changelog.md b/documentation/Changelog.md
index 19f97e2e2e7..be02ae3e952 100644
--- a/documentation/Changelog.md
+++ b/documentation/Changelog.md
@@ -1,5 +1,104 @@
 # MSBuild Changelog
 
+## MSBuild 17.0.0
+
+This version of MSBuild shipped with Visual Studio 2022 version 17.0.0 and .NET SDK 6.0.100.
+
+### What's new
+
+* MSBuild now reports its version as `17` and uses Visual Studio 2022 versions of tasks where appropriate.
+* MSBuild now targets .NET Framework 4.7.2 and .NET 6.0.
+* 64-bit MSBuild is now used for builds from Visual Studio.
+* Binary logs are smaller and have more information.
+* `MSBuildCopyContentTransitively` is now on by default, ensuring consistency in output folders on incremental builds.
+* The method `GetType()` can no longer be called in property functions.
+
+### Detailed release notes
+
+#### Added
+
+* Intrinsic tasks now log their location (#6397). Thanks, @KirillOsenkov!
+* `TargetSkippedEventArgs` now has `TargetSkipReason` and `OriginalBuildEventContext` (#6402, #6577). Thanks, @KirillOsenkov!
+* `TaskStarted` events now log line and column (#6399). Thanks, @KirillOsenkov!
+* ETW trace events for PerformDependencyAnalysis (#6658), WriteLinesToFile (#6670), CopyUpToDate (#6661).
+* If the environment variable `MSBuildDebugEngine` is set, MSBuild will create binary logs for all operations to `MSBUILDDEBUGPATH` regardless of how it is called (#6639, #6792).
+* `ProjectReference`s can now negotiate `Platform` (#6655, #6724, #6889).
+* Tasks can now call `TaskLoggingHelper.LogsMessagesOfImportance` to determine if any attached logger would preserve a log message before constructing it (to save time in the not-being-logged case) (#6381, #6737).
+* Support referencing assemblies with generic attributes (#6735). Thanks, @davidwrighton!
+* XSD-based MSBuild IntelliSense now supports `ImplicitUsings` and `Using` items (#6755), `InternalsVisibleTo` (#6778), Windows Forms properties (#6860), `DebugType` (#6849), and `SatelliteResourceLanguages` (#6861). Thanks, @pranavkm, @DamianEdwards, @RussKie, and @drewnoakes!
+* Tasks can now call `TaskLoggingHelper.IsTaskInputLoggingEnabled` and avoid redundant logging of inputs (#6803).
+* Support extracting resource namespace from C# source that uses file-scoped namespaces (#6881).
+
+#### Changed
+
+* The on-disk format of serialized caches has changed (#6350, #6324, #6490, #6674).
+* MSBuild is now [signed with a new certificate](https://github.com/dotnet/announcements/issues/184) (#6448).
+* `BuildParameters.DisableInprocNode` now applies to more processes (#6400).
+* `VCTargetsPath` now defaults to `v170` (#6550).
+* MSBuild no longer logs `Building with tools version "Current"` (#6627). Thanks, @KirillOsenkov!
+* Text loggers now log properties and items at the end of evaluation (#6535).
+* `MSBuildCopyContentTransitively` is now on by default, ensuring consistency in output folders on incremental builds (#6622, #6703).
+* MSBuild on .NET 6 has improved task-assembly-reference fallback behavior (#6558).
+* MSBuild features gated on the 16.8 changewave are now nonconfigurable (#6634).
+* The deprecated import of `$(CoreCrossTargetingTargetsPath)` was removed (#6668). Thanks, @Nirmal4G!
+* Improved error message for `MSB4213` (#6640).
+* The method `GetType()` can no longer be called in property functions (#6769).
+* MSBuild is now fully NGENed by Visual Studio setup (#6764).
+* MSBuild (and Visual Studio) now reference `System.Text.Json` 5.0.2 (#6784). Thanks, @JakeRadMSFT!
+* Default to SHA2 digest for ClickOnce manifest when certificate signing algorithm is sha256/384/512 (#6882).
+
+#### Fixed
+
+* Solution builds should work when using the secret environment variable `MSBUILDNOINPROCNODE` (#6385).
+* Solution extensions can now use `BeforeTargets="ValidateSolutionConfiguration"` (#6454).
+* Performance improvements (#6529, #6556, #6598, #6632, #6669, #6671, #6666, #6678, #6680, #6705, #6595, #6716, #6786, #6816, #6832, #6845).
+* Single-file ClickOnce publish includes file association icons (#6578).
+* Improved robustness in error handling of libraries without resources (#6546).
+* Fixed missing information in `Project`'s `DebuggerDisplay` (#6650).
+* `ResolveAssemblyReferences` output paths are now output in normalized form (#6533).
+* Improved handling of satellite assemblies in ClickOnce (#6665).
+* Roslyn code analyzers are no longer run during XAML precompilation (#6676). Thanks, @jlaanstra!
+* 64-bit API callers no longer need to set `MSBUILD_EXE_PATH` (#6683, #6746).
+* `EvaluateStop` ETW events are now automatically correlated with `EvaluateStart` (#6725).
+* Evaluation time is included in text performance traces (#6725).
+* Add PackageDescription to `Microsoft.NET.StringTools` (#6740).
+* Fixed deadlock between `ExecuteSubmission` and `LoggingService` (#6717).
+* Narrowed conditions where MSBuild would blame NuGet for SDK resolution problems (#6742).
+* `CombineTargetFrameworkInfoProperties` no longer fails on portable framework names (#6699).
+* Avoid needless builds of `GenerateBindingRedirects` (#6726).
+* The solution configuration is now passed to experimental cache plugins (#6738).
+* Clearer errors when SDK resolvers throw exceptions (#6763).
+* Improved errors from `InternableString.ExpensiveConvertToString` (#6798).
+* Binding redirects for all `System.*` assemblies updated (#6830).
+* Fixed deadlock between `BuildManager` and `LoggingService` (#6837).
+* Log message arguments for warnings and errors (#6804). Thanks, @KirillOsenkov!
+* Use static CoreClrAssemblyLoader for SDK resolvers (#6864). Thanks, @marcin-krystianc!
+* Avoid break caused by fix and workaround for AL path colliding (#6884).
+* Support private-use area Unicode characters in paths passed to `XslTransformation` (#6863, #6946). Thanks, @lanfeust69!
+* Use the correct .NET host when called from a .NET 6.0 application (#6890).
+
+#### Infrastructure
+
+* This repo now builds with Arcade 6.0 (#6143).
+* Use newer Ubuntu versions for Linux CI builds (#6488).
+* MSBuild now uses [Arcade-powered source build](https://github.com/dotnet/source-build/tree/ba0b33e9f96354b8d07317c3cdf406ce666921f8/Documentation/planning/arcade-powered-source-build) (#6387).
+* Improved repo issue templates and automation (#6557).
+* Whitespace cleanup (#6565).
+* This repo no longer needs to double-specify the SDK version (#6596).
+* Simplify references to `TargetFramework` using new intrinsics (#5799).
+* Reference the `Microsoft.DotNet.XUnitExtensions` package from Arcade instead of our fork (#6638).
+* Use [`BannedApiAnalyzers`](https://www.nuget.org/packages/Microsoft.CodeAnalysis.BannedApiAnalyzers/) (#6675).
+* Enable analyzers for the MSBuild repo with rules similar to `dotnet/runtime` (#5656). Thanks, @elachlan!
+* Improved internal OptProf training scenarios (#6758).
+* Delete Unreachable code (#6805). Thanks, @KirillOsenkov!
+* Upgrade System.Net.Http package version used in tests (#6879).
+
+#### Documentation
+
+* Use GitHub-generated Markdown tables of contents (#6760).
+* Fixed validation issues in docs build (#6744).
+* Descriptions of labels in use in this repo (#6873).
+
 ## MSBuild 16.11.0
 
 This version of MSBuild shipped with Visual Studio 2019 version 16.11.0 and .NET SDK 5.0.400.
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index 5e2a138e3d5..9dc2f404fa2 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -22,7 +22,7 @@ Importing `Microsoft.Common.targets` includes logic that consumes these items an
 
 ## Who this document is for
 
-This document describes that process, including what is required of a project to be referenceable through a `ProjectReference`. It is intended for for MSBuild SDK maintainers, and those who have created a completely custom project type that needs to interoperate with other projects. It may also be of interest if you'd like to see the implementation details of references. Understanding the details should not be necessary to _use_ `ProjectReferences` in your project.
+This document describes that process, including what is required of a project to be referenceable through a `ProjectReference`. It is intended for MSBuild SDK maintainers, and those who have created a completely custom project type that needs to interoperate with other projects. It may also be of interest if you'd like to see the implementation details of references. Understanding the details should not be necessary to _use_ `ProjectReferences` in your project.
 
 ## Targets related to consuming a reference
 
@@ -51,7 +51,7 @@ These targets should exist in a project to be compatible with the common targets
 
 These targets are all defined in `Microsoft.Common.targets` and are defined in Microsoft SDKs. You should only have to implement them yourself if you require custom behavior or are authoring a project that doesn't import the common targets.
 
-If implementing a project with an “outer” (determine what properties to pass to the real build) and “inner” (fully specified) build, only `GetTargetFrameworkProperties` is required in the “outer” build. The other targets listed can be “inner” build only.
+If implementing a project with an “outer” (determine what properties to pass to the real build) and “inner” (fully specified) build, only `GetTargetFrameworks` is required in the “outer” build. The other targets listed can be “inner” build only.
 
 * `GetTargetFrameworks` tells referencing projects what options are available to the build.
   * It returns an item with the following metadata:
@@ -106,7 +106,7 @@ As of MSBuild 16.10, it is possible to gather additional properties from referen
 
 These properties will then be gathered via the `GetTargetFrameworks` call.  They will be available to the referencing project via the `AdditionalPropertiesFromProject` metadata on the `_MSBuildProjectReferenceExistent` item.  The `AdditionalPropertiesFromProject` value will be an XML string which contains the values of the properties for each `TargetFramework` in the referenced project.  For example:
 
-> :warning: This format is being changed. Soon, the schema will replace <net5.0> with <TargetFramework Name="net5.0">. You can opt into that behavior early by setting the _UseAttributeForTargetFrameworkInfoPropertyNames property to true. This property will have no effect after the transition is complete.
+> :warning: This format is being changed. Soon, the schema will replace `<net5.0>` with `<TargetFramework Name="net5.0">`. You can opt into that behavior early by setting the `_UseAttributeForTargetFrameworkInfoPropertyNames` property to true. This property will have no effect after the transition is complete.
 
 ```xml
 <AdditionalProjectProperties>
@@ -176,7 +176,7 @@ Project B: Unmanaged, has `$(Platforms)` constructed from its `Platform` metadat
 Because `AnyCPU` does not map to anything architecture-specific, a custom mapping must be defined. Project A can either:
 1. Define `PlatformLookupTable` in its project or a Directory.Build.props as `AnyCPU=x64` or `AnyCPU=Win32`.
 2. Define `PlatformLookupTable` as metadata on the `ProjectReference` item, which would take priority over a lookup table defined elsewhere.
-     *  When only one mapping is valid, you could also directly define `SetPlatform` metadata as `Platform=foo` (for unmanaged) or `PlatformTarget=bar` (for managed). This would skip over most negotiation logic.
+     *  When only one mapping is valid, you could also directly define `SetPlatform` metadata as `Platform=foo`. This would skip over most negotiation logic.
 
 Example of project A defining a lookup table directly on the `ProjectReference`:
 ```xml
diff --git a/documentation/consuming-nuget-package.md b/documentation/consuming-nuget-package.md
index e4e42f5c187..e611e2194d6 100644
--- a/documentation/consuming-nuget-package.md
+++ b/documentation/consuming-nuget-package.md
@@ -30,7 +30,7 @@ The items in this namespace are MSBuild tasks that have been developed by the MS
 [Csc](https://msdn.microsoft.com/en-us/library/microsoft.build.tasks.csc.aspx), and [Exec](https://msdn.microsoft.com/en-us/library/microsoft.build.tasks.exec.aspx).
 
 Most developers do not need to reference this package unless they want to extend a stock MSBuild task with custom functionality.  Alternatively, we recommend that MSBuild task developers reference the 
-`Microsoft.Build.Utilites.Core` package and implement the abstract class [Task](https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.task.aspx) or
+`Microsoft.Build.Utilities.Core` package and implement the abstract class [Task](https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.task.aspx) or
 [ToolTask](https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.tooltask.aspx).
 
 ## Microsoft.Build
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 5b152e7c1a7..6c61626ec7b 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -8,7 +8,7 @@ Opt-out is a better approach for us because we'd likely get limited feedback whe
 The opt-out comes in the form of setting the environment variable `MSBuildDisableFeaturesFromVersion` to the Change Wave (or version) that contains the feature you want **disabled**. This version happens to be the version of MSBuild that the features were developed for. See the mapping of change waves to features below.
 
 ## When do they become permanent?
-A wave of features is set to "rotate out" (i.e. become standard functionality) two bands after its release. For example, wave 16.8 stayed opt-out through wave 16.10, becoming standard functionalty when wave 17.0 is introduced.
+A wave of features is set to "rotate out" (i.e. become standard functionality) two bands after its release. For example, wave 16.8 stayed opt-out through wave 16.10, becoming standard functionality when wave 17.0 is introduced.
 
 ## MSBuildDisableFeaturesFromVersion Values & Outcomes
 | `MSBuildDisableFeaturesFromVersion` Value                         | Result        | Receive Warning? |
diff --git a/eng/Build.props b/eng/Build.props
index 6393db2a363..2fff7c5c2ca 100644
--- a/eng/Build.props
+++ b/eng/Build.props
@@ -2,6 +2,10 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
 
+  <PropertyGroup>
+    <RestoreUseStaticGraphEvaluation>true</RestoreUseStaticGraphEvaluation>
+  </PropertyGroup>
+
   <ItemGroup>
 	<!-- Remove all sln files globbed by arcade so far and add only MSBuild.sln to the build.
 	Without this, arcade tries to build all three MSBuild solution at once, which leads to
diff --git a/eng/Packages.props b/eng/Packages.props
index b1ef91dacf6..c6f27a71802 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -13,6 +13,7 @@
     <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="4.0.0-4.21379.20" />
     <PackageReference Update="Microsoft.DotNet.GenAPI" Version="2.1.0-prerelease-02404-02" />
     <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
+    <PackageReference Update="Microsoft.IO.Redist" Version="4.7.1" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="Microsoft.Win32.Registry" Version="4.3.0" />
     <PackageReference Update="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index cc3eebb1a18..3aa77017a4b 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -5,22 +5,22 @@
       <Uri>https://github.com/dotnet/roslyn-analyzers</Uri>
       <Sha />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.21460.7">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.21519.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>7324320f814152b72295946847ca72413507705a</Sha>
+      <Sha>85f3aa16d8797b5020f1fda11df1a958feb5f8df</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.0.0-preview.4.243">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.0.0-rc.262">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>f82431ecc38a28f396d527446834c7de679a6722</Sha>
+      <Sha>e3016693e01536996921d613152648d66eb0ce99</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.0.0-5.21469.2">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.0.0-6.21515.3">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>c1d8c6f043bc80425c6828455eb57f8a404759c6</Sha>
+      <Sha>95b7a0198f8c805b367f17e4639020ec21c16705</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.21460.7">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.21519.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>7324320f814152b72295946847ca72413507705a</Sha>
+      <Sha>85f3aa16d8797b5020f1fda11df1a958feb5f8df</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 7c66217f415..74d7aa3841a 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,7 +2,7 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.0.0</VersionPrefix>
+    <VersionPrefix>17.1.0</VersionPrefix>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -32,11 +32,11 @@
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.21460.7</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.21519.3</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftCodeAnalysisBannedApiAnalyzersVersion>3.3.2</MicrosoftCodeAnalysisBannedApiAnalyzersVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.0.0-5.21469.2</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.0.0-preview.4.243</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.0.0-6.21515.3</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.0.0-rc.262</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/eng/build.ps1 b/eng/build.ps1
index 9245a71a0f4..2762b71fb9f 100644
--- a/eng/build.ps1
+++ b/eng/build.ps1
@@ -158,9 +158,13 @@ function Check-EditedFiles() {
 
 function Check-RequiredVersionBumps() {
   # Log VSTS errors for missing required version bumps
-  if ($env:SYSTEM_PULLREQUEST_TARGETBRANCH) {
+  $targetBranch = $env:SYSTEM_PULLREQUEST_TARGETBRANCH
+  if ($targetBranch) {
+    # Some PRs specify the bare target branch (most commonly "main"), some prefix it with "refs/heads/".
+    # The following statement normalizes both to a revision spec that git understands.
+    $targetBranch = "refs/remotes/origin/" + ($targetBranch -replace "^refs/heads/", "")
     $versionLineChanged = $false
-    git --no-pager diff --unified --no-color --exit-code -w origin/$env:SYSTEM_PULLREQUEST_TARGETBRANCH HEAD src\Framework\EngineServices.cs `
+    git --no-pager diff --unified --no-color --exit-code -w $targetBranch HEAD src\Framework\EngineServices.cs `
       | Select-String -Pattern "int Version =" | ForEach-Object -process { $versionLineChanged = $true }
     if (($LASTEXITCODE -ne 0) -and (-not $versionLineChanged)) {
       throw "##vso[task.logissue type=error] Detected changes in Framework\EngineServices.cs without a version bump.  " +
diff --git a/eng/common/templates/post-build/post-build.yml b/eng/common/templates/post-build/post-build.yml
index bf9f2eb4617..4f79cf0f337 100644
--- a/eng/common/templates/post-build/post-build.yml
+++ b/eng/common/templates/post-build/post-build.yml
@@ -166,11 +166,6 @@ stages:
           inputs:
             filePath: eng\common\enable-cross-org-publishing.ps1
             arguments: -token $(dn-bot-dnceng-artifact-feeds-rw)
-        
-        - task: DeleteFiles@1
-          inputs:
-            SourceFolder: $(Build.ArtifactStagingDirectory)/PackageArtifacts
-            Contents: Microsoft.SourceBuild.Intermediate*
 
         # Signing validation will optionally work with the buildmanifest file which is downloaded from
         # Azure DevOps above.
diff --git a/eng/common/tools.ps1 b/eng/common/tools.ps1
index 02347914f5d..44484289943 100644
--- a/eng/common/tools.ps1
+++ b/eng/common/tools.ps1
@@ -709,14 +709,7 @@ function MSBuild() {
       Write-PipelineSetVariable -Name 'NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS' -Value '20'
     }
 
-    if ($ci) {
-      $env:NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY = 'true'
-      $env:NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT = 6
-      $env:NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS = 1000
-      Write-PipelineSetVariable -Name 'NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY' -Value 'true'
-      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT' -Value '6'
-      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS' -Value '1000'
-    }
+    Enable-Nuget-EnhancedRetry
 
     $toolsetBuildProject = InitializeToolset
     $basePath = Split-Path -parent $toolsetBuildProject
@@ -764,6 +757,8 @@ function MSBuild-Core() {
     }
   }
 
+  Enable-Nuget-EnhancedRetry
+
   $buildTool = InitializeBuildTool
 
   $cmdArgs = "$($buildTool.Command) /m /nologo /clp:Summary /v:$verbosity /nr:$nodeReuse /p:ContinuousIntegrationBuild=$ci"
@@ -904,3 +899,18 @@ function Try-LogClientIpAddress()
         Write-Host "Unable to get this machine's effective IP address for logging: $_"
     }
 }
+
+#
+# If $ci flag is set, turn on (and log that we did) special environment variables for improved Nuget client retry logic.
+#
+function Enable-Nuget-EnhancedRetry() {
+    if ($ci) {
+      Write-Host "Setting NUGET enhanced retry environment variables"
+      $env:NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY = 'true'
+      $env:NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT = 6
+      $env:NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS = 1000
+      Write-PipelineSetVariable -Name 'NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY' -Value 'true'
+      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT' -Value '6'
+      Write-PipelineSetVariable -Name 'NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS' -Value '1000'
+    }
+}
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 526fcab2ac4..3b88fde499f 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -21,12 +21,11 @@
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
-    <GlobalPackageReference Include="Microsoft.NETFramework.ReferenceAssemblies" Version="1.0.0" PrivateAssets="All" />
+    <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="$(MicrosoftCodeAnalysisBannedApiAnalyzersVersion)" />
   </ItemGroup>
 
   <ItemGroup>
     <GlobalPackageReference Include="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.15" PrivateAssets="All" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
-    <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="$(MicrosoftCodeAnalysisBannedApiAnalyzersVersion)" />
   </ItemGroup>
 
 </Project>
diff --git a/global.json b/global.json
index c0ab9c781c8..3d50b269200 100644
--- a/global.json
+++ b/global.json
@@ -4,17 +4,12 @@
   },
   "tools": {
     "dotnet": "6.0.100-rc.1.21458.32",
-    "runtimes": {
-      "dotnet/x64": [
-        "2.1.7"
-      ]
-    },
     "vs": {
       "version": "16.0"
     }
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.21460.7"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.21519.3"
   }
 }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index fb5b4b8da5e..b2fff2cee3d 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -498,6 +498,7 @@ namespace Microsoft.Build.Definition
     public partial class ProjectOptions
     {
         public ProjectOptions() { }
+        public Microsoft.Build.FileSystem.IDirectoryCacheFactory DirectoryCacheFactory { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.Context.EvaluationContext EvaluationContext { get { throw null; } set { } }
         public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.ProjectLoadSettings LoadSettings { get { throw null; } set { } }
@@ -1504,6 +1505,19 @@ public ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, strin
 }
 namespace Microsoft.Build.FileSystem
 {
+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);
+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);
+    public partial interface IDirectoryCache
+    {
+        bool DirectoryExists(string path);
+        System.Collections.Generic.IEnumerable<TResult> EnumerateDirectories<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);
+        System.Collections.Generic.IEnumerable<TResult> EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);
+        bool FileExists(string path);
+    }
+    public partial interface IDirectoryCacheFactory
+    {
+        Microsoft.Build.FileSystem.IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);
+    }
     public abstract partial class MSBuildFileSystemBase
     {
         protected MSBuildFileSystemBase() { }
@@ -1528,6 +1542,7 @@ public partial class CompositeGlob : Microsoft.Build.Globbing.IMSBuildGlob
         public CompositeGlob(params Microsoft.Build.Globbing.IMSBuildGlob[] globs) { }
         public CompositeGlob(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) { }
         public System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> Globs { get { throw null; } }
+        public static Microsoft.Build.Globbing.IMSBuildGlob Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) { throw null; }
         public bool IsMatch(string stringToMatch) { throw null; }
     }
     public partial interface IMSBuildGlob
@@ -1546,10 +1561,10 @@ internal MSBuildGlob() { }
         public static Microsoft.Build.Globbing.MSBuildGlob Parse(string fileSpec) { throw null; }
         public static Microsoft.Build.Globbing.MSBuildGlob Parse(string globRoot, string fileSpec) { throw null; }
         [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public partial struct MatchInfoResult
+        public readonly partial struct MatchInfoResult
         {
-            private object _dummy;
-            private int _dummyPrimitive;
+            private readonly object _dummy;
+            private readonly int _dummyPrimitive;
             public string FilenamePartMatchGroup { get { throw null; } }
             public string FixedDirectoryPartMatchGroup { get { throw null; } }
             public bool IsMatch { get { throw null; } }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index b387429467c..34ffaa47e3a 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -498,6 +498,7 @@ namespace Microsoft.Build.Definition
     public partial class ProjectOptions
     {
         public ProjectOptions() { }
+        public Microsoft.Build.FileSystem.IDirectoryCacheFactory DirectoryCacheFactory { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.Context.EvaluationContext EvaluationContext { get { throw null; } set { } }
         public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } set { } }
         public Microsoft.Build.Evaluation.ProjectLoadSettings LoadSettings { get { throw null; } set { } }
@@ -1498,6 +1499,19 @@ public ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, strin
 }
 namespace Microsoft.Build.FileSystem
 {
+    public delegate bool FindPredicate(ref System.ReadOnlySpan<char> fileName);
+    public delegate TResult FindTransform<TResult>(ref System.ReadOnlySpan<char> fileName);
+    public partial interface IDirectoryCache
+    {
+        bool DirectoryExists(string path);
+        System.Collections.Generic.IEnumerable<TResult> EnumerateDirectories<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);
+        System.Collections.Generic.IEnumerable<TResult> EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform);
+        bool FileExists(string path);
+    }
+    public partial interface IDirectoryCacheFactory
+    {
+        Microsoft.Build.FileSystem.IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);
+    }
     public abstract partial class MSBuildFileSystemBase
     {
         protected MSBuildFileSystemBase() { }
@@ -1522,6 +1536,7 @@ public partial class CompositeGlob : Microsoft.Build.Globbing.IMSBuildGlob
         public CompositeGlob(params Microsoft.Build.Globbing.IMSBuildGlob[] globs) { }
         public CompositeGlob(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) { }
         public System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> Globs { get { throw null; } }
+        public static Microsoft.Build.Globbing.IMSBuildGlob Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) { throw null; }
         public bool IsMatch(string stringToMatch) { throw null; }
     }
     public partial interface IMSBuildGlob
@@ -1540,10 +1555,10 @@ internal MSBuildGlob() { }
         public static Microsoft.Build.Globbing.MSBuildGlob Parse(string fileSpec) { throw null; }
         public static Microsoft.Build.Globbing.MSBuildGlob Parse(string globRoot, string fileSpec) { throw null; }
         [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
-        public partial struct MatchInfoResult
+        public readonly partial struct MatchInfoResult
         {
-            private object _dummy;
-            private int _dummyPrimitive;
+            private readonly object _dummy;
+            private readonly int _dummyPrimitive;
             public string FilenamePartMatchGroup { get { throw null; } }
             public string FixedDirectoryPartMatchGroup { get { throw null; } }
             public bool IsMatch { get { throw null; } }
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index f27baefae70..6bb58a189b1 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -93,6 +93,7 @@ if ($runtime -eq "Desktop") {
 
         FileToCopy "$bootstrapBinDirectory\Microsoft.Bcl.AsyncInterfaces.dll"
         FileToCopy "$bootstrapBinDirectory\Microsoft.Data.Entity.targets"
+        FileToCopy "$bootstrapBinDirectory\Microsoft.IO.Redist.dll"
         FileToCopy "$bootstrapBinDirectory\Microsoft.ServiceModel.targets"
         FileToCopy "$bootstrapBinDirectory\Microsoft.WinFx.targets"
         FileToCopy "$bootstrapBinDirectory\Microsoft.WorkflowBuildExtensions.targets"
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index 5323c0fd85e..3abcf608f97 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -3733,7 +3733,7 @@ public void GetAllGlobsShouldProduceGlobThatMatches(string itemContents, string[
 
             var getAllGlobsResult = ObjectModelHelpers.CreateInMemoryProject(projectContents).GetAllGlobs();
 
-            var uberGlob = new CompositeGlob(getAllGlobsResult.Select(r => r.MsBuildGlob).ToImmutableArray());
+            var uberGlob = CompositeGlob.Create(getAllGlobsResult.Select(r => r.MsBuildGlob));
 
             foreach (var matchingString in stringsThatShouldMatch)
             {
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 7c478d2a782..aab3620f407 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -6,7 +6,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <IsPackable>false</IsPackable>
 
     <AssemblyName>Microsoft.Build.Engine.OM.UnitTests</AssemblyName>
@@ -20,6 +19,8 @@
 </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
     <PackageDownload Include="NuGet.CommandLine" Version="[$(NuGetCommandLinePackageVersion)]" />
diff --git a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
index d49cc341887..106e03beaf3 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
@@ -184,8 +184,8 @@ public void CreatableByTaskFactoryMatchingIdentity()
             SetupTaskFactory(factoryIdentityParameters, false /* don't want task host */);
 
             IDictionary<string, string> taskIdentityParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-            taskIdentityParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
-            taskIdentityParameters.Add(XMakeAttributes.architecture, XMakeAttributes.MSBuildArchitectureValues.any);
+            taskIdentityParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
+            taskIdentityParameters.Add(XMakeAttributes.architecture, XMakeAttributes.GetCurrentMSBuildArchitecture());
 
             Assert.True(_taskFactory.TaskNameCreatableByFactory("TaskToTestFactories", taskIdentityParameters, String.Empty, null, ElementLocation.Create(".", 1, 1)));
         }
@@ -309,7 +309,7 @@ public void VerifyMatchingTaskParametersDontLaunchTaskHost2()
             try
             {
                 IDictionary<string, string> taskParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                taskParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
+                taskParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
                 taskParameters.Add(XMakeAttributes.architecture, XMakeAttributes.GetCurrentMSBuildArchitecture());
 
                 createdTask = _taskFactory.CreateTaskInstance(ElementLocation.Create("MSBUILD"), null, new MockHost(), taskParameters,
@@ -406,7 +406,7 @@ public void VerifyMatchingParametersDontLaunchTaskHost()
             try
             {
                 IDictionary<string, string> factoryParameters = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
-                factoryParameters.Add(XMakeAttributes.runtime, XMakeAttributes.MSBuildRuntimeValues.clr4);
+                factoryParameters.Add(XMakeAttributes.runtime, XMakeAttributes.GetCurrentMSBuildRuntime());
 
                 SetupTaskFactory(factoryParameters, false /* don't want task host */);
 
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 1587123afc0..761597bd4e1 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -1598,7 +1598,7 @@ public void CancelledBuildWithDelay20()
             _logger.AssertLogDoesntContain("[errormessage]");
         }
 
-#if FEATURE_TASKHOST && !NO_MSBUILDTASKHOST
+#if !NO_MSBUILDTASKHOST
         // Run this test only if we expect MSBuildTaskHost to have been produced, which requires that MSBuildTaskHost.csproj
         // be built with full-framework MSBuild (so that it can target .NET 3.5).
 
@@ -1672,7 +1672,6 @@ public void CancelledBuildWithDelay40()
             _logger.AssertLogDoesntContain("[errormessage]");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// A canceled build which waits for the task to get started before canceling.  Because it is a 12.0 task, we should
         /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly.
@@ -1706,7 +1705,6 @@ public void CancelledBuildInTaskHostWithDelay40()
             // Task host should not have exited prematurely
             _logger.AssertLogDoesntContain("MSB4217");
         }
-#endif
 
         /// <summary>
         /// This test verifies that builds of the same project instance in sequence are permitted.
@@ -4360,10 +4358,8 @@ public override bool Execute()
         [Theory]
         [InlineData("", false)] // regular task host, input logging disabled
         [InlineData("", true)] // regular task host, input logging enabled
-#if NETFRAMEWORK // https://github.com/microsoft/msbuild/issues/5158
         [InlineData("TaskHostFactory", false)] // OOP task host, input logging disabled
         [InlineData("TaskHostFactory", true)] // OOP task host, input logging enabled
-#endif
         public void TaskInputLoggingIsExposedToTasks(string taskFactory, bool taskInputLoggingEnabled)
         {
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"<Project>
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index b7d3098dd5c..2476d984cbf 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -372,12 +372,13 @@ public void PropertyOverridesContainSemicolon()
 
             // Just a normal console application project.
             ObjectModelHelpers.CreateFileInTempProjectDirectory(
-                @"bug'533'369\Sub;Dir\ConsoleApplication1\ConsoleApplication1.csproj", @"
+                @"bug'533'369\Sub;Dir\ConsoleApplication1\ConsoleApplication1.csproj", $@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                   <PropertyGroup>
                     <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                     <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                     <OutputType>Exe</OutputType>
                     <AssemblyName>ConsoleApplication1</AssemblyName>
                   </PropertyGroup>
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 486352af3f2..87152257402 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -22,6 +22,7 @@
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
+using System.Threading;
 
 namespace Microsoft.Build.UnitTests.BackEnd
 {
@@ -107,6 +108,63 @@ public void TasksNotDiscoveredWhenTaskConditionFalse()
             logger.AssertLogContains("Made it");
         }
 
+        [Fact]
+        public void CanceledTasksDoNotLogMSB4181()
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_testOutput))
+            {
+                BuildManager manager = new BuildManager();
+                ProjectCollection collection = new ProjectCollection();
+
+                string contents = @"
+                    <Project xmlns='http://schemas.microsoft.com/developer/msbuild/2003' ToolsVersion ='Current'>
+                     <Target Name='test'>
+                        <Exec Command='" + Helpers.GetSleepCommand(TimeSpan.FromSeconds(10)) + @"'/>
+                     </Target>
+                    </Project>";
+
+                MockLogger logger = new MockLogger(_testOutput);
+
+                var project = new Project(XmlReader.Create(new StringReader(contents)), null, MSBuildConstants.CurrentToolsVersion, collection)
+                {
+                    FullPath = env.CreateFile().Path
+                };
+
+                var _parameters = new BuildParameters
+                {
+                    ShutdownInProcNodeOnBuildFinish = true,
+                    Loggers = new ILogger[] { logger },
+                    EnableNodeReuse = false
+                };
+                ;
+
+                BuildRequestData data = new BuildRequestData(project.CreateProjectInstance(), new string[] { "test" }, collection.HostServices);
+                manager.BeginBuild(_parameters);
+                BuildSubmission asyncResult = manager.PendBuildRequest(data);
+                asyncResult.ExecuteAsync(null, null);
+                Thread.Sleep(500);
+                manager.CancelAllSubmissions();
+                asyncResult.WaitHandle.WaitOne();
+                BuildResult result = asyncResult.BuildResult;
+                manager.EndBuild();
+
+                // No errors from cancelling a build.
+                logger.ErrorCount.ShouldBe(0);
+                // Warn because the task is being cancelled.
+                // NOTE: This assertion will fail when debugging into it because "waiting on exec to cancel" warning will be logged.
+                logger.WarningCount.ShouldBe(1);
+                // Build failed because it was cancelled.
+                result.OverallResult.ShouldBe(BuildResultCode.Failure);
+                // Should log "Cmd being cancelled because build was cancelled" warning
+                logger.AssertLogContains("MSB5021");
+                // Should NOT log "exec failed without logging error"
+                logger.AssertLogDoesntContain("MSB4181");
+
+                collection.Dispose();
+                manager.Dispose();
+            }
+        }
+
         /// <summary>
         /// Verify when task outputs are overridden the override messages are correctly displayed
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 897b6a5751f..fa4146484e9 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -12,7 +12,6 @@ namespace Microsoft.Build.Engine.UnitTests.BackEnd
     public sealed class TaskHostFactory_Tests
     {
         [Fact]
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp, "https://github.com/microsoft/msbuild/issues/5158")]
         [Trait("Category", "mono-osx-failing")]
         public void TaskNodesDieAfterBuild()
         {
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index 232d22c62dd..49497a0e870 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -129,6 +129,41 @@ public void IsolatedContextShouldNotSupportBeingPassedAFileSystem()
             Should.Throw<ArgumentException>(() => EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated, fileSystem));
         }
 
+        [Fact]
+        public void EvaluationShouldUseDirectoryCache()
+        {
+            var projectFile = _env.CreateFile("1.proj", @"<Project> <ItemGroup Condition=`Exists('1.file')`> <Compile Include='*.cs'/> </ItemGroup> </Project>".Cleanup()).Path;
+
+            var projectCollection = _env.CreateProjectCollection().Collection;
+            var directoryCacheFactory = new Helpers.LoggingDirectoryCacheFactory();
+
+            var project = Project.FromFile(
+                projectFile,
+                new ProjectOptions
+                {
+                    ProjectCollection = projectCollection,
+                    DirectoryCacheFactory = directoryCacheFactory,
+                }
+            );
+
+            directoryCacheFactory.DirectoryCaches.Count.ShouldBe(1);
+            var directoryCache = directoryCacheFactory.DirectoryCaches[0];
+
+            directoryCache.EvaluationId.ShouldBe(project.LastEvaluationId);
+
+            directoryCache.ExistenceChecks.OrderBy(kvp => kvp.Key).ShouldBe(
+                new Dictionary<string, int>
+                {
+                    { _env.DefaultTestDirectory.Path, 1},
+                    { Path.Combine(_env.DefaultTestDirectory.Path, "1.file"), 2 }
+                }.OrderBy(kvp => kvp.Key));
+            directoryCache.Enumerations.ShouldBe(
+                new Dictionary<string, int>
+                {
+                    { _env.DefaultTestDirectory.Path, 1 }
+                });
+        }
+
         [Theory]
         [InlineData(EvaluationContext.SharingPolicy.Shared)]
         [InlineData(EvaluationContext.SharingPolicy.Isolated)]
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index e1ad11a9be0..edd37ea0144 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -21,6 +21,7 @@
 using ResourceUtilities = Microsoft.Build.Shared.ResourceUtilities;
 using Xunit;
 using Xunit.Abstractions;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.UnitTests.EscapingInProjects_Tests
 {
@@ -94,7 +95,6 @@ public void SemicolonInPropertyPassedIntoStringParam()
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Make sure I can define a property with escaped characters and pass it into
         /// a string parameter of a task, in this case the Message task.
@@ -117,7 +117,6 @@ public void SemicolonInPropertyPassedIntoStringParam_UsingTaskHost()
 
             logger.AssertLogContains("Property value is 'abc ; def ; ghi'");
         }
-#endif
 
 #if FEATURE_ASSEMBLY_LOCATION
         /// <summary>
@@ -588,7 +587,6 @@ public void ItemTransformContainingSemicolon()
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Do an item transform, where the transform expression contains an unescaped semicolon as well
         /// as an escaped percent sign.
@@ -616,7 +614,6 @@ public void ItemTransformContainingSemicolon_InTaskHost()
 
             logger.AssertLogContains("Transformed item list: 'X;X%3bX.txt    Y;Y%3bY.txt    Z;Z%3bZ.txt'");
         }
-#endif
 
         /// <summary>
         /// Tests that when we add an item and are in a directory with characters in need of escaping, and the
@@ -710,7 +707,6 @@ public void EscapedWildcardsShouldNotBeExpanded()
             }
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// If %2A (escaped '*') or %3F (escaped '?') is in an item's Include, it should be treated
         /// literally, not as a wildcard
@@ -747,7 +743,6 @@ public void EscapedWildcardsShouldNotBeExpanded_InTaskHost()
                 ObjectModelHelpers.DeleteTempProjectDirectory();
             }
         }
-#endif
 
         /// <summary>
         /// Parity with Orcas: Target names are always unescaped, and in fact, if there are two targets,
@@ -954,12 +949,13 @@ public void SemicolonInConfiguration()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1002,7 +998,6 @@ public class Class1
             logger.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\a;b'c\ClassLibrary16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: Escaping in conditionals is broken.
         /// </summary>
@@ -1019,12 +1014,13 @@ public void SemicolonInConfiguration_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1071,7 +1067,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         ///     ESCAPING: CopyBuildTarget target fails if the output assembly name contains a semicolon or single-quote
@@ -1084,12 +1079,13 @@ public void SemicolonInAssemblyName()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%3bLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1127,7 +1123,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\Class;Library16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: CopyBuildTarget target fails if the output assembly name contains a semicolon or single-quote
         /// </summary>
@@ -1144,12 +1139,13 @@ public void SemicolonInAssemblyName_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%3bLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1191,7 +1187,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         ///     ESCAPING: Conversion Issue: Properties with $(xxx) as literals are not being converted correctly
@@ -1204,12 +1199,13 @@ public void DollarSignInAssemblyName()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%24%28prop%29Library16</AssemblyName>
                     </PropertyGroup>
@@ -1247,7 +1243,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\Class$(prop)Library16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         ///     ESCAPING: Conversion Issue: Properties with $(xxx) as literals are not being converted correctly
         /// </summary>
@@ -1264,12 +1259,13 @@ public void DollarSignInAssemblyName_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>Class%24%28prop%29Library16</AssemblyName>
                     </PropertyGroup>
@@ -1311,7 +1307,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         /// This is the case when one of the source code files in the project has a filename containing a semicolon.
@@ -1324,12 +1319,13 @@ public void SemicolonInSourceCodeFilename()
             // ---------------------
             // Foo.csproj
             // ---------------------
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1367,7 +1363,6 @@ public class Class1
             log.AssertLogContains(String.Format("foo -> {0}", Path.Combine(ObjectModelHelpers.TempProjectDir, @"bin\Debug\ClassLibrary16.dll")));
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// This is the case when one of the source code files in the project has a filename containing a semicolon.
         /// </summary>
@@ -1384,12 +1379,13 @@ public void SemicolonInSourceCodeFilename_UsingTaskHost()
                 // ---------------------
                 // Foo.csproj
                 // ---------------------
-                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", @"
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
+                ObjectModelHelpers.CreateFileInTempProjectDirectory("foo.csproj", $@"
+                <Project DefaultTargets=`Build` xmlns=`http://schemas.microsoft.com/developer/msbuild/2003`>
                     <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                     <PropertyGroup>
                         <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                         <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <AssemblyName>ClassLibrary16</AssemblyName>
                     </PropertyGroup>
@@ -1431,7 +1427,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
 
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
@@ -1599,7 +1594,6 @@ public class Class1
             Assert.True(File.Exists(Path.Combine(ObjectModelHelpers.TempProjectDir, @"SLN;!@(foo)'^1\Console;!@(foo)'^(Application1\bin\debug\Console;!@(foo)'^(Application1.exe"))); //                     @"Did not find expected file Console;!@(foo)'^(Application1.exe"
         }
 
-#if FEATURE_TASKHOST
         /// <summary>
         /// Build a .SLN file using MSBuild.  The .SLN and the projects contained within
         /// have all sorts of crazy characters in their name. There
@@ -1775,7 +1769,6 @@ public class Class1
                 Environment.SetEnvironmentVariable("MSBUILDFORCEALLTASKSOUTOFPROC", originalOverrideTaskHostVariable);
             }
         }
-#endif
     }
 #endif
 
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index b58a72d0843..c8c590e79cd 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -1874,19 +1874,19 @@ public void TestItemSpecModiferEscaping()
         [Trait("Category", "mono-osx-failing")]
         public void TestGetPathToReferenceAssembliesAsFunction()
         {
-            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45) == null)
+            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) == null)
             {
                 // if there aren't any reference assemblies installed on the machine in the first place, of course
                 // we're not going to find them. :)
                 return;
             }
 
-            string content = @"
+            string content = $@"
                 <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
 
                     <PropertyGroup>
                         <TargetFrameworkIdentifier>.NETFramework</TargetFrameworkIdentifier>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <TargetFrameworkProfile></TargetFrameworkProfile>
                         <TargetFrameworkMoniker>$(TargetFrameworkIdentifier),Version=$(TargetFrameworkVersion)</TargetFrameworkMoniker>
                     </PropertyGroup>
@@ -3979,6 +3979,12 @@ public void PropertyFunctionStringLastIndexOf()
             TestPropertyFunction("$(prop.LastIndexOf('y', 7))", "prop", "x-x-y-y-y-z", "6");
         }
 
+        [Fact]
+        public void PropertyFunctionStringLastIndexOfAny()
+        {
+            TestPropertyFunction("$(prop.LastIndexOfAny('xy'))", "prop", "x-x-y-y-y-z", "8");
+        }
+
         [Fact]
         public void PropertyFunctionStringCopy()
         {
diff --git a/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs b/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
index 6aec4235e18..ca0efc0d850 100644
--- a/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/CompositeGlob_Tests.cs
@@ -138,5 +138,37 @@ public void MSBuildGlobVisitorShouldFindAllLeaves()
                 Assert.Contains(expectedGlob, leafGlobs);
             }
         }
+
+        [Fact]
+        public void CreateShouldHandleZeroChildren()
+        {
+            IMSBuildGlob composite = CompositeGlob.Create(Enumerable.Empty<IMSBuildGlob>());
+
+            Assert.False(composite.IsMatch(""));
+        }
+
+        [Fact]
+        public void CreateShouldReturnSingleChildUnchanged()
+        {
+            var glob = MSBuildGlob.Parse("");
+
+            IMSBuildGlob composite = CompositeGlob.Create(new[] { glob });
+
+            Assert.Same(glob, composite);
+        }
+
+        [Fact]
+        public void CreateShouldReturnNewCompositeWhenMultipleProvided()
+        {
+            var glob1 = MSBuildGlob.Parse("");
+            var glob2 = MSBuildGlob.Parse("");
+
+            IMSBuildGlob result = CompositeGlob.Create(new[] { glob1, glob2 });
+
+            var composite = Assert.IsType<CompositeGlob>(result);
+            Assert.Same(glob1, composite.Globs.First());
+            Assert.Same(glob2, composite.Globs.Skip(1).First());
+            Assert.Equal(2, composite.Globs.Count());
+        }
     }
 }
\ No newline at end of file
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
index 9dc8a506fcf..fd742516500 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlobWithGaps_Tests.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Engine.UnitTests.Globbing
     public class MSBuildGlobWithGaps_Tests
     {
         [Fact]
-        public void GlobWithGapsShoulWorkWithNoGaps()
+        public void GlobWithGapsShouldWorkWithNoGaps()
         {
             var glob = new MSBuildGlobWithGaps(MSBuildGlob.Parse("a*"), Enumerable.Empty<IMSBuildGlob>());
 
@@ -19,7 +19,7 @@ public void GlobWithGapsShoulWorkWithNoGaps()
         }
 
         [Fact]
-        public void GlobWithGapsShoulMatchIfNoGapsMatch()
+        public void GlobWithGapsShouldMatchIfNoGapsMatch()
         {
             var glob = new MSBuildGlobWithGaps(MSBuildGlob.Parse("a*"), MSBuildGlob.Parse("b*"));
 
@@ -27,7 +27,7 @@ public void GlobWithGapsShoulMatchIfNoGapsMatch()
         }
 
         [Fact]
-        public void GlobWithGapsShoulNotMatchIfGapsMatch()
+        public void GlobWithGapsShouldNotMatchIfGapsMatch()
         {
             var glob = new MSBuildGlobWithGaps(MSBuildGlob.Parse("a*"), MSBuildGlob.Parse("*b"));
 
diff --git a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
index d357c472750..c550d10b888 100644
--- a/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
+++ b/src/Build.UnitTests/Globbing/MSBuildGlob_Tests.cs
@@ -90,7 +90,7 @@ public void GlobFromRootWithInvalidPathThrows()
             "../d/e/**",
             "a/b/d/e"
             )]
-        public void GlobWithRelativeFixedDirectoryPartShouldMissmatchTheGlobRoot(string globRoot, string filespec, string expectedFixedDirectoryPart)
+        public void GlobWithRelativeFixedDirectoryPartShouldMismatchTheGlobRoot(string globRoot, string filespec, string expectedFixedDirectoryPart)
         {
             var glob = MSBuildGlob.Parse(globRoot, filespec);
 
diff --git a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
index dc3a40ef3ce..817d408f8a1 100644
--- a/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
+++ b/src/Build.UnitTests/Microsoft.Build.Engine.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <IsPackable>false</IsPackable>
     <AssemblyName>Microsoft.Build.Engine.UnitTests</AssemblyName>
 
diff --git a/src/Build.UnitTests/TargetsFile_Test.cs b/src/Build.UnitTests/TargetsFile_Test.cs
index 3efd05703f6..4a7e4b27904 100644
--- a/src/Build.UnitTests/TargetsFile_Test.cs
+++ b/src/Build.UnitTests/TargetsFile_Test.cs
@@ -32,11 +32,12 @@ public void TargetARM()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>arm</PlatformTarget>
@@ -134,18 +135,18 @@ public void ExplicitAnyCPULibraryProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -186,7 +187,7 @@ public void AnyCPUWinMDObjProjectIsNot32BitPreferred()
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
                     @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>" + outputPath + @"</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -241,10 +242,10 @@ public void ExplicitAnyCPUWinMDObjProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>winmdobj</OutputType>
                         <Configuration>Debug</Configuration>
@@ -253,10 +254,10 @@ public void ExplicitAnyCPUWinMDObjProjectIsNot32BitPreferred()
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
                            we need to be .NET 4.5 or greater -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -298,17 +299,17 @@ public void AnyCPUExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -348,18 +349,18 @@ public void ExplicitAnyCPUExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -400,7 +401,7 @@ public void AnyCPU40ExeProjectIsNot32BitPreferred()
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
                     @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
                         <OutputPath>" + outputPath + @"</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
@@ -434,10 +435,10 @@ public void AnyCPU40ExeProjectIsNot32BitPreferred()
 
         /// <summary>
         /// Check that with an explicit platformtarget of anycpu, exe type assemblies that are 
-        /// targeting .NET 4.0 do not get forced to anycpu32bitpreferred by default. 
+        /// targeting .NET 4.0+ do not get forced to anycpu32bitpreferred by default. 
         /// </summary>
         [Fact]
-        public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
+        public void ExplicitAnyCPUExeProjectIsNot32BitPreferred()
         {
             string file = null;
             string outputPath = Path.GetTempPath() + "\\" + Guid.NewGuid().ToString("N");
@@ -449,18 +450,18 @@ public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Exe</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <PlatformTarget>AnyCPU</PlatformTarget>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                     </Project>
@@ -470,7 +471,7 @@ public void ExplicitAnyCPU40ExeProjectIsNot32BitPreferred()
 
                 project.Build();
 
-                logger.AssertLogContains(" /platform:AnyCPU ");
+                logger.AssertLogContains("Platform=AnyCPU");
             }
             finally
             {
@@ -500,21 +501,21 @@ public void AnyCPUAppContainerExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>AppContainerExe</OutputType>
                         <Configuration>Debug</Configuration>
                       </PropertyGroup>
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
-                           we need to be .NET 4.5 or greater -->
+                           we need to be .NET 4.5 or greater, but 4.8 is on the CI machine -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -556,10 +557,10 @@ public void ExplicitAnyCPUAppContainerExeProjectIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>AppContainerExe</OutputType>
                         <Configuration>Debug</Configuration>
@@ -568,10 +569,10 @@ public void ExplicitAnyCPUAppContainerExeProjectIs32BitPreferred()
                       <!-- For dealing with the case where the Jupiter targets do not exist, in order to follow the appropriate codepaths in the standard managed
                            we need to be .NET 4.5 or greater -->
                       <PropertyGroup Condition=`!Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')`>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -613,19 +614,19 @@ public void AnyCPULibraryProjectIs32BitPreferredIfPrefer32BitSet()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`Current` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <Prefer32Bit>true</Prefer32Bit>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                    </Project>
@@ -665,17 +666,17 @@ public void AnyCPUProjectWithNoExplicitOutputTypeIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                    </Project>
@@ -715,17 +716,17 @@ public void AnyCPUJupiterProjectWithNoExplicitOutputTypeIs32BitPreferred()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
-                   <Project DefaultTargets=`Build` ToolsVersion=`4.0` xmlns=`msbuildnamespace`>
+                    $@"
+                   <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <Configuration>Debug</Configuration>
                         <PlatformTarget>AnyCPU</PlatformTarget>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + file + @"` />
+                        <Compile Include=`{file}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets` Condition=`Exists('$(MSBuildExtensionsPath)\Microsoft\WindowsXaml\v1.0\Microsoft.Windows.UI.Xaml.CSharp.targets')` />
                       <!-- Fall back to CSharp targets for the sake of this test if the Jupiter targets don't exist, since what we're testing can be equally well resolved by either -->
@@ -867,20 +868,20 @@ public void NoLinkMetadataSynthesisWhenDefinedInProject()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>true</SynthesizeLinkMetadata>
                       </PropertyGroup>
                       <ItemGroup>
-                        <Compile Include=`" + files[0] + @"` />
-                        <None Include=`" + files[1] + @"` />
-                        <Content Include=`" + files[2] + @"` />
+                        <Compile Include=`{files[0]}` />
+                        <None Include=`{files[1]}` />
+                        <Content Include=`{files[2]}` />
                       </ItemGroup>
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
@@ -952,17 +953,17 @@ public void SynthesizeLinkMetadataForItemsOnWhitelist()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>true</SynthesizeLinkMetadata>
                       </PropertyGroup>
-                      <Import Project=`" + files[3] + @"` />
+                      <Import Project=`{files[3]}` />
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
                         <Message Text=`%(Compile.Identity): [%(Compile.Link)]` />
@@ -1030,17 +1031,17 @@ public void DontSynthesizeLinkMetadataIfPropertyNotSet()
                 MockLogger logger = new MockLogger();
 
                 Project project = ObjectModelHelpers.CreateInMemoryProject(
-                    @"
+                    $@"
                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
                       <PropertyGroup>
-                        <OutputPath>" + outputPath + @"</OutputPath>
+                        <OutputPath>{outputPath}</OutputPath>
                         <AssemblyName>MyAssembly</AssemblyName>
                         <OutputType>Library</OutputType>
                         <Configuration>Debug</Configuration>
-                        <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+                        <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                         <SynthesizeLinkMetadata>false</SynthesizeLinkMetadata>
                       </PropertyGroup>
-                      <Import Project=`" + files[3] + @"` />
+                      <Import Project=`{files[3]}` />
                       <Import Project=`$(MSBuildToolsPath)\Microsoft.CSharp.targets` />
                       <Target Name=`AfterBuild`>
                         <Message Text=`%(Compile.Identity): [%(Compile.Link)]` />
diff --git a/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs b/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
index a8a88862e4f..a9ba7b26914 100644
--- a/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
+++ b/src/Build.UnitTests/TestComparers/ProjectInstanceModelTestComparers.cs
@@ -183,6 +183,12 @@ public bool Equals(ProjectItemGroupTaskItemInstance x, ProjectItemGroupTaskItemI
                 Assert.Equal(x.RemoveMetadataLocation, y.RemoveMetadataLocation, new Helpers.ElementLocationComparerIgnoringType());
                 Assert.Equal(x.ConditionLocation, y.ConditionLocation, new Helpers.ElementLocationComparerIgnoringType());
 
+                Assert.Equal(x.MatchOnMetadata, y.MatchOnMetadata);
+                Assert.Equal(x.MatchOnMetadataLocation, y.MatchOnMetadataLocation, new Helpers.ElementLocationComparerIgnoringType());
+
+                Assert.Equal(x.MatchOnMetadataOptions, y.MatchOnMetadataOptions);
+                Assert.Equal(x.MatchOnMetadataOptionsLocation, y.MatchOnMetadataOptionsLocation, new Helpers.ElementLocationComparerIgnoringType());
+
                 Assert.Equal(x.Metadata, y.Metadata, new TargetItemMetadataComparer());
 
                 return true;
diff --git a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
index d83d61361fa..e8ead4b2e98 100644
--- a/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
+++ b/src/Build.UnitTests/WarningsAsMessagesAndErrors_Tests.cs
@@ -417,6 +417,9 @@ public void TaskReturnsFailureButDoesNotLogError_ShouldCauseBuildFailure()
             }
         }
 
+        /// <summary>
+        /// Test that a task that returns false without logging anything reports MSB4181 as a warning.
+        /// </summary>
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue()
         {
@@ -439,6 +442,31 @@ public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_WarnAndContinue
             }
         }
 
+        /// <summary>
+        /// Test that a task that returns false after logging an error->warning does NOT also log MSB4181
+        /// </summary>
+        [Fact]
+        public void TaskReturnsFailureAndLogsError_ContinueOnError_WarnAndContinue()
+        {
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                TransientTestProjectWithFiles proj = env.CreateTestProjectWithFiles($@"
+                <Project>
+                    <UsingTask TaskName = ""CustomLogAndReturnTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <UsingTask TaskName = ""ReturnFailureWithoutLoggingErrorTask"" AssemblyName=""Microsoft.Build.Engine.UnitTests""/>
+                    <Target Name='Build'>
+                        <CustomLogAndReturnTask Return=""false"" ErrorCode=""MSB1234"" ContinueOnError=""WarnAndContinue""/>
+                    </Target>
+                </Project>");
+
+                MockLogger logger = proj.BuildProjectExpectSuccess();
+
+                // The only warning should be the error->warning logged by the task.
+                logger.WarningCount.ShouldBe(1);
+                logger.AssertLogContains("MSB1234");
+            }
+        }
+
         [Fact]
         public void TaskReturnsFailureButDoesNotLogError_ContinueOnError_True()
         {
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index ddabf21013b..a07d1e40557 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -20,7 +20,6 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
@@ -31,7 +30,6 @@
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
-using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
index 132cb665bb1..5f73ac08e8b 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointOutOfProc.cs
@@ -29,12 +29,10 @@ internal class NodeEndpointOutOfProc : NodeEndpointOutOfProcBase
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
         /// <param name="host">The component host.</param>
         /// <param name="enableReuse">Whether this node may be reused for a later build.</param>
         /// <param name="lowPriority">Whether this node is low priority.</param>
         internal NodeEndpointOutOfProc(
-            string pipeName, 
             IBuildComponentHost host,
             bool enableReuse,
             bool lowPriority)
@@ -44,7 +42,7 @@ internal NodeEndpointOutOfProc(
             _enableReuse = enableReuse;
             _lowPriority = lowPriority;
 
-            InternalConstruct(pipeName);
+            InternalConstruct();
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
index 11ea72ba505..3472c8ff01d 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProc.cs
@@ -76,7 +76,7 @@ public bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration
         {
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
 
-            if (_nodeContexts.Count == ComponentHost.BuildParameters.MaxNodeCount)
+            if (_nodeContexts.Count >= ComponentHost.BuildParameters.MaxNodeCount)
             {
                 ErrorUtilities.ThrowInternalError("All allowable nodes already created ({0}).", _nodeContexts.Count);
                 return false;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index ef21df23454..9d7adfb26a6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -355,7 +355,7 @@ private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStrea
         private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
         {
             // Try and connect to the process.
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + nodeProcessId);
+            string pipeName = NamedPipeUtil.GetPipeNameOrPath(nodeProcessId);
 
             NamedPipeClientStream nodeStream = new NamedPipeClientStream(".", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous
 #if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
@@ -590,7 +590,7 @@ private static string GetCurrentHost()
 #if RUNTIME_TYPE_NETCORE || MONO
             if (CurrentHost == null)
             {
-                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, 2),
+                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
                     NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet");
                 if (File.Exists(dotnetExe))
                 {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 2a917d6eaee..5d6c5f8f2cc 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -372,7 +372,9 @@ internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostConte
 
                     if (s_msbuildName == null)
                     {
-                        s_msbuildName = "MSBuild.exe";
+                        s_msbuildName = (hostContext & HandshakeOptions.NET) == HandshakeOptions.NET
+                            ? "MSBuild.dll"
+                            : "MSBuild.exe";
                     }
                 }
 
@@ -498,7 +500,7 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
             ErrorUtilities.VerifyThrowArgumentNull(factory, nameof(factory));
             ErrorUtilities.VerifyThrow(!_nodeIdToPacketFactory.ContainsKey((int)hostContext), "We should not already have a factory for this context!  Did we forget to call DisconnectFromHost somewhere?");
 
-            if (AvailableNodes == 0)
+            if (AvailableNodes <= 0)
             {
                 ErrorUtilities.ThrowInternalError("All allowable nodes already created ({0}).", _nodeContexts.Count);
                 return false;
diff --git a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
index 4e6e5be0145..57c0e51523e 100644
--- a/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
+++ b/src/Build/BackEnd/Components/Logging/BuildEventArgTransportSink.cs
@@ -121,7 +121,7 @@ public IDictionary<int, ISet<string>> WarningsAsMessagesByProject
         /// </summary>
         public void Consume(BuildEventArgs buildEvent)
         {
-            ErrorUtilities.VerifyThrow(false, "Do not use this method for the transport sink");
+            ErrorUtilities.ThrowInternalError("Do not use this method for the transport sink");
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index 97b7512d14e..a393d6c36a8 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -280,7 +280,7 @@ public void Consume(BuildEventArgs buildEvent)
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Unknown event args type.");
+                ErrorUtilities.ThrowInternalError("Unknown event args type.");
             }
         }
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 19ed313b922..117f5195448 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -1417,7 +1417,7 @@ private void RouteBuildEvent(object loggingEvent)
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Unknown logging item in queue:" + loggingEvent.GetType().FullName);
+                ErrorUtilities.ThrowInternalError("Unknown logging item in queue:" + loggingEvent.GetType().FullName);
             }
 
             if (buildEventArgs is BuildWarningEventArgs warningEvent)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index 3e676950ea5..3fde04be279 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -156,8 +156,7 @@ ElementLocation elementLocation
                         // to really loop here... it's just that the foreach is the only way I can
                         // figure out how to get data out of the hashtable without knowing any of the
                         // keys!
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false,
-                            elementLocation, "CannotReferenceItemMetadataWithoutItemName", unqualifiedMetadataName);
+                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "CannotReferenceItemMetadataWithoutItemName", unqualifiedMetadataName);
                     }
                 }
                 else
@@ -410,7 +409,7 @@ ElementLocation elementLocation
                     }
                     catch (InvalidOperationException e)
                     {
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation,
+                        ProjectErrorUtilities.ThrowInvalidProject(elementLocation,
                             "CannotEvaluateItemMetadata", metadataName, e.Message);
                     }
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 109cb49b9bf..165b1f2b427 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -28,8 +28,6 @@ internal class ItemGroupIntrinsicTask : IntrinsicTask
         /// </summary>
         private ProjectItemGroupTaskInstance _taskInstance;
 
-        private EngineFileUtilities _engineFileUtilities;
-
         /// <summary>
         /// Instantiates an ItemGroup task
         /// </summary>
@@ -41,7 +39,6 @@ public ItemGroupIntrinsicTask(ProjectItemGroupTaskInstance taskInstance, TargetL
             : base(loggingContext, projectInstance, logTaskInputs)
         {
             _taskInstance = taskInstance;
-            _engineFileUtilities = EngineFileUtilities.Default;
         }
 
         /// <summary>
@@ -431,7 +428,7 @@ ISet<string> removeMetadata
                     // The expression is not of the form "@(X)". Treat as string
 
                     // Pass the non wildcard expanded excludes here to fix https://github.com/Microsoft/msbuild/issues/2621
-                    string[] includeSplitFiles = _engineFileUtilities.GetFileListEscaped(
+                    string[] includeSplitFiles = EngineFileUtilities.GetFileListEscaped(
                         Project.Directory,
                         includeSplit,
                         excludes);
@@ -455,7 +452,7 @@ ISet<string> removeMetadata
 
             foreach (string excludeSplit in excludes)
             {
-                string[] excludeSplitFiles = _engineFileUtilities.GetFileListUnescaped(Project.Directory, excludeSplit);
+                string[] excludeSplitFiles = EngineFileUtilities.GetFileListUnescaped(Project.Directory, excludeSplit);
 
                 foreach (string excludeSplitFile in excludeSplitFiles)
                 {
@@ -540,7 +537,7 @@ Expander<ProjectPropertyInstance, ProjectItemInstance> expander
                 // Don't unescape wildcards just yet - if there were any escaped, the caller wants to treat them
                 // as literals. Everything else is safe to unescape at this point, since we're only matching
                 // against the file system.
-                string[] fileList = _engineFileUtilities.GetFileListEscaped(Project.Directory, piece);
+                string[] fileList = EngineFileUtilities.GetFileListEscaped(Project.Directory, piece);
 
                 foreach (string file in fileList)
                 {
@@ -586,7 +583,7 @@ private List<ProjectItemInstance> FindItemsMatchingMetadataSpecification(
             ItemSpec<ProjectPropertyInstance, ProjectItemInstance> itemSpec = new ItemSpec<ProjectPropertyInstance, ProjectItemInstance>(child.Remove, expander, child.RemoveLocation, Project.Directory, true);
             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
                 itemSpec.Fragments.All(f => f is ItemSpec<ProjectPropertyInstance, ProjectItemInstance>.ItemExpressionFragment),
-                new BuildEventFileInfo(string.Empty),
+                BuildEventFileInfo.Empty,
                 "OM_MatchOnMetadataIsRestrictedToReferencedItems",
                 child.RemoveLocation,
                 child.Remove);
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 5fdd1a3e145..efe47bf3381 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -709,7 +709,7 @@ private void UpdateContinueOnError(ItemBucket bucket, TaskHost taskHost)
                 catch (ArgumentException e)
                 {
                     // handle errors in string-->bool conversion
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _taskNode.ContinueOnErrorLocation, "InvalidContinueOnErrorAttribute", _taskNode.Name, e.Message);
+                    ProjectErrorUtilities.ThrowInvalidProject(_taskNode.ContinueOnErrorLocation, "InvalidContinueOnErrorAttribute", _taskNode.Name, e.Message);
                 }
             }
 
@@ -740,7 +740,7 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
             if (!taskExecutionHost.SetTaskParameters(_taskNode.ParametersForBuild))
             {
                 // The task cannot be initialized.
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, _targetChildInstance.Location, "TaskParametersError", _taskNode.Name, String.Empty);
+                ProjectErrorUtilities.ThrowInvalidProject(_targetChildInstance.Location, "TaskParametersError", _taskNode.Name, String.Empty);
             }
             else
             {
@@ -938,8 +938,14 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                 // that is logged as an error. MSBuild tasks are an exception because
                 // errors are not logged directly from them, but the tasks spawned by them.
                 IBuildEngine be = host.TaskInstance.BuildEngine;
-                if (taskReturned && !taskResult && !taskLoggingContext.HasLoggedErrors && (be is TaskHost th ? th.BuildRequestsSucceeded : false) && (be is IBuildEngine7 be7 ? !be7.AllowFailureWithoutError : true))
+                if (taskReturned // if the task returned
+                    && !taskResult // and it returned false
+                    && !taskLoggingContext.HasLoggedErrors // and it didn't log any errors
+                    && (be is TaskHost th ? th.BuildRequestsSucceeded : false)
+                    && (be is IBuildEngine7 be7 ? !be7.AllowFailureWithoutError : true) // and it's not allowed to fail unless it logs an error
+                    && !(_cancellationToken.CanBeCanceled && _cancellationToken.IsCancellationRequested)) // and it wasn't cancelled
                 {
+                    // Then decide how to log MSB4181
                     if (_continueOnError == ContinueOnError.WarnAndContinue)
                     {
                         taskLoggingContext.LogWarning(null,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 154ace42f96..0c07dae6d6f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -455,8 +455,9 @@ public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
                 {
                     e.BuildEventContext = _taskLoggingContext.BuildEventContext;
                     _taskLoggingContext.LoggingService.LogBuildEvent(e);
-                    _taskLoggingContext.HasLoggedErrors = true;
                 }
+                
+                 _taskLoggingContext.HasLoggedErrors = true;
             }
         }
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 3f541b05568..23c505ff896 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -35,6 +36,8 @@ public override void ClearCaches()
 
         public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
         {
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStart(sdk.Name, solutionPath, projectPath);
+
             SdkResult result;
 
             if (Traits.Instance.EscapeHatches.DisableSdkResolutionCache)
@@ -44,7 +47,9 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
             else
             {
                 // Get the dictionary for the specified submission if one is already added otherwise create a new dictionary for the submission.
-                ConcurrentDictionary<string, Lazy<SdkResult>> cached = _cache.GetOrAdd(submissionId, new ConcurrentDictionary<string, Lazy<SdkResult>>(MSBuildNameIgnoreCaseComparer.Default));
+                ConcurrentDictionary<string, Lazy<SdkResult>> cached = _cache.GetOrAdd(
+                    submissionId,
+                    _ => new ConcurrentDictionary<string, Lazy<SdkResult>>(MSBuildNameIgnoreCaseComparer.Default));
 
                 /*
                  * Get a Lazy<SdkResult> if available, otherwise create a Lazy<SdkResult> which will resolve the SDK with the SdkResolverService.Instance.  If multiple projects are attempting to resolve
@@ -66,6 +71,8 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                 loggingContext.LogWarning(null, new BuildEventFileInfo(sdkReferenceLocation), "ReferencingMultipleVersionsOfTheSameSdk", sdk.Name, result.Version, result.ElementLocation, sdk.Version);
             }
 
+            MSBuildEventSource.Log.CachedSdkResolverServiceResolveSdkStop(sdk.Name, solutionPath, projectPath, result.Success);
+
             return result;
         }
     }
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 6f90dacaeb4..ff98112817b 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -11,6 +11,7 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Reflection;
+using Microsoft.Build.Eventing;
 
 namespace Microsoft.Build.BackEnd.SdkResolution
 {
@@ -115,7 +116,9 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
 
                 try
                 {
+                    MSBuildEventSource.Log.SdkResolverResolveSdkStart();
                     result = (SdkResult)sdkResolver.Resolve(sdk, context, resultFactory);
+                    MSBuildEventSource.Log.SdkResolverResolveSdkStop(sdkResolver.Name, sdk.Name, solutionPath, projectPath, result?.Path, result?.Success ?? false);
                 }
                 catch (Exception e) when ((e is FileNotFoundException || e is FileLoadException) && sdkResolver.GetType().GetTypeInfo().Name.Equals("NuGetSdkResolver", StringComparison.Ordinal))
                 {
@@ -232,8 +235,11 @@ private void Initialize(LoggingContext loggingContext, ElementLocation location)
                     return;
                 }
 
+                MSBuildEventSource.Log.SdkResolverServiceInitializeStart();
                 _resolvers = _sdkResolverLoader.LoadResolvers(loggingContext, location);
+                MSBuildEventSource.Log.SdkResolverServiceInitializeStop(_resolvers.Count);
             }
+
         }
 
         private void SetResolverState(int submissionId, SdkResolver resolver, object state)
@@ -241,7 +247,9 @@ private void SetResolverState(int submissionId, SdkResolver resolver, object sta
             // Do not set state for resolution requests that are not associated with a valid build submission ID
             if (submissionId != BuildEventContext.InvalidSubmissionId)
             {
-                ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(submissionId, new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));
+                ConcurrentDictionary<SdkResolver, object> resolverState = _resolverStateBySubmission.GetOrAdd(
+                    submissionId,
+                    _ => new ConcurrentDictionary<SdkResolver, object>(NativeMethodsShared.GetLogicalCoreCount(), _resolvers.Count));
 
                 resolverState.AddOrUpdate(resolver, state, (sdkResolver, obj) => state);
             }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 9e500181510..ae59a7b50af 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -239,9 +239,8 @@ public NodeEngineShutdownReason Run(bool enableReuse, out Exception shutdownExce
         public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, out Exception shutdownException)
         {
             // Console.WriteLine("Run called at {0}", DateTime.Now);
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath("MSBuild" + Process.GetCurrentProcess().Id);
 
-            _nodeEndpoint = new NodeEndpointOutOfProc(pipeName, this, enableReuse, lowPriority);
+            _nodeEndpoint = new NodeEndpointOutOfProc(this, enableReuse, lowPriority);
             _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
             _nodeEndpoint.Listen(this);
 
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 2cc6ab1f7b4..6d55273c55c 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -768,7 +768,7 @@ Func<string, bool> GetReferenceFilter()
                     }
 
                     var fragments = items.SelectMany(i => ExpressionShredder.SplitSemiColonSeparatedList(i.EvaluatedInclude));
-                    var glob = new CompositeGlob(
+                    var glob = CompositeGlob.Create(
                         fragments
                             .Select(s => MSBuildGlob.Parse(Project.Directory, s)));
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index f6a291d929c..77497354b7b 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -12,7 +12,6 @@
 #endif
 using System.Text;
 using System.Threading;
-using System.Threading.Tasks;
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Construction;
@@ -442,9 +441,8 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                 }
                 else
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject
+                    ProjectErrorUtilities.ThrowInvalidProject
                     (
-                        false,
                         parameterLocation,
                         "UnsupportedTaskParameterTypeError",
                         parameter.PropertyType.FullName,
@@ -482,9 +480,8 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
 
                 // We do not recover from a task exception while getting outputs,
                 // so do not merely set gatheredGeneratedOutputsSuccessfully = false; here
-                ProjectErrorUtilities.VerifyThrowInvalidProject
+                ProjectErrorUtilities.ThrowInvalidProject
                 (
-                    false,
                     parameterLocation,
                     "FailedToRetrieveTaskOutputs",
                     _taskName,
@@ -500,9 +497,8 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                     throw;
                 }
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject
+                ProjectErrorUtilities.ThrowInvalidProject
                 (
-                    false,
                     parameterLocation,
                     "FailedToRetrieveTaskOutputs",
                     _taskName,
@@ -1183,11 +1179,9 @@ out bool taskParameterSet
                         {
                             // We only allow a single item to be passed into a parameter of ITaskItem.
 
-                            // Some of the computation (expansion) here is expensive, so don't make the above
-                            // "if" statement directly part of the first param to VerifyThrowInvalidProject.
-                            ProjectErrorUtilities.VerifyThrowInvalidProject
+                            // Some of the computation (expansion) here is expensive, so don't switch to VerifyThrowInvalidProject.
+                            ProjectErrorUtilities.ThrowInvalidProject
                                 (
-                                false,
                                 parameterLocation,
                                 "CannotPassMultipleItemsIntoScalarParameter",
                                 _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation),
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 80d7bdaad22..c1e3f8efe62 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -8,7 +8,9 @@
 using System.Security;
 using System.Text;
 using System.Xml;
+#if !NETFRAMEWORK || MONO
 using Microsoft.Build.Shared;
+#endif
 
 using XMakeAttributes = Microsoft.Build.Shared.XMakeAttributes;
 using ProjectFileErrorUtilities = Microsoft.Build.Shared.ProjectFileErrorUtilities;
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 625352ba374..43318152844 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -1133,9 +1133,8 @@ private bool CanBuildDirectly(ProjectInstance traversalProject, ProjectInSolutio
                 {
                     if (!_solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
                     {
-                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                        ProjectFileErrorUtilities.ThrowInvalidProjectFile
                             (
-                            false,
                             "SubCategoryForSolutionParsingErrors",
                             new BuildEventFileInfo(traversalProject.FullPath),
                             "SolutionParseProjectDepNotFoundError",
@@ -1206,9 +1205,8 @@ private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, Proj
             if (project.ProjectType == SolutionProjectType.WebProject)
             {
 #if !FEATURE_ASPNET_COMPILER
-                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile
                     (
-                    false,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(_solutionFile.FullPath),
                     "AspNetCompiler.UnsupportedMSBuildVersion",
@@ -1295,9 +1293,8 @@ private void AddMetaprojectReferenceItems(ProjectInstance traversalProject, Proj
             {
                 if (!_solutionFile.ProjectsByGuid.TryGetValue(dependencyProjectGuid, out ProjectInSolution dependencyProject))
                 {
-                    ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile
                         (
-                        false,
                         "SubCategoryForSolutionParsingErrors",
                         new BuildEventFileInfo(traversalProject.FullPath),
                         "SolutionParseProjectDepNotFoundError",
@@ -1557,9 +1554,8 @@ private void ValidateTargetFrameworkForWebProject(ProjectInSolution project)
             }
             if (!isDotNetFramework)
             {
-                ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                ProjectFileErrorUtilities.ThrowInvalidProjectFile
                     (
-                    false,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(_solutionFile.FullPath),
                     "AspNetCompiler.InvalidTargetFrameworkMonikerNotDotNET",
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index d842373c86c..df1d8ed8eb4 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -32,6 +32,7 @@
 using EvaluationItemSpec = Microsoft.Build.Evaluation.ItemSpec<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>;
 using EvaluationItemExpressionFragment = Microsoft.Build.Evaluation.ItemSpec<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>.ItemExpressionFragment;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
+using Microsoft.Build.FileSystem;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -68,6 +69,11 @@ public class Project : ILinkableObject
         internal ProjectLink Link => implementation;
         object ILinkableObject.Link => IsLinked ? Link : null;
 
+        /// <summary>
+        /// Host-provided factory for <see cref="IDirectoryCache"/> interfaces to be used during evaluation.
+        /// </summary>
+        private readonly IDirectoryCacheFactory _directoryCacheFactory;
+
         /// <summary>
         /// Default project template options (include all features).
         /// </summary>
@@ -250,20 +256,22 @@ public Project(ProjectRootElement xml, IDictionary<string, string> globalPropert
         /// <param name="projectCollection">The <see cref="ProjectCollection"/> the project is added to.</param>
         /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
         public Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
         {
         }
 
-        private Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+        private Project(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
             ProjectCollection = projectCollection;
-            var defaultImplementation = new ProjectImpl(this, xml, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            var defaultImplementation = new ProjectImpl(this, xml, globalProperties, toolsVersion, subToolsetVersion, loadSettings);
             implementationInternal = (IProjectLinkInternal)defaultImplementation;
             implementation = defaultImplementation;
 
+            _directoryCacheFactory = directoryCacheFactory;
             defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
         }
 
@@ -342,21 +350,23 @@ public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null)
+            : this(xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
         {
         }
 
-        private Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+        private Project(XmlReader xmlReader, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xmlReader, nameof(xmlReader));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
             ProjectCollection = projectCollection;
-            var defailtImplementation = new ProjectImpl(this, xmlReader, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
-            implementationInternal = (IProjectLinkInternal)defailtImplementation;
-            implementation = defailtImplementation;
+            var defaultImplementation = new ProjectImpl(this, xmlReader, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            implementationInternal = (IProjectLinkInternal)defaultImplementation;
+            implementation = defaultImplementation;
 
-            defailtImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            _directoryCacheFactory = directoryCacheFactory;
+            defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
         }
 
         /// <summary>
@@ -436,26 +446,29 @@ public Project(string projectFile, IDictionary<string, string> globalProperties,
         /// <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
         /// <param name="loadSettings">The load settings for this project.</param>
         public Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings)
-            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings, null, null)
         {
         }
 
-        private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+        private Project(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings,
+            EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, nameof(projectFile));
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
             ErrorUtilities.VerifyThrowArgumentNull(projectCollection, nameof(projectCollection));
 
             ProjectCollection = projectCollection;
-            var defailtImplementation = new ProjectImpl(this, projectFile, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
-            implementationInternal = (IProjectLinkInternal)defailtImplementation;
-            implementation = defailtImplementation;
+            var defaultImplementation = new ProjectImpl(this, projectFile, globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+            implementationInternal = (IProjectLinkInternal)defaultImplementation;
+            implementation = defaultImplementation;
+
+            _directoryCacheFactory = directoryCacheFactory;
 
             // Note: not sure why only this ctor flavor do TryUnloadProject
             // seems the XmlReader based one should also clean the same way.
             try
             {
-                defailtImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
+                defaultImplementation.Initialize(globalProperties, toolsVersion, subToolsetVersion, loadSettings, evaluationContext);
             }
             catch (Exception ex)
             {
@@ -488,7 +501,8 @@ public static Project FromFile(string file, ProjectOptions options)
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.DirectoryCacheFactory);
         }
 
         /// <summary>
@@ -505,7 +519,8 @@ public static Project FromProjectRootElement(ProjectRootElement rootElement, Pro
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.DirectoryCacheFactory);
         }
 
         /// <summary>
@@ -522,7 +537,8 @@ public static Project FromXmlReader(XmlReader reader, ProjectOptions options)
                 options.SubToolsetVersion,
                 options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
                 options.LoadSettings,
-                options.EvaluationContext);
+                options.EvaluationContext,
+                options.DirectoryCacheFactory);
         }
 
         /// <summary>
@@ -1767,6 +1783,18 @@ internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml
             ErrorUtilities.VerifyThrowInvalidOperation(ReferenceEquals(Xml, otherXml), "OM_CannotModifyEvaluatedObjectInImportedFile", otherXml.Location.File);
         }
 
+        /// <summary>
+        /// Returns <see cref="IDirectoryCache"/> as provided by the <see cref="IDirectoryCacheFactory"/> passed when creating the
+        /// project, specific for a given evaluation ID.
+        /// </summary>
+        /// <param name="evaluationId">The evaluation ID for which the cache is requested.</param>
+        /// <returns>An <see cref="IDirectoryCache"/> implementation, or null if this project has no <see cref="IDirectoryCacheFactory"/>
+        /// associated with it or it returned null.</returns>
+        internal IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId)
+        {
+            return _directoryCacheFactory?.GetDirectoryCacheForEvaluation(evaluationId);
+        }
+
         /// <summary>
         /// Internal project evaluation implementation.
         /// </summary>
@@ -1829,8 +1857,7 @@ private class ProjectImpl : ProjectLink, IProjectLinkInternal
             /// <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
             /// <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
             /// <param name="loadSettings">The <see cref="ProjectLoadSettings"/> to use for evaluation.</param>
-            /// <param name="evaluationContext">The evaluation context to use in case reevaluation is required.</param>
-            public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext)
+            public ProjectImpl(Project owner, ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectLoadSettings loadSettings)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(xml, nameof(xml));
                 ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, nameof(toolsVersion));
@@ -2548,7 +2575,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                 }
 
                 ImmutableArray<string> includeGlobStrings = includeGlobFragments.Select(f => f.TextFragment).ToImmutableArray();
-                var includeGlob = new CompositeGlob(includeGlobFragments.Select(f => f.ToMSBuildGlob()));
+                var includeGlob = CompositeGlob.Create(includeGlobFragments.Select(f => f.ToMSBuildGlob()));
 
                 IEnumerable<string> excludeFragmentStrings = Enumerable.Empty<string>();
                 IMSBuildGlob excludeGlob = null;
@@ -2567,7 +2594,7 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
                 if (removeElementCache.TryGetValue(itemElement.ItemType, out CumulativeRemoveElementData removeItemElement))
                 {
                     removeFragmentStrings = removeItemElement.FragmentStrings;
-                    removeGlob = new CompositeGlob(removeItemElement.Globs);
+                    removeGlob = CompositeGlob.Create(removeItemElement.Globs);
                 }
 
                 var includeGlobWithGaps = CreateIncludeGlobWithGaps(includeGlob, excludeGlob, removeGlob);
@@ -2577,17 +2604,13 @@ private GlobResult BuildGlobResultFromIncludeItem(ProjectItemElement itemElement
 
             private static IMSBuildGlob CreateIncludeGlobWithGaps(IMSBuildGlob includeGlob, IMSBuildGlob excludeGlob, IMSBuildGlob removeGlob)
             {
-                if (excludeGlob == null)
+                return (excludeGlob, removeGlob) switch
                 {
-                    return removeGlob == null ? includeGlob :
-                        new MSBuildGlobWithGaps(includeGlob, removeGlob);
-                }
-                else
-                {
-                    return new MSBuildGlobWithGaps(includeGlob,
-                        removeGlob == null ? excludeGlob :
-                        new CompositeGlob(excludeGlob, removeGlob));
-                }
+                    (null,     null)     => includeGlob,
+                    (not null, null)     => new MSBuildGlobWithGaps(includeGlob, excludeGlob),
+                    (null,     not null) => new MSBuildGlobWithGaps(includeGlob, removeGlob),
+                    (not null, not null) => new MSBuildGlobWithGaps(includeGlob, new CompositeGlob(excludeGlob, removeGlob))
+                };
             }
 
             private void CacheInformationFromRemoveItem(ProjectItemElement itemElement, Dictionary<string, CumulativeRemoveElementData> removeElementCache)
@@ -3623,6 +3646,7 @@ private void Reevaluate(
 
                 Evaluator<ProjectProperty, ProjectItem, ProjectMetadata, ProjectItemDefinition>.Evaluate(
                     _data,
+                    Owner,
                     Xml,
                     loadSettings,
                     ProjectCollection.MaxNodeCount,
@@ -4164,7 +4188,7 @@ internal Data(Project project, PropertyDictionary<ProjectPropertyInstance> globa
             /// <summary>
             /// Prepares the data object for evaluation.
             /// </summary>
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
             {
                 DefaultTargets = null;
                 Properties = new PropertyDictionary<ProjectProperty>();
@@ -4172,7 +4196,7 @@ public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSyste
                 Items = new ItemDictionary<ProjectItem>();
                 ItemsIgnoringCondition = new ItemDictionary<ProjectItem>();
                 ItemsByEvaluatedIncludeCache = new MultiDictionary<string, ProjectItem>(StringComparer.OrdinalIgnoreCase);
-                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, fileSystem);
+                Expander = new Expander<ProjectProperty, ProjectItem>(Properties, Items, evaluationContext);
                 ItemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinition>(MSBuildNameIgnoreCaseComparer.Default);
                 Targets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
                 ImportClosure = new List<ResolvedImport>();
diff --git a/src/Build/Definition/ProjectOptions.cs b/src/Build/Definition/ProjectOptions.cs
index 44d2ecccfd6..fadfe73a6e3 100644
--- a/src/Build/Definition/ProjectOptions.cs
+++ b/src/Build/Definition/ProjectOptions.cs
@@ -1,6 +1,7 @@
 ﻿using System.Collections.Generic;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.FileSystem;
 
 namespace Microsoft.Build.Definition
 {
@@ -38,5 +39,10 @@ public class ProjectOptions
         /// The <see cref="EvaluationContext"/> to use for evaluation.
         /// </summary>
         public EvaluationContext EvaluationContext { get; set; }
+
+        /// <summary>
+        /// Provides <see cref="IDirectoryCache"/> to be used for evaluation.
+        /// </summary>
+        public IDirectoryCacheFactory DirectoryCacheFactory { get; set; }
     }
 }
diff --git a/src/Build/Definition/Toolset.cs b/src/Build/Definition/Toolset.cs
index 77d32963bf6..b623fed7040 100644
--- a/src/Build/Definition/Toolset.cs
+++ b/src/Build/Definition/Toolset.cs
@@ -920,6 +920,17 @@ private void InitializeProperties(ILoggingService loggingServices, BuildEventCon
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.assemblyVersion, Constants.AssemblyVersion, mayBeReserved: true));
                     reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.version, MSBuildAssemblyFileVersion.Instance.MajorMinorBuild, mayBeReserved: true));
 
+                    reservedProperties.Add(ProjectPropertyInstance.Create(ReservedPropertyNames.msbuildRuntimeType,
+#if RUNTIME_TYPE_NETCORE
+                        "Core",
+#elif MONO
+                        NativeMethodsShared.IsMono ? "Mono" : "Full");
+#else
+                        "Full",
+#endif
+                        mayBeReserved: true));
+
+
                     // Add one for the subtoolset version property -- it may or may not be set depending on whether it has already been set by the
                     // environment or global properties, but it's better to create a dictionary that's one too big than one that's one too small.
                     int count = _environmentProperties.Count + reservedProperties.Count + Properties.Values.Count + _globalProperties.Count + 1;
@@ -1087,7 +1098,7 @@ private void LoadAndRegisterFromTasksFile(string[] defaultTaskFiles, ILoggingSer
                 catch (XmlException e)
                 {
                     // handle XML errors in the default tasks file
-                    ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(false, new BuildEventFileInfo(defaultTasksFile, e), taskFileError, e.Message);
+                    ProjectFileErrorUtilities.ThrowInvalidProjectFile(new BuildEventFileInfo(defaultTasksFile, e), taskFileError, e.Message);
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
diff --git a/src/Build/ElementLocation/XmlAttributeWithLocation.cs b/src/Build/ElementLocation/XmlAttributeWithLocation.cs
index 25820d1d1bb..2a8ad231e60 100644
--- a/src/Build/ElementLocation/XmlAttributeWithLocation.cs
+++ b/src/Build/ElementLocation/XmlAttributeWithLocation.cs
@@ -72,7 +72,7 @@ internal ElementLocation Location
             {
                 // Caching the element location object saves significant memory
                 XmlDocumentWithLocation ownerDocumentWithLocation = (XmlDocumentWithLocation)OwnerDocument;
-                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath, StringComparison.OrdinalIgnoreCase))
+                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath ?? String.Empty, StringComparison.OrdinalIgnoreCase))
                 {
                     _elementLocation = ElementLocation.Create(ownerDocumentWithLocation.FullPath, _elementLocation.Line, _elementLocation.Column);
                 }
@@ -90,4 +90,4 @@ public bool HasLineInfo()
             return Location.Line != 0;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/ElementLocation/XmlDocumentWithLocation.cs b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
index 15c91a6f68e..1b3de4bb5e0 100644
--- a/src/Build/ElementLocation/XmlDocumentWithLocation.cs
+++ b/src/Build/ElementLocation/XmlDocumentWithLocation.cs
@@ -352,24 +352,17 @@ private void DetermineWhetherToLoadReadOnly(string fullPath)
                     // Only files from Microsoft
                     if (Path.GetFileName(fullPath).StartsWith("Microsoft.", StringComparison.OrdinalIgnoreCase))
                     {
-                        // If we are loading devdiv targets, we're in razzle
-                        if (Path.GetFileName(fullPath).StartsWith("Microsoft.DevDiv", StringComparison.OrdinalIgnoreCase))
-                        {
-                            _loadAsReadOnly = true;
-                        }
-                        else // Else, only load if they're in program files or windows directories
-                        {
-                            ErrorUtilities.VerifyThrow(Path.IsPathRooted(fullPath), "should be full path");
-                            string directory = Path.GetDirectoryName(fullPath);
+                        // Load read-only if they're in program files or windows directories
+                        ErrorUtilities.VerifyThrow(Path.IsPathRooted(fullPath), "should be full path");
+                        string directory = Path.GetDirectoryName(fullPath);
 
-                            string windowsFolder = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
+                        string windowsFolder = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
 
-                            if ((!String.IsNullOrEmpty(windowsFolder) && directory.StartsWith(windowsFolder, StringComparison.OrdinalIgnoreCase)) ||
-                                (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles32) && directory.StartsWith(FrameworkLocationHelper.programFiles32, StringComparison.OrdinalIgnoreCase)) ||
-                                (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles64) && directory.StartsWith(FrameworkLocationHelper.programFiles64, StringComparison.OrdinalIgnoreCase)))
-                            {
-                                _loadAsReadOnly = true;
-                            }
+                        if ((!String.IsNullOrEmpty(windowsFolder) && directory.StartsWith(windowsFolder, StringComparison.OrdinalIgnoreCase)) ||
+                            (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles32) && directory.StartsWith(FrameworkLocationHelper.programFiles32, StringComparison.OrdinalIgnoreCase)) ||
+                            (!String.IsNullOrEmpty(FrameworkLocationHelper.programFiles64) && directory.StartsWith(FrameworkLocationHelper.programFiles64, StringComparison.OrdinalIgnoreCase)))
+                        {
+                            _loadAsReadOnly = true;
                         }
                     }
                 }
diff --git a/src/Build/ElementLocation/XmlElementWithLocation.cs b/src/Build/ElementLocation/XmlElementWithLocation.cs
index 7da601d28b2..47446943860 100644
--- a/src/Build/ElementLocation/XmlElementWithLocation.cs
+++ b/src/Build/ElementLocation/XmlElementWithLocation.cs
@@ -92,7 +92,7 @@ internal ElementLocation Location
             {
                 // Caching the element location object saves significant memory
                 XmlDocumentWithLocation ownerDocumentWithLocation = (XmlDocumentWithLocation)OwnerDocument;
-                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath, StringComparison.OrdinalIgnoreCase))
+                if (!String.Equals(_elementLocation.File, ownerDocumentWithLocation.FullPath ?? String.Empty, StringComparison.OrdinalIgnoreCase))
                 {
                     _elementLocation = ElementLocation.Create(ownerDocumentWithLocation.FullPath, _elementLocation.Line, _elementLocation.Column);
                 }
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index 7a1e0aa25ad..56016a76d82 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -33,7 +33,7 @@ public sealed class InternalLoggerException : Exception
         /// <exception cref="InvalidOperationException"></exception>
         public InternalLoggerException()
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(false, "InternalLoggerExceptionOnlyThrownByEngine");
+            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
         }
 
         /// <summary>
@@ -47,7 +47,7 @@ public InternalLoggerException()
         public InternalLoggerException(string message)
             : base(message)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(false, "InternalLoggerExceptionOnlyThrownByEngine");
+            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
         }
 
         /// <summary>
@@ -62,7 +62,7 @@ public InternalLoggerException(string message)
         public InternalLoggerException(string message, Exception innerException)
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(false, "InternalLoggerExceptionOnlyThrownByEngine");
+            ErrorUtilities.ThrowInvalidOperation("InternalLoggerExceptionOnlyThrownByEngine");
         }
 
         #endregion
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index 7b3e099fb4c..69df786fb83 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -18,30 +18,34 @@ internal sealed class AndExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (LeftChild.CanBoolEvaluate(state),
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
                      state.ElementLocation,
                      "ExpressionDoesNotEvaluateToBoolean",
                      LeftChild.GetUnexpandedValue(state),
                      LeftChild.GetExpandedValue(state),
                      state.Condition);
+            }
 
-            if (!LeftChild.BoolEvaluate(state))
+            if (!leftBool)
             {
                 // Short circuit
                 return false;
             }
             else
             {
-                ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (RightChild.CanBoolEvaluate(state),
-                     state.ElementLocation,
-                     "ExpressionDoesNotEvaluateToBoolean",
-                     RightChild.GetUnexpandedValue(state),
-                     RightChild.GetExpandedValue(state),
-                     state.Condition);
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                {
+                    ProjectErrorUtilities.ThrowInvalidProject(
+                         state.ElementLocation,
+                         "ExpressionDoesNotEvaluateToBoolean",
+                         RightChild.GetUnexpandedValue(state),
+                         RightChild.GetExpandedValue(state),
+                         state.Condition);
+                }
 
-                return RightChild.BoolEvaluate(state);
+                return rightBool;
             }
         }
 
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index 12547eaa3ae..d1ffa2a8248 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -90,8 +90,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // We haven't implemented any other "functions"
             else
             {
-                ProjectErrorUtilities.VerifyThrowInvalidProject(
-                    false,
+                ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "UndefinedFunctionCall",
                     state.Condition,
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index d4862fec251..c85b95e088d 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -12,12 +12,9 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class GenericExpressionNode
     {
-        internal abstract bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state);
-        internal abstract Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state);
+        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result);
+        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result);
+        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result);
 
         /// <summary>
         /// Returns true if this node evaluates to an empty string,
@@ -56,14 +53,16 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// <returns></returns>
         internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            ProjectErrorUtilities.VerifyThrowInvalidProject(
-                CanBoolEvaluate(state),
-                state.ElementLocation,
-                "ConditionNotBooleanDetail",
-                state.Condition,
-                GetExpandedValue(state));
-
-            return BoolEvaluate(state);
+            if (!TryBoolEvaluate(state, out bool boolValue))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ConditionNotBooleanDetail",
+                    state.Condition,
+                    GetExpandedValue(state));
+            }
+
+            return boolValue;
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 6a457794da3..18e1caad924 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -48,36 +48,41 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // and we know which do, then we already have enough information to evaluate this expression.
             // That means we don't have to fully expand a condition like " '@(X)' == '' " 
             // which is a performance advantage if @(X) is a huge item list.
-            if (LeftChild.EvaluatesToEmpty(state) || RightChild.EvaluatesToEmpty(state))
+            bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
+            bool rightEmpty = RightChild.EvaluatesToEmpty(state);
+            if (leftEmpty || rightEmpty)
             {
                 UpdateConditionedProperties(state);
 
-                return Compare(LeftChild.EvaluatesToEmpty(state), RightChild.EvaluatesToEmpty(state));
+                return Compare(leftEmpty, rightEmpty);
             }
-
-            if (LeftChild.CanNumericEvaluate(state) && RightChild.CanNumericEvaluate(state))
+            else if (LeftChild.TryNumericEvaluate(state, out double leftNumericValue) && RightChild.TryNumericEvaluate(state, out double rightNumericValue))
             {
-                return Compare(LeftChild.NumericEvaluate(state), RightChild.NumericEvaluate(state));
+                // The left child evaluating to a number and the right child not evaluating to a number
+                // is insufficient to say they are not equal because $(MSBuildToolsVersion) evaluates to
+                // the string "Current" most of the time but when doing numeric comparisons, is treated
+                // as a version and returns "17.0" (or whatever the current tools version is). This means
+                // that if '$(MSBuildToolsVersion)' is "equal" to BOTH '17.0' and 'Current' (if 'Current'
+                // is 17.0).
+                return Compare(leftNumericValue, rightNumericValue);
             }
-            else if (LeftChild.CanBoolEvaluate(state) && RightChild.CanBoolEvaluate(state))
+            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue))
             {
-                return Compare(LeftChild.BoolEvaluate(state), RightChild.BoolEvaluate(state));
+                return Compare(leftBoolValue, rightBoolValue);
             }
-            else // string comparison
-            {
-                string leftExpandedValue = LeftChild.GetExpandedValue(state);
-                string rightExpandedValue = RightChild.GetExpandedValue(state);
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (leftExpandedValue != null && rightExpandedValue != null,
-                     state.ElementLocation,
-                     "IllFormedCondition",
-                     state.Condition);
+            string leftExpandedValue = LeftChild.GetExpandedValue(state);
+            string rightExpandedValue = RightChild.GetExpandedValue(state);
 
-                UpdateConditionedProperties(state);
+            ProjectErrorUtilities.VerifyThrowInvalidProject
+                (leftExpandedValue != null && rightExpandedValue != null,
+                    state.ElementLocation,
+                    "IllFormedCondition",
+                    state.Condition);
 
-                return Compare(leftExpandedValue, rightExpandedValue);
-            }
+            UpdateConditionedProperties(state);
+
+            return Compare(leftExpandedValue, rightExpandedValue);
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index 0a2521feda7..2f5dd07d112 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Shared;
 using System.Diagnostics;
 
 namespace Microsoft.Build.Evaluation
@@ -17,12 +18,17 @@ internal sealed class NotExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            return !LeftChild.BoolEvaluate(state);
-        }
+            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ExpressionDoesNotEvaluateToBoolean",
+                    LeftChild.GetUnexpandedValue(state),
+                    LeftChild.GetExpandedValue(state),
+                    state.Condition);
+            }
 
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            return LeftChild.CanBoolEvaluate(state);
+            return !boolValue;
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index 0bd30600cbf..a86a3031bb3 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -38,46 +38,31 @@ internal abstract class NumericComparisonExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            bool isLeftNum = LeftChild.CanNumericEvaluate(state);
-            bool isLeftVersion = LeftChild.CanVersionEvaluate(state);
-            bool isRightNum = RightChild.CanNumericEvaluate(state);
-            bool isRightVersion = RightChild.CanVersionEvaluate(state);
-            bool isNumeric = isLeftNum && isRightNum;
-            bool isVersion = isLeftVersion && isRightVersion;
-            bool isValidComparison = isNumeric || isVersion || (isLeftNum && isRightVersion) || (isLeftVersion && isRightNum);
+            bool isLeftNum = LeftChild.TryNumericEvaluate(state, out double leftNum);
+            bool isLeftVersion = LeftChild.TryVersionEvaluate(state, out Version leftVersion);
+            bool isRightNum = RightChild.TryNumericEvaluate(state, out double rightNum);
+            bool isRightVersion = RightChild.TryVersionEvaluate(state, out Version rightVersion);
 
-            ProjectErrorUtilities.VerifyThrowInvalidProject
-                (isValidComparison,
-                 state.ElementLocation,
-                "ComparisonOnNonNumericExpression",
-                 state.Condition,
-                 /* helpfully display unexpanded token and expanded result in error message */
-                 LeftChild.CanNumericEvaluate(state) ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
-                 LeftChild.CanNumericEvaluate(state) ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
-
-            // If the values identify as numeric, make that comparison instead of the Version comparison since numeric has a stricter definition
-            if (isNumeric)
-            {
-                return Compare(LeftChild.NumericEvaluate(state), RightChild.NumericEvaluate(state));
-            }
-            else if (isVersion)
+            if ((!isLeftNum && !isLeftVersion) || (!isRightNum && !isRightVersion))
             {
-                return Compare(LeftChild.VersionEvaluate(state), RightChild.VersionEvaluate(state));
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ComparisonOnNonNumericExpression",
+                    state.Condition,
+                    /* helpfully display unexpanded token and expanded result in error message */
+                    isLeftNum ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
+                    isLeftNum ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
             }
 
-            // If the numbers are of a mixed type, call that specific Compare method
-            if (isLeftNum && isRightVersion)
+            return (isLeftNum, isLeftVersion, isRightNum, isRightVersion) switch
             {
-                return Compare(LeftChild.NumericEvaluate(state), RightChild.VersionEvaluate(state));
-            }
-            else if (isLeftVersion && isRightNum)
-            {
-                return Compare(LeftChild.VersionEvaluate(state), RightChild.NumericEvaluate(state));
-            }
+                (true, _, true, _) => Compare(leftNum, rightNum),
+                (_, true, _, true) => Compare(leftVersion, rightVersion),
+                (true, _, _, true) => Compare(leftNum, rightVersion),
+                (_, true, true, _) => Compare(leftVersion, rightNum),
 
-            // Throw error here as this code should be unreachable
-            ErrorUtilities.ThrowInternalErrorUnreachable();
-            return false;
+                _ => false
+            };
         }
     }
 }
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index 306db6d802b..fe21a15a1ad 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -21,60 +21,20 @@ internal NumericExpressionNode(string value)
             _value = value;
         }
 
-        /// <summary>
-        /// Evaluate as boolean
-        /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            // Should be unreachable: all calls check CanBoolEvaluate() first
-            ErrorUtilities.VerifyThrow(false, "Can't evaluate a numeric expression as boolean.");
-            return false;
-        }
-
-        /// <summary>
-        /// Evaluate as numeric
-        /// </summary>
-        internal override double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            return ConversionUtilities.ConvertDecimalOrHexToDouble(_value);
-        }
-
-        /// <summary>
-        /// Evaluate as a Version
-        /// </summary>
-        internal override Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            return Version.Parse(_value);
-        }
-
-        /// <summary>
-        /// Whether it can be evaluated as a boolean: never allowed for numerics
-        /// </summary>
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            // Numeric expressions are never allowed to be treated as booleans.
+            result = default;
             return false;
         }
 
-        /// <summary>
-        /// Whether it can be evaluated as numeric
-        /// </summary>
-        internal override bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
-            // It is not always possible to numerically evaluate even a numerical expression -
-            // for example, it may overflow a double. So check here.
-            return ConversionUtilities.ValidDecimalOrHexNumber(_value);
+            return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        /// <summary>
-        /// Whether it can be evaluated as a Version
-        /// </summary>
-        internal override bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
-            // Check if the value can be formatted as a Version number
-            // This is needed for nodes that identify as Numeric but can't be parsed as numbers (e.g. 8.1.1.0 vs 8.1)
-            Version unused;
-            return Version.TryParse(_value, out unused);
+            return Version.TryParse(_value, out result);
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 918e188ff85..92609fd763e 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -11,48 +10,23 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class OperatorExpressionNode : GenericExpressionNode
     {
-        /// <summary>
-        /// Numeric evaluation is never allowed for operators
-        /// </summary>
-        internal override double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            // Should be unreachable: all calls check CanNumericEvaluate() first
-            ErrorUtilities.VerifyThrow(false, "Cannot numeric evaluate an operator");
-            return 0.0D;
-        }
-
-        /// <summary>
-        /// Version evaluation is never allowed for operators
-        /// </summary>
-        internal override Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            ErrorUtilities.VerifyThrow(false, "Cannot version evaluate an operator");
-            return null;
-        }
-
-        /// <summary>
-        /// Whether boolean evaluation is allowed: always allowed for operators
-        /// </summary>
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
+            result = BoolEvaluate(state);
             return true;
         }
 
-        /// <summary>
-        /// Whether the node can be evaluated as a numeric: by default,
-        /// this is not allowed
-        /// </summary>
-        internal override bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
+
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
+            result = default;
             return false;
         }
 
-        /// <summary>
-        /// Whether the node can be evaluated as a version: by default,
-        /// this is not allowed
-        /// </summary>
-        internal override bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
+            result = default;
             return false;
         }
 
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index e9469f07aca..1ac1713a5aa 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -18,30 +18,34 @@ internal sealed class OrExpressionNode : OperatorExpressionNode
         /// </summary>
         internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (LeftChild.CanBoolEvaluate(state),
-                     state.ElementLocation,
-                     "ExpressionDoesNotEvaluateToBoolean",
-                     LeftChild.GetUnexpandedValue(state),
-                     LeftChild.GetExpandedValue(state),
-                     state.Condition);
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(
+                    state.ElementLocation,
+                    "ExpressionDoesNotEvaluateToBoolean",
+                    LeftChild.GetUnexpandedValue(state),
+                    LeftChild.GetExpandedValue(state),
+                    state.Condition);
+            }
 
-            if (LeftChild.BoolEvaluate(state))
+            if (leftBool)
             {
                 // Short circuit
                 return true;
             }
             else
             {
-                ProjectErrorUtilities.VerifyThrowInvalidProject
-                    (RightChild.CanBoolEvaluate(state),
-                     state.ElementLocation,
-                     "ExpressionDoesNotEvaluateToBoolean",
-                     RightChild.GetUnexpandedValue(state),
-                     RightChild.GetExpandedValue(state),
-                     state.Condition);
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
+                {
+                    ProjectErrorUtilities.ThrowInvalidProject(
+                        state.ElementLocation,
+                        "ExpressionDoesNotEvaluateToBoolean",
+                        RightChild.GetUnexpandedValue(state),
+                        RightChild.GetExpandedValue(state),
+                        state.Condition);
+                }
 
-                return RightChild.BoolEvaluate(state);
+                return rightBool;
             }
         }
 
diff --git a/src/Build/Evaluation/Conditionals/Parser.cs b/src/Build/Evaluation/Conditionals/Parser.cs
index ac231b18964..292226a5ed8 100644
--- a/src/Build/Evaluation/Conditionals/Parser.cs
+++ b/src/Build/Evaluation/Conditionals/Parser.cs
@@ -107,13 +107,13 @@ internal GenericExpressionNode Parse(string expression, ParserOptions optionSett
             if (!_lexer.Advance())
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
             }
             GenericExpressionNode node = Expr(expression);
             if (!_lexer.IsNext(Token.TokenType.EndOfInput))
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
             }
             return node;
         }
@@ -177,7 +177,7 @@ private GenericExpressionNode BooleanTerm(string expression)
             if (node == null)
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
             }
 
             if (!_lexer.IsNext(Token.TokenType.EndOfInput))
@@ -199,7 +199,7 @@ private GenericExpressionNode BooleanTermPrime(string expression, GenericExpress
                 if (rhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
 
                 OperatorExpressionNode andNode = new AndExpressionNode();
@@ -221,7 +221,7 @@ private GenericExpressionNode RelationalExpr(string expression)
                 if (lhs == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
 
                 OperatorExpressionNode node = RelationalOperation(expression);
@@ -284,7 +284,7 @@ private GenericExpressionNode Factor(string expression)
                 if (!Same(expression, Token.TokenType.LeftParenthesis))
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", _lexer.IsNextString(), errorPosition);
                     return null;
                 }
                 var arglist = new List<GenericExpressionNode>();
@@ -292,7 +292,7 @@ private GenericExpressionNode Factor(string expression)
                 if (!Same(expression, Token.TokenType.RightParenthesis))
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                     return null;
                 }
                 return new FunctionCallExpressionNode(current.String, arglist);
@@ -305,7 +305,7 @@ private GenericExpressionNode Factor(string expression)
                 else
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
             }
             else if (Same(expression, Token.TokenType.Not))
@@ -315,7 +315,7 @@ private GenericExpressionNode Factor(string expression)
                 if (expr == null)
                 {
                     errorPosition = _lexer.GetErrorPosition();
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                    ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
                 }
                 notNode.LeftChild = expr;
                 return notNode;
@@ -323,7 +323,7 @@ private GenericExpressionNode Factor(string expression)
             else
             {
                 errorPosition = _lexer.GetErrorPosition();
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
+                ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, "UnexpectedTokenInCondition", expression, _lexer.IsNextString(), errorPosition);
             }
             return null;
         }
@@ -384,11 +384,11 @@ private bool Same(string expression, Token.TokenType token)
                     errorPosition = _lexer.GetErrorPosition();
                     if (_lexer.UnexpectedlyFound != null)
                     {
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
+                        ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, _lexer.GetErrorResource(), expression, errorPosition, _lexer.UnexpectedlyFound);
                     }
                     else
                     {
-                        ProjectErrorUtilities.VerifyThrowInvalidProject(false, _elementLocation, _lexer.GetErrorResource(), expression, errorPosition);
+                        ProjectErrorUtilities.ThrowInvalidProject(_elementLocation, _lexer.GetErrorResource(), expression, errorPosition);
                     }
                 }
                 return true;
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 61eabd438fd..54afb1dc6b8 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Diagnostics;
-
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Evaluation
@@ -29,60 +28,35 @@ internal StringExpressionNode(string value, bool expandable)
             _expandable = expandable;
         }
 
-        /// <summary>
-        /// Evaluate as boolean
-        /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            return ConversionUtilities.ConvertStringToBool(GetExpandedValue(state));
+            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state), out result);
         }
 
-        /// <summary>
-        /// Evaluate as numeric
-        /// </summary>
-        internal override double NumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
-                return ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
+                result = ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
+                return true;
             }
-
-            return ConversionUtilities.ConvertDecimalOrHexToDouble(GetExpandedValue(state));
-        }
-
-        internal override Version VersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            else
             {
-                return Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
+                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state), out result);
             }
-
-            return Version.Parse(GetExpandedValue(state));
         }
 
-        internal override bool CanBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            return ConversionUtilities.CanConvertStringToBool(GetExpandedValue(state));
-        }
-
-        internal override bool CanNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
             if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
+                result = Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
-
-            return ConversionUtilities.ValidDecimalOrHexNumber(GetExpandedValue(state));
-        }
-
-        internal override bool CanVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state)
-        {
-            if (ShouldBeTreatedAsVisualStudioVersion(state))
+            else
             {
-                return true;
+                return Version.TryParse(GetExpandedValue(state), out result);
             }
-
-            return Version.TryParse(GetExpandedValue(state), out _);
         }
 
         /// <summary>
@@ -98,6 +72,25 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
             {
                 if (_expandable)
                 {
+                    switch (_value.Length)
+                    {
+                        case 0:
+                            _cachedExpandedValue = String.Empty;
+                            return true;
+                        // If the length is 1 or 2, it can't possibly be a property, item, or metadata, and it isn't empty.
+                        case 1:
+                        case 2:
+                            _cachedExpandedValue = _value;
+                            return false;
+                        default:
+                            if (_value[1] != '(' || (_value[0] != '$' && _value[0] != '%' && _value[0] != '@') || _value[_value.Length - 1] != ')')
+                            {
+                                // This isn't just a property, item, or metadata value, and it isn't empty.
+                                return false;
+                            }
+                            break;
+                    }
+
                     string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value);
 
                     if (expandBreakEarly == null)
diff --git a/src/Build/Evaluation/Context/EvaluationContext.cs b/src/Build/Evaluation/Context/EvaluationContext.cs
index 827d9465d75..19510f6d663 100644
--- a/src/Build/Evaluation/Context/EvaluationContext.cs
+++ b/src/Build/Evaluation/Context/EvaluationContext.cs
@@ -7,7 +7,6 @@
 using System.Threading;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.FileSystem;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
@@ -43,27 +42,22 @@ public enum SharingPolicy
 
         internal ISdkResolverService SdkResolverService { get; }
         internal IFileSystem FileSystem { get; }
-        internal EngineFileUtilities EngineFileUtilities { get; }
+        internal FileMatcher FileMatcher { get; }
 
         /// <summary>
         /// Key to file entry list. Example usages: cache glob expansion and intermediary directory expansions during glob expansion.
         /// </summary>
         private ConcurrentDictionary<string, IReadOnlyList<string>> FileEntryExpansionCache { get; }
 
-        private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem)
+        private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem, ISdkResolverService sdkResolverService = null,
+            ConcurrentDictionary<string, IReadOnlyList<string>> fileEntryExpansionCache = null)
         {
-            // Unsupported case: isolated context with non null file system.
-            // Isolated means caches aren't reused, but the given file system might cache.
-            ErrorUtilities.VerifyThrowArgument(
-                policy == SharingPolicy.Shared || fileSystem == null,
-                "IsolatedContextDoesNotSupportFileSystem");
-
             Policy = policy;
 
-            SdkResolverService = new CachingSdkResolverService();
-            FileEntryExpansionCache = new ConcurrentDictionary<string, IReadOnlyList<string>>();
+            SdkResolverService = sdkResolverService ?? new CachingSdkResolverService();
+            FileEntryExpansionCache = fileEntryExpansionCache ?? new ConcurrentDictionary<string, IReadOnlyList<string>>();
             FileSystem = fileSystem ?? new CachingFileSystemWrapper(FileSystems.Default);
-            EngineFileUtilities = new EngineFileUtilities(new FileMatcher(FileSystem, FileEntryExpansionCache));
+            FileMatcher = new FileMatcher(FileSystem, FileEntryExpansionCache);
         }
 
         /// <summary>
@@ -89,6 +83,12 @@ public static EvaluationContext Create(SharingPolicy policy)
         /// </param>
         public static EvaluationContext Create(SharingPolicy policy, MSBuildFileSystemBase fileSystem)
         {
+            // Unsupported case: isolated context with non null file system.
+            // Isolated means caches aren't reused, but the given file system might cache.
+            ErrorUtilities.VerifyThrowArgument(
+                policy == SharingPolicy.Shared || fileSystem == null,
+                "IsolatedContextDoesNotSupportFileSystem");
+
             var context = new EvaluationContext(
                 policy,
                 fileSystem);
@@ -124,5 +124,19 @@ internal EvaluationContext ContextForNewProject()
                     return null;
             }
         }
+
+        /// <summary>
+        /// Creates a copy of this <see cref="EvaluationContext"/> with a given <see cref="IFileSystem"/> swapped in.
+        /// </summary>
+        /// <param name="fileSystem">The file system to use by the new evaluation context.</param>
+        /// <returns>The new evaluation context.</returns>
+        internal EvaluationContext ContextWithFileSystem(IFileSystem fileSystem)
+        {
+            var newContext = new EvaluationContext(this.Policy, fileSystem, this.SdkResolverService, this.FileEntryExpansionCache)
+            {
+                _used = 1
+            };
+            return newContext;
+        }
     }
 }
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 712307191f4..e72f28469c6 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections;
-using System.Collections.Concurrent;
 using System.Collections.Generic;
 using ObjectModel = System.Collections.ObjectModel;
 using System.Diagnostics;
@@ -20,6 +19,7 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.ProjectCache;
+using Microsoft.Build.FileSystem;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Internal;
@@ -144,6 +144,9 @@ internal class Evaluator<P, I, M, D>
         /// </summary>
         private readonly int _submissionId;
 
+        /// <summary>
+        /// The evaluation context to use.
+        /// </summary>
         private readonly EvaluationContext _evaluationContext;
 
         /// <summary>
@@ -189,6 +192,7 @@ internal class Evaluator<P, I, M, D>
         /// </summary>
         private Evaluator(
             IEvaluatorData<P, I, M, D> data,
+            Project project,
             ProjectRootElement projectRootElement,
             ProjectLoadSettings loadSettings,
             int maxNodeCount,
@@ -206,6 +210,7 @@ private Evaluator(
         {
             ErrorUtilities.VerifyThrowInternalNull(data, nameof(data));
             ErrorUtilities.VerifyThrowInternalNull(projectRootElementCache, nameof(projectRootElementCache));
+            ErrorUtilities.VerifyThrowInternalNull(evaluationContext, nameof(evaluationContext));
             ErrorUtilities.VerifyThrowInternalNull(loggingService, nameof(loggingService));
             ErrorUtilities.VerifyThrowInternalNull(buildEventContext, nameof(buildEventContext));
 
@@ -220,12 +225,20 @@ private Evaluator(
                 // Wrap the IEvaluatorData<> object passed in.
                 data = new PropertyTrackingEvaluatorDataWrapper<P, I, M, D>(data, _evaluationLoggingContext, Traits.Instance.LogPropertyTracking);
             }
-            _evaluationContext = evaluationContext ?? EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated);
+
+            // If the host wishes to provide a directory cache for this evaluation, create a new EvaluationContext with the right file system.
+            _evaluationContext = evaluationContext;
+            IDirectoryCache directoryCache = project?.GetDirectoryCacheForEvaluation(_evaluationLoggingContext.BuildEventContext.EvaluationId);
+            if (directoryCache is not null)
+            {
+                IFileSystem fileSystem = new DirectoryCacheFileSystemWrapper(evaluationContext.FileSystem, directoryCache);
+                _evaluationContext = evaluationContext.ContextWithFileSystem(fileSystem);
+            }
 
             // Create containers for the evaluation results
-            data.InitializeForEvaluation(toolsetProvider, _evaluationContext.FileSystem);
+            data.InitializeForEvaluation(toolsetProvider, _evaluationContext);
 
-            _expander = new Expander<P, I>(data, data, _evaluationContext.FileSystem);
+            _expander = new Expander<P, I>(data, data, _evaluationContext);
 
             // This setting may change after the build has started, therefore if the user has not set the property to true on the build parameters we need to check to see if it is set to true on the environment variable.
             _expander.WarnForUninitializedProperties = BuildParameters.WarnOnUninitializedProperty || Traits.Instance.EscapeHatches.WarnOnUninitializedProperty;
@@ -284,6 +297,7 @@ private Evaluator(
         /// </remarks>
         internal static void Evaluate(
             IEvaluatorData<P, I, M, D> data,
+            Project project,
             ProjectRootElement root,
             ProjectLoadSettings loadSettings,
             int maxNodeCount,
@@ -295,13 +309,14 @@ internal static void Evaluate(
             BuildEventContext buildEventContext,
             ISdkResolverService sdkResolverService,
             int submissionId,
-            EvaluationContext evaluationContext = null,
+            EvaluationContext evaluationContext,
             bool interactive = false)
         {
             MSBuildEventSource.Log.EvaluateStart(root.ProjectFileLocation.File);
             var profileEvaluation = (loadSettings & ProjectLoadSettings.ProfileEvaluation) != 0 || loggingService.IncludeEvaluationProfile;
             var evaluator = new Evaluator<P, I, M, D>(
                 data,
+                project,
                 root,
                 loadSettings,
                 maxNodeCount,
@@ -357,7 +372,7 @@ internal static List<I> CreateItemsFromInclude(string rootDirectory, ProjectItem
                     else
                     {
                         // The expression is not of the form "@(X)". Treat as string
-                        string[] includeSplitFilesEscaped = EngineFileUtilities.Default.GetFileListEscaped(rootDirectory, includeSplitEscaped);
+                        string[] includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(rootDirectory, includeSplitEscaped, excludeSpecsEscaped: null, forceEvaluate: false, fileMatcher: expander.EvaluationContext?.FileMatcher);
 
                         if (includeSplitFilesEscaped.Length > 0)
                         {
@@ -2009,7 +2024,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
                     }
 
                     // Expand the wildcards and provide an alphabetical order list of import statements.
-                    importFilesEscaped = _evaluationContext.EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true);
+                    importFilesEscaped = EngineFileUtilities.GetFileListEscaped(directoryOfImportingFile, importExpressionEscapedItem, forceEvaluate: true, fileMatcher: _evaluationContext.FileMatcher);
                 }
                 catch (Exception ex) when (ExceptionHandling.IsIoRelatedException(ex))
                 {
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index fe397e4469a..1e18aba7c7c 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -1,4 +1,4 @@
-// Copyright (c) Microsoft. All rights reserved.
+﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
@@ -13,6 +13,7 @@
 using System.Runtime.CompilerServices;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -301,6 +302,11 @@ private void FlushFirstValueIfNeeded()
 
         private readonly IFileSystem _fileSystem;
 
+        /// <summary>
+        /// Non-null if the expander was constructed for evaluation.
+        /// </summary>
+        internal EvaluationContext EvaluationContext { get; }
+
         /// <summary>
         /// Creates an expander passing it some properties to use.
         /// Properties may be null.
@@ -312,6 +318,18 @@ internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
             _fileSystem = fileSystem;
         }
 
+        /// <summary>
+        /// Creates an expander passing it some properties to use and the evaluation context.
+        /// Properties may be null.
+        /// </summary>
+        internal Expander(IPropertyProvider<P> properties, EvaluationContext evaluationContext)
+        {
+            _properties = properties;
+            _usedUninitializedProperties = new UsedUninitializedProperties();
+            _fileSystem = evaluationContext.FileSystem;
+            EvaluationContext = evaluationContext;
+        }
+
         /// <summary>
         /// Creates an expander passing it some properties and items to use.
         /// Either or both may be null.
@@ -322,6 +340,16 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IFile
             _items = items;
         }
 
+        /// <summary>
+        /// Creates an expander passing it some properties and items to use, and the evaluation context.
+        /// Either or both may be null.
+        /// </summary>
+        internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, EvaluationContext evaluationContext)
+            : this(properties, evaluationContext)
+        {
+            _items = items;
+        }
+
         /// <summary>
         /// Creates an expander passing it some properties, items, and/or metadata to use.
         /// Any or all may be null.
@@ -2216,7 +2244,7 @@ internal static IEnumerable<Pair<string, S>> GetItemPairEnumerable(IEnumerable<S
                         {
                             foreach (
                                 var resultantItem in
-                                EngineFileUtilities.Default.GetFileListEscaped(
+                                EngineFileUtilities.GetFileListEscaped(
                                     item.ProjectDirectory,
                                     item.EvaluatedIncludeEscaped,
                                     forceEvaluate: true))
@@ -3668,6 +3696,14 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                             return true;
                         }
                     }
+                    else if (string.Equals(_methodMethodName, nameof(string.LastIndexOfAny), StringComparison.OrdinalIgnoreCase))
+                    {
+                        if (TryGetArg(args, out string arg0))
+                        {
+                            returnVal = text.LastIndexOfAny(arg0.ToCharArray());
+                            return true;
+                        }
+                    }
                     else if (string.Equals(_methodMethodName, nameof(string.Length), StringComparison.OrdinalIgnoreCase))
                     {
                         if (args.Length == 0)
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index ffa04158d9d..1ea8786cf67 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -110,12 +110,14 @@ internal static List<ItemExpressionCapture> GetReferencedItemExpressions(string
         {
             List<ItemExpressionCapture> subExpressions = null;
 
-            if (expression.IndexOf('@') < 0)
+            int startIndex = expression.IndexOf('@', start, end - start);
+
+            if (startIndex < 0)
             {
                 return null;
             }
 
-            for (int i = start; i < end; i++)
+            for (int i = startIndex; i < end; i++)
             {
                 int restartPoint;
                 int startPoint;
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index af0265b01d3..7e2c9c5c85c 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -8,7 +8,7 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.SdkResolution;
-using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Evaluation.Context;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -210,7 +210,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Prepares the data block for a new evaluation pass
         /// </summary>
-        void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem);
+        void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext);
 
         /// <summary>
         /// Indicates to the data block that evaluation has completed,
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index fbc0b6f6b1a..b2f33e70f30 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -97,7 +97,13 @@ public override IMSBuildGlob ToMSBuildGlob()
 
             protected override IMSBuildGlob CreateMsBuildGlob()
             {
-                return new CompositeGlob(ReferencedItems.Select(i => i.ItemAsValueFragment.ToMSBuildGlob()));
+                if (ReferencedItems.Count == 1)
+                {
+                    // Optimize the common case, avoiding allocation of enumerable/enumerator.
+                    return ReferencedItems[0].ItemAsValueFragment.ToMSBuildGlob();
+                }
+
+                return CompositeGlob.Create(ReferencedItems.Select(i => i.ItemAsValueFragment.ToMSBuildGlob()));
             }
 
             private bool InitReferencedItemsIfNecessary()
@@ -368,7 +374,13 @@ public IList<string> IntersectsWith(IReadOnlyDictionary<string, ItemDataCollecti
         /// </summary>
         public IMSBuildGlob ToMSBuildGlob()
         {
-            return new CompositeGlob(Fragments.Select(f => f.ToMSBuildGlob()));
+            if (Fragments.Count == 1)
+            {
+                // Optimize the common case, avoiding allocation of enumerable/enumerator.
+                return Fragments[0].ToMSBuildGlob();
+            }
+
+            return CompositeGlob.Create(Fragments.Select(f => f.ToMSBuildGlob()));
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index 4c88a6d976f..c493969feb5 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -7,8 +7,8 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Evaluation
 {
@@ -285,9 +285,9 @@ public ProjectTargetInstance GetTarget(string targetName)
                 return _wrappedData.GetTarget(targetName);
             }
 
-            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem)
+            public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
             {
-                _wrappedData.InitializeForEvaluation(toolsetProvider, fileSystem);
+                _wrappedData.InitializeForEvaluation(toolsetProvider, evaluationContext);
             }
 
             public void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult)
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index da5f61449b6..b50ed189861 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -113,7 +113,8 @@ protected override ImmutableList<I> SelectItems(OrderedItemDataCollection.Builde
                                 includeSplitFilesEscaped = EngineFileUtilities.GetFileListEscaped(
                                     _rootDirectory,
                                     glob,
-                                    excludePatternsForGlobs
+                                    excludePatternsForGlobs,
+                                    fileMatcher: FileMatcher
                                 );
                             }
                             if (MSBuildEventSource.Log.IsEnabled())
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 288d11ce9b9..20706932be6 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -44,12 +44,12 @@ protected LazyItemOperation(OperationBuilder builder, LazyItemEvaluator<P, I, M,
 
                 _evaluatorData = new EvaluatorData(_lazyEvaluator._outerEvaluatorData, itemType => GetReferencedItems(itemType, ImmutableHashSet<string>.Empty));
                 _itemFactory = new ItemFactoryWrapper(_itemElement, _lazyEvaluator._itemFactory);
-                _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, _lazyEvaluator.FileSystem);
+                _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, _lazyEvaluator.EvaluationContext);
 
                 _itemSpec.Expander = _expander;
             }
 
-            protected EngineFileUtilities EngineFileUtilities => _lazyEvaluator.EngineFileUtilities;
+            protected FileMatcher FileMatcher => _lazyEvaluator.FileMatcher;
 
             public void Apply(OrderedItemDataCollection.Builder listBuilder, ImmutableHashSet<string> globsToIgnore)
             {
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index 1db3ddfd3ce..d63e2a31c38 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -23,7 +23,7 @@ public RemoveOperation(RemoveOperationBuilder builder, LazyItemEvaluator<P, I, M
                 _matchOnMetadata = builder.MatchOnMetadata.ToImmutable();
 
                 ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(
-                    _matchOnMetadata.IsEmpty || _itemSpec.Fragments.All(f => f is ItemSpec<ProjectProperty, ProjectItem>.ItemExpressionFragment),
+                    _matchOnMetadata.IsEmpty || _itemSpec.Fragments.All(f => f is ItemSpec<P, I>.ItemExpressionFragment),
                     new BuildEventFileInfo(string.Empty),
                     "OM_MatchOnMetadataIsRestrictedToReferencedItems");
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 9fd3eec87e7..ada3da6a27f 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Eventing;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
@@ -40,22 +39,22 @@ internal partial class LazyItemEvaluator<P, I, M, D>
             new Dictionary<string, LazyItemList>() :
             new Dictionary<string, LazyItemList>(StringComparer.OrdinalIgnoreCase);
 
-        protected IFileSystem FileSystem { get; }
+        protected EvaluationContext EvaluationContext { get; }
 
-        protected EngineFileUtilities EngineFileUtilities { get; }
+        protected IFileSystem FileSystem => EvaluationContext.FileSystem;
+        protected FileMatcher FileMatcher => EvaluationContext.FileMatcher;
 
         public LazyItemEvaluator(IEvaluatorData<P, I, M, D> data, IItemFactory<I, I> itemFactory, LoggingContext loggingContext, EvaluationProfiler evaluationProfiler, EvaluationContext evaluationContext)
         {
             _outerEvaluatorData = data;
-            _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext.FileSystem);
+            _outerExpander = new Expander<P, I>(_outerEvaluatorData, _outerEvaluatorData, evaluationContext);
             _evaluatorData = new EvaluatorData(_outerEvaluatorData, itemType => GetItems(itemType));
-            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext.FileSystem);
+            _expander = new Expander<P, I>(_evaluatorData, _evaluatorData, evaluationContext);
             _itemFactory = itemFactory;
             _loggingContext = loggingContext;
             _evaluationProfiler = evaluationProfiler;
 
-            FileSystem = evaluationContext.FileSystem;
-            EngineFileUtilities = evaluationContext.EngineFileUtilities;
+            EvaluationContext = evaluationContext;
         }
 
         private ImmutableList<I> GetItems(string itemType)
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 761ef477d6f..186ed1ddf4c 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -127,7 +127,10 @@ private void Parse()
             // XML guarantees exactly one root element
             XmlElementWithLocation element = _document.DocumentElement as XmlElementWithLocation;
 
-            ProjectErrorUtilities.VerifyThrowInvalidProject(element != null, ElementLocation.Create(_document.FullPath), "NoRootProjectElement", XMakeElements.project);
+            if (element is null)
+            {
+                ProjectErrorUtilities.ThrowInvalidProject(ElementLocation.Create(_document.FullPath), "NoRootProjectElement", XMakeElements.project);
+            }
             ProjectErrorUtilities.VerifyThrowInvalidProject(element.Name != XMakeElements.visualStudioProject, element.Location, "ProjectUpgradeNeeded", _project.FullPath);
             ProjectErrorUtilities.VerifyThrowInvalidProject(element.LocalName == XMakeElements.project, element.Location, "UnrecognizedElement", element.Name);
 
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index 6e3dc3a3ec7..54effc239c5 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -5,10 +5,10 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Shared.FileSystem;
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Components.Logging;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
@@ -135,7 +135,7 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
         public ItemDictionary<I> Items => _wrapped.Items;
         public List<ProjectItemElement> EvaluatedItemElements => _wrapped.EvaluatedItemElements;
         public PropertyDictionary<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary => _wrapped.EnvironmentVariablePropertiesDictionary;
-        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem) => _wrapped.InitializeForEvaluation(toolsetProvider, fileSystem);
+        public void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext) => _wrapped.InitializeForEvaluation(toolsetProvider, evaluationContext);
         public void FinishEvaluation() => _wrapped.FinishEvaluation();
         public void AddItem(I item) => _wrapped.AddItem(item);
         public void AddItemIgnoringCondition(I item) => _wrapped.AddItemIgnoringCondition(item);
diff --git a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
new file mode 100644
index 00000000000..84c24fb02cc
--- /dev/null
+++ b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
@@ -0,0 +1,118 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+
+#if FEATURE_MSIOREDIST
+using Path = Microsoft.IO.Path;
+#endif
+
+namespace Microsoft.Build.FileSystem
+{
+    internal class DirectoryCacheFileSystemWrapper : IFileSystem
+    {
+        /// <summary>
+        /// The base <see cref="IFileSystem"/> to fall back to for functionality not provided by <see cref="_directoryCache"/>.
+        /// </summary>
+        private readonly IFileSystem _fileSystem;
+
+        /// <summary>
+        /// A host-provided cache used for file existence and directory enumeration.
+        /// </summary>
+        private readonly IDirectoryCache _directoryCache;
+
+        public DirectoryCacheFileSystemWrapper(IFileSystem fileSystem, IDirectoryCache directoryCache)
+        {
+            _fileSystem = fileSystem;
+            _directoryCache = directoryCache;
+        }
+
+        #region IFileSystem implementation based on IDirectoryCache
+
+        public bool FileOrDirectoryExists(string path)
+        {
+            return _directoryCache.FileExists(path) || _directoryCache.DirectoryExists(path);
+        }
+
+        public bool DirectoryExists(string path)
+        {
+            return _directoryCache.DirectoryExists(path);
+        }
+
+        public bool FileExists(string path)
+        {
+            return _directoryCache.FileExists(path);
+        }
+
+        public IEnumerable<string> EnumerateDirectories(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            if (searchOption != SearchOption.TopDirectoryOnly)
+            {
+                // Recursive enumeration is not used during evaluation, pass it through.
+                return _fileSystem.EnumerateDirectories(path, searchPattern, searchOption);
+            }
+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: false, includeDirectories: true);
+        }
+
+        public IEnumerable<string> EnumerateFiles(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            if (searchOption != SearchOption.TopDirectoryOnly)
+            {
+                // Recursive enumeration is not used during evaluation, pass it through.
+                return _fileSystem.EnumerateFiles(path, searchPattern, searchOption);
+            }
+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: false);
+        }
+
+        public IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern = "*", SearchOption searchOption = SearchOption.TopDirectoryOnly)
+        {
+            if (searchOption != SearchOption.TopDirectoryOnly)
+            {
+                // Recursive enumeration is not used during evaluation, pass it through.
+                return _fileSystem.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+            }
+            return EnumerateFullFileSystemPaths(path, searchPattern, includeFiles: true, includeDirectories: true);
+        }
+
+        private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string searchPattern, bool includeFiles, bool includeDirectories)
+        {
+            FindPredicate predicate = (ref ReadOnlySpan<char> fileName) =>
+            {
+                return FileMatcher.IsAllFilesWildcard(searchPattern) || FileMatcher.IsMatch(fileName, searchPattern);
+            };
+            FindTransform<string> transform = (ref ReadOnlySpan<char> fileName) => Path.Join(path.AsSpan(), fileName);
+
+            IEnumerable<string> directories = includeDirectories
+                ? _directoryCache.EnumerateDirectories(path, searchPattern, predicate, transform)
+                : Enumerable.Empty<string>();
+            IEnumerable<string> files = includeFiles
+                ? _directoryCache.EnumerateFiles(path, searchPattern, predicate, transform)
+                : Enumerable.Empty<string>();
+
+            return Enumerable.Concat(directories, files);
+        }
+
+        #endregion
+
+        #region IFileSystem pass-through implementation
+
+        public FileAttributes GetAttributes(string path) => _fileSystem.GetAttributes(path);
+
+        public DateTime GetLastWriteTimeUtc(string path) => _fileSystem.GetLastWriteTimeUtc(path);
+
+        public TextReader ReadFile(string path) => _fileSystem.ReadFile(path);
+
+        public Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share) => _fileSystem.GetFileStream(path, mode, access, share);
+
+        public string ReadFileAllText(string path) => _fileSystem.ReadFileAllText(path);
+
+        public byte[] ReadFileAllBytes(string path) => _fileSystem.ReadFileAllBytes(path);
+
+        #endregion
+    }
+}
diff --git a/src/Build/FileSystem/IDirectoryCache.cs b/src/Build/FileSystem/IDirectoryCache.cs
new file mode 100644
index 00000000000..fb6e62c1b6a
--- /dev/null
+++ b/src/Build/FileSystem/IDirectoryCache.cs
@@ -0,0 +1,89 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+
+namespace Microsoft.Build.FileSystem
+{
+    /// <summary>
+    /// A provider of <see cref="IDirectoryCache"/> instances. To be implemented by MSBuild hosts that wish to intercept
+    /// file existence checks and file enumerations performed during project evaluation.
+    /// </summary>
+    /// <remarks>
+    /// Unlike <see cref="MSBuildFileSystemBase"/>, file enumeration returns file/directory names, not full paths.
+    /// The host uses <see cref="Definition.ProjectOptions.DirectoryCacheFactory"/> to specify the directory cache
+    /// factory per project.
+    /// </remarks>
+    public interface IDirectoryCacheFactory
+    {
+        /// <summary>
+        /// Returns an <see cref="IDirectoryCache"/> to be used when evaluating the project associated with this <see cref="IDirectoryCacheFactory"/>.
+        /// </summary>
+        /// <param name="evaluationId">The ID of the evaluation for which the interface is requested.</param>
+        IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);
+    }
+
+    /// <summary>
+    /// A predicate taking file name.
+    /// </summary>
+    /// <param name="fileName">The file name to check.</param>
+    public delegate bool FindPredicate(ref ReadOnlySpan<char> fileName);
+
+    /// <summary>
+    /// A function taking file name and returning an arbitrary result.
+    /// </summary>
+    /// <typeparam name="TResult">The type of the result to return</typeparam>
+    /// <param name="fileName">The file name to transform.</param>
+    public delegate TResult FindTransform<TResult>(ref ReadOnlySpan<char> fileName);
+
+    /// <summary>
+    /// Allows the implementor to intercept file existence checks and file enumerations performed during project evaluation.
+    /// </summary>
+    public interface IDirectoryCache
+    {
+        /// <summary>
+        /// Returns <code>true</code> if the given path points to an existing file on disk.
+        /// </summary>
+        /// <param name="path">A full and normalized path.</param>
+        bool FileExists(string path);
+
+        /// <summary>
+        /// Returns <code>true</code> if the given path points to an existing directory on disk.
+        /// </summary>
+        /// <param name="path">A full and normalized path.</param>
+        bool DirectoryExists(string path);
+
+        /// <summary>
+        /// Enumerates files in the given directory only (non-recursively).
+        /// </summary>
+        /// <typeparam name="TResult">The desired return type.</typeparam>
+        /// <param name="path">The directory to enumerate, specified as a full normalized path.</param>
+        /// <param name="pattern">A search pattern supported by the platform which is guaranteed to return a superset of relevant files.</param>
+        /// <param name="predicate">A predicate to test whether a file should be included.</param>
+        /// <param name="transform">A transform from <code>ReadOnlySpan&lt;char&gt;</code> to <typeparamref name="TResult"/>.</param>
+        /// <remarks>
+        /// The <paramref name="pattern"/> parameter may match more files than what the caller is interested in. In other words,
+        /// <paramref name="predicate"/> can return <code>false</code> even if the implementation enumerates only files whose names
+        /// match the pattern. The implementation is free to ignore the pattern and call the predicate for all files on the given
+        /// <paramref name="path"/>.
+        /// </remarks>
+        IEnumerable<TResult> EnumerateFiles<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform);
+
+        /// <summary>
+        /// Enumerates subdirectories in the given directory only (non-recursively).
+        /// </summary>
+        /// <typeparam name="TResult">The desired return type.</typeparam>
+        /// <param name="path">The directory to enumerate, specified as a full normalized path.</param>
+        /// <param name="pattern">A search pattern supported by the platform which is guaranteed to return a superset of relevant directories.</param>
+        /// <param name="predicate">A predicate to test whether a directory should be included.</param>
+        /// <param name="transform">A transform from <code>ReadOnlySpan&lt;char&gt;</code> to <typeparamref name="TResult"/>.</param>
+        /// <remarks>
+        /// The <paramref name="pattern"/> parameter may match more direcories than what the caller is interested in. In other words,
+        /// <paramref name="predicate"/> can return <code>false</code> even if the implementation enumerates only directories whose names
+        /// match the pattern. The implementation is free to ignore the pattern and call the predicate for all directories on the given
+        /// <paramref name="path"/>.
+        /// </remarks>
+        IEnumerable<TResult> EnumerateDirectories<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform);
+    }
+}
diff --git a/src/Build/Globbing/CompositeGlob.cs b/src/Build/Globbing/CompositeGlob.cs
index 58687130fa4..96606323bc9 100644
--- a/src/Build/Globbing/CompositeGlob.cs
+++ b/src/Build/Globbing/CompositeGlob.cs
@@ -5,33 +5,30 @@
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Globbing
 {
     /// <summary>
-    ///     A Composite glob
+    ///     A composite glob that returns a match for an input if any of its
+    ///     inner globs match the input (disjunction).
     /// </summary>
     public class CompositeGlob : IMSBuildGlob
     {
+        private readonly ImmutableArray<IMSBuildGlob> _globs;
+
         /// <summary>
         /// The direct children of this composite
         /// </summary>
-        public IEnumerable<IMSBuildGlob> Globs { get; }
+        public IEnumerable<IMSBuildGlob> Globs => _globs;
 
         /// <summary>
         ///     Constructor
         /// </summary>
         /// <param name="globs">Children globs. Input gets shallow cloned</param>
         public CompositeGlob(IEnumerable<IMSBuildGlob> globs)
-        {
-            // ImmutableArray also does this check, but copied it here just in case they remove it
-            if (globs is ImmutableArray<IMSBuildGlob>)
-            {
-                Globs = (ImmutableArray<IMSBuildGlob>)globs;
-            }
-
-            Globs = globs.ToImmutableArray();
-        }
+            : this(globs is ImmutableArray<IMSBuildGlob> immutableGlobs ? immutableGlobs : globs.ToImmutableArray())
+        {}
 
         /// <summary>
         ///     Constructor
@@ -40,13 +37,114 @@ public CompositeGlob(IEnumerable<IMSBuildGlob> globs)
         public CompositeGlob(params IMSBuildGlob[] globs) : this(globs.ToImmutableArray())
         {}
 
+        /// <summary>
+        ///     Constructor
+        /// </summary>
+        /// <param name="glob1">First child glob.</param>
+        /// <param name="glob2">Second child glob.</param>
+        internal CompositeGlob(IMSBuildGlob glob1, IMSBuildGlob glob2)
+            : this(ImmutableArray.Create(glob1, glob2))
+        {}
+
+        /// <summary>
+        ///     Constructor
+        /// </summary>
+        /// <param name="globs">Children globs.</param>
+        private CompositeGlob(ImmutableArray<IMSBuildGlob> globs)
+        {
+            _globs = globs;
+        }
+
         /// <inheritdoc />
         public bool IsMatch(string stringToMatch)
         {
             // Threadpools are a scarce resource in Visual Studio, do not use them.
             //return Globs.AsParallel().Any(g => g.IsMatch(stringToMatch));
 
-            return Globs.Any(g => g.IsMatch(stringToMatch));
+            return _globs.Any(g => g.IsMatch(stringToMatch));
+        }
+
+        /// <summary>
+        ///     Creates an <see cref="IMSBuildGlob"/> that aggregates multiple other globs
+        ///     such that the resulting glob matches when any inner glob matches (disjunction).
+        /// </summary>
+        /// <remarks>
+        ///     <para>
+        ///         When <paramref name="globs"/> contains no elements, a singleton glob is
+        ///         returned that never matches, regardless of input.
+        ///     </para>
+        ///     <para>
+        ///         When <paramref name="globs"/> contains one element, that single element is
+        ///         returned directly. This avoids allocating a redundant wrapper instance.
+        ///     </para>
+        /// </remarks>
+        /// <param name="globs">An enumeration of globs to compose.</param>
+        /// <returns>The logical disjunction of the input globs.</returns>
+        public static IMSBuildGlob Create(IEnumerable<IMSBuildGlob> globs)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(globs, nameof(globs));
+
+            if (globs is ImmutableArray<IMSBuildGlob> immutableGlobs)
+            {
+                // Avoid allocations in the case that the input is an ImmutableArray
+                return immutableGlobs.Length switch
+                {
+                    0 => NeverMatchingGlob.Instance,
+                    1 => immutableGlobs[0],
+                    _ => new CompositeGlob(immutableGlobs)
+                };
+            }
+
+            // Use explicit enumeration so we can do minimal work in the case
+            // that the input set of globs is either empty or only contains a
+            // single item.
+
+            using var enumerator = globs.GetEnumerator();
+
+            if (!enumerator.MoveNext())
+            {
+                // The input is empty, so return our singleton that doesn't
+                // match anything.
+                return NeverMatchingGlob.Instance;
+            }
+
+            var first = enumerator.Current;
+
+            if (!enumerator.MoveNext())
+            {
+                // The input contains only a single glob. Disjunction has no
+                // effect on a single input, so return it directly and avoid
+                // allocating a CompositeGlob instance.
+                return first;
+            }
+
+            // We have more than one input glob, to add them all to a builder
+            // and create a new CompositeGlob.
+
+            var builder = ImmutableArray.CreateBuilder<IMSBuildGlob>();
+
+            builder.Add(first);
+            builder.Add(enumerator.Current);
+
+            while (enumerator.MoveNext())
+            {
+                builder.Add(enumerator.Current);
+            }
+
+            return new CompositeGlob(builder.ToImmutable());
+        }
+
+        /// <summary>
+        ///    A glob that never returns a match.
+        /// </summary>
+        private sealed class NeverMatchingGlob : IMSBuildGlob
+        {
+            /// <summary>
+            ///    Singleton instance of this type.
+            /// </summary>
+            public static NeverMatchingGlob Instance { get; } = new();
+
+            public bool IsMatch(string stringToMatch) => false;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/Build/Globbing/IMSBuildGlob.cs b/src/Build/Globbing/IMSBuildGlob.cs
index 59e630fd225..c6b9279ab50 100644
--- a/src/Build/Globbing/IMSBuildGlob.cs
+++ b/src/Build/Globbing/IMSBuildGlob.cs
@@ -15,7 +15,7 @@ public interface IMSBuildGlob
         ///     - arguments representing relative paths are normalized against the glob's root.
         ///     For example, the glob **/*.cs does not match ../a.cs, since ../a.cs points outside of the glob root.
         /// 
-        ///     Returns false if <paramref name="stringToMatch" /> contains invalid path or file characters>
+        ///     Returns false if <paramref name="stringToMatch" /> contains invalid path or file characters.
         /// </summary>
         /// <param name="stringToMatch">The string to match. If the string represents a relative path, it will get normalized against the glob's root. Cannot be null.</param>
         /// <returns></returns>
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index 9460958a40f..3fdf05a6b9c 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -260,7 +260,7 @@ public static MSBuildGlob Parse(string fileSpec)
         /// <summary>
         ///     Return type of <see cref="MSBuildGlob.MatchInfo" />
         /// </summary>
-        public struct MatchInfoResult
+        public readonly struct MatchInfoResult
         {
             /// <summary>
             ///     Whether the <see cref="MSBuildGlob.MatchInfo" /> argument was matched against the glob
diff --git a/src/Build/Globbing/MSBuildGlobWithGaps.cs b/src/Build/Globbing/MSBuildGlobWithGaps.cs
index 1a1abe4d149..fd6cf67baf4 100644
--- a/src/Build/Globbing/MSBuildGlobWithGaps.cs
+++ b/src/Build/Globbing/MSBuildGlobWithGaps.cs
@@ -32,6 +32,20 @@ public class MSBuildGlobWithGaps : IMSBuildGlob
         /// </summary>
         public IMSBuildGlob Gaps { get; }
 
+        /// <summary>
+        ///     Constructor
+        /// </summary>
+        /// <param name="mainGlob">The main glob</param>
+        /// <param name="gaps">The gap glob</param>
+        internal MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IMSBuildGlob gaps)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(mainGlob, nameof(mainGlob));
+            ErrorUtilities.VerifyThrowArgumentNull(gaps, nameof(gaps));
+
+            MainGlob = mainGlob;
+            Gaps = gaps;
+        }
+
         /// <summary>
         ///     Constructor
         /// </summary>
@@ -43,7 +57,7 @@ public MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IEnumerable<IMSBuildGlob> gaps
             ErrorUtilities.VerifyThrowArgumentNull(gaps, nameof(gaps));
 
             MainGlob = mainGlob;
-            Gaps = new CompositeGlob(gaps);
+            Gaps = CompositeGlob.Create(gaps);
         }
 
         /// <summary>
diff --git a/src/Build/Globbing/Visitor/GlobVisitor.cs b/src/Build/Globbing/Visitor/GlobVisitor.cs
index 26a349c2c35..972af2443ad 100644
--- a/src/Build/Globbing/Visitor/GlobVisitor.cs
+++ b/src/Build/Globbing/Visitor/GlobVisitor.cs
@@ -7,25 +7,22 @@ internal abstract class GlobVisitor
     {
         public void Visit(IMSBuildGlob glob)
         {
-            var msbuildGlob = glob as MSBuildGlob;
-            if (msbuildGlob != null)
+            if (glob is MSBuildGlob msbuildGlob)
             {
                 VisitMSBuildGlob(msbuildGlob);
             }
 
-            var compositGlob = glob as CompositeGlob;
-            if (compositGlob != null)
+            if (glob is CompositeGlob compositeGlob)
             {
-                VisitCompositeGlob(compositGlob);
+                VisitCompositeGlob(compositeGlob);
 
-                foreach (var globPart in compositGlob.Globs)
+                foreach (var globPart in compositeGlob.Globs)
                 {
                     Visit(globPart);
                 }
             }
 
-            var globWithGaps = glob as MSBuildGlobWithGaps;
-            if (globWithGaps != null)
+            if (glob is MSBuildGlobWithGaps globWithGaps)
             {
                 VisitGlobWithGaps(globWithGaps);
 
@@ -37,7 +34,7 @@ protected virtual void VisitGlobWithGaps(MSBuildGlobWithGaps globWithGaps)
         {
         }
 
-        protected virtual void VisitCompositeGlob(CompositeGlob compositGlob)
+        protected virtual void VisitCompositeGlob(CompositeGlob compositeGlob)
         {
         }
 
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index b67aba3de21..35795e9d705 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1347,7 +1347,7 @@ ICollection<ProjectItemInstance> IItemProvider<ProjectItemInstance>.GetItems(str
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
         void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.
-            InitializeForEvaluation(IToolsetProvider toolsetProvider, IFileSystem fileSystem)
+            InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext)
         {
             // All been done in the constructor.  We don't allow re-evaluation of project instances.
         }
@@ -2761,6 +2761,7 @@ out var usingDifferentToolsVersionFromProjectFile
 
             Evaluator<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Evaluate(
                 this,
+                null,
                 xml,
                 projectLoadSettings ?? buildParameters.ProjectLoadSettings, /* Use override ProjectLoadSettings if specified */
                 buildParameters.MaxNodeCount,
diff --git a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
index 62f79e2d8a0..2ba9a93a0e4 100644
--- a/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
+++ b/src/Build/Instance/ProjectItemGroupTaskItemInstance.cs
@@ -459,6 +459,8 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _keepMetadataLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _removeMetadataLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _keepDuplicatesLocation, ElementLocation.FactoryForDeserialization);
+            translator.Translate(ref _matchOnMetadataLocation, ElementLocation.FactoryForDeserialization);
+            translator.Translate(ref _matchOnMetadataOptionsLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _conditionLocation, ElementLocation.FactoryForDeserialization);
             translator.Translate(ref _metadata, ProjectItemGroupTaskMetadataInstance.FactoryForDeserialization);
         }
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 802539f6077..4596be57f52 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -282,7 +282,7 @@ string taskProjectFile
             {
                 // Exception thrown by the called code itself
                 // Log the stack, so the task vendor can fix their code
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, Environment.NewLine + e.InnerException.ToString());
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, Environment.NewLine + e.InnerException.ToString());
             }
             catch (ReflectionTypeLoadException e)
             {
@@ -295,12 +295,12 @@ string taskProjectFile
                     }
                 }
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
             }
             catch (ArgumentNullException e)
             {
                 // taskName may be null
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
             }
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
@@ -309,7 +309,7 @@ string taskProjectFile
                     throw;
                 }
 
-                ProjectErrorUtilities.VerifyThrowInvalidProject(false, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
+                ProjectErrorUtilities.ThrowInvalidProject(elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, e.Message);
             }
 
             return _loadedType;
@@ -355,15 +355,12 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
 
                 mergedParameters ??= new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
-                string runtime = null;
-                string architecture = null;
-
-                if (!mergedParameters.TryGetValue(XMakeAttributes.runtime, out runtime))
+                if (!mergedParameters.ContainsKey(XMakeAttributes.runtime))
                 {
-                    mergedParameters[XMakeAttributes.runtime] = XMakeAttributes.MSBuildRuntimeValues.clr4;
+                    mergedParameters[XMakeAttributes.runtime] = XMakeAttributes.GetCurrentMSBuildRuntime();
                 }
 
-                if (!mergedParameters.TryGetValue(XMakeAttributes.architecture, out architecture))
+                if (!mergedParameters.ContainsKey(XMakeAttributes.architecture))
                 {
                     mergedParameters[XMakeAttributes.architecture] = XMakeAttributes.GetCurrentMSBuildArchitecture();
                 }
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index 167a67e396e..28f1d0d9d5f 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -352,7 +352,7 @@ internal static LoggerVerbosity ImportanceToMinimumVerbosity(MessageImportance i
                     return LoggerVerbosity.Detailed;
 
                 default:
-                    ErrorUtilities.VerifyThrow(false, "Impossible");
+                    ErrorUtilities.ThrowInternalError("Impossible");
                     lightenText = false;
                     return LoggerVerbosity.Detailed;
             }
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index c64e5f2fd85..72f225241d3 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -183,7 +183,7 @@ public LoggerVerbosity Verbosity
         {
             get
             {
-                ErrorUtilities.VerifyThrow(false, "Should not be getting verbosity from distributed file logger");
+                ErrorUtilities.ThrowInternalError("Should not be getting verbosity from distributed file logger");
                 return LoggerVerbosity.Detailed;
             }
             set
diff --git a/src/Build/Logging/NullCentralLogger.cs b/src/Build/Logging/NullCentralLogger.cs
index b2101e63bc6..de64da650a1 100644
--- a/src/Build/Logging/NullCentralLogger.cs
+++ b/src/Build/Logging/NullCentralLogger.cs
@@ -53,7 +53,7 @@ public void AnyEventRaisedHandler(object sender, BuildEventArgs e)
         {
             if (!(e is BuildStartedEventArgs) && !(e is BuildFinishedEventArgs))
             {
-                ErrorUtilities.VerifyThrowInvalidOperation(false, "Should not receive any events other than build started or finished");
+                ErrorUtilities.ThrowInvalidOperation("Should not receive any events other than build started or finished");
             }
         }
 
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 9deedd88b0e..4784c183001 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -702,7 +702,7 @@ private string GetCurrentlyBuildingProjectFile()
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Unexpected frame type.");
+                ErrorUtilities.ThrowInternalError("Unexpected frame type.");
                 return null;
             }
         }
@@ -752,7 +752,7 @@ private void ShowDeferredMessages()
                         break;
 
                     default:
-                        ErrorUtilities.VerifyThrow(false, "Unexpected frame type.");
+                        ErrorUtilities.ThrowInternalError("Unexpected frame type.");
                         break;
                 }
             }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index d08e337c5da..f7540863381 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -36,6 +36,8 @@
     <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
+
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/Build/Utilities/EngineFileUtilities.cs b/src/Build/Utilities/EngineFileUtilities.cs
index da8165d3369..40347473d2a 100644
--- a/src/Build/Utilities/EngineFileUtilities.cs
+++ b/src/Build/Utilities/EngineFileUtilities.cs
@@ -12,10 +12,8 @@
 
 namespace Microsoft.Build.Internal
 {
-    internal class EngineFileUtilities
+    internal static class EngineFileUtilities
     {
-        private readonly FileMatcher _fileMatcher;
-
         // Regexes for wildcard filespecs that should not get expanded
         // By default all wildcards are expanded.
         private static List<Regex> s_lazyWildCardExpansionRegexes;
@@ -34,13 +32,6 @@ internal static void CaptureLazyWildcardRegexes()
             s_lazyWildCardExpansionRegexes = PopulateRegexFromEnvironment();
         }
 
-        public static EngineFileUtilities Default = new EngineFileUtilities(FileMatcher.Default);
-
-        public EngineFileUtilities(FileMatcher fileMatcher)
-        {
-            _fileMatcher = fileMatcher;
-        }
-
         /// <summary>
         /// Used for the purposes of evaluating an item specification. Given a filespec that may include wildcard characters * and
         /// ?, we translate it into an actual list of files. If the input filespec doesn't contain any wildcard characters, and it
@@ -54,14 +45,14 @@ public EngineFileUtilities(FileMatcher fileMatcher)
         /// <param name="directoryEscaped">The directory to evaluate, escaped.</param>
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <returns>Array of file paths, unescaped.</returns>
-        internal string[] GetFileListUnescaped
+        internal static string[] GetFileListUnescaped
             (
             string directoryEscaped,
             string filespecEscaped
             )
 
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: false, forceEvaluateWildCards: false);
+            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: false, forceEvaluateWildCards: false, excludeSpecsEscaped: null, fileMatcher: FileMatcher.Default);
         }
 
         /// <summary>
@@ -78,16 +69,18 @@ string filespecEscaped
         /// <param name="filespecEscaped">The filespec to evaluate, escaped.</param>
         /// <param name="excludeSpecsEscaped">Filespecs to exclude, escaped.</param>
         /// <param name="forceEvaluate">Whether to force file glob expansion when eager expansion is turned off</param>
+        /// <param name="fileMatcher"></param>
         /// <returns>Array of file paths, escaped.</returns>
-        internal string[] GetFileListEscaped
+        internal static string[] GetFileListEscaped
             (
             string directoryEscaped,
             string filespecEscaped,
             IEnumerable<string> excludeSpecsEscaped = null,
-            bool forceEvaluate = false
+            bool forceEvaluate = false,
+            FileMatcher fileMatcher = null
             )
         {
-            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: true, forceEvaluate, excludeSpecsEscaped);
+            return GetFileList(directoryEscaped, filespecEscaped, returnEscaped: true, forceEvaluate, excludeSpecsEscaped, fileMatcher ?? FileMatcher.Default);
         }
 
         internal static bool FilespecHasWildcards(string filespecEscaped)
@@ -119,14 +112,16 @@ internal static bool FilespecHasWildcards(string filespecEscaped)
         /// <param name="returnEscaped"><code>true</code> to return escaped specs.</param>
         /// <param name="forceEvaluateWildCards">Whether to force file glob expansion when eager expansion is turned off</param>
         /// <param name="excludeSpecsEscaped">The exclude specification, escaped.</param>
+        /// <param name="fileMatcher"></param>
         /// <returns>Array of file paths.</returns>
-        private string[] GetFileList
+        private static string[] GetFileList
             (
             string directoryEscaped,
             string filespecEscaped,
             bool returnEscaped,
             bool forceEvaluateWildCards,
-            IEnumerable<string> excludeSpecsEscaped = null
+            IEnumerable<string> excludeSpecsEscaped,
+            FileMatcher fileMatcher
             )
         {
             ErrorUtilities.VerifyThrowInternalLength(filespecEscaped, nameof(filespecEscaped));
@@ -156,7 +151,7 @@ private string[] GetFileList
                 // as a relative path, we will get back a bunch of relative paths.
                 // If the filespec started out as an absolute path, we will get
                 // back a bunch of absolute paths.
-                fileList = _fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
+                fileList = fileMatcher.GetFiles(directoryUnescaped, filespecUnescaped, excludeSpecsUnescaped);
 
                 ErrorUtilities.VerifyThrow(fileList != null, "We must have a list of files here, even if it's empty.");
 
@@ -241,18 +236,13 @@ internal static Func<string, bool> GetFileSpecMatchTester(IList<string> filespec
             return file => matchers.Any(m => m.Value.IsMatch(file));
         }
 
-        internal class IOCache
+        internal sealed class IOCache
         {
             private readonly Lazy<ConcurrentDictionary<string, bool>> existenceCache = new Lazy<ConcurrentDictionary<string, bool>>(() => new ConcurrentDictionary<string, bool>(), true);
 
-            public virtual bool DirectoryExists(string directory)
-            {
-                return existenceCache.Value.GetOrAdd(directory, Directory.Exists);
-            }
-
-            public virtual bool FileExists(string file)
+            public bool DirectoryExists(string directory)
             {
-                return existenceCache.Value.GetOrAdd(file, File.Exists);
+                return existenceCache.Value.GetOrAdd(directory, directory => Directory.Exists(directory));
             }
         }
     }
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 913c97b1281..cb6fabf4c0d 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -80,7 +80,6 @@
     <DefineConstants>$(DefineConstants);FEATURE_SYSTEMPAGESIZE</DefineConstants>
     <FeatureSystemConfiguration>true</FeatureSystemConfiguration>
     <DefineConstants>$(DefineConstants);FEATURE_TASK_GENERATERESOURCES</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_TASKHOST</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_ABORT</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_CULTURE</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_THREAD_PRIORITY</DefineConstants>
@@ -142,4 +141,9 @@
     <DocumentationFile Condition=" '$(GenerateDocumentationFile)' == 'true' ">$(IntermediateOutputPath)\$(AssemblyName).xml</DocumentationFile>
   </PropertyGroup>
 
+  <PropertyGroup Condition="'$(MonoBuild)' != 'true' and $([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETFramework'">
+    <DefineConstants>$(DefineConstants);FEATURE_MSIOREDIST</DefineConstants>
+    <FeatureMSIORedist>true</FeatureMSIORedist>
+  </PropertyGroup>
+
 </Project>
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index 2043a496e46..7be18a10802 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -11,6 +11,7 @@
   </PropertyGroup>
 
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
     <PackageReference Include="Shouldly" />
     <PackageReference Include="System.Net.Http" />
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index 3581225789d..e32cb633fbc 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -429,7 +429,7 @@ public void TargetUpToDateStop(int result)
         {
             WriteEvent(57, result);
         }
-        
+
         [Event(58, Keywords = Keywords.All)]
         public void CopyUpToDateStart(string path)
         {
@@ -454,6 +454,42 @@ public void WriteLinesToFileUpToDateStop(string fileItemSpec, bool wasUpToDate)
             WriteEvent(61, fileItemSpec, wasUpToDate);
         }
 
+        [Event(62, Keywords = Keywords.All)]
+        public void SdkResolverServiceInitializeStart()
+        {
+            WriteEvent(62);
+        }
+
+        [Event(63, Keywords = Keywords.All)]
+        public void SdkResolverServiceInitializeStop(int resolverCount)
+        {
+            WriteEvent(63, resolverCount);
+        }
+
+        [Event(64, Keywords = Keywords.All)]
+        public void SdkResolverResolveSdkStart()
+        {
+            WriteEvent(64);
+        }
+
+        [Event(65, Keywords = Keywords.All)]
+        public void SdkResolverResolveSdkStop(string resolverName, string sdkName, string solutionPath, string projectPath, string sdkPath, bool success)
+        {
+            WriteEvent(65, resolverName, sdkName, solutionPath, projectPath, sdkPath, success);
+        }
+
+        [Event(66, Keywords = Keywords.All)]
+        public void CachedSdkResolverServiceResolveSdkStart(string sdkName, string solutionPath, string projectPath)
+        {
+            WriteEvent(66, sdkName, solutionPath, projectPath);
+        }
+
+        [Event(67, Keywords = Keywords.All)]
+        public void CachedSdkResolverServiceResolveSdkStop(string sdkName, string solutionPath, string projectPath, bool success)
+        {
+            WriteEvent(67, sdkName, solutionPath, projectPath, success);
+        }
+
         #endregion
     }
 }
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index c9dbd905e72..c6909ccceb1 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -57,6 +57,23 @@ public void GatherCommandLineSwitchesTwoProperties()
             parameters[1].ShouldBe("c=d");
         }
 
+        [Fact]
+        public void GatherCommandLineSwitchesAnyDash()
+        {
+            var switches = new CommandLineSwitches();
+
+            var arguments = new List<string> {
+                "-p:a=b",
+                "--p:maxcpucount=8"
+            };
+
+            MSBuildApp.GatherCommandLineSwitches(arguments, switches);
+
+            string[] parameters = switches[CommandLineSwitches.ParameterizedSwitch.Property];
+            parameters[0].ShouldBe("a=b");
+            parameters[1].ShouldBe("maxcpucount=8");
+        }
+
         [Fact]
         public void GatherCommandLineSwitchesMaxCpuCountWithArgument()
         {
@@ -392,46 +409,85 @@ public void ExtractSwitchParametersTest()
         {
             string commandLineArg = "\"/p:foo=\"bar";
             string unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out var doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":\"foo=\"bar");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":\"foo=\"bar");
             doubleQuotesRemovedFromArg.ShouldBe(2);
 
             commandLineArg = "\"/p:foo=bar\"";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar");
             doubleQuotesRemovedFromArg.ShouldBe(2);
 
             commandLineArg = "/p:foo=bar";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar");
             doubleQuotesRemovedFromArg.ShouldBe(0);
 
             commandLineArg = "\"\"/p:foo=bar\"";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar\"");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar\"");
             doubleQuotesRemovedFromArg.ShouldBe(3);
 
             // this test is totally unreal -- we'd never attempt to extract switch parameters if the leading character is not a
             // switch indicator (either '-' or '/') -- here the leading character is a double-quote
             commandLineArg = "\"\"\"/p:foo=bar\"";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "/p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar\"");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "/p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar\"");
             doubleQuotesRemovedFromArg.ShouldBe(3);
 
             commandLineArg = "\"/pr\"operty\":foo=bar";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar");
             doubleQuotesRemovedFromArg.ShouldBe(3);
 
             commandLineArg = "\"/pr\"op\"\"erty\":foo=bar\"";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":foo=bar");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":foo=bar");
             doubleQuotesRemovedFromArg.ShouldBe(6);
 
             commandLineArg = "/p:\"foo foo\"=\"bar bar\";\"baz=onga\"";
             unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
-            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":\"foo foo\"=\"bar bar\";\"baz=onga\"");
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 1).ShouldBe(":\"foo foo\"=\"bar bar\";\"baz=onga\"");
             doubleQuotesRemovedFromArg.ShouldBe(6);
         }
+        
+        [Fact]
+        public void ExtractSwitchParametersTestDoubleDash()
+        {
+            var commandLineArg = "\"--p:foo=\"bar";
+            var unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out var doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":\"foo=\"bar");
+            doubleQuotesRemovedFromArg.ShouldBe(2);
+
+            commandLineArg = "\"--p:foo=bar\"";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":foo=bar");
+            doubleQuotesRemovedFromArg.ShouldBe(2);
+
+            commandLineArg = "--p:foo=bar";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":foo=bar");
+            doubleQuotesRemovedFromArg.ShouldBe(0);
+
+            commandLineArg = "\"\"--p:foo=bar\"";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":foo=bar\"");
+            doubleQuotesRemovedFromArg.ShouldBe(3);
+
+            commandLineArg = "\"--pr\"operty\":foo=bar";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":foo=bar");
+            doubleQuotesRemovedFromArg.ShouldBe(3);
+
+            commandLineArg = "\"--pr\"op\"\"erty\":foo=bar\"";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "property", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":foo=bar");
+            doubleQuotesRemovedFromArg.ShouldBe(6);
+
+            commandLineArg = "--p:\"foo foo\"=\"bar bar\";\"baz=onga\"";
+            unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':'), 2).ShouldBe(":\"foo foo\"=\"bar bar\";\"baz=onga\"");
+            doubleQuotesRemovedFromArg.ShouldBe(6);
+        }        
 
         [Fact]
         public void GetLengthOfSwitchIndicatorTest()
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 93185ce820a..08aaad0b333 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -105,6 +105,7 @@
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\IKeyed.cs" />
     <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
     <Compile Include="..\Shared\NativeMethodsShared.cs">
@@ -229,6 +230,7 @@
     </None>
   </ItemGroup>
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index c032f6978c2..d3511c927b5 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -720,7 +720,15 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="Compile_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="CopyToOutputDirectory"/>
+                            <xs:element name="CopyToOutputDirectory">
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
+                            </xs:element>
                             <xs:element name="VBMyExtensionTemplateID"/>
                         </xs:choice>
                     </xs:sequence>
@@ -730,6 +738,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Compile_Include" _locComment="" -->Semi-colon separated list of source files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -770,7 +788,15 @@ elementFormDefault="qualified">
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory"/>
+                            <xs:element name="CopyToOutputDirectory">
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
+                            </xs:element>
                             <xs:element name="LogicalName"/>
                         </xs:choice>
                     </xs:sequence>
@@ -780,6 +806,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="EmbeddedResource_Include" _locComment="" -->Semi-colon separated list of resource files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -819,15 +855,29 @@ elementFormDefault="qualified">
                                 </xs:annotation>
                             </xs:element>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Content_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Content_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
-                            <xs:element name="CopyToPublishDirectory" type="msb:boolean">
+                            <xs:element name="CopyToPublishDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Content_CopyToPublishDirectory" _locComment="" -->Copy file to publish directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Content_CopyToPublishDirectory" _locComment="" -->Copy file to publish directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
@@ -837,6 +887,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Content_Include" _locComment="" -->Semi-colon separated list of content files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -865,10 +925,17 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Page_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Page_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, Never, PreserveNewest or Always, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
@@ -878,6 +945,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Page_Include" _locComment="" -->Semi-colon separated list of XAML files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -906,10 +983,17 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="Resource_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="Resource_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
@@ -919,6 +1003,16 @@ elementFormDefault="qualified">
                             <xs:documentation><!-- _locID_text="Resource_Include" _locComment="" -->Semi-colon separated list of files (wildcards are allowed)</xs:documentation>
                         </xs:annotation>
                     </xs:attribute>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -947,13 +1041,30 @@ elementFormDefault="qualified">
                             </xs:element>
                             <xs:element name="Group"/>
                             <xs:element name="SubType"/>
-                            <xs:element name="CopyToOutputDirectory" type="msb:boolean">
+                            <xs:element name="CopyToOutputDirectory">
                                 <xs:annotation>
-                                    <xs:documentation><!-- _locID_text="ApplicationDefinition_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, boolean, default false)</xs:documentation>
+                                    <xs:documentation><!-- _locID_text="ApplicationDefinition_CopyToOutputDirectory" _locComment="" -->Copy file to output directory (optional, default Never)</xs:documentation>
                                 </xs:annotation>
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
                             </xs:element>
                         </xs:choice>
                     </xs:sequence>
+                    <!-- metadata may be defined as nested elements (as above) or as attributes (as below), so we duplicate these entries -->
+                    <xs:attribute name="CopyToOutputDirectory">
+                        <xs:simpleType>
+                            <xs:restriction base="xs:string">
+                                <xs:enumeration value="Never" />
+                                <xs:enumeration value="Always" />
+                                <xs:enumeration value="PreserveNewest" />
+                            </xs:restriction>
+                        </xs:simpleType>
+                    </xs:attribute>
                 </xs:extension>
             </xs:complexContent>
         </xs:complexType>
@@ -985,7 +1096,15 @@ elementFormDefault="qualified">
                                     <xs:documentation><!-- _locID_text="None_InProject" _locComment="" -->Display in user interface (optional, boolean)</xs:documentation>
                                 </xs:annotation>
                             </xs:element>
-                            <xs:element name="CopyToOutputDirectory"/>
+                            <xs:element name="CopyToOutputDirectory">
+                                <xs:simpleType>
+                                    <xs:restriction base="xs:string">
+                                        <xs:enumeration value="Never" />
+                                        <xs:enumeration value="Always" />
+                                        <xs:enumeration value="PreserveNewest" />
+                                    </xs:restriction>
+                                </xs:simpleType>
+                            </xs:element>
                         </xs:choice>
                     </xs:sequence>
                 </xs:extension>
@@ -1164,9 +1283,11 @@ elementFormDefault="qualified">
       </xs:annotation>
       <xs:simpleType>
         <xs:restriction base="xs:string">
-          <xs:enumeration value="Default" />
-          <xs:enumeration value="AllEnabledByDefault" />
-          <xs:enumeration value="AllDisabledByDefault" />
+          <xs:enumeration value="none" />
+          <xs:enumeration value="default" />
+          <xs:enumeration value="minimum" />
+          <xs:enumeration value="recommended" />
+          <xs:enumeration value="all" />
         </xs:restriction>
       </xs:simpleType>
     </xs:element>
@@ -1608,7 +1729,32 @@ elementFormDefault="qualified">
             <xs:documentation><!-- _locID_text="InstallFrom" _locComment="" -->Web, Unc, or Disk</xs:documentation>
         </xs:annotation>
     </xs:element>
-    <xs:element name="AnalysisLevel" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
+    <xs:element name="AnalysisLevel" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="AnalysisLevel" _locComment="" -->Customizes the set of rules that are enabled by default.</xs:documentation>
+      </xs:annotation>
+      <xs:simpleType>
+        <xs:restriction base="xs:string">
+          <xs:enumeration value="none" />
+          <xs:enumeration value="latest" />
+          <xs:enumeration value="latest-minimum" />
+          <xs:enumeration value="latest-recommended" />
+          <xs:enumeration value="latest-all" />
+          <xs:enumeration value="preview" />
+          <xs:enumeration value="preview-minimum" />
+          <xs:enumeration value="preview-recommended" />
+          <xs:enumeration value="preview-all" />
+          <xs:enumeration value="5.0" />
+          <xs:enumeration value="5.0-minimum" />
+          <xs:enumeration value="5.0-recommended" />
+          <xs:enumeration value="5.0-all" />
+          <xs:enumeration value="6.0" />
+          <xs:enumeration value="6.0-minimum" />
+          <xs:enumeration value="6.0-recommended" />
+          <xs:enumeration value="6.0-all" />
+        </xs:restriction>
+      </xs:simpleType>
+    </xs:element>
     <xs:element name="InstallUrl" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="IsCodeSharingProject" type="msb:boolean" substitutionGroup="msb:Property"/>
     <xs:element name="IsPackable" type="msb:boolean" substitutionGroup="msb:Property">
diff --git a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
index a03db6f636f..1714165cad1 100644
--- a/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
+++ b/src/MSBuild/NodeEndpointOutOfProcTaskHost.cs
@@ -16,10 +16,9 @@ internal class NodeEndpointOutOfProcTaskHost : NodeEndpointOutOfProcBase
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
-        internal NodeEndpointOutOfProcTaskHost(string pipeName)
+        internal NodeEndpointOutOfProcTaskHost()
         {
-            InternalConstruct(pipeName);
+            InternalConstruct();
         }
 
         #endregion // Constructors and Factories
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 6dc795d6762..d4212f1d09b 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -612,9 +612,7 @@ public NodeEngineShutdownReason Run(out Exception shutdownException)
             // Snapshot the current environment
             _savedEnvironment = CommunicationsUtilities.GetEnvironmentVariables();
 
-            string pipeName = "MSBuild" + Process.GetCurrentProcess().Id;
-
-            _nodeEndpoint = new NodeEndpointOutOfProcTaskHost(pipeName);
+            _nodeEndpoint = new NodeEndpointOutOfProcTaskHost();
             _nodeEndpoint.OnLinkStatusChanged += new LinkStatusChangedDelegate(OnLinkStatusChanged);
             _nodeEndpoint.Listen(this);
 
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 0d8f59307c4..61b9471ba63 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1092,7 +1092,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</comment>
   </data>
   <data name="UnsupportedOS" UESanitized="true" Visibility="Public">
-    <value>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</value>
+    <value>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</value>
     <comment>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</comment>
   </data>
   <data name="Using35Engine" UESanitized="true" Visibility="Public">
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 5769d82fa59..3391a53a640 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -1330,8 +1330,8 @@ Copyright (C) Microsoft Corporation. Všechna práva vyhrazena.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: MSBuild nejde spustit v této verzi operačního systému. Podporuje se jenom v systémech Windows 2000, Windows XP a novějších verzích.</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild nejde spustit v této verzi operačního systému. Podporuje se jenom v systémech Windows 7 a novějších verzích.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 9ccad6d1801..63493f136ce 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1322,8 +1322,8 @@ Copyright (C) Microsoft Corporation. Alle Rechte vorbehalten.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: MSBuild kann unter dieser Version des Betriebssystems nicht ausgeführt werden. Nur Windows 2000, Windows XP und Folgeversionen werden unterstützt.</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild kann unter dieser Version des Betriebssystems nicht ausgeführt werden. Nur Windows 7 und Folgeversionen werden unterstützt.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index e36eec845fb..956059968ba 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1331,8 +1331,8 @@ Copyright (C) Microsoft Corporation. Todos los derechos reservados.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: MSBuild no se puede ejecutar en esta versión del sistema operativo. Solo es compatible con Windows 2000, Windows XP y versiones posteriores.</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild no se ha podido ejecutar en esta versión del sistema operativo. Solo se admite en Windows 7 y versiones posteriores.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index ecd04ae29ab..a0aa66f7a84 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1322,8 +1322,8 @@ Copyright (C) Microsoft Corporation. Tous droits réservés.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: MSBuild ne s'exécute pas sur cette version du système d'exploitation. Il est pris en charge uniquement sur Windows 2000, Windows XP et les versions ultérieures.</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild ne s'exécute pas sur cette version du système d'exploitation. Il n'est pris en charge que sur Windows 7 et les versions ultérieures.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index c37e60c4dc4..200a7a77dae 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -1344,8 +1344,8 @@ Copyright (C) Microsoft Corporation. Tutti i diritti sono riservati.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: MSBuild non può essere eseguito su questa versione del sistema operativo. È supportato solo in Windows 2000, Windows XP e versioni successive.</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild non può essere eseguito su questa versione del sistema operativo. È supportato solo in Windows 7 e versioni successive.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index 58adc2124db..453bbc44766 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1322,8 +1322,8 @@ Copyright (C) Microsoft Corporation.All rights reserved.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: MSBuild はこのバージョンのオペレーティング システムでは実行できません。Windows 2000、Windows XP およびそれ以降のバージョンでのみサポートされています。</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild はこのバージョンのオペレーティング システムでは実行できません。Windows 7 およびそれ以降のバージョンでのみサポートされています。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index 4e641e8d1e0..e57ed62661a 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1322,8 +1322,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: 이 운영 체제 버전에서는 MSBuild를 실행할 수 없습니다. MSBuild는 Windows 2000 및 Windows XP 이상 버전에서만 지원됩니다.</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: 이 운영 체제 버전에서는 MSBuild를 실행할 수 없습니다. MSBuild는 Windows 7 이상의 버전에서만 지원됩니다.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 548f0673c44..c1e63e21afe 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -1336,8 +1336,8 @@ Copyright (C) Microsoft Corporation. Wszelkie prawa zastrzeżone.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: Program MSBuild nie działa w tej wersji systemu operacyjnego. Jest obsługiwany tylko w systemie Windows 2000, Windows XP oraz nowszych wersjach.</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: Program MSBuild nie działa w tej wersji systemu operacyjnego. Jest obsługiwany tylko w systemie Windows 7 i nowszych wersjach.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index e41b484c1a6..e8293005192 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1323,8 +1323,8 @@ isoladamente.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: O MSBuild não é executado nesta versão de sistema operacional. Há suporte para ele somente nas versões Windows 2000, Windows XP e versões posteriores.</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: O MSBuild não é executado nesta versão do sistema operacional. É suportado apenas no Windows 7 e em versões posteriores.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 4ef8b52a05a..d5f02251680 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1321,8 +1321,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: MSBuild не работает в этой версии операционной системы. Он поддерживается только в Windows 2000, Windows XP и более поздних версиях.</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild не работает в этой версии операционной системы. Он поддерживается только в Windows 7, Windows XP и более поздних версиях.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 8bed4f53eff..06ed57c5523 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1326,8 +1326,8 @@ Telif Hakkı (C) Microsoft Corporation. Tüm hakları saklıdır.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: MSBuild işletim sisteminin bu sürümünde çalışmaz. Yalnızca Windows 2000, Windows XP ve sonraki sürümlerde desteklenir.</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild işletim sisteminin bu sürümünde çalışmaz. Yalnızca Windows 7 ve üzeri sürümlerde desteklenir.</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 011389fa1a6..3a68a4c3a6b 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1322,8 +1322,8 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: MSBuild 不能在此版本的操作系统上运行。它仅在 Windows 2000、Windows XP 及更高版本的操作系统上受支持。</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild 不在此版本操作系统上运行，而仅在 Windows 7 及更高版本的操作系统上受支持。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index a3b1e39cf03..5992ad480da 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1322,8 +1322,8 @@ Copyright (C) Microsoft Corporation. 著作權所有，並保留一切權利。
     LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="UnsupportedOS">
-        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 2000, Windows XP, and later versions.</source>
-        <target state="translated">MSBUILD : error MSB1015: MSBuild 在此版本的作業系統上不會執行。只有在 Windows 2000、Windows XP 及更新版本才受支援。</target>
+        <source>MSBUILD : error MSB1015: MSBuild does not run on this version of the operating system. It is only supported on Windows 7 and later versions.</source>
+        <target state="translated">MSBUILD : error MSB1015: MSBuild 不會在此版本的作業系統上執行。只有在 Windows 7 及更新版本才受支援。</target>
         <note>{StrBegin="MSBUILD : error MSB1015: "}LOCALIZATION: The error prefix "MSBUILD : error MSBxxxx:" should not be localized.</note>
       </trans-unit>
       <trans-unit id="Using35Engine">
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 3a62d532f86..ae95d608193 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1545,15 +1545,13 @@ private static bool BuildProjectWithOldOM(string projectFile, string[] targets,
         private static void VerifyThrowSupportedOS()
         {
 #if FEATURE_OSVERSION
-            if ((Environment.OSVersion.Platform == PlatformID.Win32S) ||        // Win32S
-                (Environment.OSVersion.Platform == PlatformID.Win32Windows) ||  // Windows 95, Windows 98, Windows ME
-                (Environment.OSVersion.Platform == PlatformID.WinCE) ||         // Windows CE
-                ((Environment.OSVersion.Platform == PlatformID.Win32NT) &&      // Windows NT 4.0 and earlier
-                (Environment.OSVersion.Version.Major <= 4)))
+            if (Environment.OSVersion.Platform != PlatformID.Win32NT ||
+                Environment.OSVersion.Version.Major < 6 ||
+                (Environment.OSVersion.Version.Major == 6 && Environment.OSVersion.Version.Minor < 1)) // Windows 7 is minimum
             {
                 // If we're running on any of the unsupported OS's, fail immediately.  This way,
                 // we don't run into some obscure error down the line, totally confusing the user.
-                InitializationException.VerifyThrow(false, "UnsupportedOS");
+                InitializationException.Throw("UnsupportedOS", null, null, false);
             }
 #endif
         }
@@ -1706,8 +1704,8 @@ internal static void GatherCommandLineSwitches(List<string> commandLineArgs, Com
                             }
                             else
                             {
-                                switchName = unquotedCommandLineArg.Substring(switchIndicatorsLength, switchParameterIndicator - 1);
-                                switchParameters = ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, switchName, switchParameterIndicator);
+                                switchName = unquotedCommandLineArg.Substring(switchIndicatorsLength, switchParameterIndicator - switchIndicatorsLength);
+                                switchParameters = ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, switchName, switchParameterIndicator, switchIndicatorsLength);
                             }
                         }
 
@@ -1766,6 +1764,7 @@ internal static void GatherCommandLineSwitches(List<string> commandLineArgs, Com
         /// <param name="doubleQuotesRemovedFromArg"></param>
         /// <param name="switchName"></param>
         /// <param name="switchParameterIndicator"></param>
+        /// <param name="switchIndicatorsLength"></param>
         /// <returns>The given switch's parameters (with interesting quoting preserved).</returns>
         internal static string ExtractSwitchParameters
         (
@@ -1773,7 +1772,8 @@ internal static string ExtractSwitchParameters
             string unquotedCommandLineArg,
             int doubleQuotesRemovedFromArg,
             string switchName,
-            int switchParameterIndicator
+            int switchParameterIndicator,
+            int switchIndicatorsLength
         )
         {
 
@@ -1785,7 +1785,7 @@ int switchParameterIndicator
             // check if there is any quoting in the name portion of the switch
             string unquotedSwitchIndicatorAndName = QuotingUtilities.Unquote(commandLineArg.Substring(0, quotedSwitchParameterIndicator), out var doubleQuotesRemovedFromSwitchIndicatorAndName);
 
-            ErrorUtilities.VerifyThrow(switchName == unquotedSwitchIndicatorAndName.Substring(1),
+            ErrorUtilities.VerifyThrow(switchName == unquotedSwitchIndicatorAndName.Substring(switchIndicatorsLength),
                 "The switch name extracted from either the partially or completely unquoted arg should be the same.");
 
             ErrorUtilities.VerifyThrow(doubleQuotesRemovedFromArg >= doubleQuotesRemovedFromSwitchIndicatorAndName,
@@ -2843,7 +2843,7 @@ DirectoryGetFiles getFiles
                 // If there is more than one solution file in the current directory we have no idea which one to use
                 else if (actualSolutionFiles.Count > 1)
                 {
-                    InitializationException.VerifyThrow(false, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory);
+                    InitializationException.VerifyThrow(false, projectDirectory == null ? "AmbiguousProjectError" : "AmbiguousProjectDirectoryError", null, projectDirectory, false);
                 }
                 // If there is more than one project file in the current directory we may be able to figure it out
                 else if (actualProjectFiles.Count > 1)
@@ -2883,7 +2883,7 @@ DirectoryGetFiles getFiles
                          actualSolutionFiles.Count== 0 &&
                          solutionFilterFiles.Count == 0)
                 {
-                    InitializationException.VerifyThrow(false, "MissingProjectError");
+                    InitializationException.Throw("MissingProjectError", null, null, false);
                 }
                 else
                 {
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 93697e88064..9583cfd1e04 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -127,15 +127,15 @@
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
         <dependentAssembly>
           <assemblyIdentity name="FxCopTask" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\FxCopTask.dll" />
+          <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\FxCopTask.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
+          <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
+          <codeBase version="17.0.0.0" href="..\..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
       </assemblyBinding>
     </runtime>
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 047b20fb44c..8fd02af793e 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -119,15 +119,15 @@
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
         <dependentAssembly>
           <assemblyIdentity name="FxCopTask" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\FxCopTask.dll" />
+          <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\FxCopTask.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
+          <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.dll" />
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.VisualStudio.CodeAnalysis.Sdk" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <codeBase version="16.0.0.0" href="..\..\Microsoft\VisualStudio\v16.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
+          <codeBase version="17.0.0.0" href="..\..\Microsoft\VisualStudio\v17.0\CodeAnalysis\Microsoft.VisualStudio.CodeAnalysis.Sdk.dll" />
         </dependentAssembly>
       </assemblyBinding>
     </runtime>
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index 66f5bc78f00..b26225401f6 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -108,6 +108,7 @@
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Modifiers.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\NativeMethodsShared.cs">
       <Link>NativeMethodsShared.cs</Link>
     </Compile>
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index 2918e172a5c..04a42dbfce4 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -31,6 +31,7 @@
     <file src="$X86BinPath$/Microsoft.Build.Framework.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.Build.Tasks.Core.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.IO.Redist.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin" />
@@ -87,6 +88,7 @@
     <file src="$X86BinPath$/Microsoft.Build.Framework.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.Build.Tasks.Core.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.IO.Redist.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin/amd64" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 67e5764974d..fc7164e4899 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -32,6 +32,7 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(X86BinPath)Microsoft.Build.Framework.tlb
   file source=$(X86BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenApplications="[installDir]\Common7\IDE\vsn.exe" vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe vs.file.ngenArchitecture=x86 vs.file.ngenPriority=1
   file source=$(X86BinPath)MSBuild.exe.config
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe vs.file.ngenArchitecture=x86
@@ -184,6 +185,7 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 4b118f31594..3c472f898d0 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -60,7 +60,12 @@ internal enum HandshakeOptions
         /// <summary>
         /// Building with administrator privileges
         /// </summary>
-        Administrator = 32
+        Administrator = 32,
+
+        /// <summary>
+        /// Using the .NET Core/.NET 5.0+ runtime
+        /// </summary>
+        NET = 64,
     }
 
     internal readonly struct Handshake
@@ -75,7 +80,7 @@ internal readonly struct Handshake
 
         internal Handshake(HandshakeOptions nodeType)
         {
-            // We currently use 6 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
+            // We currently use 7 bits of this 32-bit integer. Very old builds will instantly reject any handshake that does not start with F5 or 06; slightly old builds always lead with 00.
             // This indicates in the first byte that we are a modern build.
             options = (int)nodeType | (((int)CommunicationsUtilities.handshakeVersion) << 24);
             string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
@@ -492,7 +497,23 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.runtime, out string runtimeVersion), "Should always have an explicit runtime when we call this method.");
                     ErrorUtilities.VerifyThrow(taskHostParameters.TryGetValue(XMakeAttributes.architecture, out string architecture), "Should always have an explicit architecture when we call this method.");
 
-                    clrVersion = runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ? 4 : 2;
+                    if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr2, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 2;
+                    } 
+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 4;
+                    }
+                    else if (runtimeVersion.Equals(XMakeAttributes.MSBuildRuntimeValues.net, StringComparison.OrdinalIgnoreCase))
+                    {
+                        clrVersion = 5;
+                    }
+                    else
+                    {
+                        ErrorUtilities.ThrowInternalErrorUnreachable();
+                    }
+
                     is64Bit = architecture.Equals(XMakeAttributes.MSBuildArchitectureValues.x64);
                 }
             }
@@ -501,10 +522,26 @@ internal static HandshakeOptions GetHandshakeOptions(bool taskHost, bool is64Bit
             {
                 context |= HandshakeOptions.X64;
             }
-            if (clrVersion == 2)
+
+            switch (clrVersion)
             {
-                context |= HandshakeOptions.CLR2;
+                case 0:
+                    // Not a taskhost, runtime must match
+                case 4:
+                    // Default for MSBuild running on .NET Framework 4,
+                    // not represented in handshake
+                    break;
+                case 2:
+                    context |= HandshakeOptions.CLR2;
+                    break;
+                case >= 5:
+                    context |= HandshakeOptions.NET;
+                    break;
+                default:
+                    ErrorUtilities.ThrowInternalErrorUnreachable();
+                    break;
             }
+
             if (nodeReuse)
             {
                 context |= HandshakeOptions.NodeReuse;
diff --git a/src/Shared/Constants.cs b/src/Shared/Constants.cs
index 6289ef54bef..9a36fc1816e 100644
--- a/src/Shared/Constants.cs
+++ b/src/Shared/Constants.cs
@@ -77,6 +77,16 @@ internal static class MSBuildConstants
         /// </summary>
         internal const string DefaultTargetsMarker = ".default";
 
+        /// <summary>
+        /// Framework version against which our test projects should be built.
+        /// </summary>
+        /// <remarks>
+        /// The targeting pack for this version of .NET Framework must be installed
+        /// on any machine that wants to run tests successfully, so this can be
+        /// periodically updated.
+        /// </remarks>
+        internal const string StandardTestTargetFrameworkVersion = "v4.8";
+
         /// <summary>
         /// Symbol used in ProjectReferenceTarget items to represent targets specified on the ProjectReference item
         /// with fallback to default targets if the ProjectReference item has no targets specified.
diff --git a/src/Shared/ConversionUtilities.cs b/src/Shared/ConversionUtilities.cs
index 351b3b04e46..a6febc5c973 100644
--- a/src/Shared/ConversionUtilities.cs
+++ b/src/Shared/ConversionUtilities.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Globalization;
 using System.Text;
-using error = Microsoft.Build.Shared.ErrorUtilities;
+using Error = Microsoft.Build.Shared.ErrorUtilities;
 
 namespace Microsoft.Build.Shared
 {
@@ -33,7 +33,7 @@ internal static bool ConvertStringToBool(string parameterValue)
             else
             {
                 // Unsupported boolean representation.
-                error.VerifyThrowArgument(false, "Shared.CannotConvertStringToBool", parameterValue);
+                Error.ThrowArgument("Shared.CannotConvertStringToBool", parameterValue);
                 return false;
             }
         }
@@ -64,6 +64,21 @@ internal static string ConvertByteArrayToHex(byte[] bytes)
             return sb.ToString();
         }
 
+        internal static bool TryConvertStringToBool(string parameterValue, out bool boolValue)
+        {
+            boolValue = false;
+            if (ValidBooleanTrue(parameterValue))
+            {
+                boolValue = true;
+                return true;
+            }
+            else if (ValidBooleanFalse(parameterValue))
+            {
+                return true;
+            }
+            return false;
+        }
+
         /// <summary>
         /// Returns true if the string can be successfully converted to a bool,
         /// such as "on" or "yes"
@@ -123,30 +138,40 @@ internal static double ConvertHexToDouble(string number)
         /// </summary>
         internal static double ConvertDecimalOrHexToDouble(string number)
         {
-            if (ConversionUtilities.ValidDecimalNumber(number))
+            if (TryConvertDecimalOrHexToDouble(number, out double result))
             {
-                return ConversionUtilities.ConvertDecimalToDouble(number);
+                return result;
             }
-            else if (ConversionUtilities.ValidHexNumber(number))
+            Error.ThrowInternalError("Cannot numeric evaluate");
+            return 0.0D;
+        }
+
+        internal static bool TryConvertDecimalOrHexToDouble(string number, out double doubleValue)
+        {
+            if (ConversionUtilities.ValidDecimalNumber(number, out doubleValue))
             {
-                return ConversionUtilities.ConvertHexToDouble(number);
+                return true;
+            }
+            else if (ConversionUtilities.ValidHexNumber(number, out int hexValue))
+            {
+                doubleValue = (double)hexValue;
+                return true;
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Cannot numeric evaluate");
-                return 0.0D;
+                return false;
             }
         }
 
         /// <summary>
         /// Returns true if the string is a valid hex number, like "0xABC"
         /// </summary>
-        private static bool ValidHexNumber(string number)
+        private static bool ValidHexNumber(string number, out int value)
         {
             bool canConvert = false;
+            value = 0;
             if (number.Length >= 3 && number[0] == '0' && (number[1] == 'x' || number[1] == 'X'))
             {
-                int value;
                 canConvert = Int32.TryParse(number.Substring(2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture.NumberFormat, out value);
             }
             return canConvert;
@@ -155,9 +180,8 @@ private static bool ValidHexNumber(string number)
         /// <summary>
         /// Returns true if the string is a valid decimal number, like "-123.456"
         /// </summary>
-        private static bool ValidDecimalNumber(string number)
+        private static bool ValidDecimalNumber(string number, out double value)
         {
-            double value;
             return Double.TryParse(number, NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture.NumberFormat, out value) && !double.IsInfinity(value);
         }
 
@@ -166,7 +190,7 @@ private static bool ValidDecimalNumber(string number)
         /// </summary>
         internal static bool ValidDecimalOrHexNumber(string number)
         {
-            return ValidDecimalNumber(number) || ValidHexNumber(number);
+            return ValidDecimalNumber(number, out _) || ValidHexNumber(number, out _);
         }
     }
 }
diff --git a/src/Shared/EncodingUtilities.cs b/src/Shared/EncodingUtilities.cs
index 1a74d635c1c..c492d063165 100644
--- a/src/Shared/EncodingUtilities.cs
+++ b/src/Shared/EncodingUtilities.cs
@@ -219,16 +219,6 @@ internal static Encoding BatchFileEncoding(string contents, string encodingSpeci
 
             string useUtf8 = string.IsNullOrEmpty(encodingSpecification) ? EncodingUtilities.UseUtf8Detect : encodingSpecification;
 
-#if FEATURE_OSVERSION
-            // UTF8 is only supported in Windows 7 (6.1) or greater.
-            var windows7 = new Version(6, 1);
-
-            if (Environment.OSVersion.Version < windows7)
-            {
-                useUtf8 = EncodingUtilities.UseUtf8Never;
-            }
-#endif
-
             switch (useUtf8.ToUpperInvariant())
             {
                 case EncodingUtilities.UseUtf8Always:
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 9bb3502596b..05dcb114de3 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -488,7 +488,7 @@ params object[] args
         /// <param name="innerException">Can be null.</param>
         /// <param name="resourceName"></param>
         /// <param name="args"></param>
-        private static void ThrowArgument
+        internal static void ThrowArgument
         (
             Exception innerException,
             string resourceName,
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 9af0619bab7..cca9caee3b3 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -132,7 +132,7 @@ internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemE
                                     directory,
                                     false));
                         IEnumerable<string> filteredEntriesForPath = (pattern != null && !IsAllFilesWildcard(pattern))
-                            ? allEntriesForPath.Where(o => IsMatch(Path.GetFileName(o), pattern))
+                            ? allEntriesForPath.Where(o => IsFileNameMatch(o, pattern))
                             : allEntriesForPath;
                         return stripProjectDirectory
                             ? RemoveProjectDirectory(filteredEntriesForPath, directory).ToArray()
@@ -244,9 +244,9 @@ private static IReadOnlyList<string> GetAccessibleFileSystemEntries(IFileSystem
             {
                 case FileSystemEntity.Files: return GetAccessibleFiles(fileSystem, path, pattern, projectDirectory, stripProjectDirectory);
                 case FileSystemEntity.Directories: return GetAccessibleDirectories(fileSystem, path, pattern);
-                case FileSystemEntity.FilesAndDirectories: return GetAccessibleFilesAndDirectories(fileSystem,path, pattern);
+                case FileSystemEntity.FilesAndDirectories: return GetAccessibleFilesAndDirectories(fileSystem, path, pattern);
                 default:
-                    ErrorUtilities.VerifyThrow(false, "Unexpected filesystem entity type.");
+                    ErrorUtilities.ThrowInternalError("Unexpected filesystem entity type.");
                     break;
             }
             return Array.Empty<string>();
@@ -268,7 +268,7 @@ private static IReadOnlyList<string> GetAccessibleFilesAndDirectories(IFileSyste
                 {
                     return (ShouldEnforceMatching(pattern)
                         ? fileSystem.EnumerateFileSystemEntries(path, pattern)
-                            .Where(o => IsMatch(Path.GetFileName(o), pattern))
+                            .Where(o => IsFileNameMatch(o, pattern))
                         : fileSystem.EnumerateFileSystemEntries(path, pattern)
                         ).ToArray();
                 }
@@ -351,7 +351,7 @@ bool stripProjectDirectory
                     files = fileSystem.EnumerateFiles(dir, filespec);
                     if (ShouldEnforceMatching(filespec))
                     {
-                        files = files.Where(o => IsMatch(Path.GetFileName(o), filespec));
+                        files = files.Where(o => IsFileNameMatch(o, filespec));
                     }
                 }
                 // If the Item is based on a relative path we need to strip
@@ -414,7 +414,7 @@ string pattern
                     directories = fileSystem.EnumerateDirectories((path.Length == 0) ? s_thisDirectory : path, pattern);
                     if (ShouldEnforceMatching(pattern))
                     {
-                        directories = directories.Where(o => IsMatch(Path.GetFileName(o), pattern));
+                        directories = directories.Where(o => IsFileNameMatch(o, pattern));
                     }
                 }
 
@@ -956,7 +956,7 @@ private void GetFilesRecursive(
                     for (int i = 0; i < excludeNextSteps.Length; i++)
                     {
                         if (excludeNextSteps[i].NeedsDirectoryRecursion &&
-                            (excludeNextSteps[i].DirectoryPattern == null || IsMatch(Path.GetFileName(subdir), excludeNextSteps[i].DirectoryPattern)))
+                            (excludeNextSteps[i].DirectoryPattern == null || IsFileNameMatch(subdir, excludeNextSteps[i].DirectoryPattern)))
                         {
                             RecursionState thisExcludeStep = searchesToExclude[i];
                             thisExcludeStep.BaseDirectory = subdir;
@@ -1097,7 +1097,7 @@ private static bool MatchFileRecursionStep(RecursionState recursionState, string
             }
             else if (recursionState.SearchData.Filespec != null)
             {
-                return IsMatch(Path.GetFileName(file), recursionState.SearchData.Filespec);
+                return IsFileNameMatch(file, recursionState.SearchData.Filespec);
             }
 
             // if no file-spec provided, match the file to the regular expression
@@ -1664,12 +1664,39 @@ internal Result()
             internal string wildcardDirectoryPart = string.Empty;
         }
 
+        /// <summary>
+        /// A wildcard (* and ?) matching algorithm that tests whether the input path file name matches against the pattern.
+        /// </summary>
+        /// <param name="path">The path whose file name is matched against the pattern.</param>
+        /// <param name="pattern">The pattern.</param>
+        internal static bool IsFileNameMatch(string path, string pattern)
+        {
+            // Use a span-based Path.GetFileName if it is available.
+#if FEATURE_MSIOREDIST
+            return IsMatch(Microsoft.IO.Path.GetFileName(path.AsSpan()), pattern);
+#elif NETSTANDARD2_0
+            return IsMatch(Path.GetFileName(path), pattern);
+#else
+            return IsMatch(Path.GetFileName(path.AsSpan()), pattern);
+#endif
+        }
+
         /// <summary>
         /// A wildcard (* and ?) matching algorithm that tests whether the input string matches against the pattern.
         /// </summary>
         /// <param name="input">String which is matched against the pattern.</param>
         /// <param name="pattern">Pattern against which string is matched.</param>
         internal static bool IsMatch(string input, string pattern)
+        {
+            return IsMatch(input.AsSpan(), pattern);
+        }
+
+        /// <summary>
+        /// A wildcard (* and ?) matching algorithm that tests whether the input string matches against the pattern.
+        /// </summary>
+        /// <param name="input">String which is matched against the pattern.</param>
+        /// <param name="pattern">Pattern against which string is matched.</param>
+        internal static bool IsMatch(ReadOnlySpan<char> input, string pattern)
         {
             if (input == null)
             {
@@ -1705,9 +1732,12 @@ internal static bool IsMatch(string input, string pattern)
             // to using the string indexer. The iIndex and pIndex parameters are only used
             // when we have to compare two non ASCII characters. Using just string.Compare for
             // character comparison, would reduce the speed by approx. 5 times.
-            bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
+            bool CompareIgnoreCase(ref ReadOnlySpan<char> input, int iIndex, int pIndex)
 #endif
             {
+                char inputChar = input[iIndex];
+                char patternChar = pattern[pIndex];
+
                 // We will mostly be comparing ASCII characters, check English letters first.
                 char inputCharLower = (char)(inputChar | 0x20);
                 if (inputCharLower >= 'a' && inputCharLower <= 'z')
@@ -1721,7 +1751,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                     // and a non ASCII character cannot have its lowercase/uppercase inside the ASCII table
                     return inputChar == patternChar;
                 }
-                return string.Compare(input, iIndex, pattern, pIndex, 1, StringComparison.OrdinalIgnoreCase) == 0;
+                return MemoryExtensions.Equals(input.Slice(iIndex, 1), pattern.AsSpan(pIndex, 1), StringComparison.OrdinalIgnoreCase);
             }
 #if MONO
             ; // The end of the CompareIgnoreCase anonymous function
@@ -1761,7 +1791,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                                     break;
                                 }
                                 // If the tail doesn't match, we can safely return e.g. ("aaa", "*b")
-                                if (!CompareIgnoreCase(input[inputTailIndex], pattern[patternTailIndex], patternTailIndex, inputTailIndex) &&
+                                if (!CompareIgnoreCase(ref input, inputTailIndex, patternTailIndex) &&
                                     pattern[patternTailIndex] != '?')
                                 {
                                     return false;
@@ -1781,7 +1811,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                         // The ? wildcard cannot be skipped as we will have a wrong result for e.g. ("aab" "*?b")
                         if (pattern[patternIndex] != '?')
                         {
-                            while (!CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex))
+                            while (!CompareIgnoreCase(ref input, inputIndex, patternIndex))
                             {
                                 // Return if there is no character that match e.g. ("aa", "*b")
                                 if (++inputIndex >= inputLength)
@@ -1796,7 +1826,7 @@ bool CompareIgnoreCase(char inputChar, char patternChar, int iIndex, int pIndex)
                     }
 
                     // If we have a match, step to the next character
-                    if (CompareIgnoreCase(input[inputIndex], pattern[patternIndex], inputIndex, patternIndex) ||
+                    if (CompareIgnoreCase(ref input, inputIndex, patternIndex) ||
                         pattern[patternIndex] == '?')
                     {
                         patternIndex++;
@@ -2557,14 +2587,14 @@ private static bool IsSubdirectoryOf(string possibleChild, string possibleParent
         private static bool DirectoryEndsWithPattern(string directoryPath, string pattern)
         {
             int index = directoryPath.LastIndexOfAny(FileUtilities.Slashes);
-            return (index != -1 && IsMatch(directoryPath.Substring(index + 1), pattern));
+            return (index != -1 && IsMatch(directoryPath.AsSpan(index + 1), pattern));
         }
 
         /// <summary>
         /// Returns true if <paramref name="pattern"/> is <code>*</code> or <code>*.*</code>.
         /// </summary>
         /// <param name="pattern">The filename pattern to check.</param>
-        private static bool IsAllFilesWildcard(string pattern) => pattern?.Length switch
+        internal static bool IsAllFilesWildcard(string pattern) => pattern?.Length switch
         {
             1 => pattern[0] == '*',
             3 => pattern[0] == '*' && pattern[1] == '.' && pattern[2] == '*',
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index 6d8bd32fb4e..d5d80a07e35 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -1,6 +1,7 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using Microsoft.Build.Utilities;
 using System;
 using System.Collections.Generic;
 using System.IO;
@@ -16,6 +17,20 @@ internal class ManagedFileSystem : IFileSystem
 
         public static ManagedFileSystem Singleton() => ManagedFileSystem.Instance;
 
+        private static bool ShouldUseMicrosoftIO
+        {
+            get
+            {
+#if !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+                return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0);
+#else
+                // We need to mock usage of ChangeWaves class,
+                // because Microsoft.Build.Engine.OM.UnitTests should not have access to internals of Microsoft.Build.Framework.
+                return true;
+#endif
+            }
+        }
+
         protected ManagedFileSystem() { }
 
         public TextReader ReadFile(string path)
@@ -38,19 +53,78 @@ public byte[] ReadFileAllBytes(string path)
             return File.ReadAllBytes(path);
         }
 
+#if FEATURE_MSIOREDIST
+        private static IEnumerable<string> HandleFileLoadException(
+            Func<string, string, Microsoft.IO.SearchOption, IEnumerable<string>> enumerateFunctionDelegate,
+            string path,
+            string searchPattern,
+            Microsoft.IO.SearchOption searchOption
+        )
+        {
+            try
+            {
+                return enumerateFunctionDelegate(path, searchPattern, searchOption);
+            }
+            // Microsoft.IO.Redist has a dependency on System.Buffers and if System.Buffers assembly is not found the line above throws an exception.
+            // However, FileMatcher class (that in most cases calls the enumeration) does not allow to fail on a IO-related exception. Such behavior hides the actual exception and makes it obscure.
+            // We rethrow it to make it fail with a proper error message and call stack.
+            catch (FileLoadException ex)
+            {
+                throw new InvalidOperationException(ex.Message, ex);
+            }
+            // Sometimes FileNotFoundException is thrown when there is an assembly load failure. In this case it should have FusionLog.
+            catch (FileNotFoundException ex) when (ex.FusionLog != null)
+            {
+                throw new InvalidOperationException(ex.Message, ex);
+            }
+        }
+#endif
+
         public virtual IEnumerable<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption)
         {
+#if FEATURE_MSIOREDIST
+            return ShouldUseMicrosoftIO
+                ? HandleFileLoadException(
+                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateFiles(path, searchPattern, searchOption),
+                    path,
+                    searchPattern,
+                    (Microsoft.IO.SearchOption)searchOption
+                )
+                : Directory.EnumerateFiles(path, searchPattern, searchOption);
+#else
             return Directory.EnumerateFiles(path, searchPattern, searchOption);
+#endif
         }
 
         public virtual IEnumerable<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption)
         {
+#if FEATURE_MSIOREDIST
+            return ShouldUseMicrosoftIO
+                ? HandleFileLoadException(
+                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateDirectories(path, searchPattern, searchOption),
+                    path,
+                    searchPattern,
+                    (Microsoft.IO.SearchOption)searchOption
+                )
+                : Directory.EnumerateDirectories(path, searchPattern, searchOption);
+#else
             return Directory.EnumerateDirectories(path, searchPattern, searchOption);
+#endif
         }
 
         public virtual IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption)
         {
+#if FEATURE_MSIOREDIST
+            return ShouldUseMicrosoftIO
+                ? HandleFileLoadException(
+                    (path, searchPattern, searchOption) => Microsoft.IO.Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption),
+                    path,
+                    searchPattern, (Microsoft.IO.SearchOption)searchOption
+                )
+                : Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+#else
             return Directory.EnumerateFileSystemEntries(path, searchPattern, searchOption);
+#endif
         }
 
         public FileAttributes GetAttributes(string path)
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 76155b33800..952fd9963d4 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -903,7 +903,7 @@ internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSys
                 fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
-                    ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.DirectoryExists)
+                    ? FileExistenceCache.GetOrAdd(fullPath, fullPath => fileSystem.DirectoryExists(fullPath))
                     : fileSystem.DirectoryExists(fullPath);
             }
             catch
@@ -927,7 +927,7 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =
                 fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
-                    ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.FileExists)
+                    ? FileExistenceCache.GetOrAdd(fullPath, fullPath => fileSystem.FileExists(fullPath))
                     : fileSystem.FileExists(fullPath);
             }
             catch
@@ -951,7 +951,7 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
                 fileSystem ??= DefaultFileSystem;
 
                 return Traits.Instance.CacheFileExistence
-                    ? FileExistenceCache.GetOrAdd(fullPath, fileSystem.FileOrDirectoryExists)
+                    ? FileExistenceCache.GetOrAdd(fullPath, fullPath => fileSystem.FileOrDirectoryExists(fullPath))
                     : fileSystem.FileOrDirectoryExists(fullPath);
             }
             catch
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index afdbc7fefec..42237dde8c9 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -976,13 +976,10 @@ internal static string GenerateReferenceAssemblyPath(string targetFrameworkRootP
 
             try
             {
-                string path = targetFrameworkRootPath;
-                path = Path.Combine(path, frameworkName.Identifier);
-                path = Path.Combine(path, "v" + frameworkName.Version.ToString());
+                string path = Path.Combine(targetFrameworkRootPath, frameworkName.Identifier, "v" + frameworkName.Version.ToString());
                 if (!String.IsNullOrEmpty(frameworkName.Profile))
                 {
-                    path = Path.Combine(path, "Profile");
-                    path = Path.Combine(path, frameworkName.Profile);
+                    path = Path.Combine(path, "Profile", frameworkName.Profile);
                 }
 
                 return Path.GetFullPath(path);
diff --git a/src/Shared/Modifiers.cs b/src/Shared/Modifiers.cs
index 1ad37579cb6..bfb564d884b 100644
--- a/src/Shared/Modifiers.cs
+++ b/src/Shared/Modifiers.cs
@@ -599,7 +599,7 @@ internal static string GetItemSpecModifier(string currentDirectory, string itemS
                 }
                 catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                 {
-                    ErrorUtilities.VerifyThrowInvalidOperation(false, "Shared.InvalidFilespecForTransform", modifier, itemSpec, e.Message);
+                    ErrorUtilities.ThrowInvalidOperation("Shared.InvalidFilespecForTransform", modifier, itemSpec, e.Message);
                 }
 
                 return modifiedItemSpec;
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index a7f8913e7d7..e3b1341515f 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -1,15 +1,24 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
+using System.Diagnostics;
 using System.IO;
 
+#nullable enable
+
 namespace Microsoft.Build.Shared
 {
     internal static class NamedPipeUtil
     {
-        internal static string GetPipeNameOrPath(string pipeName)
+        internal static string GetPipeNameOrPath(int? processId = null)
         {
+            if (processId is null)
+            {
+                processId = Process.GetCurrentProcess().Id;
+            }
+
+            string pipeName = $"MSBuild{processId}";
+
             if (NativeMethodsShared.IsUnixLike)
             {
                 // If we're on a Unix machine then named pipes are implemented using Unix Domain Sockets.
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 09314174d36..810125d90ac 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -876,33 +876,6 @@ private static SystemInformationData SystemInformation
 
 #endregion
 
-#region Set Error Mode (copied from BCL)
-
-        private static readonly Version s_threadErrorModeMinOsVersion = new Version(6, 1, 0x1db0);
-
-        internal static int SetErrorMode(int newMode)
-        {
-#if FEATURE_OSVERSION
-            if (Environment.OSVersion.Version < s_threadErrorModeMinOsVersion)
-            {
-                return SetErrorMode_VistaAndOlder(newMode);
-            }
-#endif
-            int num;
-            SetErrorMode_Win7AndNewer(newMode, out num);
-            return num;
-        }
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", EntryPoint = "SetThreadErrorMode", SetLastError = true)]
-        private static extern bool SetErrorMode_Win7AndNewer(int newMode, out int oldMode);
-
-        [SuppressMessage("Microsoft.Design", "CA1060:MovePInvokesToNativeMethodsClass", Justification = "Class name is NativeMethodsShared for increased clarity")]
-        [DllImport("kernel32.dll", EntryPoint = "SetErrorMode", ExactSpelling = true)]
-        private static extern int SetErrorMode_VistaAndOlder(int newMode);
-
-#endregion
-
 #region Wrapper methods
 
         /// <summary>
@@ -1636,9 +1609,11 @@ out FILETIME lpLastWriteTime
 
         [DllImport("kernel32.dll", SetLastError = true)]
         [return: MarshalAs(UnmanagedType.Bool)]
-
         internal static extern bool CloseHandle(IntPtr hObject);
 
+        [DllImport("kernel32.dll", SetLastError = true)]
+        internal static extern bool SetThreadErrorMode(int newMode, out int oldMode);
+
 #endregion
 
 #region Extensions
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 3d468e23e95..4562c4309d7 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -183,11 +183,8 @@ public void SendData(INodePacket packet)
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
-        internal void InternalConstruct(string pipeName)
+        internal void InternalConstruct()
         {
-            ErrorUtilities.VerifyThrowArgumentLength(pipeName, nameof(pipeName));
-
             _status = LinkStatus.Inactive;
             _asyncDataMonitor = new object();
             _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
@@ -195,6 +192,8 @@ internal void InternalConstruct(string pipeName)
             _packetStream = new MemoryStream();
             _binaryWriter = new BinaryWriter(_packetStream);
 
+            string pipeName = NamedPipeUtil.GetPipeNameOrPath();
+
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
             if (!NativeMethodsShared.IsMono)
             {
diff --git a/src/Shared/ProjectErrorUtilities.cs b/src/Shared/ProjectErrorUtilities.cs
index 540b26f71d1..b02ed0ef6c3 100644
--- a/src/Shared/ProjectErrorUtilities.cs
+++ b/src/Shared/ProjectErrorUtilities.cs
@@ -57,7 +57,7 @@ internal static void ThrowInvalidProject<T1>
             T1 arg0
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0);
         }
 
         /// <summary>
@@ -93,7 +93,7 @@ internal static void ThrowInvalidProject<T1, T2>
             T2 arg1
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0, arg1);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1);
         }
 
         /// <summary>
@@ -113,7 +113,7 @@ internal static void ThrowInvalidProject<T1, T2, T3>
             T3 arg2
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0, arg1, arg2);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1, arg2);
         }
 
         /// <summary>
@@ -135,7 +135,7 @@ internal static void ThrowInvalidProject<T1, T2, T3, T4>
             T4 arg3
         )
         {
-            VerifyThrowInvalidProject(false, null, elementLocation, resourceName, arg0, arg1, arg2, arg3);
+            ThrowInvalidProject(null, elementLocation, resourceName, arg0, arg1, arg2, arg3);
         }
 
         /// <summary>
@@ -396,16 +396,9 @@ params object[] args
 
             ResourceUtilities.VerifyResourceStringExists(resourceName);
 #endif
-            string errorSubCategory = null;
+            string errorSubCategory = errorSubCategoryResourceName is null ? null : AssemblyResources.GetString(errorSubCategoryResourceName);
 
-            if (errorSubCategoryResourceName != null)
-            {
-                errorSubCategory = AssemblyResources.GetString(errorSubCategoryResourceName);
-            }
-
-            string errorCode;
-            string helpKeyword;
-            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errorCode, out helpKeyword, resourceName, args);
+            string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, resourceName, args);
 
             throw new InvalidProjectFileException(elementLocation.File, elementLocation.Line, elementLocation.Column, 0 /* Unknown end line */, 0 /* Unknown end column */, message, errorSubCategory, errorCode, helpKeyword);
         }
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index d672e250e5f..bcc433204d0 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -29,7 +29,7 @@ internal static void ThrowInvalidProjectFile
             params object[] args
         )
         {
-            VerifyThrowInvalidProjectFile(false, null, projectFile, resourceName, args);
+            ThrowInvalidProjectFile(null, projectFile, resourceName, args);
         }
 
         /// <summary>
@@ -157,16 +157,8 @@ params object[] args
 #endif
             if (!condition)
             {
-                string errorSubCategory = null;
-
-                if (errorSubCategoryResourceName != null)
-                {
-                    errorSubCategory = AssemblyResources.GetString(errorSubCategoryResourceName);
-                }
-
-                string errorCode;
-                string helpKeyword;
-                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out errorCode, out helpKeyword, resourceName, args);
+                string errorSubCategory = errorSubCategoryResourceName is null ? null : AssemblyResources.GetString(errorSubCategoryResourceName);
+                string message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword(out string errorCode, out string helpKeyword, resourceName, args);
 
                 throw new InvalidProjectFileException(projectFile.File, projectFile.Line, projectFile.Column, projectFile.EndLine, projectFile.EndColumn, message, errorSubCategory, errorCode, helpKeyword, innerException);
             }
diff --git a/src/Shared/Shared Code.doc b/src/Shared/Shared Code.doc
deleted file mode 100644
index 3bb7c7745d2..00000000000
Binary files a/src/Shared/Shared Code.doc and /dev/null differ
diff --git a/src/Shared/SharedCode.md b/src/Shared/SharedCode.md
new file mode 100644
index 00000000000..955f9af23f8
--- /dev/null
+++ b/src/Shared/SharedCode.md
@@ -0,0 +1,83 @@
+# Shared Code
+
+## **Namespace**
+All shared code _must_ live in `Microsoft.Build.Shared` namespace.
+___
+
+## **Internal Access Only**
+Shared code gets compiled into every assembly as it is referenced by. However this does _not_ mean that the shared types can migrate across the assemblies they are in.
+
+Even if two types in different assemblies have the same name and are in the same namespace, the CLR does _not_ recognize the types to be the same, because their assembly identities are different.
+
+As a result all shared code _must_ have **internal** access only. There should be _no_ public types in shared code.
+___
+
+## **Resources**
+Shared code needs access to assembly resources e.g. for loading error messages for exceptions. Each assembly that shares code, _must_ define a class called `AssemblyResources` in the shared namespace, with an `internal static readonly` member of type `ResourceManager` called `resources`. Each sharing assembly is required to do this because only it knows what the manifest resource name (a.k.a. logical name) of its resources is. Shared code can then statically reference the assembly’s resources. If the `AssemblyResources` class is not defined, it is a compile-time error.
+
+The `AssemblyResources` class at a minimum must look like this:
+
+```cs
+using System.Resources;
+using System.Reflection;
+
+namespace Microsoft.Build.Shared
+{
+    internal static class AssemblyResources
+    {
+        internal static readonly ResourceManager resources =
+            new ResourceManager(
+                "<manifest resource name>",
+                Assembly.GetExecutingAssembly());
+    }
+}
+```
+
+NOTE: the class is explicitly marked `static`, because it only contains static members and methods -- making the class static prevents it from being instantiated, and allows the compiler to flag the (accidental) addition of instance members.
+___
+
+## **Shared Resources**
+Shared code sometimes needs to define its own resources. If this were not allowed, then each sharing assembly would have to redefine the same set of resources on behalf of the shared code. As with code, maintaining multiple copies of the same resources is not desirable.
+
+Shared resources must be placed in the file `Strings.shared.resx` in the shared code directory. All resource names must be prefixed with “`Shared.`” to distinguish the shared resources from an assembly’s primary resources. Each sharing assembly must add an `internal static readonly` member of type `ResourceManager`, called `sharedResources`, to the `AssemblyResources` class. This is necessary because only the sharing assembly can assign the correct manifest resource name to the shared resources. Shared code can then statically reference the shared resources. The absence of either the `AssemblyResources` class, or the `sharedResources` member is a compile-time error.
+
+For assemblies that share resources, the `AssemblyResources` class at a minimum must look like this:
+
+```cs
+using System.Resources;
+using System.Reflection;
+
+namespace Microsoft.Build.Shared
+{
+    internal static class AssemblyResources
+    {
+        internal static readonly ResourceManager resources =
+            new ResourceManager(
+                "<manifest resource name>",
+                Assembly.GetExecutingAssembly());
+
+        internal static readonly ResourceManager sharedResources =
+            new ResourceManager(
+                "<manifest resource name of shared resources>",
+                Assembly.GetExecutingAssembly());
+    }
+}
+```
+
+To simplify the retrieval of resources, the `AssemblyResources` class can optionally define a method called `GetString()` that searches both the assembly’s primary resources as well as its shared resources for a given string. For example:
+
+```cs
+internal static string GetString(string name)
+{
+    string resource = resources.GetString(name, CultureInfo.CurrentUICulture);
+
+    if (resource == null)
+    {
+        resource = sharedResources.GetString(name, CultureInfo.CurrentUICulture);
+    }
+
+    return resource;
+}
+```
+
+NOTE: if the above method is added to the `AssemblyResources` class, it is advisable to make both `resources` and `sharedResources` private (instead of `internal`) to unify access to assembly resources.
\ No newline at end of file
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 4ee21110651..7de1b7c8ab1 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -1435,7 +1435,7 @@ public bool LogMessageFromText(string lineOfText, MessageImportance messageImpor
                         }
 
                     default:
-                        ErrorUtilities.VerifyThrow(false, "Impossible canonical part.");
+                        ErrorUtilities.ThrowInternalError("Impossible canonical part.");
                         break;
                 }
             }
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index d8cf2eeed4c..471e1536b63 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -12,6 +12,7 @@
 using Microsoft.Build.Shared.FileSystem;
 using Xunit;
 using Xunit.Abstractions;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -1244,13 +1245,20 @@ public void IllegalPaths()
         [Fact]
         [PlatformSpecific(TestPlatforms.Windows)] // Nothing's too long for Unix
         [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
-        public void IllegalTooLongPath()
+        public void IllegalTooLongPathOptOutWave17_0()
         {
-            string longString = new string('X', 500) + "*"; // need a wildcard to do anything
-            string[] result = FileMatcher.Default.GetFiles(@"c:\", longString);
+            using (var env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_0.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
 
-            Assert.Equal(longString, result[0]); // Does not throw
+                string longString = new string('X', 500) + "*"; // need a wildcard to do anything
+                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString);
 
+                Assert.Equal(longString, result[0]); // Does not throw
+                ChangeWaves.ResetStateForTests();
+            }
             // Not checking that GetFileSpecMatchInfo returns the illegal-path flag,
             // not certain that won't break something; this fix is merely to avoid a crash.
         }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 9261b45785c..e647fd709c0 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -2019,6 +2019,65 @@ public void Dispose()
             }
         }
 
+        internal sealed class LoggingDirectoryCacheFactory : IDirectoryCacheFactory
+        {
+            public List<LoggingDirectoryCache> DirectoryCaches { get; } = new();
+
+            public IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId)
+            {
+                var directoryCache = new LoggingDirectoryCache(evaluationId);
+                DirectoryCaches.Add(directoryCache);
+                return directoryCache;
+            }
+        }
+
+        internal sealed class LoggingDirectoryCache : IDirectoryCache
+        {
+            internal int EvaluationId { get; }
+
+            public ConcurrentDictionary<string, int> ExistenceChecks { get; } = new();
+            public ConcurrentDictionary<string, int> Enumerations { get; } = new();
+
+            public LoggingDirectoryCache(int evaluationId)
+            {
+                EvaluationId = evaluationId;
+            }
+
+            public bool DirectoryExists(string path)
+            {
+                IncrementExistenceChecks(path);
+                return Directory.Exists(path);
+            }
+
+            public bool FileExists(string path)
+            {
+                IncrementExistenceChecks(path);
+                return File.Exists(path);
+            }
+
+            public IEnumerable<TResult> EnumerateDirectories<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform)
+            {
+                IncrementEnumerations(path);
+                return Enumerable.Empty<TResult>();
+            }
+
+            public IEnumerable<TResult> EnumerateFiles<TResult>(string path, string pattern, FindPredicate predicate, FindTransform<TResult> transform)
+            {
+                IncrementEnumerations(path);
+                return Enumerable.Empty<TResult>();
+            }
+
+            private void IncrementExistenceChecks(string path)
+            {
+                ExistenceChecks.AddOrUpdate(path, p => 1, (p, c) => c + 1);
+            }
+
+            private void IncrementEnumerations(string path)
+            {
+                Enumerations.AddOrUpdate(path, p => 1, (p, c) => c + 1);
+            }
+        }
+
         internal class LoggingFileSystem : MSBuildFileSystemBase
         {
             private int _fileSystemCalls;
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index f3c58b19237..70cf960d823 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -2,6 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Shared;
+
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -47,35 +49,82 @@ public void TestIsNonBatchingTargetAttribute()
         public void TestRuntimeValuesMatch()
         {
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime));
+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.net));
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4));
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any));
+#if NET5_0_OR_GREATER
+            Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.net));
+#else
             Assert.True(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr4));
+#endif
 
+            // Never true
             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2));
+
             Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2));
+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.net));
+            Assert.False(XMakeAttributes.RuntimeValuesMatch(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.net));
         }
 
-        [Fact]
-        public void TestMergeRuntimeValues()
+        [Theory]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4, true, XMakeAttributes.MSBuildRuntimeValues.clr4)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.any, true, XMakeAttributes.MSBuildRuntimeValues.clr4)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any, true, XMakeAttributes.MSBuildRuntimeValues.clr2)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2, false, null)]
+        [InlineData(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2, false, null)]
+        public void TestMergeRuntimeValues(string left, string right, bool success, string expected)
         {
-            string mergedRuntime;
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.currentRuntime, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            XMakeAttributes.TryMergeRuntimeValues(left, right, out string mergedRuntime)
+                .ShouldBe(success);
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any, XMakeAttributes.MSBuildRuntimeValues.clr4, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            mergedRuntime.ShouldBe(expected);
+        }
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.clr2, XMakeAttributes.MSBuildRuntimeValues.any, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr2, mergedRuntime);
+        [Fact]
+        public void TestMergeRuntimeValuesAnyAcceptsCurrent()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.any,
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                out string mergedRuntime)
+                .ShouldBeTrue();
 
-            Assert.True(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr4, out mergedRuntime));
-            Assert.Equal(XMakeAttributes.MSBuildRuntimeValues.clr4, mergedRuntime);
+            mergedRuntime.ShouldBe(XMakeAttributes.GetCurrentMSBuildRuntime());
+        }
 
-            Assert.False(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.currentRuntime, XMakeAttributes.MSBuildRuntimeValues.clr2, out mergedRuntime));
-            Assert.Null(mergedRuntime);
+        [Fact]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp,
+            "Tests whether 'current' merges with 'clr4' which is true only on Framework")]
+        public void TestMergeRuntimeValuesCurrentToClr4()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.clr4,
+                out string mergedRuntime).ShouldBeTrue();
+            mergedRuntime.ShouldBe(XMakeAttributes.MSBuildRuntimeValues.clr4);
+
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.net,
+                out mergedRuntime).ShouldBeFalse();
+            mergedRuntime.ShouldBeNull();
+        }
 
-            Assert.False(XMakeAttributes.TryMergeRuntimeValues(XMakeAttributes.MSBuildRuntimeValues.clr4, XMakeAttributes.MSBuildRuntimeValues.clr2, out mergedRuntime));
-            Assert.Null(mergedRuntime);
+        [Fact]
+        [SkipOnTargetFramework(TargetFrameworkMonikers.NetFramework,
+            "Tests whether 'current' merges with 'net' which is true only on core")]
+        public void TestMergeRuntimeValuesCurrentToCore()
+        {
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.net,
+                out string mergedRuntime).ShouldBeTrue();
+            mergedRuntime.ShouldBe(XMakeAttributes.MSBuildRuntimeValues.net);
+
+            XMakeAttributes.TryMergeRuntimeValues(
+                XMakeAttributes.MSBuildRuntimeValues.currentRuntime,
+                XMakeAttributes.MSBuildRuntimeValues.clr4,
+                out mergedRuntime).ShouldBeFalse();
+            mergedRuntime.ShouldBeNull();
         }
 
         [Fact]
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index 461bc2ef740..d290eee6246 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Runtime.CompilerServices;
 
 namespace Microsoft.Build.Shared
 {
@@ -76,6 +77,7 @@ internal struct MSBuildRuntimeValues
             internal const string clr2 = "CLR2";
             internal const string clr4 = "CLR4";
             internal const string currentRuntime = "CurrentRuntime";
+            internal const string net = "NET";
             internal const string any = "*";
         }
 
@@ -99,7 +101,7 @@ internal struct MSBuildArchitectureValues
 
         private static readonly HashSet<string> KnownBatchingTargetAttributes = new HashSet<string> { name, condition, dependsOnTargets, beforeTargets, afterTargets };
 
-        private static readonly HashSet<string> ValidMSBuildRuntimeValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildRuntimeValues.clr2, MSBuildRuntimeValues.clr4, MSBuildRuntimeValues.currentRuntime, MSBuildRuntimeValues.any };
+        private static readonly HashSet<string> ValidMSBuildRuntimeValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildRuntimeValues.clr2, MSBuildRuntimeValues.clr4, MSBuildRuntimeValues.currentRuntime, MSBuildRuntimeValues.net, MSBuildRuntimeValues.any };
 
         private static readonly HashSet<string> ValidMSBuildArchitectureValues = new HashSet<string>(StringComparer.OrdinalIgnoreCase) { MSBuildArchitectureValues.x86, MSBuildArchitectureValues.x64, MSBuildArchitectureValues.currentArchitecture, MSBuildArchitectureValues.any };
 
@@ -179,10 +181,10 @@ internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB)
                 return true;
             }
 
-            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase)) ||
-                (runtimeA.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))
+            if ((runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase)) ||
+                (runtimeA.Equals(GetCurrentMSBuildRuntime(), StringComparison.OrdinalIgnoreCase) && runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase)))
             {
-                // CLR4 is the current runtime, so this is also a match. 
+                // Matches the current runtime, so match.
                 return true;
             }
 
@@ -216,13 +218,15 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 runtimeB = MSBuildRuntimeValues.any;
             }
 
+            string actualCurrentRuntime = GetCurrentMSBuildRuntime();
+
             // if they're equal, then there's no problem -- just return the equivalent runtime.  
             if (runtimeA.Equals(runtimeB, StringComparison.OrdinalIgnoreCase))
             {
                 if (runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                     runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase))
                 {
-                    mergedRuntime = MSBuildRuntimeValues.clr4;
+                    mergedRuntime = actualCurrentRuntime;
                 }
                 else
                 {
@@ -232,21 +236,22 @@ internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, out
                 return true;
             }
 
-            // if both A and B are one of CLR4, don't care, or current, then the end result will be CLR4 no matter what.  
+            // if both A and B are one of actual-current-runtime, don't care or current,
+            // then the end result will be current-runtime no matter what.  
             if (
                 (
-                 runtimeA.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ||
+                 runtimeA.Equals(actualCurrentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeA.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeA.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase)
                 ) &&
                 (
-                 runtimeB.Equals(MSBuildRuntimeValues.clr4, StringComparison.OrdinalIgnoreCase) ||
+                 runtimeB.Equals(actualCurrentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeB.Equals(MSBuildRuntimeValues.currentRuntime, StringComparison.OrdinalIgnoreCase) ||
                  runtimeB.Equals(MSBuildRuntimeValues.any, StringComparison.OrdinalIgnoreCase)
                 )
                )
             {
-                mergedRuntime = MSBuildRuntimeValues.clr4;
+                mergedRuntime = actualCurrentRuntime;
                 return true;
             }
 
@@ -320,8 +325,8 @@ internal static string GetExplicitMSBuildRuntime(string runtime)
                 MSBuildRuntimeValues.any.Equals(runtime, StringComparison.OrdinalIgnoreCase) ||
                 MSBuildRuntimeValues.currentRuntime.Equals(runtime, StringComparison.OrdinalIgnoreCase))
             {
-                // Default to CLR4.
-                return MSBuildRuntimeValues.clr4;
+                // Default to current.
+                return GetCurrentMSBuildRuntime();
             }
             else
             {
@@ -425,6 +430,18 @@ internal static string GetCurrentMSBuildArchitecture()
             return currentArchitecture;
         }
 
+        /// <summary>
+        /// Returns the MSBuildRuntime value corresponding to the current process' runtime. 
+        /// </summary>
+        internal static string GetCurrentMSBuildRuntime()
+        {
+#if NET40_OR_GREATER
+            return MSBuildRuntimeValues.clr4;
+#else
+            return MSBuildRuntimeValues.net;
+#endif
+        }
+
         /// <summary>
         /// Given an MSBuildArchitecture value that may be non-explicit -- e.g. "CurrentArchitecture" or "Any" --
         /// return the specific MSBuildArchitecture value that it would map to in this case.  If it does not map 
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index fef9909ce6f..93a4634ce01 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -20,17 +20,12 @@
 
   <PropertyGroup Condition="'$(TargetFramework)' == 'net35'">
     <AssemblyName>Microsoft.NET.StringTools.net35</AssemblyName>
-    <!-- Disable Fx install checks as we're building against jnm2's 3.5 reference assemblies -->
-    <BypassFrameworkInstallChecks>true</BypassFrameworkInstallChecks>
   </PropertyGroup>
 
   <ItemGroup Condition="'$(TargetFramework)' != 'net35'">
     <PackageReference Include="System.Memory" />
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
   </ItemGroup>
-  <ItemGroup>
-    <PackageReference Include="jnm2.ReferenceAssemblies.net35" PrivateAssets="All" />
-  </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFramework)' == 'net35'">
     <Compile Remove="SpanBasedStringBuilder.cs" />
diff --git a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
index 88f8cf4959f..a88113e0319 100644
--- a/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
+++ b/src/Tasks.UnitTests/GetReferencePaths_Tests.cs
@@ -23,9 +23,9 @@ sealed public class GetReferenceAssmeblyPath_Tests
         [Fact]
         public void TestGeneralFrameworkMonikerGood()
         {
-            string targetFrameworkMoniker = ".NetFramework, Version=v4.5";
-            MockEngine engine = new MockEngine();
-            GetReferenceAssemblyPaths getReferencePaths = new GetReferenceAssemblyPaths();
+            string targetFrameworkMoniker = ".NetFramework, Version=v4.8";
+            MockEngine engine = new();
+            GetReferenceAssemblyPaths getReferencePaths = new();
             getReferencePaths.BuildEngine = engine;
             getReferencePaths.TargetFrameworkMoniker = targetFrameworkMoniker;
             getReferencePaths.Execute();
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index 05200fcfac9..04ef5ffcd1d 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -7,6 +7,7 @@
 
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
 
@@ -350,12 +351,13 @@ public void PropertyOverridesContainSemicolon()
 
             // Just a normal console application project.
             ObjectModelHelpers.CreateFileInTempProjectDirectory(
-                Path.Combine("bug'533'369", "Sub;Dir", "ConsoleApplication1", "ConsoleApplication1.csproj"), @"
+                Path.Combine("bug'533'369", "Sub;Dir", "ConsoleApplication1", "ConsoleApplication1.csproj"), $@"
 
-                <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                   <Import Project=`$(MSBuildBinPath)\Microsoft.Common.props` />
                   <PropertyGroup>
                     <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
+                    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                     <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                     <OutputType>Exe</OutputType>
                     <AssemblyName>ConsoleApplication1</AssemblyName>
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index 98ae00b9da8..74020be52f0 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-
     <IsPackable>false</IsPackable>
 
     <AssemblyName>Microsoft.Build.Tasks.UnitTests</AssemblyName>
diff --git a/src/Tasks.UnitTests/RegressionTests.cs b/src/Tasks.UnitTests/RegressionTests.cs
index f400cef6a24..f9aabd40908 100644
--- a/src/Tasks.UnitTests/RegressionTests.cs
+++ b/src/Tasks.UnitTests/RegressionTests.cs
@@ -52,13 +52,16 @@ public void OverrideBaseIntermediateOutputPathSucceeds()
         [ConditionalFact(typeof(NativeMethodsShared), nameof(NativeMethodsShared.IsWindows))]
         public void AssemblyAttributesLocation()
         {
-            var expectedCompileItems = "a.cs;" + Path.Combine("obj", "Debug", ".NETFramework,Version=v4.0.AssemblyAttributes.cs");
+            var expectedCompileItems = "a.cs;" + Path.Combine("obj", "Debug", ".NETFramework,Version=v4.8.AssemblyAttributes.cs");
 
             var project = ObjectModelHelpers.CreateInMemoryProject($@"
 <Project>
   <Import Project=""$(MSBuildToolsPath)\Microsoft.Common.props"" />
+  <PropertyGroup>
+    <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
+  </PropertyGroup>
   <ItemGroup>
-    <Compile Include=""a.cs""/>       
+    <Compile Include=""a.cs""/>
   </ItemGroup>
   <Import Project=""$(MSBuildToolsPath)\Microsoft.CSharp.targets"" />
 
diff --git a/src/Tasks.UnitTests/RemoveDir_Tests.cs b/src/Tasks.UnitTests/RemoveDir_Tests.cs
index 7f88ef17839..0dee182082b 100644
--- a/src/Tasks.UnitTests/RemoveDir_Tests.cs
+++ b/src/Tasks.UnitTests/RemoveDir_Tests.cs
@@ -1,15 +1,25 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
+using System.IO;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks;
 using Microsoft.Build.Utilities;
+using Shouldly;
 using Xunit;
+using Xunit.Abstractions;
 
 namespace Microsoft.Build.UnitTests
 {
     sealed public class RemoveDir_Tests
     {
+        ITestOutputHelper _output;
+        public RemoveDir_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+        }
+
         /*
          * Method:   AttributeForwarding
          *
@@ -23,14 +33,42 @@ public void AttributeForwarding()
             ITaskItem i = new TaskItem("MyNonExistentDirectory");
             i.SetMetadata("Locale", "en-GB");
             t.Directories = new ITaskItem[] { i };
-            t.BuildEngine = new MockEngine();
+            t.BuildEngine = new MockEngine(_output);
 
             t.Execute();
 
-            Assert.Equal("en-GB", t.RemovedDirectories[0].GetMetadata("Locale"));
+            t.RemovedDirectories[0].GetMetadata("Locale").ShouldBe("en-GB");
+            t.RemovedDirectories[0].ItemSpec.ShouldBe("MyNonExistentDirectory");
+            Directory.Exists(t.RemovedDirectories[0].ItemSpec).ShouldBeFalse();
+        }
+
+        [Fact]
+        public void SimpleDelete()
+        {
+
+            using (TestEnvironment env = TestEnvironment.Create(_output))
+            {
+                List<TaskItem> list = new List<TaskItem>();
+
+                for (int i = 0; i < 20; i++)
+                {
+                    list.Add(new TaskItem(env.CreateFolder().Path));
+                }
+
+                RemoveDir t = new RemoveDir();
+
+                t.Directories = list.ToArray();
+                t.BuildEngine = new MockEngine(_output);
+
+                t.Execute().ShouldBeTrue();
+
+                t.RemovedDirectories.Length.ShouldBe(list.Count);
 
-            // Output ItemSpec should not be overwritten.
-            Assert.Equal("MyNonExistentDirectory", t.RemovedDirectories[0].ItemSpec);
+                for (int i = 0; i < 20; i++)
+                {
+                    Directory.Exists(list[i].ItemSpec).ShouldBeFalse();
+                }
+            }
         }
     }
 }
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 6d055df7140..8ffdf31868d 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -2369,14 +2369,15 @@ public void DontLockP2PReferenceWhenResolvingSystemTypes()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", @"
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", $@"
 
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                             <AssemblyName>lib1</AssemblyName>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
                         </PropertyGroup>
@@ -2546,13 +2547,13 @@ public void ReferencedAssemblySpecifiedUsingRelativePath()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <AssemblyName>ClassLibrary20</AssemblyName>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 99e3d7066b0..3e20f81bc0f 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -2730,14 +2730,14 @@ public void DontLockP2PReferenceWhenResolvingSystemTypes()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("lib1.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
                             <AssemblyName>lib1</AssemblyName>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
                         </PropertyGroup>
@@ -2908,13 +2908,13 @@ public void ReferencedAssemblySpecifiedUsingRelativePath()
             // -------------------------------------------------------------------------------
             ObjectModelHelpers.DeleteTempProjectDirectory();
 
-            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", @"
-
-                    <Project DefaultTargets=`Build` ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+            ObjectModelHelpers.CreateFileInTempProjectDirectory("ClassLibrary20.csproj", $@"
+                    <Project DefaultTargets=`Build` xmlns=`msbuildnamespace`>
                         <PropertyGroup>
                             <ProjectType>Local</ProjectType>
                             <Configuration Condition=` '$(Configuration)' == '' `>Debug</Configuration>
                             <Platform Condition=` '$(Platform)' == '' `>AnyCPU</Platform>
+                            <TargetFrameworkVersion>{MSBuildConstants.StandardTestTargetFrameworkVersion}</TargetFrameworkVersion>
                             <AssemblyName>ClassLibrary20</AssemblyName>
                             <OutputType>Library</OutputType>
                             <RootNamespace>lib1</RootNamespace>
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index 5fc54d6dfcf..785bab86be5 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -13,6 +13,7 @@
 using System.Text.RegularExpressions;
 using System.Xml.Xsl;
 using System.Xml;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests
@@ -386,7 +387,7 @@ public void OutputTest()
         /// Setting correct "Parameter" parameters for Xsl.
         /// </summary>
         [Fact]
-        public void XsltParamatersCorrect()
+        public void XsltParametersCorrect()
         {
             string dir;
             TaskItem[] xmlPaths;
@@ -780,6 +781,39 @@ public void OutputFileCannotBeWritten()
             CleanUp(dir);
         }
 
+        /// <summary>
+        /// The files are not kept locked by the task
+        /// </summary>
+        [Fact]
+        public void InputFilesDontLock()
+        {
+            string dir;
+            TaskItem[] xmlPaths;
+            TaskItem xslPath;
+            TaskItem[] outputPaths;
+            MockEngine engine;
+            Prepare(out dir, out xmlPaths, out xslPath, out _, out outputPaths, out _, out _, out engine);
+
+            // Test with files
+            {
+                XslTransformation t = new XslTransformation();
+                t.BuildEngine = engine;
+                t.XmlInputPaths = xmlPaths;
+                t.XslInputPath = xslPath;
+                t.OutputPaths = outputPaths;
+
+                t.Execute().ShouldBeTrue();
+                string xmlInputPath = xmlPaths[0].ItemSpec;
+                File.Delete(xmlInputPath); // this should succeed (file not locked by task)
+                File.Exists(xmlInputPath).ShouldBeFalse();
+                string xslInputPath = xslPath.ItemSpec;
+                File.Delete(xslInputPath); // this should succeed (file not locked by task)
+                File.Exists(xslInputPath).ShouldBeFalse();
+            }
+
+            CleanUp(dir);
+        }
+
         /// <summary>
         /// XslDocument that throws runtime exception.
         /// </summary>
diff --git a/src/Tasks/AppConfig/BindingRedirect.cs b/src/Tasks/AppConfig/BindingRedirect.cs
index 5e5404af394..8a226ede9c5 100644
--- a/src/Tasks/AppConfig/BindingRedirect.cs
+++ b/src/Tasks/AppConfig/BindingRedirect.cs
@@ -61,7 +61,7 @@ internal void Read(XmlReader reader)
                     throw;
                 }
 
-                ErrorUtilities.VerifyThrowArgument(false, e, "AppConfig.InvalidOldVersionAttribute", e.Message);
+                ErrorUtilities.ThrowArgument(e, "AppConfig.InvalidOldVersionAttribute", e.Message);
             }
 
             string newVersionAttribute = reader.GetAttribute("newVersion");
@@ -80,7 +80,7 @@ internal void Read(XmlReader reader)
                     throw;
                 }
 
-                ErrorUtilities.VerifyThrowArgument(false, e, "AppConfig.InvalidNewVersionAttribute", e.Message);
+                ErrorUtilities.ThrowArgument(e, "AppConfig.InvalidNewVersionAttribute", e.Message);
             }
         }
     }
diff --git a/src/Tasks/AppConfig/DependentAssembly.cs b/src/Tasks/AppConfig/DependentAssembly.cs
index 2337cafd376..2bbbc37e39a 100644
--- a/src/Tasks/AppConfig/DependentAssembly.cs
+++ b/src/Tasks/AppConfig/DependentAssembly.cs
@@ -96,7 +96,7 @@ internal void Read(XmlReader reader)
                     catch (System.IO.FileLoadException e)
                     {
                         // A badly formed assembly name.
-                        ErrorUtilities.VerifyThrowArgument(false, e, "AppConfig.InvalidAssemblyIdentityFields");
+                        ErrorUtilities.ThrowArgument(e, "AppConfig.InvalidAssemblyIdentityFields");
                     }
                 }
 
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 196a70b8747..3b214c55a9f 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -741,13 +741,8 @@ out string redistName
         /// </summary>
         private static void TryConvertToAssemblyName(string itemSpec, string fusionName, ref AssemblyNameExtension assemblyName)
         {
-            // FusionName is used if available.
-            string finalName = fusionName;
-            if (string.IsNullOrEmpty(finalName))
-            {
-                // Otherwise, its itemSpec.
-                finalName = itemSpec;
-            }
+            // FusionName is used if available; otherwise use itemspec.
+            string finalName = string.IsNullOrEmpty(fusionName) ? itemSpec : fusionName;
 
             bool pathRooted = false;
             try
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 2cea34c71bb..53b19c17a62 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -3153,23 +3153,26 @@ public override bool Execute()
         {
             return Execute
             (
-                new FileExists(p => FileUtilities.FileExistsNoThrow(p)),
-                new DirectoryExists(p => FileUtilities.DirectoryExistsNoThrow(p)),
-                new GetDirectories(Directory.GetDirectories),
-                new GetAssemblyName(AssemblyNameExtension.GetAssemblyNameEx),
-                new GetAssemblyMetadata(AssemblyInformation.GetAssemblyMetadata),
+                p => FileUtilities.FileExistsNoThrow(p),
+                p => FileUtilities.DirectoryExistsNoThrow(p),
+                (p, searchPattern) => Directory.GetDirectories(p, searchPattern),
+                p => AssemblyNameExtension.GetAssemblyNameEx(p),
+                (string path, ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache, out AssemblyNameExtension[] dependencies, out string[] scatterFiles, out FrameworkNameVersioning frameworkName)
+                    => AssemblyInformation.GetAssemblyMetadata(path, assemblyMetadataCache, out dependencies, out scatterFiles, out frameworkName),
 #if FEATURE_WIN32_REGISTRY
-                new GetRegistrySubKeyNames(RegistryHelper.GetSubKeyNames),
-                new GetRegistrySubKeyDefaultValue(RegistryHelper.GetDefaultValue),
+                (baseKey, subkey) => RegistryHelper.GetSubKeyNames(baseKey, subkey),
+                (baseKey, subkey) => RegistryHelper.GetDefaultValue(baseKey, subkey),
 #endif
-                new GetLastWriteTime(NativeMethodsShared.GetLastWriteFileUtcTime),
-                new GetAssemblyRuntimeVersion(AssemblyInformation.GetRuntimeVersion),
+                p => NativeMethodsShared.GetLastWriteFileUtcTime(p),
+                p => AssemblyInformation.GetRuntimeVersion(p),
 #if FEATURE_WIN32_REGISTRY
-                new OpenBaseKey(RegistryHelper.OpenBaseKey),
+                (hive, view) => RegistryHelper.OpenBaseKey(hive, view),
 #endif
-                new GetAssemblyPathInGac(GetAssemblyPathInGac),
-                new IsWinMDFile(AssemblyInformation.IsWinMDFile),
-                new ReadMachineTypeFromPEHeader(ReferenceTable.ReadMachineTypeFromPEHeader)
+                (assemblyName, targetProcessorArchitecture, getRuntimeVersion, targetedRuntimeVersion, fileExists, fullFusionName, specificVersion)
+                    => GetAssemblyPathInGac(assemblyName, targetProcessorArchitecture, getRuntimeVersion, targetedRuntimeVersion, fileExists, fullFusionName, specificVersion),
+                (string fullPath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, out string imageRuntimeVersion, out bool isManagedWinmd)
+                    => AssemblyInformation.IsWinMDFile(fullPath, getAssemblyRuntimeVersion, fileExists, out imageRuntimeVersion, out isManagedWinmd),
+                p => ReferenceTable.ReadMachineTypeFromPEHeader(p)
             );
         }
 
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index be72b128729..350f9d70f69 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -52,13 +52,13 @@ internal abstract class Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
+        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
         {
             this.searchPathElement = searchPathElement;
             this.getAssemblyName = getAssemblyName;
             this.fileExists = fileExists;
             this.getRuntimeVersion = getRuntimeVersion;
-            this.targetedRuntimeVersion = targetedRuntimeVesion;
+            this.targetedRuntimeVersion = targetedRuntimeVersion;
             this.targetProcessorArchitecture = targetedProcessorArchitecture;
             this.compareProcessorArchitecture = compareProcessorArchitecture;
         }
diff --git a/src/Tasks/AssemblyFolder.cs b/src/Tasks/AssemblyFolder.cs
index d6d3e0ae209..dfc0c4632c7 100644
--- a/src/Tasks/AssemblyFolder.cs
+++ b/src/Tasks/AssemblyFolder.cs
@@ -54,7 +54,7 @@ Dictionary<string, string> directories
                 }
                 else
                 {
-                    ErrorUtilities.VerifyThrow(false, "AssemblyFolder.AddFoldersFromRegistryKey expected a known hive.");
+                    ErrorUtilities.ThrowInternalError("AssemblyFolder.AddFoldersFromRegistryKey expected a known hive.");
                 }
 
                 if (baseKey != null)
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index c3ecc2aac73..3e7da8c94cd 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -2091,7 +2091,10 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     }
 
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
-                    if (publicKey?.Equals(publicKeyAttribute.Value, StringComparison.OrdinalIgnoreCase) == false)
+                    // Skip this check if the public key attribute is "0", as this means we're expecting the public key
+                    // comparison to be skipped at install time because the file is signed by an MS trusted cert.
+                    if (publicKeyAttribute.Value.Equals("0", StringComparison.OrdinalIgnoreCase) == false &&
+                        publicKey?.Equals(publicKeyAttribute.Value, StringComparison.OrdinalIgnoreCase) == false)
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", PUBLICKEY_ATTRIBUTE, builder.Name, fileSource));
                     }
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 6c91abeaab3..1575b55d11b 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -588,8 +588,7 @@ private bool CopyParallel(
                 if (!partitionAccepted)
                 {
                     // Retail assert...
-                    ErrorUtilities.VerifyThrow(false,
-                        "Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity.");
+                    ErrorUtilities.ThrowInternalError("Failed posting a file copy to an ActionBlock. Should not happen with block at max int capacity.");
                 }
             }
 
diff --git a/src/Tasks/CreateCSharpManifestResourceName.cs b/src/Tasks/CreateCSharpManifestResourceName.cs
index 9837e9b1f2a..bb939b9174a 100644
--- a/src/Tasks/CreateCSharpManifestResourceName.cs
+++ b/src/Tasks/CreateCSharpManifestResourceName.cs
@@ -3,11 +3,10 @@
 
 using System;
 using System.IO;
-using System.Text;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -114,7 +113,7 @@ internal static string CreateManifestNameImpl
                 info.culture = culture;
             }
 
-            var manifestName = new StringBuilder();
+            var manifestName = StringBuilderCache.Acquire();
             if (binaryStream != null)
             {
                 // Resource depends on a form. Now, get the form's class name fully 
@@ -212,7 +211,7 @@ internal static string CreateManifestNameImpl
                 }
             }
 
-            return manifestName.ToString();
+            return StringBuilderCache.GetStringAndRelease(manifestName);
         }
 
         /// <summary>
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 864450634a1..fe02c57753f 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -3,8 +3,8 @@
 
 using System;
 using System.IO;
-using System.Text;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
@@ -111,7 +111,7 @@ internal static string CreateManifestNameImpl
                 info.culture = culture;
             }
 
-            var manifestName = new StringBuilder();
+            var manifestName = StringBuilderCache.Acquire();
             if (binaryStream != null)
             {
                 // Resource depends on a form. Now, get the form's class name fully 
@@ -192,7 +192,7 @@ internal static string CreateManifestNameImpl
                 }
             }
 
-            return manifestName.ToString();
+            return StringBuilderCache.GetStringAndRelease(manifestName);
         }
 
         /// <summary>
diff --git a/src/Tasks/FileState.cs b/src/Tasks/FileState.cs
index 6545558ff30..af2e2f29897 100644
--- a/src/Tasks/FileState.cs
+++ b/src/Tasks/FileState.cs
@@ -93,7 +93,7 @@ public FileDirInfo(string filename)
                     // there is no disk in drive A:, please insert one.  We don't want that. 
                     // SetErrorMode will let us disable this, but we should set the error
                     // mode back, since this may have wide-ranging effects.
-                    oldMode = NativeMethodsShared.SetErrorMode(1 /* ErrorModes.SEM_FAILCRITICALERRORS */);
+                    NativeMethodsShared.SetThreadErrorMode(1 /* ErrorModes.SEM_FAILCRITICALERRORS */, out oldMode);
                 }
 
                 try
@@ -174,7 +174,7 @@ public FileDirInfo(string filename)
                     // Reset the error mode on Windows
                     if (NativeMethodsShared.IsWindows)
                     {
-                        NativeMethodsShared.SetErrorMode(oldMode);
+                        NativeMethodsShared.SetThreadErrorMode(oldMode, out _);
                     }
                 }
             }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 26967ca64e7..54d5b149d96 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -4146,7 +4146,7 @@ public Type GetType(string name, bool throwOnError, bool ignoreCase)
 
                 if (result == null && throwOnError)
                 {
-                    ErrorUtilities.VerifyThrowArgument(false, "GenerateResource.CouldNotLoadType", name);
+                    ErrorUtilities.ThrowArgument("GenerateResource.CouldNotLoadType", name);
                 }
 
                 _cachedTypes[name] = result;
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index d8f81bf9926..485e5d33714 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -989,6 +989,8 @@
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
   </ItemGroup>
   <ItemGroup>
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
+
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Resources.Extensions" />
   </ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index ab2342d58e4..2847dcd30d7 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1930,13 +1930,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ============================================================
                                     GetTargetFrameworkProperties
 
-    Overrridden by cross-targeting projects to return the set of
-    properties (in the form "key1=value1;...keyN=valueN") needed
-    to build it with the best target for the referring project's
-    target framework.
-
-    The referring project's $(TargetFrameworkMoniker) is passed
-    in as $(ReferringTargetFramework)
+    OBSOLETE: present only for theoretical backward compatibility.
   -->
   <Target Name="GetTargetFrameworkProperties" />
 
@@ -4832,10 +4826,12 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          not be considered up to date, so touch this marker file that is considered an
          input to projects that reference this one. -->
     <Touch Files="@(CopyUpToDateMarker)"
-           AlwaysCreate="true"
-           Condition="'@(ReferencesCopiedInThisBuild)' != '' and '$(WroteAtLeastOneFile)' == 'true'">
-        <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
-    </Touch>
+      AlwaysCreate="true"
+      Condition="'@(ReferencesCopiedInThisBuild)' != '' and '$(WroteAtLeastOneFile)' == 'true'" />
+
+    <ItemGroup>
+      <FileWrites Include="@(CopyUpToDateMarker)" />
+    </ItemGroup>
 
   </Target>
 
diff --git a/src/Tasks/Microsoft.Common.tasks b/src/Tasks/Microsoft.Common.tasks
index f6b98da83af..f909cc1afe2 100644
--- a/src/Tasks/Microsoft.Common.tasks
+++ b/src/Tasks/Microsoft.Common.tasks
@@ -122,8 +122,9 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateLauncher"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="NET" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' == 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.GenerateResource"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''  and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.GenerateTrustInfo"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.GetAssemblyIdentity"                   AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
@@ -141,8 +142,8 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.ReadLinesFromFile"                     AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.RegisterAssembly"                      AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir"                             AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.RemoveDuplicates"                      AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
@@ -164,8 +165,8 @@
     <UsingTask TaskName="Microsoft.Build.Tasks.Touch"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' != ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
-    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == ''" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR4" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
+    <UsingTask TaskName="Microsoft.Build.Tasks.UnregisterAssembly"                    AssemblyName="Microsoft.Build.Tasks.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Runtime="CLR2" Condition="('$(MSBuildAssemblyVersion)' != '') and '$(DisableOutOfProcTaskHost)' == '' and '$(MSBuildRuntimeType)' != 'Core'" />
 
     <UsingTask TaskName="Microsoft.Build.Tasks.UpdateManifest"                        AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
     <UsingTask TaskName="Microsoft.Build.Tasks.Unzip"                                 AssemblyName="Microsoft.Build.Tasks.Core, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" Condition="'$(MSBuildAssemblyVersion)' != ''" />
diff --git a/src/Tasks/RemoveDir.cs b/src/Tasks/RemoveDir.cs
index f802cbfc70d..c19be8486f6 100644
--- a/src/Tasks/RemoveDir.cs
+++ b/src/Tasks/RemoveDir.cs
@@ -44,8 +44,6 @@ public ITaskItem[] Directories
         //-----------------------------------------------------------------------------------
         public override bool Execute()
         {
-            // Delete each directory
-            bool overallSuccess = true;
             // Our record of the directories that were removed
             var removedDirectoriesList = new List<ITaskItem>();
 
@@ -73,12 +71,6 @@ public override bool Execute()
                         }
                     }
 
-                    // The current directory was not removed successfully
-                    if (!currentSuccess)
-                    {
-                        overallSuccess = false;
-                    }
-
                     // We successfully removed the directory, so add the removed directory to our record
                     if (currentSuccess)
                     {
@@ -97,7 +89,7 @@ public override bool Execute()
             }
             // convert the list of deleted files into an array of ITaskItems
             RemovedDirectories = removedDirectoriesList.ToArray();
-            return overallSuccess;
+            return !Log.HasLoggedErrors;
         }
 
         // Core implementation of directory removal
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index a8cf11d7a56..e64e155ca4b 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -1040,7 +1040,7 @@ internal bool ResolveComClassicReference(ComReferenceInfo referenceInfo, string
             }
             else
             {
-                ErrorUtilities.VerifyThrow(false, "Unknown wrapper type!");
+                ErrorUtilities.ThrowInternalError("Unknown wrapper type!");
             }
             referenceInfo.resolvedWrapper = wrapperInfo;
 
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 2992e07bc73..2c11513b244 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -366,19 +366,14 @@ private FileState ComputeFileStateFromCachesAndDisk(string path)
             // If the process-wide cache contains an up-to-date FileState, always use it
             if (isProcessFileStateUpToDate)
             {
-                // If a FileState already exists in this instance cache due to deserialization, remove it;
-                // another instance has taken responsibility for serialization, and keeping this would
-                // result in multiple instances serializing the same data to disk
-                if (isCachedInInstance)
+                // For the next build, we may be using a different process. Update the file cache.
+                if (!isInstanceFileStateUpToDate)
                 {
-                    instanceLocalFileStateCache.Remove(path);
+                    instanceLocalFileStateCache[path] = cachedProcessFileState;
                     isDirty = true;
                 }
-
                 return cachedProcessFileState;
             }
-            // If the process-wide FileState is missing or out-of-date, this instance owns serialization;
-            // sync the process-wide cache and signal other instances to avoid data duplication
             if (isInstanceFileStateUpToDate)
             {
                 return s_processWideFileStateCache[path] = cachedInstanceFileState;
diff --git a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
index 41d74bb1934..96fc22b7388 100644
--- a/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
+++ b/src/Tasks/XamlTaskFactory/CommandLineGenerator.cs
@@ -256,7 +256,7 @@ internal void GenerateCommandsAccordingToType(CommandLineBuilder clb, CommandLin
                     break;
                 default:
                     // should never reach this point - if it does, there's a bug somewhere.
-                    ErrorUtilities.VerifyThrow(false, "InternalError");
+                    ErrorUtilities.ThrowInternalError("InternalError");
                     break;
             }
         }
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 3b8810be561..0f47a2edfe2 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -334,9 +334,9 @@ public XmlReader CreateReader(int itemPos)
             {
                 if (XmlMode == XmlModes.XmlFile)
                 {
-                    return XmlReader.Create(new StreamReader(_data[itemPos]), null, _data[itemPos]);
+                    return XmlReader.Create(new StreamReader(_data[itemPos]), new XmlReaderSettings { CloseInput = true }, _data[itemPos]);
                 }
-                else // xmlModes.Xml 
+                else // xmlModes.Xml
                 {
                     return XmlReader.Create(new StringReader(_data[itemPos]));
                 }
@@ -459,7 +459,10 @@ public XslCompiledTransform LoadXslt(bool useTrustedSettings)
                             _log.LogMessageFromResources(MessageImportance.Low, "XslTransform.UseTrustedSettings", _data);
                         }
 
-                        xslct.Load(new XPathDocument(XmlReader.Create(new StreamReader(_data), null, _data)), settings, new XmlUrlResolver());
+                        using (XmlReader reader = XmlReader.Create(new StreamReader(_data), new XmlReaderSettings { CloseInput = true }, _data))
+                        {
+                            xslct.Load(new XPathDocument(reader), settings, new XmlUrlResolver());
+                        }
                         break;
                     case XslModes.XsltCompiledDll:
 #if FEATURE_COMPILED_XSL
diff --git a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
index 2051aed69cf..0eea164b802 100644
--- a/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
+++ b/src/Utilities.UnitTests/Microsoft.Build.Utilities.UnitTests.csproj
@@ -3,7 +3,6 @@
   <PropertyGroup>
     <TargetFrameworks>$(RuntimeOutputTargetFrameworks)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
-    
     <AssemblyName>Microsoft.Build.Utilities.UnitTests</AssemblyName>
     <IsTestProject>true</IsTestProject>
     <RootNamespace>Microsoft.Build.Utilities.UnitTests</RootNamespace>
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index b2099ce44c5..e2588de3155 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -1950,26 +1950,30 @@ public void GetPathToReferenceAssembliesDefaultLocationNullFrameworkName()
             }
            );
         }
+
         /// <summary>
-        /// Verify the method correctly returns the 4.5 reference assembly location information if .net 4.5 and
+        /// Verify the method correctly returns the 4.8 reference assembly location information if .net 4.8 and
         /// its corresponding reference assemblies are installed.
-        /// If they are not installed, the test should be ignored.
+        /// .NET 4.8 should always be installed for our tests. We cannot validly verify on Windows that by adding a check
+        /// that ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48)
+        /// returns something reasonable because later versions of the framework overwrote the current version in
+        /// place, which means it just looks for a folder starting with v4.0 in the right spot for any higher version.
         /// </summary>
         [Fact]
         [Trait("Category", "mono-osx-failing")]
-        public void GetPathToReferenceAssembliesDefaultLocation45()
+        public void GetPathToReferenceAssembliesDefaultLocation48()
         {
-            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45) != null)
+            if (ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48) != null)
             {
-                FrameworkNameVersioning frameworkName = new FrameworkNameVersioning(".NETFramework", new Version("4.5"));
+                FrameworkNameVersioning frameworkName = new(".NETFramework", new Version("4.8"));
                 IList<string> directories = ToolLocationHelper.GetPathToReferenceAssemblies(frameworkName);
                 directories.Count.ShouldBe(1); // "Expected the method to return one path."
 
-                string referenceAssemblyPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version45);
+                string referenceAssemblyPath = ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(TargetDotNetFrameworkVersion.Version48);
                 directories[0].ShouldBe(referenceAssemblyPath, StringCompareShould.IgnoreCase);
             }
             // else
-            // "Ignored because v4.5 did not seem to be installed"
+            // "Ignored because v4.8 did not seem to be installed"
         }
 
         /// <summary>
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index f683c61ca7d..3b5d3eb6085 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -681,19 +681,20 @@ public void FindOnPathSucceeds()
         {
             string[] expectedCmdPath;
             string shellName;
+            string cmdPath;
             if (NativeMethodsShared.IsWindows)
             {
-                expectedCmdPath = new[] { Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "cmd.exe") };
+                expectedCmdPath = new[] { Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "cmd.exe").ToUpperInvariant() };
                 shellName = "cmd.exe";
+                cmdPath = ToolTask.FindOnPath(shellName).ToUpperInvariant();
             }
             else
             {
                 expectedCmdPath = new[] { "/bin/sh", "/usr/bin/sh" };
                 shellName = "sh";
+                cmdPath = ToolTask.FindOnPath(shellName);
             }
 
-            string cmdPath = ToolTask.FindOnPath(shellName);
-
             cmdPath.ShouldBeOneOf(expectedCmdPath);
         }
 
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index 09634e72315..da7f065bffe 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -21,6 +21,7 @@
     <ProjectReference Include="..\Framework\Microsoft.Build.Framework.csproj" />
     <ProjectReference Include="..\StringTools\StringTools.csproj" />
 
+    <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Configuration.ConfigurationManager" />
   </ItemGroup>
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index e34d6eef2af..6237b17f4c7 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -2199,7 +2199,7 @@ public static IList<string> GetPathToReferenceAssemblies(string targetFrameworkR
                 }
             }
 
-            return new List<string>();
+            return pathsList ?? new List<string>();
         }
 
         /// <summary>
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index e7766038d11..0818aec23b2 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -902,7 +902,7 @@ private void HandleToolNotifications(Process proc)
                             break;
 
                         default:
-                            ErrorUtilities.VerifyThrow(false, "Unknown tool notification.");
+                            ErrorUtilities.ThrowInternalError("Unknown tool notification.");
                             break;
                     }
                 }
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index ec2d396bfc5..423083dbd1b 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -1,6 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 
 using System.Collections.Generic;
@@ -13,8 +15,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
-#if FEATURE_FILE_TRACKER
-
 namespace Microsoft.Build.Utilities
 {
     /// <summary>
@@ -58,7 +58,7 @@ public enum ExecutableType
     /// </summary>
     public static class FileTracker
     {
-        #region Static Member Data
+#region Static Member Data
 
         // The default path to temp, used to create explicitly short and long paths
         private static readonly string s_tempPath = Path.GetTempPath();
@@ -101,9 +101,9 @@ public static class FileTracker
         // Static cache of the path separator character in an array for use in String.Split.
         private static readonly string pathSeparator = Path.PathSeparator.ToString();
 
-        #endregion
+#endregion
 
-        #region Static constructor
+#region Static constructor
 
         static FileTracker()
         {
@@ -128,9 +128,9 @@ static FileTracker()
             }
         }
 
-        #endregion
+#endregion
 
-        #region Native method wrappers
+#region Native method wrappers
 
         /// <summary>
         /// Stops tracking file accesses.  
@@ -195,9 +195,9 @@ public static void StartTrackingContextWithRoot(string intermediateDirectory, st
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TLogs", Justification = "Has now shipped as public API; plus it's unclear whether 'Tlog' or 'TLog' is the preferred casing")]
         public static void WriteContextTLogs(string intermediateDirectory, string taskName) => InprocTrackingNativeMethods.WriteContextTLogs(intermediateDirectory, taskName);
 
-        #endregion // Native method wrappers
+#endregion // Native method wrappers
 
-        #region Methods
+#region Methods
 
         /// <summary>
         /// Test to see if the specified file is excluded from tracked dependencies
@@ -627,7 +627,7 @@ public static string TrackerArguments(string command, string arguments, string d
         public static string TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName)
             => TrackerResponseFileArguments(dllName, intermediateDirectory, rootFiles, cancelEventName) + TrackerCommandArguments(command, arguments);
 
-        #region StartProcess methods
+#region StartProcess methods
 
         /// <summary>
         /// Start the process; tracking the command.  
@@ -694,7 +694,7 @@ public static Process StartProcess(string command, string arguments, ExecutableT
         public static Process StartProcess(string command, string arguments, ExecutableType toolType)
             => StartProcess(command, arguments, toolType, null, null, null, null);
 
-        #endregion // StartProcess methods
+#endregion // StartProcess methods
 
         /// <summary>
         /// Logs a message of the given importance using the specified resource string. To the specified Log.
@@ -744,7 +744,7 @@ internal static void LogWarningWithCodeFromResources(TaskLoggingHelper Log, stri
             Log?.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
         }
 
-        #endregion
+#endregion
     }
 
     /// <summary>
