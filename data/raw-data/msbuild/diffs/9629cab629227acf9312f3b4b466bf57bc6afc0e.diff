diff --git a/documentation/specs/BuildCheck/BuildCheck-Architecture.md b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
index d51504ad8f4..87c6a30b30e 100644
--- a/documentation/specs/BuildCheck/BuildCheck-Architecture.md
+++ b/documentation/specs/BuildCheck/BuildCheck-Architecture.md
@@ -11,8 +11,8 @@ This is an internal engineering document. For general overview and user point of
 | Advisory/Leadership | @rainersigwald |
 | Infrastructure      | @jankrivanek |
 | Configuration       | @f-alizada   |
-| Custom Analyzers    | @YuliiaKovalova |
-| Inbox Analyzers     | @ladipro |
+| Custom Checks       | @YuliiaKovalova |
+| Inbox Checks        | @ladipro |
 | Replay Mode         | @surayya-MS |
 | Tracing             | @maridematte |
 | Perf Advisory       | @AR-May |
@@ -47,29 +47,29 @@ In both cases the sink for the data is actualy a `LoggingContext` - this is to e
 
 #### Sample in-node data case - evaluated project
 
-One example of rich data that might be helpful for internal analyses is [`Project`](https://github.com/dotnet/msbuild/blob/28f488a74ed75bf5f21ca93ac2463a8cb1586d79/src/Build/Definition/Project.cs#L49). This OM is not currently being used during the standard build execution (`ProjectInstance` is used instead) - but we can conditionaly create and expose `Project` and satisfy the current internal consumers of `ProjectInstance` - spike of that is available [in experimental branch](https://github.com/dotnet/msbuild/compare/main...JanKrivanek:msbuild:research/analyzers-evaluation-hooking#diff-08a12a2fa138c3bfcabc7639bb75dda8534f3b662db4aca4f2b5595dbf9ba197).
+One example of rich data that might be helpful for internal checks is [`Project`](https://github.com/dotnet/msbuild/blob/28f488a74ed75bf5f21ca93ac2463a8cb1586d79/src/Build/Definition/Project.cs#L49). This OM is not currently being used during the standard build execution (`ProjectInstance` is used instead) - but we can conditionaly create and expose `Project` and satisfy the current internal consumers of `ProjectInstance` - spike of that is available [in experimental branch](https://github.com/dotnet/msbuild/compare/main...JanKrivanek:msbuild:research/analyzers-evaluation-hooking#diff-08a12a2fa138c3bfcabc7639bb75dda8534f3b662db4aca4f2b5595dbf9ba197).
 
 ## Execution Modes
 
-**Replay Mode** - so that users can choose to perform analyses post build, without impacting the performance of the build. And so that some level of analysis can be run on artifacts from builds produced by MSBuild from NET 9.0 / VS 17.12 or newer. The older versions won't be supported.
+**Replay Mode** - so that users can choose to perform checks post build, without impacting the performance of the build. And so that some level of checking can be run on artifacts from builds produced by MSBuild from NET 9.0 / VS 17.12 or newer. The older versions won't be supported.
 
-**Live mode** - this is what users are used to from compilation analyses. Integrating into build execution will as well help driving adoption by opting-in users by default to some level of checking and hence exposing them to the feature.
+**Live mode** - this is what users are used to from compilation checks. Integrating into build execution will as well help driving adoption by opting-in users by default to some level of checking and hence exposing them to the feature.
 
 ## Live Mode Hosting
 
 Prerequisites: [MSBuild Nodes Orchestration](../../wiki/Nodes-Orchestration.md#orchestration)
 
 The BuildCheck infrastructure will be prepared to be available concurrently within the `scheduler node` as well as in the additional `worker nodes`. There are 2 reasons for this:
-* BuildCheck will need to recognize custom analyzers packages during the evaluation time - so some basic code related to BuildCheck will need to be present in the worker node.
-* Presence in worker node (as part of the `RequestBuilder`), will allow inbox analyzers to agile leverage data not available within `BuildEventArgs` (while data proven to be useful should over time be exposed to `BuildEventArgs`)
+* BuildCheck will need to recognize custom check packages during the evaluation time - so some basic code related to BuildCheck will need to be present in the worker node.
+* Presence in worker node (as part of the `RequestBuilder`), will allow inbox checks to agile leverage data not available within `BuildEventArgs` (while data proven to be useful should over time be exposed to `BuildEventArgs`)
 
 ## Replay Mode
 
 Prerequisites: [MSBuild Replaying a Binary Log](../../wiki/Binary-Log.md#replaying-a-binary-log)
 
-When replaying a binary log, we can apply BuildCheck with help of `-analyze` switch:
+When replaying a binary log, we can apply BuildCheck with help of `-check` switch:
 ```
-> msbuild.exe msbuild.binlog -analyze
+> msbuild.exe msbuild.binlog -check
 ```
 
 If BuildCheck is enabled, then the events from `BinaryLogReplayEventSource` and new events from BuildCheck are merged into the `IEventSource`, from which the loggers get events.
@@ -89,36 +89,36 @@ flowchart TD
 
 ## Handling the Distributed Model
 
-We want to get some benefits (mostly inbox analyzers agility) from hosting BuildCheck infrastructure in worker nodes, but foremost we should prevent leaking the details of this model into public API and OM, until we are sure we cannot achieve all goals from just scheduler node from `BuildEventArgs` (which will likely never happen - as the build should be fully reconstructable from the `BuildEventArgs`).
+We want to get some benefits (mostly inbox checks agility) from hosting BuildCheck infrastructure in worker nodes, but foremost we should prevent leaking the details of this model into public API and OM, until we are sure we cannot achieve all goals from just scheduler node from `BuildEventArgs` (which will likely never happen - as the build should be fully reconstructable from the `BuildEventArgs`).
 
 How we'll internally handle the distributed model:
 * Each node will have just a single instance of infrastructure (`IBuildCheckManager`) available (registered via the MSBuild dependency injection container - `IBuildComponentHost`). This applies to a scheduler node with inproc worker node as well.
 * Scheduler node will have an MSBuild `ILogger` registered that will enable communicating information from worker nodes BuildCheck module to the scheduler node BuildCheck module - namely:
-    * Acquisition module from worker node will be able to communicated to the scheduler node that it encountered `PackageReference` for particular analyzer and that it should be loaded and instantiated in the main node.
+    * Acquisition module from worker node will be able to communicated to the scheduler node that it encountered `PackageReference` for particular check and that it should be loaded and instantiated in the main node.
     * Tracing module will be able to send perf stats from current worker node and aggregate all of those together in the main node.
-    * Theoretical execution-data-only sourcing inbox analyzer will be able to aggregate data from the whole build context (again - we should use this only for agility purposes, but shoot for analyzer that needs presence only in scheduler node). The way to do that can be via being present in all worker nodes, sending a specific type of 'in progress result' BuildEventArgs and aggreggating those intermediary results in the single instance running in the main node.
-* Apart from the scenarios above - the BuildCheck infrastructure modules in individual nodes should be able to function independently (namely - load the inbox analyzers that should live in nodes; send the analyzers reports via logging infrastructure; load user configuration from `.editorconfig` and decide on need to enable/disable/configure particular analyzers).
-* The custom analyzers will be hosted only in the main node - and hence the distributed model will be fully hidden from them. This might be a subject for revision in future versions.
+    * Theoretical execution-data-only sourcing inbox check will be able to aggregate data from the whole build context (again - we should use this only for agility purposes, but shoot for check that needs presence only in scheduler node). The way to do that can be via being present in all worker nodes, sending a specific type of 'in progress result' BuildEventArgs and aggreggating those intermediary results in the single instance running in the main node.
+* Apart from the scenarios above - the BuildCheck infrastructure modules in individual nodes should be able to function independently (namely - load the inbox checks that should live in nodes; send the checks reports via logging infrastructure; load user configuration from `.editorconfig` and decide on need to enable/disable/configure particular checks).
+* The custom checks will be hosted only in the main node - and hence the distributed model will be fully hidden from them. This might be a subject for revision in future versions.
 * Communication from main to worker node between BuildCheck infra modules is not planned (this might be revisited - even for the V1).
 
-## Analyzers Lifecycle
+## Check Lifecycle
 
 Planned model:
-* Analyzers factories get registered with the BuildCheck infrastructure (`BuildCheckManager`)
-    * For inbox analyzers - this happens on startup.
-    * For custom analyzers - this happens on connecting `ILogger` instance in scheduler node receives acquistion event (`BuildCheckAcquisitionEventArgs`). This event is being sent by worker node as soon as it hits a special marker (a magic property function call) during early evaluation. Loading is not processed by worker node as currently we want custom analyzers only in the main node (as they will be only given data proxied from BuildEventArgs).
-    The `BuildCheckAcquisitionEventArgs` should be sent prior `ProjectEvaluationStartedEventArgs` (buffering will need to take place), or main node will need to replay some initial data after custom analyzer is registered.
+* Checks factories get registered with the BuildCheck infrastructure (`BuildCheckManager`)
+    * For inbox checks - this happens on startup.
+    * For custom checks - this happens on connecting `ILogger` instance in scheduler node receives acquistion event (`BuildCheckAcquisitionEventArgs`). This event is being sent by worker node as soon as it hits a special marker (a magic property function call) during early evaluation. Loading is not processed by worker node as currently we want custom checks only in the main node (as they will be only given data proxied from BuildEventArgs).
+    The `BuildCheckAcquisitionEventArgs` should be sent prior `ProjectEvaluationStartedEventArgs` (buffering will need to take place), or main node will need to replay some initial data after custom check is registered.
 * `BuildCheckManager` receives info about new project starting to be build
     * On scheduler node the information is sourced from `ProjectEvaluationStartedEventArgs`
     * On worker node this is received from `RequestBuilder.BuildProject`
-* `BuildCheckManager` calls Configuration module and gets information for all analyzers in it's registry
-    * Analyzers with issues in configuration (communicated via `BuildCheckConfigurationException`) will issue an error and then be deregistered for the rest of the build.
+* `BuildCheckManager` calls Configuration module and gets information for all checks in it's registry
+    * Checks with issues in configuration (communicated via `BuildCheckConfigurationException`) will issue an error and then be deregistered for the rest of the build.
     * Global configuration issue (communicated via `BuildCheckConfigurationException`) will issue an error and then entirely disable BuildCheck.
-* `BuildCheckManager` instantiates all newly enabled analyzers and updates configuration for all already instantiated analyzers.
-* At that point of time analyzers are prepared for receiving data and performing their work. MSBuild will start calling `BuildCheckManager` callbacks (mostly pumping `BuildEventArgs`), passed data will be translated into BuildCheck OM and passed to analyzers.
-* Analyzers may decide to report results of their findings (via `BuildCheckDataContext.ReportResult`), the infrastructure will then perform post-processing (filter out reports for `Rule`s that are disabled, set the severity based on configuration) and send the result via the standard MSBuild logging infrastructure.
-* Analysis result might hence be reported after project's final `ProjectFinishedEventArgs`
-* Final status of the build should not be reported (and `BuildFinishedEventArgs` logged) until all analyzers are done processing and their results are accounted for.
+* `BuildCheckManager` instantiates all newly enabled checks and updates configuration for all already instantiated checks.
+* At that point of time checks are prepared for receiving data and performing their work. MSBuild will start calling `BuildCheckManager` callbacks (mostly pumping `BuildEventArgs`), passed data will be translated into BuildCheck OM and passed to checks.
+* Checks may decide to report results of their findings (via `BuildCheckDataContext.ReportResult`), the infrastructure will then perform post-processing (filter out reports for `Rule`s that are disabled, set the severity based on configuration) and send the result via the standard MSBuild logging infrastructure.
+* Checks result might hence be reported after project's final `ProjectFinishedEventArgs`
+* Final status of the build should not be reported (and `BuildFinishedEventArgs` logged) until all checks are done processing and their results are accounted for.
 
 # Configuration
 
@@ -126,35 +126,35 @@ Planned model:
 
 ## High-level logic
 
-MSBuild engine always finds and parses relevant `.editorconfig` files to see which analyzers should be enabled, if any. In typical builds this operation will not be expensive compared to everything else happening as part of building a project. It's a new cost to all builds though, and in the unlikely case that it starts showing as a perf bottleneck, we can cache the data relevant to MSBuild in a separate intermediate file, in a process-wide in-memory cache invalidated by timestamp checks, and so on.
+MSBuild engine always finds and parses relevant `.editorconfig` files to see which checks should be enabled, if any. In typical builds this operation will not be expensive compared to everything else happening as part of building a project. It's a new cost to all builds though, and in the unlikely case that it starts showing as a perf bottleneck, we can cache the data relevant to MSBuild in a separate intermediate file, in a process-wide in-memory cache invalidated by timestamp checks, and so on.
 
-The rest of the configuration comes directly or indirectly from project files in the form of properties, which creates an interesting ordering issue. For the engine to know the final values of properties such as `TargetFramework`, it needs to evaluate the project. However, if it turns out that an analyzer should be enabled that is interested in _tracing_ the evaluation, it is already too late. It's important to note that this issue exists only for a subset of analyzers. Analyzers interested in the _result_ of evaluation, for example, are fine. The best way of handling this would be to simply evaluate again. Technically, we only need to finish Pass 1 of evaluation to know the value of properties and have the relevant property functions called, so the extra work can be limited to pass 0 and 1. Measurements show that 75% of evaluation is spent in passes 0 and 1. In the very worst case when an extra pass 0/1 runs for each project and lacks any kind of further optimization, single-process incremental build of OrchardCore has been measured to take about 5% longer. There are opportunities for optimizing this, for example by adding a marker to SDK targets files notifying MSBuild of the point after which `TargetFramework` is expected to be fixed so the engine can bail early.
+The rest of the configuration comes directly or indirectly from project files in the form of properties, which creates an interesting ordering issue. For the engine to know the final values of properties such as `TargetFramework`, it needs to evaluate the project. However, if it turns out that an checks should be enabled that is interested in _tracing_ the evaluation, it is already too late. It's important to note that this issue exists only for a subset of checks. Checks interested in the _result_ of evaluation, for example, are fine. The best way of handling this would be to simply evaluate again. Technically, we only need to finish Pass 1 of evaluation to know the value of properties and have the relevant property functions called, so the extra work can be limited to pass 0 and 1. Measurements show that 75% of evaluation is spent in passes 0 and 1. In the very worst case when an extra pass 0/1 runs for each project and lacks any kind of further optimization, single-process incremental build of OrchardCore has been measured to take about 5% longer. There are opportunities for optimizing this, for example by adding a marker to SDK targets files notifying MSBuild of the point after which `TargetFramework` is expected to be fixed so the engine can bail early.
 
-Once `TargetFramework` is known, we can combine the default analyzer config with what came from `.editorconfig`, restart evaluation if an evaluation-tracing analyzer just got enabled, and continue with the rest of the build. Unlike `TargetFramework` which has an additive effect on the enabled analyzers, a master switch like `RunMSBuildChecks` may instruct the engine to not run anything. It would be unfortunate if the user had to pay any extra cost when `RunMSBuildChecks` evaluates to false. So preferrably we don't do anything perf sensitive until we hit the point in evaluation when `TargetFramework`, `RunMSBuildChecks`, `SdkAnalysisLevel`, ... are all known and the set of analyzers to use is finalized.
+Once `TargetFramework` is known, we can combine the default checks config with what came from `.editorconfig`, restart evaluation if an evaluation-tracing check just got enabled, and continue with the rest of the build. Unlike `TargetFramework` which has an additive effect on the enabled checks, a master switch like `RunMSBuildChecks` may instruct the engine to not run anything. It would be unfortunate if the user had to pay any extra cost when `RunMSBuildChecks` evaluates to false. So preferrably we don't do anything perf sensitive until we hit the point in evaluation when `TargetFramework`, `RunMSBuildChecks`, `SdkAnalysisLevel`, ... are all known and the set of checks to use is finalized.
 
-Since we are unlikely to enable any analyzers by default in .NET 9, the focus in this release should be on optimizing the `.editorconfig` handling.
+Since we are unlikely to enable any checks by default in .NET 9, the focus in this release should be on optimizing the `.editorconfig` handling.
 
 # Acquisition
 
-BuildCheck employs two distinct types of analyzers: inbox and custom. As a result, the acquisition and distribution processes vary.
-Inbox rules are integrated into the MSBuild repository, while custom analyzers can be packaged as NuGet packages and detected by MSBuild provided they adhere to a specific structure. 
+BuildCheck employs two distinct types of checks: inbox and custom. As a result, the acquisition and distribution processes vary.
+Inbox rules are integrated into the MSBuild repository, while custom checks can be packaged as NuGet packages and detected by MSBuild provided they adhere to a specific structure. 
 
 To streamline the creation of custom rules, a special [template](https://learn.microsoft.com/dotnet/core/tools/custom-templates) has been introduced.
-To enable MSBuild to recognize a custom analyzer, it must invoke the intrinsic function [`void RegisterBuildCheck(string path)`](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/Build/Evaluation/IntrinsicFunctions.cs#L700), which requires the path to the assembly as input. Therefore, it's essential for the user to ensure that the assembly exists in the specified location.
-Additionally, the custom rule must use [`BuildAnalyzerRule`](https://github.com/dotnet/msbuild/blob/9cdb3615adb4115f92b390de2f258fac5f320909/src/Build/BuildCheck/API/BuildAnalyzerRule.cs#L11C14-L11C31) as a parent class; otherwise, MSBuild will not register it.
+To enable MSBuild to recognize a custom check, it must invoke the intrinsic function [`void RegisterBuildCheck(string path)`](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/Build/Evaluation/IntrinsicFunctions.cs#L700), which requires the path to the assembly as input. Therefore, it's essential for the user to ensure that the assembly exists in the specified location.
+Additionally, the custom rule must use [`BuildCheckRule`](https://github.com/dotnet/msbuild/blob/9cdb3615adb4115f92b390de2f258fac5f320909/src/Build/BuildCheck/API/BuildAnalyzerRule.cs#L11C14-L11C31) as a parent class; otherwise, MSBuild will not register it.
 
 Examples of custom rules can be found in the [end-to-end tests](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/src/BuildCheck.UnitTests/EndToEndTests.cs#L139), showcasing various scenarios:
 
 1. [`Single Custom Rule Packaged as a NuGet Package`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate): Demonstrates the implementation of a custom rule encapsulated within a NuGet package. It contains the process of creating, packaging, and integrating a single custom rule into a project.
-2. [`Project with Multiple Analyzers Referenced`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected): Illustrates a project setup where multiple custom analyzers are referenced. This scenario is common in larger projects where multiple rule sets need to be enforced simultaneously.
+2. [`Project with Multiple Checks Referenced`](https://github.com/dotnet/msbuild/tree/main/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleChecksInjected): Illustrates a project setup where multiple custom checks are referenced. This scenario is common in larger projects where multiple rule sets need to be enforced simultaneously.
 
 Important Notes: 
-- In these examples, pay attention to the presence of the `CustomAnalyzerName.props` file. This file contains intrinsic function invocations necessary for successful rule registration. Understanding and correctly implementing these invocations are crucial for integrating custom rules into your projects effectively.
-- The examples do not include references to third-party assemblies that might be required in other custom analyzers. To load the custom instance in MSBuild, third-party assemblies have to be included in the NuGet package. The current implementation achieves this goal by using a special target: [AddNuGetDlls](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj#L22).
+- In these examples, pay attention to the presence of the `CustomCheckName.props` file. This file contains intrinsic function invocations necessary for successful rule registration. Understanding and correctly implementing these invocations are crucial for integrating custom rules into your projects effectively.
+- The examples do not include references to third-party assemblies that might be required in other custom checks. To load the custom instance in MSBuild, third-party assemblies have to be included in the NuGet package. The current implementation achieves this goal by using a special target: [AddNuGetDlls](https://github.com/dotnet/msbuild/blob/1c3b240ce7417223672c62862a6ff7e884e6997a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj#L22).
 
 ### Future Enhancements
 As our library of custom rules expands, we plan to enrich this section with real-world production rule examples. These examples will showcase a diverse range of rules addressing common development challenges. Once these production rules are published and available on nuget.org, we will update this documentation accordingly.
 
-# Build OM for Analyzers Authoring
+# Build OM for Checks Authoring
 
-**TBD** - details for the initial inbox analyzers set to be amended by @ladipro
+**TBD** - details for the initial inbox checks set to be amended by @ladipro
diff --git a/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md b/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
index ec1944a8700..2bc17291362 100644
--- a/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
+++ b/documentation/specs/BuildCheck/BuildCheck-feature-threat-model.md
@@ -4,8 +4,8 @@
 ## BuildCheck Feature Description
 
 The infrastructure within MSBuild allowing pluggability and execution of
-Analyzers and their Rules previously known as "warning waves" and
-"MSBuild Analyzers".
+Checks and their Rules previously known as "warning waves" and
+"MSBuild Checks".
 
 The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
 
@@ -24,45 +24,45 @@ For this document, we do not address any threats that result from violating thes
 
 ## Acquisition
 
-### Threat: Supply chain attack on custom analyzer
+### Threat: Supply chain attack on custom check
 
-Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box.
+Custom BuildCheck checks are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box.
 
 #### Mitigation
 
 Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
 
-Custom analyzers are delivered as regular nuget packages by MSBuild `<PackageReference />` element.
-Users is expected to implement process to detect and warn about known malicious custom analyzers.
+Custom checks are delivered as regular nuget packages by MSBuild `<PackageReference />` element.
+Users is expected to implement process to detect and warn about known malicious custom checks.
 
 #### Important Notice:
-Users should not add untrusted build analyzers to their projects. The use of untrusted or unverified 3rd party analyzers can introduce security risks and vulnerabilities into the build process. Always ensure that any build analyzers integrated into your projects come from reputable sources and have been thoroughly vetted.
+Users should not add untrusted build checks to their projects. The use of untrusted or unverified 3rd party checks can introduce security risks and vulnerabilities into the build process. Always ensure that any build checks integrated into your projects come from reputable sources and have been thoroughly vetted.
 
 To ensure a secure and reliable build environment, the following steps should be taken:
 
 #### Use Dedicated Security Tools:
-Utilize specialized security tools and services to scan and monitor 3rd party analyzer packages and their dependencies. 
+Utilize specialized security tools and services to scan and monitor 3rd party check packages and their dependencies. 
 #### Regular Updates:
 Ensure that all 3rd party packages and dependencies are regularly updated to the latest versions, which often include security patches and vulnerability fixes.
 
 #### Vendor Documentation and Support:
-Refer to the official documentation and support channels provided by the developers of the 3rd party analyzer packages. They may offer guidance and tools for managing security and addressing vulnerabilities.
+Refer to the official documentation and support channels provided by the developers of the 3rd party check packages. They may offer guidance and tools for managing security and addressing vulnerabilities.
 
 #### Internal Security Policies:
 Implement internal policies and processes for the assessment and mitigation of security risks associated with using 3rd party packages. This can include regular security audits, dependency management protocols, and automated vulnerability scanning during the build process.
 
 ## Execution
 
-### Threat: Supply chain attack by custom analyzer
+### Threat: Supply chain attack by custom check
 
-Custom BuildCheck analyzers are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box, with intent to inject malicious behavior into build artifacts.
+Custom BuildCheck checks are executed during build. If bad external actors inject malicious code into it by supply chain attack or somehow else, such code can run on build machine, mostly build agent or develop box, with intent to inject malicious behavior into build artifacts.
 
 #### Mitigation
 
 Detecting unsecure packages is not MSBuild responsibility and is currently out of scope of this feature.
 
 ### Threat: Third-Party Vulnerabilities
-Vulnerabilities in custom analyzer or its dependencies.
+Vulnerabilities in custom check or its dependencies.
 
 #### Mitigation
 
@@ -72,18 +72,18 @@ Detecting unsecure packages is not MSBuild responsibility and is currently out o
 
 ### Threat: Malicious configuration value
 
-Although .editorconfig shall be part of trusted sources, and hence not malicious, .editorconfig is looked up in parent folders up to the root. This can allow attacked to store malicious editor config up in parent folders with intent of disabling an analyzer or cause build malfunction for any reason.
+Although .editorconfig shall be part of trusted sources, and hence not malicious, .editorconfig is looked up in parent folders up to the root. This can allow attacked to store malicious editor config up in parent folders with intent of disabling an check or cause build malfunction for any reason.
 
 #### Mitigation
 
-This problem is identical to existing .editorconfig for Roslyn analyzers and since we share code for parsing it, we adopt same mitigation strategy, which is:
+This problem is identical to existing .editorconfig for Roslyn checks and since we share code for parsing it, we adopt same mitigation strategy, which is:
 
 - default template for editor config has `root = true` stopping parent config traversing
 - code is unit tested to verify and sanitize .editorconfig values
 
-### Threat: Intentional analyzer ID conflict or misleading ID
+### Threat: Intentional check ID conflict or misleading ID
 
-Malicious actors can define analyzer ID to be identical or like existing well known analyzer ID to increase probability of executing malicious analyzer code.
+Malicious actors can define check ID to be identical or like existing well known check ID to increase probability of executing malicious check code.
 
 #### Mitigation
 
@@ -91,9 +91,9 @@ Detecting unsecure packages is not MSBuild responsibility and is currently out o
 
 ## Declaration
 
-### Threat: Malicious analyzer registration property function
+### Threat: Malicious check registration property function
 
-Threat actor can write malicious analyzer registration property function in project files, with intent to run code from non-governed assemblies.
+Threat actor can write malicious check registration property function in project files, with intent to run code from non-governed assemblies.
 
 #### Mitigation
 
diff --git a/documentation/specs/BuildCheck/BuildCheck.md b/documentation/specs/BuildCheck/BuildCheck.md
index 69e542aa2e7..e1aaba36424 100644
--- a/documentation/specs/BuildCheck/BuildCheck.md
+++ b/documentation/specs/BuildCheck/BuildCheck.md
@@ -1,32 +1,32 @@
 
 # BuildCheck - Design Spec
 
-Previously known as "warning waves" and "MSBuild Analyzers"
+Previously known as "warning waves" and "MSBuild Checks"
 
 The feature is meant to help customers to improve and understand quality of their MSBuild scripts via rules violations reporting. It will allow MSBuild to gradually roll out additional rules, as users will be capable to configure their opt-in and severity of reports – preventing unwanted build breakages. And to equip powerusers to roll out their own quality checks – whether for general community or internal enterprise usage.
 
 # Terminology
 
-* **Analyzer** – unit of execution (single implementing class), can host multiple rules. 
+* **Check** – unit of execution (single implementing class), can host multiple rules. 
 * **Rule** – Single violation type, with single unique code (`“BC1234: Redefining built-in target”`). 
-* **Report** – Output from Analyzer informing about violating particular rule.
+* **Report** – Output from check informing about violating particular rule.
 * **CodeFix** – Violation remedy suggestion. Not yet applicable for MSBuild.
-* **BuildCheck** - Feature name. The infrastructure within MSBuild allowing pluggability and execution of Analyzers and their Rules
+* **BuildCheck** - Feature name. The infrastructure within MSBuild allowing pluggability and execution of checks and their Rules
 
 
 # North Star / Longer-term vision
 
-MSBuild provides a rich object model (further just OM) exposing representation of the build scripts (unstructured and structured model of documents contributing to the build), build data (the definition and evaluated values of MSBuild primitives) and build execution (the eventing model of inputs, processing and outputs of the orchestrated execution) so that various quality checking rules can be authored. This includes static analysis rules (e.g. checking validity of condition expressions) as well as build execution rules (e.g. checking of referencing nonexistent files) and composition rules (e.g. unintended outputs overwrites checking). Identical OM is exposed from live build execution and via post-build log event sourcing – so that users can choose whether the build analysis will happen as part of the build or as a separate process.
+MSBuild provides a rich object model (further just OM) exposing representation of the build scripts (unstructured and structured model of documents contributing to the build), build data (the definition and evaluated values of MSBuild primitives) and build execution (the eventing model of inputs, processing and outputs of the orchestrated execution) so that various quality checking rules can be authored. This includes static check rules (e.g. checking validity of condition expressions) as well as build execution rules (e.g. checking of referencing nonexistent files) and composition rules (e.g. unintended outputs overwrites checking). Identical OM is exposed from live build execution and via post-build log event sourcing – so that users can choose whether the build check will happen as part of the build or as a separate process.
 
-Users are able to tune the behavior of the checks via `.editorconfig` which brings unified and standardized experience with other tooling (including built-in and third-party C# analyzers) leveraging `.editorconfig` files.
+Users are able to tune the behavior of the checks via `.editorconfig` which brings unified and standardized experience with other tooling (including built-in and third-party C# checks) leveraging `.editorconfig` files.
 
-Powerusers are able to develop, test and publish their custom analyzers easily and contribute them back to community. The local development scenario doesn’t require roundtrip through packaging.
+Powerusers are able to develop, test and publish their custom checks easily and contribute them back to community. The local development scenario doesn’t require roundtrip through packaging.
 
-A solid set of in-the-box analyzers is provided by MSBuild and the .NET SDK, extended each release, with high quality reports (pointing exact locations of issue, offering clear and actionable explanations, not repetitive for builds with multi-execution or/and multi-importing of a same script in single build context). The existing in-the-box analyzers are gradually enabled by default and their severity increased - in waves (likely tied to sdk releases) - aiming to constantly increase the quality of our customers build scripts. To avoid breaking customers builds, there will still be an explicit user gesture required to opt into running the analysis. This will be done either by configuring the analyzers with `.editorconfig` or auto-enabling the analysis based on the TFM of the project. There will be no difference between building with `dotnet build` and with `MSBuild.exe`, they will follow the same enablement rules with the set of enabled built-in analyzers derived from `.editorconfig` and TFM/props. Building in Visual Studio will eventually reach parity with command-line build as well.
+A solid set of in-the-box checks is provided by MSBuild and the .NET SDK, extended each release, with high quality reports (pointing exact locations of issue, offering clear and actionable explanations, not repetitive for builds with multi-execution or/and multi-importing of a same script in single build context). The existing in-the-box checks are gradually enabled by default and their severity increased - in waves (likely tied to sdk releases) - aiming to constantly increase the quality of our customers build scripts. To avoid breaking customers builds, there will still be an explicit user gesture required to opt into running the check. This will be done either by configuring the checks with `.editorconfig` or auto-enabling the check based on the TFM of the project. There will be no difference between building with `dotnet build` and with `MSBuild.exe`, they will follow the same enablement rules with the set of enabled built-in checks derived from `.editorconfig` and TFM/props. Building in Visual Studio will eventually reach parity with command-line build as well.
 
-Projects that don't use the .NET SDK and those that are not SDK-style at all are TBD. There is a possibility of using a property like `MSBuildAnalysisLevel` to enable some base analyzers we believe will add value everywhere.
+Projects that don't use the .NET SDK and those that are not SDK-style at all are TBD. There is a possibility of using a property like `MSBuildCheckLevel` to enable some base checks we believe will add value everywhere.
 
-The analysis has small impact on build duration with ability to disable analysis altogether which will remove all the performance costs associated with the analysis. The perf impact on representative projects is continuously monitored and documented by the MSBuild team.
+The check has small impact on build duration with ability to disable check altogether which will remove all the performance costs associated with the check. The perf impact on representative projects is continuously monitored and documented by the MSBuild team.
 
 
 # Scope of initial iteration
@@ -34,43 +34,43 @@ The analysis has small impact on build duration with ability to disable analysis
 Majority of following cases are included in appropriate context within the scenarios in [User Experience](#user-experience) section. Following is a quick overview.
 
 ## In scope
-* Inbox (built-in) analyzers that run during the build execution.
-* Inbox analyzers that run when replaying binlog.
-* Custom authored analyzers, delivered via nuget.
-* Analyzers reports (errors, warnings, messages) are in logger output, VS error window.
+* Inbox (built-in) checks that run during the build execution.
+* Inbox checks that run when replaying binlog.
+* Custom authored checks, delivered via nuget.
+* Checks reports (errors, warnings, messages) are in logger output, VS error window.
 * Codes will be distinguishable from standard build warnings/error (to prevent easy mixups and attempts to configure standard msbuild warnings/errors via editorconfig), but otherwise the outputs are very similar.
-* Default opt-ins and levels for inbox analyzers set by sdk version (via [`$SdkAnalysisLevel`]((https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md))) or other agreed mechanism for controlling increasing strictness between .NET versions.
-* Custom analyzers opted in via `PackageReference` of a particular nuget with the analyzer.
-* Explicit overrides of enablement and analysis levels via `.editorconfig` file (with up to a per-project scope).
+* Default opt-ins and levels for inbox checks set by sdk version (via [`$SdkAnalysisLevel`]((https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md))) or other agreed mechanism for controlling increasing strictness between .NET versions.
+* Custom checks opted in via `PackageReference` of a particular nuget with the check.
+* Explicit overrides of enablement and check levels via `.editorconfig` file (with up to a per-project scope).
 * [Specification of `.editorconfig`](https://spec.editorconfig.org/) will be observed. 
 * Simplified authoring experience via template and doc.
-* Single analyzer can produce reports for multiple rules. However those need to be declared upfront.
-* Opt-in reporting of time spent via specific analyzers and infra overall.
+* Single check can produce reports for multiple rules. However those need to be declared upfront.
+* Opt-in reporting of time spent via specific checks and infra overall.
 * Collect touched `.editorconfig`s into binlog embedded files.
-* Possibility to opt-out from analysis - the perf should not be impacted when done so.
-* Team collects performance impact numbers on a set of benchmark builds with the inbox analyzers enabled.
+* Possibility to opt-out from check - the perf should not be impacted when done so.
+* Team collects performance impact numbers on a set of benchmark builds with the inbox checks enabled.
 
 ## Non Goals, but subject for consideration
-* Custom analyzer in a local project (source codes) or a binary.
+* Custom check in a local project (source codes) or a binary.
 * Bulk configuration of multiple rules (based on prefixes).
-* Specifying scope of MSBuild imports that will be considered for analysis (so that e.g. data from sdk won't even be passed to analyzer, if not requested).
+* Specifying scope of MSBuild imports that will be considered for check (so that e.g. data from sdk won't even be passed to check, if not requested).
 * Attempts to try to configure standard msbuild warnings/errors via `.editorconfig` should lead to fail fast errors.
-* Configuring analysis levels when analyzing from binlog - beyond the collected editorconfigs
-* Structured information in VS error window (similarly to the Roslyn analyzer reports - reports have titles, details, locations, searchable codes and exposed links leading to detailed documentation).
+* Configuring BuildCheck levels when checking from binlog - beyond the collected editorconfigs
+* Structured information in VS error window (similarly to the Roslyn check reports - reports have titles, details, locations, searchable codes and exposed links leading to detailed documentation).
 
 
 ## Out of scope
 * Instrumentation for telemetry.
-* Design time build analysis.
+* Design time build check.
 * Localization support (for reports message formats, identifiers, etc.).
-* Custom analyzers have equal data access as the inbox analyzers. We'll aim to ship analyzers that use public BuildCheck API/OM surface. But for extra agility we might chose to implement and ship some analyzers using unexposed data.
-* All inbox analyzers reports have precise location(s) of issues (however for each individual analyzer not providing precise location we should have a very strong reason, why location cannot be provided and why it still brings value even without precise location).
-* Opt-out of analysis on code-level (something like C# `#pragma warning disable`, but within msbuild xml files).
+* Custom checks have equal data access as the inbox checks. We'll aim to ship checks that use public BuildCheck API/OM surface. But for extra agility we might chose to implement and ship some checks using unexposed data.
+* All inbox checks reports have precise location(s) of issues (however for each individual check not providing precise location we should have a very strong reason, why location cannot be provided and why it still brings value even without precise location).
+* Opt-out of BuildCheck on code-level (something like C# `#pragma warning disable`, but within msbuild xml files).
 * Simplified authoring experience via dedicated reference assembly.
-* Restore phase analysis.
-* Turning analysis off/on based on target (e.g. multi-targeted builds, calling MSBuild task etc.).
-* Controlling/Configuring lifetime of analyzers - analyzers will currently be held alive, as single instance per analyzer, for the whole duration of the build. But future versions might prevent some of the analyzers to survive beyond a scope of a single project built (means for sharing data would be provided).
-* Event Tracing for Windows (ETW) for analyzers.
+* Restore phase check.
+* Turning check off/on based on target (e.g. multi-targeted builds, calling MSBuild task etc.).
+* Controlling/Configuring lifetime of checks - checks will currently be held alive, as single instance per check, for the whole duration of the build. But future versions might prevent some of the checks to survive beyond a scope of a single project built (means for sharing data would be provided).
+* Event Tracing for Windows (ETW) for checks.
 * Attributing `.editorconfig` configurations to .sln files. E.g.:
 ```ini
 # I expect this to apply to all projects within my solution, but not to projects which are not part of the solution
@@ -91,17 +91,17 @@ build_check.BC0101.Severity=warning
 
 ## Running / UX
 
-### Inbox Analyzers
+### Inbox Checks
 
-Suggested list of analyzers to be shipped with V1: https://github.com/dotnet/msbuild/issues/9630#issuecomment-2007440323
+Suggested list of checks to be shipped with V1: https://github.com/dotnet/msbuild/issues/9630#issuecomment-2007440323
 
-The proposed initial configuration for those is TBD (as well based on initial test runs of the analyzers of chosen public repositories).
+The proposed initial configuration for those is TBD (as well based on initial test runs of the checks of chosen public repositories).
 
 ### Live Build
 
-BuildCheck will run as part of the build and execute [inbox analyzers](#inbox-analyzers) and [custom analyzers](#acquisition-of-custom-analyzers) based on the [configuration](#configuration). Users will have an option to completely opt-out from BuildCheck to run via an MSBuild property (could be set in a project file or passed on the commandline).
+BuildCheck will run as part of the build and execute [inbox checks](#inbox-checks) and [custom checks](#acquisition-of-custom-checks) based on the [configuration](#configuration). Users will have an option to completely opt-out from BuildCheck to run via an MSBuild property (could be set in a project file or passed on the commandline).
 
-Findings - reports - of analyzers will be output as build messages/warnings/errors, and the message/warnings/error code should help distinguish BuildCheck produced reports from regular build errors/warnings.
+Findings - reports - of checks will be output as build messages/warnings/errors, and the message/warnings/error code should help distinguish BuildCheck produced reports from regular build errors/warnings.
 
 BuildCheck reports will have power to fail the build (via errors or warnings), that would otherwise succeed without the BuildCheck. This is actually the main benefit of the feature - as it helps enforcing new rules, that are easily user configurable individually or as a whole feature - to prevent unwanted breakages of legacy builds not ready for improvements.
 
@@ -110,36 +110,36 @@ BuildCheck reports will have power to fail the build (via errors or warnings), t
 Users will have option to explicitly opt-in to run BuildCheck during the binlog replay mode:
 
 ```bash
-> dotnet build msbuild.binlog /analyze
+> dotnet build msbuild.binlog /check
 ```
 
-Would there be any analyzers that are not possible to run during the replay mode (subject to internal design - this difference won't be exposed during [custom analyzers authoring](#custom-analyzers-authoring)), replay mode will inform user about those via warnings.
+Would there be any checks that are not possible to run during the replay mode (subject to internal design - this difference won't be exposed during [custom checks authoring](#custom-checks-authoring)), replay mode will inform user about those via warnings.
 
-Replay mode will by default consider `.editorconfig` files stored within the binlog and will run analyzers based on those. This would possibly lead to unintended double-reports – as binlog will have the runtime analysis reports stored, plus the replay-time analysis reports will be augmented. At the same time we might want to run some additional checks in the replay mode, that have not been enabled (or not even available) during the build time.
+Replay mode will by default consider `.editorconfig` files stored within the binlog and will run checks based on those. This would possibly lead to unintended double-reports – as binlog will have the runtime check reports stored, plus the replay-time check reports will be augmented. At the same time we might want to run some additional checks in the replay mode, that have not been enabled (or not even available) during the build time.
 
 For this reason we will consider following modes (all are non-goals):
 * All binlog stored reports are skipped by default. We add option to request not skipping them (but they might need to be prefixed or otherwise distinguished from the 'fresh' reports).
 * Ability to specify skipping of the stored .editorconfig files
 * Ability to specify single replay-time .editorconfig file and it’s precedence (only the specified, specified as most significant, specified as least significant)
 
-We might as well consider specifying custom analyzers on a command line (as a non-goal) - so that unreferenced custom analyzers can be run against the binlog.
+We might as well consider specifying custom checks on a command line (as a non-goal) - so that unreferenced custom checks can be run against the binlog.
 
 ## Configuration
 
-There will be 3 mechanisms of configuring the analyzers and rules:
-* The default configuration declared by the analyzers themselves ([more details on implementation](#rules-declaration))
-* The TFM of the project and the [Sdk Analysis Level property](https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md) – mostly for the inbox analyzers
+There will be 3 mechanisms of configuring the checks and rules:
+* The default configuration declared by the checks themselves ([more details on implementation](#rules-declaration))
+* The TFM of the project and the [Sdk Analysis Level property](https://github.com/dotnet/designs/blob/main/proposed/sdk-analysis-level.md) – mostly for the inbox checks
 * `.editorconfig` file
 
 We will also consider respecting `SdkAnalysisLevel` to override the per-TFM defaults. Additionally, we may introduce a new "master switch" property, tentatively called `RunMSBuildChecks`, to make it possible to disable everything whole-sale. This would be used in scenarios like F5 in VS.
 ```
-Skipping analyzers to speed up the build. You can execute 'Build' or 'Rebuild' command to run analyzers.
+Skipping checks to speed up the build. You can execute 'Build' or 'Rebuild' command to run checks.
 ```
 
 Here's the proposed release schedule:
-- **.NET 9** - the feature is introduced and enabled in `dotnet build` and `MSBuild.exe` command-line builds. It is not enabled in VS just yet. No analyzers are enabled by default. It is not technically required to read the TFM or any other props during evaluation, though it would be nice to respect `RunMSBuildChecks` already in this release. `.editorconfig` can be the sole source of configuration.
-- **.NET 10** - based on feedback and testing, we choose a set of analyzers to enable by default for projects targeting `net10.0`, and enable the feature as a whole in Visual Studio. Depending on how we feel about the perf characteristics of evaluation, especially the "double evaluation" mandated by discovering evaluation-tracking analyzers just-in-time, we may want to omit such analyzers from the default set.
-- **.NET 11** and beyond - some more analyzers are enabled for projects targeting `net11.0`, the `net10.0` does not change. Everything is mature and performant enough that we are able to auto-enable any analyzer. The gradual tightening of rules enabled by default gets us closer to the long envisioned "strict mode", which will ultimately allow us to evolve MSBuild to be simpler and more performant.
+- **.NET 9** - the feature is introduced and enabled in `dotnet build` and `MSBuild.exe` command-line builds. It is not enabled in VS just yet. No checks are enabled by default. It is not technically required to read the TFM or any other props during evaluation, though it would be nice to respect `RunMSBuildChecks` already in this release. `.editorconfig` can be the sole source of configuration.
+- **.NET 10** - based on feedback and testing, we choose a set of checks to enable by default for projects targeting `net10.0`, and enable the feature as a whole in Visual Studio. Depending on how we feel about the perf characteristics of evaluation, especially the "double evaluation" mandated by discovering evaluation-tracking checks just-in-time, we may want to omit such checks from the default set.
+- **.NET 11** and beyond - some more checks are enabled for projects targeting `net11.0`, the `net10.0` does not change. Everything is mature and performant enough that we are able to auto-enable any check. The gradual tightening of rules enabled by default gets us closer to the long envisioned "strict mode", which will ultimately allow us to evolve MSBuild to be simpler and more performant.
 
 
 For the `.editorconfig` file configuration, following will apply:
@@ -148,16 +148,16 @@ For the `.editorconfig` file configuration, following will apply:
 * `.editorconfig` files packaged within nuget packages within local nuget cache won’t be considered.
 
 ### Non-Goals (but might be considered):
-* bulk configuration of multiple rules - based on analyzers/rules prefixes or/and categories.
+* bulk configuration of multiple rules - based on checks/rules prefixes or/and categories.
 * attempts to try to configure standard msbuild warnings/errors via `.editorconfig` should lead to fail fast errors.
-* configuring analysis levels when analyzing from binlog - beyond the collected editorconfigs.
-* Aliasing the analyzers/rules, allowing to create multiple instances with different custom configuration (e.g. single analyzer checking configurable list of forbidden properties prefixes can have 2 instance, each initialized with different list to check, each of the instance configurable for individual projects separately).
+* configuring check levels when checking from binlog - beyond the collected editorconfigs.
+* Aliasing the checks/rules, allowing to create multiple instances with different custom configuration (e.g. single check checking configurable list of forbidden properties prefixes can have 2 instance, each initialized with different list to check, each of the instance configurable for individual projects separately).
 
 ### Out of scope for configuration:
-* opt-out of analysis on code-level (analogy to C# pragmas, but within msbuild xml files).
+* opt-out of check on code-level (analogy to C# pragmas, but within msbuild xml files).
 * lower granularity of `.editorconfig` settings other than whole projects.
 * attributing configuration to a .sln file and expecting it will apply to all contained projects.
-* Support for multiple [custom configurations](#custom-configuration-declaration) within a single build for a single rule. (Not to be mixed with [standardized configuration](#standardized-configuration-declaration) - which can be configured freely per project) If a custom configuration will be used, it will need to be specified identically in each explicit configurations of the rule. This is chosen so that there are no implicit requirements on lifetime of the analyzer or analyzer instancing – each analyzer will be instantiated only once per build (this is however something that will very likely change in future versions – so authors are advised not to take hard dependency on single instance policy).
+* Support for multiple [custom configurations](#custom-configuration-declaration) within a single build for a single rule. (Not to be mixed with [standardized configuration](#standardized-configuration-declaration) - which can be configured freely per project) If a custom configuration will be used, it will need to be specified identically in each explicit configurations of the rule. This is chosen so that there are no implicit requirements on lifetime of the check or check instancing – each check will be instantiated only once per build (this is however something that will very likely change in future versions – so authors are advised not to take hard dependency on single instance policy).
 
 ### Sample configuration
 
@@ -172,7 +172,7 @@ build_check.COND0543.custom_switch=QWERTY
 
 ### User Configurable Options
 
-Initial version of BuildCheck plans a limited set of options configurable by user (via `.editorconfig`) by which users can override default configuration of individual analyzer rules.
+Initial version of BuildCheck plans a limited set of options configurable by user (via `.editorconfig`) by which users can override default configuration of individual check rules.
 
 **NOTE:** The actual naming of the configuration options is yet to be determined.
 
@@ -188,13 +188,13 @@ Option `Severity` with following values will be available:
 | Warning | `warning` |
 | Error | `error` |
 
-Severity levels are in line with [roslyn analyzers severity levels](https://learn.microsoft.com/en-us/visualstudio/code-quality/use-roslyn-analyzers). `Default` severity in `.editorconfig` will lead to using build-in severity from the analyzer (so this can be used for clearing custom severity setting from higher level `.editorconfig` file). `Default` severity in the build-in code has same effect as if the code doesn't specify severity at all - an infrastruture default of `None` is considered.
+Severity levels are in line with [roslyn analyzers severity levels](https://learn.microsoft.com/en-us/visualstudio/code-quality/use-roslyn-analyzers). `Default` severity in `.editorconfig` will lead to using build-in severity from the check (so this can be used for clearing custom severity setting from higher level `.editorconfig` file). `Default` severity in the build-in code has same effect as if the code doesn't specify severity at all - an infrastruture default of `None` is considered.
 
-Configuration will dictate transformation of the analyzer report to particular build output type (message, warning or error).
+Configuration will dictate transformation of the check report to particular build output type (message, warning or error).
 
-Each rule has a severity, even if multiple rules are defined in a single analyzer. The rule can have different severities for different projects within a single build session.
+Each rule has a severity, even if multiple rules are defined in a single check. The rule can have different severities for different projects within a single build session.
 
-If all the rules from a single analyzer have severity `None` - analyzer won't be given any data for such configured part of the build (specific project or a whole build). If analyzer have some rules enabled and some disabled - it will be still fed with data, but the reports will be post-filtered.
+If all the rules from a single check have severity `None` - check won't be given any data for such configured part of the build (specific project or a whole build). If check have some rules enabled and some disabled - it will be still fed with data, but the reports will be post-filtered.
 
 #### Configuring severity level
 
@@ -203,21 +203,21 @@ If all the rules from a single analyzer have severity `None` - analyzer won't be
 build_check.BC0101.severity=warning
 ```
 
-#### Scope of Analysis
+#### Scope of Check
 
-Option `EvaluationAnalysisScope` with following possible options will be available:
+Option `EvaluationCheckScope` with following possible options will be available:
 
-| EvaluationAnalysisScope (Solution Explorer)   | EditorConfig option      |  Behavior  | 
+| EvaluationCheckScope (Solution Explorer)   | EditorConfig option      |  Behavior  | 
 | ------------- | ------------- |   ------------- |
-| ProjectFileOnly | `project_file` | Only the data from currently analyzed project will be sent to the analyzer. Imports will be discarded. | 
-| WorkTreeImports | `work_tree_imports` |  Only the data from currently analyzed project and imports from files not recognized to be in nuget cache or SDK install folder will be sent to the analyzer. Other imports will be discarded. |  
-| ProjectWithAllImports | `all` | All data will be sent to the analyzer. | 
+| ProjectFileOnly | `project_file` | Only the data from currently checked project will be sent to the check. Imports will be discarded. | 
+| WorkTreeImports | `work_tree_imports` |  Only the data from currently checked project and imports from files not recognized to be in nuget cache or SDK install folder will be sent to the check. Other imports will be discarded. |  
+| ProjectWithAllImports | `all` | All data will be sent to the check. | 
 
-All rules of a single analyzer must have the `EvaluationAnalysisScope` configured to a same value. If any rule from the analyzer have the value configured differently - a warning will be issued during the build and analyzer will be deregistered.
+All rules of a single check must have the `EvaluationCheckScope` configured to a same value. If any rule from the check have the value configured differently - a warning will be issued during the build and check will be deregistered.
 
-Same rule can have `EvaluationAnalysisScope` configured to different values for different projects.
+Same rule can have `EvaluationCheckScope` configured to different values for different projects.
 
-BuildCheck might not be able to guarantee to properly filter the data with this distinction for all [registration types](#RegisterActions) - in case an explicit value is attempted to be configured (either [from the analyzer code](#BuildAnalyzerConfiguration) or from `.editorconfig` file) for an analyzer that has a subscription to unfilterable data - a warning will be issued during the build and analyzer will be deregistered.
+BuildCheck might not be able to guarantee to properly filter the data with this distinction for all [registration types](#RegisterActions) - in case an explicit value is attempted to be configured (either [from the check code](#BuildExecutionCheckConfiguration) or from `.editorconfig` file) for an check that has a subscription to unfilterable data - a warning will be issued during the build and check will be deregistered.
 
 #### Configuring evalution scope
 
@@ -226,7 +226,7 @@ BuildCheck might not be able to guarantee to properly filter the data with this
 build_check.BC0101.scope=all
 ```
 
-## Analyzers and Rules Identification
+## Checks and Rules Identification
 
 **TBD**
 
@@ -236,36 +236,36 @@ build_check.BC0101.scope=all
 * Ability to use prefixes during configuration
 
 
-## Custom Analyzers Authoring
+## Custom Checks Authoring
 
 ### Implementation
 
-To author custom analyzer, user will need to implement given contract (delivered in Microsoft.Build package). The contract will provide access to the exposed BuildCheck OM focused on build analysis.
+To author custom check, user will need to implement given contract (delivered in Microsoft.Build package). The contract will provide access to the exposed BuildCheck OM focused on build check.
 
-#### Analyzer declaration
+#### Check declaration
 
 Simplified proposal:
 
 ```csharp
-public abstract class BuildAnalyzer : IDisposable
+public abstract class BuildExecutionCheck : IDisposable
 {
     /// <summary>
-    /// Friendly name of the analyzer.
+    /// Friendly name of the check.
     /// Should be unique - as it will be used in the tracing stats, infrastructure error messages, etc.
     /// </summary>
     public abstract string FriendlyName { get; }
 
     /// <summary>
-    /// Single or multiple rules supported by the analyzer.
+    /// Single or multiple rules supported by the check.
     /// </summary>
-    public abstract IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; }
+    public abstract IReadOnlyList<BuildExecutionCheckRule> SupportedRules { get; }
 
     /// <summary>
-    /// Optional initialization of the analyzer.
+    /// Optional initialization of the check.
     /// </summary>
     /// <param name="configurationContext">
     /// Custom data (not recognized by the infrastructure) passed from .editorconfig
-    /// Currently the custom data has to be identical for all rules in the analyzer and all projects.
+    /// Currently the custom data has to be identical for all rules in the check and all projects.
     /// </param>
     public abstract void Initialize(ConfigurationContext configurationContext);
 
@@ -287,26 +287,26 @@ Sample of how registrations might look like:
 ```csharp
 public interface IBuildCheckRegistrationContext
 {
-    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
+    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction);
 
-    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
+    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction);
 
     // ...
 }
 ```
 
-The data provided in callbacks for registered actions will allow the analyzer to submit reports for its rules. A single callback can lead to multiple reports being generated.
+The data provided in callbacks for registered actions will allow the check to submit reports for its rules. A single callback can lead to multiple reports being generated.
 
-Any analyzer will be allowed to produce reports only for Rules that it declared in it’s `SupportedRules` definition.
+Any check will be allowed to produce reports only for Rules that it declared in it’s `SupportedRules` definition.
 
 #### Rules declaration
 
-A single analyzer can declare support of multiple rules – since it might produce reports for those on top of same input data – and for efficiency reasons a single processing of data might be needed.
+A single check can declare support of multiple rules – since it might produce reports for those on top of same input data – and for efficiency reasons a single processing of data might be needed.
 
 Simplified proposal of definition of a single rule:
 
 ```csharp
-public class BuildAnalyzerRule
+public class BuildExecutionCheckRule
 {
     // Identification/Description fields
     // (To be defined more precisely by https://github.com/dotnet/msbuild/issues/9823)
@@ -315,11 +315,11 @@ public class BuildAnalyzerRule
     /// The default configuration - overridable by the user via .editorconfig.
     /// If no user specified configuration is provided, this default will be used.
     /// </summary>
-    public BuildAnalyzerConfiguration DefaultConfiguration { get; }
+    public BuildExecutionCheckConfiguration DefaultConfiguration { get; }
 }
 ```
 
-<a name="BuildAnalyzerConfiguration"></a>Each rule will supply its default configuration (mainly enablement and report severity) – those will apply if `.editorconfig` file will not set those settings explicitly. If the rule doesn't provide (some of) its defaults, a global hardcoded default is used (`severity: message, enabled: false`).
+<a name="BuildExecutionCheckConfiguration"></a>Each rule will supply its default configuration (mainly enablement and report severity) – those will apply if `.editorconfig` file will not set those settings explicitly. If the rule doesn't provide (some of) its defaults, a global hardcoded default is used (`severity: message, enabled: false`).
 
 #### Standardized configuration declaration
 
@@ -327,37 +327,37 @@ Proposal of configuration specification:
 
 ```csharp
 /// <summary>
-/// Configuration for a build analyzer.
-/// Default values can be specified by the Analyzer in code.
+/// Configuration for a build check.
+/// Default values can be specified by the check in code.
 /// Users can overwrite the defaults by explicit settings in the .editorconfig file.
 /// Each rule can have its own configuration, which can differ per each project.
-/// The <see cref="EvaluationAnalysisScope"/> setting must be same for all rules in the same analyzer (but can differ between projects)
+/// The <see cref="EvaluationCheckScope"/> setting must be same for all rules in the same check (but can differ between projects)
 /// </summary>
-public class BuildAnalyzerConfiguration
+public class BuildExecutionCheckConfiguration
 {
     /// <summary>
     /// This applies only to specific events, that can distinguish whether they are directly inferred from
-    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from analysis.
+    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from check.
     ///
     /// If not supported by the data source - then the setting is ignored
     /// </summary>
-    public EvaluationAnalysisScope? EvaluationAnalysisScope { get; internal init; }
+    public EvaluationCheckScope? EvaluationCheckScope { get; internal init; }
 
     /// <summary>
     /// The default severity of the result for the rule. May be overridden by user configuration.
     ///
-    /// If all rules within the analyzer are `none`, the whole analyzer will not be run.
-    /// If some rules are `none` and some are not, the analyzer will be run and reports will be post-filtered.
+    /// If all rules within the check are `none`, the whole check will not be run.
+    /// If some rules are `none` and some are not, the check will be run and reports will be post-filtered.
     /// </summary>
-    public BuildAnalyzerResultSeverity? Severity { get; internal init; }
+    public BuildExecutionCheckResultSeverity? Severity { get; internal init; }
 }
 ```
 
-Values for this recognized contract, that are explicitly specified via .editorconfig files are passed both to the BuildCheck infrastructure as well as individual analyzers.
+Values for this recognized contract, that are explicitly specified via .editorconfig files are passed both to the BuildCheck infrastructure as well as individual checks.
 
 #### Custom configuration declaration
 
-However if user will specify additional – unrecognized - values in `.editorconfig` file as part of a particular analyzer configuration – those values will be extracted as key-value pairs and passed to the analyzer initialization call (`Initialize`) via `ConfigurationContext`:
+However if user will specify additional – unrecognized - values in `.editorconfig` file as part of a particular check configuration – those values will be extracted as key-value pairs and passed to the check initialization call (`Initialize`) via `ConfigurationContext`:
 
 ```csharp
 /// <summary>
@@ -373,7 +373,7 @@ public class ConfigurationContext
     /// <summary>
     /// Configuration data from standard declarations
     /// </summary>
-    public IReadOnlyList<BuildAnalyzerConfiguration> BuildAnalyzerConfig { get; init; }
+    public IReadOnlyList<BuildExecutionCheckConfiguration> BuildExecutionCheckConfig { get; init; }
 }
 ```
 
@@ -390,35 +390,35 @@ All the publicly exposed contracts will be available within `Microsoft.Build.Exp
 var availability = Features.CheckFeatureAvailability("BuildCheck.Beta");
 ```
 
-This way the analyzers authors will be equipped to write highly-compatible analyzers even in a possibility of changing API.
+This way the checks authors will be equipped to write highly-compatible checks even in a possibility of changing API.
 
 
 ### Testing and Debugging
 
 **TBD**
 
-We aim to provide ability to locally test analyzers from local projects or assemblies without a need to roundtrip through packaging them. The exact way is yet to be determined.
+We aim to provide ability to locally test checks from local projects or assemblies without a need to roundtrip through packaging them. The exact way is yet to be determined.
 
 At the same time we aim to provide mocks providing the BuildCheck context data – this work is however a non-goal.
 
 ### Packaging
 
-Several requirements are mandated for analyzer packages to be properly recognized (Netstandard only, A call to designated property function will need to be part of the packaged build assets, dependencies will need to be packaged, binaries structure flattened). There might as well be couple of optional practices making the analyzer package more resources savvy (E.g. defining the rule ids and enablement status within the mentioned property function - so that such information doesn't require loading and calling of the analyzer type).
+Several requirements are mandated for check packages to be properly recognized (Netstandard only, A call to designated property function will need to be part of the packaged build assets, dependencies will need to be packaged, binaries structure flattened). There might as well be couple of optional practices making the check package more resources savvy (E.g. defining the rule ids and enablement status within the mentioned property function - so that such information doesn't require loading and calling of the check type).
 
-Also custom analyzer package is a dependency is a purely development time harness - so it should be marked as [`DevelopmentDependency`](https://learn.microsoft.com/en-us/nuget/reference/nuspec#developmentdependency).
+Also custom check package is a dependency is a purely development time harness - so it should be marked as [`DevelopmentDependency`](https://learn.microsoft.com/en-us/nuget/reference/nuspec#developmentdependency).
 
 In order to simplify the packaging process (and meeting above mentioned requirements) a dotnet template will be provided producing proper package on pack action.
 
 **TBD** - dotnet new sample on initiating the development.
 
-## Acquisition of custom analyzers
+## Acquisition of custom checks
 
-Apart from [inbox analyzers](#inbox-analyzers) (shipped together with msbuild), users will be able to plug-in packaged analyzers shipped as nugets (this will serve for community contributions, but possibly as a venue for off-cycle distribution of official analyzers).
+Apart from [inbox checks](#inbox-checks) (shipped together with msbuild), users will be able to plug-in packaged checks shipped as nugets (this will serve for community contributions, but possibly as a venue for off-cycle distribution of official checks).
 
-In order to use an analyzer package users just need to reference them via `<PackageReference>` element as standard package reference. 
+In order to use an check package users just need to reference them via `<PackageReference>` element as standard package reference. 
 
 ```xml
-<PackageReference Include="Contoso.Analyzers" Version="1.2.3" />
+<PackageReference Include="Contoso.checks" Version="1.2.3" />
 ```
 
-Only projects referencing the package will be able to run its analyzers. Enabling the rules from package on other projects won’t take any effect.
+Only projects referencing the package will be able to run its checks. Enabling the rules from package on other projects won’t take any effect.
diff --git a/documentation/specs/BuildCheck/Codes.md b/documentation/specs/BuildCheck/Codes.md
index 6698d20a2dc..4ffcca8427c 100644
--- a/documentation/specs/BuildCheck/Codes.md
+++ b/documentation/specs/BuildCheck/Codes.md
@@ -14,7 +14,7 @@ To enable verbose logging in order to troubleshoot issue(s), enable [binary logg
 
 _Cmd:_
 ```cmd
-dotnet build -bl -analyze
+dotnet build -bl -check
 ```
 
 ## <a name="BC0101"></a>BC0101 - Shared output path.
diff --git a/documentation/specs/proposed/BuildCheck-acquisition-challenge.md b/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
index b92a45f36a4..cc19390f06a 100644
--- a/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
+++ b/documentation/specs/proposed/BuildCheck-acquisition-challenge.md
@@ -4,21 +4,21 @@ This is an internal engineering document. For general overview and user-oriented
 
 # Challenge
 
-Let's recall some details of BuildCheck analyzers acquisition. There might be two types of the build analyzer: build-in and custom. 
-The build-in analyzers are configured in the `.editorconfig` file. The custom analyzers are declared in the project files via PackageReference and also configured in the `.editorconfig` file.
-Project files are read during the first pass of the evaluation of the project. Given the multi-processing nature of MSBuild, this might happen either on main node or on the msbuild worker node. When the analyzer is encountered, the event `BuildCheckAcquisitionEventArgs` is logged with information concerning the analyzer that is needed to be loaded. This event is forwarded by `BuildCheckForwardingLogger` through logging system via the named pipes to the main msbuild node, where it is processed by `BuildCheckConnectorLogger`. This requires the logging system to be configured on main and worker msbuild nodes. 
+Let's recall some details of BuildCheck checks acquisition. There might be two types of the build check: build-in and custom. 
+The build-in checks are configured in the `.editorconfig` file. The custom checks are declared in the project files via PackageReference and also configured in the `.editorconfig` file.
+Project files are read during the first pass of the evaluation of the project. Given the multi-processing nature of MSBuild, this might happen either on main node or on the msbuild worker node. When the check is encountered, the event `BuildCheckAcquisitionEventArgs` is logged with information concerning the check that is needed to be loaded. This event is forwarded by `BuildCheckForwardingLogger` through logging system via the named pipes to the main msbuild node, where it is processed by `BuildCheckConnectorLogger`. This requires the logging system to be configured on main and worker msbuild nodes. 
 
-![analyzers-acquisition](analyzers-acquisition.png)
+![checks-acquisition](checks-acquisition.png)
 
 There are two issues that arise from such a design:
-1. The configuration of the logging system should be ideally dependent on the set of the applied build analyzers. Verbosity of the build hugely affects the set of logging events that are logged by default. Moreover, some events are not forwarded with forwarding loggers, depending on forwarding loggers configuration. This is done for performance reasons to allow to drop the events that are not consumed by any of the central loggers. We need to ensure that the events required for the analyzers to work pass through. For that we need to have information about active rules from the `.editorconfig` file and the declarations in the project files via PackageReference when setting up the logging system.
+1. The configuration of the logging system should be ideally dependent on the set of the applied build checks. Verbosity of the build hugely affects the set of logging events that are logged by default. Moreover, some events are not forwarded with forwarding loggers, depending on forwarding loggers configuration. This is done for performance reasons to allow to drop the events that are not consumed by any of the central loggers. We need to ensure that the events required for the checks to work pass through. For that we need to have information about active rules from the `.editorconfig` file and the declarations in the project files via PackageReference when setting up the logging system.
 2. There is no synchronization between build manager and logging service. When the build check acquisition events get to the main node, most of the build might have been already finished on worker nodes.
 
 # Solution ideas
 
-- When analyzers are used, always create and forward all the events. This will have a considerable impact on performance but makes configuring of the logging system easy.
-- Set up the logger configuration before the build starts on the worker nodes: the main node can read the `.editorconfig` file and set up the correct configuration. For custom analysers we cannot do that, as they could be downloaded during the restore and discovered during the evaluation. 
+- When checks are used, always create and forward all the events. This will have a considerable impact on performance but makes configuring of the logging system easy.
+- Set up the logger configuration before the build starts on the worker nodes: the main node can read the `.editorconfig` file and set up the correct configuration. For custom checks we cannot do that, as they could be downloaded during the restore and discovered during the evaluation. 
 - Change the initial confuguration of the logging system (in particular, forwardning loggers) during the build. 
-    - Do that as soon as we get the events `BuildCheckAcquisitionEventArgs` in forwarding logger: create a custom `BuildCheckForwardingLogger` that will re-configure itself when it gets `BuildCheckAcquisitionEventArgs`. This will need reading the editorconfig files and possibly loading custom analyzers in the worker node in order to find which events are needed for the custom analyzers. We will miss some of the events on the evaluation prior `BuildCheckAcquisitionEventArgs` event but since the events are processed in an order, the new filters in the forwarding logger will apply to the later events.
-    - Process the events `BuildCheckAcquisitionEventArgs` in the build check manager and send a message to the worker node to re-configure it. However due to the absence of syncronization between build manager and logging service, this message might get processed on the worker node late and we will miss a lot of events needed for the analyzers.  
+    - Do that as soon as we get the events `BuildCheckAcquisitionEventArgs` in forwarding logger: create a custom `BuildCheckForwardingLogger` that will re-configure itself when it gets `BuildCheckAcquisitionEventArgs`. This will need reading the editorconfig files and possibly loading custom checks in the worker node in order to find which events are needed for the custom checks. We will miss some of the events on the evaluation prior `BuildCheckAcquisitionEventArgs` event but since the events are processed in an order, the new filters in the forwarding logger will apply to the later events.
+    - Process the events `BuildCheckAcquisitionEventArgs` in the build check manager and send a message to the worker node to re-configure it. However due to the absence of syncronization between build manager and logging service, this message might get processed on the worker node late and we will miss a lot of events needed for the checks.  
 - As an addition the previous ideas, we may initialize the loggers from cache (either in-process cache or cache file in file system). We might have a strict mode which in case of cache miss invalidates and restarts a corresponding build.
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index cbc0a2d02c3..16adcc0eb2f 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -656,10 +656,10 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
 
         #endregion
 
-        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
         { /* Ignore the data */ }
 
-        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
         { /* Ignore the data */ }
     }
 }
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 98f98388834..52c61ccc9ab 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2934,7 +2934,7 @@ private ILoggingService CreateLoggingService(
                     verbosity: LoggerVerbosity.Quiet);
 
                 ILogger buildCheckLogger =
-                    new BuildCheckConnectorLogger(new AnalysisLoggingContextFactory(loggingService),
+                    new BuildCheckConnectorLogger(new CheckLoggingContextFactory(loggingService),
                         buildCheckManagerProvider.Instance);
 
                 ForwardingLoggerRecord[] forwardingLogger = { new ForwardingLoggerRecord(buildCheckLogger, forwardingLoggerDescription) };
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 9657019dc00..0ce71397288 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -840,7 +840,7 @@ public bool Question
         }
 
         /// <summary>
-        /// Gets or sets an indication of build analysis enablement.
+        /// Gets or sets an indication of build check enablement.
         /// </summary>
         public bool IsBuildCheckEnabled
         {
diff --git a/src/Build/BackEnd/Components/IBuildComponentHost.cs b/src/Build/BackEnd/Components/IBuildComponentHost.cs
index 7983229f5b2..a3fc16da831 100644
--- a/src/Build/BackEnd/Components/IBuildComponentHost.cs
+++ b/src/Build/BackEnd/Components/IBuildComponentHost.cs
@@ -144,7 +144,7 @@ internal enum BuildComponentType
         NodeLauncher,
 
         /// <summary>
-        /// The Build Analyzer Manager.
+        /// The Build Check Manager.
         /// </summary>
         BuildCheckManagerProvider,
     }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index e06b2a85864..6c871f7667c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -316,12 +316,12 @@ internal void LogIncludeFile(string filePath)
         public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo)
             => _loggingService.BuildEngineDataRouter.ProcessPropertyRead(
                     propertyReadInfo,
-                    new AnalysisLoggingContext(_loggingService, BuildEventContext));
+                    new CheckLoggingContext(_loggingService, BuildEventContext));
 
         public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo)
             => _loggingService.BuildEngineDataRouter.ProcessPropertyWrite(
                     propertyWriteInfo,
-                    new AnalysisLoggingContext(_loggingService, BuildEventContext));
+                    new CheckLoggingContext(_loggingService, BuildEventContext));
 
         private protected void CheckValidity()
         {
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index f547084425d..9a6df6ce995 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -1288,8 +1288,7 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
         {
             if (loggingPacket?.NodeBuildEvent != null && _componentHost != null)
             {
-                var projectStartedEventArgs = loggingPacket.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
-                if (projectStartedEventArgs != null && _configCache.Value != null)
+                if (loggingPacket.NodeBuildEvent.Value.Value is ProjectStartedEventArgs projectStartedEventArgs && _configCache.Value != null)
                 {
                     ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectStartedEventArgs.ProjectId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
                     BuildRequestConfiguration buildRequestConfiguration = _configCache.Value[projectStartedEventArgs.ProjectId];
@@ -1300,6 +1299,12 @@ internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
                     s_projectStartedEventArgsGlobalProperties.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.GlobalProperties.ToDictionary(), index: null);
 
                     s_projectStartedEventArgsToolsVersion.Value.SetValue(projectStartedEventArgs, buildRequestConfiguration.ToolsVersion, null);
+
+                    // When logging happens out of process, we need to map the project context id to the project file on the receiving side.
+                    if (!_projectFileMap.ContainsKey(projectStartedEventArgs.BuildEventContext.ProjectContextId))
+                    {
+                        _projectFileMap[projectStartedEventArgs.BuildEventContext.ProjectContextId] = projectStartedEventArgs.ProjectFile;
+                    }
                 }
             }
         }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index c7822f0c7aa..b118ca46d34 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -798,10 +798,10 @@ public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
 
         #endregion
 
-        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)
-            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyRead(propertyReadInfo, analysisContext);
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
+            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyRead(propertyReadInfo, checkContext);
 
-        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext analysisContext)
-            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyWrite(propertyWriteInfo, analysisContext);
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
+            => BuildCheckManagerProvider.GlobalBuildEngineDataRouter?.ProcessPropertyWrite(propertyWriteInfo, checkContext);
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index d792e0c2c05..9991bf07d1f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -1123,7 +1123,7 @@ private async Task<BuildResult> BuildProject()
                 {
                     buildCheckManager.StartProjectEvaluation(
                         BuildCheckDataSource.BuildExecution,
-                        new AnalysisLoggingContext(_nodeLoggingContext.LoggingService, _requestEntry.Request.BuildEventContext),
+                        new CheckLoggingContext(_nodeLoggingContext.LoggingService, _requestEntry.Request.BuildEventContext),
                         _requestEntry.RequestConfiguration.ProjectFullPath);
 
                     _requestEntry.RequestConfiguration.LoadProjectIntoConfiguration(
@@ -1226,7 +1226,7 @@ private async Task<BuildResult> BuildProject()
             {
                 buildCheckManager.EndProjectRequest(
                     BuildCheckDataSource.BuildExecution,
-                    new AnalysisLoggingContext(_nodeLoggingContext.LoggingService, _requestEntry.Request.BuildEventContext),
+                    new CheckLoggingContext(_nodeLoggingContext.LoggingService, _requestEntry.Request.BuildEventContext),
                     _requestEntry.RequestConfiguration.ProjectFullPath);
             }
 
diff --git a/src/Build/BuildCheck/API/BuildCheckResult.cs b/src/Build/BuildCheck/API/BuildCheckResult.cs
index 299d855123a..1ff0e46715e 100644
--- a/src/Build/BuildCheck/API/BuildCheckResult.cs
+++ b/src/Build/BuildCheck/API/BuildCheckResult.cs
@@ -9,35 +9,35 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Representation of a single report of a single finding from a BuildAnalyzer
+/// Representation of a single report of a single finding from a Check
 /// Each rule has upfront known message format - so only the concrete arguments are added
 /// Optionally a location is attached - in the near future we might need to support multiple locations
 ///  (for 2 cases - a) grouped result for multiple occurrences; b) a single report for a finding resulting from combination of multiple locations)
 /// </summary>
 public sealed class BuildCheckResult : IBuildCheckResult
 {
-    public static BuildCheckResult Create(BuildAnalyzerRule rule, ElementLocation location, params string[] messageArgs)
+    public static BuildCheckResult Create(CheckRule rule, ElementLocation location, params string[] messageArgs)
     {
         return new BuildCheckResult(rule, location, messageArgs);
     }
 
-    public BuildCheckResult(BuildAnalyzerRule buildAnalyzerRule, ElementLocation location, string[] messageArgs)
+    public BuildCheckResult(CheckRule checkConfig, ElementLocation location, string[] messageArgs)
     {
-        BuildAnalyzerRule = buildAnalyzerRule;
+        CheckRule = checkConfig;
         Location = location;
         MessageArgs = messageArgs;
     }
 
-    internal BuildEventArgs ToEventArgs(BuildAnalyzerResultSeverity severity)
+    internal BuildEventArgs ToEventArgs(CheckResultSeverity severity)
         => severity switch
         {
-            BuildAnalyzerResultSeverity.Suggestion => new BuildCheckResultMessage(this),
-            BuildAnalyzerResultSeverity.Warning => new BuildCheckResultWarning(this, BuildAnalyzerRule.Id),
-            BuildAnalyzerResultSeverity.Error => new BuildCheckResultError(this, BuildAnalyzerRule.Id),
+            CheckResultSeverity.Suggestion => new BuildCheckResultMessage(this),
+            CheckResultSeverity.Warning => new BuildCheckResultWarning(this, CheckRule.Id),
+            CheckResultSeverity.Error => new BuildCheckResultError(this, CheckRule.Id),
             _ => throw new ArgumentOutOfRangeException(nameof(severity), severity, null),
         };
 
-    public BuildAnalyzerRule BuildAnalyzerRule { get; }
+    public CheckRule CheckRule { get; }
 
     /// <summary>
     /// Optional location of the finding (in near future we might need to support multiple locations).
@@ -47,12 +47,11 @@ internal BuildEventArgs ToEventArgs(BuildAnalyzerResultSeverity severity)
     public string LocationString => Location.LocationString;
 
     public string[] MessageArgs { get; }
-
-    public string MessageFormat => BuildAnalyzerRule.MessageFormat;
+    public string MessageFormat => CheckRule.MessageFormat;
 
     // Here we will provide different link for built-in rules and custom rules - once we have the base classes differentiated.
     public string FormatMessage() =>
-        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}https://aka.ms/buildcheck/codes#{BuildAnalyzerRule.Id} - {string.Format(BuildAnalyzerRule.MessageFormat, MessageArgs)}";
+        _message ??= $"{(Equals(Location ?? ElementLocation.EmptyLocation, ElementLocation.EmptyLocation) ? string.Empty : (Location!.LocationString + ": "))}https://aka.ms/buildcheck/codes#{CheckRule.Id} - {string.Format(CheckRule.MessageFormat, MessageArgs)}";
 
     private string? _message;
 }
diff --git a/src/Build/BuildCheck/API/BuildAnalyzer.cs b/src/Build/BuildCheck/API/Check.cs
similarity index 70%
rename from src/Build/BuildCheck/API/BuildAnalyzer.cs
rename to src/Build/BuildCheck/API/Check.cs
index 0c6ed5a0752..4eeeb8599f1 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzer.cs
+++ b/src/Build/BuildCheck/API/Check.cs
@@ -9,29 +9,29 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Base class for build analyzers.
-/// Same base will be used for custom and built-in analyzers.
-/// <see cref="BuildAnalyzer"/> is a unit of build analysis execution, but it can contain multiple rules - each representing a distinct violation.
+/// Base class for build checks.
+/// Same base will be used for custom and built-in checks.
+/// <see cref="Check"/> is a unit of build checks execution, but it can contain multiple rules - each representing a distinct violation.
 /// </summary>
-public abstract class BuildAnalyzer : IDisposable
+public abstract class Check : IDisposable
 {
     /// <summary>
-    /// Friendly name of the analyzer.
+    /// Friendly name of the check.
     /// Should be unique - as it will be used in the tracing stats, infrastructure error messages, etc.
     /// </summary>
     public abstract string FriendlyName { get; }
 
     /// <summary>
-    /// Single or multiple rules supported by the analyzer.
+    /// Single or multiple rules supported by the check.
     /// </summary>
-    public abstract IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; }
+    public abstract IReadOnlyList<CheckRule> SupportedRules { get; }
 
     /// <summary>
-    /// Optional initialization of the analyzer.
+    /// Optional initialization of the check.
     /// </summary>
     /// <param name="configurationContext">
     /// Custom data (not recognized by the infrastructure) passed from .editorconfig
-    /// Currently the custom data has to be identical for all rules in the analyzer and all projects.
+    /// Currently the custom data has to be identical for all rules in the check and all projects.
     /// </param>
     public abstract void Initialize(ConfigurationContext configurationContext);
 
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs b/src/Build/BuildCheck/API/CheckConfiguration.cs
similarity index 56%
rename from src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
rename to src/Build/BuildCheck/API/CheckConfiguration.cs
index 8ff336ca295..9c4ac89749f 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerConfiguration.cs
+++ b/src/Build/BuildCheck/API/CheckConfiguration.cs
@@ -9,51 +9,51 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Configuration for a build analyzer.
-/// Default values can be specified by the Analyzer in code.
+/// Configuration for a build check.
+/// Default values can be specified by the Check in code.
 /// Users can overwrite the defaults by explicit settings in the .editorconfig file.
 /// Each rule can have its own configuration, which can differ per each project.
-/// The <see cref="EvaluationAnalysisScope"/> setting must be same for all rules in the same analyzer (but can differ between projects)
+/// The <see cref="EvaluationCheckScope"/> setting must be same for all rules in the same check (but can differ between projects)
 /// </summary>
-public class BuildAnalyzerConfiguration
+public class CheckConfiguration
 {
     // Defaults to be used if any configuration property is not specified neither as default
     //  nor in the editorconfig configuration file.
-    public static BuildAnalyzerConfiguration Default { get; } = new()
+    public static CheckConfiguration Default { get; } = new()
     {
-        EvaluationAnalysisScope = BuildCheck.EvaluationAnalysisScope.ProjectFileOnly,
-        Severity = BuildAnalyzerResultSeverity.None
+        EvaluationCheckScope = BuildCheck.EvaluationCheckScope.ProjectFileOnly,
+        Severity = CheckResultSeverity.None
     };
 
-    public static BuildAnalyzerConfiguration Null { get; } = new();
+    public static CheckConfiguration Null { get; } = new();
 
     public string? RuleId { get; internal set; }
 
     /// <summary>
     /// This applies only to specific events, that can distinguish whether they are directly inferred from
-    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from analysis.
+    ///  the current project, or from some import. If supported it can help tuning the level of detail or noise from check.
     ///
     /// If not supported by the data source - then the setting is ignored
     /// </summary>
-    public EvaluationAnalysisScope? EvaluationAnalysisScope { get; internal init; }
+    public EvaluationCheckScope? EvaluationCheckScope { get; internal init; }
 
     /// <summary>
     /// The severity of the result for the rule.
     /// </summary>
-    public BuildAnalyzerResultSeverity? Severity { get; internal init; }
+    public CheckResultSeverity? Severity { get; internal init; }
 
     /// <summary>
-    /// Whether the analyzer rule is enabled.
-    /// If all rules within the analyzer are not enabled, it will not be run.
-    /// If some rules are enabled and some are not, the analyzer will be run and reports will be post-filtered.
+    /// Whether the check rule is enabled.
+    /// If all rules within the check are not enabled, it will not be run.
+    /// If some rules are enabled and some are not, the check will be run and reports will be post-filtered.
     /// </summary>
     public bool? IsEnabled {
         get
         {
-            // Do not consider Default as enabled, because the default severity of the rule coule be set to None
-            if (Severity.HasValue && Severity.Value != BuildAnalyzerResultSeverity.Default)
+            // Do not consider Default as enabled, because the default severity of the rule could be set to None
+            if (Severity.HasValue && Severity.Value != CheckResultSeverity.Default)
             {
-                return !Severity.Value.Equals(BuildAnalyzerResultSeverity.None);
+                return !Severity.Value.Equals(CheckResultSeverity.None);
             }
 
             return null;
@@ -61,20 +61,20 @@ public bool? IsEnabled {
     }
 
     /// <summary>
-    /// Creates a <see cref="BuildAnalyzerConfiguration"/> object based on the provided configuration dictionary.
-    /// If the BuildAnalyzerConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
+    /// Creates a <see cref="CheckConfiguration"/> object based on the provided configuration dictionary.
+    /// If the BuildCheckConfiguration's property name presented in the dictionary, the value of this key-value pair is parsed and assigned to the instance's field.
     /// If parsing failed the value will be equal to null.
     /// </summary>
-    /// <param name="configDictionary">The configuration dictionary containing the settings for the build analyzer. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
-    /// <returns>A new instance of <see cref="BuildAnalyzerConfiguration"/> with the specified settings.</returns>
-    internal static BuildAnalyzerConfiguration Create(Dictionary<string, string>? configDictionary) => new()
+    /// <param name="configDictionary">The configuration dictionary containing the settings for the build check. The configuration's keys are expected to be in lower case or the EqualityComparer to ignore case.</param>
+    /// <returns>A new instance of <see cref="CheckConfiguration"/> with the specified settings.</returns>
+    internal static CheckConfiguration Create(Dictionary<string, string>? configDictionary) => new()
     {
-        EvaluationAnalysisScope = TryExtractEvaluationAnalysisScope(configDictionary),
+        EvaluationCheckScope = TryExtractEvaluationCheckScope(configDictionary),
         Severity = TryExtractSeverity(configDictionary),
     };
 
 
-    private static EvaluationAnalysisScope? TryExtractEvaluationAnalysisScope(Dictionary<string, string>? config)
+    private static EvaluationCheckScope? TryExtractEvaluationCheckScope(Dictionary<string, string>? config)
     {
 
         if (!TryExtractValue(BuildCheckConstants.scopeConfigurationKey, config, out string? stringValue) || stringValue is null)
@@ -86,11 +86,11 @@ public bool? IsEnabled {
         {
             case "projectfile":
             case "project_file":
-                return BuildCheck.EvaluationAnalysisScope.ProjectFileOnly;
+                return BuildCheck.EvaluationCheckScope.ProjectFileOnly;
             case "work_tree_imports":
-                return BuildCheck.EvaluationAnalysisScope.WorkTreeImports;
+                return BuildCheck.EvaluationCheckScope.WorkTreeImports;
             case "all":
-                return BuildCheck.EvaluationAnalysisScope.All;
+                return BuildCheck.EvaluationCheckScope.All;
             default:
                 ThrowIncorrectValueException(BuildCheckConstants.scopeConfigurationKey, stringValue);
                 break;
@@ -99,7 +99,7 @@ public bool? IsEnabled {
         return null;
     }
 
-    private static BuildAnalyzerResultSeverity? TryExtractSeverity(Dictionary<string, string>? config)
+    private static CheckResultSeverity? TryExtractSeverity(Dictionary<string, string>? config)
     {
         if (!TryExtractValue(BuildCheckConstants.severityConfigurationKey, config, out string? stringValue) || stringValue is null)
         {
@@ -109,15 +109,15 @@ public bool? IsEnabled {
         switch (stringValue)
         {
             case "none":
-                return BuildAnalyzerResultSeverity.None;
+                return CheckResultSeverity.None;
             case "default":
-                return BuildAnalyzerResultSeverity.Default;
+                return CheckResultSeverity.Default;
             case "suggestion":
-                return BuildAnalyzerResultSeverity.Suggestion;
+                return CheckResultSeverity.Suggestion;
             case "warning":
-                return BuildAnalyzerResultSeverity.Warning;
+                return CheckResultSeverity.Warning;
             case "error":
-                return BuildAnalyzerResultSeverity.Error;
+                return CheckResultSeverity.Error;
             default:
                 ThrowIncorrectValueException(BuildCheckConstants.severityConfigurationKey, stringValue);
                 break;
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs b/src/Build/BuildCheck/API/CheckResultSeverity.cs
similarity index 95%
rename from src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
rename to src/Build/BuildCheck/API/CheckResultSeverity.cs
index cd98bdbbf22..dc26b9d4532 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerResultSeverity.cs
+++ b/src/Build/BuildCheck/API/CheckResultSeverity.cs
@@ -6,7 +6,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// The severity of reported result (or preconfigured or user configured severity for a rule).
 /// </summary>
-public enum BuildAnalyzerResultSeverity
+public enum CheckResultSeverity
 {
     /// <summary>
     /// When set, the default value of the BuildCheck rule will be used.
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs b/src/Build/BuildCheck/API/CheckRule.cs
similarity index 78%
rename from src/Build/BuildCheck/API/BuildAnalyzerRule.cs
rename to src/Build/BuildCheck/API/CheckRule.cs
index 9061d9fd36d..3fdf97bbc44 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
+++ b/src/Build/BuildCheck/API/CheckRule.cs
@@ -4,18 +4,18 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Represents a rule that is a unit of build analysis.
-/// <see cref="BuildAnalyzer"/> is a unit of executing the analysis, but it can be discovering multiple distinct violation types,
-///  for this reason a single <see cref="BuildAnalyzer"/> can expose multiple <see cref="BuildAnalyzerRule"/>s.
+/// Represents a rule that is a unit of a build check.
+/// <see cref="Check"/> is a unit of executing the check, but it can be discovering multiple distinct violation types,
+///  for this reason a single <see cref="Check"/> can expose multiple <see cref="CheckRule"/>s.
 /// </summary>
-public class BuildAnalyzerRule
+public class CheckRule
 {
-    public BuildAnalyzerRule(
+    public CheckRule(
         string id,
         string title,
         string description,
         string messageFormat,
-        BuildAnalyzerConfiguration defaultConfiguration)
+        CheckConfiguration defaultConfiguration)
     {
         Id = id;
         Title = title;
@@ -55,5 +55,5 @@ public BuildAnalyzerRule(
     /// The default configuration - overridable by the user via .editorconfig.
     /// If no user specified configuration is provided, this default will be used.
     /// </summary>
-    public BuildAnalyzerConfiguration DefaultConfiguration { get; }
+    public CheckConfiguration DefaultConfiguration { get; }
 }
diff --git a/src/Build/BuildCheck/API/ConfigurationContext.cs b/src/Build/BuildCheck/API/ConfigurationContext.cs
index 8f06a14717e..86a52ae1a11 100644
--- a/src/Build/BuildCheck/API/ConfigurationContext.cs
+++ b/src/Build/BuildCheck/API/ConfigurationContext.cs
@@ -13,15 +13,15 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// </summary>
 public class ConfigurationContext
 {
-    private ConfigurationContext(CustomConfigurationData[] customConfigurationData, BuildAnalyzerConfigurationEffective[] buildAnalyzerConfig)
+    private ConfigurationContext(CustomConfigurationData[] customConfigurationData, CheckConfigurationEffective[] checkConfig)
     {
         CustomConfigurationData = customConfigurationData;
-        BuildAnalyzerConfig = buildAnalyzerConfig;
+        CheckConfig = checkConfig;
     }
 
-    internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData, BuildAnalyzerConfigurationEffective[] buildAnalyzerConfig)
+    internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData[] customConfigurationData, CheckConfigurationEffective[] checkConfig)
     {
-        return new ConfigurationContext(customConfigurationData, buildAnalyzerConfig);
+        return new ConfigurationContext(customConfigurationData, checkConfig);
     }
 
     /// <summary>
@@ -32,5 +32,5 @@ internal static ConfigurationContext FromDataEnumeration(CustomConfigurationData
     /// <summary>
     /// Infrastructure configuration data
     /// </summary>
-    public IReadOnlyList<BuildAnalyzerConfigurationEffective> BuildAnalyzerConfig { get; init; }
+    public IReadOnlyList<CheckConfigurationEffective> CheckConfig { get; init; }
 }
diff --git a/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs b/src/Build/BuildCheck/API/EvaluationCheckScope.cs
similarity index 57%
rename from src/Build/BuildCheck/API/EvaluationAnalysisScope.cs
rename to src/Build/BuildCheck/API/EvaluationCheckScope.cs
index 5068f3b1282..08aecf49c80 100644
--- a/src/Build/BuildCheck/API/EvaluationAnalysisScope.cs
+++ b/src/Build/BuildCheck/API/EvaluationCheckScope.cs
@@ -5,25 +5,25 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
 /// For datasource events that can differentiate from where exactly they originate - e.g.
-///  For a condition string or AST - was that directly in hte analyzed project or imported?
+///  For a condition string or AST - was that directly in the checked project or imported?
 ///
 /// Ignored by infrastructure if the current datasource doesn't support this level of setting.
 /// </summary>
-public enum EvaluationAnalysisScope
+public enum EvaluationCheckScope
 {
     /// <summary>
-    /// Only the data from currently analyzed project will be sent to the analyzer. Imports will be discarded.
+    /// Only the data from currently checked project will be sent to the check. Imports will be discarded.
     /// </summary>
     ProjectFileOnly,
 
     /// <summary>
-    /// Only the data from currently analyzed project and imports from files not recognized to be in nuget cache or SDK install folder will be sent to the analyzer. Other imports will be discarded.
+    /// Only the data from currently checked project and imports from files not recognized to be in nuget cache or SDK install folder will be sent to the check. Other imports will be discarded.
     /// The generated nuget.g.props, nuget.g.targets will be ignored as well.
     /// </summary>
     WorkTreeImports,
 
     /// <summary>
-    /// All data will be sent to the analyzer.
+    /// All data will be sent to the check.
     /// </summary>
     All,
 }
diff --git a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
index b34ab8f726b..1bd6c390892 100644
--- a/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
+++ b/src/Build/BuildCheck/API/IBuildCheckRegistrationContext.cs
@@ -7,9 +7,9 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 
 public interface IBuildCheckRegistrationContext
 {
-    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction);
+    void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction);
 
-    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction);
+    void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction);
 
-    void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction);
+    void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction);
 }
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index b4d0b19581b..b0899f22134 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -21,36 +21,36 @@ internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
 #endif
 
     /// <summary>
-    /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
+    /// Creates a list of factory delegates for building check rules instances from a given assembly path.
     /// </summary>
-    public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(
-        AnalyzerAcquisitionData analyzerAcquisitionData,
-        IAnalysisContext analysisContext)
+    public List<CheckFactory> CreateCheckFactories(
+        CheckAcquisitionData checkAcquisitionData,
+        ICheckContext checkContext)
     {
-        var analyzersFactories = new List<BuildAnalyzerFactory>();
+        var checksFactories = new List<CheckFactory>();
 
         try
         {
             Assembly? assembly = null;
 #if FEATURE_ASSEMBLYLOADCONTEXT
-            assembly = s_coreClrAssemblyLoader.LoadFromPath(analyzerAcquisitionData.AssemblyPath);
+            assembly = s_coreClrAssemblyLoader.LoadFromPath(checkAcquisitionData.AssemblyPath);
 #else
-            assembly = Assembly.LoadFrom(analyzerAcquisitionData.AssemblyPath);
+            assembly = Assembly.LoadFrom(checkAcquisitionData.AssemblyPath);
 #endif
 
             IList<Type> availableTypes = assembly.GetExportedTypes();
-            IList<Type> analyzerTypes = availableTypes.Where(t => typeof(BuildAnalyzer).IsAssignableFrom(t)).ToArray();
+            IList<Type> checkTypes = availableTypes.Where(t => typeof(Check).IsAssignableFrom(t)).ToArray();
 
-            foreach (Type analyzerCandidate in analyzerTypes)
+            foreach (Type checkCandidate in checkTypes)
             {
-                analyzersFactories.Add(() => (BuildAnalyzer)Activator.CreateInstance(analyzerCandidate)!);
-                analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerRegistered", analyzerCandidate.Name, analyzerCandidate.Assembly);
+                checksFactories.Add(() => (Check)Activator.CreateInstance(checkCandidate)!);
+                checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckRegistered", checkCandidate.Name, checkCandidate.Assembly);
             }
 
-            if (availableTypes.Count != analyzerTypes.Count)
+            if (availableTypes.Count != checkTypes.Count)
             {
-                availableTypes.Except(analyzerTypes).ToList()
-                    .ForEach(t => analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerBaseTypeNotAssignable", t.Name, t.Assembly));
+                availableTypes.Except(checkTypes).ToList()
+                    .ForEach(t => checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckBaseTypeNotAssignable", t.Name, t.Assembly));
             }
         }
         catch (ReflectionTypeLoadException ex)
@@ -59,15 +59,15 @@ public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(
             {
                 foreach (Exception? loaderException in ex.LoaderExceptions)
                 {
-                    analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerFailedRuleLoading", loaderException?.Message);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", loaderException?.Message);
                 }
             }
         }
         catch (Exception ex)
         {
-            analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerFailedRuleLoading", ex?.Message);
+            checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedRuleLoading", ex?.Message);
         }
 
-        return analyzersFactories;
+        return checksFactories;
     }
 }
diff --git a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs b/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
similarity index 69%
rename from src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
rename to src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
index 19998b75266..74a0c87be38 100644
--- a/src/Build/BuildCheck/Acquisition/AnalyzerAcquisitionData.cs
+++ b/src/Build/BuildCheck/Acquisition/CheckAcquisitionData.cs
@@ -13,17 +13,17 @@ namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 // https://github.com/dotnet/msbuild/issues/9633
 // Acquisition
 //  define the data that will be passed to the acquisition module (and remoted if needed)
-internal class AnalyzerAcquisitionData(string assemblyPath, string projectPath)
+internal class CheckAcquisitionData(string assemblyPath, string projectPath)
 {
     public string AssemblyPath { get; init; } = assemblyPath;
 
     public string ProjectPath { get; init; } = projectPath;
 }
 
-internal static class AnalyzerAcquisitionDataExtensions
+internal static class CheckAcquisitionDataExtensions
 {
-    public static AnalyzerAcquisitionData ToAnalyzerAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
+    public static CheckAcquisitionData ToCheckAcquisitionData(this BuildCheckAcquisitionEventArgs eventArgs) =>
         new(eventArgs.AcquisitionPath, eventArgs.ProjectPath);
 
-    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this AnalyzerAcquisitionData data) => new(data.AssemblyPath, data.ProjectPath);
+    public static BuildCheckAcquisitionEventArgs ToBuildEventArgs(this CheckAcquisitionData data) => new(data.AssemblyPath, data.ProjectPath);
 }
diff --git a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
index 20259725b4f..245736ca67a 100644
--- a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
@@ -10,7 +10,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Acquisition;
 internal interface IBuildCheckAcquisitionModule
 {
     /// <summary>
-    /// Creates a list of factory delegates for building analyzer rules instances from a given assembly path.
+    /// Creates a list of factory delegates for building check rules instances from a given assembly path.
     /// </summary>
-    List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, IAnalysisContext analysisContext);
+    List<CheckFactory> CreateCheckFactories(CheckAcquisitionData checkAcquisitionData, ICheckContext checkContext);
 }
diff --git a/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
similarity index 73%
rename from src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs
rename to src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
index 0804d6d76c3..df2cbd61145 100644
--- a/src/Build/BuildCheck/Analyzers/DoubleWritesAnalyzer.cs
+++ b/src/Build/BuildCheck/Checks/DoubleWritesCheck.cs
@@ -10,26 +10,26 @@
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
-using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData;
+using static Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData;
 
 #if FEATURE_MSIOREDIST
 using Path = Microsoft.IO.Path;
 #endif
 
-namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
-internal sealed class DoubleWritesAnalyzer : BuildAnalyzer
+internal sealed class DoubleWritesCheck : Check
 {
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+    public static CheckRule SupportedRule = new CheckRule(
         "BC0102",
         "DoubleWrites",
         "Two tasks should not write the same file",
         "Tasks {0} and {1} from projects {2} and {3} write the same file: {4}.",
-        new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning });
+        new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
 
-    public override string FriendlyName => "MSBuild.DoubleWritesAnalyzer";
+    public override string FriendlyName => "MSBuild.DoubleWritesCheck";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
@@ -46,39 +46,39 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
     /// </summary>
     private readonly Dictionary<string, (string projectFilePath, string taskName)> _filesWritten = new(StringComparer.CurrentCultureIgnoreCase);
 
-    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
-        // This analyzer uses a hard-coded list of tasks known to write files.
+        // This check uses a hard-coded list of tasks known to write files.
         switch (context.Data.TaskName)
         {
             case "Csc":
             case "Vbc":
-            case "Fsc": AnalyzeCompilerTask(context); break;
-            case "Copy": AnalyzeCopyTask(context); break;
+            case "Fsc": CheckCompilerTask(context); break;
+            case "Copy": CheckCopyTask(context); break;
         }
     }
 
-    private void AnalyzeCompilerTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void CheckCompilerTask(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
         var taskParameters = context.Data.Parameters;
 
         // Compiler tasks have several parameters representing files being written.
-        AnalyzeParameter("OutputAssembly");
-        AnalyzeParameter("OutputRefAssembly");
-        AnalyzeParameter("DocumentationFile");
-        AnalyzeParameter("PdbFile");
+        CheckParameter("OutputAssembly");
+        CheckParameter("OutputRefAssembly");
+        CheckParameter("DocumentationFile");
+        CheckParameter("PdbFile");
 
-        void AnalyzeParameter(string parameterName)
+        void CheckParameter(string parameterName)
         {
             if (taskParameters.TryGetValue(parameterName, out TaskParameter? taskParameter))
             {
                 string outputPath = taskParameter.EnumerateStringValues().FirstOrDefault() ?? "";
-                AnalyzeWrite(context, outputPath);
+                CheckWrite(context, outputPath);
             }
         }
     }
 
-    private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+    private void CheckCopyTask(BuildCheckDataContext<TaskInvocationCheckData> context)
     {
         var taskParameters = context.Data.Parameters;
 
@@ -89,19 +89,19 @@ private void AnalyzeCopyTask(BuildCheckDataContext<TaskInvocationAnalysisData> c
             string destinationFolderPath = destinationFolder.EnumerateStringValues().FirstOrDefault() ?? "";
             foreach (string sourceFilePath in sourceFiles.EnumerateStringValues())
             {
-                AnalyzeWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));
+                CheckWrite(context, Path.Combine(destinationFolderPath, Path.GetFileName(sourceFilePath)));
             }
         }
         else if (taskParameters.TryGetValue("DestinationFiles", out TaskParameter? destinationFiles))
         {
             foreach (string destinationFilePath in destinationFiles.EnumerateStringValues())
             {
-                AnalyzeWrite(context, destinationFilePath);
+                CheckWrite(context, destinationFilePath);
             }
         }
     }
 
-    private void AnalyzeWrite(BuildCheckDataContext<TaskInvocationAnalysisData> context, string fileBeingWritten)
+    private void CheckWrite(BuildCheckDataContext<TaskInvocationCheckData> context, string fileBeingWritten)
     {
         if (!string.IsNullOrEmpty(fileBeingWritten))
         {
diff --git a/src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
similarity index 90%
rename from src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs
rename to src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
index 4ed9a974538..a9251e8d07d 100644
--- a/src/Build/BuildCheck/Analyzers/NoEnvironmentVariablePropertyAnalyzer.cs
+++ b/src/Build/BuildCheck/Checks/NoEnvironmentVariablePropertyCheck.cs
@@ -6,16 +6,16 @@
 using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Construction;
 
-namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
-internal sealed class NoEnvironmentVariablePropertyAnalyzer : BuildAnalyzer
+internal sealed class NoEnvironmentVariablePropertyCheck : Check
 {
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+    public static CheckRule SupportedRule = new CheckRule(
                 "BC0103",
-                "NoEnvironmentVariablePropertyAnalyzer",
+                "NoEnvironmentVariablePropertyCheck",
                 "No implicit property derived from an environment variable should be used during the build",
                 "Property is derived from environment variable: {0}. Properties should be passed explicitly using the /p option.",
-                new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Suggestion });
+                new CheckConfiguration() { Severity = CheckResultSeverity.Suggestion });
 
     private const string RuleId = "BC0103";
 
@@ -29,9 +29,9 @@ internal sealed class NoEnvironmentVariablePropertyAnalyzer : BuildAnalyzer
     private bool _isVerboseEnvVarOutput;
     private EvaluationAnalysisScope _scope;
 
-    public override string FriendlyName => "MSBuild.NoEnvironmentVariablePropertyAnalyzer";
+    public override string FriendlyName => "MSBuild.NoEnvironmentVariablePropertyCheck";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
@@ -45,7 +45,7 @@ public override void Initialize(ConfigurationContext configurationContext)
 
     public override void RegisterActions(IBuildCheckRegistrationContext registrationContext) => registrationContext.RegisterEvaluatedPropertiesAction(ProcessEnvironmentVariableReadAction);
 
-    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    private void ProcessEnvironmentVariableReadAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
     {
         if (context.Data.EvaluatedEnvironmentVariables.Count != 0)
         {
diff --git a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
similarity index 85%
rename from src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
rename to src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
index 4bcb8b1672d..1ec84093e3a 100644
--- a/src/Build/BuildCheck/Analyzers/SharedOutputPathAnalyzer.cs
+++ b/src/Build/BuildCheck/Checks/SharedOutputPathCheck.cs
@@ -11,19 +11,19 @@
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.Experimental.BuildCheck.Analyzers;
+namespace Microsoft.Build.Experimental.BuildCheck.Checks;
 
-internal sealed class SharedOutputPathAnalyzer : BuildAnalyzer
+internal sealed class SharedOutputPathCheck : Check
 {
     private const string RuleId = "BC0101";
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(RuleId, "ConflictingOutputPath",
+    public static CheckRule SupportedRule = new CheckRule(RuleId, "ConflictingOutputPath",
         "Two projects should not share their OutputPath nor IntermediateOutputPath locations",
         "Projects {0} and {1} have conflicting output paths: {2}.",
-        new BuildAnalyzerConfiguration() { RuleId = RuleId, Severity = BuildAnalyzerResultSeverity.Warning });
+        new CheckConfiguration() { RuleId = RuleId, Severity = CheckResultSeverity.Warning });
 
-    public override string FriendlyName => "MSBuild.SharedOutputPathAnalyzer";
+    public override string FriendlyName => "MSBuild.SharedOutputPathCheck";
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
@@ -38,7 +38,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
     private readonly Dictionary<string, string> _projectsPerOutputPath = new(StringComparer.CurrentCultureIgnoreCase);
     private readonly HashSet<string> _projects = new(StringComparer.CurrentCultureIgnoreCase);
 
-    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
     {
         if (!_projects.Add(context.Data.ProjectFilePath))
         {
@@ -62,7 +62,7 @@ private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedProperties
         }
     }
 
-    private string? CheckAndAddFullOutputPath(string? path, BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    private string? CheckAndAddFullOutputPath(string? path, BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
     {
         if (string.IsNullOrEmpty(path))
         {
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationEffective.cs b/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationEffective.cs
deleted file mode 100644
index 2b7bbf16ebc..00000000000
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerConfigurationEffective.cs
+++ /dev/null
@@ -1,41 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System;
-using Microsoft.Build.Experimental.BuildCheck;
-
-namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-
-/// <summary>
-/// Counterpart type for BuildAnalyzerConfiguration - with all properties non-nullable
-/// </summary>
-public sealed class BuildAnalyzerConfigurationEffective
-{
-    public BuildAnalyzerConfigurationEffective(string ruleId, EvaluationAnalysisScope evaluationAnalysisScope, BuildAnalyzerResultSeverity severity)
-    {
-        if (severity == BuildAnalyzerResultSeverity.Default)
-        {
-            throw new ArgumentOutOfRangeException(nameof(severity), severity, "Severity 'Default' is not recognized by the BuildCheck reports infrastructure");
-        }
-
-        RuleId = ruleId;
-        EvaluationAnalysisScope = evaluationAnalysisScope;
-        Severity = severity;
-    }
-
-    public string RuleId { get; }
-
-    public EvaluationAnalysisScope EvaluationAnalysisScope { get; }
-
-    public BuildAnalyzerResultSeverity Severity { get; }
-
-    public bool IsEnabled => Severity >= BuildAnalyzerResultSeverity.Suggestion;
-
-    // Intentionally not checking the RuleId
-    //  as for analyzers with multiple rules, we can squash config to a single one,
-    //  if the ruleId is the only thing differing.
-    public bool IsSameConfigurationAs(BuildAnalyzerConfigurationEffective? other) =>
-        other != null &&
-        Severity == other.Severity &&
-        EvaluationAnalysisScope == other.EvaluationAnalysisScope;
-}
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
index 2b6b94aa2d5..bfd311d03dc 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckBuildEventHandler.cs
@@ -16,16 +16,16 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 internal class BuildCheckBuildEventHandler
 {
     private readonly IBuildCheckManager _buildCheckManager;
-    private readonly IAnalysisContextFactory _analyzerContextFactory;
+    private readonly ICheckContextFactory _checkContextFactory;
 
     private readonly Dictionary<Type, Action<BuildEventArgs>> _eventHandlers;
 
     internal BuildCheckBuildEventHandler(
-        IAnalysisContextFactory analyzerContextFactory,
+        ICheckContextFactory checkContextFactory,
         IBuildCheckManager buildCheckManager)
     {
         _buildCheckManager = buildCheckManager;
-        _analyzerContextFactory = analyzerContextFactory;
+        _checkContextFactory = checkContextFactory;
 
         _eventHandlers = new()
         {
@@ -56,7 +56,7 @@ private void HandleProjectEvaluationFinishedEvent(ProjectEvaluationFinishedEvent
         if (!IsMetaProjFile(eventArgs.ProjectFile))
         {
             _buildCheckManager.ProcessEvaluationFinishedEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
             _buildCheckManager.EndProjectEvaluation(BuildCheckDataSource.EventArgs, eventArgs.BuildEventContext!);
@@ -69,7 +69,7 @@ private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventAr
         {
             _buildCheckManager.StartProjectEvaluation(
                 BuildCheckDataSource.EventArgs,
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs.ProjectFile!);
         }
     }
@@ -77,7 +77,7 @@ private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventAr
     private void HandleProjectFinishedRequest(ProjectFinishedEventArgs eventArgs)
         => _buildCheckManager.EndProjectRequest(
                 BuildCheckDataSource.EventArgs,
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs!.ProjectFile!);
 
     private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
@@ -90,27 +90,27 @@ private void HandleBuildCheckTracingEvent(BuildCheckTracingEventArgs eventArgs)
 
     private void HandleTaskStartedEvent(TaskStartedEventArgs eventArgs)
         => _buildCheckManager.ProcessTaskStartedEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
     private void HandleTaskFinishedEvent(TaskFinishedEventArgs eventArgs)
         => _buildCheckManager.ProcessTaskFinishedEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
     private void HandleTaskParameterEvent(TaskParameterEventArgs eventArgs)
         => _buildCheckManager.ProcessTaskParameterEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(eventArgs.BuildEventContext!),
+                _checkContextFactory.CreateCheckContext(eventArgs.BuildEventContext!),
                 eventArgs);
 
     private void HandleBuildCheckAcquisitionEvent(BuildCheckAcquisitionEventArgs eventArgs)
-        => _buildCheckManager.ProcessAnalyzerAcquisition(
-                eventArgs.ToAnalyzerAcquisitionData(),
-                _analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)));
+        => _buildCheckManager.ProcessCheckAcquisition(
+                eventArgs.ToCheckAcquisitionData(),
+                _checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)));
 
     private void HandleEnvironmentVariableReadEvent(EnvironmentVariableReadEventArgs eventArgs)
         => _buildCheckManager.ProcessEnvironmentVariableReadEventArgs(
-                _analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)),
+                _checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)),
                 eventArgs);
 
     private bool IsMetaProjFile(string? projectFile) => projectFile?.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase) == true;
@@ -119,15 +119,15 @@ private void HandleEnvironmentVariableReadEvent(EnvironmentVariableReadEventArgs
 
     private void HandleBuildFinishedEvent(BuildFinishedEventArgs eventArgs)
     {
-        _stats.Merge(_buildCheckManager.CreateAnalyzerTracingStats(), (span1, span2) => span1 + span2);
+        _stats.Merge(_buildCheckManager.CreateCheckTracingStats(), (span1, span2) => span1 + span2);
 
-        LogAnalyzerStats(_analyzerContextFactory.CreateAnalysisContext(GetBuildEventContext(eventArgs)));
+        LogCheckStats(_checkContextFactory.CreateCheckContext(GetBuildEventContext(eventArgs)));
     }
 
-    private void LogAnalyzerStats(IAnalysisContext analysisContext)
+    private void LogCheckStats(ICheckContext checkContext)
     {
         Dictionary<string, TimeSpan> infraStats = new Dictionary<string, TimeSpan>();
-        Dictionary<string, TimeSpan> analyzerStats = new Dictionary<string, TimeSpan>();
+        Dictionary<string, TimeSpan> checkStats = new Dictionary<string, TimeSpan>();
 
         foreach (var stat in _stats)
         {
@@ -138,20 +138,20 @@ private void LogAnalyzerStats(IAnalysisContext analysisContext)
             }
             else
             {
-                analyzerStats[stat.Key] = stat.Value;
+                checkStats[stat.Key] = stat.Value;
             }
         }
 
         BuildCheckTracingEventArgs statEvent = new BuildCheckTracingEventArgs(_stats, true)
-        { BuildEventContext = analysisContext.BuildEventContext };
+        { BuildEventContext = checkContext.BuildEventContext };
 
-        analysisContext.DispatchBuildEvent(statEvent);
+        checkContext.DispatchBuildEvent(statEvent);
 
-        analysisContext.DispatchAsCommentFromText(MessageImportance.Low, $"BuildCheck run times{Environment.NewLine}");
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, $"BuildCheck run times{Environment.NewLine}");
         string infraData = BuildCsvString("Infrastructure run times", infraStats);
-        analysisContext.DispatchAsCommentFromText(MessageImportance.Low, infraData);
-        string analyzerData = BuildCsvString("Analyzer run times", analyzerStats);
-        analysisContext.DispatchAsCommentFromText(MessageImportance.Low, analyzerData);
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, infraData);
+        string checkData = BuildCsvString("Checks run times", checkStats);
+        checkContext.DispatchAsCommentFromText(MessageImportance.Low, checkData);
     }
 
     private string BuildCsvString(string title, Dictionary<string, TimeSpan> rowData)
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
index ca235fbd2f4..fd72d1a6e8e 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckCentralContext.cs
@@ -12,7 +12,7 @@
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
-/// A manager of the runs of the analyzers - deciding based on configuration of what to run and what to postfilter.
+/// A manager of the runs of the checks - deciding based on configuration of what to run and what to postfilter.
 /// </summary>
 internal sealed class BuildCheckCentralContext
 {
@@ -22,22 +22,22 @@ internal BuildCheckCentralContext(IConfigurationProvider configurationProvider)
         => _configurationProvider = configurationProvider;
 
     private record CallbackRegistry(
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>>)> EvaluatedPropertiesActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ParsedItemsAnalysisData>>)> ParsedItemsActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<TaskInvocationAnalysisData>>)> TaskInvocationActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<PropertyReadData>>)> PropertyReadActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<PropertyWriteData>>)> PropertyWriteActions,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<ProjectProcessingDoneData>>)> ProjectProcessingDoneActions)
+        List<(CheckWrapper, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>)> EvaluatedPropertiesActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<ParsedItemsCheckData>>)> ParsedItemsActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<TaskInvocationCheckData>>)> TaskInvocationActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<PropertyReadData>>)> PropertyReadActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<PropertyWriteData>>)> PropertyWriteActions,
+        List<(CheckWrapper, Action<BuildCheckDataContext<ProjectProcessingDoneData>>)> ProjectProcessingDoneActions)
     {
         public CallbackRegistry() : this([], [], [], [], [], []) { }
 
-        internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
+        internal void DeregisterCheck(CheckWrapper check)
         {
-            EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == analyzer);
-            ParsedItemsActions.RemoveAll(a => a.Item1 == analyzer);
-            PropertyReadActions.RemoveAll(a => a.Item1 == analyzer);
-            PropertyWriteActions.RemoveAll(a => a.Item1 == analyzer);
-            ProjectProcessingDoneActions.RemoveAll(a => a.Item1 == analyzer);
+            EvaluatedPropertiesActions.RemoveAll(a => a.Item1 == check);
+            ParsedItemsActions.RemoveAll(a => a.Item1 == check);
+            PropertyReadActions.RemoveAll(a => a.Item1 == check);
+            PropertyWriteActions.RemoveAll(a => a.Item1 == check);
+            ProjectProcessingDoneActions.RemoveAll(a => a.Item1 == check);
         }
     }
 
@@ -45,7 +45,7 @@ internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
     private readonly CallbackRegistry _globalCallbacks = new();
 
     // This we can potentially use to subscribe for receiving evaluated props in the
-    //  build event args. However - this needs to be done early on, when analyzers might not be known yet
+    //  build event args. However - this needs to be done early on, when checks might not be known yet
     internal bool HasEvaluatedPropertiesActions => _globalCallbacks.EvaluatedPropertiesActions.Count > 0;
 
     internal bool HasParsedItemsActions => _globalCallbacks.ParsedItemsActions.Count > 0;
@@ -54,113 +54,113 @@ internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
     internal bool HasPropertyReadActions => _globalCallbacks.PropertyReadActions.Count > 0;
     internal bool HasPropertyWriteActions => _globalCallbacks.PropertyWriteActions.Count > 0;
 
-    internal void RegisterEvaluatedPropertiesAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
+    internal void RegisterEvaluatedPropertiesAction(CheckWrapper check, Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
         // Here we might want to communicate to node that props need to be sent.
         //  (it was being communicated via MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION)
-        => RegisterAction(analyzer, evaluatedPropertiesAction, _globalCallbacks.EvaluatedPropertiesActions);
+        => RegisterAction(check, evaluatedPropertiesAction, _globalCallbacks.EvaluatedPropertiesActions);
 
-    internal void RegisterParsedItemsAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
-        => RegisterAction(analyzer, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
+    internal void RegisterParsedItemsAction(CheckWrapper check, Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction)
+        => RegisterAction(check, parsedItemsAction, _globalCallbacks.ParsedItemsActions);
 
-    internal void RegisterTaskInvocationAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
-        => RegisterAction(analyzer, taskInvocationAction, _globalCallbacks.TaskInvocationActions);
+    internal void RegisterTaskInvocationAction(CheckWrapper check, Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
+        => RegisterAction(check, taskInvocationAction, _globalCallbacks.TaskInvocationActions);
 
-    internal void RegisterPropertyReadAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction)
-        => RegisterAction(analyzer, propertyReadAction, _globalCallbacks.PropertyReadActions);
+    internal void RegisterPropertyReadAction(CheckWrapper check, Action<BuildCheckDataContext<PropertyReadData>> propertyReadAction)
+        => RegisterAction(check, propertyReadAction, _globalCallbacks.PropertyReadActions);
 
-    internal void RegisterPropertyWriteAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction)
-        => RegisterAction(analyzer, propertyWriteAction, _globalCallbacks.PropertyWriteActions);
+    internal void RegisterPropertyWriteAction(CheckWrapper check, Action<BuildCheckDataContext<PropertyWriteData>> propertyWriteAction)
+        => RegisterAction(check, propertyWriteAction, _globalCallbacks.PropertyWriteActions);
 
-    internal void RegisterProjectProcessingDoneAction(BuildAnalyzerWrapper analyzer, Action<BuildCheckDataContext<ProjectProcessingDoneData>> projectDoneAction)
-        => RegisterAction(analyzer, projectDoneAction, _globalCallbacks.ProjectProcessingDoneActions);
+    internal void RegisterProjectProcessingDoneAction(CheckWrapper check, Action<BuildCheckDataContext<ProjectProcessingDoneData>> projectDoneAction)
+        => RegisterAction(check, projectDoneAction, _globalCallbacks.ProjectProcessingDoneActions);
 
     private void RegisterAction<T>(
-        BuildAnalyzerWrapper wrappedAnalyzer,
+        CheckWrapper wrappedCheck,
         Action<BuildCheckDataContext<T>> handler,
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
-        where T : AnalysisData
+        List<(CheckWrapper, Action<BuildCheckDataContext<T>>)> handlersRegistry)
+        where T : CheckData
     {
         void WrappedHandler(BuildCheckDataContext<T> context)
         {
-            using var _ = wrappedAnalyzer.StartSpan();
+            using var _ = wrappedCheck.StartSpan();
             handler(context);
         }
 
         lock (handlersRegistry)
         {
-            handlersRegistry.Add((wrappedAnalyzer, WrappedHandler));
+            handlersRegistry.Add((wrappedCheck, WrappedHandler));
         }
     }
 
-    internal void DeregisterAnalyzer(BuildAnalyzerWrapper analyzer)
+    internal void DeregisterCheck(CheckWrapper check)
     {
-        _globalCallbacks.DeregisterAnalyzer(analyzer);
+        _globalCallbacks.DeregisterCheck(check);
     }
 
     internal void RunEvaluatedPropertiesActions(
-        EvaluatedPropertiesAnalysisData evaluatedPropertiesAnalysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        EvaluatedPropertiesCheckData evaluatedPropertiesCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesAnalysisData,
-            analysisContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.EvaluatedPropertiesActions, evaluatedPropertiesCheckData,
+            checkContext, resultHandler);
 
     internal void RunParsedItemsActions(
-        ParsedItemsAnalysisData parsedItemsAnalysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        ParsedItemsCheckData parsedItemsCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsAnalysisData,
-            analysisContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.ParsedItemsActions, parsedItemsCheckData,
+            checkContext, resultHandler);
 
     internal void RunTaskInvocationActions(
-        TaskInvocationAnalysisData taskInvocationAnalysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        TaskInvocationCheckData taskInvocationCheckData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
-        => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationAnalysisData,
-            analysisContext, resultHandler);
+        => RunRegisteredActions(_globalCallbacks.TaskInvocationActions, taskInvocationCheckData,
+            checkContext, resultHandler);
 
     internal void RunPropertyReadActions(
         PropertyReadData propertyReadDataData,
-        AnalysisLoggingContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        CheckLoggingContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.PropertyReadActions, propertyReadDataData,
-            analysisContext, resultHandler);
+            checkContext, resultHandler);
 
     internal void RunPropertyWriteActions(
         PropertyWriteData propertyWriteData,
-        AnalysisLoggingContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        CheckLoggingContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.PropertyWriteActions, propertyWriteData,
-            analysisContext, resultHandler);
+            checkContext, resultHandler);
 
     internal void RunProjectProcessingDoneActions(
         ProjectProcessingDoneData projectProcessingDoneData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult>
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult>
             resultHandler)
         => RunRegisteredActions(_globalCallbacks.ProjectProcessingDoneActions, projectProcessingDoneData,
-            analysisContext, resultHandler);
+            checkContext, resultHandler);
 
     private void RunRegisteredActions<T>(
-        List<(BuildAnalyzerWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
-        T analysisData,
-        IAnalysisContext analysisContext,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> resultHandler)
-    where T : AnalysisData
+        List<(CheckWrapper, Action<BuildCheckDataContext<T>>)> registeredCallbacks,
+        T checkData,
+        ICheckContext checkContext,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> resultHandler)
+    where T : CheckData
     {
-        string projectFullPath = analysisData.ProjectFilePath;
+        string projectFullPath = checkData.ProjectFilePath;
 
-        foreach (var analyzerCallback in registeredCallbacks)
+        foreach (var checkCallback in registeredCallbacks)
         {
             // Tracing - https://github.com/dotnet/msbuild/issues/9629 - we might want to account this entire block
-            //  to the relevant analyzer (with BuildAnalyzerConfigurationEffectiveonly the currently accounted part as being the 'core-execution' subspan)
+            //  to the relevant check (with BuildCheckConfigurationEffectively the currently accounted part as being the 'core-execution' subspan)
 
-            BuildAnalyzerConfigurationEffective? commonConfig = analyzerCallback.Item1.CommonConfig;
-            BuildAnalyzerConfigurationEffective[] configPerRule;
+            CheckConfigurationEffective? commonConfig = checkCallback.Item1.CommonConfig;
+            CheckConfigurationEffective[] configPerRule;
 
             if (commonConfig != null)
             {
@@ -175,25 +175,25 @@ private void RunRegisteredActions<T>(
             {
                 configPerRule =
                     _configurationProvider.GetMergedConfigurations(projectFullPath,
-                        analyzerCallback.Item1.BuildAnalyzer);
+                        checkCallback.Item1.Check);
                 if (configPerRule.All(c => !c.IsEnabled))
                 {
                     return;
                 }
             }
 
-            // Here we might want to check the configPerRule[0].EvaluationAnalysisScope - if the input data supports that
+            // Here we might want to check the configPerRule[0].EvaluationsCheckScope - if the input data supports that
             // The decision and implementation depends on the outcome of the investigation tracked in:
             // https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57851137
 
             BuildCheckDataContext<T> context = new BuildCheckDataContext<T>(
-                analyzerCallback.Item1,
-                analysisContext,
+                checkCallback.Item1,
+                checkContext,
                 configPerRule,
                 resultHandler,
-                analysisData);
+                checkData);
 
-            analyzerCallback.Item2(context);
+            checkCallback.Item2(context);
         }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
index 69f3335681d..00cb17cff70 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConfigurationException.cs
@@ -13,7 +13,7 @@ internal sealed class BuildCheckConfigurationException : Exception
 {
     /// <summary>
     /// Exception to communicate issues with user specified configuration - unsupported scenarios, malformations, etc.
-    /// This exception usually leads to defuncting the particular analyzer for the rest of the build (even if issue occured with a single project).
+    /// This exception usually leads to defuncting the particular check for the rest of the build (even if issue occured with a single project).
     /// </summary>
     internal BuildCheckConfigurationErrorScope buildCheckConfigurationErrorScope;
 
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 1e1964748af..7e581e2979d 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -15,7 +15,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// <summary>
 /// Central logger for the build check infrastructure.
 /// Receives events from the <see cref="BuildCheckForwardingLogger"/>.
-/// Processes the events and forwards them to the <see cref="IBuildCheckManager"/> and registered analyzers.
+/// Processes the events and forwards them to the <see cref="IBuildCheckManager"/> and registered checks.
 /// </summary>
 /// <remarks>
 /// Ensure that the consuming events are in sync with <see cref="BuildCheckForwardingLogger"/>.
@@ -24,15 +24,15 @@ internal sealed class BuildCheckConnectorLogger : ILogger
 {
     private readonly BuildCheckBuildEventHandler _eventHandler;
     private readonly IBuildCheckManager _buildCheckManager;
-    private readonly IAnalysisContextFactory _analysisContextFactory;
+    private readonly ICheckContextFactory _checkContextFactory;
 
     internal BuildCheckConnectorLogger(
-        IAnalysisContextFactory analyzerContextFactory,
+        ICheckContextFactory checkContextFactory,
         IBuildCheckManager buildCheckManager)
     {
         _buildCheckManager = buildCheckManager;
-        _analysisContextFactory = analyzerContextFactory;
-        _eventHandler = new BuildCheckBuildEventHandler(analyzerContextFactory, buildCheckManager);
+        _checkContextFactory = checkContextFactory;
+        _eventHandler = new BuildCheckBuildEventHandler(checkContextFactory, buildCheckManager);
     }
 
     public LoggerVerbosity Verbosity { get; set; }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
index ca337bee24f..c3910395ad2 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckContext.cs
@@ -5,20 +5,20 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal sealed class BuildCheckRegistrationContext(BuildAnalyzerWrapper analyzerWrapper, BuildCheckCentralContext buildCheckCentralContext) : IBuildCheckRegistrationContext
+internal sealed class BuildCheckRegistrationContext(CheckWrapper checkWrapper, BuildCheckCentralContext buildCheckCentralContext) : IBuildCheckRegistrationContext
 {
-    public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
+    public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
     {
-        buildCheckCentralContext.RegisterEvaluatedPropertiesAction(analyzerWrapper, evaluatedPropertiesAction);
+        buildCheckCentralContext.RegisterEvaluatedPropertiesAction(checkWrapper, evaluatedPropertiesAction);
     }
 
-    public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction)
+    public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction)
     {
-        buildCheckCentralContext.RegisterParsedItemsAction(analyzerWrapper, parsedItemsAction);
+        buildCheckCentralContext.RegisterParsedItemsAction(checkWrapper, parsedItemsAction);
     }
 
-    public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
+    public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
     {
-        buildCheckCentralContext.RegisterTaskInvocationAction(analyzerWrapper, taskInvocationAction);
+        buildCheckCentralContext.RegisterTaskInvocationAction(checkWrapper, taskInvocationAction);
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
index 02808f434a5..45bd095f415 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckForwardingLogger.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 /// <summary>
 /// Forwarding logger for the build check infrastructure.
 /// For now we just want to forward all events that are needed for BuildCheckConnectorLogger and filter out all other.
-/// If the custom analyzer is detected, starts to unconditionally forward all events.
+/// If the custom check is detected, starts to unconditionally forward all events.
 /// In the future we may need more specific behavior.
 /// </summary>
 /// <remarks>
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 844ced7f2f0..8ad601ab424 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -11,7 +11,7 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Experimental.BuildCheck.Acquisition;
-using Microsoft.Build.Experimental.BuildCheck.Analyzers;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Evaluation;
@@ -19,8 +19,8 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
-internal delegate BuildAnalyzer BuildAnalyzerFactory();
-internal delegate BuildAnalyzerWrapper BuildAnalyzerWrapperFactory(ConfigurationContext configurationContext);
+internal delegate Check CheckFactory();
+internal delegate CheckWrapper CheckWrapperFactory(ConfigurationContext configurationContext);
 
 /// <summary>
 /// The central manager for the BuildCheck - this is the integration point with MSBuild infrastructure.
@@ -72,14 +72,14 @@ internal sealed class BuildCheckManager : IBuildCheckManager, IBuildEngineDataRo
         private readonly TracingReporter _tracingReporter = new TracingReporter();
         private readonly IConfigurationProvider _configurationProvider = new ConfigurationProvider();
         private readonly BuildCheckCentralContext _buildCheckCentralContext;
-        private readonly List<BuildAnalyzerFactoryContext> _analyzersRegistry;
+        private readonly List<CheckFactoryContext> _checkRegistry;
         private readonly bool[] _enabledDataSources = new bool[(int)BuildCheckDataSource.ValuesCount];
         private readonly BuildEventsProcessor _buildEventsProcessor;
         private readonly IBuildCheckAcquisitionModule _acquisitionModule;
 
         internal BuildCheckManager()
         {
-            _analyzersRegistry = new List<BuildAnalyzerFactoryContext>();
+            _checkRegistry = new List<CheckFactoryContext>();
             _acquisitionModule = new BuildCheckAcquisitionModule();
             _buildCheckCentralContext = new(_configurationProvider);
             _buildEventsProcessor = new(_buildCheckCentralContext);
@@ -90,7 +90,7 @@ internal BuildCheckManager()
 
         /// <summary>
         /// Notifies the manager that the data source will be used -
-        ///   so it should register the built-in analyzers for the source if it hasn't been done yet.
+        ///   so it should register the built-in checks for the source if it hasn't been done yet.
         /// </summary>
         /// <param name="buildCheckDataSource"></param>
         public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
@@ -99,35 +99,35 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
             if (!_enabledDataSources[(int)buildCheckDataSource])
             {
                 _enabledDataSources[(int)buildCheckDataSource] = true;
-                RegisterBuiltInAnalyzers(buildCheckDataSource);
-            }
+                RegisterBuiltInChecks(buildCheckDataSource);
+            } 
             stopwatch.Stop();
             _tracingReporter.AddSetDataSourceStats(stopwatch.Elapsed);
         }
 
-        public void ProcessAnalyzerAcquisition(
-            AnalyzerAcquisitionData acquisitionData,
-            IAnalysisContext analysisContext)
+        public void ProcessCheckAcquisition(
+            CheckAcquisitionData acquisitionData,
+            ICheckContext checkContext)
         {
             Stopwatch stopwatch = Stopwatch.StartNew();
             if (IsInProcNode)
             {
-                var analyzersFactories = _acquisitionModule.CreateBuildAnalyzerFactories(acquisitionData, analysisContext);
-                if (analyzersFactories.Count != 0)
+                var checksFactories = _acquisitionModule.CreateCheckFactories(acquisitionData, checkContext);
+                if (checksFactories.Count != 0)
                 {
-                    RegisterCustomAnalyzer(acquisitionData.ProjectPath, BuildCheckDataSource.EventArgs, analyzersFactories, analysisContext);
+                    RegisterCustomCheck(acquisitionData.ProjectPath, BuildCheckDataSource.EventArgs, checksFactories, checkContext);
                 }
                 else
                 {
-                    analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerFailedAcquisition", acquisitionData.AssemblyPath);
+                    checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckFailedAcquisition", acquisitionData.AssemblyPath);
                 }
             }
             else
             {
                 BuildCheckAcquisitionEventArgs eventArgs = acquisitionData.ToBuildEventArgs();
-                eventArgs.BuildEventContext = analysisContext.BuildEventContext!;
+                eventArgs.BuildEventContext = checkContext.BuildEventContext!;
 
-                analysisContext.DispatchBuildEvent(eventArgs);
+                checkContext.DispatchBuildEvent(eventArgs);
             }
 
             stopwatch.Stop();
@@ -136,14 +136,14 @@ public void ProcessAnalyzerAcquisition(
 
         private static T Construct<T>() where T : new() => new();
 
-        private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][] s_builtInFactoriesPerDataSource =
+        private static readonly (string[] ruleIds, bool defaultEnablement, CheckFactory factory)[][] s_builtInFactoriesPerDataSource =
         [
 
             // BuildCheckDataSource.EventArgs
             [
-                ([SharedOutputPathAnalyzer.SupportedRule.Id], SharedOutputPathAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathAnalyzer>),
-                ([DoubleWritesAnalyzer.SupportedRule.Id], DoubleWritesAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesAnalyzer>),
-                ([NoEnvironmentVariablePropertyAnalyzer.SupportedRule.Id], NoEnvironmentVariablePropertyAnalyzer.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyAnalyzer>)
+                ([SharedOutputPathCheck.SupportedRule.Id], SharedOutputPathCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<SharedOutputPathCheck>),
+                ([DoubleWritesCheck.SupportedRule.Id], DoubleWritesCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<DoubleWritesCheck>),
+                ([NoEnvironmentVariablePropertyCheck.SupportedRule.Id], NoEnvironmentVariablePropertyCheck.SupportedRule.DefaultConfiguration.IsEnabled ?? false, Construct<NoEnvironmentVariablePropertyCheck>)
             ],
 
             // BuildCheckDataSource.Execution
@@ -151,172 +151,172 @@ private static readonly (string[] ruleIds, bool defaultEnablement, BuildAnalyzer
         ];
 
         /// <summary>
-        /// For tests only. TODO: Remove when analyzer acquisition is done.
+        /// For tests only. TODO: Remove when check acquisition is done.
         /// </summary>
-        internal static (string[] ruleIds, bool defaultEnablement, BuildAnalyzerFactory factory)[][]? s_testFactoriesPerDataSource;
+        internal static (string[] ruleIds, bool defaultEnablement, CheckFactory factory)[][]? s_testFactoriesPerDataSource;
 
-        private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
+        private void RegisterBuiltInChecks(BuildCheckDataSource buildCheckDataSource)
         {
-            _analyzersRegistry.AddRange(
+            _checkRegistry.AddRange(
                 s_builtInFactoriesPerDataSource[(int)buildCheckDataSource]
-                    .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+                    .Select(v => new CheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
 
             if (s_testFactoriesPerDataSource is not null)
             {
-                _analyzersRegistry.AddRange(
+                _checkRegistry.AddRange(
                     s_testFactoriesPerDataSource[(int)buildCheckDataSource]
-                        .Select(v => new BuildAnalyzerFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
+                        .Select(v => new CheckFactoryContext(v.factory, v.ruleIds, v.defaultEnablement)));
             }
         }
 
         /// <summary>
         /// To be used by acquisition module
-        /// Registers the custom analyzer, the construction of analyzer is needed during registration.
+        /// Registers the custom check, the construction of check is needed during registration.
         /// </summary>
         /// <param name="projectPath">The project path is used for the correct .editorconfig resolution.</param>
         /// <param name="buildCheckDataSource">Represents different data sources used in build check operations.</param>
-        /// <param name="factories">A collection of build analyzer factories for rules instantiation.</param>
-        /// <param name="analysisContext">The logging context of the build event.</param>
-        internal void RegisterCustomAnalyzer(
+        /// <param name="factories">A collection of build check factories for rules instantiation.</param>
+        /// <param name="checkContext">The logging context of the build event.</param>
+        internal void RegisterCustomCheck(
             string projectPath,
             BuildCheckDataSource buildCheckDataSource,
-            IEnumerable<BuildAnalyzerFactory> factories,
-            IAnalysisContext analysisContext)
+            IEnumerable<CheckFactory> factories,
+            ICheckContext checkContext)
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
             {
                 foreach (var factory in factories)
                 {
                     var instance = factory();
-                    var analyzerFactoryContext = new BuildAnalyzerFactoryContext(
+                    var checkFactoryContext = new CheckFactoryContext(
                         factory,
                         instance.SupportedRules.Select(r => r.Id).ToArray(),
                         instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true));
 
-                    if (analyzerFactoryContext != null)
+                    if (checkFactoryContext != null)
                     {
-                        _analyzersRegistry.Add(analyzerFactoryContext);
-                        SetupSingleAnalyzer(analyzerFactoryContext, projectPath);
-                        analysisContext.DispatchAsComment(MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.FriendlyName);
+                        _checkRegistry.Add(checkFactoryContext);
+                        SetupSingleCheck(checkFactoryContext, projectPath);
+                        checkContext.DispatchAsComment(MessageImportance.Normal, "CustomCheckSuccessfulAcquisition", instance.FriendlyName);
                     }
                 }
             }
         }
 
-        private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryContext, string projectFullPath)
+        private void SetupSingleCheck(CheckFactoryContext checkFactoryContext, string projectFullPath)
         {
-            // For custom analyzers - it should run only on projects where referenced
+            // For custom checks - it should run only on projects where referenced
             // (otherwise error out - https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=57849480)
             // on others it should work similarly as disabling them.
-            // Disabled analyzer should not only post-filter results - it shouldn't even see the data 
-            BuildAnalyzerWrapper wrapper;
-            BuildAnalyzerConfigurationEffective[] configurations;
-            if (analyzerFactoryContext.MaterializedAnalyzer == null)
+            // Disabled check should not only post-filter results - it shouldn't even see the data 
+            CheckWrapper wrapper;
+            CheckConfigurationEffective[] configurations;
+            if (checkFactoryContext.MaterializedCheck == null)
             {
-                BuildAnalyzerConfiguration[] userConfigs =
-                    _configurationProvider.GetUserConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                CheckConfiguration[] userConfigs =
+                    _configurationProvider.GetUserConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
-                if (userConfigs.All(c => !(c.IsEnabled ?? analyzerFactoryContext.IsEnabledByDefault)))
+                if (userConfigs.All(c => !(c.IsEnabled ?? checkFactoryContext.IsEnabledByDefault)))
                 {
-                    // the analyzer was not yet instantiated nor mounted - so nothing to do here now.
+                    // the check was not yet instantiated nor mounted - so nothing to do here now.
                     return;
                 }
 
                 CustomConfigurationData[] customConfigData =
-                    _configurationProvider.GetCustomConfigurations(projectFullPath, analyzerFactoryContext.RuleIds);
+                    _configurationProvider.GetCustomConfigurations(projectFullPath, checkFactoryContext.RuleIds);
 
-                BuildAnalyzer uninitializedAnalyzer = analyzerFactoryContext.Factory();
-                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, uninitializedAnalyzer);
+                Check uninitializedCheck = checkFactoryContext.Factory();
+                configurations = _configurationProvider.GetMergedConfigurations(userConfigs, uninitializedCheck);
 
                 ConfigurationContext configurationContext = ConfigurationContext.FromDataEnumeration(customConfigData, configurations);
 
-                wrapper = analyzerFactoryContext.Initialize(uninitializedAnalyzer, configurationContext);
-                analyzerFactoryContext.MaterializedAnalyzer = wrapper;
-                BuildAnalyzer analyzer = wrapper.BuildAnalyzer;
+                wrapper = checkFactoryContext.Initialize(uninitializedCheck, configurationContext);
+                checkFactoryContext.MaterializedCheck = wrapper;
+                Check check = wrapper.Check;
 
-                // This is to facilitate possible perf improvement for custom analyzers - as we might want to
+                // This is to facilitate possible perf improvement for custom checks - as we might want to
                 //  avoid loading the assembly and type just to check if it's supported.
                 // If we expose a way to declare the enablement status and rule ids during registration (e.g. via
                 //  optional arguments of the intrinsic property function) - we can then avoid loading it.
                 // But once loaded - we should verify that the declared enablement status and rule ids match the actual ones.
                 if (
-                    analyzer.SupportedRules.Count != analyzerFactoryContext.RuleIds.Length
+                    check.SupportedRules.Count != checkFactoryContext.RuleIds.Length
                     ||
-                    !analyzer.SupportedRules.Select(r => r.Id)
-                        .SequenceEqual(analyzerFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
+                    !check.SupportedRules.Select(r => r.Id)
+                        .SequenceEqual(checkFactoryContext.RuleIds, StringComparer.CurrentCultureIgnoreCase)
                 )
                 {
                     throw new BuildCheckConfigurationException(
-                        $"The analyzer '{analyzer.FriendlyName}' exposes rules '{analyzer.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{analyzerFactoryContext.RuleIds.ToCsvString()}'");
+                        $"The check '{check.FriendlyName}' exposes rules '{check.SupportedRules.Select(r => r.Id).ToCsvString()}', but different rules were declared during registration: '{checkFactoryContext.RuleIds.ToCsvString()}'");
                 }
 
-                // technically all analyzers rules could be disabled, but that would mean
+                // technically all checks rules could be disabled, but that would mean
                 // that the provided 'IsEnabledByDefault' value wasn't correct - the only
                 // price to be paid in that case is slight performance cost.
 
                 // Create the wrapper and register to central context
                 wrapper.StartNewProject(projectFullPath, configurations);
                 var wrappedContext = new BuildCheckRegistrationContext(wrapper, _buildCheckCentralContext);
-                analyzer.RegisterActions(wrappedContext);
+                check.RegisterActions(wrappedContext);
             }
             else
             {
-                wrapper = analyzerFactoryContext.MaterializedAnalyzer;
+                wrapper = checkFactoryContext.MaterializedCheck;
 
-                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.BuildAnalyzer);
+                configurations = _configurationProvider.GetMergedConfigurations(projectFullPath, wrapper.Check);
 
                 _configurationProvider.CheckCustomConfigurationDataValidity(projectFullPath,
-                    analyzerFactoryContext.RuleIds[0]);
+                    checkFactoryContext.RuleIds[0]);
 
                 // Update the wrapper
                 wrapper.StartNewProject(projectFullPath, configurations);
             }
 
-            if (configurations.GroupBy(c => c.EvaluationAnalysisScope).Count() > 1)
+            if (configurations.GroupBy(c => c.EvaluationCheckScope).Count() > 1)
             {
                 throw new BuildCheckConfigurationException(
-                    string.Format("All rules for a single analyzer should have the same EvaluationAnalysisScope for a single project (violating rules: [{0}], project: {1})",
-                        analyzerFactoryContext.RuleIds.ToCsvString(),
+                    string.Format("All rules for a single check should have the same EvaluationCheckScope for a single project (violating rules: [{0}], project: {1})",
+                        checkFactoryContext.RuleIds.ToCsvString(),
                         projectFullPath));
             }
         }
 
-        private void SetupAnalyzersForNewProject(string projectFullPath, IAnalysisContext analysisContext)
+        private void SetupChecksForNewProject(string projectFullPath, ICheckContext checkContext)
         {
-            // Only add analyzers here
-            // On an execution node - we might remove and dispose the analyzers once project is done
+            // Only add checks here
+            // On an execution node - we might remove and dispose the checks once project is done
 
             // If it's already constructed - just control the custom settings do not differ
             Stopwatch stopwatch = Stopwatch.StartNew();
-            List<BuildAnalyzerFactoryContext> analyzersToRemove = new();
-            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            List<CheckFactoryContext> checksToRemove = new();
+            foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
             {
                 try
                 {
-                    SetupSingleAnalyzer(analyzerFactoryContext, projectFullPath);
+                    SetupSingleCheck(checkFactoryContext, projectFullPath);
                 }
                 catch (BuildCheckConfigurationException e)
                 {
-                    analysisContext.DispatchAsErrorFromText(
+                    checkContext.DispatchAsErrorFromText(
                         null,
                         null,
                         null,
                         new BuildEventFileInfo(projectFullPath),
                         e.Message);
-                    analyzersToRemove.Add(analyzerFactoryContext);
+                    checksToRemove.Add(checkFactoryContext);
                 }
             }
 
-            analyzersToRemove.ForEach(c =>
+            checksToRemove.ForEach(c =>
             {
-                _analyzersRegistry.Remove(c);
-                analysisContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting analyzer '{c.FriendlyName}'");
+                _checkRegistry.Remove(c);
+                checkContext.DispatchAsCommentFromText(MessageImportance.High, $"Dismounting check '{c.FriendlyName}'");
             });
-            foreach (var analyzerToRemove in analyzersToRemove.Select(a => a.MaterializedAnalyzer).Where(a => a != null))
+            foreach (var checkToRemove in checksToRemove.Select(a => a.MaterializedCheck).Where(a => a != null))
             {
-                _buildCheckCentralContext.DeregisterAnalyzer(analyzerToRemove!);
-                _tracingReporter.AddAnalyzerStats(analyzerToRemove!.BuildAnalyzer.FriendlyName, analyzerToRemove.Elapsed);
-                analyzerToRemove.BuildAnalyzer.Dispose();
+                _buildCheckCentralContext.DeregisterCheck(checkToRemove!);
+                _tracingReporter.AddCheckStats(checkToRemove!.Check.FriendlyName, checkToRemove.Elapsed);
+                checkToRemove.Check.Dispose();
             }
 
             stopwatch.Stop();
@@ -324,7 +324,7 @@ private void SetupAnalyzersForNewProject(string projectFullPath, IAnalysisContex
         }
 
         public void ProcessEvaluationFinishedEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs)
         {
             Dictionary<string, string>? propertiesLookup = null;
@@ -342,10 +342,10 @@ public void ProcessEvaluationFinishedEventArgs(
             }
 
             _buildEventsProcessor
-                .ProcessEvaluationFinishedEventArgs(analysisContext, evaluationFinishedEventArgs, propertiesLookup);
+                .ProcessEvaluationFinishedEventArgs(checkContext, evaluationFinishedEventArgs, propertiesLookup);
         }
 
-        public void ProcessEnvironmentVariableReadEventArgs(IAnalysisContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
+        public void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
         {
             if (projectEvaluationEventArgs is EnvironmentVariableReadEventArgs evr)
             {
@@ -359,35 +359,35 @@ public void ProcessEnvironmentVariableReadEventArgs(IAnalysisContext analysisCon
         }
 
         public void ProcessTaskStartedEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             TaskStartedEventArgs taskStartedEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskStartedEventArgs(analysisContext, taskStartedEventArgs);
+                .ProcessTaskStartedEventArgs(checkContext, taskStartedEventArgs);
 
         public void ProcessTaskFinishedEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             TaskFinishedEventArgs taskFinishedEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskFinishedEventArgs(analysisContext, taskFinishedEventArgs);
+                .ProcessTaskFinishedEventArgs(checkContext, taskFinishedEventArgs);
 
         public void ProcessTaskParameterEventArgs(
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             TaskParameterEventArgs taskParameterEventArgs)
             => _buildEventsProcessor
-                .ProcessTaskParameterEventArgs(analysisContext, taskParameterEventArgs);
+                .ProcessTaskParameterEventArgs(checkContext, taskParameterEventArgs);
 
-        public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats()
+        public Dictionary<string, TimeSpan> CreateCheckTracingStats()
         {
-            foreach (BuildAnalyzerFactoryContext analyzerFactoryContext in _analyzersRegistry)
+            foreach (CheckFactoryContext checkFactoryContext in _checkRegistry)
             {
-                if (analyzerFactoryContext.MaterializedAnalyzer != null)
+                if (checkFactoryContext.MaterializedCheck != null)
                 {
-                    _tracingReporter.AddAnalyzerStats(analyzerFactoryContext.FriendlyName, analyzerFactoryContext.MaterializedAnalyzer.Elapsed);
-                    analyzerFactoryContext.MaterializedAnalyzer.ClearStats();
+                    _tracingReporter.AddCheckStats(checkFactoryContext.FriendlyName, checkFactoryContext.MaterializedCheck.Elapsed);
+                    checkFactoryContext.MaterializedCheck.ClearStats();
                 }
             }
 
-            _tracingReporter.AddAnalyzerInfraStats();
+            _tracingReporter.AddCheckInfraStats();
             return _tracingReporter.TracingStats;
         }
 
@@ -399,11 +399,11 @@ public void FinalizeProcessing(LoggingContext loggingContext)
                 return;
             }
 
-            var analyzerEventStats = CreateAnalyzerTracingStats();
+            var checkEventStats = CreateCheckTracingStats();
 
-            BuildCheckTracingEventArgs analyzerEventArg =
-                new(analyzerEventStats) { BuildEventContext = loggingContext.BuildEventContext };
-            loggingContext.LogBuildEvent(analyzerEventArg);
+            BuildCheckTracingEventArgs checkEventArg =
+                new(checkEventStats) { BuildEventContext = loggingContext.BuildEventContext };
+            loggingContext.LogBuildEvent(checkEventArg);
         }
 
         private readonly ConcurrentDictionary<int, string> _projectsByContextId = new();
@@ -435,24 +435,24 @@ private string GetProjectFullPath(BuildEventContext buildEventContext)
 
         public void StartProjectEvaluation(
             BuildCheckDataSource buildCheckDataSource,
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             string projectFullPath)
         {
             if (buildCheckDataSource == BuildCheckDataSource.EventArgs && IsInProcNode)
             {
                 // Skipping this event - as it was already handled by the in-proc node.
-                // This is because in-proc node has the BuildEventArgs source and BuildExecution source
+                // This is because in-proc node has the BuildEventArgs source and check source
                 //  both in a single manager. The project started is first encountered by the execution before the EventArg is sent
                 return;
             }
 
-            SetupAnalyzersForNewProject(projectFullPath, analysisContext);
-            _projectsByContextId[analysisContext.BuildEventContext.ProjectContextId] = projectFullPath;
+            SetupChecksForNewProject(projectFullPath, checkContext);
+            _projectsByContextId[checkContext.BuildEventContext.ProjectContextId] = projectFullPath;
         }
 
         /*
          *
-         * Following methods are for future use (should we decide to approach in-execution analysis)
+         * Following methods are for future use (should we decide to approach in-execution check)
          *
          */
 
@@ -469,14 +469,14 @@ public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, Build
 
         public void EndProjectRequest(
             BuildCheckDataSource buildCheckDataSource,
-            IAnalysisContext analysisContext,
+            ICheckContext checkContext,
             string projectFullPath)
         {
-            _buildEventsProcessor.ProcessProjectDone(analysisContext, projectFullPath);
-            _projectsByContextId.TryRemove(analysisContext.BuildEventContext.ProjectContextId, out _);
+            _buildEventsProcessor.ProcessProjectDone(checkContext, projectFullPath);
+            _projectsByContextId.TryRemove(checkContext.BuildEventContext.ProjectContextId, out _);
         }
 
-        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext checkContext)
         {
             if (!_buildCheckCentralContext.HasPropertyReadActions)
             {
@@ -484,13 +484,13 @@ public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggi
             }
 
             PropertyReadData propertyReadData = new(
-                GetProjectFullPath(analysisContext.BuildEventContext),
-                analysisContext.BuildEventContext.ProjectInstanceId,
+                GetProjectFullPath(checkContext.BuildEventContext),
+                checkContext.BuildEventContext.ProjectInstanceId,
                 propertyReadInfo);
-            _buildEventsProcessor.ProcessPropertyRead(propertyReadData, analysisContext);
+            _buildEventsProcessor.ProcessPropertyRead(propertyReadData, checkContext);
         }
 
-        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext analysisContext)
+        public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext checkContext)
         {
             if (!_buildCheckCentralContext.HasPropertyWriteActions)
             {
@@ -498,39 +498,39 @@ public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLo
             }
 
             PropertyWriteData propertyWriteData = new(
-                GetProjectFullPath(analysisContext.BuildEventContext),
-                analysisContext.BuildEventContext.ProjectInstanceId,
+                GetProjectFullPath(checkContext.BuildEventContext),
+                checkContext.BuildEventContext.ProjectInstanceId,
                 propertyWriteInfo);
-            _buildEventsProcessor.ProcessPropertyWrite(propertyWriteData, analysisContext);
+            _buildEventsProcessor.ProcessPropertyWrite(propertyWriteData, checkContext);
         }
 
         public void Shutdown()
         { /* Too late here for any communication to the main node or for logging anything */ }
 
-        private class BuildAnalyzerFactoryContext(
-            BuildAnalyzerFactory factory,
+        private class CheckFactoryContext(
+            CheckFactory factory,
             string[] ruleIds,
             bool isEnabledByDefault)
         {
-            public BuildAnalyzer Factory()
+            public Check Factory()
             {
-                BuildAnalyzer ba = factory();
+                Check ba = factory();
                 return ba;
             }
 
-            public BuildAnalyzerWrapper Initialize(BuildAnalyzer ba, ConfigurationContext configContext)
+            public CheckWrapper Initialize(Check ba, ConfigurationContext configContext)
             {
                 ba.Initialize(configContext);
-                return new BuildAnalyzerWrapper(ba);
+                return new CheckWrapper(ba);
             }
 
-            public BuildAnalyzerWrapper? MaterializedAnalyzer { get; set; }
+            public CheckWrapper? MaterializedCheck { get; set; }
 
             public string[] RuleIds { get; init; } = ruleIds;
 
             public bool IsEnabledByDefault { get; init; } = isEnabledByDefault;
 
-            public string FriendlyName => MaterializedAnalyzer?.BuildAnalyzer.FriendlyName ?? factory().FriendlyName;
+            public string FriendlyName => MaterializedCheck?.Check.FriendlyName ?? factory().FriendlyName;
         }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs
index 9405818dc9f..515b050a8cc 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckReplayModeConnector.cs
@@ -43,7 +43,7 @@ public static IEventSource GetMergedEventSource(
 
         // Create BuildCheckBuildEventHandler that passes new events to the mergedEventSource
         var buildCheckEventHandler = new BuildCheckBuildEventHandler(
-            new AnalysisDispatchingContextFactory(mergedEventSource),
+            new CheckDispatchingContextFactory(mergedEventSource),
             buildCheckManagerProvider.Instance);
 
         // Pass the events from replayEventSource to the BuildCheckBuildEventHandler to produce new events
diff --git a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
index 10b4e2ce9ca..1eb68e8a02b 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildEventsProcessor.cs
@@ -17,13 +17,13 @@ internal class BuildEventsProcessor(BuildCheckCentralContext buildCheckCentralCo
     /// Represents a task currently being executed.
     /// </summary>
     /// <remarks>
-    /// <see cref="TaskParameters"/> is stored in its own field typed as a mutable dictionary because <see cref="AnalysisData"/>
+    /// <see cref="TaskParameters"/> is stored in its own field typed as a mutable dictionary because <see cref="CheckData"/>
     /// is immutable.
     /// </remarks>
     private struct ExecutingTaskData
     {
-        public TaskInvocationAnalysisData AnalysisData;
-        public Dictionary<string, TaskInvocationAnalysisData.TaskParameter> TaskParameters;
+        public TaskInvocationCheckData CheckData;
+        public Dictionary<string, TaskInvocationCheckData.TaskParameter> TaskParameters;
     }
 
     /// <summary>
@@ -56,7 +56,7 @@ internal static Dictionary<string, string> ExtractPropertiesLookup(ProjectEvalua
 
     // This requires MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION set to 1
     internal void ProcessEvaluationFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         ProjectEvaluationFinishedEventArgs evaluationFinishedEventArgs,
         Dictionary<string, string>? propertiesLookup)
     {
@@ -64,13 +64,13 @@ internal void ProcessEvaluationFinishedEventArgs(
         {
             propertiesLookup ??= ExtractPropertiesLookup(evaluationFinishedEventArgs);
 
-            EvaluatedPropertiesAnalysisData analysisData =
+            EvaluatedPropertiesCheckData checkData =
                 new(evaluationFinishedEventArgs.ProjectFile!,
                     evaluationFinishedEventArgs.BuildEventContext?.ProjectInstanceId,
                     propertiesLookup!,
                     _evaluatedEnvironmentVariables);
 
-            _buildCheckCentralContext.RunEvaluatedPropertiesActions(analysisData, analysisContext, ReportResult);
+            _buildCheckCentralContext.RunEvaluatedPropertiesActions(checkData, checkContext, ReportResult);
         }
 
         if (_buildCheckCentralContext.HasParsedItemsActions)
@@ -79,12 +79,12 @@ internal void ProcessEvaluationFinishedEventArgs(
                 evaluationFinishedEventArgs.ProjectFile!, /*unused*/
                 null, /*unused*/null, _cache, false /*Not explicitly loaded - unused*/);
 
-            ParsedItemsAnalysisData itemsAnalysisData = new(
+            ParsedItemsCheckData itemsCheckData = new(
                 evaluationFinishedEventArgs.ProjectFile!,
                 evaluationFinishedEventArgs.BuildEventContext?.ProjectInstanceId,
                 new ItemsHolder(xml.Items, xml.ItemGroups));
 
-            _buildCheckCentralContext.RunParsedItemsActions(itemsAnalysisData, analysisContext, ReportResult);
+            _buildCheckCentralContext.RunParsedItemsActions(itemsCheckData, checkContext, ReportResult);
         }
     }
 
@@ -100,12 +100,12 @@ internal void ProcessEnvironmentVariableReadEventArgs(string envVarName, string
     }
 
     internal void ProcessTaskStartedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskStartedEventArgs taskStartedEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -118,12 +118,12 @@ internal void ProcessTaskStartedEventArgs(
 
             // Add a new entry to _tasksBeingExecuted. TaskParameters are initialized empty and will be recorded
             // based on TaskParameterEventArgs we receive later.
-            Dictionary<string, TaskInvocationAnalysisData.TaskParameter> taskParameters = new();
+            Dictionary<string, TaskInvocationCheckData.TaskParameter> taskParameters = new();
 
             ExecutingTaskData taskData = new()
             {
                 TaskParameters = taskParameters,
-                AnalysisData = new(
+                CheckData = new(
                     projectFilePath: taskStartedEventArgs.ProjectFile!,
                     projectConfigurationId: taskStartedEventArgs.BuildEventContext.ProjectInstanceId,
                     taskInvocationLocation: invocationLocation,
@@ -137,12 +137,12 @@ internal void ProcessTaskStartedEventArgs(
     }
 
     internal void ProcessTaskFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskFinishedEventArgs taskFinishedEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -153,18 +153,18 @@ internal void ProcessTaskFinishedEventArgs(
             {
                 // All task parameters have been recorded by now so remove the task from the dictionary and fire the registered build check actions.
                 _tasksBeingExecuted.Remove(taskKey);
-                _buildCheckCentralContext.RunTaskInvocationActions(taskData.AnalysisData, analysisContext, ReportResult);
+                _buildCheckCentralContext.RunTaskInvocationActions(taskData.CheckData, checkContext, ReportResult);
             }
         }
     }
 
     internal void ProcessTaskParameterEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskParameterEventArgs taskParameterEventArgs)
     {
         if (!_buildCheckCentralContext.HasTaskInvocationActions)
         {
-            // No analyzer is interested in task invocation actions -> nothing to do.
+            // No check is interested in task invocation actions -> nothing to do.
             return;
         }
 
@@ -188,46 +188,46 @@ internal void ProcessTaskParameterEventArgs(
                 _ => taskParameterEventArgs.Items,
             };
 
-            taskData.TaskParameters[parameterName] = new TaskInvocationAnalysisData.TaskParameter(parameterValue, isOutput);
+            taskData.TaskParameters[parameterName] = new TaskInvocationCheckData.TaskParameter(parameterValue, isOutput);
         }
     }
 
-    public void ProcessPropertyRead(PropertyReadData propertyReadData, AnalysisLoggingContext analysisContext)
+    public void ProcessPropertyRead(PropertyReadData propertyReadData, CheckLoggingContext checkContext)
         => _buildCheckCentralContext.RunPropertyReadActions(
                 propertyReadData,
-                analysisContext,
+                checkContext,
                 ReportResult);
 
-    public void ProcessPropertyWrite(PropertyWriteData propertyWriteData, AnalysisLoggingContext analysisContext)
+    public void ProcessPropertyWrite(PropertyWriteData propertyWriteData, CheckLoggingContext checkContext)
         => _buildCheckCentralContext.RunPropertyWriteActions(
                 propertyWriteData,
-                analysisContext,
+                checkContext,
                 ReportResult);
 
-    public void ProcessProjectDone(IAnalysisContext analysisContext, string projectFullPath)
+    public void ProcessProjectDone(ICheckContext checkContext, string projectFullPath)
         => _buildCheckCentralContext.RunProjectProcessingDoneActions(
-                new ProjectProcessingDoneData(projectFullPath, analysisContext.BuildEventContext.ProjectInstanceId),
-                analysisContext,
+                new ProjectProcessingDoneData(projectFullPath, checkContext.BuildEventContext.ProjectInstanceId),
+                checkContext,
                 ReportResult);
 
     private static void ReportResult(
-        BuildAnalyzerWrapper analyzerWrapper,
-        IAnalysisContext analysisContext,
-        BuildAnalyzerConfigurationEffective[] configPerRule,
+        CheckWrapper checkWrapper,
+        ICheckContext checkContext,
+        CheckConfigurationEffective[] configPerRule,
         BuildCheckResult result)
     {
-        if (!analyzerWrapper.BuildAnalyzer.SupportedRules.Contains(result.BuildAnalyzerRule))
+        if (!checkWrapper.Check.SupportedRules.Contains(result.CheckRule))
         {
-            analysisContext.DispatchAsErrorFromText(null, null, null,
+            checkContext.DispatchAsErrorFromText(null, null, null,
                 BuildEventFileInfo.Empty,
-                $"The analyzer '{analyzerWrapper.BuildAnalyzer.FriendlyName}' reported a result for a rule '{result.BuildAnalyzerRule.Id}' that it does not support.");
+                $"The check '{checkWrapper.Check.FriendlyName}' reported a result for a rule '{result.CheckRule.Id}' that it does not support.");
             return;
         }
 
-        BuildAnalyzerConfigurationEffective config = configPerRule.Length == 1
+        CheckConfigurationEffective config = configPerRule.Length == 1
             ? configPerRule[0]
             : configPerRule.First(r =>
-                r.RuleId.Equals(result.BuildAnalyzerRule.Id, StringComparison.CurrentCultureIgnoreCase));
+                r.RuleId.Equals(result.CheckRule.Id, StringComparison.CurrentCultureIgnoreCase));
 
         if (!config.IsEnabled)
         {
@@ -236,10 +236,8 @@ private static void ReportResult(
 
         BuildEventArgs eventArgs = result.ToEventArgs(config.Severity);
 
-        // TODO: This is a workaround for https://github.com/dotnet/msbuild/issues/10176
-        // eventArgs.BuildEventContext = loggingContext.BuildEventContext;
-        eventArgs.BuildEventContext = BuildEventContext.Invalid;
+        eventArgs.BuildEventContext = checkContext.BuildEventContext;
 
-        analysisContext.DispatchBuildEvent(eventArgs);
+        checkContext.DispatchBuildEvent(eventArgs);
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/CheckConfigurationEffective.cs b/src/Build/BuildCheck/Infrastructure/CheckConfigurationEffective.cs
new file mode 100644
index 00000000000..3ab5a72de72
--- /dev/null
+++ b/src/Build/BuildCheck/Infrastructure/CheckConfigurationEffective.cs
@@ -0,0 +1,41 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using Microsoft.Build.Experimental.BuildCheck;
+
+namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+
+/// <summary>
+/// Counterpart type for BuildCheckConfiguration - with all properties non-nullable
+/// </summary>
+public sealed class CheckConfigurationEffective
+{
+    public CheckConfigurationEffective(string ruleId, EvaluationCheckScope evaluationCheckScope, CheckResultSeverity severity)
+    {
+        if (severity == CheckResultSeverity.Default)
+        {
+            throw new ArgumentOutOfRangeException(nameof(severity), severity, "Severity 'Default' is not recognized by the BuildCheck reports infrastructure");
+        }
+
+        RuleId = ruleId;
+        EvaluationCheckScope = evaluationCheckScope;
+        Severity = severity;
+    }
+
+    public string RuleId { get; }
+
+    public EvaluationCheckScope EvaluationCheckScope { get; }
+
+    public CheckResultSeverity Severity { get; }
+
+    public bool IsEnabled => Severity >= CheckResultSeverity.Suggestion;
+
+    // Intentionally not checking the RuleId
+    //  as for checks with multiple rules, we can squash config to a single one,
+    //  if the ruleId is the only thing differing.
+    public bool IsSameConfigurationAs(CheckConfigurationEffective? other) =>
+        other != null &&
+        Severity == other.Severity &&
+        EvaluationCheckScope == other.EvaluationCheckScope;
+}
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
similarity index 92%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
index f9e8cd36cfb..71befe7991b 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContext.cs
@@ -15,14 +15,14 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// <see cref="IAnalysisContext"/> that uses <see cref="EventArgsDispatcher"/> to dispatch.
+/// <see cref="ICheckContext"/> that uses <see cref="EventArgsDispatcher"/> to dispatch.
 /// </summary>
-internal class AnalysisDispatchingContext : IAnalysisContext
+internal class CheckDispatchingContext : ICheckContext
 {
     private readonly EventArgsDispatcher _eventDispatcher;
     private readonly BuildEventContext _eventContext;
 
-    public AnalysisDispatchingContext(
+    public CheckDispatchingContext(
         EventArgsDispatcher dispatch,
         BuildEventContext eventContext)
     {
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs
similarity index 62%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs
index 0a133f90f3d..6c536a14df9 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisDispatchingContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckDispatchingContextFactory.cs
@@ -6,19 +6,19 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal class AnalysisDispatchingContextFactory : IAnalysisContextFactory
+internal class CheckDispatchingContextFactory : ICheckContextFactory
 {
     private readonly EventArgsDispatcher _eventDispatcher;
 
     public event AnyEventHandler? AnyEventRaised;
 
-    public AnalysisDispatchingContextFactory(EventArgsDispatcher eventDispatcher)
+    public CheckDispatchingContextFactory(EventArgsDispatcher eventDispatcher)
     {
         _eventDispatcher = eventDispatcher;
 
         _eventDispatcher.AnyEventRaised += (sender, e) => AnyEventRaised?.Invoke(sender, e);
     }
 
-    public IAnalysisContext CreateAnalysisContext(BuildEventContext eventContext)
-        => new AnalysisDispatchingContext(_eventDispatcher, eventContext);
+    public ICheckContext CreateCheckContext(BuildEventContext eventContext)
+        => new CheckDispatchingContext(_eventDispatcher, eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
similarity index 87%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
index 5df77259f6e..c295b254f49 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContext.cs
@@ -13,14 +13,14 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// <see cref="IAnalysisContext"/> that uses <see cref="ILoggingService"/> to dispatch.
+/// <see cref="ICheckContext"/> that uses <see cref="ILoggingService"/> to dispatch.
 /// </summary>
 /// <remarks>
 /// Making this a record struct to avoid allocations (unless called through interface - which leads to boxing).
 /// This is wanted since this can be used in a hot path (of property reads and writes)
 /// </remarks>
-internal readonly struct AnalysisLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
-    : IAnalysisContext
+internal readonly struct CheckLoggingContext(ILoggingService loggingService, BuildEventContext eventContext)
+    : ICheckContext
 {
     public BuildEventContext BuildEventContext => eventContext;
 
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs
similarity index 57%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs
index b1a716d7b7f..5f429c94b02 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/AnalysisLoggingContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/CheckLoggingContextFactory.cs
@@ -11,12 +11,12 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal class AnalysisLoggingContextFactory : IAnalysisContextFactory
+internal class CheckLoggingContextFactory : ICheckContextFactory
 {
     private readonly ILoggingService _loggingService;
 
-    public AnalysisLoggingContextFactory(ILoggingService loggingService) => _loggingService = loggingService;
+    public CheckLoggingContextFactory(ILoggingService loggingService) => _loggingService = loggingService;
 
-    public IAnalysisContext CreateAnalysisContext(BuildEventContext eventContext)
-        => new AnalysisLoggingContext(_loggingService, eventContext);
+    public ICheckContext CreateCheckContext(BuildEventContext eventContext)
+        => new CheckLoggingContext(_loggingService, eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
similarity index 97%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
index 00439c6dd55..7c4e82861ea 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContext.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContext.cs
@@ -14,7 +14,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Interface that contains an instance of <see cref="BuildEventContext"/> and methods to dispatch it.
 /// </summary>
-internal interface IAnalysisContext
+internal interface ICheckContext
 {
     /// <summary>
     /// Instance of <see cref="BuildEventContext"/>.
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
similarity index 66%
rename from src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs
rename to src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
index 66cc71f507c..da90050598d 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisContext/IAnalysisContextFactory.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckContext/ICheckContextFactory.cs
@@ -5,7 +5,7 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal interface IAnalysisContextFactory
+internal interface ICheckContextFactory
 {
-    IAnalysisContext CreateAnalysisContext(BuildEventContext eventContext);
+    ICheckContext CreateCheckContext(BuildEventContext eventContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/AnalysisScopeClassifier.cs b/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs
similarity index 89%
rename from src/Build/BuildCheck/Infrastructure/AnalysisScopeClassifier.cs
rename to src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs
index 5906b5867b3..c5194d49a49 100644
--- a/src/Build/BuildCheck/Infrastructure/AnalysisScopeClassifier.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckScopeClassifier.cs
@@ -7,7 +7,7 @@
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BuildCheck.Infrastructure;
-internal static class AnalysisScopeClassifier
+internal static class CheckScopeClassifier
 {
     /// <summary>
     /// Indicates whether given location is in the observed scope, based on currently built project path.
@@ -18,7 +18,7 @@ internal static class AnalysisScopeClassifier
     /// <returns></returns>
     /// <exception cref="ArgumentOutOfRangeException"></exception>
     internal static bool IsActionInObservedScope(
-        EvaluationAnalysisScope scope,
+        EvaluationCheckScope scope,
         IMsBuildElementLocation? location,
         string projectFileFullPath)
         => IsActionInObservedScope(scope, location?.File, projectFileFullPath);
@@ -38,14 +38,14 @@ internal static bool IsActionInObservedScope(
     {
         switch (scope)
         {
-            case EvaluationAnalysisScope.ProjectFileOnly:
+            case EvaluationCheckScope.ProjectFileOnly:
                 return filePathOfEvent == projectFileFullPath;
-            case EvaluationAnalysisScope.WorkTreeImports:
+            case EvaluationCheckScope.WorkTreeImports:
                 return
                     filePathOfEvent != null &&
                     !FileClassifier.Shared.IsNonModifiable(filePathOfEvent) &&
                     !IsGeneratedNugetImport(filePathOfEvent);
-            case EvaluationAnalysisScope.All:
+            case EvaluationCheckScope.All:
                 return true;
             default:
                 throw new ArgumentOutOfRangeException(nameof(scope), scope, null);
diff --git a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs b/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
similarity index 77%
rename from src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
rename to src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
index 46c42eaa4d1..62011296cb5 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildAnalyzerWrapper.cs
+++ b/src/Build/BuildCheck/Infrastructure/CheckWrapper.cs
@@ -11,28 +11,28 @@
 namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
-/// A wrapping, enriching class for BuildAnalyzer - so that we have additional data and functionality.
+/// A wrapping, enriching class for BuildCheck - so that we have additional data and functionality.
 /// </summary>
-internal sealed class BuildAnalyzerWrapper
+internal sealed class CheckWrapper
 {
     private readonly Stopwatch _stopwatch = new Stopwatch();
 
-    public BuildAnalyzerWrapper(BuildAnalyzer buildAnalyzer)
+    public CheckWrapper(Check check)
     {
-        BuildAnalyzer = buildAnalyzer;
+        Check = check;
     }
 
-    internal BuildAnalyzer BuildAnalyzer { get; }
+    internal Check Check { get; }
     private bool _isInitialized = false;
 
     // Let's optimize for the scenario where users have a single .editorconfig file that applies to the whole solution.
     // In such case - configuration will be same for all projects. So we do not need to store it per project in a collection.
-    internal BuildAnalyzerConfigurationEffective? CommonConfig { get; private set; }
+    internal CheckConfigurationEffective? CommonConfig { get; private set; }
 
     // start new project
     internal void StartNewProject(
         string fullProjectPath,
-        IReadOnlyList<BuildAnalyzerConfigurationEffective> userConfigs)
+        IReadOnlyList<CheckConfigurationEffective> userConfigs)
     {
         if (!_isInitialized)
         {
@@ -52,7 +52,7 @@ internal void StartNewProject(
         }
     }
 
-    // to be used on eval node (BuildCheckDataSource.BuildExecution)
+    // to be used on eval node (BuildCheckDataSource.check)
     internal void Uninitialize()
     {
         _isInitialized = false;
diff --git a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
index c5f0bf3c8db..e102fe96ced 100644
--- a/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/ConfigurationProvider.cs
@@ -19,9 +19,9 @@ internal sealed class ConfigurationProvider : IConfigurationProvider
     private const string BuildCheck_ConfigurationKey = "build_check";
 
     /// <summary>
-    /// The dictionary used for storing the BuildAnalyzerConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
+    /// The dictionary used for storing the BuildCheckConfiguration per projectfile and rule id. The key is equal to {projectFullPath}-{ruleId}.
     /// </summary>
-    private readonly ConcurrentDictionary<string, BuildAnalyzerConfiguration> _buildAnalyzerConfiguration = new ConcurrentDictionary<string, BuildAnalyzerConfiguration>(StringComparer.InvariantCultureIgnoreCase);
+    private readonly ConcurrentDictionary<string, CheckConfiguration> _checkConfiguration = new ConcurrentDictionary<string, CheckConfiguration>(StringComparer.InvariantCultureIgnoreCase);
 
     /// <summary>
     /// The dictionary used for storing the key-value pairs retrieved from the .editorconfigs for specific projectfile. The key is equal to projectFullPath.
@@ -39,7 +39,7 @@ internal sealed class ConfigurationProvider : IConfigurationProvider
     };
 
     /// <summary>
-    /// Gets the user specified unrecognized configuration for the given analyzer rule.
+    /// Gets the user specified unrecognized configuration for the given check rule.
     /// 
     /// The configuration module should as well check that CustomConfigurationData
     ///  for a particular rule is equal across the whole build (for all projects)  - otherwise it should error out.
@@ -102,12 +102,12 @@ internal void VerifyCustomConfigurationEquality(string ruleId, CustomConfigurati
         }
     }
 
-    public BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
+    public CheckConfigurationEffective[] GetMergedConfigurations(
         string projectFullPath,
-        BuildAnalyzer analyzer)
-        => FillConfiguration(projectFullPath, analyzer.SupportedRules, GetMergedConfiguration);
+        Check check)
+        => FillConfiguration(projectFullPath, check.SupportedRules, GetMergedConfiguration);
 
-    public BuildAnalyzerConfiguration[] GetUserConfigurations(
+    public CheckConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetUserConfiguration);
@@ -123,17 +123,17 @@ public CustomConfigurationData[] GetCustomConfigurations(
         IReadOnlyList<string> ruleIds)
         => FillConfiguration(projectFullPath, ruleIds, GetCustomConfiguration);
 
-    public BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
-        BuildAnalyzerConfiguration[] userConfigs,
-        BuildAnalyzer analyzer)
+    public CheckConfigurationEffective[] GetMergedConfigurations(
+        CheckConfiguration[] userConfigs,
+        Check check)
     {
-        var configurations = new BuildAnalyzerConfigurationEffective[userConfigs.Length];
+        var configurations = new CheckConfigurationEffective[userConfigs.Length];
 
         for (int idx = 0; idx < userConfigs.Length; idx++)
         {
             configurations[idx] = MergeConfiguration(
-                analyzer.SupportedRules[idx].Id,
-                analyzer.SupportedRules[idx].DefaultConfiguration,
+                check.SupportedRules[idx].Id,
+                check.SupportedRules[idx].DefaultConfiguration,
                 userConfigs[idx]);
         }
 
@@ -218,28 +218,28 @@ internal Dictionary<string, string> GetConfiguration(string projectFullPath, str
     }
 
     /// <summary>
-    /// Gets effective user specified (or default) configuration for the given analyzer rule.
+    /// Gets effective user specified (or default) configuration for the given check rule.
     /// The configuration values CAN be null upon this operation.
     /// 
-    /// The configuration module should as well check that BuildAnalyzerConfigurationInternal.EvaluationAnalysisScope
+    /// The configuration module should as well check that BuildCheckConfigurationInternal.EvaluationCheckScope
     ///  for all rules is equal - otherwise it should error out.
     /// </summary>
     /// <param name="projectFullPath"></param>
     /// <param name="ruleId"></param>
     /// <returns></returns>
-    internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
+    internal CheckConfiguration GetUserConfiguration(string projectFullPath, string ruleId)
     {
         var cacheKey = $"{ruleId}-{projectFullPath}";
 
-        var editorConfigValue = _buildAnalyzerConfiguration.GetOrAdd(cacheKey, (key) =>
+        var editorConfigValue = _checkConfiguration.GetOrAdd(cacheKey, (key) =>
         {
-            BuildAnalyzerConfiguration? editorConfig = BuildAnalyzerConfiguration.Null;
+            CheckConfiguration? editorConfig = CheckConfiguration.Null;
             editorConfig.RuleId = ruleId;
             var config = GetConfiguration(projectFullPath, ruleId);
 
             if (config.Any())
             {
-                editorConfig = BuildAnalyzerConfiguration.Create(config);
+                editorConfig = CheckConfiguration.Create(config);
             }
 
             return editorConfig;
@@ -249,50 +249,50 @@ internal BuildAnalyzerConfiguration GetUserConfiguration(string projectFullPath,
     }
 
     /// <summary>
-    /// Gets effective configuration for the given analyzer rule.
+    /// Gets effective configuration for the given check rule.
     /// The configuration values are guaranteed to be non-null upon this merge operation.
     /// </summary>
     /// <param name="projectFullPath"></param>
-    /// <param name="analyzerRule"></param>
+    /// <param name="checkRule"></param>
     /// <returns></returns>
-    internal BuildAnalyzerConfigurationEffective GetMergedConfiguration(string projectFullPath, BuildAnalyzerRule analyzerRule)
-        => GetMergedConfiguration(projectFullPath, analyzerRule.Id, analyzerRule.DefaultConfiguration);
+    internal CheckConfigurationEffective GetMergedConfiguration(string projectFullPath, CheckRule checkRule)
+        => GetMergedConfiguration(projectFullPath, checkRule.Id, checkRule.DefaultConfiguration);
 
-    internal BuildAnalyzerConfigurationEffective MergeConfiguration(
+    internal CheckConfigurationEffective MergeConfiguration(
         string ruleId,
-        BuildAnalyzerConfiguration defaultConfig,
-        BuildAnalyzerConfiguration editorConfig)
-        => new BuildAnalyzerConfigurationEffective(
+        CheckConfiguration defaultConfig,
+        CheckConfiguration editorConfig)
+        => new CheckConfigurationEffective(
             ruleId: ruleId,
-            evaluationAnalysisScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationAnalysisScope),
+            evaluationCheckScope: GetConfigValue(editorConfig, defaultConfig, cfg => cfg.EvaluationCheckScope),
             severity: GetSeverityValue(editorConfig, defaultConfig));
 
-    private BuildAnalyzerConfigurationEffective GetMergedConfiguration(
+    private CheckConfigurationEffective GetMergedConfiguration(
         string projectFullPath,
         string ruleId,
-        BuildAnalyzerConfiguration defaultConfig)
+        CheckConfiguration defaultConfig)
         => MergeConfiguration(ruleId, defaultConfig, GetUserConfiguration(projectFullPath, ruleId));
 
     private T GetConfigValue<T>(
-        BuildAnalyzerConfiguration editorConfigValue,
-        BuildAnalyzerConfiguration defaultValue,
-        Func<BuildAnalyzerConfiguration, T?> propertyGetter) where T : struct
+        CheckConfiguration editorConfigValue,
+        CheckConfiguration defaultValue,
+        Func<CheckConfiguration, T?> propertyGetter) where T : struct
         => propertyGetter(editorConfigValue) ??
            propertyGetter(defaultValue) ??
-           EnsureNonNull(propertyGetter(BuildAnalyzerConfiguration.Default));
+           EnsureNonNull(propertyGetter(CheckConfiguration.Default));
 
-    private BuildAnalyzerResultSeverity GetSeverityValue(BuildAnalyzerConfiguration editorConfigValue, BuildAnalyzerConfiguration defaultValue)
+    private CheckResultSeverity GetSeverityValue(CheckConfiguration editorConfigValue, CheckConfiguration defaultValue)
     {
-        BuildAnalyzerResultSeverity? resultSeverity = null;
+        CheckResultSeverity? resultSeverity = null;
 
         // Consider Default as null, so the severity from the default value could be selected.
         // Default severity is not recognized by the infrastructure and serves for configuration purpuses only. 
-        if (editorConfigValue.Severity != null && editorConfigValue.Severity != BuildAnalyzerResultSeverity.Default)
+        if (editorConfigValue.Severity != null && editorConfigValue.Severity != CheckResultSeverity.Default)
         {
             resultSeverity = editorConfigValue.Severity;
         }
 
-        resultSeverity ??= defaultValue.Severity ?? EnsureNonNull(BuildAnalyzerConfiguration.Default.Severity);
+        resultSeverity ??= defaultValue.Severity ?? EnsureNonNull(CheckConfiguration.Default.Severity);
 
         return resultSeverity.Value;
     }
diff --git a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
index afd3645cf2e..ac8d8012e01 100644
--- a/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
+++ b/src/Build/BuildCheck/Infrastructure/CustomConfigurationData.cs
@@ -13,7 +13,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Holder for the key-value pairs of unstructured data from .editorconfig file,
 ///  that were attribute to a particular rule, but were not recognized by the infrastructure.
-/// The configuration data that is recognized by the infrastructure is passed as <see cref="BuildAnalyzerConfiguration"/>.
+/// The configuration data that is recognized by the infrastructure is passed as <see cref="CheckConfiguration"/>.
 /// </summary>
 public sealed class CustomConfigurationData
 {
@@ -41,7 +41,7 @@ public CustomConfigurationData(string ruleId, Dictionary<string, string> propert
     /// Key-value pairs of unstructured data from .editorconfig file.
     /// E.g. if in editorconfig file we'd have:
     /// [*.csrpoj]
-    /// build_analyzer.microsoft.BC0101.name_of_targets_to_restrict = "Build,CoreCompile,ResolveAssemblyReferences"
+    /// build_check.microsoft.BC0101.name_of_targets_to_restrict = "Build,CoreCompile,ResolveAssemblyReferences"
     ///
     /// the ConfigurationData would be:
     /// "name_of_targets_to_restrict" -> "Build,CoreCompile,ResolveAssemblyReferences"
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
index e19b61c2c40..163fd84f1ff 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/README.md
@@ -7,7 +7,7 @@ To track the request on sharing the code: https://github.com/dotnet/roslyn/issue
 In current implementation the usage of the editorconfig is internal only and exposed via ConfigurationProvider functionality. 
 
 Configuration divided into two categories: 
-- Infra related configuration. IsEnabled, Severity, EvaluationAnalysisScope
+- Infra related configuration. IsEnabled, Severity, EvaluationCheckScope
 - Custom configuration, any other config specified by user for this particular rule
 
 ### Example
@@ -38,7 +38,7 @@ list<editorConfig>{
 }
 ```
 Reverse the order and collect all matching section key-value pairs into new dictionary
-Remove non-msbuild-analyzer related key-values (keys not starting with msbuild_analyzer.RULEID)
+Remove non-msbuild-check related key-values (keys not starting with msbuild_check.RULEID)
 
 The implementation differs depending on category: 
  - Infra related config: Merges the configuration retrieved from configuration module with default values (respecting the specified configs in editorconfig) 
@@ -67,12 +67,12 @@ Lifecycle of BuildCheckManager could be found [here](https://github.com/dotnet/m
 
 
 #### Custom configuration data
-CustomConfigurationData is propogated to the BuildCheck Analyzer instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
-during the initialization of the [BuildAnalyzer](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildAnalyzer.cs#L36).
+CustomConfigurationData is propogated to the BuildCheck Check instance by passing the instance of [ConfigurationContext](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/ConfigurationContext.cs#L14)
+during the initialization of the [BuildExecutionCheck](https://github.com/dotnet/msbuild/blob/393c2fea652873416c8a2028810932a4fa94403f/src/Build/BuildCheck/API/BuildExecutionCheck.cs#L36).
 
 
 #### Example of consuming the CustomConfigurationData
-The `Initialize` method of BuildCheck Analyzer:
+The `Initialize` method of BuildCheck Check:
 ```C#
 public override void Initialize(ConfigurationContext configurationContext)
 {
diff --git a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
index d3174b94ed0..81b74bca9fb 100644
--- a/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/IBuildCheckManager.cs
@@ -36,44 +36,44 @@ internal enum BuildCheckDataSource
 internal interface IBuildCheckManager
 {
     void ProcessEvaluationFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checksContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs);
 
     void ProcessEnvironmentVariableReadEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checksContext,
         EnvironmentVariableReadEventArgs envVariableReadEventArgs);
 
     void ProcessTaskStartedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checksContext,
         TaskStartedEventArgs taskStartedEventArgs);
 
     void ProcessTaskFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checksContext,
         TaskFinishedEventArgs taskFinishedEventArgs);
 
     void ProcessTaskParameterEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checksContext,
         TaskParameterEventArgs taskParameterEventArgs);
 
     void SetDataSource(BuildCheckDataSource buildCheckDataSource);
 
-    void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData, IAnalysisContext analysisContext);
+    void ProcessCheckAcquisition(CheckAcquisitionData acquisitionData, ICheckContext checksContext);
 
-    Dictionary<string, TimeSpan> CreateAnalyzerTracingStats();
+    Dictionary<string, TimeSpan> CreateCheckTracingStats();
 
     void FinalizeProcessing(LoggingContext loggingContext);
 
     // All those to be called from RequestBuilder,
     //  but as well from the ConnectorLogger - as even if interleaved, it gives the info
-    //  to manager about what analyzers need to be materialized and configuration fetched.
-    // No unloading of analyzers is yet considered - once loaded it stays for whole build.
-    void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext, string projectFullPath);
+    //  to manager about what checks need to be materialized and configuration fetched.
+    // No unloading of checks is yet considered - once loaded it stays for whole build.
+    void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, ICheckContext checksContext, string projectFullPath);
 
     void EndProjectEvaluation(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext);
 
     void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, BuildEventContext buildEventContext, string projectFullPath);
 
-    void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext, string projectFullPath);
+    void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, ICheckContext checksContext, string projectFullPath);
 
     void Shutdown();
 }
diff --git a/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs b/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
index b3d942ce93a..e51903fb06e 100644
--- a/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/IConfigurationProvider.cs
@@ -8,17 +8,17 @@
 namespace Microsoft.Build.BuildCheck.Infrastructure;
 internal interface IConfigurationProvider
 {
-    BuildAnalyzerConfiguration[] GetUserConfigurations(
+    CheckConfiguration[] GetUserConfigurations(
         string projectFullPath,
         IReadOnlyList<string> ruleIds);
 
-    BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
+    CheckConfigurationEffective[] GetMergedConfigurations(
         string projectFullPath,
-        BuildAnalyzer analyzer);
+        Check check);
 
-    BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(
-        BuildAnalyzerConfiguration[] userConfigs,
-        BuildAnalyzer analyzer);
+    CheckConfigurationEffective[] GetMergedConfigurations(
+        CheckConfiguration[] userConfigs,
+        Check check);
 
     CustomConfigurationData[] GetCustomConfigurations(
         string projectFullPath,
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs
index 9331ad4bc38..ac9a4323dfb 100644
--- a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataConsumer.cs
@@ -5,7 +5,7 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// Consumer of the data from the build engine.
-/// Currently, this is used to send data for analysis to the BuildCheck.
+/// Currently, this is used to send data for checks to the BuildCheck.
 /// In the future we can multiplex the data to other consumers (e.g. copilot).
 /// </summary>
 internal interface IBuildEngineDataConsumer
@@ -19,5 +19,5 @@ internal interface IBuildEngineDataConsumer
     void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo);
 
     // TODO: We might want to move acquisition data processing into this interface as well
-    // void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData);
+    // void ProcessCheckAcquisition(CheckAcquisitionData acquisitionData);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
index 4aceff798f6..b837b71f07e 100644
--- a/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
+++ b/src/Build/BuildCheck/Infrastructure/InternalOM/IBuildEngineDataRouter.cs
@@ -5,21 +5,21 @@ namespace Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 
 /// <summary>
 /// The module that routes the data to the final consumer.
-/// Typically, it is the BuildCheck (in case of in-node analysis) or LoggingService
-///  (in case of centralized analysis, where the data will first be wrapped to BuildEventArgs and sent to central node).
+/// Typically, it is the BuildCheck (in case of in-node check) or LoggingService
+///  (in case of centralized check, where the data will first be wrapped to BuildEventArgs and sent to central node).
 /// </summary>
 internal interface IBuildEngineDataRouter
 {
     void ProcessPropertyRead(
         PropertyReadInfo propertyReadInfo,
-        // This is intentionally AnalysisLoggingContext instead of IAnalysisContext - to avoid boxing allocations
+        // This is intentionally CheckLoggingContext instead of ICheckContext - to avoid boxing allocations
         //  on a hot path of properties reading (same for writing)
-        AnalysisLoggingContext analysisContext);
+        CheckLoggingContext checkContext);
 
     /// <summary>
     /// Signals that a property was written to.
     /// </summary>
     void ProcessPropertyWrite(
         PropertyWriteInfo propertyWriteInfo,
-        AnalysisLoggingContext analysisContext);
+        CheckLoggingContext checkContext);
 }
diff --git a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
index 338a282cdcd..57830e305cc 100644
--- a/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
+++ b/src/Build/BuildCheck/Infrastructure/NullBuildCheckManager.cs
@@ -17,7 +17,7 @@ public void Shutdown()
     }
 
     public void ProcessEvaluationFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         ProjectEvaluationFinishedEventArgs projectEvaluationFinishedEventArgs)
     {
     }
@@ -27,26 +27,26 @@ public void SetDataSource(BuildCheckDataSource buildCheckDataSource)
     }
 
     public void ProcessTaskStartedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskStartedEventArgs taskStartedEventArgs)
     {
     }
 
     public void ProcessTaskFinishedEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskFinishedEventArgs taskFinishedEventArgs)
     {
     }
 
     public void ProcessTaskParameterEventArgs(
-        IAnalysisContext analysisContext,
+        ICheckContext checkContext,
         TaskParameterEventArgs taskParameterEventArgs)
     {
     }
 
-    public void ProcessAnalyzerAcquisition(
-        AnalyzerAcquisitionData acquisitionData,
-        IAnalysisContext analysisContext)
+    public void ProcessCheckAcquisition(
+        CheckAcquisitionData acquisitionData,
+        ICheckContext checkContext)
     {
     }
 
@@ -54,7 +54,7 @@ public void FinalizeProcessing(LoggingContext loggingContext)
     {
     }
 
-    public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext, string fullPath)
+    public void StartProjectEvaluation(BuildCheckDataSource buildCheckDataSource, ICheckContext checkContext, string fullPath)
     {
     }
 
@@ -66,7 +66,7 @@ public void StartProjectRequest(BuildCheckDataSource buildCheckDataSource, Build
     {
     }
 
-    public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, IAnalysisContext analysisContext,
+    public void EndProjectRequest(BuildCheckDataSource buildCheckDataSource, ICheckContext checkContext,
         string projectFullPath)
     {
     }
@@ -79,7 +79,7 @@ public void ResumeProject(BuildCheckDataSource buildCheckDataSource, BuildEventC
     {
     }
 
-    public Dictionary<string, TimeSpan> CreateAnalyzerTracingStats() => new Dictionary<string, TimeSpan>();
+    public Dictionary<string, TimeSpan> CreateCheckTracingStats() => new Dictionary<string, TimeSpan>();
 
     public void StartTaskInvocation(BuildCheckDataSource buildCheckDataSource, TaskStartedEventArgs eventArgs)
     { }
@@ -90,12 +90,12 @@ public void EndTaskInvocation(BuildCheckDataSource buildCheckDataSource, TaskFin
     public void ProcessTaskParameter(BuildCheckDataSource buildCheckDataSource, TaskParameterEventArgs eventArg)
     { }
 
-    public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, AnalysisLoggingContext buildEventContext)
+    public void ProcessPropertyRead(PropertyReadInfo propertyReadInfo, CheckLoggingContext buildEventContext)
     { }
 
-    public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, AnalysisLoggingContext buildEventContext)
+    public void ProcessPropertyWrite(PropertyWriteInfo propertyWriteInfo, CheckLoggingContext buildEventContext)
     { }
 	
-    public void ProcessEnvironmentVariableReadEventArgs(IAnalysisContext analysisContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
+    public void ProcessEnvironmentVariableReadEventArgs(ICheckContext checkContext, EnvironmentVariableReadEventArgs projectEvaluationEventArgs)
     { }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
index 9809ad27e49..d7f75922966 100644
--- a/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
+++ b/src/Build/BuildCheck/Infrastructure/TracingReporter.cs
@@ -17,11 +17,11 @@ internal class TracingReporter
 
     // Infrastructure time keepers
     // TODO: add more timers throughout BuildCheck run
-    private TimeSpan analyzerAcquisitionTime;
-    private TimeSpan analyzerSetDataSourceTime;
-    private TimeSpan newProjectAnalyzersTime;
+    private TimeSpan checkAcquisitionTime;
+    private TimeSpan checkSetDataSourceTime;
+    private TimeSpan newProjectChecksTime;
 
-    public void AddAnalyzerStats(string name, TimeSpan subtotal)
+    public void AddCheckStats(string name, TimeSpan subtotal)
     {
         if (TracingStats.TryGetValue(name, out TimeSpan existing))
         {
@@ -35,25 +35,25 @@ public void AddAnalyzerStats(string name, TimeSpan subtotal)
 
     public void AddAcquisitionStats(TimeSpan subtotal)
     {
-        analyzerAcquisitionTime += subtotal;
+        checkAcquisitionTime += subtotal;
     }
 
     public void AddSetDataSourceStats(TimeSpan subtotal)
     {
-        analyzerSetDataSourceTime += subtotal;
+        checkSetDataSourceTime += subtotal;
     }
 
     public void AddNewProjectStats(TimeSpan subtotal)
     {
-        newProjectAnalyzersTime += subtotal;
+        newProjectChecksTime += subtotal;
     }
 
-    public void AddAnalyzerInfraStats()
+    public void AddCheckInfraStats()
     {
         var infraStats = new Dictionary<string, TimeSpan>() {
-                { $"{BuildCheckConstants.infraStatPrefix}analyzerAcquisitionTime", analyzerAcquisitionTime },
-                { $"{BuildCheckConstants.infraStatPrefix}analyzerSetDataSourceTime", analyzerSetDataSourceTime },
-                { $"{BuildCheckConstants.infraStatPrefix}newProjectAnalyzersTime", newProjectAnalyzersTime }
+                { $"{BuildCheckConstants.infraStatPrefix}checkAcquisitionTime", checkAcquisitionTime },
+                { $"{BuildCheckConstants.infraStatPrefix}checkSetDataSourceTime", checkSetDataSourceTime },
+                { $"{BuildCheckConstants.infraStatPrefix}newProjectChecksTime", newProjectChecksTime }
             };
 
         TracingStats.Merge(infraStats, (span1, span2) => span1 + span2);
diff --git a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
index 823e9f0541c..fd33666fbd9 100644
--- a/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
+++ b/src/Build/BuildCheck/OM/BuildCheckDataContext.cs
@@ -15,11 +15,11 @@
 namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
-/// Base for a data passed from infrastructure to build analyzers.
+/// Base for a data passed from infrastructure to build checks.
 /// </summary>
 /// <param name="projectFilePath">Currently built project.</param>
 /// <param name="projectConfigurationId">The unique id of a project with unique global properties set.</param>
-public abstract class AnalysisData(string projectFilePath, int? projectConfigurationId)
+public abstract class CheckData(string projectFilePath, int? projectConfigurationId)
 {
     private string? _projectFileDirectory;
     // The id is going to be used in future revision
@@ -57,39 +57,39 @@ public abstract class AnalysisData(string projectFilePath, int? projectConfigura
 }
 
 /// <summary>
-/// Data passed from infrastructure to build analyzers.
+/// Data passed from infrastructure to build checks.
 /// </summary>
-/// <typeparam name="T">The type of the actual data for analysis.</typeparam>
-public class BuildCheckDataContext<T> where T : AnalysisData
+/// <typeparam name="T">The type of the actual data for checking.</typeparam>
+public class BuildCheckDataContext<T> where T : CheckData
 {
-    private readonly BuildAnalyzerWrapper _analyzerWrapper;
-    private readonly IAnalysisContext _analysisContext;
-    private readonly BuildAnalyzerConfigurationEffective[] _configPerRule;
-    private readonly Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> _resultHandler;
+    private readonly CheckWrapper _executionCheckWrapper;
+    private readonly ICheckContext _checkContext;
+    private readonly CheckConfigurationEffective[] _configPerRule;
+    private readonly Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> _resultHandler;
 
     internal BuildCheckDataContext(
-        BuildAnalyzerWrapper analyzerWrapper,
-        IAnalysisContext loggingContext,
-        BuildAnalyzerConfigurationEffective[] configPerRule,
-        Action<BuildAnalyzerWrapper, IAnalysisContext, BuildAnalyzerConfigurationEffective[], BuildCheckResult> resultHandler,
+        CheckWrapper checkWrapper,
+        ICheckContext loggingContext,
+        CheckConfigurationEffective[] configPerRule,
+        Action<CheckWrapper, ICheckContext, CheckConfigurationEffective[], BuildCheckResult> resultHandler,
         T data)
     {
-        _analyzerWrapper = analyzerWrapper;
-        _analysisContext = loggingContext;
+        _executionCheckWrapper = checkWrapper;
+        _checkContext = loggingContext;
         _configPerRule = configPerRule;
         _resultHandler = resultHandler;
         Data = data;
     }
 
     /// <summary>
-    /// Method for reporting the result of the build analyzer rule.
+    /// Method for reporting the result of the build check rule.
     /// </summary>
     /// <param name="result"></param>
     public void ReportResult(BuildCheckResult result)
-        => _resultHandler(_analyzerWrapper, _analysisContext, _configPerRule, result);
+        => _resultHandler(_executionCheckWrapper, _checkContext, _configPerRule, result);
 
     /// <summary>
-    /// Data to be analyzed.
+    /// Data to be checked.
     /// </summary>
     public T Data { get; }
 }
diff --git a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs b/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs
similarity index 92%
rename from src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
rename to src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs
index be24b5346c0..9b84e9ca2f9 100644
--- a/src/Build/BuildCheck/OM/EvaluatedPropertiesAnalysisData.cs
+++ b/src/Build/BuildCheck/OM/EvaluatedPropertiesCheckData.cs
@@ -9,9 +9,9 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// BuildCheck OM data representing the evaluated properties of a project.
 /// </summary>
-public class EvaluatedPropertiesAnalysisData : AnalysisData
+public class EvaluatedPropertiesCheckData : CheckData
 {
-    internal EvaluatedPropertiesAnalysisData(
+    internal EvaluatedPropertiesCheckData(
         string projectFilePath,
         int? projectConfigurationId,
         IReadOnlyDictionary<string, string> evaluatedProperties,
diff --git a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs b/src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
similarity index 96%
rename from src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
rename to src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
index 6d3cb3aa1fe..46c295514c3 100644
--- a/src/Build/BuildCheck/OM/ParsedItemsAnalysisData.cs
+++ b/src/Build/BuildCheck/OM/ParsedItemsCheckData.cs
@@ -42,9 +42,9 @@ public IEnumerable<ProjectItemElement> GetItemsOfType(string itemType)
 /// <summary>
 /// BuildCheck OM data representing the evaluated items of a project.
 /// </summary>
-public class ParsedItemsAnalysisData : AnalysisData
+public class ParsedItemsCheckData : CheckData
 {
-    internal ParsedItemsAnalysisData(
+    internal ParsedItemsCheckData(
         string projectFilePath,
         int? projectConfigurationId,
         ItemsHolder itemsHolder) :
@@ -56,7 +56,7 @@ internal ParsedItemsAnalysisData(
 /// <summary>
 /// BuildCheck OM data representing a task executed by a project.
 /// </summary>
-public sealed class TaskInvocationAnalysisData : AnalysisData
+public sealed class TaskInvocationCheckData : CheckData
 {
     /// <summary>
     /// Represents an input or output parameter of a task.
@@ -107,7 +107,7 @@ public IEnumerable<string> EnumerateStringValues()
         }
     }
 
-    internal TaskInvocationAnalysisData(
+    internal TaskInvocationCheckData(
         string projectFilePath,
         int? projectConfigurationId,
         ElementLocation taskInvocationLocation,
diff --git a/src/Build/BuildCheck/OM/ProjectProcessingDoneData.cs b/src/Build/BuildCheck/OM/ProjectProcessingDoneData.cs
index 79c1ece94be..634ee9026ce 100644
--- a/src/Build/BuildCheck/OM/ProjectProcessingDoneData.cs
+++ b/src/Build/BuildCheck/OM/ProjectProcessingDoneData.cs
@@ -5,4 +5,4 @@
 
 namespace Microsoft.Build.Experimental.BuildCheck;
 
-internal class ProjectProcessingDoneData(string projectFilePath, int? projectConfigurationId) : AnalysisData(projectFilePath, projectConfigurationId);
+internal class ProjectProcessingDoneData(string projectFilePath, int? projectConfigurationId) : CheckData(projectFilePath, projectConfigurationId);
diff --git a/src/Build/BuildCheck/OM/PropertyReadData.cs b/src/Build/BuildCheck/OM/PropertyReadData.cs
index 4efb1107ffd..1dda8388419 100644
--- a/src/Build/BuildCheck/OM/PropertyReadData.cs
+++ b/src/Build/BuildCheck/OM/PropertyReadData.cs
@@ -18,7 +18,7 @@ internal class PropertyReadData(
     IMsBuildElementLocation elementLocation,
     bool isUninitialized,
     PropertyReadContext propertyReadContext)
-    : AnalysisData(projectFilePath, projectConfigurationId)
+    : CheckData(projectFilePath, projectConfigurationId)
 {
     public PropertyReadData(
         string projectFilePath,
diff --git a/src/Build/BuildCheck/OM/PropertyWriteData.cs b/src/Build/BuildCheck/OM/PropertyWriteData.cs
index f2148075e43..ec5745ac791 100644
--- a/src/Build/BuildCheck/OM/PropertyWriteData.cs
+++ b/src/Build/BuildCheck/OM/PropertyWriteData.cs
@@ -17,7 +17,7 @@ internal class PropertyWriteData(
     string propertyName,
     IMsBuildElementLocation? elementLocation,
     bool isEmpty)
-    : AnalysisData(projectFilePath, projectConfigurationId)
+    : CheckData(projectFilePath, projectConfigurationId)
 {
     public PropertyWriteData(string projectFilePath, int? projectConfigurationId, PropertyWriteInfo propertyWriteInfo)
         : this(projectFilePath,
diff --git a/src/Build/CompatibilitySuppressions.xml b/src/Build/CompatibilitySuppressions.xml
index ad32afc0a18..b90200708a7 100644
--- a/src/Build/CompatibilitySuppressions.xml
+++ b/src/Build/CompatibilitySuppressions.xml
@@ -1,254 +1,513 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
 <Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
+    <Left>ref/net472/Microsoft.Build.dll</Left>
+    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.AnalysisData</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerConfiguration</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0001</DiagnosticId>
+    <Target>T:Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectOnly</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithAllImports</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithImportsWithoutSdks</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.AnalysisData.#ctor(System.String)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectOnly</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithAllImports</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithImportsWithoutSdks</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.AnalysisData.#ctor(System.String)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectOnly</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithAllImports</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithImportsWithoutSdks</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.AnalysisData.#ctor(System.String)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
     <Left>ref/net472/Microsoft.Build.dll</Left>
     <Right>ref/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Info</Target>
+    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectOnly</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.#ctor(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithAllImports</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.Create(Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerRule,Microsoft.Build.Construction.ElementLocation,System.String[])</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithImportsFromCurrentWorkTree</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.BuildCheckResult.get_BuildAnalyzerRule</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.EvaluationAnalysisScope.ProjectWithImportsWithoutSdks</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesAnalysisData}})</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Execution.BuildResult.get_BuildRequestDataFlags</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsAnalysisData}})</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
     <DiagnosticId>CP0002</DiagnosticId>
-    <Target>M:Microsoft.Build.Experimental.BuildCheck.AnalysisData.#ctor(System.String)</Target>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationAnalysisData}})</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesCheckData}})</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsCheckData}})</Target>
     <Left>lib/net472/Microsoft.Build.dll</Left>
     <Right>lib/net472/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData}})</Target>
+    <Left>lib/net472/Microsoft.Build.dll</Left>
+    <Right>lib/net472/Microsoft.Build.dll</Right>
+    <IsBaselineSuppression>true</IsBaselineSuppression>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesCheckData}})</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsCheckData}})</Target>
     <Left>lib/net8.0/Microsoft.Build.dll</Left>
     <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData}})</Target>
+    <Left>lib/net8.0/Microsoft.Build.dll</Left>
+    <Right>lib/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
-    <Left>ref/net472/Microsoft.Build.dll</Left>
-    <Right>ref/net472/Microsoft.Build.dll</Right>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterEvaluatedPropertiesAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.EvaluatedPropertiesCheckData}})</Target>
+    <Left>ref/net8.0/Microsoft.Build.dll</Left>
+    <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Error</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterParsedItemsAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.ParsedItemsCheckData}})</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
   </Suppression>
   <Suppression>
-    <DiagnosticId>CP0011</DiagnosticId>
-    <Target>F:Microsoft.Build.Experimental.BuildCheck.BuildAnalyzerResultSeverity.Warning</Target>
+    <DiagnosticId>CP0006</DiagnosticId>
+    <Target>M:Microsoft.Build.Experimental.BuildCheck.IBuildCheckRegistrationContext.RegisterTaskInvocationAction(System.Action{Microsoft.Build.Experimental.BuildCheck.BuildCheckDataContext{Microsoft.Build.Experimental.BuildCheck.TaskInvocationCheckData}})</Target>
     <Left>ref/net8.0/Microsoft.Build.dll</Left>
     <Right>ref/net8.0/Microsoft.Build.dll</Right>
     <IsBaselineSuppression>true</IsBaselineSuppression>
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 999bda273c8..6d2b14dfdc6 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -340,7 +340,7 @@ internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem, Loggi
         /// Properties may be null.
         ///
         /// Used for tests and for ToolsetReader - that operates agnostic on the project
-        ///   - so no logging context is passed, and no BuildCheck analysis will be executed.
+        ///   - so no logging context is passed, and no BuildCheck check will be executed.
         /// </summary>
         internal Expander(IPropertyProvider<P> properties, IFileSystem fileSystem)
         : this(properties, fileSystem, null)
@@ -394,7 +394,7 @@ internal Expander(IPropertyProvider<P> properties, IItemProvider<I> items, IMeta
         /// Any or all may be null.
         ///
         /// This is for the purpose of evaluations through API calls, that might not be able to pass the logging context
-        ///  - BuildCheck analysis won't be executed for those.
+        ///  - BuildCheck checking won't be executed for those.
         /// (for one of the calls we can actually pass IDataConsumingContext - as we have logging service and project)
         ///
         /// </summary>
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 4d8fe9a56cb..4a4a183d24f 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -703,7 +703,7 @@ public static bool RegisterBuildCheck(string projectPath, string pathToAssembly,
                 return true;
             }
 
-            loggingContext.LogComment(MessageImportance.Low, "CustomAnalyzerAssemblyNotExist", pathToAssembly);
+            loggingContext.LogComment(MessageImportance.Low, "CustomCheckAssemblyNotExist", pathToAssembly);
 
             return false;
         }
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 741e731b9ad..53df24ba2d9 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -2107,25 +2107,25 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
     </comment>
   </data>
-  <data name="CustomAnalyzerSuccessfulAcquisition" xml:space="preserve">
-    <value>Custom analyzer rule: '{0}' has been registered successfully.</value>
-    <comment>The message is emitted on successful loading of the custom analyzer rule in process.</comment>
+  <data name="CustomCheckSuccessfulAcquisition" xml:space="preserve">
+    <value>Custom check rule: '{0}' has been registered successfully.</value>
+    <comment>The message is emitted on successful loading of the custom check rule in process.</comment>
   </data>
-  <data name="CustomAnalyzerFailedAcquisition" xml:space="preserve">
-    <value>Failed to register the custom analyzer: '{0}'.</value>
-    <comment>The message is emitted on failed loading of the custom analyzer in process.</comment>
+  <data name="CustomCheckFailedAcquisition" xml:space="preserve">
+    <value>Failed to register the custom check: '{0}'.</value>
+    <comment>The message is emitted on failed loading of the custom check in process.</comment>
   </data>
-  <data name="CustomAnalyzerFailedRuleLoading" xml:space="preserve">
-    <value>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</value>
-    <comment>The message is emitted on failed loading of the custom analyzer rule in process.</comment>
+  <data name="CustomCheckFailedRuleLoading" xml:space="preserve">
+    <value>Failed to instantiate the custom check rule with the following exception: '{0}'.</value>
+    <comment>The message is emitted on failed loading of the custom check rule in process.</comment>
   </data>
-  <data name="CustomAnalyzerAssemblyNotExist" xml:space="preserve">
-    <value>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</value>
-    <comment>The message is emitted when the custom analyzer assembly can not be found.</comment>
+  <data name="CustomCheckAssemblyNotExist" xml:space="preserve">
+    <value>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</value>
+    <comment>The message is emitted when the custom check assembly can not be found.</comment>
   </data>
-  <data name="CustomAnalyzerBaseTypeNotAssignable" xml:space="preserve">
-    <value>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
-    <comment>The message is emitted when the custom analyzer assembly can not be successfully registered.</comment>
+  <data name="CustomCheckBaseTypeNotAssignable" xml:space="preserve">
+    <value>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</value>
+    <comment>The message is emitted when the custom check assembly can not be successfully registered.</comment>
   </data>
   <data name="TaskAssemblyLocationMismatch" xml:space="preserve">
     <value>Task assembly was loaded from '{0}' while the desired location was '{1}'.</value>
@@ -2136,8 +2136,8 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="BuildCheckEnabled" xml:space="preserve">
     <value>The BuildCheck is enabled for this build.</value>
   </data>
-  <data name="CustomAnalyzerRegistered" xml:space="preserve">
-    <value>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</value>
+  <data name="CustomCheckRegistered" xml:space="preserve">
+    <value>The custom check: '{0}' is registered for the build from the location: '{1}'.</value>
   </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 9bb7feac68f..c59ba7f91b5 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Nepodařilo se najít zadané sestavení vlastního analyzátoru: {0}. Zkontrolujte prosím, jestli existuje.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Nepodařilo se načíst typ vlastního analyzátoru: {0} ze sestavení: {1}. Ujistěte se, že dědí základní třídu Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Pokud se nemá jednat o vlastní analyzátor, neměl by být exponovaný. Další informace: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Nepodařilo se zaregistrovat vlastní analyzátor: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Nepovedlo se vytvořit instanci pravidla vlastního analyzátoru s následující výjimkou: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Vlastní analyzátor {0} je pro build zaregistrován z umístění: {1}.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Pravidlo vlastního analyzátoru: {0} se úspěšně zaregistrovalo.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index d188d5430bb..1da92bd2dc3 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Fehler beim Suchen der angegebenen benutzerdefinierten Analysetoolassembly: {0}. Überprüfen Sie, ob sie vorhanden ist.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Fehler beim Laden des benutzerdefinierten Analysetooltyps „{0}“ aus der Assembly: {1}. Stellen Sie sicher, dass es die Basisklasse „Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer“ erbt. Wenn es sich nicht um ein benutzerdefiniertes Analysetool handelt, sollte es nicht verfügbar gemacht werden. Weitere Informationen: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Fehler beim Registrieren des benutzerdefinierten Analysetools: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Fehler beim Instanziieren der benutzerdefinierten Analyseregel. Ausnahme: {0}.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Das benutzerdefinierte Analysetool „{0}“ ist für den Build vom Folgenden aus registriert: {1}.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Die benutzerdefinierte Analyseregel „{0}“ wurde erfolgreich registriert.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index c1dac10107d..df05725c5e4 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">No se pudo encontrar el ensamblado del analizador personalizado especificado: '{0}'. Compruebe si existe.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">No se pudo cargar el tipo de analizador personalizado: '{0}' del ensamblado: '{1}'. Asegúrese de que hereda la clase base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Si no está pensado para ser un analizador personalizado, no debe exponerse. Más información: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">No se pudo registrar el analizador personalizado: '{0}'.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">No se pudo crear una instancia de la regla del analizador personalizado con la siguiente excepción: '{0}'.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">El analizador personalizado: '{0}' está registrado para la compilación desde la ubicación: '{1}'.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">La regla del analizador personalizado: '{0}' se ha registrado correctamente.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 9e0deee0b2a..4fb21225130 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Désolé... Nous n’avons pas pu trouver l’assembly d’analyseur personnalisé : « {0} ». Veuillez vérifier s’il existe.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Désolé... Nous n’avons pas pu charger le type d’analyseur personnalisé : « {0} » à partir de l’assembly : « {1} ». Vérifiez qu’il hérite de la classe de base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. S’il n’est pas destiné à être un analyseur personnalisé, il ne doit pas être exposé. Plus d’informations : https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Désolé... Nous n’avons pas pu inscrire l’analyseur personnalisé : « {0} ».</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Désolé... Nous n’avons pas pu instancier la règle d’analyseur personnalisé avec l’exception suivante : « {0} ».</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">L’analyseur personnalisé : « {0} » est inscrit pour la build à partir de l’emplacement : « {1} ».</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Règle de l’analyseur personnalisé : {0} a été correctement inscrit.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 3a11303b9de..b2d59875e50 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Impossibile trovare l'assembly dell'analizzatore personalizzato specificato: '{0}'. Verificare se esiste.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Non è stato possibile caricare il tipo di analizzatore diagnostico personalizzato: '{0}' dall'assembly: '{1}'. Assicurarsi che erediti la classe di base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se non è destinato a essere un analizzatore personalizzato, non deve essere esposto. Per altre informazioni: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Impossibile registrare l'analizzatore personalizzato: '{0}'.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Impossibile creare un'istanza della regola dell'analizzatore personalizzato con l'eccezione seguente: '{0}'.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Analizzatore personalizzato: '{0}' registrato per la compilazione dal percorso: '{1}'.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Regola dell'analizzatore personalizzato: '{0}' è stata registrata.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index ee8227044f8..b8d4ba74700 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">指定されたカスタム アナライザー アセンブリが見つかりませんでした: '{0}'。存在するかどうか確認してください。</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">カスタム アナライザーの種類を読み込めませんでした: アセンブリ '{1}' の '{0}'。Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基底クラスを継承していることを確認してください。カスタム アナライザーを意図していない場合は、公開しないでください。詳細情報: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">カスタム アナライザーを登録できませんでした: '{0}'。</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">次の例外により、カスタム アナライザー ルールのインスタンスを作成できませんでした: '{0}'。</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">カスタム アナライザー'{0}' は、場所 '{1}' からビルドに登録されています。</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">カスタム アナライザー ルール: '{0}' が正常に登録されました。</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index f517d92f530..82287483bf4 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">지정한 사용자 지정 분석기 어셈블리 '{0}'을(를) 찾지 못했습니다. 있는지 확인하세요.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">'{1}' 어셈블리에서 사용자 지정 분석기 유형 '{0}'을(를) 로드하지 못했습니다. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 기본 클래스를 상속해야 합니다. 사용자 지정 분석기가 아닌 경우 노출되지 않아야 합니다. 추가 정보: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">사용자 지정 분석기 '{0}'을(를) 등록하지 못했습니다.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">'{0}' 예외로 인해 사용자 지정 분석기 규칙을 인스턴스화하지 못했습니다.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">사용자 지정 분석기 '{0}'이(가) '{1}' 위치의 빌드에 등록되었습니다.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">사용자 지정 분석기 규칙 '{0}'이(가) 등록되었습니다.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index b7b9a18f770..63ace7582fc 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Nie można odnaleźć określonego zestawu analizatora niestandardowego: „{0}”. Sprawdź, czy istnieje.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Nie udało się załadować niestandardowego analizatora typu: „{0}” z zestawu: „{1}”. Upewnij się, że dziedziczy po klasie bazowej Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Jeśli nie jest przeznaczony do niestandardowego analizatora, nie powinien być ujawniany. Więcej informacji: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Nie można zarejestrować analizatora niestandardowego: „{0}”.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Nie można utworzyć wystąpienia niestandardowej reguły analizatora z następującym wyjątkiem: „{0}”.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Analizator niestandardowy „{0}” jest zarejestrowany dla kompilacji z lokalizacji: „{1}”.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Niestandardowa reguła analizatora: „{0}” została pomyślnie zarejestrowana.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index f32f6070aff..f857b1890f2 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Falha ao localizar o assembly do analisador personalizado especificado: "{0}". Verifique se existe.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Falha ao carregar o tipo de analisador personalizado: "{0}" do assembly: "{1}". Certifique-se de que ele herde a classe base Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Se não se destina a ser um analisador personalizado, ele não deve ser exposto. Mais informações: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Falha ao registrar o analisador personalizado: "{0}".</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Falha ao criar uma instância da regra do analisador personalizado com a seguinte exceção: "{0}".</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">O analisador personalizado: "{0}"está registrado para o build do local: "{1}".</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Regra do analisador personalizado: "{0}" foi registrado com sucesso.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index c10386abcc6..b5107f73d35 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Не удалось найти указанную сборку настраиваемого анализатора "{0}". Убедитесь, что она существует.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Не удалось загрузить тип настраиваемого анализатора "{0}" из сборки "{1}". Убедитесь, что он наследует базовый класс Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer. Если он не предназначен для настраиваемого анализатора, его не следует предоставлять. Подробнее: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Не удалось зарегистрировать настраиваемый анализатор "{0}".</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Не удалось создать экземпляр правила настраиваемого анализатора со следующим исключением: "{0}".</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Настраиваемый анализатор "{0}" включен для сборки из расположения "{1}".</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Правило настраиваемого анализатора "{0}" успешно зарегистрировано.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index d9e55e6fa7f..21edf0d75d2 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">Belirtilen özel çözümleyici derlemesi: ‘{0}’ bulunamadı. Lütfen var olup olmadığını kontrol edin.</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">Özel çözümleyici türü: ‘{0}’ şu derlemeden: ‘{1}’ yüklenemedi. Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer temel sınıfını devralmış olduğundan emin olun. Özel bir çözümleyici olması amaçlanmadıysa açığa çıkarılmaması gerekir. Daha fazla bilgi: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">Özel çözümleyici: ‘{0}’ kaydedilemedi.</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">Özel çözümleyici kuralı şu özel durumla başlatılamadı: ‘{0}’.</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">Özel çözümleyici: '{0}' derleme için şu konumdan kaydedildi: '{1}'.</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">Özel çözümleyici kuralı: ‘{0}’ başarıyla kaydedildi.</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index af786a8fce0..350c89b3d35 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">找不到指定的自定义分析器程序集 "{0}"。请检查它是否存在。</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">未能从程序集 "{1}" 加载自定义分析器类型 "{0}"。请确保它继承 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基类。如果不打算将其作为自定义分析器，则不应将其公开。详细信息: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">未能注册自定义分析器 "{0}"。</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">未能实例化自定义分析器规则，出现以下异常: {0}。</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">已从位置 "{1}" 为内部版本注册自定义分析器 "{0}"。</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">已成功注册自定义分析器规则 "{0}"。</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 23f8fd192f6..4d3f605a97d 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -217,35 +217,35 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
-      <trans-unit id="CustomAnalyzerAssemblyNotExist">
-        <source>Failed to find the specified custom analyzer assembly: '{0}'. Please check if it exists.</source>
-        <target state="translated">找不到指定的自訂分析器組件: '{0}'。請確認其是否存在。</target>
-        <note>The message is emitted when the custom analyzer assembly can not be found.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerBaseTypeNotAssignable">
-        <source>Failed to load the custom analyzer type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer base class. If it is not intended to be a custom analyzer, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
-        <target state="translated">無法從組件: '{1}'載入自訂分析器類型: '{0}'。請確認其繼承了 Microsoft.Build.Experimental.BuildCheck.BuildAnalyzer 基底類別。如非作為自訂分析器，則不應公開。更多資訊: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
-        <note>The message is emitted when the custom analyzer assembly can not be successfully registered.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to register the custom analyzer: '{0}'.</source>
-        <target state="translated">無法註冊自訂分析器: '{0}'。</target>
-        <note>The message is emitted on failed loading of the custom analyzer in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerFailedRuleLoading">
-        <source>Failed to instantiate the custom analyzer rule with the following exception: '{0}'.</source>
-        <target state="translated">無法具現化自訂分析器規則，發生下列例外狀況: '{0}'。</target>
-        <note>The message is emitted on failed loading of the custom analyzer rule in process.</note>
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerRegistered">
-        <source>The custom analyzer: '{0}' is registered for the build from the location: '{1}'.</source>
-        <target state="translated">已從 '{1}' 位置為組建註冊自訂分析器 '{0}'。</target>
-        <note />
-      </trans-unit>
-      <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
-        <source>Custom analyzer rule: '{0}' has been registered successfully.</source>
-        <target state="translated">已成功註冊自訂分析器規則: '{0}'。</target>
-        <note>The message is emitted on successful loading of the custom analyzer rule in process.</note>
+      <trans-unit id="CustomCheckAssemblyNotExist">
+        <source>Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</source>
+        <target state="new">Failed to find the specified custom check assembly: '{0}'. Please check if it exists.</target>
+        <note>The message is emitted when the custom check assembly can not be found.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckBaseTypeNotAssignable">
+        <source>Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</source>
+        <target state="new">Failed to load the custom check type: '{0}' from the assembly: '{1}'. Make sure it inherits the Microsoft.Build.Experimental.BuildCheck.Check base class. If it is not intended to be a custom check, than it should not be exposed. More info: https://github.com/dotnet/msbuild/blob/main/documentation/specs/proposed/BuildCheck-Architecture.md#acquisition</target>
+        <note>The message is emitted when the custom check assembly can not be successfully registered.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedAcquisition">
+        <source>Failed to register the custom check: '{0}'.</source>
+        <target state="new">Failed to register the custom check: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckFailedRuleLoading">
+        <source>Failed to instantiate the custom check rule with the following exception: '{0}'.</source>
+        <target state="new">Failed to instantiate the custom check rule with the following exception: '{0}'.</target>
+        <note>The message is emitted on failed loading of the custom check rule in process.</note>
+      </trans-unit>
+      <trans-unit id="CustomCheckRegistered">
+        <source>The custom check: '{0}' is registered for the build from the location: '{1}'.</source>
+        <target state="new">The custom check: '{0}' is registered for the build from the location: '{1}'.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="CustomCheckSuccessfulAcquisition">
+        <source>Custom check rule: '{0}' has been registered successfully.</source>
+        <target state="new">Custom check rule: '{0}' has been registered successfully.</target>
+        <note>The message is emitted on successful loading of the custom check rule in process.</note>
       </trans-unit>
       <trans-unit id="DefaultSDKResolverError">
         <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationEffectiveTests.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationEffectiveTests.cs
deleted file mode 100644
index df492de4261..00000000000
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationEffectiveTests.cs
+++ /dev/null
@@ -1,63 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using Xunit;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-using Microsoft.Build.Experimental.BuildCheck;
-using Shouldly;
-using System;
-
-namespace Microsoft.Build.BuildCheck.UnitTests;
-
-public class BuildAnalyzerConfigurationEffectiveTests
-{
-    [Theory]
-    [InlineData("ruleId", EvaluationAnalysisScope.ProjectFileOnly, BuildAnalyzerResultSeverity.Warning,  true)]
-    [InlineData("ruleId2", EvaluationAnalysisScope.ProjectFileOnly, BuildAnalyzerResultSeverity.Warning,  true)]
-    [InlineData("ruleId", EvaluationAnalysisScope.ProjectFileOnly, BuildAnalyzerResultSeverity.Error, false)]
-    public void IsSameConfigurationAsTest(
-        string secondRuleId,
-        EvaluationAnalysisScope secondScope,
-        BuildAnalyzerResultSeverity secondSeverity,
-        bool isExpectedToBeSame)
-    {
-        BuildAnalyzerConfigurationEffective configuration1 = new BuildAnalyzerConfigurationEffective(
-                       ruleId: "ruleId",
-                       evaluationAnalysisScope: EvaluationAnalysisScope.ProjectFileOnly,
-                       severity: BuildAnalyzerResultSeverity.Warning);
-
-        BuildAnalyzerConfigurationEffective configuration2 = new BuildAnalyzerConfigurationEffective(
-            ruleId: secondRuleId,
-            evaluationAnalysisScope: secondScope,
-            severity: secondSeverity);
-
-        configuration1.IsSameConfigurationAs(configuration2).ShouldBe(isExpectedToBeSame);
-    }
-
-    [Theory]
-    [InlineData( BuildAnalyzerResultSeverity.Warning, true)]
-    [InlineData(BuildAnalyzerResultSeverity.Suggestion, true)]
-    [InlineData(BuildAnalyzerResultSeverity.Error, true)]
-    [InlineData(BuildAnalyzerResultSeverity.None, false)]
-    public void BuildAnalyzerConfigurationInternal_Constructor_SeverityConfig(BuildAnalyzerResultSeverity severity, bool isEnabledExpected)
-    {
-        BuildAnalyzerConfigurationEffective configuration = new BuildAnalyzerConfigurationEffective(
-                       ruleId: "ruleId",
-                       evaluationAnalysisScope: EvaluationAnalysisScope.ProjectFileOnly,
-                       severity: severity);
-
-        configuration.IsEnabled.ShouldBe(isEnabledExpected);
-    }
-
-    [Fact]
-    public void BuildAnalyzerConfigurationInternal_Constructor_SeverityConfig_Fails()
-    {
-        Should.Throw<ArgumentOutOfRangeException>(() =>
-        {
-            new BuildAnalyzerConfigurationEffective(
-                        ruleId: "ruleId",
-                        evaluationAnalysisScope: EvaluationAnalysisScope.ProjectFileOnly,
-                        severity: BuildAnalyzerResultSeverity.Default);
-        });
-    }
-}
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
deleted file mode 100644
index 4f5274281fb..00000000000
--- a/src/BuildCheck.UnitTests/BuildAnalyzerConfiguration_Test.cs
+++ /dev/null
@@ -1,117 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-using System.Collections.Generic;
-using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
-using Microsoft.Build.Experimental.BuildCheck;
-using Shouldly;
-using Xunit;
-
-namespace Microsoft.Build.BuildCheck.UnitTests;
-
-public class BuildAnalyzerConfiguration_Test
-{
-    [Fact]
-    public void CreateWithNull_ReturnsObjectWithNullValues()
-    {
-        var buildConfig = BuildAnalyzerConfiguration.Create(null);
-        buildConfig.ShouldNotBeNull();
-        buildConfig.Severity.ShouldBeNull();
-        buildConfig.IsEnabled.ShouldBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-    }
-
-    [Fact]
-    public void CreateWithEmpty_ReturnsObjectWithNullValues()
-    {
-        var buildConfig = BuildAnalyzerConfiguration.Create(new Dictionary<string, string>());
-        buildConfig.ShouldNotBeNull();
-        buildConfig.Severity.ShouldBeNull();
-        buildConfig.IsEnabled.ShouldBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-    }
-
-    [Theory]
-    [InlineData("error", BuildAnalyzerResultSeverity.Error)]
-    [InlineData("ERROR", BuildAnalyzerResultSeverity.Error)]
-    [InlineData("suggestion", BuildAnalyzerResultSeverity.Suggestion)]
-    [InlineData("SUGGESTION", BuildAnalyzerResultSeverity.Suggestion)]
-    [InlineData("warning", BuildAnalyzerResultSeverity.Warning)]
-    [InlineData("WARNING", BuildAnalyzerResultSeverity.Warning)]
-    [InlineData("NONE", BuildAnalyzerResultSeverity.None)]
-    [InlineData("none", BuildAnalyzerResultSeverity.None)]
-    [InlineData("default", BuildAnalyzerResultSeverity.Default)]
-    [InlineData("DEFAULT", BuildAnalyzerResultSeverity.Default)]
-    public void CreateBuildAnalyzerConfiguration_Severity(string parameter, BuildAnalyzerResultSeverity? expected)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { "severity" , parameter },
-        };
-
-        var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-        buildConfig.ShouldNotBeNull();
-        buildConfig.Severity.ShouldBe(expected);
-        buildConfig.EvaluationAnalysisScope.ShouldBeNull();
-    }
-
-    [Theory]
-    [InlineData("error", true)]
-    [InlineData("warning", true)]
-    [InlineData("suggestion", true)]
-    [InlineData("none", false)]
-    [InlineData("default", null)]
-    public void CreateBuildAnalyzerConfiguration_SeverityAndEnabledOrder(string parameter, bool? expected)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { "severity", parameter },
-        };
-        
-        var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-        buildConfig.IsEnabled.ShouldBe(expected);
-    }
-
-    [Theory]
-    [InlineData("project_file", EvaluationAnalysisScope.ProjectFileOnly)]
-    [InlineData("projectfile", EvaluationAnalysisScope.ProjectFileOnly)]
-    [InlineData("PROJECT_FILE", EvaluationAnalysisScope.ProjectFileOnly)]
-    [InlineData("work_tree_imports", EvaluationAnalysisScope.WorkTreeImports)]
-    [InlineData("WORK_TREE_IMPORTS", EvaluationAnalysisScope.WorkTreeImports)]
-    [InlineData("all", EvaluationAnalysisScope.All)]
-    [InlineData("ALL", EvaluationAnalysisScope.All)]
-    public void CreateBuildAnalyzerConfiguration_EvaluationAnalysisScope(string parameter, EvaluationAnalysisScope? expected)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { "scope" , parameter },
-        };
-
-        var buildConfig = BuildAnalyzerConfiguration.Create(config);
-
-        buildConfig.ShouldNotBeNull();
-        buildConfig.EvaluationAnalysisScope.ShouldBe(expected);
-
-        buildConfig.IsEnabled.ShouldBeNull();
-        buildConfig.Severity.ShouldBeNull();
-    }
-
-    [Theory]
-    [InlineData("scope", "incorrec-value")]
-    [InlineData("severity", "incorrec-value")]
-    public void CreateBuildAnalyzerConfiguration_ExceptionOnInvalidInputValue(string key, string value)
-    {
-        var config = new Dictionary<string, string>()
-        {
-            { key , value },
-        };
-
-        var exception = Should.Throw<BuildCheckConfigurationException>(() =>
-        {
-            BuildAnalyzerConfiguration.Create(config);
-        });
-        exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
-    }
-}
diff --git a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
index ba4a0e9da46..d33261fc6d9 100644
--- a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
+++ b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
@@ -34,21 +34,21 @@ public BuildCheckManagerTests(ITestOutputHelper output)
     }
 
     [Theory]
-    [InlineData(true, new[] { "Custom analyzer rule: 'Rule1' has been registered successfully.", "Custom analyzer rule: 'Rule2' has been registered successfully." })]
-    [InlineData(false, new[] { "Failed to register the custom analyzer: 'DummyPath'." })]
-    public void ProcessAnalyzerAcquisitionTest(bool isAnalyzerRuleExist, string[] expectedMessages)
+    [InlineData(true, new[] { "Custom check rule: 'Rule1' has been registered successfully.", "Custom check rule: 'Rule2' has been registered successfully." })]
+    [InlineData(false, new[] { "Failed to register the custom check: 'DummyPath'." })]
+    public void ProcessCheckAcquisitionTest(bool isCheckRuleExist, string[] expectedMessages)
     {
         MockConfigurationProvider();
-        MockBuildCheckAcquisition(isAnalyzerRuleExist);
+        MockBuildCheckAcquisition(isCheckRuleExist);
         MockEnabledDataSourcesDefinition();
 
-        _testedInstance.ProcessAnalyzerAcquisition(new AnalyzerAcquisitionData("DummyPath", "ProjectPath"), new AnalysisLoggingContext(_loggingService, new BuildEventContext(1, 2, 3, 4, 5, 6, 7)));
+        _testedInstance.ProcessCheckAcquisition(new CheckAcquisitionData("DummyPath", "ProjectPath"), new CheckLoggingContext(_loggingService, new BuildEventContext(1, 2, 3, 4, 5, 6, 7)));
 
         _logger.AllBuildEvents.Where(be => be.GetType() == typeof(BuildMessageEventArgs)).Select(be => be.Message).ToArray()
             .ShouldBeEquivalentTo(expectedMessages);
     }
 
-    private void MockBuildCheckAcquisition(bool isAnalyzerRuleExist) => MockField("_acquisitionModule", new BuildCheckAcquisitionModuleMock(isAnalyzerRuleExist));
+    private void MockBuildCheckAcquisition(bool isCheckRuleExist) => MockField("_acquisitionModule", new BuildCheckAcquisitionModuleMock(isCheckRuleExist));
 
     private void MockEnabledDataSourcesDefinition() => MockField("_enabledDataSources", new[] { true, true });
 
@@ -70,46 +70,46 @@ public void CheckCustomConfigurationDataValidity(string projectFullPath, string
 
     public CustomConfigurationData[] GetCustomConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
 
-    public BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(string projectFullPath, BuildAnalyzer analyzer) => [];
+    public CheckConfigurationEffective[] GetMergedConfigurations(string projectFullPath, Check check) => [];
 
-    public BuildAnalyzerConfigurationEffective[] GetMergedConfigurations(BuildAnalyzerConfiguration[] userConfigs, BuildAnalyzer analyzer) => [];
+    public CheckConfigurationEffective[] GetMergedConfigurations(CheckConfiguration[] userConfigs, Check check) => [];
 
-    public BuildAnalyzerConfiguration[] GetUserConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
+    public CheckConfiguration[] GetUserConfigurations(string projectFullPath, IReadOnlyList<string> ruleIds) => [];
 }
 
 internal sealed class BuildCheckAcquisitionModuleMock : IBuildCheckAcquisitionModule
 {
-    private readonly bool _isAnalyzerRuleExistForTest = true;
+    private readonly bool _isCheckRuleExistForTest = true;
 
-    internal BuildCheckAcquisitionModuleMock(bool isAnalyzerRuleExistForTest) => _isAnalyzerRuleExistForTest = isAnalyzerRuleExistForTest;
+    internal BuildCheckAcquisitionModuleMock(bool isCheckRuleExistForTest) => _isCheckRuleExistForTest = isCheckRuleExistForTest;
 
-    public List<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, IAnalysisContext analysisContext)
-        => _isAnalyzerRuleExistForTest
-        ? new List<BuildAnalyzerFactory>() { () => new BuildAnalyzerRuleMock("Rule1"), () => new BuildAnalyzerRuleMock("Rule2") }
-        : new List<BuildAnalyzerFactory>();
+    public List<CheckFactory> CreateCheckFactories(CheckAcquisitionData checkAcquisitionData, ICheckContext checkContext)
+        => _isCheckRuleExistForTest
+        ? new List<CheckFactory>() { () => new CheckRuleMock("Rule1"), () => new CheckRuleMock("Rule2") }
+        : new List<CheckFactory>();
 }
 
-internal sealed class BuildAnalyzerRuleMock : BuildAnalyzer
+internal sealed class CheckRuleMock : Check
 {
-    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+    public static CheckRule SupportedRule = new CheckRule(
         "X01234",
         "Title",
         "Description",
         "Message format: {0}",
-        new BuildAnalyzerConfiguration());
+        new CheckConfiguration());
 
-    internal BuildAnalyzerRuleMock(string friendlyName)
+    internal CheckRuleMock(string friendlyName)
     {
         FriendlyName = friendlyName;
     }
 
     public override string FriendlyName { get; }
 
-    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+    public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
     public override void Initialize(ConfigurationContext configurationContext)
     {
-        // configurationContext to be used only if analyzer needs external configuration data.
+        // configurationContext to be used only if check needs external configuration data.
     }
 
     public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -117,7 +117,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
         registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
     }
 
-    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
     {
         context.ReportResult(BuildCheckResult.Create(
             SupportedRule,
diff --git a/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs b/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
new file mode 100644
index 00000000000..12920740700
--- /dev/null
+++ b/src/BuildCheck.UnitTests/CheckConfigurationEffectiveTests.cs
@@ -0,0 +1,63 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using Xunit;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using System;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class CheckConfigurationEffectiveTests
+{
+    [Theory]
+    [InlineData("ruleId", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Warning,  true)]
+    [InlineData("ruleId2", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Warning,  true)]
+    [InlineData("ruleId", EvaluationCheckScope.ProjectFileOnly, CheckResultSeverity.Error, false)]
+    public void IsSameConfigurationAsTest(
+        string secondRuleId,
+        EvaluationCheckScope secondScope,
+        CheckResultSeverity secondSeverity,
+        bool isExpectedToBeSame)
+    {
+        CheckConfigurationEffective configuration1 = new CheckConfigurationEffective(
+                       ruleId: "ruleId",
+                       evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
+                       severity: CheckResultSeverity.Warning);
+
+        CheckConfigurationEffective configuration2 = new CheckConfigurationEffective(
+            ruleId: secondRuleId,
+            evaluationCheckScope: secondScope,
+            severity: secondSeverity);
+
+        configuration1.IsSameConfigurationAs(configuration2).ShouldBe(isExpectedToBeSame);
+    }
+
+    [Theory]
+    [InlineData( CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Suggestion, true)]
+    [InlineData(CheckResultSeverity.Error, true)]
+    [InlineData(CheckResultSeverity.None, false)]
+    public void CheckConfigurationInternal_Constructor_SeverityConfig(CheckResultSeverity severity, bool isEnabledExpected)
+    {
+        CheckConfigurationEffective configuration = new CheckConfigurationEffective(
+                       ruleId: "ruleId",
+                       evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
+                       severity: severity);
+
+        configuration.IsEnabled.ShouldBe(isEnabledExpected);
+    }
+
+    [Fact]
+    public void CheckConfigurationInternal_Constructor_SeverityConfig_Fails()
+    {
+        Should.Throw<ArgumentOutOfRangeException>(() =>
+        {
+            new CheckConfigurationEffective(
+                        ruleId: "ruleId",
+                        evaluationCheckScope: EvaluationCheckScope.ProjectFileOnly,
+                        severity: CheckResultSeverity.Default);
+        });
+    }
+}
diff --git a/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs b/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
new file mode 100644
index 00000000000..3fd22bd8a46
--- /dev/null
+++ b/src/BuildCheck.UnitTests/CheckConfiguration_Test.cs
@@ -0,0 +1,117 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Collections.Generic;
+using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class CheckConfiguration_Test
+{
+    [Fact]
+    public void CreateWithNull_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = CheckConfiguration.Create(null);
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationCheckScope.ShouldBeNull();
+    }
+
+    [Fact]
+    public void CreateWithEmpty_ReturnsObjectWithNullValues()
+    {
+        var buildConfig = CheckConfiguration.Create(new Dictionary<string, string>());
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBeNull();
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.EvaluationCheckScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("error", CheckResultSeverity.Error)]
+    [InlineData("ERROR", CheckResultSeverity.Error)]
+    [InlineData("suggestion", CheckResultSeverity.Suggestion)]
+    [InlineData("SUGGESTION", CheckResultSeverity.Suggestion)]
+    [InlineData("warning", CheckResultSeverity.Warning)]
+    [InlineData("WARNING", CheckResultSeverity.Warning)]
+    [InlineData("NONE", CheckResultSeverity.None)]
+    [InlineData("none", CheckResultSeverity.None)]
+    [InlineData("default", CheckResultSeverity.Default)]
+    [InlineData("DEFAULT", CheckResultSeverity.Default)]
+    public void CreateCheckConfiguration_Severity(string parameter, CheckResultSeverity? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "severity" , parameter },
+        };
+
+        var buildConfig = CheckConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.Severity.ShouldBe(expected);
+        buildConfig.EvaluationCheckScope.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("error", true)]
+    [InlineData("warning", true)]
+    [InlineData("suggestion", true)]
+    [InlineData("none", false)]
+    [InlineData("default", null)]
+    public void CreateCheckConfiguration_SeverityAndEnabledOrder(string parameter, bool? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "severity", parameter },
+        };
+        
+        var buildConfig = CheckConfiguration.Create(config);
+
+        buildConfig.IsEnabled.ShouldBe(expected);
+    }
+
+    [Theory]
+    [InlineData("project_file", EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData("projectfile", EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData("PROJECT_FILE", EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData("work_tree_imports", EvaluationCheckScope.WorkTreeImports)]
+    [InlineData("WORK_TREE_IMPORTS", EvaluationCheckScope.WorkTreeImports)]
+    [InlineData("all", EvaluationCheckScope.All)]
+    [InlineData("ALL", EvaluationCheckScope.All)]
+    public void CreateCheckConfiguration_EvaluationCheckScope(string parameter, EvaluationCheckScope? expected)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { "scope" , parameter },
+        };
+
+        var buildConfig = CheckConfiguration.Create(config);
+
+        buildConfig.ShouldNotBeNull();
+        buildConfig.EvaluationCheckScope.ShouldBe(expected);
+
+        buildConfig.IsEnabled.ShouldBeNull();
+        buildConfig.Severity.ShouldBeNull();
+    }
+
+    [Theory]
+    [InlineData("scope", "incorrec-value")]
+    [InlineData("severity", "incorrec-value")]
+    public void CreateCheckConfiguration_ExceptionOnInvalidInputValue(string key, string value)
+    {
+        var config = new Dictionary<string, string>()
+        {
+            { key , value },
+        };
+
+        var exception = Should.Throw<BuildCheckConfigurationException>(() =>
+        {
+            CheckConfiguration.Create(config);
+        });
+        exception.Message.ShouldContain($"Incorrect value provided in config for key {key}");
+    }
+}
diff --git a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
index f38cdbb46fe..53b7ba1b7b3 100644
--- a/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
+++ b/src/BuildCheck.UnitTests/ConfigurationProvider_Tests.cs
@@ -117,8 +117,8 @@ public void GetRuleIdConfiguration_ReturnsBuildRuleConfiguration()
         buildConfig.ShouldNotBeNull();
 
         buildConfig.IsEnabled.ShouldBe(true);
-        buildConfig.Severity.ShouldBe(BuildAnalyzerResultSeverity.Error);
-        buildConfig.EvaluationAnalysisScope.ShouldBe(EvaluationAnalysisScope.ProjectFileOnly);
+        buildConfig.Severity.ShouldBe(CheckResultSeverity.Error);
+        buildConfig.EvaluationCheckScope.ShouldBe(EvaluationCheckScope.ProjectFileOnly);
     }
 
     [Fact]
@@ -216,27 +216,27 @@ public void GetRuleIdConfiguration_CustomConfigurationValidity_Valid()
     }
 
     [Theory]
-    [InlineData(BuildAnalyzerResultSeverity.Warning, BuildAnalyzerResultSeverity.Warning, true)]
-    [InlineData(BuildAnalyzerResultSeverity.Error, BuildAnalyzerResultSeverity.Error, true)]
-    [InlineData(BuildAnalyzerResultSeverity.Default, BuildAnalyzerResultSeverity.Warning, true)]
-    [InlineData(BuildAnalyzerResultSeverity.Suggestion, BuildAnalyzerResultSeverity.Suggestion, true)]
-    [InlineData(BuildAnalyzerResultSeverity.None, BuildAnalyzerResultSeverity.None, false)]
-    [InlineData(null, BuildAnalyzerResultSeverity.Warning, true)]
-    public void GetConfigurationProvider_MergesSeverity_Correctly(BuildAnalyzerResultSeverity? buildAnalyzerResultSeverity, BuildAnalyzerResultSeverity expectedSeverity, bool expectedEnablment)
+    [InlineData(CheckResultSeverity.Warning, CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Error, CheckResultSeverity.Error, true)]
+    [InlineData(CheckResultSeverity.Default, CheckResultSeverity.Warning, true)]
+    [InlineData(CheckResultSeverity.Suggestion, CheckResultSeverity.Suggestion, true)]
+    [InlineData(CheckResultSeverity.None, CheckResultSeverity.None, false)]
+    [InlineData(null, CheckResultSeverity.Warning, true)]
+    public void GetConfigurationProvider_MergesSeverity_Correctly(CheckResultSeverity? checkResultSeverity, CheckResultSeverity expectedSeverity, bool expectedEnablment)
     {
         var configurationProvider = new ConfigurationProvider();
-        BuildAnalyzerConfiguration buildAnalyzerConfiguration = new BuildAnalyzerConfiguration()
+        CheckConfiguration checkConfiguration = new CheckConfiguration()
         {
-            Severity = buildAnalyzerResultSeverity
+            Severity = checkResultSeverity
         };
 
-        BuildAnalyzerConfiguration defaultValue = new BuildAnalyzerConfiguration()
+        CheckConfiguration defaultValue = new CheckConfiguration()
         {
-            Severity = BuildAnalyzerResultSeverity.Warning
+            Severity = CheckResultSeverity.Warning
         };
 
-        var internalBuildAnalyzer = configurationProvider.MergeConfiguration("ruleId", defaultValue, buildAnalyzerConfiguration);
-        internalBuildAnalyzer.Severity.ShouldBe(expectedSeverity);
-        internalBuildAnalyzer.IsEnabled.ShouldBe(expectedEnablment);
+        var internalCheck = configurationProvider.MergeConfiguration("ruleId", defaultValue, checkConfiguration);
+        internalCheck.Severity.ShouldBe(expectedSeverity);
+        internalCheck.IsEnabled.ShouldBe(expectedEnablment);
     }
 }
diff --git a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
index 9320e382e97..c773fefbc11 100644
--- a/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
+++ b/src/BuildCheck.UnitTests/DoubleWritesAnalyzer_Tests.cs
@@ -6,30 +6,30 @@
 using System.IO;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.Experimental.BuildCheck.Analyzers;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.BuildCheck.UnitTests
 {
-    public sealed class DoubleWritesAnalyzer_Tests
+    public sealed class DoubleWritesCheck_Tests
     {
-        private readonly DoubleWritesAnalyzer _analyzer;
+        private readonly DoubleWritesCheck _check;
 
         private readonly MockBuildCheckRegistrationContext _registrationContext;
 
-        public DoubleWritesAnalyzer_Tests()
+        public DoubleWritesCheck_Tests()
         {
-            _analyzer = new DoubleWritesAnalyzer();
+            _check = new DoubleWritesCheck();
             _registrationContext = new MockBuildCheckRegistrationContext();
-            _analyzer.RegisterActions(_registrationContext);
+            _check.RegisterActions(_registrationContext);
         }
 
-        private TaskInvocationAnalysisData MakeTaskInvocationData(string taskName, Dictionary<string, TaskInvocationAnalysisData.TaskParameter> parameters)
+        private TaskInvocationCheckData MakeTaskInvocationData(string taskName, Dictionary<string, TaskInvocationCheckData.TaskParameter> parameters)
         {
             string projectFile = NativeMethodsShared.IsWindows ? @"C:\fake\project.proj" : "/fake/project.proj";
-            return new TaskInvocationAnalysisData(
+            return new TaskInvocationCheckData(
                 projectFile,
                 null,
                 Construction.ElementLocation.EmptyLocation,
@@ -41,19 +41,19 @@ private TaskInvocationAnalysisData MakeTaskInvocationData(string taskName, Dicti
         [Fact]
         public void TestCopyTask()
         {
-            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationAnalysisData.TaskParameter>
+            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationCheckData.TaskParameter>
                 {
-                    { "SourceFiles", new TaskInvocationAnalysisData.TaskParameter("source1", IsOutput: false) },
-                    { "DestinationFolder", new TaskInvocationAnalysisData.TaskParameter("outdir", IsOutput: false) },
+                    { "SourceFiles", new TaskInvocationCheckData.TaskParameter("source1", IsOutput: false) },
+                    { "DestinationFolder", new TaskInvocationCheckData.TaskParameter("outdir", IsOutput: false) },
                 }));
-            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationAnalysisData.TaskParameter>
+            _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData("Copy", new Dictionary<string, TaskInvocationCheckData.TaskParameter>
                 {
-                    { "SourceFiles", new TaskInvocationAnalysisData.TaskParameter("source1", IsOutput: false) },
-                    { "DestinationFiles", new TaskInvocationAnalysisData.TaskParameter(Path.Combine("outdir", "source1"), IsOutput: false) },
+                    { "SourceFiles", new TaskInvocationCheckData.TaskParameter("source1", IsOutput: false) },
+                    { "DestinationFiles", new TaskInvocationCheckData.TaskParameter(Path.Combine("outdir", "source1"), IsOutput: false) },
                 }));
 
             _registrationContext.Results.Count.ShouldBe(1);
-            _registrationContext.Results[0].BuildAnalyzerRule.Id.ShouldBe("BC0102");
+            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0102");
         }
 
         [Theory]
@@ -64,17 +64,17 @@ public void TestCompilerTask(string taskName)
         {
             for (int i = 0; i < 2; i++)
             {
-                _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData(taskName, new Dictionary<string, TaskInvocationAnalysisData.TaskParameter>
+                _registrationContext.TriggerTaskInvocationAction(MakeTaskInvocationData(taskName, new Dictionary<string, TaskInvocationCheckData.TaskParameter>
                     {
-                        { "OutputAssembly", new TaskInvocationAnalysisData.TaskParameter("out.dll", IsOutput: false) },
-                        { "OutputRefAssembly", new TaskInvocationAnalysisData.TaskParameter("out_ref.dll", IsOutput: false) },
-                        { "DocumentationFile", new TaskInvocationAnalysisData.TaskParameter("out.xml", IsOutput: false) },
-                        { "PdbFile", new TaskInvocationAnalysisData.TaskParameter("out.pdb", IsOutput: false) },
+                        { "OutputAssembly", new TaskInvocationCheckData.TaskParameter("out.dll", IsOutput: false) },
+                        { "OutputRefAssembly", new TaskInvocationCheckData.TaskParameter("out_ref.dll", IsOutput: false) },
+                        { "DocumentationFile", new TaskInvocationCheckData.TaskParameter("out.xml", IsOutput: false) },
+                        { "PdbFile", new TaskInvocationCheckData.TaskParameter("out.pdb", IsOutput: false) },
                     }));
             }
 
             _registrationContext.Results.Count.ShouldBe(4);
-            _registrationContext.Results.ForEach(result => result.BuildAnalyzerRule.Id.ShouldBe("BC0102"));
+            _registrationContext.Results.ForEach(result => result.CheckRule.Id.ShouldBe("BC0102"));
         }
     }
 }
diff --git a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
index 1b1b0c5aaa4..84e9af60f02 100644
--- a/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
+++ b/src/BuildCheck.UnitTests/EditorConfig_Tests.cs
@@ -841,13 +841,13 @@ public void CanGetSectionsWithSpecialCharacters()
 build_metadata.Compile.ToRetrieve = def456
 ");
 
-        var set = AnalyzerConfigSet.Create(ImmutableArray.Create(config));
+        var set = CheckConfigSet.Create(ImmutableArray.Create(config));
 
         var sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/{releaseid}.cs");
-        Assert.Equal("abc123", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+        Assert.Equal("abc123", sectionOptions.CheckOptions["build_metadata.compile.toretrieve"]);
 
         sectionOptions = set.GetOptionsForSourcePath("/home/foo/src/Pages/#foo/HomePage.cs");
-        Assert.Equal("def456", sectionOptions.AnalyzerOptions["build_metadata.compile.toretrieve"]);
+        Assert.Equal("def456", sectionOptions.CheckOptions["build_metadata.compile.toretrieve"]);
     }*/
 
     [Fact]
@@ -895,9 +895,9 @@ public void CaseInsensitivePropKey()
     public void NonReservedKeyPreservedCaseVal()
     {
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
+            CheckConfig.ReservedKeys.Select(k => "MY_" + k + " = MY_VAL")));
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
+            CheckConfig.ReservedKeys.Select(k => KeyValuePair.Create("my_" + k, "MY_VAL")).ToList(),
             config.GlobalSection.Properties);
     }*/
 
@@ -1055,10 +1055,10 @@ public void ReservedValues()
     {
         int index = 0;
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
+            CheckConfig.ReservedValues.Select(v => "MY_KEY" + (index++) + " = " + v.ToUpperInvariant())));
         index = 0;
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
+            CheckConfig.ReservedValues.Select(v => KeyValuePair.Create("my_key" + (index++), v)).ToList(),
             config.GlobalSection.Properties);
     }
     */
@@ -1068,9 +1068,9 @@ public void ReservedValues()
     public void ReservedKeys()
     {
         var config = ParseConfigFile(string.Join(Environment.NewLine,
-            AnalyzerConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
+            CheckConfig.ReservedKeys.Select(k => k + " = MY_VAL")));
         AssertEx.SetEqual(
-            AnalyzerConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
+            CheckConfig.ReservedKeys.Select(k => KeyValuePair.Create(k, "my_val")).ToList(),
             config.GlobalSection.Properties);
     }
     */
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index 410c550db7c..f1a77277d4b 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -41,19 +41,19 @@ public EndToEndTests(ITestOutputHelper output)
     [InlineData(true, true)]
     [InlineData(false, true)]
     [InlineData(false, false)]
-    public void SampleAnalyzerIntegrationTest_AnalyzeOnBuild(bool buildInOutOfProcessNode, bool analysisRequested)
+    public void SampleCheckIntegrationTest_CheckOnBuild(bool buildInOutOfProcessNode, bool checkRequested)
     {
         PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", "warning") });
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
             $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
-            (analysisRequested ? " -analyze" : string.Empty), out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
+            (checkRequested ? " -check" : string.Empty), out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
         _env.Output.WriteLine(output);
 
         success.ShouldBeTrue();
 
-        // The analyzer warnings should appear - but only if analysis was requested.
-        if (analysisRequested)
+        // The check warnings should appear - but only if check was requested.
+        if (checkRequested)
         {
             output.ShouldContain("BC0101");
             output.ShouldContain("BC0102");
@@ -75,7 +75,7 @@ public void SampleAnalyzerIntegrationTest_AnalyzeOnBuild(bool buildInOutOfProces
     [InlineData(false, true, "error")]
     [InlineData(false, true, "suggestion")]
     [InlineData(false, false, "warning")]
-    public void SampleAnalyzerIntegrationTest_ReplayBinaryLogOfAnalyzedBuild(bool buildInOutOfProcessNode, bool analysisRequested, string BC0101Severity)
+    public void SampleCheckIntegrationTest_ReplayBinaryLogOfCheckedBuild(bool buildInOutOfProcessNode, bool checkRequested, string BC0101Severity)
     {
         PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", BC0101Severity) });
 
@@ -83,10 +83,13 @@ public void SampleAnalyzerIntegrationTest_ReplayBinaryLogOfAnalyzedBuild(bool bu
         string logFile = _env.ExpectFile(".binlog").Path;
 
         _ = RunnerUtilities.ExecBootstrapedMSBuild(
-            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore {(analysisRequested ? "-analyze" : string.Empty)} -bl:{logFile}",
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore {(checkRequested ? "-check" : string.Empty)} -bl:{logFile}",
             out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
 
-        success.ShouldBeTrue();
+        if (BC0101Severity != "error")
+        {
+            success.ShouldBeTrue();
+        }
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
          $"{logFile} -flp:logfile={Path.Combine(projectDirectory!, "logFile.log")};verbosity=diagnostic",
@@ -94,10 +97,13 @@ public void SampleAnalyzerIntegrationTest_ReplayBinaryLogOfAnalyzedBuild(bool bu
 
         _env.Output.WriteLine(output);
 
-        success.ShouldBeTrue();
+        if (BC0101Severity != "error")
+        {
+            success.ShouldBeTrue();
+        }
 
-        // The conflicting outputs warning appears - but only if analysis was requested
-        if (analysisRequested)
+        // The conflicting outputs warning appears - but only if check was requested
+        if (checkRequested)
         {
             output.ShouldContain("BC0101");
             output.ShouldContain("BC0102");
@@ -116,16 +122,19 @@ public void SampleAnalyzerIntegrationTest_ReplayBinaryLogOfAnalyzedBuild(bool bu
     [InlineData("error", "error BC0101", new string[] { "warning BC0101" })]
     [InlineData("suggestion", "BC0101", new string[] { "error BC0101", "warning BC0101" })]
     [InlineData("default", "warning BC0101", new string[] { "error BC0101" })]
-    [InlineData("none", null, new string[] { "BC0101"})]
+    [InlineData("none", null, new string[] { "BC0101" })]
     public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string expectedOutputValues, string[] unexpectedOutputValues)
     {
         PrepareSampleProjectsAndConfig(true, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", BC0101Severity) });
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
-            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -analyze",
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check",
             out bool success, false, _env.Output, timeoutMilliseconds: 120_000);
 
-        success.ShouldBeTrue();
+        if (BC0101Severity != "error")
+        {
+            success.ShouldBeTrue();
+        }
 
         if (!string.IsNullOrEmpty(expectedOutputValues))
         {
@@ -142,7 +151,7 @@ public void EditorConfig_SeverityAppliedCorrectly(string BC0101Severity, string
     [InlineData(true, true)]
     [InlineData(false, true)]
     [InlineData(false, false)]
-    public void SampleAnalyzerIntegrationTest_AnalyzeOnBinaryLogReplay(bool buildInOutOfProcessNode, bool analysisRequested)
+    public void SampleCheckIntegrationTest_CheckOnBinaryLogReplay(bool buildInOutOfProcessNode, bool checkRequested)
     {
         PrepareSampleProjectsAndConfig(buildInOutOfProcessNode, out TransientTestFile projectFile, new List<(string, string)>() { ("BC0101", "warning") });
 
@@ -156,15 +165,15 @@ public void SampleAnalyzerIntegrationTest_AnalyzeOnBinaryLogReplay(bool buildInO
         success.ShouldBeTrue();
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
-         $"{logFile} -flp:logfile={Path.Combine(projectDirectory!, "logFile.log")};verbosity=diagnostic {(analysisRequested ? "-analyze" : string.Empty)}",
+         $"{logFile} -flp:logfile={Path.Combine(projectDirectory!, "logFile.log")};verbosity=diagnostic {(checkRequested ? "-check" : string.Empty)}",
          out success, false, _env.Output, timeoutMilliseconds: 120_000);
 
         _env.Output.WriteLine(output);
 
         success.ShouldBeTrue();
 
-        // The conflicting outputs warning appears - but only if analysis was requested
-        if (analysisRequested)
+        // The conflicting outputs warning appears - but only if check was requested
+        if (checkRequested)
         {
             output.ShouldContain("BC0101");
             output.ShouldContain("BC0102");
@@ -201,24 +210,24 @@ public void NoEnvironmentVariableProperty_Test(bool? customConfigEnabled, string
             customConfigData);
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
-            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -analyze", out bool success, false, _env.Output);
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check", out bool success, false, _env.Output);
 
         output.ShouldContain(expectedMessage);
     }
 
     [Theory]
-    [InlineData(EvaluationAnalysisScope.ProjectFileOnly)]
-    [InlineData(EvaluationAnalysisScope.WorkTreeImports)]
-    [InlineData(EvaluationAnalysisScope.All)]
-    public void NoEnvironmentVariableProperty_Scoping(EvaluationAnalysisScope scope)
+    [InlineData(EvaluationCheckScope.ProjectFileOnly)]
+    [InlineData(EvaluationCheckScope.WorkTreeImports)]
+    [InlineData(EvaluationCheckScope.All)]
+    public void NoEnvironmentVariableProperty_Scoping(EvaluationCheckScope scope)
     {
         List<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? customConfigData = null;
 
         string editorconfigScope = scope switch
         {
-            EvaluationAnalysisScope.ProjectFileOnly => "project_file",
-            EvaluationAnalysisScope.WorkTreeImports => "work_tree_imports",
-            EvaluationAnalysisScope.All => "all",
+            EvaluationCheckScope.ProjectFileOnly => "project_file",
+            EvaluationCheckScope.WorkTreeImports => "work_tree_imports",
+            EvaluationCheckScope.All => "all",
             _ => throw new ArgumentOutOfRangeException(nameof(scope), scope, null),
         };
 
@@ -234,9 +243,9 @@ public void NoEnvironmentVariableProperty_Scoping(EvaluationAnalysisScope scope)
             customConfigData);
 
         string output = RunnerUtilities.ExecBootstrapedMSBuild(
-            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -analyze", out bool success, false, _env.Output);
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore -check", out bool success, false, _env.Output);
 
-        if(scope == EvaluationAnalysisScope.ProjectFileOnly)
+        if(scope == EvaluationCheckScope.ProjectFileOnly)
         {
             output.ShouldNotContain("Property is derived from environment variable: 'TestImported'. Properties should be passed explicitly using the /p option.");
         }
@@ -247,59 +256,68 @@ public void NoEnvironmentVariableProperty_Scoping(EvaluationAnalysisScope scope)
     }
 
     [Theory]
-    [InlineData("AnalysisCandidate", new[] { "CustomRule1", "CustomRule2" })]
-    [InlineData("AnalysisCandidateWithMultipleAnalyzersInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
-    public void CustomAnalyzerTest_NoEditorConfig(string analysisCandidate, string[] expectedRegisteredRules, bool expectedRejectedAnalyzers = false)
+    [InlineData("CheckCandidate", new[] { "CustomRule1", "CustomRule2" })]
+    [InlineData("CheckCandidateWithMultipleChecksInjected", new[] { "CustomRule1", "CustomRule2", "CustomRule3" }, true)]
+    public void CustomCheckTest_NoEditorConfig(string checkCandidate, string[] expectedRegisteredRules, bool expectedRejectedChecks = false)
     {
         using (var env = TestEnvironment.Create())
         {
-            var analysisCandidatePath = Path.Combine(TestAssetsRootPath, analysisCandidate);
-            AddCustomDataSourceToNugetConfig(analysisCandidatePath);
+            var checkCandidatePath = Path.Combine(TestAssetsRootPath, checkCandidate);
+            AddCustomDataSourceToNugetConfig(checkCandidatePath);
 
-            string projectAnalysisBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
-                $"{Path.Combine(analysisCandidatePath, $"{analysisCandidate}.csproj")} /m:1 -nr:False -restore -analyze -verbosity:n",
+            string projectCheckBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
+                $"{Path.Combine(checkCandidatePath, $"{checkCandidate}.csproj")} /m:1 -nr:False -restore -check -verbosity:n",
                 out bool successBuild);
-            successBuild.ShouldBeTrue(projectAnalysisBuildLog);
 
             foreach (string registeredRule in expectedRegisteredRules)
             {
-                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomAnalyzerSuccessfulAcquisition", registeredRule));
+                projectCheckBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CustomCheckSuccessfulAcquisition", registeredRule));
             }
 
-            if (expectedRejectedAnalyzers)
+            if (!expectedRejectedChecks)
             {
-                projectAnalysisBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
-                    "CustomAnalyzerBaseTypeNotAssignable",
-                    "InvalidAnalyzer",
-                    "InvalidCustomAnalyzer, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
+                successBuild.ShouldBeTrue(projectCheckBuildLog);
+            }
+            else
+            {
+                projectCheckBuildLog.ShouldContain(ResourceUtilities.FormatResourceStringStripCodeAndKeyword(
+                    "CustomCheckBaseTypeNotAssignable",
+                    "InvalidCheck",
+                    "InvalidCustomCheck, Version=15.1.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a"));
             }
         }
     }
 
     [Theory]
-    [InlineData("AnalysisCandidate", "X01234", "error", "error X01234")]
-    [InlineData("AnalysisCandidateWithMultipleAnalyzersInjected", "X01234", "warning", "warning X01234")]
-    public void CustomAnalyzerTest_WithEditorConfig(string analysisCandidate, string ruleId, string severity, string expectedMessage)
+    [InlineData("CheckCandidate", "X01234", "error", "error X01234")]
+    [InlineData("CheckCandidateWithMultipleChecksInjected", "X01234", "warning", "warning X01234")]
+    public void CustomCheckTest_WithEditorConfig(string checkCandidate, string ruleId, string severity, string expectedMessage)
     {
         using (var env = TestEnvironment.Create())
         {
-            var analysisCandidatePath = Path.Combine(TestAssetsRootPath, analysisCandidate);
-            AddCustomDataSourceToNugetConfig(analysisCandidatePath);
-            File.WriteAllText(Path.Combine(analysisCandidatePath, EditorConfigFileName), ReadEditorConfig(
+            string checkCandidatePath = Path.Combine(TestAssetsRootPath, checkCandidate);
+
+            // Can't use Transitive environment due to the need to dogfood local nuget packages.
+            AddCustomDataSourceToNugetConfig(checkCandidatePath);
+            string editorConfigName = Path.Combine(checkCandidatePath, EditorConfigFileName);
+            File.WriteAllText(editorConfigName, ReadEditorConfig(
                 new List<(string, string)>() { (ruleId, severity) },
                 ruleToCustomConfig: null,
-                analysisCandidatePath));
+                checkCandidatePath));
 
-            string projectAnalysisBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
-                $"{Path.Combine(analysisCandidatePath, $"{analysisCandidate}.csproj")} /m:1 -nr:False -restore -analyze -verbosity:n", out bool _, timeoutMilliseconds: 120_000);
+            string projectCheckBuildLog = RunnerUtilities.ExecBootstrapedMSBuild(
+                $"{Path.Combine(checkCandidatePath, $"{checkCandidate}.csproj")} /m:1 -nr:False -restore -check -verbosity:n", out bool _, timeoutMilliseconds: 1200_0000);
 
-            projectAnalysisBuildLog.ShouldContain(expectedMessage);
+            projectCheckBuildLog.ShouldContain(expectedMessage);
+            
+            // Cleanup
+            File.Delete(editorConfigName);
         }
     }
 
-    private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath)
+    private void AddCustomDataSourceToNugetConfig(string checkCandidatePath)
     {
-        var nugetTemplatePath = Path.Combine(analysisCandidatePath, "nugetTemplate.config");
+        var nugetTemplatePath = Path.Combine(checkCandidatePath, "nugetTemplate.config");
 
         var doc = new XmlDocument();
         doc.LoadXml(File.ReadAllText(nugetTemplatePath));
@@ -307,11 +325,11 @@ private void AddCustomDataSourceToNugetConfig(string analysisCandidatePath)
         {
             XmlNode? packageSourcesNode = doc.SelectSingleNode("//packageSources");
 
-            // The test packages are generated during the test project build and saved in CustomAnalyzers folder.
-            string analyzersPackagesPath = Path.Combine(Directory.GetParent(AssemblyLocation)?.Parent?.FullName ?? string.Empty, "CustomAnalyzers");
-            AddPackageSource(doc, packageSourcesNode, "Key", analyzersPackagesPath);
+            // The test packages are generated during the test project build and saved in CustomChecks folder.
+            string checksPackagesPath = Path.Combine(Directory.GetParent(AssemblyLocation)?.Parent?.FullName ?? string.Empty, "CustomChecks");
+            AddPackageSource(doc, packageSourcesNode, "Key", checksPackagesPath);
 
-            doc.Save(Path.Combine(analysisCandidatePath, "nuget.config"));
+            doc.Save(Path.Combine(checkCandidatePath, "nuget.config"));
         }
     }
 
@@ -342,7 +360,7 @@ private void PrepareSampleProjectsAndConfig(
         IEnumerable<(string RuleId, string Severity)>? ruleToSeverity,
         IEnumerable<(string RuleId, (string ConfigKey, string Value) CustomConfig)>? ruleToCustomConfig = null)
     {
-        string testAssetsFolderName = "SampleAnalyzerIntegrationTest";
+        string testAssetsFolderName = "SampleCheckIntegrationTest";
         TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
         TransientTestFile testFile = _env.CreateFile(workFolder, "somefile");
 
@@ -357,7 +375,7 @@ private void PrepareSampleProjectsAndConfig(
         _env.CreateFile(workFolder, ".editorconfig", ReadEditorConfig(ruleToSeverity, ruleToCustomConfig, testAssetsFolderName));
 
         // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
-        // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
+        // This discrepancy breaks path equality checks in MSBuild checks if we pass to MSBuild full path to the initial project.
         // See if there is a way of fixing it in the engine - tracked: https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=55702688.
         _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
 
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index 6a72903b8e6..3961ef049c3 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -17,9 +17,9 @@
   </ItemGroup>
   
   <ItemGroup Label="TestAssests">
-    <ProjectReference Include=".\TestAssets\CustomAnalyzer\CustomAnalyzer.csproj" />
-    <ProjectReference Include=".\TestAssets\CustomAnalyzer2\CustomAnalyzer2.csproj" />
-    <ProjectReference Include=".\TestAssets\InvalidCustomAnalyzer\InvalidCustomAnalyzer.csproj" />
+    <ProjectReference Include=".\TestAssets\CustomCheck\CustomCheck.csproj" />
+    <ProjectReference Include=".\TestAssets\CustomCheck2\CustomCheck2.csproj" />
+    <ProjectReference Include=".\TestAssets\InvalidCustomCheck\InvalidCustomCheck.csproj" />
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
index 883bb0f188e..5ead0d0369f 100644
--- a/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
+++ b/src/BuildCheck.UnitTests/MockBuildCheckRegistrationContext.cs
@@ -10,23 +10,23 @@ namespace Microsoft.Build.BuildCheck.UnitTests
 {
     internal sealed class MockBuildCheckRegistrationContext : IBuildCheckRegistrationContext
     {
-        private event Action<BuildCheckDataContext<TaskInvocationAnalysisData>>? _taskInvocationAction;
-        private event Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>>? _evaluatedPropertiesAction;
+        private event Action<BuildCheckDataContext<TaskInvocationCheckData>>? _taskInvocationAction;
+        private event Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>>? _evaluatedPropertiesAction;
 
         public List<BuildCheckResult> Results { get; } = new();
 
-        public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesAnalysisData>> evaluatedPropertiesAction)
+        public void RegisterEvaluatedPropertiesAction(Action<BuildCheckDataContext<EvaluatedPropertiesCheckData>> evaluatedPropertiesAction)
             => _evaluatedPropertiesAction += evaluatedPropertiesAction;
-        public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsAnalysisData>> parsedItemsAction) => throw new NotImplementedException();
+        public void RegisterParsedItemsAction(Action<BuildCheckDataContext<ParsedItemsCheckData>> parsedItemsAction) => throw new NotImplementedException();
 
-        public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationAnalysisData>> taskInvocationAction)
+        public void RegisterTaskInvocationAction(Action<BuildCheckDataContext<TaskInvocationCheckData>> taskInvocationAction)
             => _taskInvocationAction += taskInvocationAction;
 
-        public void TriggerTaskInvocationAction(TaskInvocationAnalysisData data)
+        public void TriggerTaskInvocationAction(TaskInvocationCheckData data)
         {
             if (_taskInvocationAction is not null)
             {
-                BuildCheckDataContext<TaskInvocationAnalysisData> context = new BuildCheckDataContext<TaskInvocationAnalysisData>(
+                BuildCheckDataContext<TaskInvocationCheckData> context = new BuildCheckDataContext<TaskInvocationCheckData>(
                     null!,
                     null!,
                     null!,
@@ -35,11 +35,11 @@ public void TriggerTaskInvocationAction(TaskInvocationAnalysisData data)
                 _taskInvocationAction(context);
             }
         }
-        public void TriggerEvaluatedPropertiesAction(EvaluatedPropertiesAnalysisData data)
+        public void TriggerEvaluatedPropertiesAction(EvaluatedPropertiesCheckData data)
         {
             if (_evaluatedPropertiesAction is not null)
             {
-                BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context = new BuildCheckDataContext<EvaluatedPropertiesAnalysisData>(
+                BuildCheckDataContext<EvaluatedPropertiesCheckData> context = new BuildCheckDataContext<EvaluatedPropertiesCheckData>(
                     null!,
                     null!,
                     null!,
@@ -49,7 +49,7 @@ public void TriggerEvaluatedPropertiesAction(EvaluatedPropertiesAnalysisData dat
             }
         }
 
-        private void ResultHandler(BuildAnalyzerWrapper wrapper, IAnalysisContext context, BuildAnalyzerConfigurationEffective[] configs, BuildCheckResult result)
+        private void ResultHandler(CheckWrapper wrapper, ICheckContext context, CheckConfigurationEffective[] configs, BuildCheckResult result)
             => Results.Add(result);
     }
 }
diff --git a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
index 7734c19f311..f9f5612c0bb 100644
--- a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
@@ -10,7 +10,7 @@
 
 namespace Microsoft.Build.BuildCheck.UnitTests;
 
-public class ParsedItemsAnalysisDataTests
+public class ParsedItemsCheckDataTests
 {
     [Fact]
     public void ItemsHolder_GetItemsOfType_ShouldFilterProperly()
diff --git a/src/BuildCheck.UnitTests/SharedOutputPathAnalyzer_Tests.cs b/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
similarity index 87%
rename from src/BuildCheck.UnitTests/SharedOutputPathAnalyzer_Tests.cs
rename to src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
index f7a7f2df58a..629775901a4 100644
--- a/src/BuildCheck.UnitTests/SharedOutputPathAnalyzer_Tests.cs
+++ b/src/BuildCheck.UnitTests/SharedOutputPathCheck_Tests.cs
@@ -3,31 +3,31 @@
 
 using System.Collections.Generic;
 using Microsoft.Build.Experimental.BuildCheck;
-using Microsoft.Build.Experimental.BuildCheck.Analyzers;
+using Microsoft.Build.Experimental.BuildCheck.Checks;
 using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.BuildCheck.UnitTests
 {
-    public class SharedOutputPathAnalyzer_Tests
+    public class SharedOutputPathCheck_Tests
     {
-        private readonly SharedOutputPathAnalyzer _analyzer;
+        private readonly SharedOutputPathCheck _check;
 
         private readonly MockBuildCheckRegistrationContext _registrationContext;
 
-        public SharedOutputPathAnalyzer_Tests()
+        public SharedOutputPathCheck_Tests()
         {
-            _analyzer = new SharedOutputPathAnalyzer();
+            _check = new SharedOutputPathCheck();
             _registrationContext = new MockBuildCheckRegistrationContext();
-            _analyzer.RegisterActions(_registrationContext);
+            _check.RegisterActions(_registrationContext);
         }
 
-        private EvaluatedPropertiesAnalysisData MakeEvaluatedPropertiesAction(
+        private EvaluatedPropertiesCheckData MakeEvaluatedPropertiesAction(
             string projectFile,
             Dictionary<string, string>? evaluatedProperties,
             IReadOnlyDictionary<string, (string EnvVarValue, string File, int Line, int Column)>? evaluatedEnvVars)
         {
-            return new EvaluatedPropertiesAnalysisData(
+            return new EvaluatedPropertiesCheckData(
                 projectFile,
                 null,
                 evaluatedProperties ?? new Dictionary<string, string>(),
@@ -57,7 +57,7 @@ public void TestTwoProjectsWithSameRelativeOutputPath()
                 },
                 null));
 
-            // Relative paths coincide but full does not. SharedOutputPathAnalyzer should not report it.
+            // Relative paths coincide but full does not. SharedOutputPathCheck should not report it.
             _registrationContext.Results.Count.ShouldBe(0);
         }
 
@@ -86,8 +86,8 @@ public void TestProjectsWithDifferentPathsSeparators()
 
             // 2 reports for bin and obj folders.
             _registrationContext.Results.Count.ShouldBe(2);
-            _registrationContext.Results[0].BuildAnalyzerRule.Id.ShouldBe("BC0101");
-            _registrationContext.Results[1].BuildAnalyzerRule.Id.ShouldBe("BC0101");
+            _registrationContext.Results[0].CheckRule.Id.ShouldBe("BC0101");
+            _registrationContext.Results[1].CheckRule.Id.ShouldBe("BC0101");
 
             // Check that paths are formed with correct paths separators
             string wrongPathSeparator = NativeMethodsShared.IsWindows ? "/" : "\\";
@@ -131,7 +131,7 @@ public void TestThreeProjectsWithSameOutputPath()
             _registrationContext.Results.Count.ShouldBe(4); // 4 reports for two pairs of project: (1, 2) and (1, 3).
             foreach (var result in _registrationContext.Results)
             {
-                result.BuildAnalyzerRule.Id.ShouldBe("BC0101");
+                result.CheckRule.Id.ShouldBe("BC0101");
             }
         }
     }
diff --git a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
index 99d52c7f9f1..7d109f7da15 100644
--- a/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
+++ b/src/BuildCheck.UnitTests/TaskInvocationAnalysisDataTests.cs
@@ -17,18 +17,18 @@
 
 namespace Microsoft.Build.BuildCheck.UnitTests
 {
-    public class TaskInvocationAnalysisDataTests : IDisposable
+    public class TaskInvocationCheckDataTests : IDisposable
     {
-        internal sealed class TestAnalyzer : BuildAnalyzer
+        internal sealed class TestCheck : Check
         {
-            #region BuildAnalyzer initialization
+            #region Check initialization
 
-            public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("BC0000", "TestRule", "TestDescription", "TestMessage",
-                new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning });
+            public static CheckRule SupportedRule = new CheckRule("BC0000", "TestRule", "TestDescription", "TestMessage",
+                new CheckConfiguration() { Severity = CheckResultSeverity.Warning });
 
-            public override string FriendlyName => "MSBuild.TestAnalyzer";
+            public override string FriendlyName => "MSBuild.TestCheck";
 
-            public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = [SupportedRule];
+            public override IReadOnlyList<CheckRule> SupportedRules { get; } = [SupportedRule];
 
             public override void Initialize(ConfigurationContext configurationContext)
             { }
@@ -43,29 +43,29 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             /// <summary>
             /// Stores all TaskInvocationAnalysisData reported during the build.
             /// </summary>
-            public List<TaskInvocationAnalysisData> AnalysisData = new();
+            public List<TaskInvocationCheckData> CheckData = new();
 
-            private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationAnalysisData> context)
+            private void TaskInvocationAction(BuildCheckDataContext<TaskInvocationCheckData> context)
             {
-                AnalysisData.Add(context.Data);
+                CheckData.Add(context.Data);
             }
         }
 
-        private static TestAnalyzer? s_testAnalyzer;
+        private static TestCheck? s_testCheck;
 
-        public TaskInvocationAnalysisDataTests()
+        public TaskInvocationCheckDataTests()
         {
             BuildCheckManager.s_testFactoriesPerDataSource =
             [
                 // BuildCheckDataSource.EventArgs
                 [
-                    ([TestAnalyzer.SupportedRule.Id], true, () => (s_testAnalyzer = new TestAnalyzer())),
+                    ([TestCheck.SupportedRule.Id], true, () => (s_testCheck = new TestCheck())),
                 ],
                 // BuildCheckDataSource.Execution
                 [],
             ];
 
-            s_testAnalyzer?.AnalysisData.Clear();
+            s_testCheck?.CheckData.Clear();
         }
 
         public void Dispose()
@@ -94,7 +94,7 @@ private void BuildProject(string taskInvocation)
                     result.OverallResult.ShouldBe(BuildResultCode.Success);
                 }
 
-                foreach (var data in s_testAnalyzer!.AnalysisData)
+                foreach (var data in s_testCheck!.CheckData)
                 {
                     data.ProjectFilePath.ShouldBe(testProject.ProjectFile);
                     data.TaskInvocationLocation.Line.ShouldBeGreaterThan(0);
@@ -108,8 +108,8 @@ public void ReportsSimpleTaskParameters()
         {
             BuildProject("<Message Text='Hello'/>");
 
-            s_testAnalyzer!.AnalysisData.Count.ShouldBe(1);
-            var data = s_testAnalyzer.AnalysisData[0];
+            s_testCheck!.CheckData.Count.ShouldBe(1);
+            var data = s_testCheck.CheckData[0];
             data.TaskName.ShouldBe("Message");
             data.Parameters.Count.ShouldBe(1);
             data.Parameters["Text"].IsOutput.ShouldBe(false);
@@ -130,8 +130,8 @@ public void ReportsComplexTaskParameters(string outputElement)
                 </CombinePath>
             """);
 
-            s_testAnalyzer!.AnalysisData.Count.ShouldBe(1);
-            var data = s_testAnalyzer.AnalysisData[0];
+            s_testCheck!.CheckData.Count.ShouldBe(1);
+            var data = s_testCheck.CheckData[0];
             data.TaskName.ShouldBe("CombinePath");
             data.Parameters.Count.ShouldBe(3);
 
@@ -174,8 +174,8 @@ public void TaskParameterEnumeratesValues()
             parameter5.EnumerateValues().SequenceEqual(array2).ShouldBeTrue();
             parameter5.EnumerateStringValues().SequenceEqual(["item1", "item2"]).ShouldBeTrue();
 
-            static TaskInvocationAnalysisData.TaskParameter MakeParameter(object value)
-                => new TaskInvocationAnalysisData.TaskParameter(value, IsOutput: false);
+            static TaskInvocationCheckData.TaskParameter MakeParameter(object value)
+                => new TaskInvocationCheckData.TaskParameter(value, IsOutput: false);
         }
     }
 }
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/.editorconfigtest
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/.editorconfigtest
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidate/.editorconfigtest
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/CheckCandidate.csproj
similarity index 83%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidate/CheckCandidate.csproj
index 52f65afffee..6d35fe06138 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/AnalysisCandidate.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/CheckCandidate.csproj
@@ -6,7 +6,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="CustomAnalyzer" Version="1.0.0"/>
+    <PackageReference Include="CustomCheck" Version="1.0.0"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/CheckCandidate/nugetTemplate.config
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidate/nugetTemplate.config
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidate/nugetTemplate.config
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/.editorconfigtest
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/.editorconfigtest
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
similarity index 62%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
index 0ffaa8d26b7..07695e19e8e 100644
--- a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/AnalysisCandidateWithMultipleAnalyzersInjected.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/CheckCandidateWithMultipleChecksInjected.csproj
@@ -6,9 +6,9 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <PackageReference Include="CustomAnalyzer" Version="1.0.0"/>
-    <PackageReference Include="CustomAnalyzer2" Version="1.0.0"/>
-    <PackageReference Include="InvalidCustomAnalyzer" Version="1.0.0"/>
+    <PackageReference Include="CustomCheck" Version="1.0.0"/>
+    <PackageReference Include="CustomCheck2" Version="1.0.0"/>
+    <PackageReference Include="InvalidCustomCheck" Version="1.0.0"/>
   </ItemGroup>
 
   <ItemGroup>
diff --git a/src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config b/src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/nugetTemplate.config
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/AnalysisCandidateWithMultipleAnalyzersInjected/nugetTemplate.config
rename to src/BuildCheck.UnitTests/TestAssets/CheckCandidateWithMultipleChecksInjected/nugetTemplate.config
diff --git a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
index 4e4cb1c0796..d79475be5f0 100644
--- a/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
+++ b/src/BuildCheck.UnitTests/TestAssets/Common/CommonTest.props
@@ -5,7 +5,7 @@
     <IsPackable>true</IsPackable>
     <IsShipping>false</IsShipping>
     <PackageVersion>1.0.0</PackageVersion>
-    <ArtifactsNonShippingPackagesDir>$(ArtifactsBinDir)Microsoft.Build.BuildCheck.UnitTests\CustomAnalyzers</ArtifactsNonShippingPackagesDir>
+    <ArtifactsNonShippingPackagesDir>$(ArtifactsBinDir)Microsoft.Build.BuildCheck.UnitTests\CustomChecks</ArtifactsNonShippingPackagesDir>
     <NoWarn>NU5101;NU5128;MSB3277;NU1507;NU1701;NU1702;NU5104</NoWarn>
   </PropertyGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props
deleted file mode 100644
index 31a9526dd62..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.props
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomAnalyzer.dll))</MSBuildAnalyzer>
-  </PropertyGroup>
-</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props
deleted file mode 100644
index 869000fa12f..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.props
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomAnalyzer2.dll))</MSBuildAnalyzer>
-  </PropertyGroup>
-</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
similarity index 65%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
index 5cd1d3317c0..940791d3705 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer1.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check1.cs
@@ -2,24 +2,24 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace CustomAnalyzer
+namespace CustomCheck
 {
-    public sealed class Analyzer1 : BuildAnalyzer
+    public sealed class Check1 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01234",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule1";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -27,7 +27,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
similarity index 65%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
index 714a82ae95a..4517f8eeee6 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/Analyzer2.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/Check2.cs
@@ -2,24 +2,24 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace CustomAnalyzer
+namespace CustomCheck
 {
-    public sealed class Analyzer2 : BuildAnalyzer
+    public sealed class Check2 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01235",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule2";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -27,7 +27,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.csproj
similarity index 79%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.csproj
index f27ab620690..fc81bc53eb5 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer/CustomAnalyzer.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.csproj
@@ -8,7 +8,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="CustomAnalyzer.props" Pack="true" PackagePath="build\CustomAnalyzer.props" />
+    <None Include="CustomCheck.props" Pack="true" PackagePath="build\CustomCheck.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.props b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.props
new file mode 100644
index 00000000000..f7aae0517f4
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/CustomCheck.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomCheck.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
similarity index 65%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
index c0272937c87..528b29e224a 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/Analyzer3.cs
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/Check3.cs
@@ -2,24 +2,24 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Experimental.BuildCheck;
 
-namespace CustomAnalyzer2
+namespace CustomCheck2
 {
-    public sealed class Analyzer3 : BuildAnalyzer
+    public sealed class Check3 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static CheckRule SupportedRule = new CheckRule(
             "X01235",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new CheckConfiguration());
 
         public override string FriendlyName => "CustomRule3";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
         public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
@@ -27,7 +27,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.csproj
similarity index 78%
rename from src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
rename to src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.csproj
index a405546f1cc..5d4396dea07 100644
--- a/src/BuildCheck.UnitTests/TestAssets/CustomAnalyzer2/CustomAnalyzer2.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.csproj
@@ -8,7 +8,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="CustomAnalyzer2.props" Pack="true" PackagePath="build\CustomAnalyzer2.props" />
+    <None Include="CustomCheck2.props" Pack="true" PackagePath="build\CustomCheck2.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.props b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.props
new file mode 100644
index 00000000000..f2377250f91
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/CustomCheck2.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)CustomCheck2.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/README.md b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/CustomCheck2/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
deleted file mode 100644
index e5f466ce414..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidAnalyzer.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿using System.Collections.Generic;
-
-namespace InvalidCustomAnalyzer
-{
-    public sealed class InvalidAnalyzer
-    {
-        public string FriendlyName => "InvalidAnalyzer";
-    }
-}
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
deleted file mode 100644
index 52a9bab57c0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.props
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<Project>
-  <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)InvalidCustomAnalyzer.dll))</MSBuildAnalyzer>
-  </PropertyGroup>
-</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs
new file mode 100644
index 00000000000..0b727549e95
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCheck.cs
@@ -0,0 +1,9 @@
+﻿using System.Collections.Generic;
+
+namespace InvalidCustomCheck
+{
+    public sealed class InvalidCheck
+    {
+        public string FriendlyName => "InvalidCheck";
+    }
+}
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.csproj
similarity index 76%
rename from src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
rename to src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.csproj
index 4ef7f0674ca..81c7c28efe7 100644
--- a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomAnalyzer/InvalidCustomAnalyzer.csproj
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.csproj
@@ -8,7 +8,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="InvalidCustomAnalyzer.props" Pack="true" PackagePath="build\InvalidCustomAnalyzer.props" />
+    <None Include="InvalidCustomCheck.props" Pack="true" PackagePath="build\InvalidCustomCheck.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.props b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.props
new file mode 100644
index 00000000000..01867df6b8a
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/InvalidCustomCheck.props
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project>
+  <PropertyGroup>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)InvalidCustomCheck.dll))</MSBuildCheck>
+  </PropertyGroup>
+</Project>
diff --git a/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/src/BuildCheck.UnitTests/TestAssets/InvalidCustomCheck/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigtest b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
similarity index 79%
rename from src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigtest
rename to src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
index b6fe5e17ba9..57d36981808 100644
--- a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/.editorconfigtest
+++ b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/.editorconfigtest
@@ -9,5 +9,5 @@ build_check.BC0103.Severity=warning
 build_check.BC0103.CustomConfig=dummy
 
 build_check.COND0543.Severity=Error
-build_check.COND0543.EvaluationAnalysisScope=AnalyzedProjectOnly
+build_check.COND0543.EvaluationCheckScope=CheckedProjectOnly
 build_check.COND0543.CustomSwitch=QWERTY
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/ImportedFile1 b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/ImportedFile1
rename to src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/ImportedFile1
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project1 b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project1
rename to src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project1
diff --git a/src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project2 b/src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2
similarity index 100%
rename from src/BuildCheck.UnitTests/TestAssets/SampleAnalyzerIntegrationTest/Project2
rename to src/BuildCheck.UnitTests/TestAssets/SampleCheckIntegrationTest/Project2
diff --git a/src/Framework/BuildCheck/BuildCheckEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
index 248a2d193fc..4b4e95960c6 100644
--- a/src/Framework/BuildCheck/BuildCheckEventArgs.cs
+++ b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
@@ -79,7 +79,7 @@ internal BuildCheckAcquisitionEventArgs()
     }
 
     /// <summary>
-    /// Gets the path to the analyzer assembly that needs to be loaded into the application context.
+    /// Gets the path to the check assembly that needs to be loaded into the application context.
     /// </summary>
     /// <remarks>
     /// The <see cref="AcquisitionPath"/> property contains the file system path to the assembly
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 6851120de48..0ef451ba979 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -2622,11 +2622,11 @@ public void EndToEndVersionMessage(string arguments, bool shouldContainVersionMe
         [InlineData("/v:minimal /bl", MessageImportance.Low)] // v:minimal but with binary logger so everything must be logged
         [InlineData("/v:quiet /bl", MessageImportance.Low)] // v:quiet but with binary logger so everything must be logged
 
-        [InlineData("/v:diagnostic /analyze", MessageImportance.Low)]
-        [InlineData("/v:detailed /analyze", MessageImportance.Low)]
-        [InlineData("/v:normal /analyze", MessageImportance.Normal)]
-        [InlineData("/v:minimal /analyze", MessageImportance.High)]
-        [InlineData("/v:quiet /analyze", MessageImportance.High)]
+        [InlineData("/v:diagnostic /check", MessageImportance.Low)]
+        [InlineData("/v:detailed /check", MessageImportance.Low)]
+        [InlineData("/v:normal /check", MessageImportance.Normal)]
+        [InlineData("/v:minimal /check", MessageImportance.High)]
+        [InlineData("/v:quiet /check", MessageImportance.High)]
 
         [InlineData("/v:diagnostic /tl", MessageImportance.Low)]
         [InlineData("/v:detailed /tl", MessageImportance.Low)]
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 8f9d947b310..ae5646ca7d1 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -100,7 +100,7 @@ internal enum ParameterizedSwitch
             WarningsNotAsErrors,
             WarningsAsMessages,
             BinaryLogger,
-            Analyze,
+            Check,
             Restore,
             ProfileEvaluation,
             RestoreProperty,
@@ -277,7 +277,7 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "warnnotaserror", "noerr" },           ParameterizedSwitch.WarningsNotAsErrors,        null,                           true,           "MissingWarnNotAsErrorParameterError", true,   false,   "HelpMessage_40_WarnNotAsErrorSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "warnasmessage", "nowarn" },           ParameterizedSwitch.WarningsAsMessages,         null,                           true,           "MissingWarnAsMessageParameterError",  true,   false,   "HelpMessage_29_WarnAsMessageSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "binarylogger", "bl" },                ParameterizedSwitch.BinaryLogger,               null,                           false,          null,                                  true,   false,   "HelpMessage_30_BinaryLoggerSwitch"),
-            new ParameterizedSwitchInfo(  new string[] { "analyze", },                          ParameterizedSwitch.Analyze,                    null,                           false,          null,                                  true,   false,   null),
+            new ParameterizedSwitchInfo(  new string[] { "check", },                            ParameterizedSwitch.Check,                      null,                           false,          null,                                  true,   false,   null),
             new ParameterizedSwitchInfo(  new string[] { "restore", "r" },                      ParameterizedSwitch.Restore,                    null,                           false,          null,                                  true,   false,   "HelpMessage_31_RestoreSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "profileevaluation", "prof" },         ParameterizedSwitch.ProfileEvaluation,          null,                           false,          "MissingProfileParameterError",        true,   false,   "HelpMessage_32_ProfilerSwitch"),
             new ParameterizedSwitchInfo(  new string[] { "restoreproperty", "rp" },             ParameterizedSwitch.RestoreProperty,            null,                           true,           "MissingPropertyError",                true,   false,   "HelpMessage_33_RestorePropertySwitch"),
@@ -467,7 +467,7 @@ internal CommandLineSwitches()
                 Debug.Assert(i == (int)(s_parameterizedSwitchesMap[i].parameterizedSwitch),
                     "The map of parameterized switches must be ordered the same way as the ParameterizedSwitch enumeration.");
                 if (s_parameterizedSwitchesMap[i].parameterizedSwitch is not ParameterizedSwitch.Project and
-                    not ParameterizedSwitch.NodeMode and not ParameterizedSwitch.Analyze)
+                    not ParameterizedSwitch.NodeMode and not ParameterizedSwitch.Check)
                 {
                     Debug.Assert(!string.IsNullOrEmpty(s_parameterizedSwitchesMap[i].resourceId), "All parameterized switches should be cross-checked against the help message strings except from project switch");
                 }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index bfc061b5a1d..017237c35d8 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2784,8 +2784,8 @@ private static bool ProcessCommandLineSwitches(
         private static bool IsBuildCheckEnabled(CommandLineSwitches commandLineSwitches)
         {
             // Opt-in behavior to be determined by: https://github.com/dotnet/msbuild/issues/9723
-            bool isAnalysisEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Analyze);
-            return isAnalysisEnabled;
+            bool isBuildCheckEnabled = commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.Check);
+            return isBuildCheckEnabled;
         }
 
         private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)
diff --git a/template_feed/README.md b/template_feed/README.md
index f2b021d3647..f6bd358ffcd 100644
--- a/template_feed/README.md
+++ b/template_feed/README.md
@@ -1,9 +1,9 @@
-## MSBuild Custom Analyzer Template Package
+## MSBuild Custom Check Template Package
 
-The package contains the template designed to streamline the creation of MSBuild analyzer libraries.
+The package contains the template designed to streamline the creation of MSBuild check libraries.
 | Template name | Short name | Description|
 |---|---|---|
-|MSBuild Custom Analyzer Template|`msbuildanalyzer`|A project for creating a MSBuild analyzer library that targets .NET Standard.|
+|MSBuild Custom Check Template|`msbuildcheck`|A project for creating a MSBuild check library that targets .NET Standard.|
 
 The package is available for download from nuget.org.
 Please feel to contribute or provide the feedback in discussions or via opening the issue in dotnet/msbuild repo.
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/README.md b/template_feed/content/Microsoft.AnalyzerTemplate/README.md
deleted file mode 100644
index 4f29145e7f0..00000000000
--- a/template_feed/content/Microsoft.AnalyzerTemplate/README.md
+++ /dev/null
@@ -1,21 +0,0 @@
-# MSBuild Custom Analyzer Template
-
-## Overview
-MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
-
-## Features
-- Simplified template for creating MSBuild analyzer libraries.
-- Targeting .NET Standard for cross-platform compatibility.
-- Provides a starting point for implementing custom analysis rules.
-
-## Getting Started
-To use the MSBuild Custom Analyzer Template, follow these steps:
-1. Install the template using the following command:
-   ```bash
-   dotnet new install msbuildanalyzer
-2. Instantiate a custom template:
-   ```bash
-   dotnet new msbuildanalyzer -n <ProjectName>
-
-### Prerequisites
-- .NET SDK installed on your machine.
\ No newline at end of file
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
similarity index 70%
rename from template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
rename to template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
index 90cc4dcb803..3647f61a8dc 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/.template.config/template.json
+++ b/template_feed/content/Microsoft.CheckTemplate/.template.config/template.json
@@ -5,27 +5,27 @@
     "Common",
     "Library"
   ],
-  "name": "MSBuild custom analyzer skeleton project.",
+  "name": "MSBuild custom check skeleton project.",
   "generatorVersions": "[1.0.0.0-*)",
-  "description": "A project for creating a MSBuild analyzer library that targets .NET Standard",
-  "groupIdentity": "Microsoft.AnalyzerTemplate",
-  "identity": "Microsoft.AnalyzerTemplate",
-  "shortName": "msbuildanalyzer",
+  "description": "A project for creating a MSBuild check library that targets .NET Standard",
+  "groupIdentity": "Microsoft.CheckTemplate",
+  "identity": "Microsoft.CheckTemplate",
+  "shortName": "msbuildcheck",
   "tags": {
     "language": "C#",
     "type": "project"
   },
-  "sourceName": "Company.AnalyzerTemplate",
+  "sourceName": "Company.CheckTemplate",
   "preferNameDirectory": true,
   "primaryOutputs": [
     {
-      "path": "Company.AnalyzerTemplate.csproj"
+      "path": "Company.CheckTemplate.csproj"
     }
   ],
   "symbols": {
     "MicrosoftBuildVersion": {
       "type": "parameter",
-      "description": "Overrides the default Microsoft.Build version where analyzer's interfaces are placed",
+      "description": "Overrides the default Microsoft.Build version where check's interfaces are placed",
       "datatype": "text",
       "defaultValue": "17.12.0",
       "replaces": "1.0.0-MicrosoftBuildPackageVersion",
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs b/template_feed/content/Microsoft.CheckTemplate/Check1.cs
similarity index 59%
rename from template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
rename to template_feed/content/Microsoft.CheckTemplate/Check1.cs
index 78dae77947b..2a44afef40c 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Analyzer1.cs
+++ b/template_feed/content/Microsoft.CheckTemplate/Check1.cs
@@ -2,24 +2,24 @@
 using Microsoft.Build.Experimental.BuildCheck;
 using System.Collections.Generic;
 
-namespace Company.AnalyzerTemplate
+namespace Company.CheckTemplate
 {
-    public sealed class Analyzer1 : BuildAnalyzer
+    public sealed class Check1 : Check
     {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        public static BuildCheckRule SupportedRule = new CheckRule(
             "X01234",
             "Title",
             "Description",
             "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+            new BuildCheckConfiguration());
 
-        public override string FriendlyName => "Company.Analyzer1";
+        public override string FriendlyName => "Company.Check1";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+        public override IReadOnlyList<CheckRule> SupportedRules { get; } = new List<CheckRule>() { SupportedRule };
 
         public override void Initialize(ConfigurationContext configurationContext)
         {
-            // configurationContext to be used only if analyzer needs external configuration data.
+            // configurationContext to be used only if check needs external configuration data.
         }
 
 
@@ -28,7 +28,7 @@ public override void RegisterActions(IBuildCheckRegistrationContext registration
             registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
         }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesCheckData> context)
         {
             context.ReportResult(BuildCheckResult.Create(
                 SupportedRule,
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
similarity index 94%
rename from template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
rename to template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
index 33d8c992326..009b2ad1fe0 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
+++ b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.csproj
@@ -10,7 +10,7 @@
   </PropertyGroup>
 
   <ItemGroup>
-    <None Include="Company.AnalyzerTemplate.props" Pack="true" PackagePath="build\Company.AnalyzerTemplate.props" />
+    <None Include="Company.CheckTemplate.props" Pack="true" PackagePath="build\Company.CheckTemplate.props" />
     <Content Include="README.md" />
   </ItemGroup>
 
diff --git a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props
similarity index 63%
rename from template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
rename to template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props
index 5a606b3cac6..050b67fb18a 100644
--- a/template_feed/content/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.props
+++ b/template_feed/content/Microsoft.CheckTemplate/Company.CheckTemplate.props
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Project>
   <PropertyGroup>
-	  <MSBuildAnalyzer>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)Company.AnalyzerTemplate.dll))</MSBuildAnalyzer>
+	  <MSBuildCheck>$([MSBuild]::RegisterBuildCheck($(MSBuildThisFileDirectory)Company.CheckTemplate.dll))</MSBuildCheck>
   </PropertyGroup>
   <ItemGroup>
     <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
diff --git a/template_feed/content/Microsoft.CheckTemplate/README.md b/template_feed/content/Microsoft.CheckTemplate/README.md
new file mode 100644
index 00000000000..ef41e00277e
--- /dev/null
+++ b/template_feed/content/Microsoft.CheckTemplate/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Check Template
+
+## Overview
+MSBuild Custom Check Template is a .NET template designed to streamline the creation of MSBuild check libraries. This template facilitates the development of custom checks targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild check libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom check rules.
+
+## Getting Started
+To use the MSBuild Custom Check Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildcheck
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildcheck -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
