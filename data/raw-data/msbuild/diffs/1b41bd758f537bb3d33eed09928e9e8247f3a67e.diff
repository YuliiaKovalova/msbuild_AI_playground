diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.SerializationInfoTable.cs b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.SerializationInfoTable.cs
new file mode 100644
index 00000000000..f4a06553361
--- /dev/null
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.SerializationInfoTable.cs
@@ -0,0 +1,28 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+// Used by Hashtable and Dictionary's SeralizationInfo .ctor's to store the SeralizationInfo
+// object until OnDeserialization is called.
+
+using System.Threading;
+using System.Runtime.CompilerServices;
+using System.Runtime.Serialization;
+
+namespace Microsoft.Build.Collections
+{
+    internal static partial class HashHelpers
+    {
+        private static ConditionalWeakTable<object, SerializationInfo>? s_serializationInfoTable;
+
+        public static ConditionalWeakTable<object, SerializationInfo> SerializationInfoTable
+        {
+            get
+            {
+                if (s_serializationInfoTable == null)
+                    Interlocked.CompareExchange(ref s_serializationInfoTable, new ConditionalWeakTable<object, SerializationInfo>(), null);
+
+                return s_serializationInfoTable;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
index 735c08b2a37..942015167c3 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashHelpers.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Diagnostics;
+using System.Runtime.CompilerServices;
 #if !SILVERLIGHT
 #if FEATURE_CONSTRAINED_EXECUTION
 using System.Runtime.ConstrainedExecution;
@@ -16,8 +17,15 @@ namespace Microsoft.Build.Collections
     /// <summary>
     /// Duplicated because internal to mscorlib
     /// </summary>
-    internal static class HashHelpers
+    internal static partial class HashHelpers
     {
+        public const uint HashCollisionThreshold = 100;
+
+        // This is the maximum prime smaller than Array.MaxArrayLength
+        internal const int MaxPrimeArrayLength = 0x7FEFFFFD;
+
+        public const int HashPrime = 101;
+
         // Table of prime numbers to use as hash table sizes. 
         // The entry used for capacity is the smallest prime number in this array
         // that is larger than twice the previous capacity. 
@@ -60,23 +68,23 @@ internal static int GetPrime(int min)
         {
             Debug.Assert(min >= 0, "min less than zero; handle overflow checking before calling HashHelpers");
 
-            for (int i = 0; i < primes.Length; i++)
+            foreach (int prime in primes)
             {
-                int prime = primes[i];
                 if (prime >= min)
                 {
                     return prime;
                 }
             }
 
-            // Outside of our predefined table. Compute the hard way. 
-            for (int i = (min | 1); i < Int32.MaxValue; i += 2)
+            // Outside of our predefined table. Compute the hard way.
+            for (int i = (min | 1); i < int.MaxValue; i += 2)
             {
-                if (IsPrime(i))
+                if (IsPrime(i) && ((i - 1) % HashPrime != 0))
                 {
                     return i;
                 }
             }
+
             return min;
         }
 
@@ -92,15 +100,35 @@ internal static int ExpandPrime(int oldSize)
 
             // Allow the hashtables to grow to maximum possible size (~2G elements) before encoutering capacity overflow.
             // Note that this check works even when _items.Length overflowed thanks to the (uint) cast
-            if ((uint) newSize > MaxPrimeArrayLength)
+            if ((uint)newSize > MaxPrimeArrayLength && MaxPrimeArrayLength > oldSize)
             {
+                Debug.Assert(MaxPrimeArrayLength == GetPrime(MaxPrimeArrayLength), "Invalid MaxPrimeArrayLength");
                 return MaxPrimeArrayLength;
             }
 
             return GetPrime(newSize);
         }
 
-        // This is the maximum prime smaller than Array.MaxArrayLength
-        internal const int MaxPrimeArrayLength = 0x7FEFFFFD;
+        /// <summary>Returns approximate reciprocal of the divisor: ceil(2**64 / divisor).</summary>
+        /// <remarks>This should only be used on 64-bit.</remarks>
+        public static ulong GetFastModMultiplier(uint divisor) =>
+            ulong.MaxValue / divisor + 1;
+
+        /// <summary>Performs a mod operation using the multiplier pre-computed with <see cref="GetFastModMultiplier"/>.</summary>
+        /// <remarks>This should only be used on 64-bit.</remarks>
+        [MethodImpl(MethodImplOptions.AggressiveInlining)]
+        public static uint FastMod(uint value, uint divisor, ulong multiplier)
+        {
+            // We use modified Daniel Lemire's fastmod algorithm (https://github.com/dotnet/runtime/pull/406),
+            // which allows to avoid the long multiplication if the divisor is less than 2**31.
+            Debug.Assert(divisor <= int.MaxValue);
+
+            // This is equivalent of (uint)Math.BigMul(multiplier * value, divisor, out _). This version
+            // is faster than BigMul currently because we only need the high bits.
+            uint highbits = (uint)(((((multiplier * value) >> 32) + 1) * divisor) >> 32);
+
+            Debug.Assert(highbits == value % divisor);
+            return highbits;
+        }
     }
 }
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index 50349f0f2e8..5c96c2ebdbb 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -79,10 +79,10 @@ namespace Microsoft.Build.Collections
     /// the same time. 
     /// </summary>
     /// <typeparam name="T"></typeparam>
-    [DebuggerTypeProxy(typeof(Microsoft.Build.Collections.HashSetDebugView<>))]
+    [DebuggerTypeProxy(typeof(HashSetDebugView<>))]
     [DebuggerDisplay("Count = {Count}")]
     [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Justification = "By design")]
-    [Serializable()]
+    [Serializable]
 #if FEATURE_SECURITY_PERMISSIONS
     [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
 #endif
@@ -93,10 +93,7 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
     {
         // store lower 31 bits of hash code
         private const int Lower31BitMask = 0x7FFFFFFF;
-#if NEVER
-        // cutoff point, above which we won't do stackallocs. This corresponds to 100 integers.
-        private const int StackAllocThreshold = 100;
-#endif
+
         // when constructing a hashset from an existing collection, it may contain duplicates, 
         // so this is used as the max acceptable excess ratio of capacity to count. Note that
         // this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
@@ -105,10 +102,10 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
         private const int ShrinkThreshold = 3;
 
         // constants for serialization
-        private const String CapacityName = "Capacity";
-        private const String ElementsName = "Elements";
-        private const String ComparerName = "Comparer";
-        private const String VersionName = "Version";
+        private const string CapacityName = "Capacity"; // Do not rename (binary serialization)
+        private const string ElementsName = "Elements"; // Do not rename (binary serialization)
+        private const string ComparerName = "Comparer"; // Do not rename (binary serialization)
+        private const string VersionName = "Version"; // Do not rename (binary serialization)
 
         private int[] _buckets;
         private Slot[] _slots;
@@ -120,10 +117,7 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
         private int _version;
         private bool _readOnly;
 
-        // temporary variable needed during deserialization
-        private SerializationInfo _siInfo;
-
-#region Constructors
+ #region Constructors
 
         public RetrievableEntryHashSet(IEqualityComparer<string> comparer)
         {
@@ -203,7 +197,7 @@ protected RetrievableEntryHashSet(SerializationInfo info, StreamingContext conte
             // deserialized and we have a reasonable estimate that GetHashCode is not going to 
             // fail.  For the time being, we'll just cache this.  The graph is not valid until 
             // OnDeserialization has been called.
-            _siInfo = info;
+            HashHelpers.SerializationInfoTable.Add(this, info);
         }
 
 #endregion
@@ -213,10 +207,10 @@ public ICollection<string> Keys
         {
             get
             {
-                var keys = new string[_count];
+                string[] keys = new string[_count];
 
                 int i = 0;
-                foreach (var item in this)
+                foreach (T item in this)
                 {
                     keys[i] = item.Key;
                     i++;
@@ -227,10 +221,7 @@ public ICollection<string> Keys
         }
 
         // Convenience to minimise change to callers used to dictionaries
-        public ICollection<T> Values
-        {
-            get { return this; }
-        }
+        public ICollection<T> Values => this;
 
 #region ICollection<T> methods
 
@@ -244,7 +235,7 @@ internal T this[string name]
 
             set
             {
-                Debug.Assert(String.Equals(name, value.Key, StringComparison.Ordinal));
+                Debug.Assert(string.Equals(name, value.Key, StringComparison.Ordinal));
                 Add(value);
             }
         }
@@ -254,10 +245,7 @@ internal T this[string name]
         /// interface. The other Add method returns bool indicating whether item was added.
         /// </summary>
         /// <param name="item">item to add</param>
-        void ICollection<T>.Add(T item)
-        {
-            AddEvenIfPresent(item);
-        }
+        void ICollection<T>.Add(T item) => AddEvenIfPresent(item);
 
         /// <summary>
         /// Remove all items from this set. This clears the elements but not the underlying 
@@ -275,32 +263,31 @@ public void Clear()
                 Debug.Assert(_buckets != null, "m_buckets was null but m_lastIndex > 0");
 
                 // clear the elements so that the gc can reclaim the references.
-                // clear only up to m_lastIndex for m_slots 
+                // clear only up to m_lastIndex for m_slots
                 Array.Clear(_slots, 0, _lastIndex);
+#if NET6_0_OR_GREATER
+                Array.Clear(_buckets);
+#else
                 Array.Clear(_buckets, 0, _buckets.Length);
+#endif
                 _lastIndex = 0;
                 _count = 0;
                 _freeList = -1;
             }
+
             _version++;
         }
 
         // Convenience
-        internal bool Contains(string key)
-        {
-            return Get(key) != null;
-        }
+        internal bool Contains(string key) => Get(key) != null;
 
         bool ICollection<KeyValuePair<string, T>>.Contains(KeyValuePair<string, T> entry)
         {
-            Debug.Assert(String.Equals(entry.Key, entry.Value.Key, StringComparison.Ordinal));
+            Debug.Assert(string.Equals(entry.Key, entry.Value.Key, StringComparison.Ordinal));
             return Get(entry.Value.Key) != null;
         }
 
-        public bool ContainsKey(string key)
-        {
-            return Get(key) != null;
-        }
+        public bool ContainsKey(string key) => Get(key) != null;
 
         T IDictionary<string, T>.this[string name]
         {
@@ -313,10 +300,7 @@ T IDictionary<string, T>.this[string name]
         /// </summary>
         /// <param name="item">item to check for containment</param>
         /// <returns>true if item contained; false if not</returns>
-        public bool Contains(T item)
-        {
-            return Get(item.Key) != null;
-        }
+        public bool Contains(T item) => Get(item.Key) != null;
 
         // Convenience to minimise change to callers used to dictionaries
         public bool TryGetValue(string key, out T item)
@@ -330,10 +314,7 @@ public bool TryGetValue(string key, out T item)
         /// </summary>
         /// <param name="key">key to check for containment</param>
         /// <returns>true if item contained; false if not</returns>
-        public T Get(string key)
-        {
-            return GetCore(key, 0, key?.Length ?? 0);
-        }
+        public T Get(string key) => GetCore(key, 0, key?.Length ?? 0);
 
         /// <summary>
         /// Gets the item if any with the given name
@@ -386,22 +367,16 @@ private T GetCore(string item, int index, int length)
         /// </summary>
         /// <param name="array">array to add items to</param>
         /// <param name="arrayIndex">index to start at</param>
-        public void CopyTo(T[] array, int arrayIndex)
-        {
-            CopyTo(array, arrayIndex, _count);
-        }
+        public void CopyTo(T[] array, int arrayIndex) => CopyTo(array, arrayIndex, _count);
 
         /// <summary>
         /// Remove entry that compares equal to T
         /// </summary>        
-        public bool Remove(T item)
-        {
-            return Remove(item.Key);
-        }
+        public bool Remove(T item) => Remove(item.Key);
 
         bool ICollection<KeyValuePair<string, T>>.Remove(KeyValuePair<string, T> entry)
         {
-            Debug.Assert(String.Equals(entry.Key, entry.Value.Key, StringComparison.Ordinal));
+            Debug.Assert(string.Equals(entry.Key, entry.Value.Key, StringComparison.Ordinal));
             return Remove(entry.Value);
         }
 
@@ -462,35 +437,23 @@ public bool Remove(string item)
         /// <summary>
         /// Number of elements in this hashset
         /// </summary>
-        public int Count
-        {
-            get { return _count; }
-        }
+        public int Count => _count;
 
         /// <summary>
         /// Whether this is readonly
         /// </summary>
-        public bool IsReadOnly
-        {
-            get { return _readOnly; }
-        }
+        public bool IsReadOnly => _readOnly;
 
         /// <summary>
         /// Permanently prevent changes to the set.
         /// </summary>
-        internal void MakeReadOnly()
-        {
-            _readOnly = true;
-        }
+        internal void MakeReadOnly() => _readOnly = true;
 
 #endregion
 
 #region IEnumerable methods
 
-        public Enumerator GetEnumerator()
-        {
-            return new Enumerator(this);
-        }
+        public Enumerator GetEnumerator() => new Enumerator(this);
 
         IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator()
         {
@@ -500,15 +463,9 @@ IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnu
             }
         }
 
-        IEnumerator<T> IEnumerable<T>.GetEnumerator()
-        {
-            return new Enumerator(this);
-        }
+        IEnumerator<T> IEnumerable<T>.GetEnumerator() => new Enumerator(this);
 
-        IEnumerator IEnumerable.GetEnumerator()
-        {
-            return new Enumerator(this);
-        }
+        IEnumerator IEnumerable.GetEnumerator() => new Enumerator(this);
 
 #endregion
 
@@ -539,9 +496,10 @@ public virtual void GetObjectData(SerializationInfo info, StreamingContext conte
 
 #region IDeserializationCallback methods
 
-        public virtual void OnDeserialization(Object sender)
+        public virtual void OnDeserialization(object sender)
         {
-            if (_siInfo == null)
+            HashHelpers.SerializationInfoTable.TryGetValue(this, out SerializationInfo siInfo);
+            if (siInfo == null)
             {
                 // It might be necessary to call OnDeserialization from a container if the 
                 // container object also implements OnDeserialization. However, remoting will 
@@ -550,8 +508,8 @@ public virtual void OnDeserialization(Object sender)
                 return;
             }
 
-            int capacity = _siInfo.GetInt32(CapacityName);
-            _comparer = (IEqualityComparer<string>)_siInfo.GetValue(ComparerName, typeof(IEqualityComparer<string>));
+            int capacity = siInfo.GetInt32(CapacityName);
+            _comparer = (IEqualityComparer<string>)siInfo.GetValue(ComparerName, typeof(IEqualityComparer<string>));
             _constrainedComparer = _comparer as IConstrainedEqualityComparer<string>;
             _freeList = -1;
 
@@ -560,7 +518,7 @@ public virtual void OnDeserialization(Object sender)
                 _buckets = new int[capacity];
                 _slots = new Slot[capacity];
 
-                T[] array = (T[])_siInfo.GetValue(ElementsName, typeof(T[]));
+                T[] array = (T[])siInfo.GetValue(ElementsName, typeof(T[]));
 
                 if (array == null)
                 {
@@ -578,8 +536,8 @@ public virtual void OnDeserialization(Object sender)
                 _buckets = null;
             }
 
-            _version = _siInfo.GetInt32(VersionName);
-            _siInfo = null;
+            _version = siInfo.GetInt32(VersionName);
+            HashHelpers.SerializationInfoTable.Remove(this);
         }
 
 #endregion
@@ -605,7 +563,7 @@ void IDictionary<string, T>.Add(string key, T item)
 
         void ICollection<KeyValuePair<string, T>>.Add(KeyValuePair<string, T> entry)
         {
-            Debug.Assert(String.Equals(entry.Key, entry.Value.Key, StringComparison.Ordinal));
+            Debug.Assert(string.Equals(entry.Key, entry.Value.Key, StringComparison.Ordinal));
 
             AddEvenIfPresent(entry.Value);
         }
@@ -632,366 +590,13 @@ public void UnionWith(IEnumerable<T> other)
             }
         }
 
-#if NEVER
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Takes the intersection of this set with other. Modifies this set.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes: 
-                                                                                                                                                        /// We get better perf if other is a hashset using same equality comparer, because we 
-                                                                                                                                                        /// get constant contains check in other. Resulting cost is O(n1) to iterate over this.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// If we can't go above route, iterate over the other and mark intersection by checking
-                                                                                                                                                        /// contains in this. Then loop over and delete any unmarked elements. Total cost is n2+n1. 
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Attempts to return early based on counts alone, using the property that the 
-                                                                                                                                                        /// intersection of anything with the empty set is the empty set.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other">enumerable with items to add </param>
-                                                                                                                                                        public void IntersectWith(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // intersection of anything with empty set is empty set, so return if count is 0
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // if other is empty, intersection is empty set; remove all elements and we're done
-                                                                                                                                                            // can only figure this out if implements ICollection<T>. (IEnumerable<T> has no count)
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                if (otherAsCollection.Count == 0) {
-                                                                                                                                                                    Clear();
-                                                                                                                                                                    return;
-                                                                                                                                                                }
-
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // faster if other is a hashset using same equality comparer; so check 
-                                                                                                                                                                // that other is a hashset using the same equality comparer.
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    IntersectWithHashSetWithSameEC(otherAsSet);
-                                                                                                                                                                    return;
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            IntersectWithEnumerable(other);
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Remove items in other from this set. Modifies this set.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other">enumerable with items to remove</param>
-                                                                                                                                                        public void ExceptWith(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // this is already the enpty set; return
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // special case if other is this; a set minus itself is the empty set
-                                                                                                                                                            if (other == this) {
-                                                                                                                                                                Clear();
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // remove every element in other from this
-                                                                                                                                                            foreach (T element in other) {
-                                                                                                                                                                Remove(element);
-                                                                                                                                                            }
-                                                                                                                                                        }
-
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Takes symmetric difference (XOR) with other and this set. Modifies this set.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other">enumerable with items to XOR</param>
-                                                                                                                                                        public void SymmetricExceptWith(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // if set is empty, then symmetric difference is other
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                UnionWith(other);
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            // special case this; the symmetric difference of a set with itself is the empty set
-                                                                                                                                                            if (other == this) {
-                                                                                                                                                                Clear();
-                                                                                                                                                                return;
-                                                                                                                                                            }
-
-                                                                                                                                                            RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                            // If other is a HashSet, it has unique elements according to its equality comparer,
-                                                                                                                                                            // but if they're using different equality comparers, then assumption of uniqueness
-                                                                                                                                                            // will fail. So first check if other is a hashset using the same equality comparer;
-                                                                                                                                                            // symmetric except is a lot faster and avoids bit array allocations if we can assume
-                                                                                                                                                            // uniqueness
-                                                                                                                                                            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                SymmetricExceptWithUniqueHashSet(otherAsSet);
-                                                                                                                                                            }
-                                                                                                                                                            else {
-                                                                                                                                                                SymmetricExceptWithEnumerable(other);
-                                                                                                                                                            }
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a subset of other.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If this is the empty set, then it's a subset of anything, including the empty set
-                                                                                                                                                        /// 2. If other has unique elements according to this equality comparer, and this has more
-                                                                                                                                                        /// elements than other, then it can't be a subset.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Furthermore, if other is a hashset using the same equality comparer, we can use a 
-                                                                                                                                                        /// faster element-wise check.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a subset of other; false if not</returns>
-                                                                                                                                                        public bool IsSubsetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // The empty set is a subset of any set
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return true;
-                                                                                                                                                            }
-
-                                                                                                                                                            RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                            // faster if other has unique elements according to this equality comparer; so check 
-                                                                                                                                                            // that other is a hashset using the same equality comparer.
-                                                                                                                                                            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                // if this has more elements then it can't be a subset
-                                                                                                                                                                if (m_count > otherAsSet.Count) {
-                                                                                                                                                                    return false;
-                                                                                                                                                                }
-
-                                                                                                                                                                // already checked that we're using same equality comparer. simply check that 
-                                                                                                                                                                // each element in this is contained in other.
-                                                                                                                                                                return IsSubsetOfHashSetWithSameEC(otherAsSet);
-                                                                                                                                                            }
-                                                                                                                                                            else {
-                                                                                                                                                                ElementCount result = CheckUniqueAndUnfoundElements(other, false);
-                                                                                                                                                                return (result.uniqueCount == m_count && result.unfoundCount >= 0);
-                                                                                                                                                            }
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a proper subset of other (i.e. strictly contained in)
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If this is the empty set, then it's a proper subset of a set that contains at least
-                                                                                                                                                        /// one element, but it's not a proper subset of the empty set.
-                                                                                                                                                        /// 2. If other has unique elements according to this equality comparer, and this has >=
-                                                                                                                                                        /// the number of elements in other, then this can't be a proper subset.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Furthermore, if other is a hashset using the same equality comparer, we can use a 
-                                                                                                                                                        /// faster element-wise check.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a proper subset of other; false if not</returns>
-                                                                                                                                                        public bool IsProperSubsetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                // the empty set is a proper subset of anything but the empty set
-                                                                                                                                                                if (m_count == 0) {
-                                                                                                                                                                    return otherAsCollection.Count > 0;
-                                                                                                                                                                }
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // faster if other is a hashset (and we're using same equality comparer)
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    if (m_count >= otherAsSet.Count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                    // this has strictly less than number of items in other, so the following
-                                                                                                                                                                    // check suffices for proper subset.
-                                                                                                                                                                    return IsSubsetOfHashSetWithSameEC(otherAsSet);
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            ElementCount result = CheckUniqueAndUnfoundElements(other, false);
-                                                                                                                                                            return (result.uniqueCount == m_count && result.unfoundCount > 0);
-
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a superset of other
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If other has no elements (it's the empty set), then this is a superset, even if this
-                                                                                                                                                        /// is also the empty set.
-                                                                                                                                                        /// 2. If other has unique elements according to this equality comparer, and this has less 
-                                                                                                                                                        /// than the number of elements in other, then this can't be a superset
-                                                                                                                                                        /// 
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a superset of other; false if not</returns>
-                                                                                                                                                        public bool IsSupersetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // try to fall out early based on counts
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                // if other is the empty set then this is a superset
-                                                                                                                                                                if (otherAsCollection.Count == 0) {
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // try to compare based on counts alone if other is a hashset with
-                                                                                                                                                                // same equality comparer
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    if (otherAsSet.Count > m_count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            return ContainsAllElements(other);
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this is a proper superset of other (i.e. other strictly contained in this)
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Implementation Notes: 
-                                                                                                                                                        /// This is slightly more complicated than above because we have to keep track if there
-                                                                                                                                                        /// was at least one element not contained in other.
-                                                                                                                                                        /// 
-                                                                                                                                                        /// The following properties are used up-front to avoid element-wise checks:
-                                                                                                                                                        /// 1. If this is the empty set, then it can't be a proper superset of any set, even if 
-                                                                                                                                                        /// other is the empty set.
-                                                                                                                                                        /// 2. If other is an empty set and this contains at least 1 element, then this is a proper
-                                                                                                                                                        /// superset.
-                                                                                                                                                        /// 3. If other has unique elements according to this equality comparer, and other's count
-                                                                                                                                                        /// is greater than or equal to this count, then this can't be a proper superset
-                                                                                                                                                        /// 
-                                                                                                                                                        /// Furthermore, if other has unique elements according to this equality comparer, we can
-                                                                                                                                                        /// use a faster element-wise check.
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if this is a proper superset of other; false if not</returns>
-                                                                                                                                                        public bool IsProperSupersetOf(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            // the empty set isn't a proper superset of any set.
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return false;
-                                                                                                                                                            }
-
-                                                                                                                                                            ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                            if (otherAsCollection != null) {
-                                                                                                                                                                // if other is the empty set then this is a superset
-                                                                                                                                                                if (otherAsCollection.Count == 0) {
-                                                                                                                                                                    // note that this has at least one element, based on above check
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                                RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                                // faster if other is a hashset with the same equality comparer
-                                                                                                                                                                if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                    if (otherAsSet.Count >= m_count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                    // now perform element check
-                                                                                                                                                                    return ContainsAllElements(otherAsSet);
-                                                                                                                                                                }
-                                                                                                                                                            }
-                                                                                                                                                            // couldn't fall out in the above cases; do it the long way
-                                                                                                                                                            ElementCount result = CheckUniqueAndUnfoundElements(other, true);
-                                                                                                                                                            return (result.uniqueCount < m_count && result.unfoundCount == 0);
-
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this set overlaps other (i.e. they share at least one item)
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns>true if these have at least one common element; false if disjoint</returns>
-                                                                                                                                                        public bool Overlaps(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            if (m_count == 0) {
-                                                                                                                                                                return false;
-                                                                                                                                                            }
-
-                                                                                                                                                            foreach (T element in other) {
-                                                                                                                                                                if (Contains(element)) {
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                            }
-                                                                                                                                                            return false;
-                                                                                                                                                        }
-
-                                                                                                                                                        /// <summary>
-                                                                                                                                                        /// Checks if this and other contain the same elements. This is set equality: 
-                                                                                                                                                        /// duplicates and order are ignored
-                                                                                                                                                        /// </summary>
-                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                        /// <returns></returns>
-                                                                                                                                                        public bool SetEquals(IEnumerable<T> other) {
-                                                                                                                                                            if (other == null) {
-                                                                                                                                                                throw new ArgumentNullException("other");
-                                                                                                                                                            }
-                                                                                                                                                            Contract.EndContractBlock();
-
-                                                                                                                                                            RetrievableEntryHashSet<T> otherAsSet = other as RetrievableEntryHashSet<T>;
-                                                                                                                                                            // faster if other is a hashset and we're using same equality comparer
-                                                                                                                                                            if (otherAsSet != null && AreEqualityComparersEqual(this, otherAsSet)) {
-                                                                                                                                                                // attempt to return early: since both contain unique elements, if they have 
-                                                                                                                                                                // different counts, then they can't be equal
-                                                                                                                                                                if (m_count != otherAsSet.Count) {
-                                                                                                                                                                    return false;
-                                                                                                                                                                }
-
-                                                                                                                                                                // already confirmed that the sets have the same number of distinct elements, so if
-                                                                                                                                                                // one is a superset of the other then they must be equal
-                                                                                                                                                                return ContainsAllElements(otherAsSet);
-                                                                                                                                                            }
-                                                                                                                                                            else {
-                                                                                                                                                                ICollection<T> otherAsCollection = other as ICollection<T>;
-                                                                                                                                                                if (otherAsCollection != null) {
-                                                                                                                                                                    // if this count is 0 but other contains at least one element, they can't be equal
-                                                                                                                                                                    if (m_count == 0 && otherAsCollection.Count > 0) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                }
-                                                                                                                                                                ElementCount result = CheckUniqueAndUnfoundElements(other, true);
-                                                                                                                                                                return (result.uniqueCount == m_count && result.unfoundCount == 0);
-                                                                                                                                                            }
-                                                                                                                                                        }
-#endif
-
         // Copy all elements into array starting at zero based index specified
-        [SuppressMessage("Microsoft.Usage", "CA2208:InstantiateArgumentExceptionsCorrectly", Justification = "Decently informative for an exception that will probably never actually see the light of day")]
         void ICollection<KeyValuePair<string, T>>.CopyTo(KeyValuePair<string, T>[] array, int index)
         {
             if (index < 0 || Count > array.Length - index)
-                throw new ArgumentException("index");
+            {
+                throw new ArgumentException(nameof(index));
+            }
 
             int i = index;
             foreach (var entry in this)
@@ -1001,15 +606,15 @@ void ICollection<KeyValuePair<string, T>>.CopyTo(KeyValuePair<string, T>[] array
             }
         }
 
-        public void CopyTo(T[] array) { CopyTo(array, 0, _count); }
+        public void CopyTo(T[] array) => CopyTo(array, 0, _count);
 
-        [SuppressMessage("Microsoft.Usage", "CA2208:InstantiateArgumentExceptionsCorrectly", Justification = "Decently informative for an exception that will probably never actually see the light of day")]
         public void CopyTo(T[] array, int arrayIndex, int count)
         {
             if (array == null)
             {
                 throw new ArgumentNullException(nameof(array));
             }
+
             Contract.EndContractBlock();
 
             // check array index valid index into array
@@ -1029,7 +634,7 @@ public void CopyTo(T[] array, int arrayIndex, int count)
             // count of 0; subsequent check takes care of the rest)
             if (arrayIndex > array.Length || count > array.Length - arrayIndex)
             {
-                throw new ArgumentException("arrayIndex");
+                throw new ArgumentException(null, nameof(arrayIndex));
             }
 
             int numCopied = 0;
@@ -1043,46 +648,6 @@ public void CopyTo(T[] array, int arrayIndex, int count)
             }
         }
 
-#if NEVER
-                                                                                                                                                    /// <summary>
-                                                                                                                                                    /// Remove elements that match specified predicate. Returns the number of elements removed
-                                                                                                                                                    /// </summary>
-                                                                                                                                                    /// <param name="match"></param>
-                                                                                                                                                    /// <returns></returns>
-                                                                                                                                                    public int RemoveWhere(Predicate<T> match) {
-                                                                                                                                                        if (match == null) {
-                                                                                                                                                            throw new ArgumentNullException("match");
-                                                                                                                                                        }
-                                                                                                                                                        Contract.EndContractBlock();
-
-                                                                                                                                                        int numRemoved = 0;
-                                                                                                                                                        for (int i = 0; i < m_lastIndex; i++) {
-                                                                                                                                                            if (m_slots[i].hashCode >= 0) {
-                                                                                                                                                                // cache value in case delegate removes it
-                                                                                                                                                                T value = m_slots[i].value;
-                                                                                                                                                                if (match(value)) {
-                                                                                                                                                                    // check again that remove actually removed it
-                                                                                                                                                                    if (Remove(value)) {
-                                                                                                                                                                        numRemoved++;
-                                                                                                                                                                    }
-                                                                                                                                                                }
-                                                                                                                                                            }
-                                                                                                                                                        }
-                                                                                                                                                        return numRemoved;
-                                                                                                                                                    }
-
-        /// <summary>
-        /// Gets the IEqualityComparer that is used to determine equality of keys for 
-        /// the HashSet.
-        /// </summary>
-        public IEqualityComparer<IKeyed> Comparer
-        {
-            get
-            {
-                return _comparer;
-            }
-        }
-#endif
         /// <summary>
         /// Sets the capacity of this list to the size of the list (rounded up to nearest prime),
         /// unless count is 0, in which case we release references.
@@ -1142,18 +707,6 @@ public void TrimExcess()
             }
         }
 
-#if NEVER
-#if !SILVERLIGHT || FEATURE_NETCORE
-                                                                                                                                                    /// <summary>
-                                                                                                                                                    /// Used for deep equality of HashSet testing
-                                                                                                                                                    /// </summary>
-                                                                                                                                                    /// <returns></returns>
-                                                                                                                                                    public static IEqualityComparer<RetrievableEntryHashSet<T>> CreateSetComparer() {
-                                                                                                                                                        return new HashSetEqualityComparer<T>();
-                                                                                                                                                    }
-#endif
-#endif
-
 #endregion
 
 #region Helper methods
@@ -1251,6 +804,7 @@ private bool AddEvenIfPresent(T value)
                 if (_lastIndex == _slots.Length)
                 {
                     IncreaseCapacity();
+
                     // this will change during resize
                     bucket = hashCode % _buckets.Length;
                 }
@@ -1272,7 +826,7 @@ private bool AddEvenIfPresent(T value)
         /// </summary>
         internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet<T> other)
         {
-            if (Object.ReferenceEquals(this, other))
+            if (ReferenceEquals(this, other))
             {
                 return true;
             }
@@ -1285,7 +839,7 @@ internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet<T> other)
             T ours;
             foreach (T element in other)
             {
-                if (!TryGetValue(element.Key, out ours) || !Object.ReferenceEquals(element, ours))
+                if (!TryGetValue(element.Key, out ours) || !ReferenceEquals(element, ours))
                 {
                     return false;
                 }
@@ -1294,338 +848,6 @@ internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet<T> other)
             return true;
         }
 
-#if NEVER
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// Checks if this contains of other's elements. Iterates over other's elements and 
-                                                                                                                                                                        /// returns false as soon as it finds an element in other that's not in this.
-                                                                                                                                                                        /// Used by SupersetOf, ProperSupersetOf, and SetEquals.
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        /// <returns></returns>
-                                                                                                                                                                        private bool ContainsAllElements(IEnumerable<T> other) {
-                                                                                                                                                                            foreach (T element in other) {
-                                                                                                                                                                                if (!Contains(element)) {
-                                                                                                                                                                                    return false;
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                            return true;
-                                                                                                                                                                        }
-
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// Implementation Notes:
-                                                                                                                                                                        /// If other is a hashset and is using same equality comparer, then checking subset is 
-                                                                                                                                                                        /// faster. Simply check that each element in this is in other.
-                                                                                                                                                                        /// 
-                                                                                                                                                                        /// Note: if other doesn't use same equality comparer, then Contains check is invalid,
-                                                                                                                                                                        /// which is why callers must take are of this.
-                                                                                                                                                                        /// 
-                                                                                                                                                                        /// If callers are concerned about whether this is a proper subset, they take care of that.
-                                                                                                                                                                        ///
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        /// <returns></returns>
-                                                                                                                                                                        private bool IsSubsetOfHashSetWithSameEC(RetrievableEntryHashSet<T> other) {
-
-                                                                                                                                                                            foreach (T item in this) {
-                                                                                                                                                                                if (!other.Contains(item)) {
-                                                                                                                                                                                    return false;
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                            return true;
-                                                                                                                                                                        }
-
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// If other is a hashset that uses same equality comparer, intersect is much faster 
-                                                                                                                                                                        /// because we can use other's Contains
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        private void IntersectWithHashSetWithSameEC(RetrievableEntryHashSet<T> other) {
-                                                                                                                                                                            for (int i = 0; i < m_lastIndex; i++) {
-                                                                                                                                                                                if (m_slots[i].hashCode >= 0) {
-                                                                                                                                                                                    T item = m_slots[i].value;
-                                                                                                                                                                                    if (!other.Contains(item)) {
-                                                                                                                                                                                        Remove(item);
-                                                                                                                                                                                    }
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-
-                                                                                                                                                                        /// <summary>
-                                                                                                                                                                        /// Iterate over other. If contained in this, mark an element in bit array corresponding to
-                                                                                                                                                                        /// its position in m_slots. If anything is unmarked (in bit array), remove it.
-                                                                                                                                                                        /// 
-                                                                                                                                                                        /// This attempts to allocate on the stack, if below StackAllocThreshold.
-                                                                                                                                                                        /// </summary>
-                                                                                                                                                                        /// <param name="other"></param>
-                                                                                                                                                                        [System.Security.SecuritySafeCritical]
-                                                                                                                                                                        private unsafe void IntersectWithEnumerable(IEnumerable<T> other) {
-                                                                                                                                                                            Debug.Assert(m_buckets != null, "m_buckets shouldn't be null; callers should check first");
-
-                                                                                                                                                                            // keep track of current last index; don't want to move past the end of our bit array
-                                                                                                                                                                            // (could happen if another thread is modifying the collection)
-                                                                                                                                                                            int originalLastIndex = m_lastIndex;
-                                                                                                                                                                            int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-                                                                                                                                                                            BitHelper bitHelper;
-                                                                                                                                                                            if (intArrayLength <= StackAllocThreshold) {
-                                                                                                                                                                                int* bitArrayPtr = stackalloc int[intArrayLength];
-                                                                                                                                                                                bitHelper = new BitHelper(bitArrayPtr, intArrayLength);
-                                                                                                                                                                            }
-                                                                                                                                                                            else {
-                                                                                                                                                                                int[] bitArray = new int[intArrayLength];
-                                                                                                                                                                                bitHelper = new BitHelper(bitArray, intArrayLength);
-                                                                                                                                                                            }
-
-                                                                                                                                                                            // mark if contains: find index of in slots array and mark corresponding element in bit array
-                                                                                                                                                                            foreach (T item in other) {
-                                                                                                                                                                                int index = InternalIndexOf(item);
-                                                                                                                                                                                if (index >= 0) {
-                                                                                                                                                                                    bitHelper.MarkBit(index);
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-
-                                                                                                                                                                            // if anything unmarked, remove it. Perf can be optimized here if BitHelper had a 
-                                                                                                                                                                            // FindFirstUnmarked method.
-                                                                                                                                                                            for (int i = 0; i < originalLastIndex; i++) {
-                                                                                                                                                                                if (m_slots[i].hashCode >= 0 && !bitHelper.IsMarked(i)) {
-                                                                                                                                                                                    Remove(m_slots[i].value);
-                                                                                                                                                                                }
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-
-                                                                                                                                                                    /// <summary>
-                                                                                                                                                                    /// Used internally by set operations which have to rely on bit array marking. This is like
-                                                                                                                                                                    /// Contains but returns index in slots array. 
-                                                                                                                                                                    /// </summary>
-                                                                                                                                                                    /// <param name="item"></param>
-                                                                                                                                                                    /// <returns></returns>
-                                                                                                                                                                    private int InternalIndexOf(T item) {
-                                                                                                                                                                        Debug.Assert(m_buckets != null, "m_buckets was null; callers should check first");
-
-                                                                                                                                                                        int hashCode = InternalGetHashCode(item);
-                                                                                                                                                                        for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                                                                                                                                                                            if ((m_slots[i].hashCode) == hashCode && m_comparer.Equals(m_slots[i].value, item)) {
-                                                                                                                                                                                return i;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                        // wasn't found
-                                                                                                                                                                        return -1;
-                                                                                                                                                                    }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// if other is a set, we can assume it doesn't have duplicate elements, so use this
-                                                                                                                                                                /// technique: if can't remove, then it wasn't present in this set, so add.
-                                                                                                                                                                /// 
-                                                                                                                                                                /// As with other methods, callers take care of ensuring that other is a hashset using the
-                                                                                                                                                                /// same equality comparer.
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="other"></param>
-                                                                                                                                                                private void SymmetricExceptWithUniqueHashSet(RetrievableEntryHashSet<T> other) {
-                                                                                                                                                                    foreach (T item in other) {
-                                                                                                                                                                        if (!Remove(item)) {
-                                                                                                                                                                            AddEvenIfPresent(item);
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// Implementation notes:
-                                                                                                                                                                /// 
-                                                                                                                                                                /// Used for symmetric except when other isn't a HashSet. This is more tedious because 
-                                                                                                                                                                /// other may contain duplicates. HashSet technique could fail in these situations:
-                                                                                                                                                                /// 1. Other has a duplicate that's not in this: HashSet technique would add then 
-                                                                                                                                                                /// remove it.
-                                                                                                                                                                /// 2. Other has a duplicate that's in this: HashSet technique would remove then add it
-                                                                                                                                                                /// back.
-                                                                                                                                                                /// In general, its presence would be toggled each time it appears in other. 
-                                                                                                                                                                /// 
-                                                                                                                                                                /// This technique uses bit marking to indicate whether to add/remove the item. If already
-                                                                                                                                                                /// present in collection, it will get marked for deletion. If added from other, it will
-                                                                                                                                                                /// get marked as something not to remove.
-                                                                                                                                                                ///
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="other"></param>
-                                                                                                                                                                [System.Security.SecuritySafeCritical]
-                                                                                                                                                                private unsafe void SymmetricExceptWithEnumerable(IEnumerable<T> other) {
-                                                                                                                                                                    int originalLastIndex = m_lastIndex;
-                                                                                                                                                                    int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-                                                                                                                                                                    BitHelper itemsToRemove;
-                                                                                                                                                                    BitHelper itemsAddedFromOther;
-                                                                                                                                                                    if (intArrayLength <= StackAllocThreshold / 2) {
-                                                                                                                                                                        int* itemsToRemovePtr = stackalloc int[intArrayLength];
-                                                                                                                                                                        itemsToRemove = new BitHelper(itemsToRemovePtr, intArrayLength);
-
-                                                                                                                                                                        int* itemsAddedFromOtherPtr = stackalloc int[intArrayLength];
-                                                                                                                                                                        itemsAddedFromOther = new BitHelper(itemsAddedFromOtherPtr, intArrayLength);
-                                                                                                                                                                    }
-                                                                                                                                                                    else {
-                                                                                                                                                                        int[] itemsToRemoveArray = new int[intArrayLength];
-                                                                                                                                                                        itemsToRemove = new BitHelper(itemsToRemoveArray, intArrayLength);
-
-                                                                                                                                                                        int[] itemsAddedFromOtherArray = new int[intArrayLength];
-                                                                                                                                                                        itemsAddedFromOther = new BitHelper(itemsAddedFromOtherArray, intArrayLength);
-                                                                                                                                                                    }
-
-                                                                                                                                                                    foreach (T item in other) {
-                                                                                                                                                                        int location = 0;
-                                                                                                                                                                        bool added = AddOrGetLocation(item, out location);
-                                                                                                                                                                        if (added) {
-                                                                                                                                                                            // wasn't already present in collection; flag it as something not to remove
-                                                                                                                                                                            // *NOTE* if location is out of range, we should ignore. BitHelper will
-                                                                                                                                                                            // detect that it's out of bounds and not try to mark it. But it's 
-                                                                                                                                                                            // expected that location could be out of bounds because adding the item
-                                                                                                                                                                            // will increase m_lastIndex as soon as all the free spots are filled.
-                                                                                                                                                                            itemsAddedFromOther.MarkBit(location);
-                                                                                                                                                                        }
-                                                                                                                                                                        else {
-                                                                                                                                                                            // already there...if not added from other, mark for remove. 
-                                                                                                                                                                            // *NOTE* Even though BitHelper will check that location is in range, we want 
-                                                                                                                                                                            // to check here. There's no point in checking items beyond originalLastIndex
-                                                                                                                                                                            // because they could not have been in the original collection
-                                                                                                                                                                            if (location < originalLastIndex && !itemsAddedFromOther.IsMarked(location)) {
-                                                                                                                                                                                itemsToRemove.MarkBit(location);
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-
-                                                                                                                                                                    // if anything marked, remove it
-                                                                                                                                                                    for (int i = 0; i < originalLastIndex; i++) {
-                                                                                                                                                                        if (itemsToRemove.IsMarked(i)) {
-                                                                                                                                                                            Remove(m_slots[i].value);
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// Add if not already in hashset. Returns an out param indicating index where added. This 
-                                                                                                                                                                /// is used by SymmetricExcept because it needs to know the following things:
-                                                                                                                                                                /// - whether the item was already present in the collection or added from other
-                                                                                                                                                                /// - where it's located (if already present, it will get marked for removal, otherwise
-                                                                                                                                                                /// marked for keeping)
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="value"></param>
-                                                                                                                                                                /// <param name="location"></param>
-                                                                                                                                                                /// <returns></returns>
-                                                                                                                                                                private bool AddOrGetLocation(T value, out int location) {
-                                                                                                                                                                    Debug.Assert(m_buckets != null, "m_buckets is null, callers should have checked");
-
-                                                                                                                                                                    int hashCode = InternalGetHashCode(value);
-                                                                                                                                                                    int bucket = hashCode % m_buckets.Length;
-                                                                                                                                                                    for (int i = m_buckets[hashCode % m_buckets.Length] - 1; i >= 0; i = m_slots[i].next) {
-                                                                                                                                                                        if (m_slots[i].hashCode == hashCode && m_comparer.Equals(m_slots[i].value, value)) {
-                                                                                                                                                                            location = i;
-                                                                                                                                                                            return false; //already present
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                    int index;
-                                                                                                                                                                    if (m_freeList >= 0) {
-                                                                                                                                                                        index = m_freeList;
-                                                                                                                                                                        m_freeList = m_slots[index].next;
-                                                                                                                                                                    }
-                                                                                                                                                                    else {
-                                                                                                                                                                        if (m_lastIndex == m_slots.Length) {
-                                                                                                                                                                            IncreaseCapacity();
-                                                                                                                                                                            // this will change during resize
-                                                                                                                                                                            bucket = hashCode % m_buckets.Length;
-                                                                                                                                                                        }
-                                                                                                                                                                        index = m_lastIndex;
-                                                                                                                                                                        m_lastIndex++;
-                                                                                                                                                                    }
-                                                                                                                                                                    m_slots[index].hashCode = hashCode;
-                                                                                                                                                                    m_slots[index].value = value;
-                                                                                                                                                                    m_slots[index].next = m_buckets[bucket] - 1;
-                                                                                                                                                                    m_buckets[bucket] = index + 1;
-                                                                                                                                                                    m_count++;
-                                                                                                                                                                    m_version++;
-                                                                                                                                                                    location = index;
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-
-                                                                                                                                                                /// <summary>
-                                                                                                                                                                /// Determines counts that can be used to determine equality, subset, and superset. This
-                                                                                                                                                                /// is only used when other is an IEnumerable and not a HashSet. If other is a HashSet
-                                                                                                                                                                /// these properties can be checked faster without use of marking because we can assume 
-                                                                                                                                                                /// other has no duplicates.
-                                                                                                                                                                /// 
-                                                                                                                                                                /// The following count checks are performed by callers:
-                                                                                                                                                                /// 1. Equals: checks if unfoundCount = 0 and uniqueFoundCount = m_count; i.e. everything 
-                                                                                                                                                                /// in other is in this and everything in this is in other
-                                                                                                                                                                /// 2. Subset: checks if unfoundCount >= 0 and uniqueFoundCount = m_count; i.e. other may
-                                                                                                                                                                /// have elements not in this and everything in this is in other
-                                                                                                                                                                /// 3. Proper subset: checks if unfoundCount > 0 and uniqueFoundCount = m_count; i.e
-                                                                                                                                                                /// other must have at least one element not in this and everything in this is in other
-                                                                                                                                                                /// 4. Proper superset: checks if unfound count = 0 and uniqueFoundCount strictly less
-                                                                                                                                                                /// than m_count; i.e. everything in other was in this and this had at least one element
-                                                                                                                                                                /// not contained in other.
-                                                                                                                                                                /// 
-                                                                                                                                                                /// An earlier implementation used delegates to perform these checks rather than returning
-                                                                                                                                                                /// an ElementCount struct; however this was changed due to the perf overhead of delegates.
-                                                                                                                                                                /// </summary>
-                                                                                                                                                                /// <param name="other"></param>
-                                                                                                                                                                /// <param name="returnIfUnfound">Allows us to finish faster for equals and proper superset
-                                                                                                                                                                /// because unfoundCount must be 0.</param>
-                                                                                                                                                                /// <returns></returns>
-                                                                                                                                                                [System.Security.SecuritySafeCritical]
-                                                                                                                                                                private unsafe ElementCount CheckUniqueAndUnfoundElements(IEnumerable<T> other, bool returnIfUnfound) {
-                                                                                                                                                                    ElementCount result;
-
-                                                                                                                                                                    // need special case in case this has no elements. 
-                                                                                                                                                                    if (m_count == 0) {
-                                                                                                                                                                        int numElementsInOther = 0;
-                                                                                                                                                                        foreach (T item in other) {
-                                                                                                                                                                            numElementsInOther++;
-                                                                                                                                                                            // break right away, all we want to know is whether other has 0 or 1 elements
-                                                                                                                                                                            break;
-                                                                                                                                                                        }
-                                                                                                                                                                        result.uniqueCount = 0;
-                                                                                                                                                                        result.unfoundCount = numElementsInOther;
-                                                                                                                                                                        return result;
-                                                                                                                                                                    }
-
-
-                                                                                                                                                                    Debug.Assert((m_buckets != null) && (m_count > 0), "m_buckets was null but count greater than 0");
-
-                                                                                                                                                                    int originalLastIndex = m_lastIndex;
-                                                                                                                                                                    int intArrayLength = BitHelper.ToIntArrayLength(originalLastIndex);
-
-                                                                                                                                                                    BitHelper bitHelper;
-                                                                                                                                                                    if (intArrayLength <= StackAllocThreshold) {
-                                                                                                                                                                        int* bitArrayPtr = stackalloc int[intArrayLength];
-                                                                                                                                                                        bitHelper = new BitHelper(bitArrayPtr, intArrayLength);
-                                                                                                                                                                    }
-                                                                                                                                                                    else {
-                                                                                                                                                                        int[] bitArray = new int[intArrayLength];
-                                                                                                                                                                        bitHelper = new BitHelper(bitArray, intArrayLength);
-                                                                                                                                                                    }
-
-                                                                                                                                                                    // count of items in other not found in this
-                                                                                                                                                                    int unfoundCount = 0;
-                                                                                                                                                                    // count of unique items in other found in this
-                                                                                                                                                                    int uniqueFoundCount = 0;
-
-                                                                                                                                                                    foreach (T item in other) {
-                                                                                                                                                                        int index = InternalIndexOf(item);
-                                                                                                                                                                        if (index >= 0) {
-                                                                                                                                                                            if (!bitHelper.IsMarked(index)) {
-                                                                                                                                                                                // item hasn't been seen yet
-                                                                                                                                                                                bitHelper.MarkBit(index);
-                                                                                                                                                                                uniqueFoundCount++;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                        else {
-                                                                                                                                                                            unfoundCount++;
-                                                                                                                                                                            if (returnIfUnfound) {
-                                                                                                                                                                                break;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-
-                                                                                                                                                                    result.uniqueCount = uniqueFoundCount;
-                                                                                                                                                                    result.unfoundCount = unfoundCount;
-                                                                                                                                                                    return result;
-                                                                                                                                                                }
-#endif
         /// <summary>
         /// Copies this to an array. Used for DebugView
         /// </summary>
@@ -1636,79 +858,13 @@ internal T[] ToArray()
             CopyTo(newArray);
             return newArray;
         }
-
-#if NEVER
-                                                                                                                                                            /// <summary>
-                                                                                                                                                            /// Internal method used for HashSetEqualityComparer. Compares set1 and set2 according 
-                                                                                                                                                            /// to specified comparer.
-                                                                                                                                                            /// 
-                                                                                                                                                            /// Because items are hashed according to a specific equality comparer, we have to resort
-                                                                                                                                                            /// to n^2 search if they're using different equality comparers.
-                                                                                                                                                            /// </summary>
-                                                                                                                                                            /// <param name="set1"></param>
-                                                                                                                                                            /// <param name="set2"></param>
-                                                                                                                                                            /// <param name="comparer"></param>
-                                                                                                                                                            /// <returns></returns>
-                                                                                                                                                            internal static bool HashSetEquals(RetrievableEntryHashSet<T> set1, RetrievableEntryHashSet<T> set2, IEqualityComparer<T> comparer) {
-                                                                                                                                                                // handle null cases first
-                                                                                                                                                                if (set1 == null) {
-                                                                                                                                                                    return (set2 == null);
-                                                                                                                                                                }
-                                                                                                                                                                else if (set2 == null) {
-                                                                                                                                                                    // set1 != null
-                                                                                                                                                                    return false;
-                                                                                                                                                                }
-
-                                                                                                                                                                // all comparers are the same; this is faster
-                                                                                                                                                                if (AreEqualityComparersEqual(set1, set2)) {
-                                                                                                                                                                    if (set1.Count != set2.Count) {
-                                                                                                                                                                        return false;
-                                                                                                                                                                    }
-                                                                                                                                                                    // suffices to check subset
-                                                                                                                                                                    foreach (T item in set2) {
-                                                                                                                                                                        if (!set1.Contains(item)) {
-                                                                                                                                                                            return false;
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                                else {  // n^2 search because items are hashed according to their respective ECs
-                                                                                                                                                                    foreach (T set2Item in set2) {
-                                                                                                                                                                        bool found = false;
-                                                                                                                                                                        foreach (T set1Item in set1) {
-                                                                                                                                                                            if (comparer.Equals(set2Item, set1Item)) {
-                                                                                                                                                                                found = true;
-                                                                                                                                                                                break;
-                                                                                                                                                                            }
-                                                                                                                                                                        }
-                                                                                                                                                                        if (!found) {
-                                                                                                                                                                            return false;
-                                                                                                                                                                        }
-                                                                                                                                                                    }
-                                                                                                                                                                    return true;
-                                                                                                                                                                }
-                                                                                                                                                            }
-
-                                                                                                                                                            /// <summary>
-                                                                                                                                                            /// Checks if equality comparers are equal. This is used for algorithms that can
-                                                                                                                                                            /// speed up if it knows the other item has unique elements. I.e. if they're using 
-                                                                                                                                                            /// different equality comparers, then uniqueness assumption between sets break.
-                                                                                                                                                            /// </summary>
-                                                                                                                                                            /// <param name="set1"></param>
-                                                                                                                                                            /// <param name="set2"></param>
-                                                                                                                                                            /// <returns></returns>
-                                                                                                                                                            private static bool AreEqualityComparersEqual(RetrievableEntryHashSet<T> set1, RetrievableEntryHashSet<T> set2) {
-                                                                                                                                                                return set1.Comparer.Equals(set2.Comparer);
-        }
-#endif
        
         private int InternalGetHashCode(string item, int index, int length)
         {
             // No need to check for null 'item' as we own all comparers
-            if (_constrainedComparer != null)
-                return _constrainedComparer.GetHashCode(item, index, length) & Lower31BitMask;
-
-            return InternalGetHashCode(item);
+            return _constrainedComparer != null
+                ? _constrainedComparer.GetHashCode(item, index, length) & Lower31BitMask
+                : InternalGetHashCode(item);
         }
 
         /// <summary>
@@ -1716,14 +872,7 @@ private int InternalGetHashCode(string item, int index, int length)
         /// </summary>
         /// <param name="item"></param>
         /// <returns>hash code</returns>
-        private int InternalGetHashCode(string item)
-        {
-            if (item == null)
-            {
-                return 0;
-            }
-            return _comparer.GetHashCode(item) & Lower31BitMask;
-        }
+        private int InternalGetHashCode(string item) => item == null ? 0 : _comparer.GetHashCode(item) & Lower31BitMask;
 
 #endregion
 
@@ -1747,18 +896,18 @@ internal struct Slot
         [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
 #endif
 #endif
-        public struct Enumerator : IEnumerator<T>, System.Collections.IEnumerator
+        public struct Enumerator : IEnumerator<T>, IEnumerator
         {
-            private RetrievableEntryHashSet<T> _set;
+            private readonly RetrievableEntryHashSet<T> _hashSet;
+            private readonly int _version;
             private int _index;
-            private int _version;
             private T _current;
 
-            internal Enumerator(RetrievableEntryHashSet<T> set)
+            internal Enumerator(RetrievableEntryHashSet<T> hashSet)
             {
-                _set = set;
+                _hashSet = hashSet;
+                _version = hashSet._version;
                 _index = 0;
-                _version = set._version;
                 _current = default(T);
             }
 
@@ -1768,49 +917,44 @@ public void Dispose()
 
             public bool MoveNext()
             {
-                if (_version != _set._version)
+                if (_version != _hashSet._version)
                 {
                     throw new InvalidOperationException();
                 }
 
-                while (_index < _set._lastIndex)
+                while (_index < _hashSet._lastIndex)
                 {
-                    if (_set._slots[_index].hashCode >= 0)
+                    if (_hashSet._slots[_index].hashCode >= 0)
                     {
-                        _current = _set._slots[_index].value;
+                        _current = _hashSet._slots[_index].value;
                         _index++;
                         return true;
                     }
                     _index++;
                 }
-                _index = _set._lastIndex + 1;
+                _index = _hashSet._lastIndex + 1;
                 _current = default(T);
                 return false;
             }
 
-            public T Current
-            {
-                get
-                {
-                    return _current;
-                }
-            }
+            public T Current => _current;
 
-            Object System.Collections.IEnumerator.Current
+            object IEnumerator.Current
             {
                 get
                 {
-                    if (_index == 0 || _index == _set._lastIndex + 1)
+                    if (_index == 0 || (_index == _hashSet._lastIndex + 1))
                     {
                         throw new InvalidOperationException();
                     }
-                    return Current;
+
+                    return _current;
                 }
             }
 
-            void System.Collections.IEnumerator.Reset()
+            void IEnumerator.Reset()
             {
-                if (_version != _set._version)
+                if (_version != _hashSet._version)
                 {
                     throw new InvalidOperationException();
                 }
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index c25e4dc39fe..aec725113cc 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -235,6 +235,9 @@
     <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="Collections\RetrievableEntryHashSet\HashHelpers.SerializationInfoTable.cs">
+      <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
+    </Compile>
     <Compile Include="Construction\ImplicitImportLocation.cs" />
     <Compile Include="Construction\ProjectSdkElement.cs" />
     <Compile Include="Definition\ProjectOptions.cs" />
