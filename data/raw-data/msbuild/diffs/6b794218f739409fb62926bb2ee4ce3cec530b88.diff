diff --git a/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs b/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
new file mode 100644
index 00000000000..ba4539b6d77
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
@@ -0,0 +1,79 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Xunit;
+
+#nullable disable
+
+namespace Microsoft.Build.UnitTests.BackEnd
+{
+    public class CacheSerialization_Tests
+    {
+        public static IEnumerable<object[]> CacheData
+        {
+            get
+            {
+                var configCache = new ConfigCache();
+                var brq1 = new BuildRequestConfiguration(
+                   1,
+                   new BuildRequestData("path1", new Dictionary<string, string> { ["a1"] = "b1" }, Constants.defaultToolsVersion, new[] { "target1" }, null),
+                   Constants.defaultToolsVersion);
+
+                var brq2 = new BuildRequestConfiguration(
+                    2,
+                    new BuildRequestData("path2", new Dictionary<string, string> { ["a2"] = "b2" }, Constants.defaultToolsVersion, new[] { "target2" }, null),
+                    Constants.defaultToolsVersion);
+                var brq3 = new BuildRequestConfiguration(
+                   3,
+                   new BuildRequestData("path3", new Dictionary<string, string> { ["a3"] = "b3" }, Constants.defaultToolsVersion, new[] { "target3" }, null),
+                   Constants.defaultToolsVersion);
+
+                configCache.AddConfiguration(brq1);
+                configCache.AddConfiguration(brq2);
+                configCache.AddConfiguration(brq3);
+
+                var resultsCache = new ResultsCache();
+                var request1 = new BuildRequest(1, 0, 1, new string[] { "target1" }, null, BuildEventContext.Invalid, null);
+                var request2 = new BuildRequest(2, 0, 2, new string[] { "target2" }, null, BuildEventContext.Invalid, null);
+                var request3 = new BuildRequest(3, 0, 3, new string[] { "target3" }, null, BuildEventContext.Invalid, null);
+
+                resultsCache.AddResult(new BuildResult(request1));
+                resultsCache.AddResult(new BuildResult(request2));
+                resultsCache.AddResult(new BuildResult(request3));
+
+                return new List<object[]>
+                {
+                    new object[] { configCache, resultsCache },
+                };
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(CacheData))]
+        public void OnlySerializeCacheEntryWithSmallestConfigId(object configCache, object resultsCache)
+        {
+            string cacheFile = null;
+            try
+            {
+                cacheFile = FileUtilities.GetTemporaryFile("MSBuildResultsCache");
+                Assert.Null(CacheSerialization.SerializeCaches((ConfigCache)configCache, (ResultsCache)resultsCache, cacheFile));
+
+                var result = CacheSerialization.DeserializeCaches(cacheFile);
+                Assert.True(result.ConfigCache.HasConfiguration(1));
+                Assert.False(result.ConfigCache.HasConfiguration(2));
+                Assert.False(result.ConfigCache.HasConfiguration(3));
+            }
+            finally
+            {
+                File.Delete(cacheFile);
+            }
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
index 7cfadc9a5e4..1593604ae74 100644
--- a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
@@ -5,6 +5,7 @@
 using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Shouldly;
 using Xunit;
@@ -55,6 +56,38 @@ public static IEnumerable<object[]> CacheSerializationTestData
             }
         }
 
+        public static IEnumerable<object[]> CacheSerializationTestDataNoConfigs
+        {
+            get
+            {
+                yield return new[] { new ConfigCache() };
+            }
+        }
+
+        public static IEnumerable<object[]> CacheSerializationTestDataMultipleConfigs
+        {
+            get
+            {
+                var configCache = new ConfigCache();
+                var brq1 = new BuildRequestConfiguration(
+                  1,
+                  new BuildRequestData("path1", new Dictionary<string, string> { ["a1"] = "b1" }, Constants.defaultToolsVersion, new[] { "target1" }, null),
+                  Constants.defaultToolsVersion);
+                var brq2 = new BuildRequestConfiguration(
+                  2,
+                  new BuildRequestData("path2", new Dictionary<string, string> { ["a2"] = "b2" }, Constants.defaultToolsVersion, new[] { "target2" }, null),
+                  Constants.defaultToolsVersion);
+                var brq3 = new BuildRequestConfiguration(
+                  3,
+                  new BuildRequestData("path3", new Dictionary<string, string> { ["a3"] = "b3" }, Constants.defaultToolsVersion, new[] { "target3" }, null),
+                  Constants.defaultToolsVersion);
+                configCache.AddConfiguration(brq1.ShallowCloneWithNewId(1));
+                configCache.AddConfiguration(brq2.ShallowCloneWithNewId(2));
+                configCache.AddConfiguration(brq3.ShallowCloneWithNewId(3));
+                yield return new[] { configCache };
+            }
+        }
+
         [Theory]
         [MemberData(nameof(CacheSerializationTestData))]
         public void ConfigCacheShouldBeTranslatable(object obj)
@@ -84,5 +117,19 @@ public void ConfigCacheShouldBeTranslatable(object obj)
                 copy[initialConfiguration.ConfigurationId].ProjectInitialTargets.ShouldBe(initialConfiguration.ProjectInitialTargets);
             }
         }
+
+        [Theory]
+        [MemberData(nameof(CacheSerializationTestDataNoConfigs))]
+        public void GetSmallestConfigIdThrows(object obj)
+        {
+            Assert.Throws<InternalErrorException>(() => ((ConfigCache)obj).GetSmallestConfigId());
+        }
+
+        [Theory]
+        [MemberData(nameof(CacheSerializationTestDataMultipleConfigs))]
+        public void HappyGetSmallestConfigId(object obj)
+        {
+            Assert.Equal(1, ((ConfigCache)obj).GetSmallestConfigId());
+        }
     }
 }
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 318c2c6f92f..4d28600f8a1 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -585,7 +585,7 @@ public void SolutionEdgesShouldNotOverwriteMultitargetingEdges()
             var graph = new ProjectGraph(_env.CreateFile("solution.sln", solutionContents).Path);
 
             var edges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
-            edges.Count.ShouldBe(8);
+            edges.Count.ShouldBe(10);
 
             var node1 = GetFirstNodeWithProjectNumber(graph, 1);
             node1.ProjectReferences.Count.ShouldBe(3);
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index 65b1b86965c..fd6e5a951c3 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -6,6 +6,7 @@
 using System.IO;
 using System.Linq;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Shouldly;
@@ -36,40 +37,50 @@ internal static class GraphTestingUtilities
                                                                                             <AddTransitiveProjectReferencesInStaticGraph>true</AddTransitiveProjectReferencesInStaticGraph>
                                                                                          </PropertyGroup>";
 
-        public static void AssertOuterBuildAsNonRoot(
+        public static void AssertOuterBuild(
             ProjectGraphNode outerBuild,
             ProjectGraph graph,
             Dictionary<string, string> additionalGlobalProperties = null,
             int expectedInnerBuildCount = 2)
         {
-            additionalGlobalProperties ??= new Dictionary<string, string>();
+            additionalGlobalProperties ??= new Dictionary<string, string>(0);
 
             AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
 
-            outerBuild.ProjectReferences.ShouldBeEmpty();
-            outerBuild.ReferencingProjects.ShouldNotBeEmpty();
+            outerBuild.ProjectReferences.Count.ShouldBe(expectedInnerBuildCount);
 
-            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)
+            // Outer -> Inner build edges
+            foreach (ProjectGraphNode innerBuild in outerBuild.ProjectReferences)
             {
-                var innerBuilds =
-                    outerBuildReferencer.ProjectReferences.Where(
-                        p =>
-                            IsInnerBuild(p) 
-                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();
+                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
+
+                ProjectItemInstance edge = graph.TestOnly_Edges[(outerBuild, innerBuild)];
+                edge.DirectMetadataCount.ShouldBe(1);
+
+                string expectedPropertiesMetadata = $"{InnerBuildPropertyName}={innerBuild.ProjectInstance.GlobalProperties[InnerBuildPropertyName]}";
+                edge.GetMetadata("Properties").EvaluatedValue.ShouldBe(expectedPropertiesMetadata);
+            }
+
+            // Ensure edges were added directly to the inner builds
+            foreach (ProjectGraphNode outerBuildReferencer in outerBuild.ReferencingProjects)
+            {
+                ProjectGraphNode[] innerBuilds = outerBuildReferencer.ProjectReferences
+                    .Where(p => IsInnerBuild(p) && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath)
+                    .ToArray();
 
                 innerBuilds.Length.ShouldBe(expectedInnerBuildCount);
 
-                foreach (var innerBuild in innerBuilds)
+                foreach (ProjectGraphNode innerBuild in innerBuilds)
                 {
                     AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
 
                     innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);
-                    innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);
+                    innerBuild.ReferencingProjects.ShouldContain(outerBuild);
 
-                    graph.TestOnly_Edges.HasEdge((outerBuild, innerBuild)).ShouldBeFalse();
+                    graph.TestOnly_Edges.HasEdge((outerBuild, innerBuild)).ShouldBeTrue();
 
-                    var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
-                    var edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
+                    ProjectItemInstance edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
+                    ProjectItemInstance edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
 
                     edgeToOuterBuild.ShouldBe(edgeToInnerBuild);
                 }
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 2a17d2e97d0..273d6d4a7eb 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -971,13 +971,13 @@ public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()
         [Fact]
         public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBuilds()
         {
-            var projectReferenceTargetsProtocol =
+            string projectReferenceTargetsProtocol =
 $@"<ItemGroup>
      <ProjectReferenceTargets Include='A' Targets='{MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker};A;AInner' />
      <ProjectReferenceTargets Include='A' Targets='{MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker};A;AOuter' OuterBuild='true' />
    </ItemGroup>";
 
-            var entryProject = CreateProjectFile(
+            string entryProject = CreateProjectFile(
                 env: _env,
                 projectNumber: 1,
                 projectReferences: null,
@@ -1015,28 +1015,28 @@ public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBui
 
             var dot = graph.ToDot();
 
-            var rootOuterBuild = GetOuterBuild(graph, 1);
-            var nonRootOuterBuild = GetOuterBuild(graph, 3);
+            ProjectGraphNode rootOuterBuild = GetOuterBuild(graph, 1);
+            ProjectGraphNode nonRootOuterBuild = GetOuterBuild(graph, 3);
 
-            AssertOuterBuildAsRoot(rootOuterBuild, graph);
-            AssertOuterBuildAsNonRoot(nonRootOuterBuild, graph);
+            AssertOuterBuild(rootOuterBuild, graph);
+            AssertOuterBuild(nonRootOuterBuild, graph);
 
-            var targetLists = graph.GetTargetLists(new[] {"A"});
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(new[] { "A" });
 
-            targetLists[rootOuterBuild].ShouldBe(new []{"A"});
+            targetLists[rootOuterBuild].ShouldBe(new[] { "A" });
 
-            foreach (var innerBuild in GetInnerBuilds(graph, 1))
+            foreach (ProjectGraphNode innerBuild in GetInnerBuilds(graph, 1))
             {
-                targetLists[innerBuild].ShouldBe(new []{"D1", "A", "AOuter", "AInner"});
+                targetLists[innerBuild].ShouldBe(new[] { "D1", "A", "AOuter", "AInner" });
             }
 
-            targetLists[GetFirstNodeWithProjectNumber(graph, 2)].ShouldBe(new []{"T2", "A", "AOuter", "AInner"});
+            targetLists[GetFirstNodeWithProjectNumber(graph, 2)].ShouldBe(new[] { "T2", "A", "AOuter", "AInner" });
 
-            targetLists[nonRootOuterBuild].ShouldBe(new []{"T3", "A", "AOuter"});
+            targetLists[nonRootOuterBuild].ShouldBe(new[] { "T3", "A", "AOuter" });
 
-            foreach (var innerBuild in GetInnerBuilds(graph, 3))
+            foreach (ProjectGraphNode innerBuild in GetInnerBuilds(graph, 3))
             {
-                targetLists[innerBuild].ShouldBe(new []{"T3", "A", "AOuter", "AInner"});
+                targetLists[innerBuild].ShouldBe(new[] { "T3", "A", "AOuter", "AInner", "D3" });
             }
         }
 
@@ -1531,31 +1531,6 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
             Regex.Matches(dot,"label").Count.ShouldBe(graph.ProjectNodes.Count);
         }
 
-        private static void AssertOuterBuildAsRoot(
-            ProjectGraphNode outerBuild,
-            ProjectGraph graph,
-            Dictionary<string, string> additionalGlobalProperties = null,
-            int expectedInnerBuildCount = 2)
-        {
-            additionalGlobalProperties ??= new Dictionary<string, string>();
-
-            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
-
-            outerBuild.ReferencingProjects.ShouldBeEmpty();
-            outerBuild.ProjectReferences.Count.ShouldBe(expectedInnerBuildCount);
-
-            foreach (var innerBuild in outerBuild.ProjectReferences)
-            {
-                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
-
-                var edge = graph.TestOnly_Edges[(outerBuild, innerBuild)];
-                edge.DirectMetadataCount.ShouldBe(1);
-
-                var expectedPropertiesMetadata = $"{InnerBuildPropertyName}={innerBuild.ProjectInstance.GlobalProperties[InnerBuildPropertyName]}";
-                edge.GetMetadata("Properties").EvaluatedValue.ShouldBe(expectedPropertiesMetadata);
-            }
-        }
-
         [Fact]
         public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
         {
@@ -1569,7 +1544,7 @@ public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
 
             var outerBuild = graph.GraphRoots.First();
 
-            AssertOuterBuildAsRoot(outerBuild, graph);
+            AssertOuterBuild(outerBuild, graph);
         }
 
         [Fact]
@@ -1596,7 +1571,7 @@ public void OuterBuildAsNonRootShouldNotReferenceInnerBuilds()
 
             var outerBuild = GetOuterBuild(graph, 2);
 
-            AssertOuterBuildAsNonRoot(outerBuild, graph);
+            AssertOuterBuild(outerBuild, graph);
         }
 
         [Fact]
@@ -1630,7 +1605,7 @@ public void InnerBuildsFromNonRootOuterBuildInheritEdgesToOuterBuild()
 
             var outerBuild = GetOuterBuild(graph, 2);
 
-            AssertOuterBuildAsNonRoot(outerBuild, graph);
+            AssertOuterBuild(outerBuild, graph);
 
             var outerBuildReferencingNode = GetFirstNodeWithProjectNumber(graph, 1);
 
@@ -1652,7 +1627,7 @@ public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
                                                     <InnerBuildProperties>a;a</InnerBuildProperties>
                                                 </PropertyGroup>";
 
-            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, multitargetingSpecification).Path;
+            var root = CreateProjectFile(_env, 1, new[] { 2 }, null, null, multitargetingSpecification).Path;
             CreateProjectFile(_env, 2, null, null, null, multitargetingSpecification);
 
             var graph = new ProjectGraph(root);
@@ -1664,8 +1639,8 @@ public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
             var rootOuterBuild = GetOuterBuild(graph, 1);
             var nonRootOuterBuild = GetOuterBuild(graph, 2);
 
-            AssertOuterBuildAsRoot(rootOuterBuild, graph, null, 1);
-            AssertOuterBuildAsNonRoot(nonRootOuterBuild, graph, null, 1);
+            AssertOuterBuild(rootOuterBuild, graph, null, 1);
+            AssertOuterBuild(nonRootOuterBuild, graph, null, 1);
         }
 
         [Fact]
@@ -1680,7 +1655,7 @@ public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGl
 
             graph.ProjectNodes.Count.ShouldBe(4);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
+            AssertOuterBuild(graph.GraphRoots.First(), graph);
 
             var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);
 
@@ -1748,8 +1723,8 @@ public void NonMultitargetingProjectsAreCompatibleWithMultitargetingProjects()
 
             graph.ProjectNodes.Count.ShouldBe(8);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
-            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 4), graph);
+            AssertOuterBuild(graph.GraphRoots.First(), graph);
+            AssertOuterBuild(GetOuterBuild(graph, 4), graph);
 
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2));
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));
@@ -1775,9 +1750,9 @@ public void InnerBuildsCanHaveSeparateReferences()
 
             graph.ProjectNodes.Count.ShouldBe(11);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
-            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 2), graph);
-            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 2), graph);
+            AssertOuterBuild(graph.GraphRoots.First(), graph);
+            AssertOuterBuild(GetOuterBuild(graph, 2), graph);
+            AssertOuterBuild(GetOuterBuild(graph, 2), graph);
 
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 5));
@@ -1817,7 +1792,7 @@ public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
 
             var outerBuild = graph.GraphRoots.First(IsOuterBuild);
 
-            AssertOuterBuildAsRoot(outerBuild, graph, additionalGlobalProperties);
+            AssertOuterBuild(outerBuild, graph, additionalGlobalProperties);
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2), additionalGlobalProperties);
 
             var referencedInnerBuild = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GetPropertyValue(InnerBuildPropertyName) == "a");
@@ -1895,7 +1870,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
 
             var outerBuild1 = GetOuterBuild(graph, 1);
 
-            AssertOuterBuildAsRoot(outerBuild1, graph, additionalGlobalProperties);
+            AssertOuterBuild(outerBuild1, graph, additionalGlobalProperties);
 
             var innerBuild1WithReferenceToInnerBuild2 = outerBuild1.ProjectReferences.FirstOrDefault(n => IsInnerBuild(n) && n.ProjectInstance.GlobalProperties[InnerBuildPropertyName] == "a");
             innerBuild1WithReferenceToInnerBuild2.ShouldNotBeNull();
@@ -2226,9 +2201,9 @@ public void TransitiveReferencesShouldNotBeAddedToOuterBuilds()
                 innerBuild.AssertReferencesIgnoringOrder(new []{3, 4, 4, 4, 5, 6, 6, 6});
             }
 
-            GetFirstNodeWithProjectNumber(graph, 2).AssertReferencesIgnoringOrder(new []{3, 4, 4, 4, 5, 6, 6, 6});
+            GetFirstNodeWithProjectNumber(graph, 2).AssertReferencesIgnoringOrder(new[] { 3, 4, 4, 4, 5, 6, 6, 6 });
 
-            GetOuterBuild(graph, 4).AssertReferencesIgnoringOrder(Array.Empty<int>());
+            GetOuterBuild(graph, 4).AssertReferencesIgnoringOrder(new[] { 4, 4 });
 
             var innerBuilds4 = GetInnerBuilds(graph, 4);
             innerBuilds4.Count.ShouldBe(2);
@@ -2303,7 +2278,7 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
             var outerBuild1 = GetOuterBuild(graph, 1);
             targetLists[outerBuild1].ShouldBe(new[] {"Build"});
 
-            AssertOuterBuildAsRoot(outerBuild1, graph, expectedInnerBuildCount: 2);
+            AssertOuterBuild(outerBuild1, graph, expectedInnerBuildCount: 2);
 
             var innerBuildsFor1 = GetInnerBuilds(graph, 1);
             innerBuildsFor1.Count.ShouldBe(2);
@@ -2316,7 +2291,7 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
 
             var outerBuild2 = GetOuterBuild(graph, 2);
             targetLists[outerBuild2].ShouldBe(new[] {"BuildForOuterBuild"});
-            AssertOuterBuildAsNonRoot(outerBuild2, graph, expectedInnerBuildCount: 2);
+            AssertOuterBuild(outerBuild2, graph, expectedInnerBuildCount: 2);
 
             var innerBuildsFor2 = GetInnerBuilds(graph, 2);
             innerBuildsFor2.Count.ShouldBe(2);
@@ -2331,13 +2306,13 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
 
             outerBuild3.ReferencingProjects.Count.ShouldBe(4);
 
-            AssertOuterBuildAsNonRoot(outerBuild3, graph, expectedInnerBuildCount: 2);
+            AssertOuterBuild(outerBuild3, graph, expectedInnerBuildCount: 2);
             var innerBuildsFor3 = GetInnerBuilds(graph, 3);
             innerBuildsFor3.Count.ShouldBe(2);
 
             foreach (var inner3 in innerBuildsFor3)
             {
-                inner3.ReferencingProjects.Count.ShouldBe(4);
+                inner3.ReferencingProjects.Count.ShouldBe(5);
 
                 // 3 does not get called with 1ATarget or 1BTarget because those apply only to direct references
                 targetLists[inner3]
diff --git a/src/Build/BackEnd/BuildManager/CacheSerialization.cs b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
index 4c337378637..950182296ab 100644
--- a/src/Build/BackEnd/BuildManager/CacheSerialization.cs
+++ b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.IO;
+using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 
@@ -61,6 +62,27 @@ public static string SerializeCaches(IConfigCache configCache, IResultsCache res
                             break;
                     }
 
+                    // Avoid creating new config and results caches if no projects were built in violation
+                    // of isolation mode.
+                    if (configCacheToSerialize.Count() > 1)
+                    {
+                        // We need to preserve all configurations to enable the scheduler to dump them and their
+                        // associated requests, so create new caches to serialize storing solely data
+                        // associated with the project specified to be built in isolation (and not any
+                        // data associated with referenced projects needed for said project to complete
+                        // its build).
+                        var tempConfigCacheToSerialize = new ConfigCache();
+
+                        // The project that was built in isolation mode has the
+                        // smallest configuration id.
+                        int smallestCacheConfigId = configCacheToSerialize.GetSmallestConfigId();
+                        tempConfigCacheToSerialize.AddConfiguration(configCacheToSerialize[smallestCacheConfigId]);
+                        configCacheToSerialize = tempConfigCacheToSerialize;
+                        var tempResultsCacheToSerialize = new ResultsCache();
+                        tempResultsCacheToSerialize.AddResult(resultsCacheToSerialize.GetResultsForConfiguration(smallestCacheConfigId));
+                        resultsCacheToSerialize = tempResultsCacheToSerialize;
+                    }
+
                     translator.Translate(ref configCacheToSerialize);
                     translator.Translate(ref resultsCacheToSerialize);
                 }
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index d2821aee570..f2eac09484f 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -200,6 +201,21 @@ public void ClearConfigurations()
             }
         }
 
+        /// <summary>
+        /// Gets the smallest configuration id of any configuration
+        /// in this cache.
+        /// </summary>
+        /// <returns>Gets the smallest configuration id of any
+        /// configuration in this cache.</returns>
+        public int GetSmallestConfigId()
+        {
+            lock (_lockObject)
+            {
+                ErrorUtilities.VerifyThrow(_configurations.Count > 0, "No configurations exist from which to obtain the smallest configuration id.");
+                return _configurations.OrderBy(kvp => kvp.Key).First().Key;
+            }
+        }
+    
         /// <summary>
         /// Clears configurations from the configuration cache which have not been explicitly loaded.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/CurrentHost.cs b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
index 81116ecb054..5eec58d2d0b 100644
--- a/src/Build/BackEnd/Components/Communications/CurrentHost.cs
+++ b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
@@ -1,9 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if RUNTIME_TYPE_NETCORE || MONO
 using System.Diagnostics;
 using System.IO;
 using Microsoft.Build.Shared;
+#endif
 
 #nullable disable
 
diff --git a/src/Build/BackEnd/Components/Communications/INodeProvider.cs b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
index 0da32af6678..810dc4d9011 100644
--- a/src/Build/BackEnd/Components/Communications/INodeProvider.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
@@ -3,7 +3,6 @@
 
 using System;
 
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
index 9a08a3940a7..b39bcc78b9e 100644
--- a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Diagnostics;
 using System.Globalization;
-using System.IO;
 using System.Runtime.InteropServices;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 88f5feea51b..337cbd76f03 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -9,7 +9,9 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
+#if FEATURE_THREAD_CULTURE
 using BuildParameters = Microsoft.Build.Execution.BuildParameters;
+#endif
 using NodeEngineShutdownReason = Microsoft.Build.Execution.NodeEngineShutdownReason;
 
 #nullable disable
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index cd5a88127e0..77741a46412 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -10,15 +10,15 @@
 using System.IO.Pipes;
 using System.Diagnostics;
 using System.Linq;
-using System.Threading;
 using System.Threading.Tasks;
-using System.Runtime.InteropServices;
 #if FEATURE_PIPE_SECURITY
 using System.Security.Principal;
 #endif
 
 #if FEATURE_APM
 using Microsoft.Build.Eventing;
+#else
+using System.Threading;
 #endif
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index cfd6c3a61da..11aea7b2c52 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Concurrent;
-using System.Linq;
 using System.Reflection;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
diff --git a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
index c1fa3e463a7..1a4d63c65a9 100644
--- a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections;
-using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
index cb85cae4558..9f51cf9e10a 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.ProjectCache
diff --git a/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs b/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
index 505fa0ed693..4ebc567c45d 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
@@ -1,14 +1,14 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.IO;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
index 7888b1a6679..71f82542916 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 9fdc4c5f8bc..f411afbd2b2 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -10,7 +10,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 0a048df26d4..38bc4c3c23a 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 7ccb8008ceb..ce94320a586 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -14,7 +14,6 @@
 using Microsoft.Build.Eventing;
 using System.Linq;
 using System.Text.RegularExpressions;
-using System.Diagnostics;
 
 #nullable disable
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index fb7c35ad18e..ce0b8db4ad0 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -23,7 +23,6 @@
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Task = System.Threading.Tasks.Task;
-using System.Linq;
 
 #nullable disable
 
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index e5c1677ee6a..b581d671b9d 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -7,9 +7,6 @@
 using System.Diagnostics;
 using System.Diagnostics.Contracts;
 using System.Runtime.Serialization;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 using System.Diagnostics.CodeAnalysis;
 using System.Security;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index caae6ee03a0..db1aa93901e 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -8,10 +8,8 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 645181ce8f7..f8f74e0686a 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -5,9 +5,7 @@
 using System;
 using System.Diagnostics;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index 79d4de04eb6..a49654cefca 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using Microsoft.Build.Collections;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index ce0dc977426..cbbc06d0cef 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using Microsoft.CodeAnalysis.Collections;
 using System;
 using System.Collections.Generic;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index f0c19a5c681..2e0cf86d90d 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -3,7 +3,6 @@
 
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using System;
 using System.Collections.Generic;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index b742bb23311..8fbcc487daa 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -4,7 +4,6 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index 612c1a8d9d1..88c299dd571 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Framework;
 using System.Collections.Immutable;
 using System.Linq;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 871ad820e6a..cddd1390eda 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -9,12 +9,13 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 
 using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using System.Linq;
 using System.Threading;
 
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index d9843d908e9..92464daafd4 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -6,9 +6,7 @@
 using System.IO;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
 
 #nullable disable
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 09263b6b97c..776514e4d7d 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -6,7 +6,6 @@
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
-using System.Security.Cryptography.Xml;
 using System.Text;
 using System.Threading;
 using Microsoft.Build.BackEnd;
@@ -117,7 +116,7 @@ private void AddEdges(Dictionary<ConfigurationMetadata, ParsedProject> allParsed
 
             AddEdgesFromProjectReferenceItems(allParsedProjects, Edges);
 
-            _projectInterpretation.ReparentInnerBuilds(allParsedProjects, this);
+            _projectInterpretation.AddInnerBuildEdges(allParsedProjects, this);
 
             if (_solutionDependencies != null && _solutionDependencies.Count != 0)
             {
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index bbd597033fb..a293483551b 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -105,12 +105,12 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                 var requesterPlatform = "";
                 var requesterPlatformLookupTable = "";
 
-                if ( !projectReferenceItem.HasMetadata(SetPlatformMetadataName) && ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
+                if (!projectReferenceItem.HasMetadata(SetPlatformMetadataName) && ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
                 {
                     requesterPlatform = requesterInstance.GetPropertyValue("Platform");
                     requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
 
-                    var  projectInstance = _projectInstanceFactory(
+                    var projectInstance = _projectInstanceFactory(
                         projectReferenceFullPath,
                         null, // Platform negotiation requires an evaluation with no global properties first
                         _projectCollection);
@@ -164,30 +164,28 @@ internal static ProjectType GetProjectType(ProjectInstance project)
         }
 
         /// <summary>
-        /// To avoid calling nuget at graph construction time, the graph is initially constructed with outer build nodes referencing inner build nodes.
-        /// However, at build time, for non root outer builds, the inner builds are NOT referenced by the outer build, but by the nodes referencing the
-        /// outer build. Change the graph to mimic this behaviour.
-        /// Examples
-        /// OuterAsRoot -> Inner go to OuterAsRoot -> Inner. Inner builds remain the same, parented to their outer build
-        /// Node -> Outer -> Inner go to: Node -> Outer; Node->Inner; Outer -> empty. Inner builds get reparented to Node
+        /// To avoid calling nuget at graph construction time, the graph is initially constructed with nodes referencing outer build nodes which in turn
+        /// reference inner build nodes. However at build time, the inner builds are referenced directly by the nodes referencing the outer build.
+        /// Change the graph to mimic this behaviour.
+        /// Example: Node -> Outer -> Inner go to: Node -> Outer; Node->Inner; Outer -> Inner. Inner build edges get added to Node.
         /// </summary>
-        public void ReparentInnerBuilds(Dictionary<ConfigurationMetadata, ParsedProject> allNodes, GraphBuilder graphBuilder)
+        public void AddInnerBuildEdges(Dictionary<ConfigurationMetadata, ParsedProject> allNodes, GraphBuilder graphBuilder)
         {
-            foreach (var node in allNodes)
+            foreach (KeyValuePair<ConfigurationMetadata, ParsedProject> node in allNodes)
             {
-                var outerBuild = node.Value.GraphNode;
+                ProjectGraphNode outerBuild = node.Value.GraphNode;
 
                 if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)
                 {
-                    foreach (var innerBuild in outerBuild.ProjectReferences)
+                    foreach (ProjectGraphNode innerBuild in outerBuild.ProjectReferences)
                     {
-                        foreach (var outerBuildReferencingProject in outerBuild.ReferencingProjects)
+                        foreach (ProjectGraphNode outerBuildReferencingProject in outerBuild.ReferencingProjects)
                         {
                             // Which edge should be used to connect the outerBuildReferencingProject to the inner builds?
                             // Decided to use the outerBuildBuildReferencingProject -> outerBuild edge in order to preserve any extra metadata
                             // information that may be present on the edge, like the "Targets" metadata which specifies what
                             // targets to call on the references.
-                            var newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
+                            ProjectItemInstance newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
 
                             if (outerBuildReferencingProject.ProjectReferences.Contains(innerBuild))
                             {
@@ -204,8 +202,6 @@ public void ReparentInnerBuilds(Dictionary<ConfigurationMetadata, ParsedProject>
                             outerBuildReferencingProject.AddProjectReference(innerBuild, newInnerBuildEdge, graphBuilder.Edges);
                         }
                     }
-
-                    outerBuild.RemoveReferences(graphBuilder.Edges);
                 }
             }
         }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index de9f9d01451..d3cb5c170a7 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -23,7 +23,6 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using ObjectModel = System.Collections.ObjectModel;
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index bc191a256a9..41135bc767b 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -3,13 +3,11 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 using System.Reflection;
 #if FEATURE_APPDOMAIN
 using System.Threading.Tasks;
 #endif
 
-using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index e7aac941dd4..3e29b27e99e 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -3,7 +3,6 @@
 using System.IO.Compression;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/Logging/FancyLogger/ANSIBuilder.cs b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
index 2a161bd6667..14f1fbb7c8a 100644
--- a/src/Build/Logging/FancyLogger/ANSIBuilder.cs
+++ b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
@@ -3,11 +3,7 @@
 //
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using System.Text.RegularExpressions;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Logging.FancyLogger
 {
diff --git a/src/Build/Logging/FancyLogger/FancyLogger.cs b/src/Build/Logging/FancyLogger/FancyLogger.cs
index 2eb3d10200e..d8f89c48909 100644
--- a/src/Build/Logging/FancyLogger/FancyLogger.cs
+++ b/src/Build/Logging/FancyLogger/FancyLogger.cs
@@ -1,29 +1,18 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
 using System.Collections.Generic;
 
 using Microsoft.Build.Framework;
-using System.Runtime.InteropServices;
-using System.Threading;
-using System.Threading.Tasks;
-using System.IO;
 
 namespace Microsoft.Build.Logging.FancyLogger
 {
     public class FancyLogger : ILogger
-    {
-        // TODO: Move somewhere else
-        public string GetUnambiguousPath(string path)
-        {
-            // Get last part of path
-            return Path.GetFileName(path);
-        }
-
-        public FancyLoggerNode root = new FancyLoggerNode(-1, FancyLoggerNodeType.None);
+    {   
+        private Dictionary<int, FancyLoggerProjectNode> projects = new Dictionary<int, FancyLoggerProjectNode>();
 
-        public Dictionary<int, FancyLoggerBufferLine> projectConsoleLines = new Dictionary<int, FancyLoggerBufferLine>();
+        private bool Succeeded;
 
         private float existingTasks = 1;
         private float completedTasks = 0;
@@ -43,12 +32,12 @@ public void Initialize(IEventSource eventSource)
             // Started
             eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);
             eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);
-            // eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);
-            // eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);
+            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);
+            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);
             // Finished
             eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);
             eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);
-            // eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);
+            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);
             // eventSource.TaskFinished += new TaskFinishedEventHandler(eventSource_TaskFinished);
             // Raised
             eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);
@@ -64,6 +53,7 @@ void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
         }
         void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
         {
+            Succeeded = e.Succeeded;
             // Console.WriteLine(LoggerFormatting.Bold("[Build]") + "\t Finished");
         }
 
@@ -73,43 +63,52 @@ void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
             // If id already exists...
-            if (projectConsoleLines.ContainsKey(id)) return;
-            // Create line
-            FancyLoggerBufferLine line = FancyLoggerBuffer.WriteNewLine(
-                ANSIBuilder.Alignment.SpaceBetween(
-                    $"{ANSIBuilder.Graphics.Spinner()} {ANSIBuilder.Formatting.Dim("Project - ")} {GetUnambiguousPath(e.ProjectFile!)}",
-                    "(5 targets completed)",
-                    Console.WindowWidth
-                )
-            );
-
-            projectConsoleLines.Add(id, line);
+            if (projects.ContainsKey(id)) return;
+            // Add project
+            FancyLoggerProjectNode node = new FancyLoggerProjectNode(e);
+            projects[id] = node;
+            // Log
+            node.Log();
         }
         void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if(!projectConsoleLines.TryGetValue(id, out FancyLoggerBufferLine? line)) return;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
             // Update line
-            FancyLoggerBuffer.UpdateLine(line.Id,
-                ANSIBuilder.Alignment.SpaceBetween(
-                    $"{ANSIBuilder.Formatting.Color("✓", ANSIBuilder.Formatting.ForegroundColor.Green)} {ANSIBuilder.Formatting.Dim("Project - ")} {ANSIBuilder.Formatting.Color(GetUnambiguousPath(e.ProjectFile!), ANSIBuilder.Formatting.ForegroundColor.Green)}",
-                    "(5 targets completed)",
-                    Console.WindowWidth
-                )
-            );
+            node.Finished = true;
+            node.Log();
         }
         // Target
         void eventSource_TargetStarted(object sender, TargetStartedEventArgs e)
         {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddTarget(e);
+            node.Log();
         }
         void eventSource_TargetFinished(object sender, TargetFinishedEventArgs e)
         {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.FinishedTargets++;
+            node.Log();
         }
 
         // Task
         void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
         {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddTask(e);
+            node.Log();
             existingTasks++;
         }
 
@@ -120,25 +119,50 @@ void eventSource_TaskFinished(object sender, TaskFinishedEventArgs e)
 
         void eventSource_MessageRaised(object sender, BuildMessageEventArgs e)
         {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddMessage(e);
+            node.Log();
         }
         void eventSource_WarningRaised(object sender, BuildWarningEventArgs e)
         {
-            FancyLoggerBuffer.WriteNewLine("Warning");
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddWarning(e);
+            node.Log();
         }
         void eventSource_ErrorRaised(object sender, BuildErrorEventArgs e)
         {
-            // TODO: Try to redirect to stderr
-            FancyLoggerBuffer.WriteNewLine("Error");
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddError(e);
+            node.Log();
         }
 
 
-        public void Shutdown() {
-            // Keep open if autoscroll disabled (the user is reading info)
-            while (FancyLoggerBuffer.AutoScrollEnabled || !FancyLoggerBuffer.IsTerminated)
+        public void Shutdown()
+        {
+            FancyLoggerBuffer.Terminate();
+            // TODO: Remove. There is a bug that causes switching to main buffer without deleting the contents of the alternate buffer
+            Console.Clear();
+            // Console.WriteLine("Build status, warnings and errors will be shown here after the build has ended and the interactive logger has closed");
+            if (Succeeded)
             {
+                Console.WriteLine(ANSIBuilder.Formatting.Color("Build succeeded.", ANSIBuilder.Formatting.ForegroundColor.Green));
+                Console.WriteLine("\tX Warning(s)");
+            }
+            else
+            {
+                Console.WriteLine(ANSIBuilder.Formatting.Color("Build failed.", ANSIBuilder.Formatting.ForegroundColor.Red));
+                Console.WriteLine("\tX Warnings(s)");
+                Console.WriteLine("\tX Errors(s)");
             }
-            FancyLoggerBuffer.Terminate();
-            Console.WriteLine("Build status, warnings and errors will be shown here after the build has ended and the interactive logger has closed");
         }
     }
 }
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs b/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
index cac4aafd7ef..84b580d2633 100644
--- a/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
+++ b/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
@@ -1,265 +1,196 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
+//
 
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
 using System.Threading.Tasks;
 
 namespace Microsoft.Build.Logging.FancyLogger
 {
-    /// <summary>
-    /// Represents an identifiable line inside the fancylogger buffer.
-    /// </summary>
     public class FancyLoggerBufferLine
     {
-        private static int counter = 0;
+        private static int Counter = 0;
         public int Id;
         public string Text;
-        public bool IsHidden;
-        public int IdentationLevel = -1;
+
         public FancyLoggerBufferLine()
         {
-            Id = counter++;
+            Id = Counter++;
             Text = String.Empty;
         }
         public FancyLoggerBufferLine(string text)
+            : this()
         {
-            Id = counter++;
             Text = text;
         }
-        public FancyLoggerBufferLine(string text, int identationLevel) : this(text)
-        {
-            IdentationLevel = identationLevel;
-        }
-        public void Hide()
-        {
-            IsHidden = true;
-        }
-        public void Unhide()
-        {
-            IsHidden = false;
-        }
-        public int GetIndex()
-        {
-            return FancyLoggerBuffer.GetLineIndexById(Id);
-        }
     }
 
-    /// <summary>
-    /// Buffer manager for FancyLogger
-    /// </summary>
-    internal static class FancyLoggerBuffer
+    public class FancyLoggerBuffer
     {
-        // Status
-        public static bool AutoScrollEnabled { get; private set; }
-        public static bool IsTerminated { get; private set; }
-        public static int CurrentTopLineIndex { get; private set; }
-        public static int Height { get { return Console.WindowHeight; } }
-        // Lines to be presented by the buffer
-        private static List<FancyLoggerBufferLine> lines = new();
+        private static List<FancyLoggerBufferLine> Lines = new();
+        private static int TopLineIndex = 0;
+        private static bool AutoScrollEnabled = true;
         public static void Initialize()
         {
-            // Setup event listeners
+            // Use alternate buffer
+            // TODO: Remove. Tries to solve a bug when switching from and to the alternate buffer
+            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
+            Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
+
+            Task.Run(async () => {
+                while (true)
+                {
+                    await Task.Delay(500 / 60);
+                    Render();
+                }
+            });
+
             Task.Run(() =>
             {
                 while (true)
                 {
-                    if (IsTerminated) return;
                     switch (Console.ReadKey().Key)
                     {
-                        case ConsoleKey.Q:
-                            IsTerminated = true;
-                        break;
                         case ConsoleKey.UpArrow:
-                            ScrollToLine(CurrentTopLineIndex - 1);
+                            if (TopLineIndex > 0) TopLineIndex--;
                             break;
                         case ConsoleKey.DownArrow:
-                            ScrollToLine(CurrentTopLineIndex + 1);
-                            break;
-                        case ConsoleKey.Home:
-                            ScrollToLine(0);
-                            break;
-                        case ConsoleKey.End:
-                            ScrollToEnd();
+                            if (TopLineIndex < Console.BufferHeight - 3) TopLineIndex++;
                             break;
                         case ConsoleKey.Spacebar:
                         case ConsoleKey.Escape:
-                            ToggleAutoScroll();
+                            AutoScrollEnabled = !AutoScrollEnabled;
                             break;
                     }
                 }
             });
-            // Switch to alternate
-            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
-            Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
-            // Settings
-            AutoScrollEnabled = true;
-            // Render contents
-            WriteTitleBar();
-            WriteFooter("~~~~~~~~~~~~~~~~~~~~~~~~~~~");
-            ScrollToEnd();
         }
+
         public static void Terminate()
         {
-            // Switch to main buffer
+            // TODO: Remove. Tries to solve a bug when switching from and to the alternate buffer
             Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
-            // Dispose event listeners
-            IsTerminated = true;
-            // Delete lines
-            lines = new();
+            Console.Write(ANSIBuilder.Eraser.Display());
+            Lines = new();
         }
 
-        #region Scrolling
-        private static void ScrollToLine(int firstLineIndex)
-        {
-            if (firstLineIndex < 0 || firstLineIndex >= lines.Count) return;
-            CurrentTopLineIndex = firstLineIndex;
-            int i = 0;
-            while (i < Height - 4)
+        #region Rendering
+        public static void Render()
+        {
+            if (Lines.Count == 0) return;
+            // Write Header
+            Console.Write(
+                // Write header
+                ANSIBuilder.Cursor.Home() +
+                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center("MSBuild - Build in progress")) +
+                // Write footer
+                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
+                // TODO: Remove and replace with actual footer
+                new string('-', Console.BufferWidth) + '\n' + "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
+            );
+            // Write lines
+            for (int i = 0; i < Console.BufferHeight - 3; i++)
             {
-                int lineIndex = i + firstLineIndex;
-                Console.Write(""
-                    + ANSIBuilder.Cursor.Position(i + 2, 0)
-                    + ANSIBuilder.Eraser.LineCursorToEnd()
-                    // + ((lineIndex < lines.Count && lines[lineIndex].IsHidden) ? " Hidden" : "")
-                    + ((lineIndex < lines.Count) ? ANSIBuilder.Tabulator.ForwardTab(lines[lineIndex].IdentationLevel) + lines[lineIndex].Text : "")
+                int lineIndex = i + TopLineIndex;
+                Console.Write(
+                    ANSIBuilder.Cursor.Position(i + 2, 0) +
+                    ANSIBuilder.Eraser.LineCursorToEnd() + 
+                    (lineIndex < Lines.Count ? Lines[lineIndex].Text : String.Empty)
                 );
-                i++;
-            }
-
-            Console.Write(ANSIBuilder.Cursor.Position(Height, 0));
-        }
-        private static void ScrollToEnd()
-        { 
-            // If number of lines is smaller than height
-            if (lines.Count < Height - 2)
-            {
-                ScrollToLine(0);
-            }
-            else
-            {
-                ScrollToLine(lines.Count - Height + 4);
             }
-            // Go to end
-            Console.Write(ANSIBuilder.Cursor.Position(Height, 0));
-        }
-        private static void ToggleAutoScroll()
-        {
-            AutoScrollEnabled = !AutoScrollEnabled;
         }
         #endregion
-        #region Line Referencing
+
+        #region Line identification
         public static int GetLineIndexById(int lineId)
         {
-            for (int i = 0; i < lines.Count; i++)
+            for (int i = 0; i < Lines.Count; i++)
             {
-                if (lines[i].Id == lineId) return i;
+                if (Lines[i].Id == lineId) return i;
             }
             return -1;
         }
+
         public static FancyLoggerBufferLine? GetLineById(int lineId)
         {
-            int i = GetLineIndexById(lineId);
-            if (i == -1) return null;
-            return lines[i];
+            int index = GetLineIndexById(lineId);
+            if (index == -1) return null;
+            return Lines[index];
         }
         #endregion
-        #region Writing
-        public static void WriteTitleBar()
-        {
-            Console.Write(""
-                + ANSIBuilder.Cursor.Home()
-                + ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center("MSBuild - Build in progress"))
-            );
-        }
-        public static void WriteFooter(string text)
-        {
-            Console.Write(""
-                + ANSIBuilder.Cursor.Position(Height - 2, 0) // Position at bottom
-                + new string('-', Console.BufferWidth) + "\n"
-                + ANSIBuilder.Eraser.LineCursorToEnd()
-                + text
-            );
-        }
-        public static FancyLoggerBufferLine WriteNewLine(string text)
-        {
-            // Create line
-            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
-            return WriteNewLine(line);
-        }
-        public static FancyLoggerBufferLine WriteNewLine(FancyLoggerBufferLine line)
-        {
-            // Add line
-            lines.Add(line);
-            // Update contents
-            if (AutoScrollEnabled) ScrollToEnd();
-            else ScrollToLine(CurrentTopLineIndex);
-            return line;
-        }
-        public static FancyLoggerBufferLine? WriteNewLineAfter(string text, int lineId)
-        {
-            // get line
-            int lineIndex = GetLineIndexById(lineId);
-            if (lineIndex == -1) return null;
 
+        #region Line create, update and delete
+        // Write new line
+        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, string text)
+        {
             FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
-            return WriteNewLineAfterIndex(line, lineIndex);
+            return WriteNewLineAfter(lineId, line);
         }
-
-        public static FancyLoggerBufferLine? WriteNewLineAfter(FancyLoggerBufferLine line, int lineId)
+        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, FancyLoggerBufferLine line)
         {
-            // get line
+            // Get line index
             int lineIndex = GetLineIndexById(lineId);
             if (lineIndex == -1) return null;
-
-            return WriteNewLineAfterIndex(line, lineIndex);
+            // Save top line
+            int topLineId = Lines[TopLineIndex].Id;
+            // Add
+            Lines.Insert(lineIndex + 1, line);
+            // Get updated top line index
+            TopLineIndex = GetLineIndexById(topLineId);
+            // Return
+            return line;
         }
 
-        public static FancyLoggerBufferLine? WriteNewLineAfterIndex(FancyLoggerBufferLine line, int lineIndex)
+        public static FancyLoggerBufferLine? WriteNewLine(string text)
         {
-            if (lineIndex == -1) return null;
-            lines.Insert(lineIndex + 1, line);
-            // Scroll to end if lineIndex >= lines
-            // if (lineIndex >= lines.Count -2 && AutoScrollEnabled) ScrollToEnd();
-            // else ScrollToLine(CurrentTopLineIndex);
-            ScrollToEnd();
-            return line;
+            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
+            return WriteNewLine(line);
         }
-
-        public static void DeleteLine(int lineId)
+        public static FancyLoggerBufferLine? WriteNewLine(FancyLoggerBufferLine line)
         {
-            int lineIndex = GetLineIndexById(lineId);
-            if (lineIndex == -1) return;
-            lines.RemoveAt(lineIndex);
-            ScrollToLine(CurrentTopLineIndex);
+            // Get last id
+            if (Lines.Count > 0)
+            {
+                int lineId = Lines.Last().Id;
+                return WriteNewLineAfter(lineId, line);
+            }
+            else
+            {
+                Lines.Add(line);
+                return line;
+            }
         }
 
+        // Update line
         public static FancyLoggerBufferLine? UpdateLine(int lineId, string text)
         {
+            // Get line
             FancyLoggerBufferLine? line = GetLineById(lineId);
             if (line == null) return null;
-
             line.Text = text;
-            ScrollToLine(CurrentTopLineIndex);
+            // Return
             return line;
         }
-        #endregion
 
-        public static void HideLine(int lineId)
-        {
-            FancyLoggerBufferLine? line = GetLineById(lineId);
-            if (line == null) return;
-            line.Hide();
-            ScrollToLine(CurrentTopLineIndex);
-        }
-        public static void UnhideLine(int lineId)
+        // Delete line
+        public static void DeleteLine(int lineId)
         {
-            FancyLoggerBufferLine? line = GetLineById(lineId);
-            if (line == null) return;
-            line.Unhide();
-            ScrollToLine(CurrentTopLineIndex);
+            // TODO: What if line id is equal to topLineId?????
+            // Get line index
+            int lineIndex = GetLineIndexById(lineId);
+            if (lineIndex == -1) return;
+            // Save top line
+            int topLineId = Lines[TopLineIndex].Id;
+            // Delete
+            Lines.RemoveAt(lineIndex);
+            // Get updated top line index
+            if (topLineId != lineId)
+            {
+                TopLineIndex = GetLineIndexById(topLineId);
+            }
         }
+        #endregion
     }
 }
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
new file mode 100644
index 00000000000..d586eb57cd0
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
@@ -0,0 +1,39 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    public class FancyLoggerMessageNode
+    {
+        public string Message;
+        public FancyLoggerBufferLine? Line;
+
+        public FancyLoggerMessageNode(LazyFormattedBuildEventArgs args)
+        {
+            // TODO: Replace
+            if (args.Message == null)
+            {
+                Message = string.Empty;
+            }
+            else if (args.Message.Length > Console.WindowWidth - 1)
+            {
+                Message = args.Message.Substring(0, Console.WindowWidth - 1);
+            }
+            else
+            {
+                Message = args.Message;
+            }
+        }
+
+        public void Log()
+        {
+            if (Line == null) return;
+            FancyLoggerBuffer.UpdateLine(Line.Id, $"    └── {ANSIBuilder.Formatting.Italic(Message)}");
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerNode.cs
deleted file mode 100644
index b3021f042eb..00000000000
--- a/src/Build/Logging/FancyLogger/FancyLoggerNode.cs
+++ /dev/null
@@ -1,151 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-//
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.FancyLogger
-{ 
-    // TODO: Maybe remove
-    public enum FancyLoggerNodeType
-    {
-        None,
-        Build,
-        Project,
-        Target,
-        Task,
-        Message,
-        Warning,
-        Error
-    }
-
-    public class FancyLoggerNode
-    {
-        public string Id;
-        public Dictionary<string, FancyLoggerNode> Children = new Dictionary<string, FancyLoggerNode>();
-        public FancyLoggerNode? Parent;
-        public FancyLoggerBufferLine? Line;
-        public int Depth = 0;
-        public FancyLoggerNode(string id)
-        {
-            Id = id;
-        }
-        public FancyLoggerNode(int id, FancyLoggerNodeType type)
-        {
-            switch (type)
-            {
-                case FancyLoggerNodeType.Build:
-                    Id = $"build-{id}";
-                    break;
-                case FancyLoggerNodeType.Project:
-                    Id = $"project-{id}";
-                    break;
-                case FancyLoggerNodeType.Target:
-                    Id = $"target-{id}";
-                    break;
-                case FancyLoggerNodeType.Task:
-                    Id = $"task-{id}";
-                    break;
-                case FancyLoggerNodeType.Message:
-                    Id = $"message-{id}";
-                    break;
-                case FancyLoggerNodeType.Warning:
-                    Id = $"warning-{id}";
-                    break;
-                case FancyLoggerNodeType.Error:
-                    Id = $"error-{id}";
-                    break;
-                default:
-                    Id = id.ToString(); break;
-            }
-        }
-        public FancyLoggerNode? Find(string id)
-        {
-            // If self
-            if(Id == id) return this;
-            // If no children
-            if(Children.Count == 0) return null;
-            // Iterate
-            foreach (var child in Children)
-            {
-                FancyLoggerNode? node = child.Value.Find(id);
-                if (node != null) return node;
-            }
-            return null;
-        }
-
-        public void Add(FancyLoggerNode node)
-        {
-            if (Children.ContainsKey(node.Id)) return;
-            Children.Add(node.Id, node);
-            node.Depth = Depth + 1;
-            node.Parent = this;
-        }
-
-        public int GetLastLineIndex()
-        {
-            // If no line, return -1
-            if (Line == null) return -1;
-            // Get line index and id
-            int lastLineIndex = FancyLoggerBuffer.GetLineIndexById(Line.Id);
-            int lastLineId = Line.Id;
-            if (lastLineIndex == -1) return -1;
-            // Get max of children
-            foreach (var child in Children)
-            {
-                int childLastLineIndex = child.Value.GetLastLineIndex();
-                if (childLastLineIndex > lastLineIndex)
-                {
-                    lastLineIndex = childLastLineIndex;
-                    lastLineId = child.Value.Line!.Id;
-                }
-            }
-            return lastLineIndex;
-        }
-
-        public void Write()
-        {
-            if (Line == null) { return; }
-            // Adjust identation
-            Line.IdentationLevel = Depth - 1;
-            // If line not in the buffer, add
-            if (FancyLoggerBuffer.GetLineIndexById(Line.Id) == -1)
-            {
-                // Get parent last line index
-                if (Parent != null)
-                {
-                    int parentLastLineId = Parent.GetLastLineIndex();
-                    // if (parentLastLineId == -1) throw new Exception("Oops something went wrong");
-                    if (parentLastLineId == -1) return;
-                    // FancyLoggerBuffer.WriteNewLineAfter(Line, parentLastLineId);
-                    FancyLoggerBuffer.WriteNewLineAfterIndex(Line, parentLastLineId);
-                }
-            }
-        }
-
-        public void Collapse()
-        {
-            foreach (var child in Children)
-            {
-                if (child.Value.Line == null) continue;
-                FancyLoggerBuffer.HideLine(child.Value.Line.Id);
-                child.Value.Collapse();
-            }
-        }
-
-        public void Expand()
-        {
-            foreach (var child in Children)
-            {
-                if (child.Value.Line == null) continue;
-                FancyLoggerBuffer.UnhideLine(child.Value.Line.Id);
-                child.Value.Expand();
-            }
-        }
-    }
-}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
new file mode 100644
index 00000000000..146dd90b665
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
@@ -0,0 +1,117 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+    internal class FancyLoggerProjectNode
+    {
+        /// <summary>
+        /// Given a list of paths, this method will get the shortest not ambiguous path for a project.
+        /// Example: for `/users/documents/foo/project.csproj` and `/users/documents/bar/project.csproj`, the respective non ambiguous paths would be `foo/project.csproj` and `bar/project.csproj`
+        /// Still work in progress...
+        /// </summary>
+        private static string GetUnambiguousPath(string path)
+        {
+            return Path.GetFileName(path);
+        }
+
+        public int Id;
+        public string ProjectPath;
+        public string TargetFramework;
+        public bool Finished;
+        // Line to display project info
+        public FancyLoggerBufferLine? Line;
+        // Targets
+        public int FinishedTargets;
+        public FancyLoggerBufferLine? CurrentTargetLine;
+        public FancyLoggerTargetNode? CurrentTargetNode;
+        // Messages, errors and warnings
+        List<FancyLoggerMessageNode> AdditionalDetails = new();
+        public FancyLoggerProjectNode(ProjectStartedEventArgs args)
+        {
+            Id = args.ProjectId;
+            ProjectPath = args.ProjectFile!;
+            Finished = false;
+            FinishedTargets = 0;
+            if (args.GlobalProperties != null && args.GlobalProperties.ContainsKey("TargetFramework"))
+            {
+                TargetFramework = args.GlobalProperties["TargetFramework"];
+            }
+            else
+            {
+                TargetFramework = "";
+            }
+        }
+
+        public void Log()
+        {
+            // Project details
+            string lineContents = ANSIBuilder.Alignment.SpaceBetween(
+                $"{(Finished ? ANSIBuilder.Formatting.Color("✓", ANSIBuilder.Formatting.ForegroundColor.Green) : ANSIBuilder.Graphics.Spinner())} {ANSIBuilder.Formatting.Dim("Project: ")} {ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), Finished ? ANSIBuilder.Formatting.ForegroundColor.Green : ANSIBuilder.Formatting.ForegroundColor.Default )} [{TargetFramework}]",
+                $"({FinishedTargets} targets completed)",
+                Console.WindowWidth
+            );
+
+            // Create or update line
+            if (Line == null) Line = FancyLoggerBuffer.WriteNewLine(lineContents);
+            else FancyLoggerBuffer.UpdateLine(Line.Id, lineContents);
+
+            // For finished projects
+            if (Finished)
+            {
+                if (CurrentTargetLine != null) FancyLoggerBuffer.DeleteLine(CurrentTargetLine.Id);
+                foreach (FancyLoggerMessageNode node in AdditionalDetails)
+                {
+                    if (node.Line != null) FancyLoggerBuffer.DeleteLine(node.Line.Id);
+                    node.Line = null;
+                }
+            }
+
+            // Current target details
+            if (CurrentTargetNode == null) return;
+            string currentTargetLineContents = $"    └── {CurrentTargetNode.TargetName} : {CurrentTargetNode.CurrentTaskNode?.TaskName ?? String.Empty}";
+            if (CurrentTargetLine == null) CurrentTargetLine = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
+            else FancyLoggerBuffer.UpdateLine(CurrentTargetLine.Id, currentTargetLineContents);
+
+            // Messages, warnings and errors
+            foreach (FancyLoggerMessageNode node in AdditionalDetails)
+            {
+                if (node.Line == null) node.Line = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, "Message");
+                node.Log();
+            }
+        }
+
+        public void AddTarget(TargetStartedEventArgs args)
+        {
+            CurrentTargetNode = new FancyLoggerTargetNode(args);
+        }
+        public void AddTask(TaskStartedEventArgs args)
+        {
+            // Get target id
+            int targetId = args.BuildEventContext!.TargetId;
+            if (CurrentTargetNode?.Id == targetId)
+            {
+                CurrentTargetNode.AddTask(args);
+            }
+        }
+        public void AddMessage(BuildMessageEventArgs args)
+        {
+            if (args.Importance != MessageImportance.High) return;
+            AdditionalDetails.Add(new FancyLoggerMessageNode(args));
+        }
+        public void AddWarning(BuildWarningEventArgs args)
+        {
+            AdditionalDetails.Add(new FancyLoggerMessageNode(args));
+        }
+        public void AddError(BuildErrorEventArgs args)
+        {
+            AdditionalDetails.Add(new FancyLoggerMessageNode(args));
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs
new file mode 100644
index 00000000000..80195e8dd33
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs
@@ -0,0 +1,25 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    public class FancyLoggerTargetNode
+    {
+        public int Id;
+        public string TargetName;
+        public FancyLoggerTaskNode? CurrentTaskNode;
+        public FancyLoggerTargetNode(TargetStartedEventArgs args)
+        {
+            Id = args.BuildEventContext!.TargetId;
+            TargetName = args.TargetName;
+        }
+        public void AddTask(TaskStartedEventArgs args)
+        {
+            CurrentTaskNode = new FancyLoggerTaskNode(args);
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs
new file mode 100644
index 00000000000..d645a5daedc
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs
@@ -0,0 +1,20 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    public class FancyLoggerTaskNode
+    {
+        public int Id;
+        public string TaskName;
+        public FancyLoggerTaskNode(TaskStartedEventArgs args)
+        {
+            Id = args.BuildEventContext!.TaskId;
+            TaskName = args.TaskName;
+        }
+    }
+}
diff --git a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
index 84c2508d8e1..2e92c39751e 100644
--- a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
+++ b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Diagnostics;
 using System.Text;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 62d277bbdb2..8d7cf63540a 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using ColorSetter = Microsoft.Build.Logging.ColorSetter;
 using ColorResetter = Microsoft.Build.Logging.ColorResetter;
 using WriteHandler = Microsoft.Build.Logging.WriteHandler;
diff --git a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
index edd9b7ee18a..1cac0aa734f 100644
--- a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
@@ -5,7 +5,9 @@
 using System.Text;
 using System.Reflection;
 using System.Globalization;
+#if DEBUG
 using System.Diagnostics;
+#endif
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
diff --git a/src/Deprecated/Engine/Shared/ResourceUtilities.cs b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
index d6443759b87..3be5976f2aa 100644
--- a/src/Deprecated/Engine/Shared/ResourceUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
@@ -2,8 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+#if !BUILDINGAPPXTASKS && DEBUG
 using System.Resources;
 using System.Diagnostics;
+#endif
 using System.Globalization;
 using System.Text.RegularExpressions;
 
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index e3020e9de14..f6809d2e4bf 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -56,6 +56,7 @@
     <GenerateResourceMSBuildArchitecture>CurrentArchitecture</GenerateResourceMSBuildArchitecture>
     <GenerateResourceMSBuildRuntime>CurrentRuntime</GenerateResourceMSBuildRuntime>
 
+    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
 
     <PackageLicenseUrl Condition="'$(PackageLicenseExpression)' == ''">http://go.microsoft.com/fwlink/?LinkId=329770</PackageLicenseUrl>
diff --git a/src/Framework/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
index 32948ee3d39..e625642076d 100644
--- a/src/Framework/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -3,10 +3,13 @@
 
 using System;
 using System.Globalization;
-using System.Linq;
 using System.Reflection;
 
+#if !FEATURE_CULTUREINFO_GETCULTURES
+using System.Linq;
 using Microsoft.Build.Framework;
+#endif
+
 
 // Declare this to get init properties. See https://github.com/dotnet/roslyn/issues/45510#issuecomment-694977239
 #nullable disable
diff --git a/src/Framework/ErrorUtilities.cs b/src/Framework/ErrorUtilities.cs
index 20792056fb0..f90c6cc9d82 100644
--- a/src/Framework/ErrorUtilities.cs
+++ b/src/Framework/ErrorUtilities.cs
@@ -2,10 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 #nullable disable
 
diff --git a/src/Framework/FileClassifier.cs b/src/Framework/FileClassifier.cs
index a214a751443..9ea92f4fccb 100644
--- a/src/Framework/FileClassifier.cs
+++ b/src/Framework/FileClassifier.cs
@@ -4,11 +4,13 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
-using System.Linq;
 using System.Runtime.InteropServices;
+#if !RUNTIME_TYPE_NETCORE
+using System.Diagnostics;
+using System.Linq;
 using System.Text.RegularExpressions;
+#endif
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index f871d073876..68fd42df662 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -10,8 +10,6 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-using System.Text;
-using System.Threading;
 
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
diff --git a/src/Framework/Sdk/SdkResultItem.cs b/src/Framework/Sdk/SdkResultItem.cs
index febbbeffabc..7feba81b7e6 100644
--- a/src/Framework/Sdk/SdkResultItem.cs
+++ b/src/Framework/Sdk/SdkResultItem.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics.CodeAnalysis;
 using System.Linq;
 
 namespace Microsoft.Build.Framework
diff --git a/src/Framework/StringBuilderCache.cs b/src/Framework/StringBuilderCache.cs
index e8b0ebb30cb..5b21061d9ae 100644
--- a/src/Framework/StringBuilderCache.cs
+++ b/src/Framework/StringBuilderCache.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Diagnostics;
 using System.Text;
-#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
 using Microsoft.Build.Eventing;
 #endif
 
diff --git a/src/Framework/VisualStudioLocationHelper.cs b/src/Framework/VisualStudioLocationHelper.cs
index 4ec70063990..be2ec623f5b 100644
--- a/src/Framework/VisualStudioLocationHelper.cs
+++ b/src/Framework/VisualStudioLocationHelper.cs
@@ -1,7 +1,7 @@
 ﻿using System;
 using System.Collections.Generic;
-using System.Runtime.InteropServices;
 #if FEATURE_VISUALSTUDIOSETUP
+using System.Runtime.InteropServices;
 using Microsoft.VisualStudio.Setup.Configuration;
 #endif
 
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 90d1c081d5c..a2a6120ec55 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -10,10 +10,6 @@
 using System.Runtime.Serialization;
 using System.IO;
 using Microsoft.Build.BackEnd;
-#if FEATURE_ASSEMBLYLOADCONTEXT
-using System.Reflection.PortableExecutable;
-using System.Reflection.Metadata;
-#endif
 
 #nullable disable
 
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 86438f1da31..05abbdbab95 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Globalization;
-using System.Reflection;
 
 #nullable disable
 
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 6d5d9ebfd74..e67cbcbd153 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -10,7 +10,6 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
-using System.Reflection;
 
 #nullable disable
 
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 9251c6a3bcf..e21e214cb78 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -8,7 +8,9 @@
 using System.IO;
 using System.IO.Pipes;
 using System.Runtime.InteropServices;
+#if FEATURE_SECURITY_PRINCIPAL_WINDOWS
 using System.Security.Principal;
+#endif
 using System.Threading;
 
 using Microsoft.Build.Framework;
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 71af8039f57..74afacbce8a 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -2,7 +2,6 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
diff --git a/src/Shared/Debugging/DebugUtils.cs b/src/Shared/Debugging/DebugUtils.cs
index 3ae6cf16891..3ebdad82043 100644
--- a/src/Shared/Debugging/DebugUtils.cs
+++ b/src/Shared/Debugging/DebugUtils.cs
@@ -5,7 +5,6 @@
 using System;
 using System.Diagnostics;
 using System.IO;
-using System.Security;
 using System.Text.RegularExpressions;
 
 #nullable disable
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index 7584322ff2b..62110039952 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -3,11 +3,9 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Reflection;
 using System.Runtime.CompilerServices;
-using System.Text.RegularExpressions;
 using Microsoft.Build.Framework;
 using CommonWriterType = System.Action<string, string, System.Collections.Generic.IEnumerable<string>>;
 
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index 51a9e9465d2..905e705fcf9 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
 using System.Text;
 
 using Microsoft.Build.Framework;
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index 7c0db803f70..ace6e1e8159 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Globalization;
-using System.Text;
 
 using Microsoft.Build.Framework;
 
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index 6edc65786a8..c36cc5dee1b 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
 using System;
 using System.Collections.Generic;
 using System.IO;
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 2105da9a21a..28f8a292848 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -7,7 +7,9 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.Versioning;
+#if FEATURE_WIN32_REGISTRY
 using Microsoft.Win32;
+#endif
 
 using Microsoft.Build.Shared.FileSystem;
 
diff --git a/src/Shared/InprocTrackingNativeMethods.cs b/src/Shared/InprocTrackingNativeMethods.cs
index cbdd7b59d96..bd0bae9633a 100644
--- a/src/Shared/InprocTrackingNativeMethods.cs
+++ b/src/Shared/InprocTrackingNativeMethods.cs
@@ -11,9 +11,6 @@
 #endif
 using System.Security;
 using Microsoft.Build.Shared.FileSystem;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 #if FEATURE_RESOURCE_EXPOSURE
 using System.Runtime.Versioning;
 #endif
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index c7181787b69..0b2500390a3 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -2,10 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index 0e0e2913faf..d3ff339ced3 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -1,9 +1,11 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
+#if BUILD_ENGINE
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Evaluation;
+#else
+using Microsoft.Build.Utilities;
+#endif
 
 namespace Microsoft.Build.Shared
 {
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index 1146f026158..bf7fe3035c8 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -2,8 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+#if !BUILDINGAPPXTASKS && DEBUG
 using System.Resources;
 using System.Diagnostics;
+#endif
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.ComponentModel;
diff --git a/src/Shared/StrongNameHelpers.cs b/src/Shared/StrongNameHelpers.cs
index d0187a100da..d176b2c40a8 100644
--- a/src/Shared/StrongNameHelpers.cs
+++ b/src/Shared/StrongNameHelpers.cs
@@ -1,14 +1,14 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_STRONG_NAMES
+
 using System;
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 using System.Diagnostics.CodeAnalysis;
 using System.Reflection;
 
-#if FEATURE_STRONG_NAMES
-
 #nullable disable
 
 namespace Microsoft.Runtime.Hosting
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index c7e900625b8..c9dd8991a6a 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -8,7 +8,9 @@
 using System.Globalization;
 using System.Linq;
 using System.Reflection;
+#if FEATURE_APPDOMAIN
 using System.Security;
+#endif
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Shared/TaskParameterTypeVerifier.cs b/src/Shared/TaskParameterTypeVerifier.cs
index 4048d4f736d..7ac8fa58f67 100644
--- a/src/Shared/TaskParameterTypeVerifier.cs
+++ b/src/Shared/TaskParameterTypeVerifier.cs
@@ -2,9 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Reflection;
 using Microsoft.Build.Framework;
+#if NET35
 using Microsoft.Build.Shared;
-using System.Reflection;
+#endif
 
 #nullable disable
 
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 1111b257726..21c374dea84 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -6,7 +6,6 @@
 using System.Configuration;
 using System.IO;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index 09184fe4666..625006b9718 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -5,7 +5,9 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
+#if DEBUG
 using System.Reflection;
+#endif
 
 #nullable disable
 
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 825bc0a41d3..40d28f23b29 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -8,9 +8,6 @@
 using System.IO;
 using System.Reflection;
 using System.Runtime.InteropServices;
-#if !NETFRAMEWORK
-using System.Runtime.Loader;
-#endif
 using System.Threading;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index 1018c4b79aa..94cd21f7169 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -6,7 +6,6 @@
 #if !CLR2COMPATIBILITY
 using System.Runtime.InteropServices;
 #endif
-using System.Runtime.CompilerServices;
 
 #nullable disable
 
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
index 59da6520dcb..7dd2b72b9ac 100644
--- a/src/StringTools/InternableString.Simple.cs
+++ b/src/StringTools/InternableString.Simple.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Linq.Expressions;
 using System.Text;
 
 namespace System
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index 97d6ab34104..e1768f2bd0d 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 
 #nullable disable
 
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index d943ca958c1..9dc674cb6ac 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -2998,23 +2998,16 @@ private AssemblyTableInfo[] GetInstalledAssemblyTableInfo(bool ignoreInstalledAs
                 // Whidbey behavior was to accept a single TargetFrameworkDirectory, and multiple
                 // InstalledAssemblyTables, under the assumption that all of the InstalledAssemblyTables
                 // were related to the single TargetFrameworkDirectory.  If inputs look like the Whidbey
-                // case, let's make sure we behave the same way.
-
+                // case, let's make sure we behave the same way. Otherwise, use non-empty metadata.
                 if (String.IsNullOrEmpty(frameworkDirectory))
                 {
                     if (TargetFrameworkDirectories?.Length == 1)
                     {
                         // Exactly one TargetFrameworkDirectory, so assume it's related to this
                         // InstalledAssemblyTable.
-
                         frameworkDirectory = TargetFrameworkDirectories[0];
                     }
                 }
-                else
-                {
-                    // The metadata on the item was non-empty, so use it.
-                    frameworkDirectory = FileUtilities.EnsureTrailingSlash(frameworkDirectory);
-                }
 
                 tableMap[installedAssemblyTable.ItemSpec] = new AssemblyTableInfo(installedAssemblyTable.ItemSpec, frameworkDirectory);
             }
diff --git a/src/Tasks/AssemblyFolder.cs b/src/Tasks/AssemblyFolder.cs
index 6f5da7d008f..d8cafc0a6d6 100644
--- a/src/Tasks/AssemblyFolder.cs
+++ b/src/Tasks/AssemblyFolder.cs
@@ -3,7 +3,6 @@
 #if FEATURE_WIN32_REGISTRY
 
 using System;
-using System.IO;
 using System.Collections.Generic;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index bf29ead3d01..f7c09a4c3d4 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -3,7 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index e3fd34e9fc6..c47cd7f6f9a 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 #nullable disable
@@ -23,6 +22,7 @@ namespace Microsoft.Build.Tasks
     using System.Reflection;
     using System.Text;
     using System.Xml;
+    using Microsoft.Build.Shared.FileSystem;
 
     /// <summary>
     /// A task factory which can take code dom supported languages and create a task out of it
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index eaf732c4ec4..f1aa4c82c3f 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Runtime.InteropServices.ComTypes;
-using System.Text;
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 6b0a1f18a25..27c60d89d2a 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -4,7 +4,6 @@
 using System;
 using System.IO;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 #nullable disable
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index 1a4786a6477..0c2a3672ad0 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -4,8 +4,10 @@
 using System;
 using System.Collections.Generic;
 using System.Globalization;
+#if NET5_0_OR_GREATER
 using System.Linq;
 using Microsoft.Build.Framework;
+#endif
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index a9e46233824..0188c913368 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -23,9 +23,9 @@
 using System.Runtime.InteropServices;
 #if FEATURE_APPDOMAIN
 using System.Runtime.Remoting;
+using System.Runtime.Serialization.Formatters.Binary;
 #endif
 using System.Runtime.Serialization;
-using System.Runtime.Serialization.Formatters.Binary;
 #if !FEATURE_ASSEMBLYLOADCONTEXT
 using System.Runtime.Versioning;
 using System.Security;
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
index 9787b51e366..c68f60f13f9 100644
--- a/src/Tasks/GetCompatiblePlatform.cs
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -5,7 +5,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using System;
-using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks
 {
diff --git a/src/Tasks/LockCheck.cs b/src/Tasks/LockCheck.cs
index fd499d4bc93..237a138dd64 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Tasks/LockCheck.cs
@@ -7,7 +7,6 @@
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-using System.Text;
 
 #nullable disable
 
diff --git a/src/Tasks/ManifestUtil/MetadataReader.cs b/src/Tasks/ManifestUtil/MetadataReader.cs
index dc7fc6529d4..1b2dbef040f 100644
--- a/src/Tasks/ManifestUtil/MetadataReader.cs
+++ b/src/Tasks/ManifestUtil/MetadataReader.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Diagnostics.CodeAnalysis;
-using System.Runtime.InteropServices;
 using System.Collections.Specialized;
 #if RUNTIME_TYPE_NETCORE
 using System.Collections.Generic;
@@ -11,6 +9,9 @@
 using System.Reflection;
 using System.Reflection.Metadata;
 using System.Reflection.PortableExecutable;
+#else
+using System.Diagnostics.CodeAnalysis;
+using System.Runtime.InteropServices;
 #endif
 
 #nullable disable
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 986370caf84..8e16ee1a599 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -1,11 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Win32;
 using System;
 #if !RUNTIME_TYPE_NETCORE
+using Microsoft.Build.Framework;
 using System.Collections.Generic;
 #endif
 using System.ComponentModel;
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index ce5a2b4843e..dc7880cd52a 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -8,8 +8,10 @@
 using System.Globalization;
 using System.IO;
 using System.Runtime.InteropServices;
+#if !RUNTIME_TYPE_NETCORE
 using System.Security;
 using System.Security.Permissions;
+#endif
 using System.Xml;
 using Microsoft.Build.Shared.FileSystem;
 
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 0ff4125961f..b7f212ebe43 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -13,7 +13,9 @@
 using System.Collections;
 using System.Globalization;
 using System.Linq;
+#if FEATURE_HANDLEPROCESSCORRUPTEDSTATEEXCEPTIONS
 using System.Runtime.ExceptionServices;
+#endif
 using System.Text.RegularExpressions;
 using System.Runtime.Versioning;
 
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 6d2862fac49..2fdd200203a 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -918,8 +918,8 @@ internal class AssemblyTableInfo : IComparable
 
         internal AssemblyTableInfo(string path, string frameworkDirectory)
         {
-            Path = path;
-            FrameworkDirectory = frameworkDirectory;
+            Path = FileUtilities.NormalizeForPathComparison(path);
+            FrameworkDirectory = FileUtilities.NormalizeForPathComparison(frameworkDirectory);
         }
 
         internal string Path { get; }
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 143d69af4c5..530982c0f32 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -2,11 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
+#if FEATURE_RESXREADER_LIVEDESERIALIZATION
+using System.Collections;
 using System.Resources;
+#endif
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index c39a2eb609b..bdca81a2457 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -2,21 +2,25 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+#if !RUNTIME_TYPE_NETCORE
 using System.Collections.Generic;
+#endif
+#if !NET7_0_OR_GREATER
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Reflection;
 using System.Runtime.InteropServices;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 // TYPELIBATTR clashes with the one in InteropServices.
 using TYPELIBATTR = System.Runtime.InteropServices.ComTypes.TYPELIBATTR;
 using UtilitiesProcessorArchitecture = Microsoft.Build.Utilities.ProcessorArchitecture;
+#endif
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index 95e3a2ecf68..9960105ee1d 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -2,16 +2,16 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using System.IO;
-using System.Security.Cryptography;
 using System.Security.Cryptography.X509Certificates;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 #if FEATURE_PFX_SIGNING
+using System.Globalization;
+using System.Security.Cryptography;
 using Microsoft.Runtime.Hosting;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 #endif
 
 #nullable disable
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 0f2b3752dbe..a765f4a4d7a 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -5,7 +5,9 @@
 using System.IO;
 using System.Collections;
 using System.Collections.Generic;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/SetRidAgnosticValueForProjects.cs b/src/Tasks/SetRidAgnosticValueForProjects.cs
index 7e45e76f163..689a4eb9711 100644
--- a/src/Tasks/SetRidAgnosticValueForProjects.cs
+++ b/src/Tasks/SetRidAgnosticValueForProjects.cs
@@ -3,10 +3,7 @@
 //
 
 using System;
-using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 2ee63116123..88e0ed11611 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -4,7 +4,9 @@
 #if FEATURE_APPDOMAIN
 
 using System;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using System.IO;
 using System.Reflection;
 using System.Runtime.InteropServices;
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 5088a0ff87e..a781f20b2c3 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -6,12 +6,14 @@
 using System.CodeDom.Compiler;
 using System.Collections;
 using System.Collections.Generic;
-using System.Configuration;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
 using System.Linq;
+#if FEATURE_SYSTEM_CONFIGURATION
+using System.Configuration;
 using System.Security;
+#endif
 using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 7378f094c43..eec457b6a96 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -20,7 +20,6 @@ namespace Microsoft.Build.Tasks
     using System.Reflection;
     using System.Text;
     using System.Threading;
-    using System.Xml;
 
     /// <summary>
     /// The task factory provider for XAML tasks.
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index 0facabc1b83..2a0ecc35e16 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -23,7 +23,9 @@
 
 using System;
 using System.IO;
+#if FEATURE_RESXREADER_LIVEDESERIALIZATION
 using System.Collections;
+#endif
 using System.Collections.Generic;
 using System.Resources;
 using System.CodeDom;
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index 67cb313a50e..dc79f6c8cc1 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -1,6 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#pragma warning disable 0219
+
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.IO;
@@ -12,10 +16,6 @@
 using Microsoft.Build.Utilities;
 using Xunit;
 
-#pragma warning disable 0219
-
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.UnitTests.TrackedDependencies
diff --git a/src/Utilities/ProcessorArchitecture.cs b/src/Utilities/ProcessorArchitecture.cs
index 6c846b7f094..188b0c6b2ef 100644
--- a/src/Utilities/ProcessorArchitecture.cs
+++ b/src/Utilities/ProcessorArchitecture.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Diagnostics.CodeAnalysis;
-using Microsoft.Build.Shared;
 
 #nullable disable
 
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 53f3d588300..edba3b1af42 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -5,9 +5,8 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
-using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
+using System.Security;
 #endif
 
 using Microsoft.Build.Framework;
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
index 1d59803aa05..2343b93060f 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
@@ -1,13 +1,13 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 99c1745f803..46495392855 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.Collections.Concurrent;
@@ -11,8 +13,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 2ccbbce8f3b..550f3bc8d35 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
@@ -9,8 +11,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/DependencyTableCache.cs b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
index ac4d674e0a8..d87e3ea9507 100644
--- a/src/Utilities/TrackedDependencies/DependencyTableCache.cs
+++ b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -9,8 +11,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index 1c6529ac55d..3a3b9d71130 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
@@ -12,8 +14,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
