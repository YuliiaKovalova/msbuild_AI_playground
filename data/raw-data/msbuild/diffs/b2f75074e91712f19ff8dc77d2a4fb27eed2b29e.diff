diff --git a/eng/Packages.props b/eng/Packages.props
index ebd0d0e551f..bee7dad7269 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -1,4 +1,12 @@
 <Project>
+
+  <PropertyGroup>
+      <NuGetPackageVersion>5.9.0-preview.1.6870</NuGetPackageVersion>
+      <NuGetBuildTasksVersion Condition="'$(NuGetBuildTasksVersion)' == ''">$(NuGetPackageVersion)</NuGetBuildTasksVersion>
+      <NuGetCommandsVersion Condition="'$(NuGetCommandsVersion)' == ''">$(NuGetPackageVersion)</NuGetCommandsVersion>
+      <NuGetProtocolVersion Condition="'$(NuGetProtocolVersion)' == ''">$(NuGetPackageVersion)</NuGetProtocolVersion>
+  </PropertyGroup>
+
   <ItemGroup>
     <PackageReference Update="jnm2.ReferenceAssemblies.net35" Version="1.0.1" />
     <PackageReference Update="LargeAddressAware" Version="1.0.3" />
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 1d4f2a4bf71..f9b9740a16a 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -2,13 +2,19 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Text;
-using System.Reflection;
-using System.Globalization;
 using System.Collections.Generic;
 using System.Configuration.Assemblies;
-using System.Runtime.Serialization;
+using System.Globalization;
 using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Runtime.Serialization;
+using System.Text;
+#if !NET35
+using System.Text.Encodings.Web;
+using System.Text.Json;
+using System.Text.Json.Serialization;
+#endif
 #if FEATURE_ASSEMBLYLOADCONTEXT
 using System.Reflection.PortableExecutable;
 using System.Reflection.Metadata;
@@ -315,6 +321,11 @@ internal Version Version
                 CreateAssemblyName();
                 return asAssemblyName.Version;
             }
+            set
+            {
+                CreateAssemblyName();
+                asAssemblyName.Version = value;
+            }
         }
 
         /// <summary>
@@ -993,5 +1004,237 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)
             info.AddValue("immutable", immutable);
             info.AddValue("remapped", remappedFrom);
         }
+
+#if !NET35
+        internal class Converter : JsonConverter<AssemblyNameExtension>
+        {
+            public override AssemblyNameExtension Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
+            {
+                AssemblyNameExtension ane = new AssemblyNameExtension();
+                if (reader.TokenType != JsonTokenType.StartObject)
+                {
+                    throw new JsonException();
+                }
+                while (reader.Read())
+                {
+                    if (reader.TokenType == JsonTokenType.EndObject)
+                    {
+                        return ane;
+                    }
+                    else if (reader.TokenType == JsonTokenType.Null)
+                    {
+                        return null;
+                    }
+                    else if (reader.TokenType != JsonTokenType.PropertyName)
+                    {
+                        throw new JsonException();
+                    }
+                    string parameter = reader.GetString();
+                    reader.Read();
+                    if (reader.TokenType == JsonTokenType.Null)
+                    {
+                        continue;
+                    }
+                    switch (parameter)
+                    {
+                        case nameof(ane.asAssemblyName):
+                            AssemblyName an = new AssemblyName();
+                            while (reader.Read())
+                            {
+                                if (reader.TokenType == JsonTokenType.EndObject)
+                                {
+                                    ane.asAssemblyName = an;
+                                    break;
+                                }
+                                if (reader.TokenType != JsonTokenType.PropertyName)
+                                {
+                                    throw new JsonException();
+                                }
+                                string anParameter = reader.GetString();
+                                reader.Read();
+                                if (reader.TokenType == JsonTokenType.Null)
+                                {
+                                    continue;
+                                }
+                                switch (anParameter)
+                                {
+                                    case nameof(an.Name):
+                                        an.Name = reader.GetString();
+                                        break;
+                                    case "PublicKey":
+                                        an.SetPublicKey(ParseByteArray(ref reader));
+                                        break;
+                                    case "PublicKeyToken":
+                                        an.SetPublicKeyToken(ParseByteArray(ref reader));
+                                        break;
+                                    case nameof(an.Version):
+                                        an.Version = Version.Parse(reader.GetString());
+                                        break;
+                                    case "Flags":
+                                        an.Flags = (AssemblyNameFlags)reader.GetDecimal();
+                                        break;
+                                    case "CPUArch":
+                                        an.ProcessorArchitecture = (ProcessorArchitecture)reader.GetDecimal();
+                                        break;
+                                    case nameof(an.CultureInfo):
+                                        an.CultureInfo = new CultureInfo(reader.GetString());
+                                        break;
+                                    case "HashAlg":
+                                        an.HashAlgorithm = (System.Configuration.Assemblies.AssemblyHashAlgorithm)reader.GetDecimal();
+                                        break;
+                                    case "VersionCompat":
+                                        an.VersionCompatibility = (AssemblyVersionCompatibility)reader.GetDecimal();
+                                        break;
+                                    case nameof(an.CodeBase):
+                                        an.CodeBase = reader.GetString();
+                                        break;
+                                    case nameof(an.KeyPair):
+                                        an.KeyPair = new StrongNameKeyPair(reader.GetString());
+                                        break;
+                                    default:
+                                        throw new JsonException();
+                                }
+                            }
+                            break;
+                        case nameof(ane.asString):
+                            ane.asString = reader.GetString();
+                            break;
+                        case nameof(ane.isSimpleName):
+                            ane.isSimpleName = reader.GetBoolean();
+                            break;
+                        case nameof(ane.hasProcessorArchitectureInFusionName):
+                            ane.hasProcessorArchitectureInFusionName = reader.GetBoolean();
+                            break;
+                        case nameof(ane.immutable):
+                            ane.immutable = reader.GetBoolean();
+                            break;
+                        case nameof(ane.remappedFrom):
+                            ane.remappedFrom = ParseArray<AssemblyNameExtension>(ref reader, this);
+                            break;
+                    }
+                }
+                throw new JsonException();
+            }
+
+            private HashSet<T> ParseArray<T>(ref Utf8JsonReader reader, JsonConverter<T> converter)
+            {
+                // If the array is null
+                if (reader.TokenType != JsonTokenType.StartArray)
+                {
+                    return null;
+                }
+                HashSet<T> ret = new HashSet<T>();
+                while (reader.Read())
+                {
+                    if (reader.TokenType == JsonTokenType.EndArray)
+                    {
+                        return ret;
+                    }
+                    ret.Add(converter.Read(ref reader, typeof(T), new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping }));
+                }
+                throw new JsonException();
+            }
+
+            public override void Write(Utf8JsonWriter writer, AssemblyNameExtension asn, JsonSerializerOptions options)
+            {
+                writer.WriteStartObject();
+                if (asn.asAssemblyName != null)
+                {
+                    writer.WritePropertyName(nameof(asn.asAssemblyName));
+                    writer.WriteStartObject();
+                    writer.WriteString(nameof(asn.asAssemblyName.Name), asn.asAssemblyName.Name);
+                    byte[] publicKey = asn.asAssemblyName.GetPublicKey();
+                    if (publicKey != null)
+                    {
+                        writer.WritePropertyName("PublicKey");
+                        writer.WriteStartArray();
+                        foreach (byte b in asn.asAssemblyName.GetPublicKey())
+                        {
+                            writer.WriteNumberValue(b);
+                        }
+                        writer.WriteEndArray();
+                    }
+                    byte[] publicKeyToken = asn.asAssemblyName.GetPublicKeyToken();
+                    if (publicKeyToken != null)
+                    {
+                        writer.WritePropertyName("PublicKeyToken");
+                        writer.WriteStartArray();
+                        foreach (byte b in asn.asAssemblyName.GetPublicKeyToken())
+                        {
+                            writer.WriteNumberValue(b);
+                        }
+                        writer.WriteEndArray();
+                    }
+                    if (asn.asAssemblyName.Version != null)
+                    {
+                        writer.WriteString(nameof(asn.asAssemblyName.Version), asn.asAssemblyName.Version.ToString());
+                    }
+                    writer.WriteNumber("Flags", (int)asn.asAssemblyName.Flags);
+                    writer.WriteNumber("CPUArch", (int)asn.asAssemblyName.ProcessorArchitecture);
+                    if (asn.asAssemblyName.CultureInfo != null)
+                    {
+                        writer.WriteString(nameof(asn.asAssemblyName.CultureInfo), asn.asAssemblyName.CultureInfo.ToString());
+                    }
+                    writer.WriteNumber("HashAlg", (int)asn.asAssemblyName.HashAlgorithm);
+                    writer.WriteNumber("VersionCompat", (int)asn.asAssemblyName.VersionCompatibility);
+                    writer.WriteString(nameof(asn.asAssemblyName.CodeBase), asn.asAssemblyName.CodeBase);
+                    if (asn.asAssemblyName.KeyPair != null)
+                    {
+                        writer.WriteString(nameof(asn.asAssemblyName.KeyPair), asn.asAssemblyName.KeyPair.ToString());
+                    }
+                    writer.WriteEndObject();
+                }
+                writer.WriteString(nameof(asn.asString), asn.asString);
+                writer.WriteBoolean(nameof(asn.isSimpleName), asn.isSimpleName);
+                writer.WriteBoolean(nameof(asn.hasProcessorArchitectureInFusionName), asn.hasProcessorArchitectureInFusionName);
+                writer.WriteBoolean(nameof(asn.immutable), asn.immutable);
+                if (asn.remappedFrom != null)
+                {
+                    writer.WritePropertyName(nameof(asn.remappedFrom));
+                    writer.WriteStartArray();
+                    JsonSerializerOptions aneOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
+                    bool first = true;
+                    foreach (AssemblyNameExtension ane in asn.remappedFrom)
+                    {
+                        if (first)
+                        {
+                            first = false;
+                        }
+                        else
+                        {
+                            writer.WriteStringValue(string.Empty);
+                        }
+                        if (ane is null)
+                        {
+                            writer.WriteNullValue();
+                            continue;
+                        }
+                        Write(writer, ane, aneOptions);
+                    }
+                    writer.WriteEndArray();
+                }
+                writer.WriteEndObject();
+            }
+
+            private byte[] ParseByteArray(ref Utf8JsonReader reader)
+            {
+                // If the array is null
+                if (reader.TokenType != JsonTokenType.StartArray)
+                {
+                    return null;
+                }
+                List<byte> ret = new List<byte>();
+                while (reader.Read())
+                {
+                    if (reader.TokenType == JsonTokenType.EndArray)
+                    {
+                        return ret.ToArray();
+                    }
+                    ret.Add(reader.GetByte());
+                }
+                throw new JsonException();
+            }
+        }
+#endif
     }
 }
diff --git a/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
new file mode 100644
index 00000000000..cb6a455050e
--- /dev/null
+++ b/src/Tasks.UnitTests/RARPrecomputedCache_Tests.cs
@@ -0,0 +1,108 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+using Microsoft.Build.Framework;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.Utilities;
+using Shouldly;
+using System;
+using System.Collections.Generic;
+using System.IO;
+using Xunit;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    public class RARPrecomputedCache_Tests
+    {
+        [Fact]
+        public void TestPrecomputedCacheOutput()
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFile standardCache = env.CreateFile(".cache");
+                ResolveAssemblyReference t = new ResolveAssemblyReference()
+                {
+                    _cache = new SystemState()
+                };
+                t._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {
+                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(DateTime.Now) },
+                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                t._cache.IsDirty = true;
+                t.StateFile = standardCache.Path;
+                t.WriteStateFile();
+                int standardLen = File.ReadAllText(standardCache.Path).Length;
+                File.Delete(standardCache.Path);
+                standardLen.ShouldBeGreaterThan(0);
+
+                string precomputedPath = standardCache.Path + ".cache";
+                t._cache.IsDirty = true;
+                t.AssemblyInformationCacheOutputPath = precomputedPath;
+                t.WriteStateFile();
+                File.Exists(standardCache.Path).ShouldBeFalse();
+                int preLen = File.ReadAllText(precomputedPath).Length;
+                preLen.ShouldBeGreaterThan(0);
+                preLen.ShouldNotBe(standardLen);
+            }
+        }
+
+        [Fact]
+        public void TestPreComputedCacheInputAndOutput()
+        {
+            using (TestEnvironment env = TestEnvironment.Create()) {
+                TransientTestFile standardCache = env.CreateFile(".cache");
+                ResolveAssemblyReference rarWriterTask = new ResolveAssemblyReference()
+                {
+                    _cache = new SystemState()
+                };
+                rarWriterTask._cache.instanceLocalFileStateCache = new Dictionary<string, SystemState.FileState>() {
+                    { Path.Combine(standardCache.Path, "assembly1"), new SystemState.FileState(DateTime.Now) },
+                    { Path.Combine(standardCache.Path, "assembly2"), new SystemState.FileState(DateTime.Now) { Assembly = new Shared.AssemblyNameExtension("hi") } } };
+                rarWriterTask.StateFile = standardCache.Path;
+                rarWriterTask._cache.IsDirty = true;
+                rarWriterTask.WriteStateFile();
+
+                string dllName = Path.Combine(Path.GetDirectoryName(standardCache.Path), "randomFolder", "dll.dll");
+                rarWriterTask._cache.instanceLocalFileStateCache.Add(dllName,
+                    new SystemState.FileState(DateTime.Now) {
+                        Assembly = new Shared.AssemblyNameExtension("notDll.dll", false),
+                        RuntimeVersion = "v4.0.30319",
+                        FrameworkNameAttribute = new System.Runtime.Versioning.FrameworkName(".NETFramework", Version.Parse("4.7.2"), "Profile"),
+                        scatterFiles = new string[] { "first", "second" } });
+                rarWriterTask._cache.instanceLocalFileStateCache[dllName].Assembly.Version = new Version("16.3");
+                string precomputedCachePath = standardCache.Path + ".cache";
+                rarWriterTask.AssemblyInformationCacheOutputPath = precomputedCachePath;
+                rarWriterTask._cache.IsDirty = true;
+                rarWriterTask.WriteStateFile();
+                // The cache is already written; this change should do nothing.
+                rarWriterTask._cache.instanceLocalFileStateCache[dllName].Assembly = null;
+
+                ResolveAssemblyReference rarReaderTask = new ResolveAssemblyReference();
+                rarReaderTask.StateFile = standardCache.Path;
+                rarReaderTask.AssemblyInformationCachePaths = new ITaskItem[]
+                {
+                    new TaskItem(precomputedCachePath)
+                };
+
+                // At this point, we should have created two cache files: one "normal" one and one "precomputed" one.
+                // When we read the state file the first time, it should read from the caches produced in a normal
+                // build, partially because we can read it faster. If that cache does not exist, as with the second
+                // time we try to read the state file, it defaults to reading the "precomputed" cache. In this case,
+                // the normal cache does not have dll.dll, whereas the precomputed cache does, so it should not be
+                // present when we read the first time but should be present the second time. Then we verify that the
+                // information contained in that cache matches what we'd expect.
+                rarReaderTask.ReadStateFile(File.GetLastWriteTime, Array.Empty<AssemblyTableInfo>(), p => true);
+                rarReaderTask._cache.instanceLocalFileStateCache.ShouldNotContainKey(dllName);
+                File.Delete(standardCache.Path);
+                rarReaderTask._cache = null;
+                rarReaderTask.ReadStateFile(File.GetLastWriteTime, Array.Empty<AssemblyTableInfo>(), p => true);
+                rarReaderTask._cache.instanceLocalFileStateCache.ShouldContainKey(dllName);
+                SystemState.FileState assembly3 = rarReaderTask._cache.instanceLocalFileStateCache[dllName];
+                assembly3.Assembly.FullName.ShouldBe("notDll.dll");
+                assembly3.Assembly.Version.Major.ShouldBe(16);
+                assembly3.RuntimeVersion.ShouldBe("v4.0.30319");
+                assembly3.FrameworkNameAttribute.Version.ShouldBe(Version.Parse("4.7.2"));
+                assembly3.scatterFiles.Length.ShouldBe(2);
+                assembly3.scatterFiles[1].ShouldBe("second");
+            }
+        }
+    }
+}
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 90af55781f5..4f561d035b3 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -10,6 +10,8 @@
 using System.Linq;
 using System.Reflection;
 using System.Text;
+using System.Text.Encodings.Web;
+using System.Text.Json;
 using System.Xml.Linq;
 
 using Microsoft.Build.Eventing;
@@ -49,7 +51,7 @@ public class ResolveAssemblyReference : TaskExtension
         /// <summary>
         /// Cache of system state information, used to optimize performance.
         /// </summary>
-        private SystemState _cache = null;
+        internal SystemState _cache = null;
 
         /// <summary>
         /// Construct
@@ -1855,27 +1857,46 @@ private void LogConflict(Reference reference, string fusionName, StringBuilder l
 
         #region StateFile
         /// <summary>
-        /// Reads the state file (if present) into the cache.
+        /// Reads the state file (if present) into the cache. If not present, attempts to read from CacheInputPaths, then creates a new cache if necessary.
         /// </summary>
-        private void ReadStateFile()
+        internal void ReadStateFile(GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists = null)
         {
-            _cache = (SystemState)StateFileBase.DeserializeCache(_stateFile, Log, typeof(SystemState));
+            var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
+            deserializeOptions.Converters.Add(new SystemState.Converter());
+            try
+            {
+                _cache = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(_stateFile), deserializeOptions);
+            }
+            catch (Exception)
+            {
+                // log message
+            }
 
-            // Construct the cache if necessary.
             if (_cache == null)
             {
-                _cache = new SystemState();
+                _cache = SystemState.DeserializePrecomputedCaches(AssemblyInformationCachePaths ?? Array.Empty<ITaskItem>(), Log, typeof(SystemState), getLastWriteTime, installedAssemblyTableInfo, fileExists);
+            }
+            else
+            {
+                _cache.SetGetLastWriteTime(getLastWriteTime);
+                _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);
             }
         }
 
         /// <summary>
-        /// Write out the state file if a state name was supplied and the cache is dirty.
+        /// If CacheOutputPath is non-null, writes out a cache to that location. Otherwise, writes out the state file if a state name was supplied and the cache is dirty.
         /// </summary>
-        private void WriteStateFile()
+        internal void WriteStateFile()
         {
-            if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
+            if (!string.IsNullOrEmpty(AssemblyInformationCacheOutputPath))
+            {
+                _cache.SerializePrecomputedCache(AssemblyInformationCacheOutputPath, Log);
+            }
+            else if (!string.IsNullOrEmpty(_stateFile) && _cache.IsDirty)
             {
-                _cache.SerializeCache(_stateFile, Log);
+                var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
+                deserializeOptions.Converters.Add(new SystemState.Converter());
+                File.WriteAllText(_stateFile, JsonSerializer.Serialize<SystemState>(_cache, deserializeOptions));
             }
         }
         #endregion
@@ -2105,9 +2126,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     }
 
                     // Load any prior saved state.
-                    ReadStateFile();
-                    _cache.SetGetLastWriteTime(getLastWriteTime);
-                    _cache.SetInstalledAssemblyInformation(installedAssemblyTableInfo);
+                    ReadStateFile(getLastWriteTime, installedAssemblyTableInfo);
 
                     // Cache delegates.
                     getAssemblyName = _cache.CacheDelegate(getAssemblyName);
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index f70cb0e0dc6..3c4c024cd2e 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -986,6 +986,7 @@
   </ItemGroup>
   <ItemGroup>
     <PackageReference Include="System.Collections.Immutable" />
+    <PackageReference Include="System.Reflection.Metadata" />
     <PackageReference Include="System.Resources.Extensions" />
   </ItemGroup>
 
@@ -993,6 +994,7 @@
   <ItemGroup>
     <!-- Reference this package to get binaries at runtime even when Arcade is not adding compiler references -->
     <PackageReference Include="Microsoft.Net.Compilers.Toolset" ExcludeAssets="all" Condition="'$(UsingToolMicrosoftNetCompilers)' == 'false'" />
+    <PackageReference Include="System.Text.Json" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'">
@@ -1004,7 +1006,6 @@
 
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <PackageReference Include="System.CodeDom" />
-    <PackageReference Include="System.Reflection.Metadata" />
     <PackageReference Include="System.Reflection.TypeExtensions" />
     <PackageReference Include="System.Runtime.InteropServices" />
     <PackageReference Include="System.Security.Cryptography.Pkcs" />
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index 3fdf14ffd43..e73626a691e 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -74,8 +74,7 @@ public override bool Execute()
 
             if ((AssemblyListFile?.ItemSpec.Length > 0))
             {
-                cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache)) ??
-                            new AssemblyRegistrationCache();
+                cacheFile = StateFileBase.DeserializeCache<AssemblyRegistrationCache>(AssemblyListFile.ItemSpec, Log) ?? new AssemblyRegistrationCache();
             }
 
             bool taskReturnValue = true;
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 3632a916d83..ccacacb77d5 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -167,7 +167,7 @@ internal override void SerializeCache(string stateFile, TaskLoggingHelper log)
         /// </summary>
         internal static ResGenDependencies DeserializeCache(string stateFile, bool useSourcePath, TaskLoggingHelper log)
         {
-            var retVal = (ResGenDependencies)DeserializeCache(stateFile, log, typeof(ResGenDependencies)) ?? new ResGenDependencies();
+            var retVal = DeserializeCache<ResGenDependencies>(stateFile, log) ?? new ResGenDependencies();
 
             // Ensure that the cache is properly initialized with respect to how resgen will 
             // resolve linked files within .resx files.  ResGen has two different
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index a8cf11d7a56..818d5fae2b1 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -324,7 +324,7 @@ public override bool Execute()
             allProjectRefs = new List<ComReferenceInfo>();
             allDependencyRefs = new List<ComReferenceInfo>();
 
-            _timestampCache = (ResolveComReferenceCache)StateFileBase.DeserializeCache(StateFile, Log, typeof(ResolveComReferenceCache));
+            _timestampCache = StateFileBase.DeserializeCache<ResolveComReferenceCache>(StateFile, Log);
 
             if (_timestampCache?.ToolPathsMatchCachePaths(_tlbimpPath, _aximpPath) != true)
             {
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index b465dd10789..8763208d60c 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -451,6 +451,10 @@
     <value>MSB3101: Could not write state file "{0}". {1}</value>
     <comment>{StrBegin="MSB3101: "}</comment>
   </data>
+  <data name="General.StateFileAlreadyPresent">
+    <value>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</value>
+    <comment>{StrBegin="MSB3667: "}</comment>
+  </data>
   <data name="General.DuplicateItemsNotSupported">
     <value>MSB3105: The item "{0}" was specified more than once in the "{1}" parameter.  Duplicate items are not supported by the "{1}" parameter.</value>
     <comment>{StrBegin="MSB3105: "}</comment>
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index d63041a77a8..87738ba6838 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Globální vlastnosti:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Odstraňování vlastností:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 6f55e8ffb7d..26da37dc629 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Globale Eigenschaften:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Eigenschaften werden entfernt:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.en.xlf b/src/Tasks/Resources/xlf/Strings.en.xlf
index 0c447b05ab3..7283348b631 100644
--- a/src/Tasks/Resources/xlf/Strings.en.xlf
+++ b/src/Tasks/Resources/xlf/Strings.en.xlf
@@ -554,6 +554,11 @@
         <target state="new">Global Properties:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="new">Removing Properties:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 620929ddfe8..f25cd317d62 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Propiedades globales:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Quitando propiedades:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 11359a59620..d237c187790 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Propriétés globales :</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Suppression des propriétés :</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 39b30cfbacb..627586b4659 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Proprietà globali:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Rimozione proprietà:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index 8166fd4d2dd..adaf0cf558e 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -509,6 +509,11 @@
         <target state="translated">グローバル プロパティ:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">プロパティの削除:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index dd566fd77b2..6cb5fb6cdb6 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -509,6 +509,11 @@
         <target state="translated">전역 속성:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">속성 제거:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index bf99b39d5ea..a7e374cb242 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Właściwości globalne:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Usuwanie właściwości:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index dc823788e5c..a7ae22a85b0 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Propriedades globais:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Removendo Propriedades:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 9e7588f33eb..9f4541597f8 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Глобальные свойства:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Удаление свойств:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index f4e09678061..2dc326bcd54 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -509,6 +509,11 @@
         <target state="translated">Genel Özellikler:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">Özellikler kaldırılıyor:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index 37aa968f49b..c1836ec8099 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -509,6 +509,11 @@
         <target state="translated">全局属性:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">移除属性:</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index 2fa9517589f..23e53494450 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -509,6 +509,11 @@
         <target state="translated">全域屬性:</target>
         <note />
       </trans-unit>
+      <trans-unit id="General.StateFileAlreadyPresent">
+        <source>MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</source>
+        <target state="new">MSB3667: There is already a file at "{0}". If you are trying to create a precomputed cache, ensure that you are building a single project that depends on your assemblies rather than building your assemblies themselves. If you are running the ResolveAssemblyReference task normally, do not set the "AssemblyInformationCacheOutputPath" parameter of the ResolveAssemblyReference task.</target>
+        <note>{StrBegin="MSB3667: "}</note>
+      </trans-unit>
       <trans-unit id="General.UndefineProperties">
         <source>Removing Properties:</source>
         <target state="translated">正在移除屬性:</target>
diff --git a/src/Tasks/StateFileBase.cs b/src/Tasks/StateFileBase.cs
index 3d17a4967a4..8fc4ee04b40 100644
--- a/src/Tasks/StateFileBase.cs
+++ b/src/Tasks/StateFileBase.cs
@@ -64,9 +64,10 @@ internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log)
         /// <summary>
         /// Reads the specified file from disk into a StateFileBase derived object.
         /// </summary>
-        internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelper log, Type requiredReturnType)
+        internal static T DeserializeCache<T>(string stateFile, TaskLoggingHelper log, bool logWarnings = true) where T : StateFileBase
         {
-            StateFileBase retVal = null;
+            T retVal = null;
+            object deserializedObject = null;
 
             // First, we read the cache from disk if one exists, or if one does not exist
             // then we create one.  
@@ -77,32 +78,35 @@ internal static StateFileBase DeserializeCache(string stateFile, TaskLoggingHelp
                     using (FileStream s = new FileStream(stateFile, FileMode.Open))
                     {
                         var formatter = new BinaryFormatter();
-                        object deserializedObject = formatter.Deserialize(s);
-                        retVal = deserializedObject as StateFileBase;
-
-                        // If the deserialized object is null then there would be no cast error but retVal would still be null
-                        // only log the message if there would have been a cast error
-                        if (retVal == null && deserializedObject != null)
-                        {
-                            // When upgrading to Visual Studio 2008 and running the build for the first time the resource cache files are replaced which causes a cast error due
-                            // to a new version number on the tasks class. "Unable to cast object of type 'Microsoft.Build.Tasks.SystemState' to type 'Microsoft.Build.Tasks.StateFileBase".
-                            // If there is an invalid cast, a message rather than a warning should be emitted.
-                            log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
-                        }
-
-                        if ((retVal != null) && (!requiredReturnType.IsInstanceOfType(retVal)))
+                        deserializedObject = formatter.Deserialize(s);
+                        retVal = deserializedObject as T;
+                    }
+                    // If the deserialized object is null then there would be no cast error but retVal would still be null
+                    // only log the message if there would have been a cast error
+                    if (retVal == null && deserializedObject != null)
+                    {
+                        // When upgrading to Visual Studio 2008 and running the build for the first time the resource cache files are replaced which causes a cast error due
+                        // to a new version number on the tasks class. "Unable to cast object of type 'Microsoft.Build.Tasks.SystemState' to type 'Microsoft.Build.Tasks.StateFileBase".
+                        // If there is an invalid cast, a message rather than a warning should be emitted.
+                        log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
+                    }
+                    else if (retVal != null && !(retVal is T))
+                    {
+                        if (logWarnings)
                         {
-                            log.LogWarningWithCodeFromResources("General.CouldNotReadStateFile", stateFile,
-                                log.FormatResourceString("General.IncompatibleStateFileType"));
-                            retVal = null;
+                            log.LogWarningWithCodeFromResources("General.CouldNotReadStateFile", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
                         }
-
-                        // If we get back a valid object and internals were changed, things are likely to be null. Check the version before we use it.
-                        if (retVal != null && retVal._serializedVersion != CurrentSerializationVersion)
+                        else
                         {
-                            log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
-                            retVal = null;
+                            log.LogMessageFromResources("General.CouldNotReadStateFile", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
                         }
+                        retVal = null;
+                    }
+                    // If we get back a valid object and internals were changed, things are likely to be null. Check the version before we use it.
+                    else if (retVal != null && retVal._serializedVersion != CurrentSerializationVersion)
+                    {
+                        log.LogMessageFromResources("General.CouldNotReadStateFileMessage", stateFile, log.FormatResourceString("General.IncompatibleStateFileType"));
+                        retVal = null;
                     }
                 }
             }
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 1dd51c92c86..2dbb3dd9bd9 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -2,17 +2,24 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
-using System.Runtime.Serialization;
+using System.Reflection.Metadata;
+using System.Reflection.PortableExecutable;
+using System.Runtime.CompilerServices;
 using System.Runtime.Versioning;
+using System.Text.Encodings.Web;
+using System.Text.Json;
+using System.Text.Json.Serialization;
 using System.Security.Permissions;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.AssemblyDependency;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Tasks
 {
@@ -20,7 +27,7 @@ namespace Microsoft.Build.Tasks
     /// Class is used to cache system state.
     /// </summary>
     [Serializable]
-    internal sealed class SystemState : StateFileBase, ISerializable
+    internal sealed class SystemState
     {
         /// <summary>
         /// Cache at the SystemState instance level. Has the same contents as <see cref="instanceLocalFileStateCache"/>.
@@ -31,7 +38,7 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// <summary>
         /// Cache at the SystemState instance level. It is serialized and reused between instances.
         /// </summary>
-        private Hashtable instanceLocalFileStateCache = new Hashtable(StringComparer.OrdinalIgnoreCase);
+        internal Dictionary<string, FileState> instanceLocalFileStateCache = new Dictionary<string, FileState>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// LastModified information is purely instance-local. It doesn't make sense to
@@ -108,18 +115,8 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// Class that holds the current file state.
         /// </summary>
         [Serializable]
-        private sealed class FileState : ISerializable
+        internal sealed class FileState
         {
-            /// <summary>
-            /// The last modified time for this file.
-            /// </summary>
-            private DateTime lastModified;
-
-            /// <summary>
-            /// The fusion name of this file.
-            /// </summary>
-            private AssemblyNameExtension assemblyName;
-
             /// <summary>
             /// The assemblies that this file depends on.
             /// </summary>
@@ -135,91 +132,38 @@ private sealed class FileState : ISerializable
             /// </summary>
             internal FrameworkName frameworkName;
 
-            /// <summary>
-            /// The CLR runtime version for the assembly.
-            /// </summary>
-            internal string runtimeVersion;
-
             /// <summary>
             /// Default construct.
             /// </summary>
             internal FileState(DateTime lastModified)
             {
-                this.lastModified = lastModified;
+                this.LastModified = lastModified;
             }
 
             /// <summary>
-            /// Deserializing constuctor.
+            /// Simplified constructor for deserialization.
             /// </summary>
-            internal FileState(SerializationInfo info, StreamingContext context)
+            internal FileState()
             {
-                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
-
-                lastModified = new DateTime(info.GetInt64("mod"), (DateTimeKind)info.GetInt32("modk"));
-                assemblyName = (AssemblyNameExtension)info.GetValue("an", typeof(AssemblyNameExtension));
-                dependencies = (AssemblyNameExtension[])info.GetValue("deps", typeof(AssemblyNameExtension[]));
-                scatterFiles = (string[])info.GetValue("sfiles", typeof(string[]));
-                runtimeVersion = (string)info.GetValue("rtver", typeof(string));
-                if (info.GetBoolean("fn"))
-                {
-                    var frameworkNameVersion = (Version) info.GetValue("fnVer", typeof(Version));
-                    var frameworkIdentifier = info.GetString("fnId");
-                    var frameworkProfile = info.GetString("fmProf");
-                    frameworkName = new FrameworkName(frameworkIdentifier, frameworkNameVersion, frameworkProfile);
-                }
-            }
-
-            /// <summary>
-            /// Serialize the contents of the class.
-            /// </summary>
-            [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
-            public void GetObjectData(SerializationInfo info, StreamingContext context)
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
-
-                info.AddValue("mod", lastModified.Ticks);
-                info.AddValue("modk", (int)lastModified.Kind);
-                info.AddValue("an", assemblyName);
-                info.AddValue("deps", dependencies);
-                info.AddValue("sfiles", scatterFiles);
-                info.AddValue("rtver", runtimeVersion);
-                info.AddValue("fn", frameworkName != null);
-                if (frameworkName != null)
-                {
-                    info.AddValue("fnVer", frameworkName.Version);
-                    info.AddValue("fnId", frameworkName.Identifier);
-                    info.AddValue("fmProf", frameworkName.Profile);
-                }
             }
 
             /// <summary>
             /// Gets the last modified date.
             /// </summary>
             /// <value></value>
-            internal DateTime LastModified
-            {
-                get { return lastModified; }
-            }
+            internal DateTime LastModified { get; set; }
 
             /// <summary>
             /// Get or set the assemblyName.
             /// </summary>
             /// <value></value>
-            internal AssemblyNameExtension Assembly
-            {
-                get { return assemblyName; }
-                set { assemblyName = value; }
-            }
+            internal AssemblyNameExtension Assembly { get; set; }
 
             /// <summary>
             /// Get or set the runtimeVersion
             /// </summary>
             /// <value></value>
-            internal string RuntimeVersion
-            {
-                get { return runtimeVersion; }
-                set { runtimeVersion = value; }
-            }
+            internal string RuntimeVersion { get; set; }
 
             /// <summary>
             /// Get or set the framework name the file was built against
@@ -232,22 +176,218 @@ internal FrameworkName FrameworkNameAttribute
             }
         }
 
-        /// <summary>
-        /// Construct.
-        /// </summary>
-        internal SystemState()
+        internal sealed class Converter : JsonConverter<SystemState>
         {
+            public override SystemState Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
+            {
+                SystemState systemState = new SystemState();
+                if (reader.TokenType != JsonTokenType.StartObject)
+                {
+                    throw new JsonException();
+                }
+                while (reader.Read())
+                {
+                    if (reader.TokenType == JsonTokenType.EndObject)
+                    {
+                        return systemState;
+                    }
+                    if (reader.TokenType != JsonTokenType.PropertyName)
+                    {
+                        throw new JsonException();
+                    }
+                    systemState.instanceLocalFileStateCache.Add(reader.GetString(), ParseFileState(ref reader));
+                }
+
+                throw new JsonException();
+            }
+
+            private FileState ParseFileState(ref Utf8JsonReader reader)
+            {
+                FileState state = new FileState();
+                reader.Read();
+                if (reader.TokenType != JsonTokenType.StartObject)
+                {
+                    throw new JsonException();
+                }
+                while (reader.Read())
+                {
+                    if (reader.TokenType == JsonTokenType.EndObject)
+                    {
+                        return state;
+                    }
+                    if (reader.TokenType != JsonTokenType.PropertyName)
+                    {
+                        throw new JsonException();
+                    }
+                    AssemblyNameExtension.Converter converter = new AssemblyNameExtension.Converter();
+                    string parameter = reader.GetString();
+                    reader.Read();
+                    if (reader.TokenType == JsonTokenType.Null)
+                    {
+                        continue;
+                    }
+                    switch (parameter)
+                    {
+                        case nameof(state.dependencies):
+                            state.dependencies = ParseArray<AssemblyNameExtension>(ref reader, converter);
+                            break;
+                        case nameof(state.scatterFiles):
+                            state.scatterFiles = ParseArray<string>(ref reader, s => s);
+                            break;
+                        case nameof(state.LastModified):
+                            state.LastModified = DateTime.Parse(reader.GetString());
+                            break;
+                        case nameof(state.Assembly):
+                            state.Assembly = converter.Read(ref reader, typeof(AssemblyNameExtension), new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping });
+                            break;
+                        case nameof(state.RuntimeVersion):
+                            state.RuntimeVersion = reader.GetString();
+                            break;
+                        case nameof(state.FrameworkNameAttribute):
+                            string version = string.Empty;
+                            string identifier = string.Empty;
+                            string profile = string.Empty;
+                            while (reader.Read())
+                            {
+                                if (reader.TokenType == JsonTokenType.EndObject)
+                                {
+                                    state.FrameworkNameAttribute = new FrameworkName(identifier, Version.Parse(version), profile);
+                                    break;
+                                }
+                                switch (reader.GetString())
+                                {
+                                    case "Version":
+                                        reader.Read();
+                                        version = reader.GetString();
+                                        break;
+                                    case "Identifier":
+                                        reader.Read();
+                                        identifier = reader.GetString();
+                                        break;
+                                    case "Profile":
+                                        reader.Read();
+                                        profile = reader.GetString();
+                                        break;
+                                }
+                            }
+                            break;
+                        default:
+                            throw new JsonException();
+                    }
+                }
+                throw new JsonException();
+            }
+
+            private T[] ParseArray<T>(ref Utf8JsonReader reader, JsonConverter<T> converter)
+            {
+                if (reader.TokenType != JsonTokenType.StartArray)
+                {
+                    return null;
+                }
+                List<T> list = new List<T>();
+                JsonSerializerOptions options = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
+                while (reader.Read())
+                {
+                    if (reader.TokenType == JsonTokenType.EndArray)
+                    {
+                        return list.ToArray();
+                    }
+                    else if (reader.TokenType == JsonTokenType.StartObject)
+                    {
+                        list.Add(converter.Read(ref reader, typeof(T), options));
+                    }
+                }
+                throw new JsonException();
+            }
+
+            public override void Write(Utf8JsonWriter writer, SystemState stateFile, JsonSerializerOptions options)
+            {
+                Dictionary<string, FileState> cache = stateFile.instanceLocalFileStateCache;
+                writer.WriteStartObject();
+                JsonSerializerOptions aneOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
+                AssemblyNameExtension.Converter converter = new AssemblyNameExtension.Converter();
+                foreach (string fileInfoKey in cache.Keys)
+                {
+                    writer.WritePropertyName(fileInfoKey);
+                    FileState fileInfo = (FileState)cache[fileInfoKey];
+                    writer.WriteStartObject();
+                    if (fileInfo.dependencies != null)
+                    {
+                        writer.WritePropertyName(nameof(fileInfo.dependencies));
+                        writer.WriteStartArray();
+                        for (int i = 0; i < fileInfo.dependencies.Length; i++)
+                        {
+                            if (i != 0)
+                            {
+                                writer.WriteStringValue(string.Empty);
+                            }
+                            converter.Write(writer, fileInfo.dependencies[i], aneOptions);
+                        }
+                        foreach (AssemblyNameExtension e in fileInfo.dependencies)
+                        {
+                            converter.Write(writer, e, aneOptions);
+                        }
+                        writer.WriteEndArray();
+                    }
+                    if (fileInfo.scatterFiles != null)
+                    {
+                        writer.WritePropertyName(nameof(fileInfo.scatterFiles));
+                        writer.WriteStartArray();
+                        foreach (string s in fileInfo.scatterFiles)
+                        {
+                            writer.WriteStringValue(s);
+                        }
+                        writer.WriteEndArray();
+                    }
+                    writer.WriteString(nameof(fileInfo.LastModified), fileInfo.LastModified.ToString());
+                    if (fileInfo.Assembly is null)
+                    {
+                        writer.WriteNull(nameof(fileInfo.Assembly));
+                    }
+                    else
+                    {
+                        writer.WritePropertyName(nameof(fileInfo.Assembly));
+                        converter.Write(writer, fileInfo.Assembly, aneOptions);
+                    }
+                    writer.WriteString(nameof(fileInfo.RuntimeVersion), fileInfo.RuntimeVersion);
+                    if (fileInfo.FrameworkNameAttribute != null)
+                    {
+                        writer.WritePropertyName(nameof(fileInfo.FrameworkNameAttribute));
+                        writer.WriteStartObject();
+                        writer.WriteString("Version", fileInfo.FrameworkNameAttribute.Version.ToString());
+                        writer.WriteString("Identifier", fileInfo.FrameworkNameAttribute.Identifier);
+                        writer.WriteString("Profile", fileInfo.FrameworkNameAttribute.Profile);
+                        writer.WriteEndObject();
+                    }
+                    writer.WriteEndObject();
+                }
+                writer.WriteEndObject();
+            }
+
+            private T[] ParseArray<T>(ref Utf8JsonReader reader, Func<string, T> converter)
+            {
+                if (reader.TokenType != JsonTokenType.StartArray)
+                {
+                    return null;
+                }
+                List<T> list = new List<T>();
+                while (reader.Read())
+                {
+                    if (reader.TokenType == JsonTokenType.EndArray)
+                    {
+                        return list.ToArray();
+                    }
+                    list.Add(converter(reader.GetString()));
+                }
+                throw new JsonException();
+            }
         }
 
         /// <summary>
-        /// Deserialize the contents of the class.
+        /// Construct.
         /// </summary>
-        internal SystemState(SerializationInfo info, StreamingContext context)
+        internal SystemState()
         {
-            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
-
-            instanceLocalFileStateCache = (Hashtable)info.GetValue("fileState", typeof(Hashtable));
-            isDirty = false;
         }
 
         /// <summary>
@@ -264,17 +404,6 @@ AssemblyTableInfo[] installedAssemblyTableInfos
             redistList = RedistList.GetRedistList(installedAssemblyTableInfos);
         }
 
-        /// <summary>
-        /// Serialize the contents of the class.
-        /// </summary>
-        [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
-        public void GetObjectData(SerializationInfo info, StreamingContext context)
-        {
-            ErrorUtilities.VerifyThrowArgumentNull(info, nameof(info));
-
-            info.AddValue("fileState", instanceLocalFileStateCache);
-        }
-
         /// <summary>
         /// Flag that indicates
         /// </summary>
@@ -282,6 +411,7 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)
         internal bool IsDirty
         {
             get { return isDirty; }
+            set { isDirty = value; }
         }
 
         /// <summary>
@@ -378,8 +508,7 @@ private FileState GetFileState(string path)
         private FileState ComputeFileStateFromCachesAndDisk(string path)
         {
             DateTime lastModified = GetAndCacheLastModified(path);
-            FileState cachedInstanceFileState = (FileState)instanceLocalFileStateCache[path];
-            bool isCachedInInstance = cachedInstanceFileState != null;
+            bool isCachedInInstance = instanceLocalFileStateCache.TryGetValue(path, out FileState cachedInstanceFileState);
             bool isCachedInProcess =
                 s_processWideFileStateCache.TryGetValue(path, out FileState cachedProcessFileState);
             
@@ -540,16 +669,84 @@ out fileState.frameworkName
 
             dependencies = fileState.dependencies;
             scatterFiles = fileState.scatterFiles;
-            frameworkName = fileState.frameworkName;
+            frameworkName = fileState.FrameworkNameAttribute;
+        }
+
+        /// <summary>
+        /// Reads in cached data from stateFiles to build an initial cache. Avoids logging warnings or errors.
+        /// </summary>
+        internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, Type requiredReturnType, GetLastWriteTime getLastWriteTime, AssemblyTableInfo[] installedAssemblyTableInfo, Func<string, bool> fileExists)
+        {
+            SystemState retVal = new SystemState();
+            retVal.SetGetLastWriteTime(getLastWriteTime);
+            retVal.SetInstalledAssemblyInformation(installedAssemblyTableInfo);
+            retVal.isDirty = stateFiles.Length > 0;
+            HashSet<string> assembliesFound = new HashSet<string>();
+            fileExists ??= FileSystems.Default.FileExists;
+
+            foreach (ITaskItem stateFile in stateFiles)
+            {
+                // Verify that it's a real stateFile; log message but do not error if not
+                var deserializeOptions = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
+                deserializeOptions.Converters.Add(new SystemState.Converter());
+                SystemState sysBase = JsonSerializer.Deserialize<SystemState>(File.ReadAllText(stateFile.ToString()), deserializeOptions);
+                if (sysBase == null)
+                {
+                    continue;
+                }
+
+                foreach (KeyValuePair<string, FileState> kvp in sysBase.instanceLocalFileStateCache)
+                {
+                    string relativePath = kvp.Key;
+                    if (!assembliesFound.Contains(relativePath))
+                    {
+                        FileState fileState = kvp.Value;
+                        string fullPath = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(stateFile.ToString()), relativePath));
+                        if (fileExists(fullPath))
+                        {
+                            // Correct file path and timestamp
+                            fileState.LastModified = retVal.getLastWriteTime(fullPath);
+                            retVal.instanceLocalFileStateCache[fullPath] = fileState;
+                            assembliesFound.Add(relativePath);
+                        }
+                    }
+                }
+            }
+
+            return retVal;
         }
 
         /// <summary>
-        /// Cached implementation of GetDirectories.
+        /// Modifies this object to be more portable across machines, then writes it to stateFile.
         /// </summary>
-        /// <param name="path"></param>
-        /// <param name="pattern"></param>
-        /// <returns></returns>
-        private string[] GetDirectories(string path, string pattern)
+        internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log)
+        {
+            Dictionary<string, FileState> oldInstanceLocalFileStateCache = instanceLocalFileStateCache;
+            Dictionary<string, FileState> newInstanceLocalFileStateCache = new Dictionary<string, FileState>(instanceLocalFileStateCache.Count);
+            foreach (KeyValuePair<string, FileState> kvp in instanceLocalFileStateCache)
+            {
+                string relativePath = FileUtilities.MakeRelative(Path.GetDirectoryName(stateFile), kvp.Key);
+                newInstanceLocalFileStateCache[relativePath] = kvp.Value;
+            }
+            instanceLocalFileStateCache = newInstanceLocalFileStateCache;
+
+            if (FileUtilities.FileExistsNoThrow(stateFile))
+            {
+                log.LogWarningWithCodeFromResources("General.StateFileAlreadyPresent", stateFile);
+            }
+            JsonSerializerOptions options = new JsonSerializerOptions() { Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
+            options.Converters.Add(new SystemState.Converter());
+            File.WriteAllText(stateFile, JsonSerializer.Serialize(this, options));
+            instanceLocalFileStateCache = oldInstanceLocalFileStateCache;
+        }
+
+            /// <summary>
+            /// Cached implementation of GetDirectories.
+            /// </summary>
+            /// <param name="path"></param>
+            /// <param name="pattern"></param>
+            /// <returns></returns>
+            private string[] GetDirectories(string path, string pattern)
         {
             // Only cache the *. pattern. This is by far the most common pattern
             // and generalized caching would require a call to Path.Combine which
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index cbcde5d8ef8..9160e78256b 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -49,7 +49,7 @@ public override bool Execute()
 
             if (AssemblyListFile != null)
             {
-                cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache));
+                cacheFile = StateFileBase.DeserializeCache<AssemblyRegistrationCache>(AssemblyListFile.ItemSpec, Log);
 
                 // no cache file, nothing to do. In case there was a problem reading the cache file, we can't do anything anyway.
                 if (cacheFile == null)
