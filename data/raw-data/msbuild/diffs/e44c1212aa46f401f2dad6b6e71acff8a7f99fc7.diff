diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 4f0e18bb982..95e7a646334 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -936,10 +936,7 @@ public void SolutionCanNotBeOpened()
                 }
                 finally
                 {
-                    if (security != null)
-                    {
-                        security.RemoveAccessRule(rule);
-                    }
+                    security?.RemoveAccessRule(rule);
 
                     File.Delete(solutionFile);
                     File.Delete(tempFileSentinel);
@@ -984,10 +981,7 @@ public void ProjectCanNotBeOpened()
                 }
                 finally
                 {
-                    if (security != null)
-                    {
-                        security.RemoveAccessRule(rule);
-                    }
+                    security?.RemoveAccessRule(rule);
 
                     File.Delete(projectFile);
                     Assert.False(File.Exists(projectFile));
diff --git a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
index ac5094dfb01..fd732589b22 100644
--- a/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/Scheduler_Tests.cs
@@ -69,10 +69,7 @@ public Scheduler_Tests()
             // Since we're creating our own BuildManager, we need to make sure that the default
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             _host = new MockHost();
             _scheduler = new Scheduler();
@@ -379,10 +376,7 @@ public void VerifyRequestOrderingDoesNotAffectNodeCreationCountWithInProcAndAnyR
             // Since we're creating our own BuildManager, we need to make sure that the default
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             _host = new MockHost();
             _host.BuildParameters.MaxNodeCount = 3;
@@ -543,10 +537,7 @@ public void VerifyNoOverCreationOfNodesWithBuildLoop()
             // Since we're creating our own BuildManager, we need to make sure that the default
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             _host = new MockHost();
             _host.BuildParameters.MaxNodeCount = 3;
diff --git a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
index 7eedce9361e..7dec7cd3423 100644
--- a/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetEntry_Tests.cs
@@ -836,10 +836,7 @@ public void AfterTargetsShouldReportFailedBuild()
             // Since we're creating our own BuildManager, we need to make sure that the default 
             // one has properly relinquished the inproc node
             NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-            if (nodeProviderInProc != null)
-            {
-                nodeProviderInProc.Dispose();
-            }
+            nodeProviderInProc?.Dispose();
 
             string content = @"
 <Project ToolsVersion='msbuilddefaulttoolsversion' DefaultTargets='Build' xmlns='http://schemas.microsoft.com/developer/msbuild/2003'>
@@ -897,10 +894,7 @@ public void AfterTargetsShouldReportFailedBuild()
                 {
                     NodeProviderInProc inProcNodeProvider = ((IBuildComponentHost)manager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
 
-                    if (inProcNodeProvider != null)
-                    {
-                        inProcNodeProvider.Dispose();
-                    }
+                    inProcNodeProvider?.Dispose();
                 }
             }
         }
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index c6f15a9b190..f1b374710bc 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -1958,10 +1958,7 @@ public void BadFrameworkMonkierExpectBuildToFail()
                 // Since we're creating our own BuildManager, we need to make sure that the default 
                 // one has properly relinquished the inproc node
                 NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-                if (nodeProviderInProc != null)
-                {
-                    nodeProviderInProc.Dispose();
-                }
+                nodeProviderInProc?.Dispose();
 
                 File.WriteAllText(projectFilePath, solutionFileContents.Replace('\'', '"'));
                 MockLogger logger = new MockLogger(output);
@@ -2050,10 +2047,7 @@ public void BadFrameworkMonkierExpectBuildToFail2()
                 // Since we're creating our own BuildManager, we need to make sure that the default 
                 // one has properly relinquished the inproc node
                 NodeProviderInProc nodeProviderInProc = ((IBuildComponentHost)BuildManager.DefaultBuildManager).GetComponent(BuildComponentType.InProcNodeProvider) as NodeProviderInProc;
-                if (nodeProviderInProc != null)
-                {
-                    nodeProviderInProc.Dispose();
-                }
+                nodeProviderInProc?.Dispose();
 
                 File.WriteAllText(projectFilePath, solutionFileContents.Replace('\'', '"'));
                 MockLogger logger = new MockLogger(output);
diff --git a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
index 2903374e8e0..2d6d78854e4 100644
--- a/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ExpressionShredder_Tests.cs
@@ -481,7 +481,7 @@ private static void VerifyAgainstCanonicalResults(string test, HashSet<string> a
             {
                 foreach (string result in actual)
                 {
-                    if (expected == null || !expected.Contains(result))
+                    if (expected?.Contains(result) != true)
                     {
                         messages.Add("Found <" + result + "> in <" + test + "> but it wasn't expected");
                     }
@@ -492,7 +492,7 @@ private static void VerifyAgainstCanonicalResults(string test, HashSet<string> a
             {
                 foreach (string expect in expected)
                 {
-                    if (actual == null || !actual.Contains(expect))
+                    if (actual?.Contains(expect) != true)
                     {
                         messages.Add("Did not find <" + expect + "> in <" + test + ">");
                     }
@@ -530,7 +530,7 @@ private static void VerifyAgainstCanonicalResults(string test, IDictionary actua
             {
                 foreach (DictionaryEntry result in actual)
                 {
-                    if (expected == null || !expected.Contains(result.Key))
+                    if (expected?.Contains(result.Key) != true)
                     {
                         messages.Add("Found <" + result.Key + "> in <" + test + "> but it wasn't expected");
                     }
@@ -541,7 +541,7 @@ private static void VerifyAgainstCanonicalResults(string test, IDictionary actua
             {
                 foreach (DictionaryEntry expect in expected)
                 {
-                    if (actual == null || !actual.Contains(expect.Key))
+                    if (actual?.Contains(expect.Key) != true)
                     {
                         messages.Add("Did not find <" + expect.Key + "> in <" + test + ">");
                     }
diff --git a/src/Build.UnitTests/SolutionFileBuilder.cs b/src/Build.UnitTests/SolutionFileBuilder.cs
index 3b87e2044a5..5e5103b9c1b 100644
--- a/src/Build.UnitTests/SolutionFileBuilder.cs
+++ b/src/Build.UnitTests/SolutionFileBuilder.cs
@@ -112,7 +112,7 @@ public string BuildSolution()
                     Guid.NewGuid()
                         .ToString("B")));
 
-            if (SolutionDependencies != null && SolutionDependencies.Length > 0)
+            if (SolutionDependencies?.Length > 0)
             {
                 foreach (var (parent, dependency) in SolutionDependencies)
                 {
@@ -123,7 +123,7 @@ public string BuildSolution()
                 }
             }
 
-            if (SolutionDependenciesProjectNameToGuids!= null && SolutionDependenciesProjectNameToGuids.Length > 0)
+            if (SolutionDependenciesProjectNameToGuids?.Length > 0)
             {
                 foreach (var (parent, dependencyGuids) in SolutionDependenciesProjectNameToGuids)
                 {
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 144ded7db93..10f220aaca2 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -816,10 +816,7 @@ public void EndBuild()
                     Reset();
                     _buildManagerState = BuildManagerState.Idle;
 
-                    if (_threadException != null)
-                    {
-                        _threadException.Throw();
-                    }
+                    _threadException?.Throw();
 
                     if (BuildParameters.DumpOpportunisticInternStats)
                     {
@@ -2367,7 +2364,7 @@ private static I ExpectPacketType<I>(INodePacket packet, NodePacketType expected
         /// </summary>
         private void SetOverallResultIfWarningsAsErrors(BuildResult result)
         {
-            if (result != null && result.OverallResult == BuildResultCode.Success)
+            if (result?.OverallResult == BuildResultCode.Success)
             {
                 ILoggingService loggingService = ((IBuildComponentHost)this).LoggingService;
 
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 8446b48cae0..48a3fcedb87 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -230,7 +230,7 @@ public bool ResolveConfigurationRequest(int unresolvedConfigId, int configId)
         {
             lock (GlobalLock)
             {
-                if (_unresolvedConfigurations == null || !_unresolvedConfigurations.ContainsKey(unresolvedConfigId))
+                if (_unresolvedConfigurations?.ContainsKey(unresolvedConfigId) != true)
                 {
                     return false;
                 }
diff --git a/src/Build/BackEnd/Components/Caching/ResultsCache.cs b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
index 64db389a8ed..52a8a24623c 100644
--- a/src/Build/BackEnd/Components/Caching/ResultsCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ResultsCache.cs
@@ -230,10 +230,7 @@ public void ClearResultsForConfiguration(int configurationId)
                 BuildResult removedResult;
                 _resultsByConfiguration.TryRemove(configurationId, out removedResult);
 
-                if (removedResult != null)
-                {
-                    removedResult.ClearCachedFiles();
-                }
+                removedResult?.ClearCachedFiles();
             }
         }
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeManager.cs b/src/Build/BackEnd/Components/Communications/NodeManager.cs
index e0c45681ff0..602a5d790ec 100644
--- a/src/Build/BackEnd/Components/Communications/NodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeManager.cs
@@ -157,15 +157,9 @@ public void ShutdownConnectedNodes(bool enableReuse)
 
             _nodesShutdown = true;
 
-            if (null != _inProcNodeProvider)
-            {
-                _inProcNodeProvider.ShutdownConnectedNodes(enableReuse);
-            }
+            _inProcNodeProvider?.ShutdownConnectedNodes(enableReuse);
 
-            if (null != _outOfProcNodeProvider)
-            {
-                _outOfProcNodeProvider.ShutdownConnectedNodes(enableReuse);
-            }
+            _outOfProcNodeProvider?.ShutdownConnectedNodes(enableReuse);
         }
 
         /// <summary>
@@ -174,10 +168,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
         public void ShutdownAllNodes()
         {
             // don't worry about inProc
-            if (null != _outOfProcNodeProvider)
-            {
-                _outOfProcNodeProvider.ShutdownAllNodes();
-            }
+            _outOfProcNodeProvider?.ShutdownAllNodes();
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 5c14d78a545..3c515131dab 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -92,10 +92,7 @@ protected void ShutdownConnectedNodes(List<NodeContext> contextsToShutDown, bool
 
             foreach (NodeContext nodeContext in contextsToShutDown)
             {
-                if (null != nodeContext)
-                {
-                    nodeContext.SendData(new NodeBuildComplete(enableReuse));
-                }
+                nodeContext?.SendData(new NodeBuildComplete(enableReuse));
             }
         }
 
@@ -382,10 +379,7 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, long hostHand
                 CommunicationsUtilities.Trace("Failed to connect to pipe {0}. {1}", pipeName, e.Message.TrimEnd());
 
                 // If we don't close any stream, we might hang up the child
-                if (nodeStream != null)
-                {
-                    nodeStream.Dispose();
-                }
+                nodeStream?.Dispose();
             }
 
             return null;
@@ -830,7 +824,7 @@ private bool ProcessHeaderBytesRead(int bytesRead)
                     try
                     {
                         Process childProcess = Process.GetProcessById(_processId);
-                        if (childProcess == null || childProcess.HasExited)
+                        if (childProcess?.HasExited != false)
                         {
                             CommunicationsUtilities.Trace(_nodeId, "   Child Process {0} has exited.", _processId);
                         }
diff --git a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
index 835e24a7c6a..5ec101d68a5 100644
--- a/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
+++ b/src/Build/BackEnd/Components/Communications/TaskHostNodeManager.cs
@@ -74,10 +74,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
         {
             ErrorUtilities.VerifyThrow(!_componentShutdown, "We should never be calling ShutdownNodes after ShutdownComponent has been called");
 
-            if (null != _outOfProcTaskHostNodeProvider)
-            {
-                _outOfProcTaskHostNodeProvider.ShutdownConnectedNodes(enableReuse);
-            }
+            _outOfProcTaskHostNodeProvider?.ShutdownConnectedNodes(enableReuse);
         }
 
         /// <summary>
@@ -85,10 +82,7 @@ public void ShutdownConnectedNodes(bool enableReuse)
         /// </summary>
         public void ShutdownAllNodes()
         {
-            if (null != _outOfProcTaskHostNodeProvider)
-            {
-                _outOfProcTaskHostNodeProvider.ShutdownAllNodes();
-            }
+            _outOfProcTaskHostNodeProvider?.ShutdownAllNodes();
         }
         #endregion
 
diff --git a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
index 835fd726971..759a59dd78d 100644
--- a/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
+++ b/src/Build/BackEnd/Components/Logging/CentralForwardingLogger.cs
@@ -114,10 +114,7 @@ private void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent
             // If no central logger was registered with the system
             // there will not be a build event redirector as there is 
             // nowhere to forward the events to.
-            if (BuildEventRedirector != null)
-            {
-                BuildEventRedirector.ForwardEvent(buildEvent);
-            }
+            BuildEventRedirector?.ForwardEvent(buildEvent);
         }
 
         #endregion
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 2c56e6ead22..0dd6b3865cb 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -519,7 +519,7 @@ public bool HasBuildSubmissionLoggedErrors(int submissionId)
             }
 
             // Determine if any of the event sinks have logged an error with this submission ID
-            return _buildSubmissionIdsThatHaveLoggedErrors != null && _buildSubmissionIdsThatHaveLoggedErrors.Contains(submissionId);
+            return _buildSubmissionIdsThatHaveLoggedErrors?.Contains(submissionId) == true;
         }
 
         public void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet<string> codes)
@@ -723,10 +723,7 @@ public void ShutdownComponent()
                     }
 
                     // 3. Null out sinks and the filter event source so that no more events can get to the central loggers
-                    if (_filterEventSource != null)
-                    {
-                        _filterEventSource.ShutDown();
-                    }
+                    _filterEventSource?.ShutDown();
 
                     foreach (IBuildEventSink sink in _eventSinkDictionary.Values)
                     {
@@ -1109,7 +1106,7 @@ internal void WaitForThreadToProcessEvents()
         /// </summary>
         internal void InjectNonSerializedData(LogMessagePacket loggingPacket)
         {
-            if (loggingPacket != null && loggingPacket.NodeBuildEvent != null && _componentHost != null)
+            if (loggingPacket?.NodeBuildEvent != null && _componentHost != null)
             {
                 var projectStartedEventArgs = loggingPacket.NodeBuildEvent.Value.Value as ProjectStartedEventArgs;
                 if (projectStartedEventArgs != null && _configCache.Value != null)
@@ -1196,10 +1193,7 @@ private void ShutdownLogger(ILogger logger)
         {
             try
             {
-                if (logger != null)
-                {
-                    logger.Shutdown();
-                }
+                logger?.Shutdown();
             }
             catch (LoggerException)
             {
@@ -1563,7 +1557,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
         {
             // This only applies if the user specified /nowarn at the command-line or added the warning code through the object model
             //
-            if (WarningsAsMessages != null && WarningsAsMessages.Contains(warningEvent.Code))
+            if (WarningsAsMessages?.Contains(warningEvent.Code) == true)
             {
                 return true;
             }
@@ -1574,7 +1568,7 @@ private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent)
             {
                 if (_warningsAsMessagesByProject.TryGetValue(GetWarningsAsErrorOrMessageKey(warningEvent), out ISet<string> codesByProject))
                 {
-                    return codesByProject != null && codesByProject.Contains(warningEvent.Code);
+                    return codesByProject?.Contains(warningEvent.Code) == true;
                 }
             }
 
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index d1bf9031adb..ef60a082609 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -447,7 +447,7 @@ public void LogBuildStarted()
 
                 IDictionary<string, string> environmentProperties = null;
 
-                if (_componentHost != null && _componentHost.BuildParameters != null)
+                if (_componentHost?.BuildParameters != null)
                 {
                     environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
                 }
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index 883059b0406..ee3e3794976 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -101,7 +101,7 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
                 items = new ProjectItemInstanceEnumeratorProxy(projectItemsEnumerator);
             }
 
-            if (projectProperties != null && propertiesToSerialize != null && propertiesToSerialize.Length > 0 && !LoggingService.SerializeAllProperties)
+            if (projectProperties != null && propertiesToSerialize?.Length > 0 && !LoggingService.SerializeAllProperties)
             {
                 PropertyDictionary<ProjectPropertyInstance> projectPropertiesToSerialize = new PropertyDictionary<ProjectPropertyInstance>();
                 foreach (string propertyToGet in propertiesToSerialize)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
index eac4bf5351c..02d22f3a0cd 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/BatchingEngine.cs
@@ -127,7 +127,7 @@ ElementLocation elementLocation
             Dictionary<string, MetadataReference> consumedMetadataReferences = pair.Metadata;
 
             List<ItemBucket> buckets = null;
-            if (consumedMetadataReferences != null && consumedMetadataReferences.Count > 0)
+            if (consumedMetadataReferences?.Count > 0)
             {
                 // Add any item types that we were explicitly told to assume.
                 if (implicitBatchableItemType != null)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index f528cadbfaf..d87997b4a68 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -215,7 +215,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                 LoggingContext.BuildEventContext,
                 FileSystems.Default);
 
-            if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd != null && itemsToAdd.Count > 0)
+            if (LogTaskInputs && !LoggingContext.LoggingService.OnlyLogCriticalEvents && itemsToAdd?.Count > 0)
             {
                 var itemGroupText = ItemGroupLoggingHelper.GetParameterText(
                     ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index d9639592e03..2e0e396a553 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -236,7 +236,7 @@ public async Task<bool> ExecuteInternal()
             }
 
             // We have been asked to unescape all escaped characters before processing
-            if (TargetAndPropertyListSeparators != null && TargetAndPropertyListSeparators.Length > 0)
+            if (TargetAndPropertyListSeparators?.Length > 0)
             {
                 ExpandAllTargetsAndProperties();
             }
@@ -484,7 +484,7 @@ bool runEachTargetSeparately
             // of the RunEachTargetSeparately parameter, we each just call the engine to run all 
             // the targets together, or we call the engine separately for each target.
             var targetLists = new List<string[]>();
-            if ((runEachTargetSeparately) && (targets != null) && (targets.Length > 0))
+            if ((runEachTargetSeparately) && (targets?.Length > 0))
             {
                 // Separate target invocations for each individual target.
                 foreach (string targetName in targets)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
index da88294d849..1e941967529 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/Lookup.cs
@@ -930,7 +930,7 @@ private void MergeModificationsIntoModificationTable(Dictionary<ProjectItemInsta
         /// </summary>
         private void MustNotBeInTable(ItemDictionary<ProjectItemInstance> table, ProjectItemInstance item)
         {
-            if (table != null && table.ItemTypes.Contains(item.ItemType))
+            if (table?.ItemTypes.Contains(item.ItemType) == true)
             {
                 ICollection<ProjectItemInstance> tableOfItemsOfSameType = table[item.ItemType];
                 if (tableOfItemsOfSameType != null)
@@ -945,7 +945,7 @@ private void MustNotBeInTable(ItemDictionary<ProjectItemInstance> table, Project
         /// </summary>
         private void MustNotBeInTable(ItemTypeToItemsMetadataUpdateDictionary table, ProjectItemInstance item)
         {
-            if (table != null && table.ContainsKey(item.ItemType))
+            if (table?.ContainsKey(item.ItemType) == true)
             {
                 ItemsMetadataUpdateDictionary tableOfItemsOfSameType = table[item.ItemType];
                 if (tableOfItemsOfSameType != null)
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index c34edb8c8e7..50ab2f1fb1a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -170,7 +170,7 @@ internal bool HasActiveBuildRequest
             {
                 VerifyIsNotZombie();
 
-                return (_requestTask != null && !_requestTask.IsCompleted) || (_componentHost.LegacyThreadingData.MainThreadSubmissionId != -1);
+                return (_requestTask?.IsCompleted == false) || (_componentHost.LegacyThreadingData.MainThreadSubmissionId != -1);
             }
         }
 
@@ -582,7 +582,7 @@ private void StartBuilderThread()
                         // to null between the null check and asking the LegacyThreadingData for the Task.
                         IBuildComponentHost componentHostSnapshot = _componentHost;
 
-                        if (componentHostSnapshot != null && componentHostSnapshot.LegacyThreadingData != null)
+                        if (componentHostSnapshot?.LegacyThreadingData != null)
                         {
                             return componentHostSnapshot.LegacyThreadingData.GetLegacyThreadInactiveTask(_requestEntry.Request.SubmissionId);
                         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index a8a180adb6e..1b868063b93 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -432,7 +432,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                 string projectFullPath = requestEntry.RequestConfiguration.ProjectFullPath;
 
                 string parentTargetName = null;
-                if (ParentEntry != null && ParentEntry.Target != null)
+                if (ParentEntry?.Target != null)
                 {
                     parentTargetName = ParentEntry.Target.Name;
                 }
@@ -531,7 +531,7 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                                 entryForInference = null;
                                 entryForExecution.LeaveScope();
                                 entryForExecution = null;
-                                targetSuccess = (bucketResult != null) && (bucketResult.ResultCode == WorkUnitResultCode.Success);
+                                targetSuccess = (bucketResult?.ResultCode == WorkUnitResultCode.Success);
                                 break;
 
                             case DependencyAnalysisResult.SkipNoInputs:
@@ -547,15 +547,9 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                         // the log is confusing.
                         targetLoggingContext.LogInvalidProjectFileError(e);
 
-                        if (null != entryForInference)
-                        {
-                            entryForInference.LeaveScope();
-                        }
+                        entryForInference?.LeaveScope();
 
-                        if (null != entryForExecution)
-                        {
-                            entryForExecution.LeaveScope();
-                        }
+                        entryForExecution?.LeaveScope();
 
                         aggregateResult = aggregateResult.AggregateResult(new WorkUnitResult(WorkUnitResultCode.Failed, WorkUnitActionCode.Stop, null));
                     }
@@ -653,11 +647,11 @@ internal async Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry re
                 }
                 finally
                 {
-                    if (targetLoggingContext != null)
-                    {
+                       
+                    
                         // log the last target finished since we now have the target outputs. 
-                        targetLoggingContext.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems != null && targetOutputItems.Count > 0 ? targetOutputItems : null);
-                    }
+                        targetLoggingContext?.LogTargetBatchFinished(projectFullPath, targetSuccess, targetOutputItems?.Count > 0 ? targetOutputItems : null);
+                    
                 }
 
                 _targetResult = new TargetResult(targetOutputItems.ToArray(), aggregateResult);
@@ -917,7 +911,7 @@ private List<string> GetBatchableParametersForTarget()
                 batchableTargetParameters.Add(_target.Outputs);
             }
 
-            if (_target.Returns != null && _target.Returns.Length > 0)
+            if (_target.Returns?.Length > 0)
             {
                 batchableTargetParameters.Add(_target.Returns);
             }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
index c141a8cf4a4..df96a54a999 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetUpToDateChecker.cs
@@ -235,7 +235,7 @@ out ItemDictionary<ProjectItemInstance> upToDateTargetInputs
                 // 1) they do not reference any item vector
                 // 2) they reference item vectors that are not referenced by any input item
                 if ((discreteItemsInTargetOutputs.Count > 0) ||
-                    ((itemVectorsReferencedOnlyInTargetOutputs != null) && (itemVectorsReferencedOnlyInTargetOutputs.Count > 0)))
+                    ((itemVectorsReferencedOnlyInTargetOutputs?.Count > 0)))
                 {
                     result = PerformDependencyAnalysisIfDiscreteOutputs(
                                 itemVectorsInTargetInputs, itemVectorTransformsInTargetInputs, discreteItemsInTargetInputs,
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 23a6fc8d5aa..48388e626c6 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -205,10 +205,7 @@ public void ShutdownComponent()
                 _componentHost = null;
 
                 IDisposable disposable = _taskExecutionHost as IDisposable;
-                if (disposable != null)
-                {
-                    disposable.Dispose();
-                }
+                disposable?.Dispose();
 
                 _taskExecutionHost = null;
             }
@@ -342,10 +339,7 @@ private async Task<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lo
                 _taskExecutionHost.CleanupForTask();
 
 #if FEATURE_APPDOMAIN
-                if (taskHost != null)
-                {
-                    taskHost.MarkAsInactive();
-                }
+                taskHost?.MarkAsInactive();
 #endif
 
                 // Now all task batches are done, apply all item adds to the outer 
@@ -597,10 +591,7 @@ private WorkUnitResult ExecuteTaskInSTAThread(ItemBucket bucket, TaskLoggingCont
                 taskRunnerFinished = null;
             }
 
-            if (exceptionFromExecution != null)
-            {
-                exceptionFromExecution.Throw();
-            }
+            exceptionFromExecution?.Throw();
 
             return taskResult;
         }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 81e53c7ba6b..c1399132c85 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -811,10 +811,7 @@ internal void MarkAsInactive()
                 {
                     ILease lease = (ILease)RemotingServices.GetLifetimeService(this);
 
-                    if (lease != null)
-                    {
-                        lease.Unregister(_sponsor);
-                    }
+                    lease?.Unregister(_sponsor);
 
                     _sponsor.Close();
                     _sponsor = null;
@@ -934,10 +931,7 @@ private async Task<BuildEngineResult> BuildProjectFilesInParallelAsync(string[]
                     // Now walk through the results, and report that subset which was asked for.
                     for (int i = 0; i < results.Length; i++)
                     {
-                        if (targetOutputsPerProject != null)
-                        {
-                            targetOutputsPerProject.Add(new Dictionary<string, ITaskItem[]>(StringComparer.OrdinalIgnoreCase));
-                        }
+                        targetOutputsPerProject?.Add(new Dictionary<string, ITaskItem[]>(StringComparer.OrdinalIgnoreCase));
 
                         foreach (KeyValuePair<string, TargetResult> resultEntry in results[i].ResultsByTarget)
                         {
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index d34a2df0426..4a02fe60a6d 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -1659,10 +1659,7 @@ private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest,
                         BuildRequest requestToAdd = requestsToAdd.Pop();
                         SchedulableRequest blockingRequest = _schedulingData.CreateRequest(requestToAdd, parentRequest);
 
-                        if (parentRequest != null)
-                        {
-                            parentRequest.BlockByRequest(blockingRequest, blocker.TargetsInProgress);
-                        }
+                        parentRequest?.BlockByRequest(blockingRequest, blocker.TargetsInProgress);
                     }
                 }
             }
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 2afdf5f88a6..1738a0518e8 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -729,7 +729,7 @@ private void HandleNodeConfiguration(NodeConfiguration configuration)
             try
             {
                 // If there are no node loggers to initialize dont do anything
-                if (configuration.LoggerDescriptions != null && configuration.LoggerDescriptions.Length > 0)
+                if (configuration.LoggerDescriptions?.Length > 0)
                 {
                     _loggingService.InitializeNodeLoggers(configuration.LoggerDescriptions, sink, configuration.NodeId);
                 }
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 301a9246a07..d9879b580da 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -276,7 +276,7 @@ internal BuildRequestConfiguration()
         /// <summary>
         /// Flag indicating whether or not the configuration has been loaded before.
         /// </summary>
-        public bool IsLoaded => _project != null && _project.IsLoaded;
+        public bool IsLoaded => _project?.IsLoaded == true;
 
         /// <summary>
         /// Flag indicating if the configuration is cached or not.
diff --git a/src/Build/Collections/PropertyDictionary.cs b/src/Build/Collections/PropertyDictionary.cs
index 86aa1e507d1..757a5a8e3bf 100644
--- a/src/Build/Collections/PropertyDictionary.cs
+++ b/src/Build/Collections/PropertyDictionary.cs
@@ -284,7 +284,7 @@ public bool Equals(PropertyDictionary<T> other)
                 foreach (T leftProp in this)
                 {
                     T rightProp = other[leftProp.Key];
-                    if (rightProp == null || !rightProp.Equals(leftProp))
+                    if (rightProp?.Equals(leftProp) != true)
                     {
                         return false;
                     }
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 2c74f13933f..8c91b70d256 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -491,8 +491,7 @@ internal void AddToXml(ProjectElement child)
                     {
                         //  Try to match the surrounding formatting by checking the whitespace that precedes the node we inserted
                         //  after, and inserting the same whitespace between the previous node and the one we added
-                        if (referenceSibling.XmlElement.PreviousSibling != null &&
-                            referenceSibling.XmlElement.PreviousSibling.NodeType == XmlNodeType.Whitespace)
+                        if (referenceSibling.XmlElement.PreviousSibling?.NodeType == XmlNodeType.Whitespace)
                         {
                             var newWhitespaceNode = XmlDocument.CreateWhitespace(referenceSibling.XmlElement.PreviousSibling.Value);
                             XmlElement.InsertAfter(newWhitespaceNode, referenceSibling.XmlElement);
@@ -508,8 +507,7 @@ internal void AddToXml(ProjectElement child)
                     {
                         //  Try to match the surrounding formatting by checking the whitespace that precedes where we inserted
                         //  the new node, and inserting the same whitespace between the node we added and the one after it.
-                        if (child.XmlElement.PreviousSibling != null &&
-                            child.XmlElement.PreviousSibling.NodeType == XmlNodeType.Whitespace)
+                        if (child.XmlElement.PreviousSibling?.NodeType == XmlNodeType.Whitespace)
                         {
                             var newWhitespaceNode = XmlDocument.CreateWhitespace(child.XmlElement.PreviousSibling.Value);
                             XmlElement.InsertBefore(newWhitespaceNode, referenceSibling.XmlElement);
@@ -579,7 +577,7 @@ internal void RemoveFromXml(ProjectElement child)
                 {
                     //  If we are trying to preserve formatting of the file, then also remove any whitespace
                     //  that came before the node we removed.
-                    if (previousSibling != null && previousSibling.NodeType == XmlNodeType.Whitespace)
+                    if (previousSibling?.NodeType == XmlNodeType.Whitespace)
                     {
                         XmlElement.RemoveChild(previousSibling);
                     }
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 287b965ab35..1e11b7a324c 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -1005,7 +1005,7 @@ public ProjectItemElement AddItem(string itemType, string include, IEnumerable<K
                     itemGroupToAddTo = itemGroup;
                 }
 
-                if (itemGroupToAddTo != null && itemGroupToAddTo.Count > 0)
+                if (itemGroupToAddTo?.Count > 0)
                 {
                     break;
                 }
diff --git a/src/Build/Construction/Solution/ProjectInSolution.cs b/src/Build/Construction/Solution/ProjectInSolution.cs
index 2c6235654ee..a9b1c636710 100644
--- a/src/Build/Construction/Solution/ProjectInSolution.cs
+++ b/src/Build/Construction/Solution/ProjectInSolution.cs
@@ -282,7 +282,7 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
                     }
                 }
 
-                if (mainProjectElement != null && mainProjectElement.LocalName == "Project")
+                if (mainProjectElement?.LocalName == "Project")
                 {
                     // MSBuild supports project files with an empty (supported in Visual Studio 2017) or the default MSBuild
                     // namespace.
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 5d3e7d5f5f8..833fc0e1066 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -232,7 +232,7 @@ internal string FullPath
 
         internal bool ProjectShouldBuild(string projectFile)
         {
-            return _solutionFilter == null || _solutionFilter.Contains(projectFile);
+            return _solutionFilter?.Contains(projectFile) != false;
         }
 
         /// <summary>
@@ -757,7 +757,7 @@ private void ParseProject(string firstLine)
                     // We have a ProjectDependencies section.  Each subsequent line should identify
                     // a dependency.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         // This should be a dependency.  The GUID identifying the parent project should
                         // be both the property name and the property value.
@@ -777,7 +777,7 @@ private void ParseProject(string firstLine)
                     // projects, and contains properties that we'll need in order to call the 
                     // AspNetCompiler task.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         Match match = s_crackPropertyLine.Value.Match(line);
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 02bba78e5d9..e0f6b154ee3 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2859,12 +2859,11 @@ public override ProjectProperty SetProperty(string name, string unevaluatedValue
 
                 ProjectProperty property = _data.Properties[name];
 
-                ErrorUtilities.VerifyThrowInvalidOperation(property == null || !property.IsReservedProperty, "OM_ReservedName", name);
-                ErrorUtilities.VerifyThrowInvalidOperation(property == null || !property.IsGlobalProperty, "OM_GlobalProperty", name);
+                ErrorUtilities.VerifyThrowInvalidOperation(property?.IsReservedProperty != true, "OM_ReservedName", name);
+                ErrorUtilities.VerifyThrowInvalidOperation(property?.IsGlobalProperty != true, "OM_GlobalProperty", name);
 
                 // If there's an existing regular property, we can reuse it, unless it's not attached to its XML any more
-                if (property != null &&
-                    !property.IsEnvironmentProperty &&
+                if (property?.IsEnvironmentProperty == false &&
                     property.Xml.Parent?.Parent != null &&
                     ReferenceEquals(property.Xml.ContainingProject, Xml))
                 {
@@ -3364,7 +3363,7 @@ public bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItemXm
                     return false;
                 }
 
-                if ((metadata != null && metadata.Any()) || candidateExistingItemXml.Count > 0)
+                if ((metadata?.Any() == true) || candidateExistingItemXml.Count > 0)
                 {
                     // Don't try to make sure the metadata are the same.
                     return false;
@@ -3749,7 +3748,7 @@ private ProjectElement GetAnySuitableExistingItemXml(string itemType, string une
                     return null;
                 }
 
-                if (metadata != null && metadata.Any())
+                if (metadata?.Any() == true)
                 {
                     // Don't bother trying to match up metadata
                     return null;
diff --git a/src/Build/Definition/ProjectItem.cs b/src/Build/Definition/ProjectItem.cs
index 4fd40b3fe7f..36ab13bf25d 100644
--- a/src/Build/Definition/ProjectItem.cs
+++ b/src/Build/Definition/ProjectItem.cs
@@ -441,7 +441,7 @@ public bool HasMetadata(string name)
                 return Link.HasMetadata(name);
             }
 
-            if (_directMetadata != null && _directMetadata.Contains(name))
+            if (_directMetadata?.Contains(name) == true)
             {
                 return true;
             }
@@ -573,7 +573,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
             XmlUtilities.VerifyThrowArgumentValidElementName(name);
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name), "ItemSpecModifierCannotBeCustomMetadata", name);
             ErrorUtilities.VerifyThrowInvalidOperation(!XMakeElements.ReservedItemNames.Contains(name), "CannotModifyReservedItemMetadata", name);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
             if (!propagateMetadataToSiblingItems)
             {
@@ -582,7 +582,7 @@ private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValu
 
             ProjectMetadata metadatum;
 
-            if (_directMetadata != null && _directMetadata.Contains(name))
+            if (_directMetadata?.Contains(name) == true)
             {
                 metadatum = _directMetadata[name];
                 metadatum.UnevaluatedValue = unevaluatedValue;
@@ -631,7 +631,7 @@ public bool RemoveMetadata(string name)
             ErrorUtilities.VerifyThrowArgumentLength(name, "name");
             ErrorUtilities.VerifyThrowArgument(!FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name), "ItemSpecModifierCannotBeCustomMetadata", name);
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
             ProjectMetadata metadatum = (_directMetadata == null) ? null : _directMetadata[name];
 
@@ -681,7 +681,7 @@ public void Rename(string name)
             }
 
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
             if (String.Equals(UnevaluatedInclude, name, StringComparison.Ordinal))
             {
@@ -777,7 +777,7 @@ internal void ChangeItemType(string newItemType)
         {
             ErrorUtilities.VerifyThrowArgumentLength(newItemType, "ItemType");
             Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+            ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
             if (String.Equals(ItemType, newItemType, StringComparison.Ordinal))
             {
diff --git a/src/Build/Definition/ProjectMetadata.cs b/src/Build/Definition/ProjectMetadata.cs
index 2408a1e6c18..44439b6cfa4 100644
--- a/src/Build/Definition/ProjectMetadata.cs
+++ b/src/Build/Definition/ProjectMetadata.cs
@@ -132,7 +132,7 @@ public string UnevaluatedValue
             {
                 ErrorUtilities.VerifyThrowArgumentNull(value, "value");
                 Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-                ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null && _xml.Parent.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+                ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
                 if (String.Equals(_xml.Value, value, StringComparison.Ordinal))
                 {
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 5cb358fae95..597c9ba1c48 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -291,7 +291,7 @@ internal void UpdateEvaluatedValue(string evaluatedValueEscaped)
         private static bool ProjectHasMatchingGlobalProperty(Project project, string propertyName)
         {
             ProjectProperty property = project.GetProperty(propertyName);
-            if (property != null && property.IsGlobalProperty && !project.GlobalPropertiesToTreatAsLocal.Contains(propertyName))
+            if (property?.IsGlobalProperty == true && !project.GlobalPropertiesToTreatAsLocal.Contains(propertyName))
             {
                 return true;
             }
@@ -362,7 +362,7 @@ public override string UnevaluatedValue
                 set
                 {
                     Project.VerifyThrowInvalidOperationNotImported(_xml.ContainingProject);
-                    ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent != null && _xml.Parent.Parent != null, "OM_ObjectIsNoLongerActive");
+                    ErrorUtilities.VerifyThrowInvalidOperation(_xml.Parent?.Parent != null, "OM_ObjectIsNoLongerActive");
 
                     _xml.Value = value;
 
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 6f98ee8108f..f8eb8933415 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -82,7 +82,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> ToolsVersions
                             toolset.ElementInformation.LineNumber,
                             0);
 
-                        if (toolset.toolsVersion != null && toolset.toolsVersion.Length == 0)
+                        if (toolset.toolsVersion?.Length == 0)
                         {
                             InvalidToolsetDefinitionException.Throw(
                                 "InvalidToolsetValueInConfigFileValue",
@@ -159,7 +159,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
             {
                 ElementLocation location = ElementLocation.Create(propertyElement.ElementInformation.Source, propertyElement.ElementInformation.LineNumber, 0);
 
-                if (propertyElement.Name != null && propertyElement.Name.Length == 0)
+                if (propertyElement.Name?.Length == 0)
                 {
                     InvalidToolsetDefinitionException.Throw("InvalidToolsetValueInConfigFileValue", location.LocationString);
                 }
diff --git a/src/Build/Definition/ToolsetRegistryReader.cs b/src/Build/Definition/ToolsetRegistryReader.cs
index d1437e00e62..ef54e940924 100644
--- a/src/Build/Definition/ToolsetRegistryReader.cs
+++ b/src/Build/Definition/ToolsetRegistryReader.cs
@@ -196,10 +196,7 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetPropertyDefinitions
             }
             finally
             {
-                if (toolsVersionWrapper != null)
-                {
-                    toolsVersionWrapper.Dispose();
-                }
+                toolsVersionWrapper?.Dispose();
             }
         }
 
@@ -227,10 +224,7 @@ protected override IEnumerable<string> GetSubToolsetVersions(string toolsVersion
             }
             finally
             {
-                if (toolsVersionWrapper != null)
-                {
-                    toolsVersionWrapper.Dispose();
-                }
+                toolsVersionWrapper?.Dispose();
             }
         }
 
@@ -275,15 +269,9 @@ protected override IEnumerable<ToolsetPropertyDefinition> GetSubToolsetPropertyD
             }
             finally
             {
-                if (toolsVersionWrapper != null)
-                {
-                    toolsVersionWrapper.Dispose();
-                }
+                toolsVersionWrapper?.Dispose();
 
-                if (subToolsetWrapper != null)
-                {
-                    subToolsetWrapper.Dispose();
-                }
+                subToolsetWrapper?.Dispose();
             }
         }
 
@@ -305,7 +293,7 @@ private static ToolsetPropertyDefinition CreatePropertyFromRegistry(RegistryKeyW
         {
             string propertyValue = null;
 
-            if (propertyName != null && propertyName.Length == 0)
+            if (propertyName?.Length == 0)
             {
                 InvalidToolsetDefinitionException.Throw("PropertyNameInRegistryHasZeroLength", toolsetWrapper.Name);
             }
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index ca0a8f26a77..58ff9b221a7 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -91,10 +91,10 @@ bool initializationException
          )
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message != null) && (message.Length > 0), "Need error message.");
+            ErrorUtilities.VerifyThrow((message?.Length > 0), "Need error message.");
             ErrorUtilities.VerifyThrow(innerException != null || initializationException == true, "Need the logger exception.");
-            ErrorUtilities.VerifyThrow((errorCode != null) && (errorCode.Length > 0), "Must specify the error message code.");
-            ErrorUtilities.VerifyThrow((helpKeyword != null) && (helpKeyword.Length > 0), "Must specify the help keyword for the IDE.");
+            ErrorUtilities.VerifyThrow((errorCode?.Length > 0), "Must specify the error message code.");
+            ErrorUtilities.VerifyThrow((helpKeyword?.Length > 0), "Must specify the help keyword for the IDE.");
 
             this.e = e;
             this.errorCode = errorCode;
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index 045fa92f794..918e188ff85 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -80,15 +80,9 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// </summary>
         internal override void ResetState()
         {
-            if (LeftChild != null)
-            {
-                LeftChild.ResetState();
-            }
+            LeftChild?.ResetState();
 
-            if (RightChild != null)
-            {
-                RightChild.ResetState();
-            }
+            RightChild?.ResetState();
         }
 
         /// <summary>
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 442822690b5..57e434ccdbf 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -134,7 +134,7 @@ internal bool Advance()
             if (_errorState)
                 return false;
 
-            if (_lookahead != null && _lookahead.IsToken(Token.TokenType.EndOfInput))
+            if (_lookahead?.IsToken(Token.TokenType.EndOfInput) == true)
                 return true;
 
             SkipWhiteSpace();
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index b38d2ee912d..6292ff37349 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1841,8 +1841,8 @@ private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(
                     }
                 }
 
-                if ((sdkResult.PropertiesToAdd != null && sdkResult.PropertiesToAdd.Any()) ||
-                    (sdkResult.ItemsToAdd != null && sdkResult.ItemsToAdd.Any()))
+                if ((sdkResult.PropertiesToAdd?.Any() == true) ||
+                    (sdkResult.ItemsToAdd?.Any() == true))
                 {
                     //  Inserting at the beginning will mean that the properties or items from the SdkResult will be evaluated before
                     //  any projects from paths returned by the SDK Resolver.
@@ -1907,7 +1907,7 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
                 ProjectRootElement project = ProjectRootElement.Create();
                 project.FullPath = projectPath;
 
-                if (sdkResult.PropertiesToAdd != null && sdkResult.PropertiesToAdd.Any())
+                if (sdkResult.PropertiesToAdd?.Any() == true)
                 {
                     var propertyGroup = project.AddPropertyGroup();
                     foreach (var propertyNameAndValue in sdkResult.PropertiesToAdd)
@@ -1916,7 +1916,7 @@ ProjectRootElement InnerCreate(string _, ProjectRootElementCacheBase __)
                     }
                 }
 
-                if (sdkResult.ItemsToAdd != null && sdkResult.ItemsToAdd.Any())
+                if (sdkResult.ItemsToAdd?.Any() == true)
                 {
                     var itemGroup = project.AddItemGroup();
                     foreach (var item in sdkResult.ItemsToAdd)
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index d06978d9b77..43f73fda702 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -746,7 +746,7 @@ internal static string ExpandMetadataLeaveEscaped(string expression, IMetadataTa
                         // The most common case is where the transform is the whole expression
                         // Also if there were no valid item vector expressions found, then go ahead and do the replacement on
                         // the whole expression (which is what Orcas did).
-                        if (itemVectorExpressions != null && itemVectorExpressions.Count == 1 && itemVectorExpressions[0].Value == expression && itemVectorExpressions[0].Separator == null)
+                        if (itemVectorExpressions?.Count == 1 && itemVectorExpressions[0].Value == expression && itemVectorExpressions[0].Separator == null)
                         {
                             return expression;
                         }
@@ -1844,8 +1844,7 @@ out List<Pair<string, S>> itemsFromCapture
                 if (itemsOfType.Count == 0)
                 {
                     // .. but only if there isn't a function "Count()", since that will want to return something (zero) for an empty list
-                    if (expressionCapture.Captures == null ||
-                        !expressionCapture.Captures.Any(capture => string.Equals(capture.FunctionName, "Count", StringComparison.OrdinalIgnoreCase)))
+                    if (expressionCapture.Captures?.Any(capture => string.Equals(capture.FunctionName, "Count", StringComparison.OrdinalIgnoreCase)) != true)
                     {
                         itemsFromCapture = new List<Pair<string, S>>();
                         return false;
@@ -2253,7 +2252,7 @@ internal static IEnumerable<Pair<string, S>> Exists(Expander<P, I> expander, IEl
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Combine(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     string relativePath = arguments[0];
 
@@ -2421,7 +2420,7 @@ internal static IEnumerable<Pair<string, S>> DirectoryName(Expander<P, I> expand
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> Metadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     string metadataName = arguments[0];
 
@@ -2529,7 +2528,7 @@ internal static IEnumerable<Pair<string, S>> Reverse(Expander<P, I> expander, IE
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     foreach (Pair<string, S> item in itemsOfType)
                     {
@@ -2552,7 +2551,7 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
                         // the caller to possibly do correlation.
 
                         // We pass in the existing item so we can copy over its metadata
-                        if (include != null && include.Length > 0)
+                        if (include?.Length > 0)
                         {
                             yield return new Pair<string, S>(include, item.Value);
                         }
@@ -2628,7 +2627,7 @@ internal static IEnumerable<Pair<string, S>> ClearMetadata(Expander<P, I> expand
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 1, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     string metadataName = arguments[0];
 
@@ -2651,7 +2650,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
 
                         // GetMetadataValueEscaped returns empty string for missing metadata,
                         // but IItem specifies it should return null
-                        if (metadataValue != null && metadataValue.Length > 0)
+                        if (metadataValue?.Length > 0)
                         {
                             // return a result through the enumerator
                             yield return new Pair<string, S>(item.Key, item.Value);
@@ -2665,7 +2664,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
@@ -2701,7 +2700,7 @@ internal static IEnumerable<Pair<string, S>> WithMetadataValue(Expander<P, I> ex
                 /// </summary>
                 internal static IEnumerable<Pair<string, S>> AnyHaveMetadataValue(Expander<P, I> expander, IElementLocation elementLocation, bool includeNullEntries, string functionName, IEnumerable<Pair<string, S>> itemsOfType, string[] arguments)
                 {
-                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments != null && arguments.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
+                    ProjectErrorUtilities.VerifyThrowInvalidProject(arguments?.Length == 2, elementLocation, "InvalidItemFunctionSyntax", functionName, (arguments == null ? 0 : arguments.Length));
 
                     string metadataName = arguments[0];
                     string metadataValueToFind = arguments[1];
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index 57ac51c9724..ce854e2339e 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -90,7 +90,7 @@ internal static bool ContainsMetadataExpressionOutsideTransform(string expressio
 
             GetReferencedItemNamesAndMetadata(expression, 0, expression.Length, ref pair, ShredderOptions.MetadataOutsideTransforms);
 
-            bool result = (pair.Metadata != null && pair.Metadata.Count > 0);
+            bool result = (pair.Metadata?.Count > 0);
 
             return result;
         }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index 89f99c08aee..528b2d85cbd 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -81,8 +81,7 @@ protected override ImmutableList<I> SelectItems(ImmutableList<ItemData>.Builder
                     {
                         string value = valueFragment.TextFragment;
 
-                        if (excludeTester == null ||
-                            !excludeTester.Value(EscapingUtilities.UnescapeAll(value)))
+                        if (excludeTester?.Value(EscapingUtilities.UnescapeAll(value)) != true)
                         {
                             var item = _itemFactory.CreateItem(value, value, _itemElement.ContainingProject.FullPath);
                             itemsToAdd.Add(item);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index 03d07264cf2..146e15c4df2 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -157,7 +157,7 @@ public string GetEscapedValueIfPresent(string itemType, string name)
 
                 private string RouteCall(string itemType, string name, Func<IMetadataTable, string, string, string> getEscapedValueFunc)
                 {
-                    if (itemType == null || itemType.Equals(_operationItem.Key, StringComparison.OrdinalIgnoreCase))
+                    if (itemType?.Equals(_operationItem.Key, StringComparison.OrdinalIgnoreCase) != false)
                     {
                         return getEscapedValueFunc(_operationItem, itemType, name);
                     }
@@ -298,7 +298,7 @@ protected bool NeedToExpandMetadataForEachItem(ImmutableList<ProjectMetadataElem
 
                 bool needToExpandMetadataForEachItem = false;
 
-                if (itemsAndMetadataFound.Metadata != null && itemsAndMetadataFound.Metadata.Values.Count > 0)
+                if (itemsAndMetadataFound.Metadata?.Values.Count > 0)
                 {
                     // If there is bare metadata of any kind, and the Include involved an item list, we should
                     // run items individually, as even non-built-in metadata might differ between items
diff --git a/src/Build/Instance/HostServices.cs b/src/Build/Instance/HostServices.cs
index 8c820643d32..37f535e216e 100644
--- a/src/Build/Instance/HostServices.cs
+++ b/src/Build/Instance/HostServices.cs
@@ -171,12 +171,12 @@ public void UnregisterProject(string projectFullPath)
         {
             if (projectFullPath != null)
             {
-                if (_hostObjectMap != null && _hostObjectMap.ContainsKey(projectFullPath))
+                if (_hostObjectMap?.ContainsKey(projectFullPath) == true)
                 {
                     _hostObjectMap.Remove(projectFullPath);
                 }
 
-                if (_projectAffinities != null && _projectAffinities.ContainsKey(projectFullPath))
+                if (_projectAffinities?.ContainsKey(projectFullPath) == true)
                 {
                     _projectAffinities.Remove(projectFullPath);
                 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index cff4feb6b66..8c53170fbf7 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -2846,10 +2846,7 @@ private Dictionary<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(Evaluat
 
                 _items.Add(instance);
 
-                if (projectItemToInstanceMap != null)
-                {
-                    projectItemToInstanceMap.Add(item, instance);
-                }
+                projectItemToInstanceMap?.Add(item, instance);
             }
 
             return projectItemToInstanceMap;
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 972ba876609..bdda0096b5f 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -106,7 +106,7 @@ internal ProjectItemInstance(ProjectInstance project, string itemType, string in
         {
             CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = null;
 
-            if (directMetadata != null && directMetadata.GetEnumerator().MoveNext())
+            if (directMetadata?.GetEnumerator().MoveNext() == true)
             {
                 metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>(directMetadata.FastCountOrZero());
                 foreach (KeyValuePair<string, string> metadatum in directMetadata)
@@ -1553,7 +1553,7 @@ public bool Equals(TaskItem other)
             /// </remarks>
             public bool HasMetadata(string name)
             {
-                if ((_directMetadata != null && _directMetadata.Contains(name)) ||
+                if ((_directMetadata?.Contains(name) == true) ||
                      FileUtilities.ItemSpecModifiers.IsItemSpecModifier(name) ||
                     GetItemDefinitionMetadata(name) != null)
                 {
@@ -2026,7 +2026,7 @@ public TaskItem CreateItem(string includeEscaped, ProjectItemInstance baseItem,
                 {
                     TaskItem item = new TaskItem(baseItem);
 
-                    if (Path.DirectorySeparatorChar != '\\' && includeEscaped != null && includeEscaped.IndexOf('\\') > -1)
+                    if (Path.DirectorySeparatorChar != '\\' && includeEscaped?.IndexOf('\\') > -1)
                     {
                         includeEscaped = includeEscaped.Replace('\\', '/');
                     }
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index e9960ce22a2..a2e1a5573b1 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -332,7 +332,7 @@ internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingConte
             // the task factory parameters if we have any to calculate; otherwise even if we 
             // still launch the task factory, it will be with parameters corresponding to the 
             // current process. 
-            if ((_factoryIdentityParameters != null && _factoryIdentityParameters.Count > 0) || (taskIdentityParameters != null && taskIdentityParameters.Count > 0))
+            if ((_factoryIdentityParameters?.Count > 0) || (taskIdentityParameters?.Count > 0))
             {
                 VerifyThrowIdentityParametersValid(taskIdentityParameters, taskLocation, _taskName, "MSBuildRuntime", "MSBuildArchitecture");
 
@@ -475,7 +475,7 @@ internal bool TaskNameCreatableByFactory(string taskName, IDictionary<string, st
         private static void VerifyThrowIdentityParametersValid(IDictionary<string, string> identityParameters, IElementLocation errorLocation, string taskName, string runtimeName, string architectureName)
         {
             // validate the task factory parameters
-            if (identityParameters != null && identityParameters.Count > 0)
+            if (identityParameters?.Count > 0)
             {
                 string runtime = null;
                 if (identityParameters.TryGetValue(XMakeAttributes.runtime, out runtime))
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 62d541b85d1..0b7e5a47fbb 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -321,10 +321,7 @@ internal void MarkAsInactive()
             {
                 ILease lease = (ILease)RemotingServices.GetLifetimeService(this);
 
-                if (lease != null)
-                {
-                    lease.Unregister(_sponsor);
-                }
+                lease?.Unregister(_sponsor);
 
                 _sponsor.Close();
                 _sponsor = null;
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index 3d261b4cf46..cd6382e530e 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -477,7 +477,7 @@ out bool retrievedFromCache
             }
 
             // Try the current task registry
-            if (taskRecord == null && _taskRegistrations != null && _taskRegistrations.Count > 0)
+            if (taskRecord == null && _taskRegistrations?.Count > 0)
             {
                 if (exactMatchRequired)
                 {
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 8a46cb45cac..bc8f203903e 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -670,7 +670,7 @@ private void Write(BuildEventContext buildEventContext)
 
         private void Write<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>> keyValuePairs)
         {
-            if (keyValuePairs != null && keyValuePairs.Any())
+            if (keyValuePairs?.Any() == true)
             {
                 Write(keyValuePairs.Count());
                 foreach (var kvp in keyValuePairs)
diff --git a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
index f488f9eee31..e5a3eb3b459 100644
--- a/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -118,10 +118,7 @@ public void Initialize(IEventSource eventSource)
             }
             catch (ArgumentException e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
-                if (_nodeFileLogger != null)
-                {
-                    _nodeFileLogger.Shutdown();
-                }
+                _nodeFileLogger?.Shutdown();
 
                 string errorCode;
                 string helpKeyword;
@@ -138,10 +135,7 @@ public void Initialize(IEventSource eventSource)
         /// </summary>
         public void Shutdown()
         {
-            if (_nodeFileLogger != null)
-            {
-                _nodeFileLogger.Shutdown();
-            }
+            _nodeFileLogger?.Shutdown();
         }
         #endregion
 
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index eb876400d4e..d143789de6b 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1389,7 +1389,7 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
             TargetStartedEventMinimumFields targetStartedEvent = _buildEventManager.GetTargetStartedEvent(e);
 
             // Make sure we have not shown the event before
-            if (targetStartedEvent != null && !targetStartedEvent.ShowTargetFinishedEvent)
+            if (targetStartedEvent?.ShowTargetFinishedEvent == false)
             {
                 // Since the target started event has been shows, the target finished event should also be shown
                 targetStartedEvent.ShowTargetFinishedEvent = true;
@@ -1463,7 +1463,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                 ProjectStartedEventMinimumFields projectStartedEvent = _buildEventManager.GetProjectStartedEvent(e);
 
                 // Make sure the project started event has not been show yet
-                if (projectStartedEvent != null && !projectStartedEvent.ShowProjectFinishedEvent)
+                if (projectStartedEvent?.ShowProjectFinishedEvent == false)
                 {
                     projectStartedEvent.ShowProjectFinishedEvent = true;
 
@@ -1721,7 +1721,7 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
                     String.Format(CultureInfo.CurrentCulture, "{0,-40}" /* pad to 40 align left */, scopeName),
                     String.Format(CultureInfo.CurrentCulture, "{0,3}", calls));
 
-                if (_internalPerformanceCounters != null && _internalPerformanceCounters.Count > 0)
+                if (_internalPerformanceCounters?.Count > 0)
                 {
                     // For each of the entry points in the project print out the performance numbers for them
                     foreach (var counter in _internalPerformanceCounters.Values)
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index af005dfbe68..2db1d8b1fbc 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -214,7 +214,7 @@ internal void RemoveProjectStartedEvent(BuildEventContext e)
         {
             ProjectStartedEventMinimumFields startedEvent = GetProjectStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInProject)
+            if (startedEvent?.ErrorInProject == false)
             {
                 _projectStartedEvents.Remove(e);
             }
@@ -227,7 +227,7 @@ internal void RemoveTargetStartedEvent(BuildEventContext e)
         {
             TargetStartedEventMinimumFields startedEvent = GetTargetStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInTarget)
+            if (startedEvent?.ErrorInTarget == false)
             {
                 _targetStartedEvents.Remove(e);
             }
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index baf3db16561..a518daca13c 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -372,9 +372,9 @@ private void DoConvert()
         {
             // Make sure we were passed in non-empty source and destination project
             // file names.
-            error.VerifyThrowArgument((this.oldProjectFile != null) && (this.oldProjectFile.Length > 0),
+            error.VerifyThrowArgument((this.oldProjectFile?.Length > 0),
                 "MissingOldProjectFile");
-            error.VerifyThrowArgument((this.newProjectFile != null) && (this.newProjectFile.Length > 0),
+            error.VerifyThrowArgument((this.newProjectFile?.Length > 0),
                 "MissingNewProjectFile");
 
             ConvertInMemoryToMSBuildProject();
@@ -425,7 +425,7 @@ private void ConvertInMemoryToMSBuildProject()
         {
             // Make sure we were passed in non-empty source and destination project
             // file names.
-            error.VerifyThrowArgument((this.oldProjectFile != null) && (this.oldProjectFile.Length > 0),
+            error.VerifyThrowArgument((this.oldProjectFile?.Length > 0),
                 "MissingOldProjectFile");
 
             // Make sure the source project file exists.
@@ -1190,10 +1190,7 @@ public bool FSharpSpecificConversions(bool actuallyMakeChanges)
                 }
             }
 
-            if (newFSharpCoreItem != null)
-            {
-                newFSharpCoreItem.AddMetadata("Private", "True");
-            }
+            newFSharpCoreItem?.AddMetadata("Private", "True");
 
             
             const string MinimumVisualStudioVersionProperty = "MinimumVisualStudioVersion";
@@ -1433,8 +1430,7 @@ XmlElementWithLocation      visualStudioProjectElement
             )
         {
             // Make sure this is the <VisualStudioProject> element.
-            error.VerifyThrow((visualStudioProjectElement != null) &&
-                (visualStudioProjectElement.Name == VSProjectElements.visualStudioProject),
+            error.VerifyThrow((visualStudioProjectElement?.Name == VSProjectElements.visualStudioProject),
                 "Expected <VisualStudioProject> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -1717,7 +1713,7 @@ private void AddFinalPropertiesAndImports(XmlElementWithLocation languageElement
                     !isTriumphProject        // Doesn't apply to Triumph->Trinity conversions.
                 )
                 {
-                    if (this.outputType != null && this.outputType.Length > 0)
+                    if (this.outputType?.Length > 0)
                     {
                         if (String.Compare(this.outputType, XMakeProjectStrings.winExe, StringComparison.OrdinalIgnoreCase) == 0)
                         {
@@ -1825,8 +1821,7 @@ XmlElementWithLocation      buildElement
             )
         {
             // Make sure this is the <Build> element.
-            error.VerifyThrow((buildElement != null) &&
-                (buildElement.Name == VSProjectElements.build), "Expected <Build> element.");
+            error.VerifyThrow((buildElement?.Name == VSProjectElements.build), "Expected <Build> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
             error.VerifyThrow(xmakeProject != null, "Expected valid XMake project object.");
@@ -1893,8 +1888,7 @@ XmlElementWithLocation      settingsElement
             )
         {
             // Make sure this is the <Settings> element.
-            error.VerifyThrow((settingsElement != null) &&
-                (settingsElement.Name == VSProjectElements.settings),
+            error.VerifyThrow((settingsElement?.Name == VSProjectElements.settings),
                 "Expected <Settings> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -2019,8 +2013,7 @@ XmlElementWithLocation      configElement
             )
         {
             // Make sure this is the <Config> element.
-            error.VerifyThrow((configElement != null) &&
-                (configElement.Name == VSProjectElements.config),
+            error.VerifyThrow((configElement?.Name == VSProjectElements.config),
                 "Expected <Config> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -2077,7 +2070,7 @@ XmlElementWithLocation      configElement
 
             // Get the "Name" attribute of the <Config> element.
             string configName = configElement.GetAttribute(VSProjectAttributes.name);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((configName != null) && (configName.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject((configName?.Length > 0),
                 configElement.Location, "MissingAttribute", VSProjectElements.config, VSProjectAttributes.name);
 
             // In the case of VSD projects, the "Name" attribute will have a pipe in it,
@@ -2115,7 +2108,7 @@ XmlElementWithLocation      configElement
 
             // Process OutputPath attribute separately to ensure it contains trailing backslash
             string outputPath = configElement.GetAttribute(VSProjectAttributes.outputPath);
-            if (outputPath != null && outputPath.Length > 0)
+            if (outputPath?.Length > 0)
             {
                 if (outputPath[outputPath.Length-1] != Path.DirectorySeparatorChar)
                     outputPath += Path.DirectorySeparatorChar;
@@ -2127,20 +2120,20 @@ XmlElementWithLocation      configElement
             // If the "SelectedDevice" or "DeploymentPlatform" attributes exist in the per-user
             //   project file, we should get rid of them.
             string selectedDevice = configElement.GetAttribute ( VSProjectAttributes.selectedDevice );
-            if ( isUserFile && ( selectedDevice != null ) && ( selectedDevice.Length > 0 ) )
+            if (isUserFile && (selectedDevice?.Length > 0))
             {
                 configElement.RemoveAttribute ( VSProjectAttributes.selectedDevice );
             }
 
             string deploymentPlatform = configElement.GetAttribute ( VSProjectAttributes.deploymentPlatform );
-            if ( isUserFile && ( deploymentPlatform != null ) && ( deploymentPlatform.Length > 0 ) )
+            if (isUserFile && (deploymentPlatform?.Length > 0))
             {
                 configElement.RemoveAttribute ( VSProjectAttributes.deploymentPlatform );
             }
 
             // Get rid of the "IncrementalBuild" attribute
             string incrementalBuild = configElement.GetAttribute ( VSProjectAttributes.incrementalBuild );
-            if (incrementalBuild != null && incrementalBuild.Length > 0)
+            if (incrementalBuild?.Length > 0)
             {
                 configElement.RemoveAttribute ( VSProjectAttributes.incrementalBuild );
             }
@@ -2261,8 +2254,7 @@ XmlElementWithLocation      platformElement
             if ( !IsUserFile )
             {
                 // Make sure this is the <Platform> element.
-                error.VerifyThrow((platformElement != null) &&
-                    (platformElement.Name == VSProjectElements.platform),
+                error.VerifyThrow((platformElement?.Name == VSProjectElements.platform),
                     "Expected <Platform> element.");
 
                 // Make sure the caller has given us a valid xmakeProject object.
@@ -2285,7 +2277,7 @@ XmlElementWithLocation      platformElement
 
                 // Get the "Name" attribute of the <Platform> element.
                 platformForVSD = platformElement.GetAttribute(VSProjectAttributes.name);
-                ProjectErrorUtilities.VerifyThrowInvalidProject((platformForVSD != null) && (platformForVSD.Length > 0),
+                ProjectErrorUtilities.VerifyThrowInvalidProject((platformForVSD?.Length > 0),
                     platformElement.Location, "MissingAttribute", VSProjectElements.platform, VSProjectAttributes.name);
 
                 // Create a new property group, and add all of the XML attributes as XMake
@@ -2354,8 +2346,7 @@ ProjectPropertyGroupElement configPropertyGroup
             )
         {
             // Make sure this is the <InteropRegistration> element.
-            error.VerifyThrow((interopRegistrationElement != null) &&
-                (interopRegistrationElement.Name == VSProjectElements.interopRegistration),
+            error.VerifyThrow((interopRegistrationElement?.Name == VSProjectElements.interopRegistration),
                 "Expected <InteropRegistration> element.");
 
             // Make sure we've been given a valid configuration property group.
@@ -2411,8 +2402,7 @@ XmlElementWithLocation      referencesElement
             )
         {
             // Make sure this is the <References> element.
-            error.VerifyThrow((referencesElement != null) &&
-                (referencesElement.Name == VSProjectElements.references),
+            error.VerifyThrow((referencesElement?.Name == VSProjectElements.references),
                 "Expected <References> element.");
 
             // Make sure the caller has given us a valid xmakeProject object.
@@ -2496,8 +2486,7 @@ ProjectItemGroupElement referencesItemGroup
             )
         {
             // Make sure this is the <Reference> element.
-            error.VerifyThrow((referenceElement != null) &&
-                (referenceElement.Name == VSProjectElements.reference),
+            error.VerifyThrow((referenceElement?.Name == VSProjectElements.reference),
                 "Expected <Reference> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -2509,7 +2498,7 @@ ProjectItemGroupElement referencesItemGroup
             //   "-Designer", we need to disregard this reference entirely.
 
             string platform = referenceElement.GetAttribute(VSProjectAttributes.platform);
-            if ((platform != null) && (platform.Length > 0))
+            if ((platform?.Length > 0))
             {
                 if (platform.IndexOf("-Designer", 0, platform.Length, StringComparison.Ordinal) != -1)
                 {
@@ -2524,7 +2513,7 @@ ProjectItemGroupElement referencesItemGroup
             // Get the "Name" attribute.  This is a required attribute in the VS7/
             // Everett format.
             string referenceName = referenceElement.GetAttribute(VSProjectAttributes.name);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((referenceName != null) && (referenceName.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject((referenceName?.Length > 0),
                 referenceElement.Location, "MissingAttribute", VSProjectAttributes.name, VSProjectElements.reference);
 
             // Before we go any further, we must special-case some assemblies for VSD projects.
@@ -2566,12 +2555,12 @@ ProjectItemGroupElement referencesItemGroup
             // reference.
             string referencedProjectGuid = referenceElement.GetAttribute(VSProjectAttributes.project);
 
-            if ((comReferenceGuid != null) && (comReferenceGuid.Length > 0) &&
+            if ((comReferenceGuid?.Length > 0) &&
                 (comReferenceGuid != "{00000000-0000-0000-0000-000000000000}"))
             {
                 newReferenceItem = ConvertClassicComReference(referenceElement, referencesItemGroup, referenceName);
             }
-            else if ((referencedProjectGuid != null) && (referencedProjectGuid.Length > 0))
+            else if ((referencedProjectGuid?.Length > 0))
             {
                 newReferenceItem = ConvertProjectToProjectReference(referenceElement, referencesItemGroup, referenceName, ref referencedProjectGuid);
             }
@@ -2954,8 +2943,7 @@ XmlElementWithLocation      importsElement
             )
         {
             // Make sure this is the <Imports> element.
-            error.VerifyThrow((importsElement != null) &&
-                (importsElement.Name == VSProjectElements.imports),
+            error.VerifyThrow((importsElement?.Name == VSProjectElements.imports),
                 "Expected <Imports> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3020,8 +3008,7 @@ ProjectItemGroupElement importsItemGroup
             )
         {
             // Make sure this is the <Import> element.
-            error.VerifyThrow((importElement != null) &&
-                (importElement.Name == VSProjectElements.import),
+            error.VerifyThrow((importElement?.Name == VSProjectElements.import),
                 "Expected <Import> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3030,7 +3017,7 @@ ProjectItemGroupElement importsItemGroup
 
             // Get the required "Namespace" attribute.
             string importNamespace = importElement.GetAttribute(VSProjectAttributes.importNamespace);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((importNamespace != null) && (importNamespace.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject((importNamespace?.Length > 0),
                 importElement.Location, "MissingAttribute", VSProjectAttributes.importNamespace, VSProjectElements.import);
             // Remove the "Namespace" attribute, so it doesn't show up in our loop later.
             importElement.RemoveAttribute(VSProjectAttributes.importNamespace);
@@ -3073,8 +3060,7 @@ XmlElementWithLocation      filesElement
             )
         {
             // Make sure this is the <Files> element.
-            error.VerifyThrow((filesElement != null) &&
-                (filesElement.Name == VSProjectElements.files),
+            error.VerifyThrow((filesElement?.Name == VSProjectElements.files),
                 "Expected <Files> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3140,8 +3126,7 @@ XmlElementWithLocation      includeElement
             )
         {
             // Make sure this is the <Include> element.
-            error.VerifyThrow((includeElement != null) &&
-                (includeElement.Name == VSProjectElements.include),
+            error.VerifyThrow((includeElement?.Name == VSProjectElements.include),
                 "Expected <Include> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3210,8 +3195,7 @@ ProjectItemGroupElement filesItemGroup
             )
         {
             // Make sure this is the <File> element.
-            error.VerifyThrow((fileElement != null) &&
-                (fileElement.Name == VSProjectElements.file),
+            error.VerifyThrow((fileElement?.Name == VSProjectElements.file),
                 "Expected <File> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3220,7 +3204,7 @@ ProjectItemGroupElement filesItemGroup
 
             // Get the required "RelPath" attribute.
             string relPath = fileElement.GetAttribute(VSProjectAttributes.relPath);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((relPath != null) && (relPath.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject((relPath?.Length > 0),
                 fileElement.Location, "MissingAttribute", VSProjectAttributes.relPath, VSProjectElements.file);
             // Remove the "RelPath" attribute, so we don't end up adding it twice.
             fileElement.RemoveAttribute(VSProjectAttributes.relPath);
@@ -3400,8 +3384,7 @@ ProjectItemGroupElement filesItemGroup
             )
         {
             // Make sure this is the <Folder> element.
-            error.VerifyThrow((folderElement != null) &&
-                (folderElement.Name == VSProjectElements.folder),
+            error.VerifyThrow((folderElement?.Name == VSProjectElements.folder),
                 "Expected <Folder> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3410,7 +3393,7 @@ ProjectItemGroupElement filesItemGroup
 
             // Get the required "RelPath" attribute.
             string relPath = folderElement.GetAttribute(VSProjectAttributes.relPath);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((relPath != null) && (relPath.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject((relPath?.Length > 0),
                 folderElement.Location, "MissingAttribute", VSProjectAttributes.relPath, VSProjectElements.folder);
             // Remove the "RelPath" attribute, so we don't end up adding it twice.
             folderElement.RemoveAttribute(VSProjectAttributes.relPath);
@@ -3454,7 +3437,7 @@ ProjectItemGroupElement filesItemGroup
                 newFolderItem = filesItemGroup.AddItem(XMakeProjectStrings.webReferences,
                     ProjectCollection.Escape(relPath));
             }
-            else if ((webReferenceUrl != null) && (webReferenceUrl.Length > 0))
+            else if ((webReferenceUrl?.Length > 0))
             {
                 // This is an actual web reference URL.
 
@@ -3549,8 +3532,7 @@ XmlElementWithLocation      startupServicesElement
             )
         {
             // Make sure this is the <StartupServices> element.
-            error.VerifyThrow((startupServicesElement != null) &&
-                (startupServicesElement.Name == VSProjectElements.startupServices),
+            error.VerifyThrow((startupServicesElement?.Name == VSProjectElements.startupServices),
                 "Expected <StartupServices> element.");
 
             // Make sure the caller gave us a valid xmakeProject to stuff
@@ -3614,8 +3596,7 @@ ProjectItemGroupElement startupServicesItemGroup
             )
         {
             // Make sure this is the <Service> element.
-            error.VerifyThrow((serviceElement != null) &&
-                (serviceElement.Name == VSProjectElements.service),
+            error.VerifyThrow((serviceElement?.Name == VSProjectElements.service),
                 "Expected <Service> element.");
 
             // Make sure the caller has already created an ProjectItemGroupElement for us to
@@ -3624,7 +3605,7 @@ ProjectItemGroupElement startupServicesItemGroup
 
             // Get the required "ID" attribute.
             string id = serviceElement.GetAttribute(VSProjectAttributes.id);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((id != null) && (id.Length > 0), serviceElement.Location,
+            ProjectErrorUtilities.VerifyThrowInvalidProject((id?.Length > 0), serviceElement.Location,
                 "MissingAttribute", VSProjectAttributes.id, VSProjectElements.service);
             // Remove the "ID" attribute, so it doesn't show up in our loop later.
             serviceElement.RemoveAttribute(VSProjectAttributes.id);
@@ -3667,8 +3648,7 @@ XmlElementWithLocation      otherProjectSettingsElement
             )
         {
             // Make sure this is the <OtherProjectSettings> element.
-            error.VerifyThrow((otherProjectSettingsElement != null) &&
-                (otherProjectSettingsElement.Name == VSProjectElements.otherProjectSettings),
+            error.VerifyThrow((otherProjectSettingsElement?.Name == VSProjectElements.otherProjectSettings),
                 "Expected <Settings> element.");
 
             // Make sure the caller gave us a valid globalPropertyGroup to stuff
@@ -3724,8 +3704,7 @@ out bool                    isTriumphProject
             )
         {
             // Make sure this is the <UserProperties> element.
-            error.VerifyThrow((userPropertiesElement != null) &&
-                (userPropertiesElement.Name == VSProjectElements.userProperties),
+            error.VerifyThrow((userPropertiesElement?.Name == VSProjectElements.userProperties),
                 "Expected <UserProperties> element.");
 
             isTriumphProject = false;
@@ -3823,7 +3802,7 @@ out bool                    isTriumphProject
                 if (officeDocumentPathAttribute != null)
                 {
                     string officeDocumentPath = officeDocumentPathAttribute.Value;
-                    if ((officeDocumentPath != null) && (officeDocumentPath.Length > 0))
+                    if ((officeDocumentPath?.Length > 0))
                     {
                         string projectFileDirectory = Path.GetDirectoryName(Path.GetFullPath(this.oldProjectFile));
                         string officeDocumentFullPath = Path.GetFullPath(Path.Combine(projectFileDirectory, officeDocumentPath));
diff --git a/src/Deprecated/Engine/Choose/Choose.cs b/src/Deprecated/Engine/Choose/Choose.cs
index 7293f8b23cd..b26f269b905 100644
--- a/src/Deprecated/Engine/Choose/Choose.cs
+++ b/src/Deprecated/Engine/Choose/Choose.cs
@@ -237,10 +237,7 @@ ProcessingPass pass
             else
             {
                 ErrorUtilities.VerifyThrow(pass == ProcessingPass.Pass2, "ProcessingPass must be Pass1 or Pass2.");
-                if (whenLastTaken != null)
-                {
-                    whenLastTaken.Evaluate(parentPropertyBag, ignoreCondition, honorCondition, conditionedPropertiesTable, pass);
-                }
+                whenLastTaken?.Evaluate(parentPropertyBag, ignoreCondition, honorCondition, conditionedPropertiesTable, pass);
             }
         }
 
diff --git a/src/Deprecated/Engine/Choose/GroupingCollection.cs b/src/Deprecated/Engine/Choose/GroupingCollection.cs
index 16d130649e0..80e61bac385 100644
--- a/src/Deprecated/Engine/Choose/GroupingCollection.cs
+++ b/src/Deprecated/Engine/Choose/GroupingCollection.cs
@@ -65,10 +65,7 @@ internal void ChangePropertyGroupCount(int delta)
             this.propertyGroupCount += delta;
             ErrorUtilities.VerifyThrow(this.propertyGroupCount >= 0, "The property group count should never be negative");
 
-            if (parentGroupingCollection != null)
-            {
-                parentGroupingCollection.ChangePropertyGroupCount(delta);
-            }
+            parentGroupingCollection?.ChangePropertyGroupCount(delta);
         }
 
         /// <summary>
@@ -156,10 +153,7 @@ internal void ChangeItemGroupCount(int delta)
             this.itemGroupCount += delta;
             ErrorUtilities.VerifyThrow(this.itemGroupCount >= 0, "The item group count should never be negative");
 
-            if (parentGroupingCollection != null)
-            {
-                parentGroupingCollection.ChangeItemGroupCount(delta);
-            }
+            parentGroupingCollection?.ChangeItemGroupCount(delta);
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Collections/DualQueue.cs b/src/Deprecated/Engine/Collections/DualQueue.cs
index 13afc4e393f..2eec32fdd2c 100644
--- a/src/Deprecated/Engine/Collections/DualQueue.cs
+++ b/src/Deprecated/Engine/Collections/DualQueue.cs
@@ -131,10 +131,7 @@ internal void Enqueue(T item)
                     queueReadyEvent.Set();
 
                     // reset queue empty
-                    if (queueEmptyEvent != null)
-                    {
-                        queueEmptyEvent.Reset();
-                    }
+                    queueEmptyEvent?.Reset();
                 }
             }
         }
@@ -162,10 +159,7 @@ internal void EnqueueArray(T[] items)
                     queueReadyEvent.Set();
 
                     // reset queue empty
-                    if (queueEmptyEvent != null)
-                    {
-                        queueEmptyEvent.Reset();
-                    }
+                    queueEmptyEvent?.Reset();
                 }
             }
         }
@@ -183,10 +177,7 @@ internal void Clear()
                 // reset queue ready event because the queue is now empty
                 queueReadyEvent.Reset();
                 // raise queue empty event because the queue is now empty
-                if (queueEmptyEvent != null)
-                {
-                    queueEmptyEvent.Set();
-                }
+                queueEmptyEvent?.Set();
             }
         }
 
@@ -235,10 +226,7 @@ private T GetTopItem(bool dequeue)
                         // signal there are no more items to read
                         queueReadyEvent.Reset();
 
-                        if (queueEmptyEvent != null)
-                        {
-                            queueEmptyEvent.Set();
-                        }
+                        queueEmptyEvent?.Set();
                     }
                 }
             }
diff --git a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
index a02b7ba708e..df182d5140b 100644
--- a/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
+++ b/src/Deprecated/Engine/Conditionals/OperatorExpressionNode.cs
@@ -72,15 +72,9 @@ internal override string GetUnexpandedValue(ConditionEvaluationState state)
         /// </summary>
         internal override void ResetState()
         {
-            if (leftChild != null)
-            {
-                leftChild.ResetState();
-            }
+            leftChild?.ResetState();
 
-            if (rightChild != null)
-            {
-                rightChild.ResetState();
-            }
+            rightChild?.ResetState();
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Conditionals/Scanner.cs b/src/Deprecated/Engine/Conditionals/Scanner.cs
index 2c40ffac255..52dd35b9833 100644
--- a/src/Deprecated/Engine/Conditionals/Scanner.cs
+++ b/src/Deprecated/Engine/Conditionals/Scanner.cs
@@ -148,7 +148,7 @@ internal bool Advance()
             if (errorState)
                 return false;
 
-            if (lookahead != null && lookahead.IsToken(Token.TokenType.EndOfInput))
+            if (lookahead?.IsToken(Token.TokenType.EndOfInput) == true)
                 return true;          
 
             SkipWhiteSpace();
diff --git a/src/Deprecated/Engine/Engine/BatchingEngine.cs b/src/Deprecated/Engine/Engine/BatchingEngine.cs
index 62d82b0be79..aae62dac278 100644
--- a/src/Deprecated/Engine/Engine/BatchingEngine.cs
+++ b/src/Deprecated/Engine/Engine/BatchingEngine.cs
@@ -123,7 +123,7 @@ string implicitBatchableItemType
             Dictionary<string, MetadataReference> consumedMetadataReferences = pair.Metadata;
 
             ArrayList buckets = null;
-            if (consumedMetadataReferences != null && consumedMetadataReferences.Count > 0)
+            if (consumedMetadataReferences?.Count > 0)
             {
                 // Add any item types that we were explicitly told to assume.
                 if (implicitBatchableItemType != null)
diff --git a/src/Deprecated/Engine/Engine/BuildTask.cs b/src/Deprecated/Engine/Engine/BuildTask.cs
index d1f7ef13095..170055d5f72 100644
--- a/src/Deprecated/Engine/Engine/BuildTask.cs
+++ b/src/Deprecated/Engine/Engine/BuildTask.cs
@@ -517,11 +517,11 @@ private void MarkTaskAsDirty
             (
             )
         {
-            if (this.ParentTarget != null)
-            {
+               
+            
                 // This is a change to the contents of the target.
-                this.ParentTarget.MarkTargetAsDirty();
-            }
+                this.ParentTarget?.MarkTargetAsDirty();
+            
         }
 
         #endregion
diff --git a/src/Deprecated/Engine/Engine/Engine.cs b/src/Deprecated/Engine/Engine/Engine.cs
index e9b5b85cf45..d6b256d2fcf 100644
--- a/src/Deprecated/Engine/Engine/Engine.cs
+++ b/src/Deprecated/Engine/Engine/Engine.cs
@@ -1210,7 +1210,7 @@ internal void EndEatingLoggingEvents()
         /// <exception cref="InternalLoggerException">Logger threw arbitrary exception</exception>
         public void UnregisterAllLoggers()
         {
-            if (forwardingLoggers != null && forwardingLoggers.Count > 0)
+            if (forwardingLoggers?.Count > 0)
             {
                 // Disconnect forwarding loggers from the event source
                 ((EngineLoggingServicesInProc)primaryLoggingServices).UnregisterEventSource
@@ -1269,7 +1269,7 @@ internal void EndingEngineExecution(bool buildResult, bool exitedDueToError)
                 // parent node, so post the event directly to the forwarding loggers.
                 if (Router.ChildMode)
                 {
-                    if (loggers != null && loggers.Count > 0)
+                    if (loggers?.Count > 0)
                     {
                         // Flush all the events currently in the queue
                         LoggingServices.ProcessPostedLoggingEvents();
@@ -1950,7 +1950,7 @@ bool initialCall
                 // Flush out all the logging messages, which may have been posted outside target execution
                 primaryLoggingServices.ProcessPostedLoggingEvents();
 
-                if (buildRequest != null && buildRequest.BuildCompleted || exitedDueToError)
+                if (buildRequest?.BuildCompleted == true || exitedDueToError)
                 {
 #if (!STANDALONEBUILD)
                     CodeMarkers.Instance.CodeMarker(CodeMarkerEvent.perfMSBuildEngineBuildProjectEnd);
@@ -2038,8 +2038,8 @@ private void FinishBuildProjectInProgress(BuildRequest buildRequest, ProjectBuil
                 buildRequest.ProcessingTotalTime += DateTime.Now.Ticks - buildRequest.ProcessingStartTime;
             }
 
-            if (buildRequest != null && buildRequest.BuildCompleted ||
-                buildContext != null && buildContext.BuildComplete )
+            if (buildRequest?.BuildCompleted == true ||
+                buildContext?.BuildComplete == true)
             {
                 DecrementProjectsInProgress();
             }
@@ -2327,7 +2327,7 @@ string [] toolVersions
             BuildEventContext buildEventContext;
                
             // Already have an instantiated project in the OM and it has not fired a project started event for itself yet
-            if (project != null && !project.HaveUsedInitialProjectContextId)
+            if (project?.HaveUsedInitialProjectContextId == false)
             {
                 buildEventContext = project.ProjectBuildEventContext;
             }
@@ -2803,7 +2803,7 @@ bool toolsVersionPeekedFromProjectFile
                 if (this.cacheOfBuildingProjects.HasProjectBeenLoaded(projectFullPath, globalPropertiesToUse, toolsVersionToUse))
                 {
                     string joinedNames = ResourceUtilities.FormatResourceString("DefaultTargets");
-                    if (targetNames != null && targetNames.Length > 0)
+                    if (targetNames?.Length > 0)
                     {
                         joinedNames = EscapingUtilities.UnescapeAll(String.Join(";", targetNames));
                     }
@@ -3002,7 +3002,7 @@ internal NodeStatus RequestStatus(int requestId)
             {
                 foreach (Target target in project.Targets)
                 {
-                    if (target.ExecutionState != null && target.ExecutionState.BuildingRequiredTargets)
+                    if (target.ExecutionState?.BuildingRequiredTargets == true)
                     {
                         inProgressTargets.Add(target);
                     }
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
index 15ad1514da1..a83003dc3dc 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
@@ -744,7 +744,7 @@ virtual internal void LogProjectStarted(int projectId, BuildEventContext parentB
                 ProjectStartedEventArgs e;
 
                
-                if (null != targetNames && targetNames.Length > 0)
+                if (targetNames?.Length > 0)
                 {
                     e = new ProjectStartedEventArgs
                         (
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
index 2f6bd3a4f9a..fbf4ed120dd 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServicesInProc.cs
@@ -119,10 +119,7 @@ override internal void ProcessBuildEvent(BuildEventArgs buildEventArgs)
             }
 
             // Check if it necessary to forward the event to another logging service
-            if (forwardingService != null)
-            {
-                forwardingService.PostLoggingEvent(buildEventArgs);
-            }
+            forwardingService?.PostLoggingEvent(buildEventArgs);
         }
 
         internal void RegisterEventSource(int loggerId, EventSource eventSource)
diff --git a/src/Deprecated/Engine/Engine/EngineProxy.cs b/src/Deprecated/Engine/Engine/EngineProxy.cs
index a1934f5d9b3..c9d1df15059 100644
--- a/src/Deprecated/Engine/Engine/EngineProxy.cs
+++ b/src/Deprecated/Engine/Engine/EngineProxy.cs
@@ -626,10 +626,7 @@ internal void MarkAsInActive()
             {
                 ILease lease = (ILease)RemotingServices.GetLifetimeService(this);
              
-                if (lease != null)
-                {
-                    lease.Unregister(sponsor);
-                }
+                lease?.Unregister(sponsor);
                 
                 sponsor.Close();
                 sponsor = null;
diff --git a/src/Deprecated/Engine/Engine/Node.cs b/src/Deprecated/Engine/Engine/Node.cs
index a16f21d38e1..d0d1b2cecee 100644
--- a/src/Deprecated/Engine/Engine/Node.cs
+++ b/src/Deprecated/Engine/Engine/Node.cs
@@ -457,10 +457,7 @@ internal void ReportUnhandledError(Exception originalException)
                 LocalNode.DumpExceptionToFile(originalException);
             }
 
-            if (localEngine != null)
-            {
-                localEngine.Shutdown();
-            }
+            localEngine?.Shutdown();
         }
 
         /// <summary>
@@ -474,10 +471,7 @@ internal void ReportUnhandledError(Exception originalException)
         /// <exception cref="Exception">Re-throws exception passed in</exception>
         internal void ReportFatalCommunicationError(Exception originalException, TextWriter loggingStream)
         {
-            if (loggingStream != null)
-            {
-                loggingStream.WriteLine(originalException.ToString());
-            }
+            loggingStream?.WriteLine(originalException.ToString());
 
             string message = ResourceUtilities.FormatResourceString("FatalErrorOnChildNode", nodeId, originalException.Message);
 
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index 95a20a3e551..072199f21db 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -1018,10 +1018,7 @@ public BuildPropertyGroup GlobalProperties
                 // the XML every time any property value changes.
 
                 // Unhook the old globalProperties from this project.
-                if (globalProperties != null)
-                {
-                    globalProperties.ClearParentProject();
-                }
+                globalProperties?.ClearParentProject();
 
                 globalProperties = value.Clone(true);
 
@@ -1356,7 +1353,7 @@ private XmlDeclaration XmlDeclarationNode
         {
             get
             {
-                if (mainProjectEntireContents != null && mainProjectEntireContents.HasChildNodes)
+                if (mainProjectEntireContents?.HasChildNodes == true)
                 {
                     return mainProjectEntireContents.FirstChild as XmlDeclaration;
                 }
@@ -3312,7 +3309,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                 else if (buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.CycleDetected)
                 {
                     ErrorUtilities.VerifyThrow(
-                        taskExecutionContext != null && taskExecutionContext.ParentTarget != null,
+                        taskExecutionContext?.ParentTarget != null,
                         "Unexpected task context. Should not be null");
                     // Check that the target is in progress
                     ErrorUtilities.VerifyThrow(
@@ -3358,8 +3355,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                             while (buildContext.NameOfBlockingTarget != null)
                             {
                                 Target blockingTarget = GetTargetForName(buildContext.NameOfBlockingTarget);
-                                if (blockingTarget.ExecutionState != null &&
-                                    blockingTarget.ExecutionState.BuildingRequiredTargets)
+                                if (blockingTarget.ExecutionState?.BuildingRequiredTargets == true)
                                 {
                                     blockingTarget.ContinueBuild(buildContext, null);
                                 }
@@ -3367,8 +3363,7 @@ internal void ContinueBuild(ProjectBuildState buildContext, TaskExecutionContext
                                 buildContext.RemoveBlockingTarget();
                             }
                             Target inprogressTarget = GetTargetForName(buildContext.NameOfTargetInProgress);
-                            if (inprogressTarget.ExecutionState != null &&
-                                inprogressTarget.ExecutionState.BuildingRequiredTargets)
+                            if (inprogressTarget.ExecutionState?.BuildingRequiredTargets == true)
                             {
                                 inprogressTarget.ContinueBuild(buildContext, null);
                             }
@@ -3581,7 +3576,7 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
                 if (!ParentEngine.LoggingServices.OnlyLogCriticalEvents && buildRequest.FireProjectStartedFinishedEvents)
                 {  
                     string joinedTargetNamesToBuild = null;
-                    if (targetNamesToBuild != null && targetNamesToBuild.Length > 0)
+                    if (targetNamesToBuild?.Length > 0)
                     {
                         joinedTargetNamesToBuild = EscapingUtilities.UnescapeAll(String.Join(";", targetNamesToBuild));
                     }
@@ -3603,7 +3598,7 @@ private ProjectBuildState InitializeForBuildingTargets(BuildRequest buildRequest
 
                         // Get the list of properties to serialize to the parent node
                         string[] propertyListToSerialize = parentEngine.PropertyListToSerialize;
-                        if (propertyListToSerialize != null && propertyListToSerialize.Length > 0)
+                        if (propertyListToSerialize?.Length > 0)
                         {
                             foreach (string propertyToGet in propertyListToSerialize)
                             {
@@ -4202,7 +4197,7 @@ private XmlDocument LoadImportedProject(Import import)
                         ImportedProject previouslyImportedProject = (ImportedProject)ParentEngine.ImportedProjectsCache[import.EvaluatedProjectPath];
                         
                         // if this project hasn't been imported before, or if it has changed on disk, we need to load it
-                        if ((previouslyImportedProject == null) || previouslyImportedProject.HasChangedOnDisk(import.EvaluatedProjectPath))
+                        if ((previouslyImportedProject?.HasChangedOnDisk(import.EvaluatedProjectPath) != false))
                         {
                             try
                             {
diff --git a/src/Deprecated/Engine/Engine/ProjectBuildState.cs b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
index f21598c28a5..1e77263e737 100644
--- a/src/Deprecated/Engine/Engine/ProjectBuildState.cs
+++ b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
@@ -89,7 +89,7 @@ internal string NameOfBlockingTarget
         {
             get
             {
-                return (requiredTargets != null && requiredTargets.Count > 0 ?
+                return (requiredTargets?.Count > 0 ?
                         this.requiredTargets.Peek() : null);
             }
         }
@@ -199,14 +199,14 @@ internal void RecordBuildException()
         internal bool ContainsCycle(string name)
         {
             bool containsCycle = false;
-            if (requiredTargets != null && requiredTargets.Count > 1)
+            if (requiredTargets?.Count > 1)
             {
                 string topTarget = requiredTargets.Pop();
                 ErrorUtilities.VerifyThrow(topTarget == name, "Requesting target should be on the top of stack");
                 containsCycle = requiredTargets.Contains(name);
                 requiredTargets.Push(topTarget);
             }
-            if (!containsCycle && requiredTargets != null && requiredTargets.Count > 0)
+            if (!containsCycle && requiredTargets?.Count > 0)
             {
                 containsCycle = 
                     (String.Compare(name, (string)targetNamesToBuild[indexOfTargetInProgress], StringComparison.OrdinalIgnoreCase) == 0);
@@ -221,7 +221,7 @@ internal bool ContainsCycle(string name)
         internal bool ContainsBlockingTarget(string name)
         {
             bool containsName = false;
-            if (requiredTargets != null && requiredTargets.Count > 0)
+            if (requiredTargets?.Count > 0)
             {
                 containsName = requiredTargets.Contains(name);
             }
@@ -237,7 +237,7 @@ internal bool ContainsBlockingTarget(string name)
         internal string GetParentTarget(string name)
         {
             string parentName = null;
-            if (requiredTargets != null && requiredTargets.Count > 0)
+            if (requiredTargets?.Count > 0)
             {
                 parentName = (string)targetNamesToBuild[indexOfTargetInProgress];
 
diff --git a/src/Deprecated/Engine/Engine/ProjectManager.cs b/src/Deprecated/Engine/Engine/ProjectManager.cs
index 234a362b835..7b5a6917d02 100644
--- a/src/Deprecated/Engine/Engine/ProjectManager.cs
+++ b/src/Deprecated/Engine/Engine/ProjectManager.cs
@@ -156,7 +156,7 @@ string projectFileFullPath
             // Get the list of projects that have this full path.
             ArrayList projectsWithThisFullPath = (ArrayList) this.projects[projectFileFullPath];
 
-            if ((projectsWithThisFullPath != null) && (projectsWithThisFullPath.Count > 0))
+            if ((projectsWithThisFullPath?.Count > 0))
             {
                 return (Project) projectsWithThisFullPath[0];
             }
diff --git a/src/Deprecated/Engine/Engine/Router.cs b/src/Deprecated/Engine/Engine/Router.cs
index 7e61058766d..999d71d8d1b 100644
--- a/src/Deprecated/Engine/Engine/Router.cs
+++ b/src/Deprecated/Engine/Engine/Router.cs
@@ -131,12 +131,12 @@ internal void PostDoneNotice(BuildRequest buildRequest)
         /// </summary>
         internal void PostDoneNotice(int nodeId, BuildResult buildResult)
         {
-            if (scheduler != null)
-            {
+               
+            
                 // Notify the scheduler that a given node(nodeId) will be getting a buildResult.
                 // This method is a no-op if the router is on a child process
-                scheduler.NotifyOfBuildResult(nodeId, buildResult);
-            }
+                scheduler?.NotifyOfBuildResult(nodeId, buildResult);
+            
 
             if (nodeId == EngineCallback.inProcNode)
             {
@@ -179,12 +179,12 @@ internal void PostBuildRequest(BuildRequest currentRequest, int nodeIndex)
                                     (nodeIndex, currentRequest.HandleId, currentRequest.NodeIndex,
                                      currentRequest.RequestId, cacheScope, currentRequest, null);
 
-                    if (scheduler != null)
-                    {
+                       
+                    
                         // Check to see if we need to change the traversal strategy of the system
                         // parentHandleId and node index are not used in the function so it can be ignored
-                        scheduler.NotifyOfBuildRequest(nodeIndex, currentRequest, parentHandleId);
-                    }
+                        scheduler?.NotifyOfBuildRequest(nodeIndex, currentRequest, parentHandleId);
+                    
                     
                     nodeManager.PostBuildRequestToNode(nodeIndex, currentRequest);
                 }
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index fcf77939cb8..97feb66b64a 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -226,7 +226,7 @@ bool        importedFromAnotherProject
             }
 
             // It's considered an error if a target does not have a name.
-            ProjectErrorUtilities.VerifyThrowInvalidProject((targetName != null) && (targetName.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject((targetName?.Length > 0),
                 targetElement, "MissingRequiredAttribute", XMakeAttributes.name, XMakeElements.target);
 
             this.taskElementList = new ArrayList();
@@ -732,11 +732,11 @@ internal void MarkTargetAsDirty
             (
             )
         {
-            if (this.ParentProject != null)
-            {
+               
+            
                 // This is a change to the contents of the project file.
-                this.ParentProject.MarkProjectAsDirty();
-            }
+                this.ParentProject?.MarkProjectAsDirty();
+            
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
index 377fe8f63ad..86cd6937734 100644
--- a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
+++ b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
@@ -238,7 +238,7 @@ out Hashtable upToDateTargetInputs
                 // 1) they do not reference any item vector
                 // 2) they reference item vectors that are not referenced by any input item
                 if ((discreteItemsInTargetOutputs.Count > 0) ||
-                    ((itemVectorsReferencedOnlyInTargetOutputs != null) && (itemVectorsReferencedOnlyInTargetOutputs.Count > 0)))
+                    ((itemVectorsReferencedOnlyInTargetOutputs?.Count > 0)))
                 {
                     result = PerformDependencyAnalysisIfDiscreteOutputs(
                                 itemVectorsInTargetInputs, itemVectorTransformsInTargetInputs, discreteItemsInTargetInputs,
@@ -1140,7 +1140,7 @@ private void RecordComparisonResults(string input, string output, string inputIt
         /// </returns>
         private int CompareLastWriteTimes(string path1, string path2, out bool path1DoesNotExist, out bool path2DoesNotExist)
         {
-            ErrorUtilities.VerifyThrow((path1 != null) && (path1.Length > 0) && (path2 != null) && (path2.Length > 0),
+            ErrorUtilities.VerifyThrow((path1 != null) && (path1.Length > 0) && (path2?.Length > 0),
                 "Need to specify paths to compare.");
 
             FileInfo path1Info = null;
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index 54396fee8ad..152c1b2b313 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -293,15 +293,9 @@ internal bool ExecuteTask(TaskExecutionMode howToExecuteTask, Lookup lookup)
             finally
             {
                 // Remove the AssemblyResolve handler in the default AppDomain, we are done with the task.
-                if (resolver != null)
-                {
-                    resolver.RemoveHandler();
-                }
+                resolver?.RemoveHandler();
 
-                if (engineProxy != null)
-                {
-                    engineProxy.MarkAsInActive();
-                }
+                engineProxy?.MarkAsInActive();
 
                 // Now all task batches are done, apply all item adds to the outer 
                 // target batch; we do this even if the task wasn't found (in that case,
@@ -997,7 +991,7 @@ private void GatherArrayStringAndValueOutputs(Lookup lookup, TaskOutput taskOutp
 
                 if (taskOutputSpecification.IsItemVector)
                 {
-                    ErrorUtilities.VerifyThrow((itemName != null) && (itemName.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow((itemName?.Length > 0), "Need item type.");
 
                     // to store the outputs as items, use the string representations of the outputs as item-specs
                     foreach (object output in convertibleOutputs)
@@ -1018,7 +1012,7 @@ private void GatherArrayStringAndValueOutputs(Lookup lookup, TaskOutput taskOutp
                 else
                 {
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName != null) && (propertyName.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow((propertyName?.Length > 0), "Need property name.");
 
                     // to store an object array in a property, join all the string representations of the objects with
                     // semi-colons to make the property value
@@ -1055,7 +1049,7 @@ private void GatherTaskItemOutputs(Lookup lookup, TaskOutput taskOutputSpecifica
 
                 if (taskOutputSpecification.IsItemVector)
                 {
-                    ErrorUtilities.VerifyThrow((itemName != null) && (itemName.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow((itemName?.Length > 0), "Need item type.");
 
                     foreach (ITaskItem output in taskItemOutputs)
                     {
@@ -1069,7 +1063,7 @@ private void GatherTaskItemOutputs(Lookup lookup, TaskOutput taskOutputSpecifica
                 else
                 {
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName != null) && (propertyName.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow((propertyName?.Length > 0), "Need property name.");
 
                     // to store an ITaskItem array in a property, join all the item-specs with semi-colons to make the
                     // property value, and ignore/discard the attributes on the ITaskItems
@@ -1132,7 +1126,7 @@ ItemBucket bucket
                 {
                     // This is an output item.
 
-                    ErrorUtilities.VerifyThrow((itemName != null) && (itemName.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow((itemName?.Length > 0), "Need item type.");
 
                     // Expand only with properties first, so that expressions like Include="@(foo)" will transfer the metadata of the "foo" items as well, not just their item specs.
                     Expander propertyAndMetadataExpander = new Expander(bucket.Expander, ExpanderOptions.ExpandPropertiesAndMetadata);
@@ -1167,7 +1161,7 @@ ItemBucket bucket
                     // This is an output property.
 
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName != null) && (propertyName.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow((propertyName?.Length > 0), "Need property name.");
 
                     string taskParameterValue = bucket.Expander.ExpandAllIntoString(taskParameterAttribute);
 
diff --git a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
index ef382bd585a..b71c5f9b966 100644
--- a/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetConfigurationReader.cs
@@ -55,7 +55,7 @@ protected override IEnumerable<PropertyDefinition> ToolsVersions
                                               toolset.ElementInformation.LineNumber
                                           );
 
-                        if (toolset.toolsVersion != null && toolset.toolsVersion.Length == 0)
+                        if (toolset.toolsVersion?.Length == 0)
                         {
                             InvalidToolsetDefinitionException.Throw("InvalidToolsetValueInConfigFileValue", location);
                         }
@@ -104,7 +104,7 @@ protected override IEnumerable<PropertyDefinition> GetPropertyDefinitions(string
                                       propertyElement.ElementInformation.LineNumber
                                   );
 
-                if (propertyElement.Name != null && propertyElement.Name.Length == 0)
+                if (propertyElement.Name?.Length == 0)
                 {
                     InvalidToolsetDefinitionException.Throw("InvalidToolsetValueInConfigFileValue", location);
                 }
diff --git a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
index bb45c98d08a..8ced8acc680 100644
--- a/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
+++ b/src/Deprecated/Engine/Engine/ToolsetRegistryReader.cs
@@ -125,7 +125,7 @@ protected override IEnumerable<PropertyDefinition> GetPropertyDefinitions(string
             {
                 string propertyValue = null;
 
-                if (propertyName != null && propertyName.Length == 0)
+                if (propertyName?.Length == 0)
                 {
                     InvalidToolsetDefinitionException.Throw("PropertyNameInRegistryHasZeroLength", toolsVersionWrapper.Name);
                 }
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index 54447515463..d088dd1c1a6 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -93,10 +93,10 @@ bool initializationException
          )
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message != null) && (message.Length > 0), "Need error message.");
+            ErrorUtilities.VerifyThrow((message?.Length > 0), "Need error message.");
             ErrorUtilities.VerifyThrow(innerException != null || initializationException == true, "Need the logger exception.");
-            ErrorUtilities.VerifyThrow((errorCode != null) && (errorCode.Length > 0), "Must specify the error message code.");
-            ErrorUtilities.VerifyThrow((helpKeyword != null) && (helpKeyword.Length > 0), "Must specify the help keyword for the IDE.");
+            ErrorUtilities.VerifyThrow((errorCode?.Length > 0), "Must specify the error message code.");
+            ErrorUtilities.VerifyThrow((helpKeyword?.Length > 0), "Must specify the help keyword for the IDE.");
 
             this.e = e;
             this.errorCode = errorCode;
diff --git a/src/Deprecated/Engine/Errors/RemoteErrorException.cs b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
index 1e040579d39..f63005004de 100644
--- a/src/Deprecated/Engine/Errors/RemoteErrorException.cs
+++ b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
@@ -19,7 +19,7 @@ public sealed class RemoteErrorException : Exception
         internal RemoteErrorException(string message, Exception innerException, BuildEventContext buildEventContext)
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message != null) && (message.Length > 0), "Need error message.");
+            ErrorUtilities.VerifyThrow((message?.Length > 0), "Need error message.");
             ErrorUtilities.VerifyThrow(innerException != null, "Need the logger exception.");
 
             this.buildEventContext = buildEventContext;
diff --git a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
index 52ff67e5b6d..ccedf6b7e24 100644
--- a/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
+++ b/src/Deprecated/Engine/Introspector/TargetInProgressState.cs
@@ -271,7 +271,7 @@ ProjectBuildState projectBuildState
             TargetInProgessState.TargetIdWrapper parentName =
                 FindParentTarget(engineCallback, projectBuildState, target, out parentRequest);
 
-            if (parentName != null && parentName.Equals(parentId))
+            if (parentName?.Equals(parentId) == true)
             {
                 return true;
             }
diff --git a/src/Deprecated/Engine/Items/BuildItem.cs b/src/Deprecated/Engine/Items/BuildItem.cs
index 8abbf2b1924..4ba36c3af14 100644
--- a/src/Deprecated/Engine/Items/BuildItem.cs
+++ b/src/Deprecated/Engine/Items/BuildItem.cs
@@ -647,7 +647,7 @@ public string Include
                 {
                     // If this is an evaluated item that originated from the project file, and the original
                     // item is declared using a wildcard that still matches the new item spec ...
-                    if ((ParentPersistedItem != null) && (ParentPersistedItem.NewItemSpecMatchesExistingWildcard(value)))
+                    if ((ParentPersistedItem?.NewItemSpecMatchesExistingWildcard(value) == true))
                     {
                         // Don't need to touch the project file since the original wildcard still matches
                         // the new item spec.  But it still should be reevaluated the next time around.
@@ -1776,10 +1776,7 @@ private Project GetParentProject()
         private void MarkItemAsDirty()
         {
             Project parentProject = GetParentProject();
-            if (parentProject != null)
-            {
-                parentProject.MarkProjectAsDirty();
-            }
+            parentProject?.MarkProjectAsDirty();
         }
 
         /// <summary>
@@ -1789,10 +1786,7 @@ private void MarkItemAsDirty()
         private void MarkItemAsDirtyForReevaluation()
         {
             Project parentProject = GetParentProject();
-            if (parentProject != null)
-            {
-                parentProject.MarkProjectAsDirtyForReevaluation();
-            }
+            parentProject?.MarkProjectAsDirtyForReevaluation();
         }
 
         /// <summary>
@@ -1877,10 +1871,7 @@ private void SplitItem()
         /// <owner>rgoel</owner>
         internal void SplitChildItemIfNecessary()
         {
-            if (this.ParentPersistedItem != null)
-            {
-                this.ParentPersistedItem.SplitItem();
-            }
+            this.ParentPersistedItem?.SplitItem();
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Items/BuildItemGroup.cs b/src/Deprecated/Engine/Items/BuildItemGroup.cs
index f80ff6d33d8..ec027f1f7a3 100644
--- a/src/Deprecated/Engine/Items/BuildItemGroup.cs
+++ b/src/Deprecated/Engine/Items/BuildItemGroup.cs
@@ -663,10 +663,7 @@ internal void RemoveAllIntermediateItems()
         /// </summary>
         private void MarkItemGroupAsDirty()
         {
-            if (parentProject != null)
-            {
-                parentProject.MarkProjectAsDirty();
-            }
+            parentProject?.MarkProjectAsDirty();
         }
 
         /// <summary>
@@ -747,7 +744,7 @@ private void MustBeInitialized()
         /// </summary>
         private void MustHaveThisParentElement(BuildItem item)
         {
-            ErrorUtilities.VerifyThrowInvalidOperation(item != null && item.ItemElement != null && item.ItemElement.ParentNode == xml.Element, "ItemDoesNotBelongToItemGroup");
+            ErrorUtilities.VerifyThrowInvalidOperation(item?.ItemElement != null && item.ItemElement.ParentNode == xml.Element, "ItemDoesNotBelongToItemGroup");
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Items/ItemExpander.cs b/src/Deprecated/Engine/Items/ItemExpander.cs
index 56f3737c2f7..78999ddbc24 100644
--- a/src/Deprecated/Engine/Items/ItemExpander.cs
+++ b/src/Deprecated/Engine/Items/ItemExpander.cs
@@ -191,7 +191,7 @@ out Match itemVectorMatch
 
             itemVectorMatch = GetItemVectorMatches(itemVectorExpression);
 
-            if (itemVectorMatch != null && itemVectorMatch.Success)
+            if (itemVectorMatch?.Success == true)
             {
                 // The method above reports a match if there are any
                 // valid @(itemlist) references in the given expression.
@@ -236,7 +236,7 @@ internal static bool ExpressionContainsItemVector(string expression)
         {
             Match itemVectorMatch = GetItemVectorMatches(expression);
 
-            if (itemVectorMatch != null && itemVectorMatch.Success)
+            if (itemVectorMatch?.Success == true)
             {
                 return true;
             }
diff --git a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
index e41665da673..e626597fe4f 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/ExpressionShredder.cs
@@ -120,7 +120,7 @@ internal static bool ContainsMetadataExpressionOutsideTransform(string expressio
 
             GetReferencedItemNamesAndMetadata(expression, 0, expression.Length, ref pair, ShredderOptions.MetadataOutsideTransforms);
 
-            bool result = (pair.Metadata != null && pair.Metadata.Count > 0);
+            bool result = (pair.Metadata?.Count > 0);
 
             return result;
         }
diff --git a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
index 30fb00eb92b..7ae380ba873 100644
--- a/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
+++ b/src/Deprecated/Engine/ItemsAndProperties/Lookup.cs
@@ -884,10 +884,7 @@ private void ImportItemsIntoTable(Hashtable table, string name, BuildItemGroup g
         private void RemoveItemsFromTableWithBackup(Hashtable table, string name, BuildItemGroup group)
         {
             BuildItemGroup existing = (BuildItemGroup)table[name];
-            if (existing != null)
-            {
-                existing.RemoveItemsWithBackup(group);
-            }
+            existing?.RemoveItemsWithBackup(group);
         }
 
         /// <summary>
@@ -897,10 +894,7 @@ private void RemoveItemsFromTableWithBackup(Hashtable table, string name, BuildI
         private void ApplyModificationsToTable(Hashtable table, string name, Dictionary<BuildItem, Dictionary<string, string>> modify)
         {
             BuildItemGroup existing = (BuildItemGroup)table[name];
-            if (existing != null)
-            {
-                existing.ModifyItemsUsingVirtualMetadata(modify);
-            }
+            existing?.ModifyItemsUsingVirtualMetadata(modify);
         }
 
         /// <summary>
@@ -1018,7 +1012,7 @@ private void MustNotBeInTable(Hashtable table, BuildItem item)
         /// </summary>
         private void MustNotBeInTable(Dictionary<string, Dictionary<BuildItem, Dictionary<string, string>>> table, BuildItem item)
         {
-            if (table != null && table.ContainsKey(item.Name))
+            if (table?.ContainsKey(item.Name) == true)
             {
                 Dictionary<BuildItem, Dictionary<string, string>> tableOfItemsOfSameType = table[item.Name];
                 if (tableOfItemsOfSameType != null)
@@ -1034,7 +1028,7 @@ private void MustNotBeInTable(Dictionary<string, Dictionary<BuildItem, Dictionar
         /// </summary>
         private void MustNotBeInTable(Hashtable table, string name, BuildItemGroup group)
         {
-            if (table != null && table.ContainsKey(name))
+            if (table?.ContainsKey(name) == true)
             {
                 BuildItemGroup existing = (BuildItemGroup)table[name];
                 if (existing != null)
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNode.cs b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
index 4b071b8da18..8537a6211a7 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNode.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNode.cs
@@ -153,15 +153,9 @@ void StopCommunicationThreads()
             // to start up its communication threads. This can happen if the node is started with /nodemode:x
             // and no parent is running, or if the parent node has spawned a new process and then crashed 
             // before establishing communication with the child node.
-            if(writerThread != null)
-            {
-              writerThread.Join();
-            }
+            writerThread?.Join();
 
-            if (readerThread != null)
-            {
-                readerThread.Join();
-            }
+            readerThread?.Join();
 
             // Make sure the exit event is not set
             communicationThreadExitEvent.Reset();
@@ -548,10 +542,7 @@ internal void ReportFatalCommunicationError(Exception originalException)
             }
             finally
             {
-                if (node != null)
-                {
-                    node.ReportFatalCommunicationError(originalException, null);
-                }
+                node?.ReportFatalCommunicationError(originalException, null);
             }
         }
 
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
index 2137adc272a..3c0d967fd5d 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeCallback.cs
@@ -122,7 +122,7 @@ internal void PostReplyFromParent(LocalReplyCallDescriptor reply)
             lock (repliesFromParent)
             {
                 ReplyData replyData = (ReplyData) repliesFromParent[requestingCallNumber];
-                ErrorUtilities.VerifyThrow(replyData != null && replyData.waitEvent != null, 
+                ErrorUtilities.VerifyThrow(replyData?.waitEvent != null, 
                     "We must have an event for this call at this point");
 
                 replyData.reply = reply;
diff --git a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
index ef43c638ee9..507d99f9229 100644
--- a/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
+++ b/src/Deprecated/Engine/LocalProvider/LocalNodeProvider.cs
@@ -755,10 +755,7 @@ private static  bool checkIfNodeActive(int nodeNumber)
             }
             finally
             {
-                if (nodeActiveHandle != null)
-                {
-                    nodeActiveHandle.Close();
-                }
+                nodeActiveHandle?.Close();
             }
 
             return nodeIsActive;
@@ -817,10 +814,7 @@ private void LaunchNode(int nodeIndex)
             finally
             {
                 // Dispose before losing scope
-                if (nodeReadyEvent != null)
-                {
-                    nodeReadyEvent.Close();
-                }
+                nodeReadyEvent?.Close();
 
                 if (exitedDueToError)
                 {
diff --git a/src/Deprecated/Engine/Logging/ConsoleLogger.cs b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
index 0ac8f1ffcf4..35c7ea997af 100644
--- a/src/Deprecated/Engine/Logging/ConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ConsoleLogger.cs
@@ -322,10 +322,7 @@ public virtual void Initialize(IEventSource eventSource, int nodeCount)
         /// </summary>
         public virtual void Shutdown()
         {
-            if (consoleLogger != null)
-            {
-                consoleLogger.Shutdown();
-            }
+            consoleLogger?.Shutdown();
         }
 
         /// <summary>
diff --git a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
index 128db0a76cc..1e26513c374 100644
--- a/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
+++ b/src/Deprecated/Engine/Logging/DistributedLoggers/DistributedFileLogger.cs
@@ -113,10 +113,7 @@ public void Initialize(IEventSource eventSource)
             catch (ArgumentException e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
 
-                if(nodeFileLogger != null)
-                {
-                    nodeFileLogger.Shutdown();
-                }
+                nodeFileLogger?.Shutdown();
 
                 string errorCode;
                 string helpKeyword;
@@ -130,10 +127,7 @@ public void Initialize(IEventSource eventSource)
 
         public void Shutdown()
         {
-            if (nodeFileLogger != null)
-            {
-                nodeFileLogger.Shutdown();
-            }
+            nodeFileLogger?.Shutdown();
         }
         #endregion
 
diff --git a/src/Deprecated/Engine/Logging/FileLogger.cs b/src/Deprecated/Engine/Logging/FileLogger.cs
index 80c7e610897..9504674cc43 100644
--- a/src/Deprecated/Engine/Logging/FileLogger.cs
+++ b/src/Deprecated/Engine/Logging/FileLogger.cs
@@ -52,10 +52,7 @@ public override void Initialize(IEventSource eventSource)
 
         private void FileLoggerBuildFinished(object sender, BuildFinishedEventArgs e)
         {
-            if (fileWriter != null)
-            {
-                fileWriter.Flush();
-            }
+            fileWriter?.Flush();
         }
 
         /// <summary>
@@ -99,10 +96,7 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)
                 string errorCode;
                 string helpKeyword;
                 string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, "InvalidFileLoggerFile", logFileName, e.Message);
-                if (fileWriter != null)
-                {
-                    fileWriter.Close();
-                }
+                fileWriter?.Close();
                 throw new LoggerException(message,e.InnerException,errorCode, helpKeyword);
             }
         }
@@ -133,10 +127,7 @@ private void Write(string text)
                 string errorCode;
                 string helpKeyword;
                 string message = ResourceUtilities.FormatResourceString(out errorCode, out helpKeyword, "InvalidFileLoggerFile", logFileName, ex.Message);
-                if (fileWriter != null)
-                {
-                    fileWriter.Close();
-                }
+                fileWriter?.Close();
                 throw new LoggerException(message, ex.InnerException, errorCode, helpKeyword);
             }
         }
@@ -154,10 +145,7 @@ public override void Shutdown()
             finally
             {
                 // Keep FxCop happy by closing in a Finally.
-                if (fileWriter != null)
-                {
-                    fileWriter.Close();
-                }
+                fileWriter?.Close();
             }
         }
 
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 11a0c9161f2..0580cd44073 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1218,7 +1218,7 @@ private void DisplayDeferredTargetStartedEvent(BuildEventContext e)
             TargetStartedEventMinimumFields targetStartedEvent = buildEventManager.GetTargetStartedEvent(e);
 
             //Make sure we have not shown the event before
-            if (targetStartedEvent != null && !targetStartedEvent.ShowTargetFinishedEvent)
+            if (targetStartedEvent?.ShowTargetFinishedEvent == false)
             {
                 //Since the target started event has been shows, the target finished event should also be shown
                 targetStartedEvent.ShowTargetFinishedEvent = true;
@@ -1271,7 +1271,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                 ProjectStartedEventMinimumFields projectStartedEvent = buildEventManager.GetProjectStartedEvent(e);
 
                 // Make sure the project started event has not been show yet
-                if (projectStartedEvent != null && !projectStartedEvent.ShowProjectFinishedEvent)
+                if (projectStartedEvent?.ShowProjectFinishedEvent == false)
                 {
                     projectStartedEvent.ShowProjectFinishedEvent = true;
 
@@ -1550,7 +1550,7 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
                                "{0,3}", calls)
                    );
 
-                if (internalPerformanceCounters != null && internalPerformanceCounters.Count > 0)
+                if (internalPerformanceCounters?.Count > 0)
                 {
                     // For each of the entry points in the project print out the performance numbers for them
                     foreach (MPPerformanceCounter counter in internalPerformanceCounters.Values)
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index d8fa15e6395..8150a8ab4fe 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -214,7 +214,7 @@ internal void RemoveProjectStartedEvent(BuildEventContext e)
         {
             ProjectStartedEventMinimumFields startedEvent = GetProjectStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInProject)
+            if (startedEvent?.ErrorInProject == false)
             {
                 projectStartedEvents.Remove(e);
             }
@@ -227,7 +227,7 @@ internal void RemoveTargetStartedEvent(BuildEventContext e)
         {
             TargetStartedEventMinimumFields startedEvent = GetTargetStartedEvent(e);
             // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
-            if (startedEvent != null && !startedEvent.ErrorInTarget)
+            if (startedEvent?.ErrorInTarget == false)
             {
                 targetStartedEvents.Remove(e);
             }
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index e168ef4fe4a..9d8a5ad9dda 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -386,7 +386,7 @@ public string Name
                 else
                 {
                     // If we are not persisted, propertyName and propertyValue must not be null.
-                    ErrorUtilities.VerifyThrow((this.propertyName != null) && (this.propertyName.Length > 0) && (this.propertyValue != null),
+                    ErrorUtilities.VerifyThrow((this.propertyName?.Length > 0) && (this.propertyValue != null),
                         "BuildProperty object doesn't have a name/value pair.");
 
                     // Get the property name from the string variable
diff --git a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
index cfc4f221e58..e79384c81ad 100644
--- a/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
+++ b/src/Deprecated/Engine/Properties/BuildPropertyGroup.cs
@@ -812,7 +812,7 @@ BuildProperty newProperty
                 {
                     // Allow properties to be "set" to the same value during a build. This is because Visual Studio unfortunately does this often,
                     // and it is safe to do this, because we won't actually change any state.
-                    ErrorUtilities.VerifyThrowInvalidOperation(parentProject == null || !parentProject.IsBuilding, "CannotSetPropertyDuringBuild");
+                    ErrorUtilities.VerifyThrowInvalidOperation(parentProject?.IsBuilding != true, "CannotSetPropertyDuringBuild");
                 }
             }
 
@@ -1109,10 +1109,7 @@ string propertyName
                 this.propertyTableByName.Remove(propertyName);
 
                 // if the property was overridden by an output property, we also want to remove the original
-                if (propertiesOverriddenByOutputProperties != null)
-                {
-                    propertiesOverriddenByOutputProperties.Remove(propertyName);
-                }
+                propertiesOverriddenByOutputProperties?.Remove(propertyName);
             }
 
             this.MarkPropertyGroupAsDirty();
@@ -1216,19 +1213,13 @@ internal void ClearHelper(bool clearImportedPropertyGroup)
             this.conditionAttribute = null;
 
             // Clear the contents of the hash table, if one exists.
-            if (this.propertyTableByName != null)
-            {
-                this.propertyTableByName.Clear();
-            }
+            this.propertyTableByName?.Clear();
 
             // clear out saved properties
             propertiesOverriddenByOutputProperties = null;
 
             // Clear the contents of the arraylist, if one exists.
-            if (this.propertyList != null)
-            {
-                this.propertyList.Clear();
-            }
+            this.propertyList?.Clear();
 
             this.MarkPropertyGroupAsDirty();
         }
diff --git a/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs b/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
index f9d16f4a33a..adf31e1208d 100644
--- a/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
@@ -22,7 +22,7 @@ internal sealed class AssemblyLoadInfo
         /// <param name="assemblyFile"></param>
         public AssemblyLoadInfo(string assemblyName, string assemblyFile)
         {
-            ErrorUtilities.VerifyThrow(((assemblyName != null) && (assemblyName.Length > 0)) || ((assemblyFile != null) && (assemblyFile.Length > 0)),
+            ErrorUtilities.VerifyThrow(((assemblyName?.Length > 0)) || ((assemblyFile?.Length > 0)),
                 "We must have either the assembly name or the assembly file/path.");
             ErrorUtilities.VerifyThrow((assemblyName == null) || (assemblyFile == null),
                 "We must not have both the assembly name and the assembly file/path.");
diff --git a/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
index 111786115c7..16513362514 100644
--- a/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
@@ -31,7 +31,7 @@ internal ConfigurationInSolution(string configurationName, string platformName)
             this.platformName = platformName;
 
             // Some configurations don't have the platform part
-            if ((platformName != null) && (platformName.Length > 0))
+            if ((platformName?.Length > 0))
             {
                 this.fullName = string.Format(CultureInfo.InvariantCulture, "{0}{1}{2}", configurationName, configurationPlatformSeparator, platformName);
             }
diff --git a/src/Deprecated/Engine/Shared/FileMatcher.cs b/src/Deprecated/Engine/Shared/FileMatcher.cs
index 14872e95a16..3edac689a1f 100644
--- a/src/Deprecated/Engine/Shared/FileMatcher.cs
+++ b/src/Deprecated/Engine/Shared/FileMatcher.cs
@@ -1249,8 +1249,7 @@ DirectoryExists directoryExists
             // 2) if the extension is three characters, and the filename contains the * wildcard, it matches files with longer
             //    extensions that start with the same three characters e.g. "*.htm" would match both "file.htm" and "file.html"
             bool needToEnforceExtensionLength =
-                    (extensionPart != null) &&
-                    (extensionPart.IndexOf('*') == -1)
+                    (extensionPart?.IndexOf('*') == -1)
                 &&
                     (extensionPart.EndsWith("?", StringComparison.Ordinal)
                 ||
diff --git a/src/Deprecated/Engine/Shared/ProjectInSolution.cs b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
index 0c720f90641..90604ee33e0 100644
--- a/src/Deprecated/Engine/Shared/ProjectInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ProjectInSolution.cs
@@ -249,7 +249,7 @@ internal bool CanBeMSBuildProjectFile(out string errorMessage)
                     }
                 }
 
-                if (mainProjectElement != null && mainProjectElement.LocalName == "Project")
+                if (mainProjectElement?.LocalName == "Project")
                 {
                     if (String.Compare(mainProjectElement.NamespaceURI, XMakeAttributes.defaultXmlNamespace, StringComparison.OrdinalIgnoreCase) == 0)
                     {
diff --git a/src/Deprecated/Engine/Shared/ResourceUtilities.cs b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
index 89cb88cf8b2..a0839d3b360 100644
--- a/src/Deprecated/Engine/Shared/ResourceUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
@@ -121,7 +121,7 @@ internal static string FormatString(string unformatted, params object[] args)
             string formatted = unformatted;
 
             // NOTE: String.Format() does not allow a null arguments array
-            if ((args != null) && (args.Length > 0))
+            if ((args?.Length > 0))
             {
 #if DEBUG
 
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 0bb83616e54..6a839d3bb9a 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -328,15 +328,9 @@ internal void ParseSolutionFile()
             }
             finally
             {
-                if (fileStream != null)
-                {
-                    fileStream.Close();
-                }
+                fileStream?.Close();
 
-                if (reader != null)
-                {
-                    reader.Close();
-                }
+                reader?.Close();
             }
         }
 
@@ -555,7 +549,7 @@ private void ParseProject(string firstLine)
                     // We have a ProjectDependencies section.  Each subsequent line should identify
                     // a dependency.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         // This should be a dependency.  The GUID identifying the parent project should
                         // be both the property name and the property value.
@@ -575,7 +569,7 @@ private void ParseProject(string firstLine)
                     // projects, and contains properties that we'll need in order to call the 
                     // AspNetCompiler task.
                     line = ReadLine();
-                    while ((line != null) && (!line.StartsWith("EndProjectSection", StringComparison.Ordinal)))
+                    while ((line?.StartsWith("EndProjectSection", StringComparison.Ordinal) == false))
                     {
                         Match match = crackPropertyLine.Match(line);
                         ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile(match.Success, "SubCategoryForSolutionParsingErrors",
@@ -984,7 +978,7 @@ string property
             )
         {
             // If the incoming string starts and ends with a double-quote, strip the double-quotes.
-            if ((property != null) && (property.Length > 0) && (property[0] == '"') && (property[property.Length - 1] == '"'))
+            if ((property?.Length > 0) && (property[0] == '"') && (property[property.Length - 1] == '"'))
             {
                 return property.Substring(1, property.Length - 2);
             }
diff --git a/src/Deprecated/Engine/Shared/XmlUtilities.cs b/src/Deprecated/Engine/Shared/XmlUtilities.cs
index b9921bfee35..ed3e9f42c97 100644
--- a/src/Deprecated/Engine/Shared/XmlUtilities.cs
+++ b/src/Deprecated/Engine/Shared/XmlUtilities.cs
@@ -44,11 +44,11 @@ internal static XmlElement RenameXmlElement(XmlElement oldElement, string newEle
                 newElement.AppendChild(newChildNode);
             }
 
-            if (oldElement.ParentNode != null)
-            {
+               
+            
                 // Add the new element in the same place the old element was.
-                oldElement.ParentNode.ReplaceChild(newElement, oldElement);
-            }
+                oldElement.ParentNode?.ReplaceChild(newElement, oldElement);
+            
 
             return newElement;
         }
@@ -69,7 +69,7 @@ internal static string GetXmlNodeFile(XmlNode node, string defaultFile)
             string file = defaultFile;
 
             // NOTE: the XML node may not have a filename if it's purely an in-memory node
-            if ((node.OwnerDocument.BaseURI != null) && (node.OwnerDocument.BaseURI.Length > 0))
+            if ((node.OwnerDocument.BaseURI?.Length > 0))
             {
                 file = new Uri(node.OwnerDocument.BaseURI).LocalPath;
             }
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index abf63f9efc6..b3a3bc8a831 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -515,7 +515,7 @@ bool specifyProjectToolsVersion
             BuildTask newTask = target.AddNewTask("MSBuild");
             newTask.SetParameterValue("Projects", projectPath, true /* treat as literal */);
 
-            if (msbuildTargetName != null && msbuildTargetName.Length > 0)
+            if (msbuildTargetName?.Length > 0)
             {
                 newTask.SetParameterValue("Targets", msbuildTargetName);
             }
@@ -557,7 +557,7 @@ string subTargetName
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (subTargetName?.Length > 0)
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -902,7 +902,7 @@ string subTargetName
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (subTargetName?.Length > 0)
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -1344,7 +1344,7 @@ string subTargetName
             AddTargetForGetFrameworkPathAndRedistList(msbuildProject);
 
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (subTargetName?.Length > 0)
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -1541,7 +1541,7 @@ string errorMessage
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName != null && subTargetName.Length > 0)
+            if (subTargetName?.Length > 0)
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -1624,7 +1624,7 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
                 msbuildTask.SetParameterValue("Projects", buildItemReference);
                 msbuildTask.SetParameterValue("Properties", "Configuration=%(Configuration); Platform=%(Platform); BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)");
 
-                if (subTargetName != null && subTargetName.Length > 0)
+                if (subTargetName?.Length > 0)
                 {
                     msbuildTask.SetParameterValue("Targets", subTargetName);
                 }
@@ -1693,7 +1693,7 @@ static private string GetProjectDependencies(SolutionParser solution, ProjectInS
                     "SolutionParseProjectDepNotFoundError", project.ProjectGuid, dependency);
 
                 dependencies.Append(ProjectInSolution.DisambiguateProjectTargetName(projectUniqueName));
-                if (subTargetName != null && subTargetName.Length > 0)
+                if (subTargetName?.Length > 0)
                 {
                     dependencies.Append(":");
                     dependencies.Append(subTargetName);
@@ -1738,7 +1738,7 @@ string subTargetName
                 }
 
                 dependencies.Append(ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName()));
-                if (subTargetName != null && subTargetName.Length > 0)
+                if (subTargetName?.Length > 0)
                 {
                     dependencies.Append(":");
                     dependencies.Append(subTargetName);
diff --git a/src/Deprecated/Engine/Solution/VCWrapperProject.cs b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
index 2bb2aefb038..251bc3dcf86 100644
--- a/src/Deprecated/Engine/Solution/VCWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
@@ -99,7 +99,7 @@ string fullConfigurationName
 
             newTask.SetParameterValue("SolutionFile", solutionPath);
 
-            if ((vcbuildTargetName != null) && (vcbuildTargetName.Length > 0))
+            if ((vcbuildTargetName?.Length > 0))
             {
                 newTask.SetParameterValue(vcbuildTargetName, "true");
             }
diff --git a/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs b/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
index a9d6773aa49..8eeca1eb9f4 100644
--- a/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
+++ b/src/Deprecated/Engine/Xml/BuildItemGroupXml.cs
@@ -68,7 +68,7 @@ internal XmlElement ParentElement
         {
             get
             {
-                if (element != null && element.ParentNode is XmlElement)
+                if (element?.ParentNode is XmlElement)
                 {
                     return (XmlElement)element.ParentNode;
                 }
diff --git a/src/Framework/LazyFormattedBuildEventArgs.cs b/src/Framework/LazyFormattedBuildEventArgs.cs
index 8c38696e5bc..9813392c45f 100644
--- a/src/Framework/LazyFormattedBuildEventArgs.cs
+++ b/src/Framework/LazyFormattedBuildEventArgs.cs
@@ -94,7 +94,7 @@ public override string Message
             {
                 lock (locker)
                 {
-                    if (arguments != null && arguments.Length > 0)
+                    if (arguments?.Length > 0)
                     {
                         if (originalCultureInfo == null)
                         {
@@ -196,7 +196,7 @@ private static string FormatString(CultureInfo culture, string unformatted, para
             string formatted = unformatted;
 
             // NOTE: String.Format() does not allow a null arguments array
-            if ((args != null) && (args.Length > 0))
+            if ((args?.Length > 0))
             {
 #if DEBUG
 
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index b441f5800db..20d4e65b201 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -674,7 +674,7 @@ private void CancelTask()
 
             // Store in a local to avoid a race
             var wrapper = _taskWrapper;
-            if (wrapper != null && !wrapper.CancelTask())
+            if (wrapper?.CancelTask() == false)
             {
                 // Create a possibility for the task to be aborted if the user really wants it dropped dead asap
                 if (Environment.GetEnvironmentVariable("MSBUILDTASKHOSTABORTTASKONCANCEL") == "1")
@@ -711,10 +711,7 @@ private void HandleNodeBuildComplete(NodeBuildComplete buildComplete)
         private NodeEngineShutdownReason HandleShutdown()
         {
             // Wait for the RunTask task runner thread before shutting down so that we can cleanly dispose all WaitHandles.
-            if (_taskRunnerThread != null)
-            {
-                _taskRunnerThread.Join();
-            }
+            _taskRunnerThread?.Join();
 
             if (_debugCommunications)
             {
@@ -1086,7 +1083,7 @@ private void InitializeMismatchedEnvironmentTable(IDictionary<string, string> en
         /// </summary>
         private void SendBuildEvent(BuildEventArgs e)
         {
-            if (_nodeEndpoint != null && _nodeEndpoint.LinkStatus == LinkStatus.Active)
+            if (_nodeEndpoint?.LinkStatus == LinkStatus.Active)
             {
                 if (!e.GetType().GetTypeInfo().IsSerializable)
                 {
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 7b159909a64..0c16b60d569 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1324,10 +1324,7 @@ string outputResultsCache
             finally
             {
                 FileUtilities.ClearCacheDirectory();
-                if (projectCollection != null)
-                {
-                    projectCollection.Dispose();
-                }
+                projectCollection?.Dispose();
 
                 BuildManager.DefaultBuildManager.Dispose();
             }
@@ -2803,13 +2800,13 @@ DirectoryGetFiles getFiles
                 if (extensionsToIgnoreDictionary.Count > 0)
                 {
                     // No point removing extensions if we have no project files
-                    if (potentialProjectFiles != null && potentialProjectFiles.Length > 0)
+                    if (potentialProjectFiles?.Length > 0)
                     {
                         potentialProjectFiles = RemoveFilesWithExtensionsToIgnore(potentialProjectFiles, extensionsToIgnoreDictionary);
                     }
 
                     // No point removing extensions if we have no solutions
-                    if (potentialSolutionFiles != null && potentialSolutionFiles.Length > 0)
+                    if (potentialSolutionFiles?.Length > 0)
                     {
                         potentialSolutionFiles = RemoveFilesWithExtensionsToIgnore(potentialSolutionFiles, extensionsToIgnoreDictionary);
                     }
@@ -2890,7 +2887,7 @@ private static Dictionary<string, object> ValidateExtensions(string[] projectsEx
             Dictionary<string, object> extensionsToIgnoreDictionary = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
 
             // Go through each of the extensions to ignore and add them as a key in the dictionary
-            if (projectsExtensionsToIgnore != null && projectsExtensionsToIgnore.Length > 0)
+            if (projectsExtensionsToIgnore?.Length > 0)
             {
                 string extension = null;
 
@@ -2949,8 +2946,8 @@ Dictionary<string, object> extensionsToIgnoreDictionary
                                 )
         {
             // If we got to this method we should have to possible projects or solutions and some extensions to ignore
-            ErrorUtilities.VerifyThrow(((potentialProjectOrSolutionFiles != null) && (potentialProjectOrSolutionFiles.Length > 0)), "There should be some potential project or solution files");
-            ErrorUtilities.VerifyThrow(((extensionsToIgnoreDictionary != null) && (extensionsToIgnoreDictionary.Count > 0)), "There should be some extensions to Ignore");
+            ErrorUtilities.VerifyThrow(((potentialProjectOrSolutionFiles?.Length > 0)), "There should be some potential project or solution files");
+            ErrorUtilities.VerifyThrow(((extensionsToIgnoreDictionary?.Count > 0)), "There should be some extensions to Ignore");
 
             List<string> filesToKeep = new List<string>();
             foreach (string projectOrSolutionFile in potentialProjectOrSolutionFiles)
@@ -3206,7 +3203,7 @@ ArrayList loggers
                 ConsoleLogger logger = new ConsoleLogger(verbosity);
                 string consoleParameters = "SHOWPROJECTFILE=TRUE;";
 
-                if ((consoleLoggerParameters != null) && (consoleLoggerParameters.Length > 0))
+                if ((consoleLoggerParameters?.Length > 0))
                 {
                     consoleParameters = AggregateParameters(consoleParameters, consoleLoggerParameters);
                 }
@@ -3273,7 +3270,7 @@ int cpuCount
             if (distributedFileLogger)
             {
                 string fileParameters = string.Empty;
-                if ((fileLoggerParameters != null) && (fileLoggerParameters.Length > 0))
+                if ((fileLoggerParameters?.Length > 0))
                 {
                     // Join the file logger parameters into one string seperated by semicolons
                     fileParameters = AggregateParameters(null, fileLoggerParameters);
diff --git a/src/Samples/XmlFileLogger/ObjectModel/Build.cs b/src/Samples/XmlFileLogger/ObjectModel/Build.cs
index 2aaba8f0054..6d45a22485e 100644
--- a/src/Samples/XmlFileLogger/ObjectModel/Build.cs
+++ b/src/Samples/XmlFileLogger/ObjectModel/Build.cs
@@ -182,7 +182,7 @@ public void AddProject(ProjectStartedEventArgs projectStartedEventArgs)
         {
             Project parent = null;
 
-            if (projectStartedEventArgs.ParentProjectBuildEventContext != null && projectStartedEventArgs.ParentProjectBuildEventContext.ProjectContextId >= 0)
+            if (projectStartedEventArgs.ParentProjectBuildEventContext?.ProjectContextId >= 0)
             {
                 parent = GetOrAddProject(projectStartedEventArgs.ParentProjectBuildEventContext.ProjectContextId);
             }
diff --git a/src/Samples/XmlFileLogger/PropertyBag.cs b/src/Samples/XmlFileLogger/PropertyBag.cs
index 7b16f65907b..6346551ff42 100644
--- a/src/Samples/XmlFileLogger/PropertyBag.cs
+++ b/src/Samples/XmlFileLogger/PropertyBag.cs
@@ -134,7 +134,7 @@ public bool TryGetValue(string key, out string value)
                 return true;
             }
 
-            return _parent != null && _parent.TryGetValue(key, out value);
+            return _parent?.TryGetValue(key, out value) == true;
         }
     }
 }
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index ed4b8f3098d..e2cf13588fb 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -234,9 +234,9 @@ OpenBaseKey openBaseKey
                     {
                         using (RegistryKey keyPlatform = baseKey.OpenSubKey(directoryKey.RegistryKey, false))
                         {
-                            if (keyPlatform != null && keyPlatform.ValueCount > 0)
+                            if (keyPlatform?.ValueCount > 0)
                             {
-                                if (platform != null && platform.Length > 0)
+                                if (platform?.Length > 0)
                                 {
                                     string platformValue = keyPlatform.GetValue("Platform", null) as string;
 
@@ -246,7 +246,7 @@ OpenBaseKey openBaseKey
                                     }
                                 }
 
-                                if (osVersion != null && osVersion.Length > 0)
+                                if (osVersion?.Length > 0)
                                 {
                                     Version ver = VersionUtilities.ConvertToVersion(osVersion);
 
@@ -274,7 +274,7 @@ private bool MatchingPlatformExists(string platform, string platformValue)
         {
             bool match = false;
 
-            if (platformValue != null && platformValue.Length > 0)
+            if (platformValue?.Length > 0)
             {
                 string[] platforms = platformValue.Split(MSBuildConstants.SemicolonChar);
                 foreach (string p in platforms)
diff --git a/src/Shared/AssemblyLoadInfo.cs b/src/Shared/AssemblyLoadInfo.cs
index 8284c1a1f5e..e85dc68a2c8 100644
--- a/src/Shared/AssemblyLoadInfo.cs
+++ b/src/Shared/AssemblyLoadInfo.cs
@@ -23,7 +23,7 @@ internal abstract class AssemblyLoadInfo : ITranslatable, IEquatable<AssemblyLoa
         /// </summary>
         internal static AssemblyLoadInfo Create(string assemblyName, string assemblyFile)
         {
-            ErrorUtilities.VerifyThrow(((assemblyName != null) && (assemblyName.Length > 0)) || ((assemblyFile != null) && (assemblyFile.Length > 0)),
+            ErrorUtilities.VerifyThrow(((assemblyName?.Length > 0)) || ((assemblyFile?.Length > 0)),
                 "We must have either the assembly name or the assembly file/path.");
             ErrorUtilities.VerifyThrow((assemblyName == null) || (assemblyFile == null),
                 "We must not have both the assembly name and the assembly file/path.");
diff --git a/src/Shared/AssemblyUtilities.cs b/src/Shared/AssemblyUtilities.cs
index f33454caec0..f4194346f88 100644
--- a/src/Shared/AssemblyUtilities.cs
+++ b/src/Shared/AssemblyUtilities.cs
@@ -153,8 +153,7 @@ private static CultureInfo[] GetValidCultures()
         {
             var cultureTypesType = s_cultureInfoGetCultureMethod?.GetParameters().FirstOrDefault()?.ParameterType;
 
-            ErrorUtilities.VerifyThrow(cultureTypesType != null &&
-                                       cultureTypesType.Name == "CultureTypes" &&
+            ErrorUtilities.VerifyThrow(cultureTypesType?.Name == "CultureTypes" &&
                                        Enum.IsDefined(cultureTypesType, "AllCultures"),
                                        "GetCulture is expected to accept CultureTypes.AllCultures");
 
diff --git a/src/Shared/ErrorUtilities.cs b/src/Shared/ErrorUtilities.cs
index 641980fc490..439a8491f96 100644
--- a/src/Shared/ErrorUtilities.cs
+++ b/src/Shared/ErrorUtilities.cs
@@ -767,7 +767,7 @@ internal static void VerifyThrowArgumentInvalidPath(string parameter, string par
         /// </summary>
         internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName)
         {
-            if (parameter != null && parameter.Length == 0 && s_throwExceptions)
+            if (parameter?.Length == 0 && s_throwExceptions)
             {
                 throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Shared.ParameterCannotHaveZeroLength", parameterName));
             }
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 967e012016b..d722ca81ad1 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -2376,7 +2376,7 @@ private string[] GetFilesImplementation(
                 }
             }
 
-            if (searchesToExclude != null && searchesToExclude.Count == 0)
+            if (searchesToExclude?.Count == 0)
             {
                 searchesToExclude = null;
             }
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index a02cf5c4582..fb02c01a83a 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -637,7 +637,7 @@ internal static string GetDirectory(string fileSpec)
         /// <returns></returns>
         internal static bool HasExtension(string fileName, string[] allowedExtensions)
         {
-            Debug.Assert(allowedExtensions != null && allowedExtensions.Length > 0);
+            Debug.Assert(allowedExtensions?.Length > 0);
 
             // Easiest way to invoke invalid path chars
             // check, which callers are relying on.
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 7b86e274cdf..f8fd0cf699a 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -978,7 +978,7 @@ internal static string RemoveDirectories(string path, int numberOfLevelsToRemove
                 DirectoryInfo fixedPathInfo = new DirectoryInfo(path);
                 for (int i = 0; i < numberOfLevelsToRemove; i++)
                 {
-                    if (fixedPathInfo != null && fixedPathInfo.Parent != null)
+                    if (fixedPathInfo?.Parent != null)
                     {
                         fixedPathInfo = fixedPathInfo.Parent;
                     }
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index 9a04c4f7ea1..128cdec4826 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -128,10 +128,7 @@ override public String ReadString()
 
                     charsRead = _decoder.GetChars(rawBuffer, rawPosition, n, charBuffer, 0);
 
-                    if (memoryStream != null)
-                    {
-                        memoryStream.Seek(readLength, SeekOrigin.Current);
-                    }
+                    memoryStream?.Seek(readLength, SeekOrigin.Current);
 
                     if (currPos == 0 && n == stringLength)
                     {
diff --git a/src/Shared/OutOfProcTaskHostTaskResult.cs b/src/Shared/OutOfProcTaskHostTaskResult.cs
index 03fcc964d2c..c4db64e07b7 100644
--- a/src/Shared/OutOfProcTaskHostTaskResult.cs
+++ b/src/Shared/OutOfProcTaskHostTaskResult.cs
@@ -75,7 +75,7 @@ internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary<string
                     );
             }
 
-            if (exceptionMessageArgs != null && exceptionMessageArgs.Length > 0)
+            if (exceptionMessageArgs?.Length > 0)
             {
                 ErrorUtilities.VerifyThrow(exceptionMessage != null, "If we have message args, we need a message.");
             }
diff --git a/src/Shared/ProjectWriter.cs b/src/Shared/ProjectWriter.cs
index 9a467ad193b..d925f19dea0 100644
--- a/src/Shared/ProjectWriter.cs
+++ b/src/Shared/ProjectWriter.cs
@@ -119,7 +119,7 @@ internal void Initialize(XmlDocument project, XmlDeclaration projectRootElementD
 
             // don't write an XML declaration unless the project already has one or has non-default encoding
             _writeXmlDeclaration = projectRootElementDeclaration != null ||
-                                   _documentEncoding != null && !_documentEncoding.IsUtf8Encoding();
+                                   _documentEncoding?.IsUtf8Encoding() == false;
         }
 
         /// <summary>
diff --git a/src/Shared/RegisteredTaskObjectCacheBase.cs b/src/Shared/RegisteredTaskObjectCacheBase.cs
index 1d8350fd73d..17444232eba 100644
--- a/src/Shared/RegisteredTaskObjectCacheBase.cs
+++ b/src/Shared/RegisteredTaskObjectCacheBase.cs
@@ -60,10 +60,7 @@ public void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifet
         {
             ConcurrentDictionary<object, object> dict = GetCollectionForLifetime(lifetime, dontCreate: false);
 
-            if (dict != null)
-            {
-                dict.TryAdd(key, obj);
-            }
+            dict?.TryAdd(key, obj);
         }
 
         /// <summary>
@@ -73,10 +70,7 @@ public object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime l
         {
             ConcurrentDictionary<object, object> dict = GetCollectionForLifetime(lifetime, dontCreate: true);
             object obj = null;
-            if (dict != null)
-            {
-                dict.TryGetValue(key, out obj);
-            }
+            dict?.TryGetValue(key, out obj);
 
             return obj;
         }
@@ -88,10 +82,7 @@ public object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime life
         {
             ConcurrentDictionary<object, object> dict = GetCollectionForLifetime(lifetime, dontCreate: true);
             object obj = null;
-            if (dict != null)
-            {
-                dict.TryRemove(key, out obj);
-            }
+            dict?.TryRemove(key, out obj);
 
             return obj;
         }
@@ -155,10 +146,7 @@ private static void DisposeObjects(Lazy<ConcurrentDictionary<object, object>> li
                     try
                     {
                         IDisposable disposable = obj as IDisposable;
-                        if (disposable != null)
-                        {
-                            disposable.Dispose();
-                        }
+                        disposable?.Dispose();
                     }
                     catch (Exception ex)
                     {
diff --git a/src/Shared/RegistryHelper.cs b/src/Shared/RegistryHelper.cs
index 49f6e4076dc..53085889348 100644
--- a/src/Shared/RegistryHelper.cs
+++ b/src/Shared/RegistryHelper.cs
@@ -48,7 +48,7 @@ internal static string GetDefaultValue(RegistryKey baseKey, string subkey)
 
             using (RegistryKey key = baseKey.OpenSubKey(subkey))
             {
-                if (key != null && key.ValueCount > 0)
+                if (key?.ValueCount > 0)
                 {
                     value = (string)key.GetValue("");
                 }
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index b380e8f2054..a25cdf34a7d 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -227,7 +227,7 @@ internal static string FormatString(string unformatted, params object[] args)
             string formatted = unformatted;
 
             // NOTE: String.Format() does not allow a null arguments array
-            if ((args != null) && (args.Length > 0))
+            if ((args?.Length > 0))
             {
 #if DEBUG
 
diff --git a/src/Shared/TaskLoader.cs b/src/Shared/TaskLoader.cs
index 620a0aba57a..44483ffef96 100644
--- a/src/Shared/TaskLoader.cs
+++ b/src/Shared/TaskLoader.cs
@@ -181,7 +181,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
         /// </summary>
         internal static Assembly AssemblyResolver(object sender, ResolveEventArgs args)
         {
-            if ((s_resolverLoadedType != null) && (s_resolverLoadedType.LoadedAssembly != null))
+            if ((s_resolverLoadedType?.LoadedAssembly != null))
             {
                 // Match the name being requested by the resolver with the FullName of the assembly we have loaded
                 if (args.Name.Equals(s_resolverLoadedType.LoadedAssembly.FullName, StringComparison.Ordinal))
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 31d299b2737..c383cf1bc1b 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -311,7 +311,7 @@ private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom)
                 IDictionary customMetadata = copyFrom.CloneCustomMetadata();
                 escapedMetadata = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
 
-                if (customMetadata != null && customMetadata.Count > 0)
+                if (customMetadata?.Count > 0)
                 {
                     foreach (string key in customMetadata.Keys)
                     {
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index b7b47a4e20e..afd14f790c9 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1656,7 +1656,7 @@ bool IsRoot(int node)
             {
                 foreach (var nodeDependencies in dependencyEdges)
                 {
-                    if (nodeDependencies.Value != null && nodeDependencies.Value.Contains(node))
+                    if (nodeDependencies.Value?.Contains(node) == true)
                     {
                         return false;
                     }
diff --git a/src/Shared/XmlUtilities.cs b/src/Shared/XmlUtilities.cs
index 103570c4d6e..8edbd1079fc 100644
--- a/src/Shared/XmlUtilities.cs
+++ b/src/Shared/XmlUtilities.cs
@@ -49,11 +49,11 @@ internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation o
                 newElement.AppendChild(oldElement.FirstChild);
             }
 
-            if (oldElement.ParentNode != null)
-            {
+               
+            
                 // Add the new element in the same place the old element was.
-                oldElement.ParentNode.ReplaceChild(newElement, oldElement);
-            }
+                oldElement.ParentNode?.ReplaceChild(newElement, oldElement);
+            
 
             return newElement;
         }
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index 52973541190..18882d1da32 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -1433,7 +1433,7 @@ public void MSBuildTaskPassesTaskIdToSpawnedBuilds()
 
                 var expectedTaskId = logger.TaskStartedEvents.First(t => t.TaskName == "MSBuild").BuildEventContext.TaskId;
                 var actualTaskId = logger.ProjectStartedEvents
-                    .Where(p => p.ParentProjectBuildEventContext != null && p.ParentProjectBuildEventContext.TaskId > 0)
+                    .Where(p => p.ParentProjectBuildEventContext?.TaskId > 0)
                     .First()
                     .ParentProjectBuildEventContext.TaskId;
 
@@ -1469,7 +1469,7 @@ public void CustomTaskWithBuildProjectFilePassesTaskId()
 
                 var expectedTaskId = logger.TaskStartedEvents.First(t => t.TaskName == nameof(BuildProjectFileTask)).BuildEventContext.TaskId;
                 var actualTaskId = logger.ProjectStartedEvents
-                    .Where(p => p.ParentProjectBuildEventContext != null && p.ParentProjectBuildEventContext.TaskId > 0)
+                    .Where(p => p.ParentProjectBuildEventContext?.TaskId > 0)
                     .First()
                     .ParentProjectBuildEventContext.TaskId;
 
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
index 307649ce8b6..6b859de116a 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResourceOutOfProc_Tests.cs
@@ -626,8 +626,8 @@ public void NothingOutOfDateExceptAdditionalInput()
             {
                 if (resxFile != null) File.Delete(resxFile);
                 if (resourcesFile != null) File.Delete(resourcesFile);
-                if (additionalInputs != null && additionalInputs[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
-                if (additionalInputs != null && additionalInputs[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
+                if (additionalInputs?[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
+                if (additionalInputs?[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
             }
         }
 
@@ -1511,7 +1511,7 @@ public void InvalidReference()
                 Assert.False(result);
 
                 // Should have not written any files
-                Assert.True(t.FilesWritten != null && t.FilesWritten.Length == 0);
+                Assert.True(t.FilesWritten?.Length == 0);
                 Assert.False(File.Exists(resourcesFile));
             }
             finally
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index b3c46b3889b..47e49c2abf1 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -890,8 +890,8 @@ public void NothingOutOfDateExceptAdditionalInput()
             {
                 if (resxFile != null) File.Delete(resxFile);
                 if (resourcesFile != null) File.Delete(resourcesFile);
-                if (additionalInputs != null && additionalInputs[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
-                if (additionalInputs != null && additionalInputs[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
+                if (additionalInputs?[0] != null && File.Exists(additionalInputs[0].ItemSpec)) File.Delete(additionalInputs[0].ItemSpec);
+                if (additionalInputs?[1] != null && File.Exists(additionalInputs[1].ItemSpec)) File.Delete(additionalInputs[1].ItemSpec);
             }
         }
 
@@ -1882,7 +1882,7 @@ public void InvalidReference()
                 Assert.False(result);
 
                 // Should have not written any files
-                Assert.True(t.FilesWritten != null && t.FilesWritten.Length == 0);
+                Assert.True(t.FilesWritten?.Length == 0);
                 Assert.False(File.Exists(resourcesFile));
             }
             finally
@@ -3498,7 +3498,7 @@ public static void ExecuteTask(GenerateResource t)
             bool success = t.Execute();
             Assert.True(success);
 
-            if (t.OutputResources != null && t.OutputResources[0] != null && t.Sources[0] != null)
+            if (t.OutputResources?[0] != null && t.Sources[0] != null)
             {
                 File.GetLastWriteTime(t.OutputResources[0].ItemSpec).ShouldBeGreaterThanOrEqualTo(File.GetLastWriteTime(t.Sources[0].ItemSpec), $"we're talking here about {t.OutputResources[0].ItemSpec} and {t.Sources[0].ItemSpec}");
             }
diff --git a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
index e361f78e0ed..098d1a23603 100644
--- a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
@@ -97,7 +97,7 @@ internal static AssemblyNameExtension GetHighestVersionInRedist(InstalledAssembl
                     var current = new AssemblyNameExtension(a.FullName);
 
                     // If the current version is higher than the previously looked at.
-                    if (current.Version != null && current.Version.CompareTo(assemblyNameToUse.Version) > 0)
+                    if (current.Version?.CompareTo(assemblyNameToUse.Version) > 0)
                     {
                         // Only compare the Culture and the public key token, the simple names will ALWAYS be the same and the version we do not care about.
                         if (assemblyName.PartialNameCompare(current, PartialComparisonFlags.Culture | PartialComparisonFlags.PublicKeyToken))
diff --git a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
index 567e98ca889..84b72957e37 100644
--- a/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
+++ b/src/Tasks/AssemblyDependency/GenerateBindingRedirects.cs
@@ -351,7 +351,7 @@ private XDocument LoadAppConfig(ITaskItem appConfigItem)
         /// </summary>
         private IDictionary<AssemblyName, string> ParseSuggestedRedirects()
         {
-            ErrorUtilities.VerifyThrow(SuggestedRedirects != null && SuggestedRedirects.Length > 0, "This should not be called if there is no suggested redirect.");
+            ErrorUtilities.VerifyThrow(SuggestedRedirects?.Length > 0, "This should not be called if there is no suggested redirect.");
 
             var map = new Dictionary<AssemblyName, string>();
             foreach (var redirect in SuggestedRedirects)
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index 69e0aeeea4f..758333718bb 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -884,7 +884,7 @@ string executableExtension
             _primarySourceItem = sourceItem;
             SDKName = sourceItem.GetMetadata("SDKName");
 
-            if (executableExtension != null && executableExtension.Length > 0)
+            if (executableExtension?.Length > 0)
             {
                 // Set the expected extension.
                 SetExecutableExtension(executableExtension);
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 344c40c092d..f3ba04eefb3 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -542,7 +542,7 @@ ITaskItem referenceAssemblyName
             // Figure out the specific version value.
             bool wantSpecificVersion = MetadataConversionUtilities.TryConvertItemMetadataToBool(referenceAssemblyName, ItemMetadataNames.specificVersion, out bool foundSpecificVersionMetadata);
 
-            bool isSimpleName = (assemblyName != null && assemblyName.IsSimpleName);
+            bool isSimpleName = (assemblyName?.IsSimpleName == true);
 
             // Create the reference.
             var reference = new Reference(_isWinMDFile, _fileExists, _getRuntimeVersion);
@@ -1008,7 +1008,7 @@ out FrameworkName frameworkName
 
             var dependencies = new List<AssemblyNameExtension>(dependentAssemblies?.Length ?? 0);
 
-            if (dependentAssemblies != null && dependentAssemblies.Length > 0)
+            if (dependentAssemblies?.Length > 0)
             {
                 // Re-map immediately so that to the sytem we actually got the remapped version when reading the manifest.
                 for (int i = 0; i < dependentAssemblies.Length; i++)
@@ -1390,7 +1390,7 @@ internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, strin
                     ICollection<ITaskItem> dependees = assemblyReference.GetSourceItems();
 
                     // Need to deal with dependencies, this can also include primary references who are dependencies themselves and are in the black list
-                    if (!assemblyReference.IsPrimary || (assemblyReference.IsPrimary && isMarkedForExclusion && (dependees != null && dependees.Count > 1)))
+                    if (!assemblyReference.IsPrimary || (assemblyReference.IsPrimary && isMarkedForExclusion && (dependees?.Count > 1)))
                     {
                         // Does the assembly have specific version true, or does any of its primary parent references have specific version true.
                         // This is checked because, if an assembly is in the black list, the only way it can possibly be allowed is if
@@ -1865,7 +1865,7 @@ out List<AssemblyNameReference> conflictingReferences
                     }
 
                     byte[] pkt = assemblyName.GetPublicKeyToken();
-                    if (pkt != null && pkt.Length > 0)
+                    if (pkt?.Length > 0)
                     {
                         AssemblyName baseKey = assemblyName.AssemblyName.CloneIfPossible();
                         Version version = baseKey.Version;
@@ -2005,7 +2005,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
 
                         // The latestTargetFrameworkDirectories can be passed into RAR, if they are then use those directories rather than 
                         // getting a list by looking at the file system.
-                        if (_latestTargetFrameworkDirectories != null && _latestTargetFrameworkDirectories.Length > 0)
+                        if (_latestTargetFrameworkDirectories?.Length > 0)
                         {
                             referenceAssemblyDirectories = new List<string>(_latestTargetFrameworkDirectories);
                             otherFrameworkName = String.Join(";", _latestTargetFrameworkDirectories);
@@ -2019,7 +2019,7 @@ private Tuple<RedistList, string> GetHighestVersionFullFrameworkForTFM(Framework
                             }
                         }
 
-                        if (referenceAssemblyDirectories != null && referenceAssemblyDirectories.Count > 0)
+                        if (referenceAssemblyDirectories?.Count > 0)
                         {
                             var seenFrameworkDirectories = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                             var assemblyTableInfos = new List<AssemblyTableInfo>();
@@ -2586,7 +2586,7 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 referenceItem.SetMetadata(ItemMetadataNames.redist, reference.RedistName);
             }
 
-            if (Reference.IsFrameworkFile(reference.FullPath, _frameworkPaths) || (_installedAssemblies != null && _installedAssemblies.FrameworkAssemblyEntryInRedist(assemblyName)))
+            if (Reference.IsFrameworkFile(reference.FullPath, _frameworkPaths) || (_installedAssemblies?.FrameworkAssemblyEntryInRedist(assemblyName) == true))
             {
                 if (!IsAssemblyRemovedFromDotNetFramework(assemblyName, reference.FullPath, _frameworkPaths, _installedAssemblies))
                 {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 61e2a6a93e5..5da91218b40 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1426,7 +1426,7 @@ private void LogInputs()
         private void LogAttribute(ITaskItem item, string metadataName)
         {
             string metadataValue = item.GetMetadata(metadataName);
-            if (metadataValue != null && metadataValue.Length > 0)
+            if (metadataValue?.Length > 0)
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.EightSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.LogAttributeFormat", metadataName, metadataValue));
             }
@@ -1972,7 +1972,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     InstalledAssemblies installedAssemblies = null;
                     RedistList redistList = null;
 
-                    if (installedAssemblyTableInfo != null && installedAssemblyTableInfo.Length > 0)
+                    if (installedAssemblyTableInfo?.Length > 0)
                     {
                         redistList = RedistList.GetRedistList(installedAssemblyTableInfo);
                     }
@@ -1989,7 +1989,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     List<string> whiteListErrorFilesNames = new List<string>();
 
                     // Check for partial success in GetRedistList and log any tolerated exceptions.
-                    if (redistList != null && redistList.Count > 0 || targetingProfile || ShouldUseSubsetBlackList())
+                    if (redistList?.Count > 0 || targetingProfile || ShouldUseSubsetBlackList())
                     {
                         // If we are not targeting a dev 10 profile and we have the required components to generate a orcas style subset, do so
                         if (!targetingProfile && ShouldUseSubsetBlackList())
@@ -1997,7 +1997,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             // Based in the target framework subset names find the paths to the files
                             SubsetListFinder whiteList = new SubsetListFinder(_targetFrameworkSubsets);
                             whiteListSubsetTableInfo = GetInstalledAssemblyTableInfo(IgnoreDefaultInstalledAssemblySubsetTables, InstalledAssemblySubsetTables, new GetListPath(whiteList.GetSubsetListPathsFromDisk), TargetFrameworkDirectories);
-                            if (whiteListSubsetTableInfo.Length > 0 && (redistList != null && redistList.Count > 0))
+                            if (whiteListSubsetTableInfo.Length > 0 && (redistList?.Count > 0))
                             {
                                 blackList = redistList.GenerateBlackList(whiteListSubsetTableInfo, whiteListErrors, whiteListErrorFilesNames);
                             }
@@ -2041,7 +2041,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                             }
                         }
 
-                        if (redistList != null && redistList.Count > 0)
+                        if (redistList?.Count > 0)
                         {
                             installedAssemblies = new InstalledAssemblies(redistList);
                         }
@@ -2181,7 +2181,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         try
                         {
                             excludedReferencesExist = false;
-                            if (redistList != null && redistList.Count > 0)
+                            if (redistList?.Count > 0)
                             {
                                 excludedReferencesExist = dependencyTable.MarkReferencesForExclusion(blackList);
                             }
@@ -2220,7 +2220,7 @@ out autoUnifiedRemappedAssemblyReferences
                         try
                         {
                             excludedReferencesExist = false;
-                            if (redistList != null && redistList.Count > 0)
+                            if (redistList?.Count > 0)
                             {
                                 excludedReferencesExist = dependencyTable.MarkReferencesForExclusion(blackList);
                             }
@@ -2427,7 +2427,7 @@ out _copyLocalFiles
         private AssemblyNameExtension[] GetDependencies(Reference resolvedReference, FileExists fileExists, GetAssemblyMetadata getAssemblyMetadata, ConcurrentDictionary<string, AssemblyMetadata> assemblyMetadataCache)
         {
             AssemblyNameExtension[] result = null;
-            if (resolvedReference != null && resolvedReference.IsPrimary && !resolvedReference.IsBadImage)
+            if (resolvedReference?.IsPrimary == true && !resolvedReference.IsBadImage)
             {
                 System.Runtime.Versioning.FrameworkName frameworkName = null;
                 string[] scatterFiles = null;
@@ -2793,7 +2793,7 @@ private AssemblyTableInfo[] GetInstalledAssemblyTableInfo(bool ignoreInstalledAs
 
                 if (String.IsNullOrEmpty(frameworkDirectory))
                 {
-                    if (TargetFrameworkDirectories != null && TargetFrameworkDirectories.Length == 1)
+                    if (TargetFrameworkDirectories?.Length == 1)
                     {
                         // Exactly one TargetFrameworkDirectory, so assume it's related to this
                         // InstalledAssemblyTable.
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index 7cbbcefaa82..06286525f43 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -178,7 +178,7 @@ ResolutionSearchLocation searchLocation
                 }
             }
 
-            bool isSimpleAssemblyName = assemblyName != null && assemblyName.IsSimpleName;
+            bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;
 
             if (fileExists(pathToCandidateAssembly))
             {
@@ -241,8 +241,8 @@ ResolutionSearchLocation searchLocation
                         }
                     }
 
-                    bool matchedSpecificVersion = (wantSpecificVersion && assemblyName != null && assemblyName.Equals(targetAssemblyName));
-                    bool matchPartialName = !wantSpecificVersion && assemblyName != null && assemblyName.PartialNameCompare(targetAssemblyName);
+                    bool matchedSpecificVersion = (wantSpecificVersion && assemblyName?.Equals(targetAssemblyName) == true);
+                    bool matchPartialName = !wantSpecificVersion && assemblyName?.PartialNameCompare(targetAssemblyName) == true;
 
                     if (matchedSpecificVersion || matchPartialName)
                     {
@@ -348,7 +348,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                             AssemblyNameExtension foundAssembly = getAssemblyName(fullPath);
 
                             // If the processor architecture does not match the we should continue to see if there is a better match.
-                            if (foundAssembly != null && foundAssembly.AssemblyName.ProcessorArchitecture == ProcessorArchitecture.MSIL)
+                            if (foundAssembly?.AssemblyName.ProcessorArchitecture == ProcessorArchitecture.MSIL)
                             {
                                 return fullPath;
                             }
diff --git a/src/Tasks/AssignProjectConfiguration.cs b/src/Tasks/AssignProjectConfiguration.cs
index 7c4f8841a24..d69c23af424 100644
--- a/src/Tasks/AssignProjectConfiguration.cs
+++ b/src/Tasks/AssignProjectConfiguration.cs
@@ -43,7 +43,7 @@ public string DefaultToVcxPlatformMapping
             set
             {
                 _defaultToVcxPlatformMapping = value;
-                if (_defaultToVcxPlatformMapping != null && _defaultToVcxPlatformMapping.Length == 0)
+                if (_defaultToVcxPlatformMapping?.Length == 0)
                 {
                     _defaultToVcxPlatformMapping = null;
                 }
@@ -83,7 +83,7 @@ public string VcxToDefaultPlatformMapping
             {
                 _vcxToDefaultPlatformMapping = value;
 
-                if (_vcxToDefaultPlatformMapping != null && _vcxToDefaultPlatformMapping.Length == 0)
+                if (_vcxToDefaultPlatformMapping?.Length == 0)
                 {
                     _vcxToDefaultPlatformMapping = null;
                 }
diff --git a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
index 036f9aee7d7..ad86917f67c 100644
--- a/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
+++ b/src/Tasks/BootstrapperUtil/BootstrapperBuilder.cs
@@ -2092,7 +2092,7 @@ private bool AddVerificationInformation(XmlNode packageFileNode, string fileSour
                     }
 
                     // If the public key in the file doesn't match the public key on disk, issue a build warning
-                    if (publicKey == null || !publicKey.ToLowerInvariant().Equals(publicKeyAttribute.Value.ToLowerInvariant()))
+                    if (publicKey?.ToLowerInvariant().Equals(publicKeyAttribute.Value.ToLowerInvariant()) != true)
                     {
                         results?.AddMessage(BuildMessage.CreateMessage(BuildMessageSeverity.Warning, "GenerateBootstrapper.DifferingPublicKeys", PUBLICKEY_ATTRIBUTE, builder.Name, fileSource));
                     }
diff --git a/src/Tasks/BootstrapperUtil/Product.cs b/src/Tasks/BootstrapperUtil/Product.cs
index 93fd74ef4ae..542b9749106 100644
--- a/src/Tasks/BootstrapperUtil/Product.cs
+++ b/src/Tasks/BootstrapperUtil/Product.cs
@@ -213,7 +213,7 @@ internal XmlValidationResults GetPackageValidationResults(string culture)
             return ValidationResults?.PackageResults(culture);
         }
 
-        internal bool ValidationPassed => ValidationResults == null || ValidationResults.ValidationPassed;
+        internal bool ValidationPassed => ValidationResults?.ValidationPassed != false;
 
         internal ProductValidationResults ValidationResults { get; }
     }
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index 8c9c1718c32..a735ccbbb24 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -452,7 +452,7 @@ internal static bool GetPathOfTypeLib(TaskLoggingHelper log, bool silent, ref TY
                 return false;
             }
 
-            if (typeLibPath != null && typeLibPath.Length > 0)
+            if (typeLibPath?.Length > 0)
             {
                 // We have to check for NULL here because QueryPathOfRegTypeLib() returns
                 // a BSTR with a NULL character appended to it.
diff --git a/src/Tasks/Culture.cs b/src/Tasks/Culture.cs
index 30b61bd2c5b..7c7e4722609 100644
--- a/src/Tasks/Culture.cs
+++ b/src/Tasks/Culture.cs
@@ -57,7 +57,7 @@ string dependentUponFilename
 
                 // See if this is a valid culture name.
                 bool validCulture = false;
-                if ((cultureName != null) && (cultureName.Length > 1))
+                if ((cultureName?.Length > 1))
                 {
                     // ... strip the "." to make "en-US"
                     cultureName = cultureName.Substring(1);
diff --git a/src/Tasks/DependencyFile.cs b/src/Tasks/DependencyFile.cs
index 67b4b936a7c..f8306894c3b 100644
--- a/src/Tasks/DependencyFile.cs
+++ b/src/Tasks/DependencyFile.cs
@@ -79,7 +79,7 @@ internal bool HasFileChanged()
             FileInfo info = FileUtilities.GetFileInfoNoThrow(filename);
 
             // Obviously if the file no longer exists then we are not up to date.
-            if (info == null || !info.Exists)
+            if (info?.Exists != true)
             {
                 return true;
             }
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index cb87f14e533..10f9e7cc7cb 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -1391,7 +1391,7 @@ private void GetResourcesToProcess(out List<ITaskItem> inputsToProcess, out List
                     // However, our cache will sometimes record all the info we need (for incremental builds).
                     string sourceFileName = Sources[i].ItemSpec;
                     ResGenDependencies.PortableLibraryFile library = _cache.TryGetPortableLibraryInfo(sourceFileName);
-                    if (library != null && library.AllOutputFilesAreUpToDate())
+                    if (library?.AllOutputFilesAreUpToDate() == true)
                     {
                         AppendCachedOutputTaskItems(library, cachedOutputFiles);
                     }
@@ -2160,7 +2160,7 @@ private void RecordFilesWritten()
             }
 
             // Add any state file
-            if (StateFile != null && StateFile.ItemSpec.Length > 0)
+            if (StateFile?.ItemSpec.Length > 0)
             {
                 // It's possible the file wasn't actually written (eg the path was invalid)
                 // We can't easily tell whether that happened here, and I think it's fine to add it anyway.
@@ -2431,7 +2431,7 @@ internal void Run(
 #if !FEATURE_ASSEMBLYLOADCONTEXT
             // If references were passed in, we will have to give the ResxResourceReader an object
             // by which it can resolve types that are referenced from within the .RESX.
-            if ((_assemblyFiles != null) && (_assemblyFiles.Length > 0))
+            if ((_assemblyFiles?.Length > 0))
             {
                 _typeResolver = new AssemblyNamesTypeResolutionService(_assemblyFiles);
             }
diff --git a/src/Tasks/GenerateTrustInfo.cs b/src/Tasks/GenerateTrustInfo.cs
index a8e07666114..7a922908366 100644
--- a/src/Tasks/GenerateTrustInfo.cs
+++ b/src/Tasks/GenerateTrustInfo.cs
@@ -65,7 +65,7 @@ public override bool Execute()
             {
                 // If it's a known zone and the user add additional permission to it.
                 if (!String.IsNullOrEmpty(TargetZone)
-                    && trustInfo.PermissionSet != null && trustInfo.PermissionSet.Count > 0
+                    && trustInfo.PermissionSet?.Count > 0
                     && !String.Equals(TargetZone, Custom, StringComparison.OrdinalIgnoreCase))
                 {
                     Log.LogErrorFromResources("GenerateManifest.KnownTargetZoneCannotHaveAdditionalPermissionType");
diff --git a/src/Tasks/GetInstalledSDKLocations.cs b/src/Tasks/GetInstalledSDKLocations.cs
index 880a2f62f0b..e5e8195e1f8 100644
--- a/src/Tasks/GetInstalledSDKLocations.cs
+++ b/src/Tasks/GetInstalledSDKLocations.cs
@@ -149,7 +149,7 @@ public override bool Execute()
 
             var outputItems = new List<ITaskItem>();
 
-            if (installedSDKs != null && installedSDKs.Count > 0)
+            if (installedSDKs?.Count > 0)
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "GetInstalledSDKs.FoundSDKs", installedSDKs.Count);
                 Log.LogMessageFromResources(MessageImportance.Low, "GetInstalledSDKs.ListInstalledSDKs");
diff --git a/src/Tasks/GetReferenceAssemblyPaths.cs b/src/Tasks/GetReferenceAssemblyPaths.cs
index e5201d9b62b..408bf6f3435 100644
--- a/src/Tasks/GetReferenceAssemblyPaths.cs
+++ b/src/Tasks/GetReferenceAssemblyPaths.cs
@@ -192,7 +192,7 @@ public override bool Execute()
             {
                 _tfmPaths = GetPaths(RootPath, TargetFrameworkFallbackSearchPaths, moniker);
 
-                if (_tfmPaths != null && _tfmPaths.Count > 0)
+                if (_tfmPaths?.Count > 0)
                 {
                     TargetFrameworkMonikerDisplayName = ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(_tfmPaths[0], moniker);
                 }
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index 4393c520267..b94162dc7bb 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -367,7 +367,7 @@ private void FindReferences(ITaskItem resolvedSDKReference, string sdkIdentity,
                 // If the SDK is manifest driven we want to grab them from the ApiContracts in the manifest if possible- will only happen if TargetSdk is identified
                 string[] manifestReferencePaths = GetReferencePathsFromManifest(resolvedSDKReference);
 
-                if (manifestReferencePaths != null && manifestReferencePaths.Length > 0)
+                if (manifestReferencePaths?.Length > 0)
                 {
                     // Found ApiContract references, use those
                     foreach (string manifestReferencePath in manifestReferencePaths)
@@ -481,7 +481,7 @@ private void GenerateOutputItems()
                             outputItem.SetMetadata(ItemMetadataNames.imageRuntime, referenceInfo.ImageRuntime);
                         }
 
-                        if (referenceInfo != null && referenceInfo.IsWinMD)
+                        if (referenceInfo?.IsWinMD == true)
                         {
                             outputItem.SetMetadata(ItemMetadataNames.winMDFile, "true");
 
@@ -1011,7 +1011,7 @@ internal SDKInfo GetCacheFileInfoFromSDK(string sdkRootDirectory, string[] sdkMa
                 directoriesToHash.AddRange(referenceDirectories);
                 directoriesToHash.AddRange(redistDirectories);
 
-                if (sdkManifestReferences != null && sdkManifestReferences.Length > 0)
+                if (sdkManifestReferences?.Length > 0)
                 {
                     // Manifest driven- get the info from the known list
                     PopulateReferencesDictionaryFromManifestPaths(directoryToFileList, references, sdkManifestReferences);
diff --git a/src/Tasks/Hash.cs b/src/Tasks/Hash.cs
index 241235d223b..c822fa90f90 100644
--- a/src/Tasks/Hash.cs
+++ b/src/Tasks/Hash.cs
@@ -42,7 +42,7 @@ public class Hash : TaskExtension
         /// </summary>
         public override bool Execute()
         {
-            if (ItemsToHash != null && ItemsToHash.Length > 0)
+            if (ItemsToHash?.Length > 0)
             {
                 using (var sha1 = SHA1.Create())
                 {
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index 88abe02d007..de2da27930b 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -199,7 +199,7 @@ public override bool Execute()
             }
 
             // We have been asked to unescape all escaped characters before processing
-            if (TargetAndPropertyListSeparators != null && TargetAndPropertyListSeparators.Length > 0)
+            if (TargetAndPropertyListSeparators?.Length > 0)
             {
                 ExpandAllTargetsAndProperties();
             }
diff --git a/src/Tasks/ManifestUtil/ApplicationManifest.cs b/src/Tasks/ManifestUtil/ApplicationManifest.cs
index 655ac5b8e9b..682b5adb2b1 100644
--- a/src/Tasks/ManifestUtil/ApplicationManifest.cs
+++ b/src/Tasks/ManifestUtil/ApplicationManifest.cs
@@ -705,7 +705,7 @@ private void ValidateReferenceForPartialTrust(AssemblyReference assembly, TrustI
             }
             else
             {
-                if (assembly.AssemblyIdentity != null && assembly.AssemblyIdentity.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion))
+                if (assembly.AssemblyIdentity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
                 {
                     // if the binary is targeting v4.0 and it has the transparent attribute then we may allow partially trusted callers.
                     if (assembly.IsPrimary
diff --git a/src/Tasks/ManifestUtil/AssemblyIdentity.cs b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
index 0c09b3e58d9..8f50a5387fd 100644
--- a/src/Tasks/ManifestUtil/AssemblyIdentity.cs
+++ b/src/Tasks/ManifestUtil/AssemblyIdentity.cs
@@ -404,7 +404,7 @@ public bool IsInFramework(string frameworkIdentifier, string frameworkVersion)
             string fullName = GetFullName(FullNameFlags.Default);
             foreach (RedistList list in redistDictionary.Values)
             {
-                if (list != null && list.IsFrameworkAssembly(fullName))
+                if (list?.IsFrameworkAssembly(fullName) == true)
                 {
                     return true;
                 }
diff --git a/src/Tasks/ManifestUtil/DeployManifest.cs b/src/Tasks/ManifestUtil/DeployManifest.cs
index da358580c54..acc18057312 100644
--- a/src/Tasks/ManifestUtil/DeployManifest.cs
+++ b/src/Tasks/ManifestUtil/DeployManifest.cs
@@ -137,7 +137,7 @@ private static FrameworkNameVersioning GetInstallableFrameworkName(FrameworkName
 
             IList<string> referenceAssemblyPaths = GetPathToReferenceAssemblies(frameworkName);
 
-            if (referenceAssemblyPaths != null && referenceAssemblyPaths.Count > 0)
+            if (referenceAssemblyPaths?.Count > 0)
             {
                 // the first one in the list is the reference assembly path for the requested TFM
                 string referenceAssemblyPath = referenceAssemblyPaths[0];
@@ -411,7 +411,7 @@ public string MinimumRequiredVersion
         internal override void OnAfterLoad()
         {
             base.OnAfterLoad();
-            if (_entryPoint == null && AssemblyReferences != null && AssemblyReferences.Count > 0)
+            if (_entryPoint == null && AssemblyReferences?.Count > 0)
             {
                 _entryPoint = AssemblyReferences[0];
                 _entryPoint.ReferenceType = AssemblyReferenceType.ClickOnceManifest;
@@ -594,8 +594,7 @@ private void ValidateEntryPoint()
                         }
                         else
                         {
-                            if (entryPointManifest.FileAssociations != null &&
-                                entryPointManifest.FileAssociations.Count > 0)
+                            if (entryPointManifest.FileAssociations?.Count > 0)
                             {
                                 OutputMessages.AddErrorMessage("GenerateManifest.FileAssociationsNotInstalled");
                             }
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index e5a0d7aa194..ba4d3ba6c57 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -252,7 +252,7 @@ private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequested
                     //  keep the default null value which means we will not create one in the
                     //  output document)
                     //
-                    if (previousNode != null && previousNode.NodeType == XmlNodeType.Comment)
+                    if (previousNode?.NodeType == XmlNodeType.Comment)
                     {
                         commentString = ((XmlComment)previousNode).Data;
                     }
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 9bc15d0aed2..8891ba4d25d 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -165,7 +165,7 @@ public bool IsFrameworkAssembly(string assemblyName)
         public bool IsPrerequisiteAssembly(string assemblyName)
         {
             AssemblyEntry entry = GetUnifiedAssemblyEntry(assemblyName);
-            return entry != null && entry.InGAC;
+            return entry?.InGAC == true;
         }
 
         /// <summary>
diff --git a/src/Tasks/RegisterAssembly.cs b/src/Tasks/RegisterAssembly.cs
index ecd34871a69..3fdf14ffd43 100644
--- a/src/Tasks/RegisterAssembly.cs
+++ b/src/Tasks/RegisterAssembly.cs
@@ -72,7 +72,7 @@ public override bool Execute()
 
             AssemblyRegistrationCache cacheFile = null;
 
-            if ((AssemblyListFile != null) && (AssemblyListFile.ItemSpec.Length > 0))
+            if ((AssemblyListFile?.ItemSpec.Length > 0))
             {
                 cacheFile = (AssemblyRegistrationCache)StateFileBase.DeserializeCache(AssemblyListFile.ItemSpec, Log, typeof(AssemblyRegistrationCache)) ??
                             new AssemblyRegistrationCache();
@@ -89,7 +89,7 @@ public override bool Execute()
                         string tlbPath;
 
                         // if the type lib path is not supplied, generate default one
-                        if ((TypeLibFiles[i] != null) && (TypeLibFiles[i].ItemSpec.Length > 0))
+                        if ((TypeLibFiles[i]?.ItemSpec.Length > 0))
                         {
                             tlbPath = TypeLibFiles[i].ItemSpec;
                         }
diff --git a/src/Tasks/ResGen.cs b/src/Tasks/ResGen.cs
index 08df15001b4..05271ec7b9d 100644
--- a/src/Tasks/ResGen.cs
+++ b/src/Tasks/ResGen.cs
@@ -577,7 +577,7 @@ private void GenerateResGenCommands(CommandLineBuilderExtension resGenArguments,
                     resGenArguments.AppendSwitch("/compile" + (useForResponseFile ? "\n" : String.Empty));
 
                     // append the resources to compile
-                    if (InputFiles != null && InputFiles.Length > 0)
+                    if (InputFiles?.Length > 0)
                     {
                         ITaskItem[] inputFiles = InputFiles;
                         ITaskItem[] outputFiles = OutputFiles;
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index e174d3e8f0d..a0bf071da6d 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -132,7 +132,7 @@ internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath)
 
             // The file is in our cache.  Make sure it's up to date.  If not, discard
             // this entry from the cache and rebuild all the state at a later point.
-            if (retVal != null && retVal.HasFileChanged())
+            if (retVal?.HasFileChanged() == true)
             {
                 portableLibraries.RemoveDependencyFile(libraryPath);
                 _isDirty = true;
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 63fef7d822d..b7d1ffcb42c 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -327,7 +327,7 @@ public override bool Execute()
 
             _timestampCache = (ResolveComReferenceCache)StateFileBase.DeserializeCache(StateFile, Log, typeof(ResolveComReferenceCache));
 
-            if (_timestampCache == null || (_timestampCache != null && !_timestampCache.ToolPathsMatchCachePaths(_tlbimpPath, _aximpPath)))
+            if (_timestampCache == null || (_timestampCache?.ToolPathsMatchCachePaths(_tlbimpPath, _aximpPath) == false))
             {
                 if (!Silent)
                 {
@@ -442,7 +442,7 @@ public override bool Execute()
             }
             finally
             {
-                if ((_timestampCache != null) && _timestampCache.Dirty)
+                if ((_timestampCache?.Dirty == true))
                 {
                     _timestampCache.SerializeCache(StateFile, Log);
                 }
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 3b10b04bd42..8c657f606dc 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -630,7 +630,7 @@ private bool IsFiltered(ITaskItem item)
                 return true;
             }
 
-            if (identity != null && identity.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion))
+            if (identity?.IsInFramework(Constants.DotNetFrameworkIdentifier, TargetFrameworkVersion) == true)
             {
                 return true;
             }
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index 85618b0140b..63b25008500 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -1381,7 +1381,7 @@ private void CreateResolvedReferenceItem(string targetConfiguration, string targ
 
                                 // If we have not seen this architecture before (and it has a compatible configuration with what we are targeting) then add it. 
                                 // Also, replace the entry if we have already added an entry for a non configuration specific entry and we now have a configuration specific entry that matches what we are targeting.
-                                if ((configurationComponent == null && !containsKey) || (configurationComponent != null && configurationComponent.Equals(sdkConfiguration, StringComparison.OrdinalIgnoreCase)))
+                                if ((configurationComponent == null && !containsKey) || (configurationComponent?.Equals(sdkConfiguration, StringComparison.OrdinalIgnoreCase) == true))
                                 {
                                     AddStatusMessage("ResolveSDKReference.FoundAppxLocation", appxLocation.Key + "=" + appxLocation.Value);
 
diff --git a/src/Tasks/System.Design.cs b/src/Tasks/System.Design.cs
index ff9adc9c4b8..ebafca295e8 100644
--- a/src/Tasks/System.Design.cs
+++ b/src/Tasks/System.Design.cs
@@ -135,12 +135,12 @@ public static string GetString(string name, params object[] args)
                 return null;
             string res = sys._resources.GetString(name, SR.Culture);
 
-            if (args != null && args.Length > 0)
+            if (args?.Length > 0)
             {
                 for (int i = 0; i < args.Length; i++)
                 {
                     String value = args[i] as String;
-                    if (value != null && value.Length > 1024)
+                    if (value?.Length > 1024)
                     {
                         args[i] = value.Substring(0, 1024 - 3) + "...";
                     }
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 928fb7aecce..cd83dcd6497 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -78,7 +78,7 @@ public override bool Execute()
                 for (int i = 0; i < Assemblies.Length; i++)
                 {
                     // if the type lib path is not supplied, generate default one
-                    if (TypeLibFiles != null && TypeLibFiles[i] != null && TypeLibFiles[i].ItemSpec.Length > 0)
+                    if (TypeLibFiles != null && TypeLibFiles[i]?.ItemSpec.Length > 0)
                     {
                         cacheFile.AddEntry(Assemblies[i].ItemSpec, TypeLibFiles[i].ItemSpec);
                     }
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index e99eb57997d..3e1f9e5d32f 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -387,7 +387,7 @@ private bool ParseParameter(XamlTypes.BaseProperty baseProperty, LinkedList<Prop
                 propertyToAdd.Arguments.Add(arg);
             }
 
-            if (argumentDependencyLookup != null && !argumentDependencyLookup.ContainsKey(propertyToAdd.Name))
+            if (argumentDependencyLookup?.ContainsKey(propertyToAdd.Name) == false)
             {
                 argumentDependencyLookup.Add(propertyToAdd.Name, propertyToAdd);
             }
diff --git a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
index 77964a82a4e..20a4c6a510c 100644
--- a/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
+++ b/src/Utilities.UnitTests/ProcessorArchitecture_Tests.cs
@@ -73,7 +73,7 @@ public void ValidateConvertDotNetFrameworkArchitectureToProcessorArchitecture()
                     procArchitecture = ToolLocationHelper.ConvertDotNetFrameworkArchitectureToProcessorArchitecture(Utilities.DotNetFrameworkArchitecture.Bitness64);
 
                     //We should also allow NULL if the machine is true x86 only.
-                    bool isValidResult = procArchitecture == null || procArchitecture.Equals(ProcessorArchitecture.AMD64) || procArchitecture.Equals(ProcessorArchitecture.IA64);
+                    bool isValidResult = procArchitecture?.Equals(ProcessorArchitecture.AMD64) != false || procArchitecture.Equals(ProcessorArchitecture.IA64);
 
                     isValidResult.ShouldBeTrue();
                     break;
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index 45f8705a621..c1a5bf65964 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -717,17 +717,11 @@ public void TestGetPathToBuildToolsFile()
         {
             string net20Path = ToolLocationHelper.GetPathToDotNetFrameworkFile("MSBuild.exe", TargetDotNetFrameworkVersion.Version20);
 
-            if (net20Path != null)
-            {
-                net20Path.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "2.0"));
-            }
+            net20Path?.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "2.0"));
 
             string net35Path = ToolLocationHelper.GetPathToDotNetFrameworkFile("MSBuild.exe", TargetDotNetFrameworkVersion.Version35);
 
-            if (net35Path != null)
-            {
-                net35Path.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "3.5"));
-            }
+            net35Path?.ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "3.5"));
 
             ToolLocationHelper.GetPathToDotNetFrameworkFile("MSBuild.exe", TargetDotNetFrameworkVersion.Version40).ShouldBe(ToolLocationHelper.GetPathToBuildToolsFile("MSBuild.exe", "4.0"));
 
diff --git a/src/Utilities/CommandLineBuilder.cs b/src/Utilities/CommandLineBuilder.cs
index 64c4bf0430a..259b7ebd4c9 100644
--- a/src/Utilities/CommandLineBuilder.cs
+++ b/src/Utilities/CommandLineBuilder.cs
@@ -401,7 +401,7 @@ public void AppendFileNamesIfNotNull(string[] fileNames, string delimiter)
         {
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (fileNames != null && fileNames.Length > 0)
+            if (fileNames?.Length > 0)
             {
                 // Don't let injection attackers escape from our quotes by sticking in
                 // their own quotes. Quotes are illegal.
@@ -436,7 +436,7 @@ public void AppendFileNamesIfNotNull(ITaskItem[] fileItems, string delimiter)
         {
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (fileItems != null && fileItems.Length > 0)
+            if (fileItems?.Length > 0)
             {
                 // Don't let injection attackers escape from our quotes by sticking in
                 // their own quotes. Quotes are illegal.
@@ -572,7 +572,7 @@ public void AppendSwitchIfNotNull(string switchName, string[] parameters, string
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
@@ -604,7 +604,7 @@ public void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, str
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
@@ -683,7 +683,7 @@ public void AppendSwitchUnquotedIfNotNull(string switchName, string[] parameters
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
@@ -714,7 +714,7 @@ public void AppendSwitchUnquotedIfNotNull(string switchName, ITaskItem[] paramet
             ErrorUtilities.VerifyThrowArgumentNull(switchName, nameof(switchName));
             ErrorUtilities.VerifyThrowArgumentNull(delimiter, nameof(delimiter));
 
-            if (parameters != null && parameters.Length > 0)
+            if (parameters?.Length > 0)
             {
                 AppendSwitch(switchName);
                 bool first = true;
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index 145aee2eb51..b6abb5f011d 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -1230,7 +1230,7 @@ private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent)
                     // logger is registered without a ProjectFinished handler, but does have an Any handler (as the mock logger does) then we would end up
                     // sending the BuildFinished event before the ProjectFinished event got processed in the Any handler.
                     ProjectFinishedEventArgs projectFinishedEvent = buildEvent as ProjectFinishedEventArgs;
-                    if (projectFinishedEvent != null && buildEvent.BuildEventContext != null && buildEvent.BuildEventContext.Equals(_firstProjectStartedEventContext))
+                    if (projectFinishedEvent != null && buildEvent.BuildEventContext?.Equals(_firstProjectStartedEventContext) == true)
                     {
                         string message = projectFinishedEvent.Succeeded ? ResourceUtilities.GetResourceString("MuxLogger_BuildFinishedSuccess") : ResourceUtilities.GetResourceString("MuxLogger_BuildFinishedFailure");
                         RaiseBuildFinishedEvent(sender, new BuildFinishedEventArgs(message, null, projectFinishedEvent.Succeeded));
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 82cd4cc9d4a..20c7db8bc02 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -998,7 +998,7 @@ string targetPlatformVersion
         private static string GetPlatformVersion(TargetPlatformSDK targetSdk, string targetPlatformIdentifier, string targetPlatformVersion)
         {
             string platformKey = TargetPlatformSDK.GetSdkKey(targetPlatformIdentifier, targetPlatformVersion);
-            if (TryGetPlatformManifest(targetSdk, platformKey, out var manifest) && manifest != null && manifest.VersionedContent)
+            if (TryGetPlatformManifest(targetSdk, platformKey, out var manifest) && manifest?.VersionedContent == true)
             {
                 return manifest.PlatformVersion;
             }
@@ -1381,7 +1381,7 @@ public static string GetLatestSDKTargetPlatformVersion(string sdkIdentifier, str
                 }
             }
 
-            if (availablePlatformVersions != null && availablePlatformVersions.Count > 0)
+            if (availablePlatformVersions?.Count > 0)
             {
                 return availablePlatformVersions.OrderByDescending(x => x).FirstOrDefault().ToString();
             }
@@ -2956,7 +2956,7 @@ private static List<string> GetTargetPlatformMonikerDiskRoots(string[] diskRoots
             ExtractSdkDiskRootsFromEnvironment(sdkDiskRoots, sdkDirectoryRootsFromEnvironment);
             if (sdkDiskRoots.Count == 0)
             {
-                if (diskRoots != null && diskRoots.Length > 0)
+                if (diskRoots?.Length > 0)
                 {
                     ErrorUtilities.DebugTraceMessage("GetTargetPlatformMonikerDiskRoots", "Passed in DiskRoots '{0}'", string.Join(";", diskRoots));
                     sdkDiskRoots.AddRange(diskRoots);
@@ -2981,7 +2981,7 @@ private static List<string> GetExtensionSdkDiskRoots(string[] diskRoots)
             var sdkDiskRoots = new List<string>();
             string sdkDirectoryRootsFromEnvironment = Environment.GetEnvironmentVariable("MSBUILDMULTIPLATFORMSDKREFERENCEDIRECTORY");
             ExtractSdkDiskRootsFromEnvironment(sdkDiskRoots, sdkDirectoryRootsFromEnvironment);
-            if (sdkDiskRoots.Count == 0 && diskRoots != null && diskRoots.Length > 0)
+            if (sdkDiskRoots.Count == 0 && diskRoots?.Length > 0)
             {
                 ErrorUtilities.DebugTraceMessage("GetMultiPlatformSdkDiskRoots", "Passed in DiskRoots '{0}'", string.Join(";", diskRoots));
                 sdkDiskRoots.AddRange(diskRoots);
@@ -3955,7 +3955,7 @@ private static IList<string> GetFrameworkProfiles(string frameworkReferenceRoot,
                     Version ver = VersionUtilities.ConvertToVersion(frameworkVersion);
                     // check if profile is installed correctly
                     IList<string> refAssemblyPaths = GetPathToReferenceAssemblies(new FrameworkNameVersioning(frameworkIdentifier, ver, subType.Name));
-                    if (refAssemblyPaths != null && refAssemblyPaths.Count > 0)
+                    if (refAssemblyPaths?.Count > 0)
                     {
                         frameworkProfiles.Add(subType.Name);
                     }
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index be7d6f571f5..65416144aed 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -424,7 +424,7 @@ private ITaskItem[] ComputeSourcesNeedingCompilationFromCompositeRootingMarker(b
         /// </summary>
         private void SourceDependenciesForOutputRoot(Dictionary<string, ITaskItem> sourceDependencies, string sourceKey, ITaskItem[] filesToIgnore)
         {
-            bool thereAreFilesToIgnore = filesToIgnore != null && filesToIgnore.Length > 0;
+            bool thereAreFilesToIgnore = filesToIgnore?.Length > 0;
 
             if (DependencyTable.TryGetValue(sourceKey, out Dictionary<string, string> dependencies))
             {
@@ -867,7 +867,7 @@ public void SaveTlog(DependencyFilter includeInTLog)
         {
             // If there are no tlog files, then this will be a clean build
             // so there is no need to write a new tlog
-            if (_tlogFiles != null && _tlogFiles.Length > 0)
+            if (_tlogFiles?.Length > 0)
             {
                 string tLogRootingMarker = DependencyTableCache.FormatNormalizedTlogRootingMarker(_tlogFiles);
 
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index 6d20cad9feb..d850f3309bb 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -727,10 +727,7 @@ internal static void LogMessageFromResources(TaskLoggingHelper Log, MessageImpor
         internal static void LogMessage(TaskLoggingHelper Log, MessageImportance importance, string message, params object[] messageArgs)
         {
             // Only log when we have been passed a TaskLoggingHelper
-            if (Log != null)
-            {
-                Log.LogMessage(importance, message, messageArgs);
-            }
+            Log?.LogMessage(importance, message, messageArgs);
         }
 
         /// <summary>
@@ -743,10 +740,7 @@ internal static void LogMessage(TaskLoggingHelper Log, MessageImportance importa
         internal static void LogWarningWithCodeFromResources(TaskLoggingHelper Log, string messageResourceName, params object[] messageArgs)
         {
             // Only log when we have been passed a TaskLoggingHelper
-            if (Log != null)
-            {
-                Log.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
-            }
+            Log?.LogWarningWithCodeFromResources(messageResourceName, messageArgs);
         }
 
         #endregion
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index 88b60b0dfc8..75538b04ce8 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -613,7 +613,7 @@ private void RecordEntryDetails(string tlogEntry, bool populateTable)
         [SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly", MessageId = "TLog", Justification = "Has now shipped as public API; plus it's unclear whether 'Tlog' or 'TLog' is the preferred casing")]
         public void SaveTlog(DependencyFilter includeInTLog)
         {
-            if (TlogFiles != null && TlogFiles.Length > 0)
+            if (TlogFiles?.Length > 0)
             {
                 string tLogRootingMarker = DependencyTableCache.FormatNormalizedTlogRootingMarker(TlogFiles);
 
@@ -872,7 +872,7 @@ public static void FinalizeTLogs(bool trackedOperationsSucceeded, ITaskItem[] re
 
                 // In addition to temporary file removal, an optional set of files to remove may be been supplied
 
-                if (trackedFilesToRemoveFromTLogs != null && trackedFilesToRemoveFromTLogs.Length > 0)
+                if (trackedFilesToRemoveFromTLogs?.Length > 0)
                 {
                     IDictionary<string, ITaskItem> trackedFilesToRemove = new Dictionary<string, ITaskItem>(StringComparer.OrdinalIgnoreCase);
 
diff --git a/src/Utilities/TrackedDependencies/TrackedDependencies.cs b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
index 802f2164d3a..414a572d4d5 100644
--- a/src/Utilities/TrackedDependencies/TrackedDependencies.cs
+++ b/src/Utilities/TrackedDependencies/TrackedDependencies.cs
@@ -71,7 +71,7 @@ internal static bool ItemsExist(ITaskItem[] files)
         {
             bool allExist = true;
 
-            if (files != null && files.Length > 0)
+            if (files?.Length > 0)
             {
                 foreach (ITaskItem item in files)
                 {
diff --git a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs
index 711e2f6aa3a..7010458077f 100644
--- a/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs
+++ b/src/Xunit.NetCore.Extensions/Discoverers/ConditionalTestDiscoverer.cs
@@ -152,11 +152,11 @@ internal static MethodInfo LookupConditionalMethod(Type t, string name)
             TypeInfo ti = t.GetTypeInfo();
 
             MethodInfo mi = ti.GetDeclaredMethod(name);
-            if (mi != null && mi.IsStatic && mi.GetParameters().Length == 0 && mi.ReturnType == typeof(bool))
+            if (mi?.IsStatic == true && mi.GetParameters().Length == 0 && mi.ReturnType == typeof(bool))
                 return mi;
 
             PropertyInfo pi = ti.GetDeclaredProperty(name);
-            if (pi != null && pi.PropertyType == typeof(bool) && pi.GetMethod != null && pi.GetMethod.IsStatic && pi.GetMethod.GetParameters().Length == 0)
+            if (pi != null && pi.PropertyType == typeof(bool) && pi.GetMethod?.IsStatic == true && pi.GetMethod.GetParameters().Length == 0)
                 return pi.GetMethod;
 
             return LookupConditionalMethod(ti.BaseType, name);
