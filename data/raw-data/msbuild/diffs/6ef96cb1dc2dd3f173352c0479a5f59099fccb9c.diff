diff --git a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
index 4866a721238..6adc6dc5ce5 100644
--- a/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
+++ b/src/Build.UnitTests/Collections/CopyOnWritePropertyDictionary_Tests.cs
@@ -2,8 +2,9 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using Microsoft.Build.Collections;
-
+using Microsoft.Build.Execution;
 using Shouldly;
 
 using Xunit;
@@ -22,15 +23,15 @@ public void Count()
 
             dic.Count.ShouldBe(0);
 
-            dic.Set(new("a"));
+            dic.Set(new MockValue("a"));
 
             dic.Count.ShouldBe(1);
 
-            dic.Set(new("b"));
+            dic.Set(new MockValue("b"));
 
             dic.Count.ShouldBe(2);
 
-            dic.Set(new("c"));
+            dic.Set(new MockValue("c"));
 
             dic.Count.ShouldBe(3);
 
@@ -112,7 +113,8 @@ public void Enumeration()
             dic.Set(a);
             dic.Set(b);
 
-            dic.ShouldBeSetEquivalentTo(new[] { a, b });
+            IEnumerable<ProjectMetadataInstance> set = [a, b];
+            dic.ShouldBeSetEquivalentTo(set);
         }
 
         [Fact]
@@ -131,7 +133,7 @@ public void Equal()
             Test(dic1, dic4, false);
             Test(dic1, dic5, false);
 
-            static void Test(CopyOnWritePropertyDictionary<MockValue> a, CopyOnWritePropertyDictionary<MockValue> b, bool expected)
+            static void Test(CopyOnWritePropertyDictionary a, CopyOnWritePropertyDictionary b, bool expected)
             {
                 if (expected)
                 {
@@ -173,51 +175,37 @@ public void ImportProperties()
 
             dic.ImportProperties(new[] { a, b });
 
-            dic.ShouldBeSetEquivalentTo(new[] { a, b });
+            IEnumerable<ProjectMetadataInstance> set = [a, b];
+            dic.ShouldBeSetEquivalentTo(set);
         }
 
         [Fact]
         public void DeepClone()
         {
-            CopyOnWritePropertyDictionary<MockValue> source = CreateInstance("a", "b", "c");
-            CopyOnWritePropertyDictionary<MockValue> clone = (CopyOnWritePropertyDictionary<MockValue>)source.DeepClone();
+            CopyOnWritePropertyDictionary source = CreateInstance("a", "b", "c");
+            CopyOnWritePropertyDictionary clone = (CopyOnWritePropertyDictionary)source.DeepClone();
 
             source.ShouldBe(clone);
             source.ShouldNotBeSameAs(clone);
         }
 
-        private static CopyOnWritePropertyDictionary<MockValue> CreateInstance(params string[] values)
+        private static CopyOnWritePropertyDictionary CreateInstance(params string[] values)
         {
-            CopyOnWritePropertyDictionary<MockValue> dic = new CopyOnWritePropertyDictionary<MockValue>();
+            CopyOnWritePropertyDictionary dic = new();
 
             foreach (string value in values)
             {
-                dic.Set(new(value));
+                dic.Set(new MockValue(value));
             }
 
             return dic;
         }
 
-        private sealed class MockValue : IKeyed, IValued, IEquatable<MockValue>, IEquatable<object>, IImmutable
+        private sealed class MockValue : ProjectMetadataInstance
         {
-            public MockValue(string s) => Key = s;
-
-            public string Key { get; }
-
-            public string EscapedValue => Key;
-
-            public bool Equals(MockValue? other)
+            public MockValue(string s)
+                : base(s, "foo")
             {
-                return other != null && Key == other.Key;
-            }
-
-            public new bool Equals(object? other)
-            {
-                if (other is MockValue mv)
-                {
-                    return Equals(mv);
-                }
-                return false;
             }
         }
     }
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 7699a66b623..ae45b11b32a 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -221,7 +221,7 @@ static TaskItem BuildItem(
                     }
                 }
 
-                CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = new();
+                CopyOnWritePropertyDictionary directMetadata = new();
                 if (metadata is not null)
                 {
                     foreach ((string name, string value) in metadata)
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 2f5a26be1fc..7e6d076898c 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -24,6 +24,7 @@
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Task = System.Threading.Tasks.Task;
+using Microsoft.Build.Collections;
 
 #nullable disable
 
@@ -1392,41 +1393,45 @@ private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetN
 
                             ProjectItemInstance newItem;
 
-                            TaskItem outputAsProjectItem = output as TaskItem;
                             string parameterLocationEscaped = EscapingUtilities.EscapeWithCaching(parameterLocation.File);
 
-                            if (outputAsProjectItem != null)
+                            if (output is TaskItem outputAsProjectItem)
                             {
                                 // The common case -- all items involved are Microsoft.Build.Execution.ProjectItemInstance.TaskItems.
                                 // Furthermore, because that is true, we know by definition that they also implement ITaskItem2.
                                 newItem = new ProjectItemInstance(_projectInstance, outputTargetName, outputAsProjectItem.IncludeEscaped, parameterLocationEscaped);
 
-                                newItem.SetMetadata(outputAsProjectItem.MetadataCollection); // copy-on-write!
+                                outputAsProjectItem.CopyMetadataTo(newItem, addOriginalItemSpec: false);
                             }
-                            else
+                            else if (output is ITaskItem2 outputAsITaskItem2)
                             {
-                                if (output is ITaskItem2 outputAsITaskItem2)
-                                {
-                                    // Probably a Microsoft.Build.Utilities.TaskItem.  Not quite as good, but we can still preserve escaping.
-                                    newItem = new ProjectItemInstance(_projectInstance, outputTargetName, outputAsITaskItem2.EvaluatedIncludeEscaped, parameterLocationEscaped);
+                                // Probably a Microsoft.Build.Utilities.TaskItem.  Not quite as good, but we can still preserve escaping.
+                                newItem = new ProjectItemInstance(_projectInstance, outputTargetName, outputAsITaskItem2.EvaluatedIncludeEscaped, parameterLocationEscaped);
 
-                                    // It would be nice to be copy-on-write here, but Utilities.TaskItem doesn't know about CopyOnWritePropertyDictionary.
-                                    newItem.SetMetadataOnTaskOutput(outputAsITaskItem2.CloneCustomMetadataEscaped().Cast<KeyValuePair<string, string>>());
+                                IDictionary customMetadataEscaped = outputAsITaskItem2.CloneCustomMetadataEscaped();
+
+                                if (customMetadataEscaped is CopyOnWriteDictionary<string> copyOnWriteDictionary)
+                                {
+                                    newItem.SetMetadata(new CopyOnWritePropertyDictionary(copyOnWriteDictionary));
                                 }
                                 else
                                 {
-                                    // Not a ProjectItemInstance.TaskItem or even a ITaskItem2, so we have to fake it.
-                                    // Setting an item spec expects the escaped value, as does setting metadata.
-                                    newItem = new ProjectItemInstance(_projectInstance, outputTargetName, EscapingUtilities.Escape(output.ItemSpec), parameterLocationEscaped);
+                                    newItem.SetMetadataOnTaskOutput(outputAsITaskItem2.CloneCustomMetadataEscaped().Cast<KeyValuePair<string, string>>());
+                                }
+                            }
+                            else
+                            {
+                                // Not a ProjectItemInstance.TaskItem or even a ITaskItem2, so we have to fake it.
+                                // Setting an item spec expects the escaped value, as does setting metadata.
+                                newItem = new ProjectItemInstance(_projectInstance, outputTargetName, EscapingUtilities.Escape(output.ItemSpec), parameterLocationEscaped);
 
-                                    newItem.SetMetadataOnTaskOutput(EnumerateMetadata(output.CloneCustomMetadata()));
+                                newItem.SetMetadataOnTaskOutput(EnumerateMetadata(output.CloneCustomMetadata()));
 
-                                    static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary customMetadata)
+                                static IEnumerable<KeyValuePair<string, string>> EnumerateMetadata(IDictionary customMetadata)
+                                {
+                                    foreach (DictionaryEntry de in customMetadata)
                                     {
-                                        foreach (DictionaryEntry de in customMetadata)
-                                        {
-                                            yield return new KeyValuePair<string, string>((string)de.Key, EscapingUtilities.Escape((string)de.Value));
-                                        }
+                                        yield return new KeyValuePair<string, string>((string)de.Key, EscapingUtilities.Escape((string)de.Value));
                                     }
                                 }
                             }
diff --git a/src/Build/Collections/CopyOnWritePropertyDictionary.cs b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
index 41dd414b5cf..d5279ba7ae3 100644
--- a/src/Build/Collections/CopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/CopyOnWritePropertyDictionary.cs
@@ -6,7 +6,7 @@
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Diagnostics;
-
+using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -34,48 +34,61 @@ namespace Microsoft.Build.Collections
     ///
     /// This collection is safe for concurrent readers and a single writer.
     /// </remarks>
-    /// <typeparam name="T">Property or Metadata class type to store</typeparam>
     [DebuggerDisplay("#Entries={Count}")]
-    internal sealed class CopyOnWritePropertyDictionary<T> : ICopyOnWritePropertyDictionary<T>, IEquatable<CopyOnWritePropertyDictionary<T>>
-        where T : class, IKeyed, IValued, IEquatable<T>, IImmutable
+    internal sealed class CopyOnWritePropertyDictionary : ICopyOnWritePropertyDictionary<ProjectMetadataInstance>, IEquatable<CopyOnWritePropertyDictionary>, IEnumerable<ProjectMetadataInstance>
     {
-        private static readonly ImmutableDictionary<string, T> NameComparerDictionaryPrototype = ImmutableDictionary.Create<string, T>(MSBuildNameIgnoreCaseComparer.Default);
+        private static readonly ImmutableDictionary<string, string> NameComparerDictionaryPrototype = ImmutableDictionary.Create<string, string>(MSBuildNameIgnoreCaseComparer.Default);
 
         /// <summary>
         /// Backing dictionary.
         /// </summary>
-        private ImmutableDictionary<string, T> _backing;
+        private ImmutableDictionary<string, string> _backing;
 
         /// <summary>
         /// Creates empty dictionary.
         /// </summary>
-        public CopyOnWritePropertyDictionary()
-        {
-            _backing = NameComparerDictionaryPrototype;
-        }
+        public CopyOnWritePropertyDictionary() => _backing = NameComparerDictionaryPrototype;
 
         /// <summary>
         /// Cloning constructor, with deferred cloning semantics.
         /// </summary>
-        private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
-        {
-            _backing = that._backing;
-        }
+        internal CopyOnWritePropertyDictionary(CopyOnWriteDictionary<string> that) => _backing = that.ToImmutableDictionary();
+
+        /// <summary>
+        /// Cloning constructor, with deferred cloning semantics.
+        /// </summary>
+        private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary that) => _backing = that._backing;
 
         /// <summary>
         /// Accessor for the list of property names.
         /// </summary>
-        ICollection<string> IDictionary<string, T>.Keys => ((IDictionary<string, T>)_backing).Keys;
+        ICollection<string> IDictionary<string, ProjectMetadataInstance>.Keys => ((IDictionary<string, string>)_backing).Keys;
 
         /// <summary>
         /// Accessor for the list of properties.
         /// </summary>
-        ICollection<T> IDictionary<string, T>.Values => ((IDictionary<string, T>)_backing).Values;
+        ICollection<ProjectMetadataInstance> IDictionary<string, ProjectMetadataInstance>.Values
+        {
+            get
+            {
+                ImmutableDictionary<string, string> backing = _backing;
+                int index = 0;
+                ProjectMetadataInstance[] values = new ProjectMetadataInstance[backing.Count];
+
+                foreach (KeyValuePair<string, string> entry in backing)
+                {
+                    values[index] = new ProjectMetadataInstance(entry.Key, entry.Value, allowItemSpecModifiers: true);
+                    index++;
+                }
+
+                return values;
+            }
+        }
 
         /// <summary>
         /// Whether the collection is read-only.
         /// </summary>
-        bool ICollection<KeyValuePair<string, T>>.IsReadOnly => false;
+        bool ICollection<KeyValuePair<string, ProjectMetadataInstance>>.IsReadOnly => false;
 
         /// <summary>
         /// Returns the number of properties in the collection.
@@ -91,20 +104,24 @@ private CopyOnWritePropertyDictionary(CopyOnWritePropertyDictionary<T> that)
         /// This better matches the semantics of property, which are considered to have a blank value if they
         /// are not defined.
         /// </remarks>
-        public T this[string name]
+        public ProjectMetadataInstance this[string name]
         {
+            // We don't want to check for a zero length name here, since that is a valid name
+            // and should return a null instance which will be interpreted as blank
             get
             {
-                // We don't want to check for a zero length name here, since that is a valid name
-                // and should return a null instance which will be interpreted as blank
-                _backing.TryGetValue(name, out T projectProperty);
-                return projectProperty;
+                if (_backing.TryGetValue(name, out string escapedValue) && escapedValue != null)
+                {
+                    return new ProjectMetadataInstance(name, escapedValue, allowItemSpecModifiers: true);
+                }
+
+                return null;
             }
 
             set
             {
                 ErrorUtilities.VerifyThrowInternalNull(value, "Properties can't have null value");
-                ErrorUtilities.VerifyThrow(String.Equals(name, value.Key, StringComparison.OrdinalIgnoreCase), "Key must match value's key");
+                ErrorUtilities.VerifyThrow(string.Equals(name, value.Key, StringComparison.OrdinalIgnoreCase), "Key must match value's key");
                 Set(value);
             }
         }
@@ -115,36 +132,31 @@ public T this[string name]
         /// </summary>
         public bool Contains(string name) => _backing.ContainsKey(name);
 
-        public string GetEscapedValue(string name)
-        {
-            if (_backing.TryGetValue(name, out T value))
-            {
-                return value?.EscapedValue;
-            }
-
-            return null;
-        }
+        public string GetEscapedValue(string name) => _backing.TryGetValue(name, out string escapedValue) ? escapedValue : null;
 
         /// <summary>
         /// Empties the collection
         /// </summary>
-        public void Clear()
-        {
-            _backing = _backing.Clear();
-        }
+        public void Clear() => _backing = _backing.Clear();
 
         /// <summary>
         /// Gets an enumerator over all the properties in the collection
         /// Enumeration is in undefined order
         /// </summary>
-        public IEnumerator<T> GetEnumerator() => _backing.Values.GetEnumerator();
+        public IEnumerator<ProjectMetadataInstance> GetEnumerator()
+        {
+            foreach (KeyValuePair<string, string> item in _backing)
+            {
+                yield return new ProjectMetadataInstance(item.Key, item.Value, allowItemSpecModifiers: true);
+            }
+        }
 
         /// <summary>
         /// Get an enumerator over entries
         /// </summary>
         IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
 
-        #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
+        #region IEquatable<CopyOnWritePropertyDictionary> Members
 
         /// <summary>
         /// Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
@@ -152,7 +164,7 @@ public void Clear()
         /// </summary>
         /// <param name="other">The dictionary to which this should be compared</param>
         /// <returns>True if they are equivalent, false otherwise.</returns>
-        public bool Equals(CopyOnWritePropertyDictionary<T> other)
+        public bool Equals(CopyOnWritePropertyDictionary other)
         {
             if (other == null)
             {
@@ -160,8 +172,8 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
             }
 
             // Copy both backing collections to locals
-            ImmutableDictionary<string, T> thisBacking = _backing;
-            ImmutableDictionary<string, T> thatBacking = other._backing;
+            ImmutableDictionary<string, string> thisBacking = _backing;
+            ImmutableDictionary<string, string> thatBacking = other._backing;
 
             // If the backing collections are the same, we are equal.
             // Note that with this check, we intentionally avoid the common reference
@@ -176,10 +188,9 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
                 return false;
             }
 
-            foreach (T thisProp in thisBacking.Values)
+            foreach (KeyValuePair<string, string> thisEntry in thisBacking)
             {
-                if (!thatBacking.TryGetValue(thisProp.Key, out T thatProp) ||
-                    !EqualityComparer<T>.Default.Equals(thisProp, thatProp))
+                if (!thatBacking.TryGetValue(thisEntry.Key, out string thatValue) || thisEntry.Value != thatValue)
                 {
                     return false;
                 }
@@ -190,7 +201,7 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
 
         #endregion
 
-        #region IEquatable<CopyOnWritePropertyDictionary<T>> Members
+        #region IEquatable<CopyOnWritePropertyDictionary<ProjectMetadataInstance>> Members
 
         /// <summary>
         /// Compares two property dictionaries for equivalence.  They are equal if each contains the same properties with the
@@ -198,38 +209,29 @@ public bool Equals(CopyOnWritePropertyDictionary<T> other)
         /// </summary>
         /// <param name="other">The dictionary to which this should be compared</param>
         /// <returns>True if they are equivalent, false otherwise.</returns>
-        public bool Equals(ICopyOnWritePropertyDictionary<T> other)
+        public bool Equals(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> other)
         {
             if (other == null)
             {
                 return false;
             }
 
-            ImmutableDictionary<string, T> thisBacking = _backing;
-            IDictionary<string, T> otherDict = other;
+            ImmutableDictionary<string, string> thisBacking = _backing;
 
-            if (other is CopyOnWritePropertyDictionary<T> otherCopyOnWritePropertyDictionary)
+            if (other is CopyOnWritePropertyDictionary otherCopyOnWritePropertyDictionary)
             {
-                // If the backing collections are the same, we are equal.
-                // Note that with this check, we intentionally avoid the common reference
-                // comparison between 'this' and 'other'.
-                if (ReferenceEquals(thisBacking, otherCopyOnWritePropertyDictionary._backing))
-                {
-                    return true;
-                }
-
-                otherDict = otherCopyOnWritePropertyDictionary._backing;
+                return Equals(otherCopyOnWritePropertyDictionary);
             }
 
-            if (thisBacking.Count != otherDict.Count)
+            if (thisBacking.Count != other.Count)
             {
                 return false;
             }
 
-            foreach (T thisProp in thisBacking.Values)
+            foreach (KeyValuePair<string, string> thisEntry in thisBacking)
             {
-                if (!otherDict.TryGetValue(thisProp.Key, out T thatProp) ||
-                    !EqualityComparer<T>.Default.Equals(thisProp, thatProp))
+                if (!other.TryGetValue(thisEntry.Key, out ProjectMetadataInstance thatProp) ||
+                    !EqualityComparer<ProjectMetadataInstance>.Default.Equals(new ProjectMetadataInstance(thisEntry.Key, thisEntry.Value, allowItemSpecModifiers: true), thatProp))
                 {
                     return false;
                 }
@@ -240,12 +242,12 @@ public bool Equals(ICopyOnWritePropertyDictionary<T> other)
 
         #endregion
 
-        #region IDictionary<string,T> Members
+        #region IDictionary<string, ProjectMetadataInstance> Members
 
         /// <summary>
         /// Adds a property
         /// </summary>
-        void IDictionary<string, T>.Add(string key, T value)
+        void IDictionary<string, ProjectMetadataInstance>.Add(string key, ProjectMetadataInstance value)
         {
             ErrorUtilities.VerifyThrowInternalNull(value, "Properties can't have null value");
             ErrorUtilities.VerifyThrow(key == value.Key, "Key must match value's key");
@@ -255,33 +257,48 @@ void IDictionary<string, T>.Add(string key, T value)
         /// <summary>
         /// Returns true if the dictionary contains the key
         /// </summary>
-        bool IDictionary<string, T>.ContainsKey(string key) => _backing.ContainsKey(key);
+        bool IDictionary<string, ProjectMetadataInstance>.ContainsKey(string key) => _backing.ContainsKey(key);
 
         /// <summary>
         /// Attempts to retrieve the a property.
         /// </summary>
-        bool IDictionary<string, T>.TryGetValue(string key, out T value) => _backing.TryGetValue(key, out value);
+        bool IDictionary<string, ProjectMetadataInstance>.TryGetValue(string key, out ProjectMetadataInstance value)
+        {
+            value = null;
+
+            if (_backing.TryGetValue(key, out string escapedValue))
+            {
+                if (escapedValue != null)
+                {
+                    value = new ProjectMetadataInstance(key, escapedValue, allowItemSpecModifiers: true);
+                }
+
+                return true;
+            }
+
+            return false;
+        }
 
         #endregion
 
-        #region ICollection<KeyValuePair<string,T>> Members
+        #region ICollection<KeyValuePair<string,ProjectMetadataInstance>> Members
 
         /// <summary>
         /// Adds a property
         /// </summary>
-        void ICollection<KeyValuePair<string, T>>.Add(KeyValuePair<string, T> item)
+        void ICollection<KeyValuePair<string, ProjectMetadataInstance>>.Add(KeyValuePair<string, ProjectMetadataInstance> item)
         {
-            ((IDictionary<string, T>)this).Add(item.Key, item.Value);
+            ((IDictionary<string, ProjectMetadataInstance>)this).Add(item.Key, item.Value);
         }
 
         /// <summary>
         /// Checks for a property in the collection
         /// </summary>
-        bool ICollection<KeyValuePair<string, T>>.Contains(KeyValuePair<string, T> item)
+        bool ICollection<KeyValuePair<string, ProjectMetadataInstance>>.Contains(KeyValuePair<string, ProjectMetadataInstance> item)
         {
-            if (_backing.TryGetValue(item.Key, out T value))
+            if (_backing.TryGetValue(item.Key, out string escapedValue))
             {
-                return EqualityComparer<T>.Default.Equals(value, item.Value);
+                return EqualityComparer<ProjectMetadataInstance>.Default.Equals(new ProjectMetadataInstance(item.Key, escapedValue, allowItemSpecModifiers: true), item.Value);
             }
 
             return false;
@@ -290,7 +307,7 @@ bool ICollection<KeyValuePair<string, T>>.Contains(KeyValuePair<string, T> item)
         /// <summary>
         /// Not implemented
         /// </summary>
-        void ICollection<KeyValuePair<string, T>>.CopyTo(KeyValuePair<string, T>[] array, int arrayIndex)
+        void ICollection<KeyValuePair<string, ProjectMetadataInstance>>.CopyTo(KeyValuePair<string, ProjectMetadataInstance>[] array, int arrayIndex)
         {
             ErrorUtilities.ThrowInternalError("CopyTo is not supported on PropertyDictionary.");
         }
@@ -298,7 +315,7 @@ void ICollection<KeyValuePair<string, T>>.CopyTo(KeyValuePair<string, T>[] array
         /// <summary>
         /// Removes a property from the collection
         /// </summary>
-        bool ICollection<KeyValuePair<string, T>>.Remove(KeyValuePair<string, T> item)
+        bool ICollection<KeyValuePair<string, ProjectMetadataInstance>>.Remove(KeyValuePair<string, ProjectMetadataInstance> item)
         {
             ErrorUtilities.VerifyThrow(item.Key == item.Value.Key, "Key must match value's key");
             return Remove(item.Key);
@@ -306,14 +323,18 @@ bool ICollection<KeyValuePair<string, T>>.Remove(KeyValuePair<string, T> item)
 
         #endregion
 
-        #region IEnumerable<KeyValuePair<string,T>> Members
+        #region IEnumerable<KeyValuePair<string,ProjectMetadataInstance>> Members
 
         /// <summary>
         /// Get an enumerator over the entries.
         /// </summary>
-        IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator()
+        IEnumerator<KeyValuePair<string, ProjectMetadataInstance>> IEnumerable<KeyValuePair<string, ProjectMetadataInstance>>.GetEnumerator()
         {
-            return _backing.GetEnumerator();
+            foreach (KeyValuePair<string, string> item in _backing)
+            {
+                ProjectMetadataInstance projectProperty = new(item.Key, item.Value, allowItemSpecModifiers: true);
+                yield return new(item.Key, projectProperty);
+            }
         }
 
         #endregion
@@ -334,26 +355,26 @@ public bool Remove(string name)
         /// Overwrites any property with the same name already in the collection.
         /// To remove a property, use Remove(...) instead.
         /// </summary>
-        public void Set(T projectProperty)
+        public void Set(ProjectMetadataInstance projectProperty)
         {
             ErrorUtilities.VerifyThrowArgumentNull(projectProperty);
 
-            _backing = _backing.SetItem(projectProperty.Key, projectProperty);
+            _backing = _backing.SetItem(projectProperty.Key, projectProperty.EscapedValue);
         }
 
         /// <summary>
         /// Adds the specified properties to this dictionary.
         /// </summary>
         /// <param name="other">An enumerator over the properties to add.</param>
-        public void ImportProperties(IEnumerable<T> other)
+        public void ImportProperties(IEnumerable<ProjectMetadataInstance> other)
         {
-            _backing = _backing.SetItems(Items());
+            _backing = _backing.SetItems(Items(other));
 
-            IEnumerable<KeyValuePair<string, T>> Items()
+            static IEnumerable<KeyValuePair<string, string>> Items(IEnumerable<ProjectMetadataInstance> other)
             {
-                foreach (T property in other)
+                foreach (ProjectMetadataInstance property in other)
                 {
-                    yield return new(property.Key, property);
+                    yield return new(property.Key, property.EscapedValue);
                 }
             }
         }
@@ -362,9 +383,18 @@ IEnumerable<KeyValuePair<string, T>> Items()
         /// Clone. As we're copy on write, this
         /// should be cheap.
         /// </summary>
-        public ICopyOnWritePropertyDictionary<T> DeepClone()
+        public ICopyOnWritePropertyDictionary<ProjectMetadataInstance> DeepClone() => new CopyOnWritePropertyDictionary(this);
+
+        /// <summary>
+        /// Returns true if these dictionaries have the same backing.
+        /// </summary>
+        public bool HasSameBacking(ICopyOnWritePropertyDictionary<ProjectMetadataInstance> other)
         {
-            return new CopyOnWritePropertyDictionary<T>(this);
+            return other is CopyOnWritePropertyDictionary otherCopyOnWritePropertyDictionary
+                ? ReferenceEquals(otherCopyOnWritePropertyDictionary._backing, _backing)
+                : false;
         }
+
+        internal CopyOnWriteDictionary<string> ToCopyOnWriteDictionary() => new(_backing);
     }
 }
diff --git a/src/Build/Collections/ICopyOnWritePropertyDictionary.cs b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
index 310476fa83b..90a92b29423 100644
--- a/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
+++ b/src/Build/Collections/ICopyOnWritePropertyDictionary.cs
@@ -61,5 +61,7 @@ internal interface ICopyOnWritePropertyDictionary<T> : IEnumerable<T>, IEquatabl
         /// directly.
         /// </summary>
         string GetEscapedValue(string name);
+
+        bool HasSameBacking(ICopyOnWritePropertyDictionary<T> other);
     }
 }
diff --git a/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs b/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs
index 27610c71543..a77943256a7 100644
--- a/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs
+++ b/src/Build/Instance/ImmutableProjectCollections/ImmutablePropertyCollectionConverter.cs
@@ -68,5 +68,7 @@ public bool Equals(ICopyOnWritePropertyDictionary<T>? other)
 
             return true;
         }
+
+        public bool HasSameBacking(ICopyOnWritePropertyDictionary<T> other) => ReferenceEquals(other, this);
     }
 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index f77da95817b..6c2d8253551 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -3342,10 +3342,10 @@ private ProjectItemInstance InstantiateProjectItemInstance(ProjectItem item)
                 }
             }
 
-            CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = null;
+            CopyOnWritePropertyDictionary directMetadata = null;
             if (item.DirectMetadata != null)
             {
-                directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                directMetadata = new CopyOnWritePropertyDictionary();
 
                 IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
                 directMetadata.ImportProperties(projectMetadataInstances);
@@ -3403,7 +3403,7 @@ private static ProjectItemInstance InstantiateProjectItemInstanceFromImmutablePr
                 }
                 else
                 {
-                    directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                    directMetadata = new CopyOnWritePropertyDictionary();
 
                     IEnumerable<ProjectMetadataInstance> projectMetadataInstances = item.DirectMetadata.Select(directMetadatum => new ProjectMetadataInstance(directMetadatum));
                     directMetadata.ImportProperties(projectMetadataInstances);
diff --git a/src/Build/Instance/ProjectItemDefinitionInstance.cs b/src/Build/Instance/ProjectItemDefinitionInstance.cs
index 4e886bd134a..2658a0ebe5a 100644
--- a/src/Build/Instance/ProjectItemDefinitionInstance.cs
+++ b/src/Build/Instance/ProjectItemDefinitionInstance.cs
@@ -58,7 +58,7 @@ internal ProjectItemDefinitionInstance(ProjectItemDefinition itemDefinition)
         {
             if (itemDefinition.MetadataCount > 0)
             {
-                var copyOnWriteMetadataDictionary = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                var copyOnWriteMetadataDictionary = new CopyOnWritePropertyDictionary();
                 IEnumerable<ProjectMetadataInstance> projectMetadataInstances = itemDefinition.Metadata.Select(originalMetadata => new ProjectMetadataInstance(originalMetadata));
                 copyOnWriteMetadataDictionary.ImportProperties(projectMetadataInstances);
 
@@ -196,7 +196,7 @@ string IMetadataTable.GetEscapedValueIfPresent(string specifiedItemType, string
         ProjectMetadataInstance IItemDefinition<ProjectMetadataInstance>.SetMetadata(ProjectMetadataElement xml, string evaluatedValue, ProjectMetadataInstance predecessor)
         {
             // No mutability check as this is used during creation (evaluation)
-            _metadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+            _metadata ??= new CopyOnWritePropertyDictionary();
 
             ProjectMetadataInstance metadatum = new ProjectMetadataInstance(xml.Name, evaluatedValue);
             _metadata[xml.Name] = metadatum;
@@ -238,7 +238,7 @@ internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITransla
 
         private static IDictionary<string, ProjectMetadataInstance> CreateMetadataCollection(int capacity)
         {
-            return new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+            return new CopyOnWritePropertyDictionary();
         }
     }
 }
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 36f280f88bb..9a058d7c135 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -121,11 +121,11 @@ internal ProjectItemInstance(
         /// </remarks>
         internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, IEnumerable<KeyValuePair<string, string>> directMetadata, string definingFileEscaped)
         {
-            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = null;
+            CopyOnWritePropertyDictionary metadata = null;
 
             if (directMetadata?.GetEnumerator().MoveNext() == true)
             {
-                metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                metadata = new CopyOnWritePropertyDictionary();
                 IEnumerable<ProjectMetadataInstance> directMetadataInstances = directMetadata.Select(metadatum => new ProjectMetadataInstance(metadatum.Key, metadatum.Value));
                 metadata.ImportProperties(directMetadataInstances);
             }
@@ -356,6 +356,8 @@ internal string ProjectFullPath
             get { return _project.FullPath; }
         }
 
+        int IMetadataContainer.CustomMetadataCount => ((IMetadataContainer)_taskItem).CustomMetadataCount;
+
         /// <summary>
         /// Get any metadata in the item that has the specified name,
         /// otherwise returns null.
@@ -541,6 +543,8 @@ IDictionary ITaskItem2.CloneCustomMetadataEscaped()
 
         #region IMetadataTable Members
 
+        bool IMetadataContainer.HasSameBackingCollection(ICollection<KeyValuePair<string, string>> backingCollection) => ((IMetadataContainer)_taskItem).HasSameBackingCollection(backingCollection);
+
         /// <summary>
         /// Retrieves any value we have in our metadata table for the metadata name specified.
         /// If no value is available, returns empty string.
@@ -603,7 +607,7 @@ void ITranslatable.Translate(ITranslator translator)
         internal static void SetMetadata(IEnumerable<KeyValuePair<string, string>> metadataList, IEnumerable<ProjectItemInstance> items)
         {
             // Set up a single dictionary that can be applied to all the items
-            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = new();
+            CopyOnWritePropertyDictionary metadata = new();
 
             IEnumerable<ProjectMetadataInstance> projectMetadataInstances = metadataList.Select(metadatum => new ProjectMetadataInstance(metadatum.Key, metadatum.Value));
             metadata.ImportProperties(projectMetadataInstances);
@@ -1081,10 +1085,39 @@ public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
-                _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                if (_directMetadata == null && metadata is ICopyOnWritePropertyDictionary<ProjectMetadataInstance> copyOnWritePropertyDictionary)
+                {
+                    _directMetadata = copyOnWritePropertyDictionary.DeepClone();
+                    return;
+                }
+                else if (_directMetadata == null && metadata is CopyOnWriteDictionary<string> copyOnWriteDictionary)
+                {
+                    _directMetadata = new CopyOnWritePropertyDictionary(copyOnWriteDictionary);
+                    return;
+                }
+
+                _directMetadata ??= new CopyOnWritePropertyDictionary();
                 _directMetadata.ImportProperties(metadata.Select(kvp => new ProjectMetadataInstance(kvp.Key, kvp.Value, allowItemSpecModifiers: true)));
             }
 
+            bool IMetadataContainer.HasSameBackingCollection(ICollection<KeyValuePair<string, string>> backingCollection)
+            {
+                if (_directMetadata == null)
+                {
+                    return backingCollection == null;
+                }
+                else if (backingCollection is ICopyOnWritePropertyDictionary<ProjectMetadataInstance> copyOnWritePropertyDictionary)
+                {
+                    return _directMetadata.HasSameBacking(copyOnWritePropertyDictionary);
+                }
+                else if (backingCollection is CopyOnWriteDictionary<string> copyOnWriteDictionary)
+                {
+                    return _directMetadata.HasSameBacking(new CopyOnWritePropertyDictionary(copyOnWriteDictionary));
+                }
+
+                return false;
+            }
+
             /// <summary>
             /// Used to return metadata from another AppDomain. Can't use yield return because the
             /// generated state machine is not marked as [Serializable], so we need to allocate.
@@ -1139,10 +1172,10 @@ internal ICopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollect
                     //  (last of which is any item definition metadata associated with the destination item's item type)
                     if (_itemDefinitions == null)
                     {
-                        return (_directMetadata == null) ? new CopyOnWritePropertyDictionary<ProjectMetadataInstance>() : _directMetadata.DeepClone(); // copy on write!
+                        return (_directMetadata == null) ? new CopyOnWritePropertyDictionary() : _directMetadata.DeepClone(); // copy on write!
                     }
 
-                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> allMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                    CopyOnWritePropertyDictionary allMetadata = new();
 
                     allMetadata.ImportProperties(metaData());
 
@@ -1188,6 +1221,8 @@ IEnumerable<ProjectMetadataInstance> metaData()
 
             IEnumerable<ProjectMetadataInstance> IItem<ProjectMetadataInstance>.Metadata => MetadataCollection;
 
+            int IMetadataContainer.CustomMetadataCount => _directMetadata?.Count ?? 0;
+
             #region Operators
 
             /// <summary>
@@ -1422,68 +1457,118 @@ public void CopyMetadataTo(ITaskItem destinationItem, bool addOriginalItemSpec)
                     originalItemSpec = destinationItem.GetMetadata("OriginalItemSpec");
                 }
 
-                if (destinationItem is TaskItem destinationAsTaskItem && destinationAsTaskItem._directMetadata == null)
+                if (destinationItem is TaskItem destinationAsTaskItem)
                 {
-                    ProjectInstance.VerifyThrowNotImmutable(destinationAsTaskItem._isImmutable);
-
-                    // This optimized path is hit most often
-                    destinationAsTaskItem._directMetadata = _directMetadata?.DeepClone(); // copy on write!
+                    CopyToProjectTaskItem(destinationAsTaskItem);
+                }
+                else if (destinationItem is ProjectItemInstance destinationAsProjectItemInstance)
+                {
+                    CopyToProjectTaskItem(destinationAsProjectItemInstance._taskItem);
+                }
+                else if (destinationItem is IMetadataContainer destinationAsMetadataContainer)
+                {
+                    CopyToMetadataContainer(destinationItem, destinationAsMetadataContainer);
+                }
+                else
+                {
+                    CopyToTaskItem(destinationItem);
+                }
 
-                    // If the destination item already has item definitions then we want to maintain them
-                    // But ours will be of less precedence than those already on the item
-                    if (destinationAsTaskItem._itemDefinitions == null)
+                if (addOriginalItemSpec)
+                {
+                    if (string.IsNullOrEmpty(originalItemSpec))
                     {
-                        destinationAsTaskItem._itemDefinitions = (_itemDefinitions == null) ? null : new List<ProjectItemDefinitionInstance>(_itemDefinitions);
+                        // This does not appear to significantly cause a copy-on-write; otherwise, it could go in its own slot.
+                        destinationItem.SetMetadata("OriginalItemSpec", _includeEscaped);
                     }
-                    else if (_itemDefinitions != null)
+                }
+
+                void CopyToProjectTaskItem(TaskItem destinationItem)
+                {
+                    ProjectInstance.VerifyThrowNotImmutable(destinationItem._isImmutable);
+
+                    if (destinationItem._directMetadata == null)
                     {
-                        for (int i = 0; i < _itemDefinitions.Count; i++)
+                        // This optimized path is hit most often
+                        destinationItem._directMetadata = _directMetadata?.DeepClone(); // copy on write!
+
+                        // If the destination item already has item definitions then we want to maintain them
+                        // But ours will be of less precedence than those already on the item
+                        if (destinationItem._itemDefinitions == null)
                         {
-                            destinationAsTaskItem._itemDefinitions.Add(_itemDefinitions[i]);
+                            destinationItem._itemDefinitions = (_itemDefinitions == null) ? null : new List<ProjectItemDefinitionInstance>(_itemDefinitions);
                         }
+                        else if (_itemDefinitions != null)
+                        {
+                            for (int i = 0; i < _itemDefinitions.Count; i++)
+                            {
+                                destinationItem._itemDefinitions.Add(_itemDefinitions[i]);
+                            }
+                        }
+                    }
+                    else if (_directMetadata != null && !_directMetadata.HasSameBacking(destinationItem._directMetadata))
+                    {
+                        IEnumerable<ProjectMetadataInstance> metadataToImport = ((IEnumerable<ProjectMetadataInstance>)_directMetadata)
+                            .Where(metadatum => string.IsNullOrEmpty(destinationItem._directMetadata.GetEscapedValue(metadatum.Name)));
+                        destinationItem._directMetadata.ImportProperties(metadataToImport);
                     }
                 }
-                else if (destinationItem is IMetadataContainer destinationItemAsMetadataContainer)
+
+                void CopyToMetadataContainer(ITaskItem destinationItem, IMetadataContainer destinationMetadata)
                 {
+                    if (_itemDefinitions == null && _directMetadata == null)
+                    {
+                        return;
+                    }
+                    else if (_itemDefinitions == null && _directMetadata is CopyOnWritePropertyDictionary copyOnWritePropertyDictionary)
+                    {
+                        if (destinationMetadata.CustomMetadataCount == 0)
+                        {
+                            destinationMetadata.ImportMetadata(copyOnWritePropertyDictionary.ToCopyOnWriteDictionary());
+                            return;
+                        }
+                        else if (destinationMetadata.HasSameBackingCollection(copyOnWritePropertyDictionary.ToCopyOnWriteDictionary()))
+                        {
+                            return;
+                        }
+                    }
+
                     // The destination implements IMetadataContainer so we can use the ImportMetadata bulk-set operation.
                     IEnumerable<ProjectMetadataInstance> metadataEnumerable = MetadataCollection;
-                    IEnumerable<KeyValuePair<string, string>> metadataToImport = metadataEnumerable
-                        .Where(metadatum => string.IsNullOrEmpty(destinationItem.GetMetadata(metadatum.Name)))
-                        .Select(metadatum => new KeyValuePair<string, string>(metadatum.Name, GetMetadataEscaped(metadatum.Name)));
+
+                    // Avoid unescaping the value just to immediately escape after, since TaskItem implementations store their values escaped.
+                    IEnumerable<KeyValuePair<string, string>> metadataToImport = destinationItem is ITaskItem2 destinationAsITaskItem2
+                        ? metadataEnumerable
+                            .Where(metadatum => string.IsNullOrEmpty(destinationAsITaskItem2.GetMetadataValueEscaped(metadatum.Name)))
+                            .Select(metadatum => new KeyValuePair<string, string>(metadatum.Name, GetMetadataEscaped(metadatum.Name)))
+                        : metadataEnumerable
+                            .Where(metadatum => string.IsNullOrEmpty(destinationItem.GetMetadata(metadatum.Name)))
+                            .Select(metadatum => new KeyValuePair<string, string>(metadatum.Name, GetMetadataEscaped(metadatum.Name)));
 
 #if FEATURE_APPDOMAIN
-                    if (RemotingServices.IsTransparentProxy(destinationItem))
+                    if (RemotingServices.IsTransparentProxy(destinationMetadata))
                     {
                         // Linq is not serializable so materialize the collection before making the call.
-                        metadataToImport = metadataToImport.ToList();
+                        metadataToImport = [.. metadataToImport];
                     }
 #endif
-
-                    destinationItemAsMetadataContainer.ImportMetadata(metadataToImport);
+                    destinationMetadata.ImportMetadata(metadataToImport);
                 }
-                else
+
+                void CopyToTaskItem(ITaskItem destinationItem)
                 {
                     // OK, most likely the destination item was a Microsoft.Build.Utilities.TaskItem.
                     foreach (ProjectMetadataInstance metadatum in (IEnumerable<ProjectMetadataInstance>)MetadataCollection)
                     {
                         // When copying metadata, we do NOT overwrite metadata already on the destination item.
                         string destinationValue = destinationItem.GetMetadata(metadatum.Name);
-                        if (String.IsNullOrEmpty(destinationValue))
+                        if (string.IsNullOrEmpty(destinationValue))
                         {
                             // Utilities.TaskItem's don't know about item definition metadata. So merge that into the values.
                             destinationItem.SetMetadata(metadatum.Name, GetMetadataEscaped(metadatum.Name));
                         }
                     }
                 }
-
-                if (addOriginalItemSpec)
-                {
-                    if (String.IsNullOrEmpty(originalItemSpec))
-                    {
-                        // This does not appear to significantly cause a copy-on-write; otherwise, it could go in its own slot.
-                        destinationItem.SetMetadata("OriginalItemSpec", _includeEscaped);
-                    }
-                }
             }
 
             /// <summary>
@@ -1547,7 +1632,7 @@ void ITranslatable.Translate(ITranslator translator)
                     translator,
                     ref _directMetadata,
                     ProjectMetadataInstance.FactoryForDeserialization,
-                    (capacity) => new CopyOnWritePropertyDictionary<ProjectMetadataInstance>());
+                    (capacity) => new CopyOnWritePropertyDictionary());
 
                 if (_itemDefinitions?.Count == 0)
                 {
@@ -1708,11 +1793,7 @@ public bool HasMetadata(string name)
             public void SetMetadata(IEnumerable<KeyValuePair<string, string>> metadataDictionary)
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
-
-                foreach (KeyValuePair<string, string> metadataEntry in metadataDictionary)
-                {
-                    SetMetadata(metadataEntry.Key, metadataEntry.Value);
-                }
+                ImportMetadata(metadataDictionary);
             }
 
             /// <summary>
@@ -1793,7 +1874,7 @@ internal void TranslateWithInterning(ITranslator translator, LookasideStringInte
                                     int value = translator.Reader.ReadInt32();
                                     return new ProjectMetadataInstance(interner.GetString(key), interner.GetString(value), allowItemSpecModifiers: true);
                                 });
-                            _directMetadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                            _directMetadata = new CopyOnWritePropertyDictionary();
                             _directMetadata.ImportProperties(metaData);
                         }
                         else
@@ -1857,8 +1938,8 @@ internal ProjectMetadataInstance SetMetadataObject(string name, string metadataV
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
 
-                _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-                ProjectMetadataInstance metadatum = new ProjectMetadataInstance(name, metadataValueEscaped, allowItemSpecModifiers /* may not be built-in metadata name */);
+                _directMetadata ??= new CopyOnWritePropertyDictionary();
+                ProjectMetadataInstance metadatum = new(name, metadataValueEscaped, allowItemSpecModifiers /* may not be built-in metadata name */);
                 _directMetadata.Set(metadatum);
 
                 return metadatum;
@@ -1879,8 +1960,8 @@ internal void SetMetadataOnTaskOutput(string name, string evaluatedValueEscaped)
 
                 if (!FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(name))
                 {
-                    _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
-                    ProjectMetadataInstance metadatum = new ProjectMetadataInstance(name, evaluatedValueEscaped, true /* may be built-in metadata name */);
+                    _directMetadata ??= new CopyOnWritePropertyDictionary();
+                    ProjectMetadataInstance metadatum = new(name, evaluatedValueEscaped, true /* may be built-in metadata name */);
                     _directMetadata.Set(metadatum);
                 }
             }
@@ -1888,7 +1969,7 @@ internal void SetMetadataOnTaskOutput(string name, string evaluatedValueEscaped)
             internal void SetMetadataOnTaskOutput(IEnumerable<KeyValuePair<string, string>> items)
             {
                 ProjectInstance.VerifyThrowNotImmutable(_isImmutable);
-                _directMetadata ??= new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                _directMetadata ??= new CopyOnWritePropertyDictionary();
 
                 var metadata = items
                     .Where(item => !FileUtilities.ItemSpecModifiers.IsDerivableItemSpecModifier(item.Key))
@@ -2059,7 +2140,7 @@ public ProjectItemInstance CreateItem(string evaluatedInclude, string evaluatedI
                 public void SetMetadata(IEnumerable<KeyValuePair<ProjectMetadataElement, string>> metadataList, IEnumerable<ProjectItemInstance> destinationItems)
                 {
                     // Set up a single dictionary that can be applied to all the items
-                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = new CopyOnWritePropertyDictionary<ProjectMetadataInstance>();
+                    CopyOnWritePropertyDictionary metadata = new();
                     IEnumerable<ProjectMetadataInstance> projectMetadataInstances = metadataList.Select(metadatum => new ProjectMetadataInstance(metadatum.Key.Name, metadatum.Value));
                     metadata.ImportProperties(projectMetadataInstances);
 
diff --git a/src/Build/Instance/ProjectMetadataInstance.cs b/src/Build/Instance/ProjectMetadataInstance.cs
index 15136b19c1d..26dba1a47be 100644
--- a/src/Build/Instance/ProjectMetadataInstance.cs
+++ b/src/Build/Instance/ProjectMetadataInstance.cs
@@ -134,6 +134,8 @@ string IKeyed.Key
             { return Name; }
         }
 
+        internal string Key => ((IKeyed)this).Key;
+
         /// <summary>
         /// Implementation of IValued
         /// </summary>
@@ -145,6 +147,8 @@ string IValued.EscapedValue
             { return EvaluatedValueEscaped; }
         }
 
+        internal string EscapedValue => ((IValued)this).EscapedValue;
+
         /// <summary>
         /// Evaluated and escaped value of the metadata.
         /// Never null.
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index b28ac113cd2..89d87896e85 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -80,9 +80,6 @@
     <Compile Include="..\Shared\CanonicalError.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\CanonicalError.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\IConstrainedEqualityComparer.cs">
-      <Link>IConstrainedEqualityComparer.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\PropertyParser.cs">
       <Link>BackEnd\Components\RequestBuilder\IntrinsicTasks\PropertyParser.cs</Link>
     </Compile>
@@ -375,11 +372,7 @@
     <Compile Include="Collections\ConcurrentStackExtensions.cs" />
     <Compile Include="Collections\ConvertingEnumerable.cs" />
     <Compile Include="Collections\CopyOnReadEnumerable.cs" />
-    <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
-      <Link>Collections\CopyOnWriteDictionary.cs</Link>
-    </Compile>
     <Compile Include="Collections\CopyOnWritePropertyDictionary.cs" />
-    <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="Collections\HashTableUtility.cs" />
     <Compile Include="Collections\IConstrainableDictionary.cs" />
     <Compile Include="Collections\ICopyOnWritePropertyDictionary.cs" />
diff --git a/src/Shared/CopyOnWriteDictionary.cs b/src/Framework/CopyOnWriteDictionary.cs
similarity index 98%
rename from src/Shared/CopyOnWriteDictionary.cs
rename to src/Framework/CopyOnWriteDictionary.cs
index b48401b964f..9f4d487f8da 100644
--- a/src/Shared/CopyOnWriteDictionary.cs
+++ b/src/Framework/CopyOnWriteDictionary.cs
@@ -108,6 +108,11 @@ public CopyOnWriteDictionary(IDictionary<string, V> dictionary)
             _backing = dictionary.ToImmutableDictionary();
         }
 
+        public CopyOnWriteDictionary(ImmutableDictionary<string, V> dictionary)
+        {
+            _backing = dictionary;
+        }
+
         /// <summary>
         /// Returns the collection of keys in the dictionary.
         /// </summary>
@@ -389,5 +394,7 @@ public void GetObjectData(SerializationInfo info, StreamingContext context)
             info.AddValue(nameof(_backing), array);
             info.AddValue(nameof(Comparer), Comparer);
         }
+
+        internal ImmutableDictionary<string, V> ToImmutableDictionary() => _backing;
     }
 }
diff --git a/src/Shared/IConstrainedEqualityComparer.cs b/src/Framework/IConstrainedEqualityComparer.cs
similarity index 89%
rename from src/Shared/IConstrainedEqualityComparer.cs
rename to src/Framework/IConstrainedEqualityComparer.cs
index c66dc8925f1..04ad75b4082 100644
--- a/src/Shared/IConstrainedEqualityComparer.cs
+++ b/src/Framework/IConstrainedEqualityComparer.cs
@@ -11,7 +11,11 @@ namespace Microsoft.Build.Collections
     ///     Defines methods to support the comparison of objects for
     ///     equality over constrained inputs.
     /// </summary>
+#if TASKHOST
+    internal interface IConstrainedEqualityComparer<T> : IEqualityComparer<T>
+#else
     internal interface IConstrainedEqualityComparer<in T> : IEqualityComparer<T>
+#endif
     {
         /// <summary>
         /// Determines whether the specified objects are equal, factoring in the specified bounds when comparing <paramref name="y"/>.
diff --git a/src/Framework/IMetadataContainer.cs b/src/Framework/IMetadataContainer.cs
index cc6588f9839..d52b1a761c8 100644
--- a/src/Framework/IMetadataContainer.cs
+++ b/src/Framework/IMetadataContainer.cs
@@ -12,6 +12,8 @@ namespace Microsoft.Build.Framework
     /// </summary>
     internal interface IMetadataContainer
     {
+        int CustomMetadataCount { get; }
+
         /// <summary>
         /// Returns a list of metadata names and unescaped values, including
         /// metadata from item definition groups, but not including built-in
@@ -32,5 +34,7 @@ internal interface IMetadataContainer
         /// to be unique and values are assumed to be escaped.
         /// </param>
         void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata);
+
+        bool HasSameBackingCollection(ICollection<KeyValuePair<string, string>> backingCollection);
     }
 }
diff --git a/src/Shared/MSBuildNameIgnoreCaseComparer.cs b/src/Framework/MSBuildNameIgnoreCaseComparer.cs
similarity index 92%
rename from src/Shared/MSBuildNameIgnoreCaseComparer.cs
rename to src/Framework/MSBuildNameIgnoreCaseComparer.cs
index e8e9a65b9eb..bb3f37887aa 100644
--- a/src/Shared/MSBuildNameIgnoreCaseComparer.cs
+++ b/src/Framework/MSBuildNameIgnoreCaseComparer.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -22,7 +23,7 @@ internal class MSBuildNameIgnoreCaseComparer : IConstrainedEqualityComparer<stri
         /// <summary>
         /// The processor architecture on which we are running, but default it will be x86
         /// </summary>
-        private static readonly NativeMethodsShared.ProcessorArchitectures s_runningProcessorArchitecture = NativeMethodsShared.ProcessorArchitecture;
+        private static readonly NativeMethods.ProcessorArchitectures s_runningProcessorArchitecture = NativeMethods.ProcessorArchitecture;
 
         /// <summary>
         /// The default immutable comparer instance.
@@ -46,12 +47,12 @@ public bool Equals(string compareToString, string constrainedString, int start,
         {
             if (lengthToCompare < 0)
             {
-                ErrorUtilities.ThrowInternalError("Invalid lengthToCompare '{0}' {1} {2}", constrainedString, start, lengthToCompare);
+                EscapeHatches.ThrowInternalError("Invalid lengthToCompare '{0}' {1} {2}", constrainedString, start, lengthToCompare);
             }
 
             if (start < 0 || start > (constrainedString?.Length ?? 0) - lengthToCompare)
             {
-                ErrorUtilities.ThrowInternalError("Invalid start '{0}' {1} {2}", constrainedString, start, lengthToCompare);
+                EscapeHatches.ThrowInternalError("Invalid start '{0}' {1} {2}", constrainedString, start, lengthToCompare);
             }
 
             if (ReferenceEquals(compareToString, constrainedString))
@@ -72,8 +73,8 @@ public bool Equals(string compareToString, string constrainedString, int start,
                 return false;
             }
 
-            if ((s_runningProcessorArchitecture != NativeMethodsShared.ProcessorArchitectures.IA64)
-                && (s_runningProcessorArchitecture != NativeMethodsShared.ProcessorArchitectures.ARM))
+            if ((s_runningProcessorArchitecture != NativeMethods.ProcessorArchitectures.IA64)
+                && (s_runningProcessorArchitecture != NativeMethods.ProcessorArchitectures.ARM))
             {
                 // The use of unsafe here is quite a bit faster than the regular
                 // mechanism in the BCL. This is because we can make assumptions
@@ -120,8 +121,8 @@ public int GetHashCode(string obj, int start, int length)
                 return 0; // per BCL convention
             }
 
-            if ((s_runningProcessorArchitecture != NativeMethodsShared.ProcessorArchitectures.IA64)
-                && (s_runningProcessorArchitecture != NativeMethodsShared.ProcessorArchitectures.ARM))
+            if ((s_runningProcessorArchitecture != NativeMethods.ProcessorArchitectures.IA64)
+                && (s_runningProcessorArchitecture != NativeMethods.ProcessorArchitectures.ARM))
             {
                 unsafe
                 {
diff --git a/src/Framework/TaskItemData.cs b/src/Framework/TaskItemData.cs
index 48c3410d7d8..992e11a0dfa 100644
--- a/src/Framework/TaskItemData.cs
+++ b/src/Framework/TaskItemData.cs
@@ -21,6 +21,8 @@ internal class TaskItemData : ITaskItem, IMetadataContainer
         public string ItemSpec { get; set; }
         public IDictionary<string, string> Metadata { get; }
 
+        int IMetadataContainer.CustomMetadataCount => Metadata.Count;
+
         public TaskItemData(string itemSpec, IDictionary<string, string> metadata)
         {
             ItemSpec = itemSpec;
@@ -89,5 +91,7 @@ public override string ToString()
         {
             return $"{ItemSpec} Metadata: {MetadataCount}";
         }
+
+        public bool HasSameBackingCollection(ICollection<KeyValuePair<string, string>> backingCollection) => false;
     }
 }
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 2edca8c339b..541f1fa5bf0 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -76,9 +76,6 @@
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <Link>FileUtilitiesRegex.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\IConstrainedEqualityComparer.cs">
-      <Link>IConstrainedEqualityComparer.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\QuotingUtilities.cs" />
     <Compile Include="..\Shared\RegisteredTaskObjectCacheBase.cs">
       <Link>RegisteredTaskObjectCacheBase.cs</Link>
@@ -89,9 +86,7 @@
     <Compile Include="..\Shared\Modifiers.cs" />
     <Compile Include="..\Shared\XMakeElements.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
-    <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\IKeyed.cs" />
-    <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="..\Shared\NamedPipeUtil.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index a189f58567a..479c7d03875 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -66,7 +66,7 @@
     <Compile Include="..\Framework\ResponseFileUsedEventArgs.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CollectionHelpers.cs" />
-    <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
+    <Compile Include="..\Framework\CopyOnWriteDictionary.cs">
       <Link>CopyOnWriteDictionary.cs</Link>
     </Compile>
     <Compile Include="..\Shared\Constants.cs" />
@@ -220,6 +220,8 @@
     <Compile Include="..\Shared\TaskHostTaskCancelled.cs" />
     <Compile Include="..\Shared\TaskParameter.cs" />
     <Compile Include="..\Shared\AssemblyNameExtension.cs" />
+    <Compile Include="..\Framework\IConstrainedEqualityComparer.cs" />
+    <Compile Include="..\Framework\MSBuildNameIgnoreCaseComparer.cs" />
 
     <Compile Include="..\Shared\FileSystem\IFileSystem.cs" />
     <Compile Include="..\Shared\FileSystem\FileSystems.cs" />
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 3e436da8c38..023316ef12c 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -811,6 +811,8 @@ public int MetadataCount
                 }
             }
 
+            public int CustomMetadataCount => _customEscapedMetadata?.Count ?? 0;
+
             /// <summary>
             /// Returns the escaped version of this item's ItemSpec
             /// </summary>
@@ -1038,6 +1040,8 @@ public void ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
                     SetMetadata(kvp.Key, kvp.Value);
                 }
             }
+
+            public bool HasSameBackingCollection(ICollection<KeyValuePair<string, string>> backingCollection) => false;
         }
     }
 }
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 9e3b0c07d36..65677a311e5 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Globalization;
@@ -9,6 +10,7 @@
 using System.Linq;
 using System.Reflection;
 using System.Runtime.Versioning;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -2585,6 +2587,9 @@ internal void GetReferenceItems(
             var scatterItems = new List<ITaskItem>();
             var copyLocalItems = new List<ITaskItem>();
 
+            // Cache shared source items to avoid enumerating slow ProjectItemInstance.TaskItem.
+            Dictionary<ITaskItem, TaskItem> referenceMetadataCache = new(ITaskItemComparer.Default);
+
             foreach (KeyValuePair<AssemblyNameExtension, Reference> kvp in References)
             {
                 AssemblyNameExtension assemblyName = kvp.Key;
@@ -2618,7 +2623,7 @@ internal void GetReferenceItems(
 
                 if (reference.IsResolved)
                 {
-                    ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, assemblyName.FullName, reference, assemblyName);
+                    ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, assemblyName.FullName, reference, assemblyName, referenceMetadataCache);
 
                     if (reference.IsPrimary)
                     {
@@ -2659,7 +2664,15 @@ internal void GetReferenceItems(
         /// <summary>
         /// Set metadata on the items which will be output from RAR.
         /// </summary>
-        private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem> satelliteItems, List<ITaskItem> serializationAssemblyItems, List<ITaskItem> scatterItems, string fusionName, Reference reference, AssemblyNameExtension assemblyName)
+        private ITaskItem SetItemMetadata(
+            List<ITaskItem> relatedItems,
+            List<ITaskItem> satelliteItems,
+            List<ITaskItem> serializationAssemblyItems,
+            List<ITaskItem> scatterItems,
+            string fusionName,
+            Reference reference,
+            AssemblyNameExtension assemblyName,
+            Dictionary<ITaskItem, TaskItem> referenceMetadataCache)
         {
             // Set up the main item.
             TaskItem referenceItem = new TaskItem();
@@ -2690,7 +2703,15 @@ private ITaskItem SetItemMetadata(List<ITaskItem> relatedItems, List<ITaskItem>
                 ICollection<ITaskItem> sourceItems = reference.GetSourceItems();
                 foreach (ITaskItem sourceItem in sourceItems)
                 {
-                    sourceItem.CopyMetadataTo(referenceItem);
+                    // Source items are shared between references. ProjectItemInstance.TaskItem is expensive to enumerate as it always
+                    // creates a new backing collection. Cache the result in a Utilities.TaskItem.instead.
+                    if (!referenceMetadataCache.TryGetValue(sourceItem, out TaskItem clonedItem))
+                    {
+                        clonedItem = new TaskItem(sourceItem);
+                        referenceMetadataCache[sourceItem] = clonedItem;
+                    }
+
+                    clonedItem.CopyMetadataTo(referenceItem);
                 }
 
                 // If the item originally did not have the implementation file metadata then we do not want to get it from the set of primary source items
@@ -3222,5 +3243,14 @@ internal AssemblyNameExtension GetImmutableFileAssemblyName(string path)
                 ? assemblyNameExtension
                 : null;
         }
+
+        private class ITaskItemComparer : IEqualityComparer<ITaskItem>
+        {
+            internal static ITaskItemComparer Default = new();
+
+            public bool Equals(ITaskItem first, ITaskItem second) => ReferenceEquals(first, second);
+
+            public int GetHashCode(ITaskItem value) => value.GetHashCode();
+        }
     }
 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 37d7cece260..8af4aa917da 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -66,14 +66,12 @@
     <Compile Include="CombineTargetFrameworkInfoProperties.cs" />
     <Compile Include="CombineXmlElements.cs" />
     <Compile Include="ConvertToAbsolutePath.cs" />
-    <Compile Include="..\Shared\CopyOnWriteDictionary.cs" />
     <Compile Include="..\Shared\ExtensionFoldersRegistryKey.cs">
       <Link>ExtensionFoldersRegistryKey.cs</Link>
     </Compile>
     <Compile Include="..\Shared\FileDelegates.cs">
       <Link>FileDelegates.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\IConstrainedEqualityComparer.cs" />
     <Compile Include="..\Shared\PropertyParser.cs">
       <Link>PropertyParser.cs</Link>
     </Compile>
@@ -118,7 +116,6 @@
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Modifiers.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs" />
     <Compile Include="..\Shared\ReadOnlyCollection.cs" />
     <Compile Include="..\Shared\ReadOnlyEmptyDictionary.cs" />
     <Compile Include="..\Shared\Tracing.cs" />
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index e5a0a89b595..48e5dc46173 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -60,9 +60,6 @@
     <Compile Include="..\Shared\FileDelegates.cs">
       <Link>Shared\FileDelegates.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
-      <Link>Shared\CopyOnWriteDictionary.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\ErrorUtilities.cs">
       <Link>Shared\ErrorUtilities.cs</Link>
     </Compile>
@@ -87,15 +84,9 @@
     <Compile Include="..\Shared\FrameworkLocationHelper.cs">
       <Link>Shared\FrameworkLocationHelper.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\IConstrainedEqualityComparer.cs">
-      <Link>Shared\IConstrainedEqualityComparer.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\IKeyed.cs">
       <Link>Shared\IKeyed.cs</Link>
     </Compile>
-    <Compile Include="..\Shared\MSBuildNameIgnoreCaseComparer.cs">
-      <Link>Shared\MSBuildNameIgnoreCaseComparer.cs</Link>
-    </Compile>
     <Compile Include="..\Shared\Modifiers.cs">
       <Link>Shared\Modifiers.cs</Link>
     </Compile>
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index d43175b77aa..a1e3bf97b75 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -232,6 +232,8 @@ public ICollection MetadataNames
         /// <value>Count of metadata.</value>
         public int MetadataCount => (_metadata?.Count ?? 0) + FileUtilities.ItemSpecModifiers.All.Length;
 
+        int IMetadataContainer.CustomMetadataCount => _metadata?.Count ?? 0;
+
         /// <summary>
         /// Gets the metadata dictionary
         /// Property is required so that we can access the metadata dictionary in an item from
@@ -322,51 +324,21 @@ public void CopyMetadataTo(ITaskItem destinationItem)
 
             if (_metadata != null)
             {
-                if (destinationItem is TaskItem destinationAsTaskItem)
+                if (destinationItem is TaskItem destinationAsUtilitiesTaskItem)
                 {
-                    CopyOnWriteDictionary<string> copiedMetadata;
-                    // Avoid a copy if we can, and if not, minimize the number of items we have to set.
-                    if (destinationAsTaskItem.Metadata == null)
-                    {
-                        copiedMetadata = _metadata.Clone(); // Copy on write!
-                    }
-                    else if (destinationAsTaskItem.Metadata.Count < _metadata.Count)
-                    {
-                        copiedMetadata = _metadata.Clone(); // Copy on write!
-                        copiedMetadata.SetItems(destinationAsTaskItem.Metadata.Where(entry => !String.IsNullOrEmpty(entry.Value)));
-                    }
-                    else
-                    {
-                        copiedMetadata = destinationAsTaskItem.Metadata.Clone();
-                        copiedMetadata.SetItems(_metadata.Where(entry => !destinationAsTaskItem.Metadata.TryGetValue(entry.Key, out string val) || String.IsNullOrEmpty(val)));
-                    }
-                    destinationAsTaskItem.Metadata = copiedMetadata;
+                    CopyToUtilitiesTaskItem(destinationAsUtilitiesTaskItem);
+                }
+                else if (destinationItem is IMetadataContainer destinationAsMetadataContainer)
+                {
+                    CopyToMetadataContainer(destinationItem, destinationAsMetadataContainer);
+                }
+                else if (destinationAsITaskItem2 != null)
+                {
+                    CopyToTaskItem2(destinationAsITaskItem2);
                 }
                 else
                 {
-                    foreach (KeyValuePair<string, string> entry in _metadata)
-                    {
-                        string value;
-
-                        if (destinationAsITaskItem2 != null)
-                        {
-                            value = destinationAsITaskItem2.GetMetadataValueEscaped(entry.Key);
-
-                            if (string.IsNullOrEmpty(value))
-                            {
-                                destinationAsITaskItem2.SetMetadata(entry.Key, entry.Value);
-                            }
-                        }
-                        else
-                        {
-                            value = destinationItem.GetMetadata(entry.Key);
-
-                            if (string.IsNullOrEmpty(value))
-                            {
-                                destinationItem.SetMetadata(entry.Key, EscapingUtilities.Escape(entry.Value));
-                            }
-                        }
-                    }
+                    CopyToTaskItem(destinationItem);
                 }
             }
 
@@ -381,6 +353,79 @@ public void CopyMetadataTo(ITaskItem destinationItem)
                     destinationItem.SetMetadata("OriginalItemSpec", EscapingUtilities.Escape(ItemSpec));
                 }
             }
+
+            void CopyToUtilitiesTaskItem(TaskItem destinationItem)
+            {
+                CopyOnWriteDictionary<string> copiedMetadata;
+
+                // Avoid a copy if we can, and if not, minimize the number of items we have to set.
+                if (destinationItem.Metadata == null)
+                {
+                    copiedMetadata = _metadata.Clone(); // Copy on write!
+                }
+                else if (destinationItem.Metadata.Count < _metadata.Count)
+                {
+                    copiedMetadata = _metadata.Clone(); // Copy on write!
+                    copiedMetadata.SetItems(destinationItem.Metadata.Where(entry =>
+                        !string.IsNullOrEmpty(entry.Value)));
+                }
+                else
+                {
+                    copiedMetadata = destinationItem.Metadata.Clone();
+                    copiedMetadata.SetItems(_metadata.Where(entry =>
+                        !destinationItem.Metadata.TryGetValue(entry.Key, out string val) || string.IsNullOrEmpty(val)));
+                }
+
+                destinationItem.Metadata = copiedMetadata;
+            }
+
+            void CopyToMetadataContainer(ITaskItem destinationItem, IMetadataContainer destinationMetadata)
+            {
+                if (destinationMetadata.CustomMetadataCount == 0)
+                {
+                    destinationMetadata.ImportMetadata(_metadata);
+                    return;
+                }
+                else if (destinationMetadata.HasSameBackingCollection(_metadata))
+                {
+                    return;
+                }
+
+                IEnumerable<KeyValuePair<string, string>> metadataToImport = destinationItem is ITaskItem2 destinationAsITaskItem2
+                    ? _metadata.Where(entry => string.IsNullOrEmpty(destinationAsITaskItem2.GetMetadataValueEscaped(entry.Key)))
+                    : _metadata.Where(entry => string.IsNullOrEmpty(destinationItem.GetMetadata(entry.Key)));
+
+#if FEATURE_APPDOMAIN
+                if (!AppDomain.CurrentDomain.IsDefaultAppDomain())
+                {
+                    // Linq is not serializable so materialize the collection before making the call.
+                    metadataToImport = [.. metadataToImport];
+                }
+#endif
+                destinationMetadata.ImportMetadata(metadataToImport);
+            }
+
+            void CopyToTaskItem2(ITaskItem2 destinationItem)
+            {
+                foreach (KeyValuePair<string, string> entry in _metadata)
+                {
+                    if (string.IsNullOrEmpty(destinationAsITaskItem2.GetMetadataValueEscaped(entry.Key)))
+                    {
+                        destinationAsITaskItem2.SetMetadata(entry.Key, entry.Value);
+                    }
+                }
+            }
+
+            void CopyToTaskItem(ITaskItem destinationItem)
+            {
+                foreach (KeyValuePair<string, string> entry in _metadata)
+                {
+                    if (string.IsNullOrEmpty(destinationItem.GetMetadata(entry.Key)))
+                    {
+                        destinationItem.SetMetadata(entry.Key, EscapingUtilities.Escape(entry.Value));
+                    }
+                }
+            }
         }
 
         /// <summary>
@@ -504,6 +549,12 @@ IEnumerable<KeyValuePair<string, string>> IMetadataContainer.EnumerateMetadata()
 
         void IMetadataContainer.ImportMetadata(IEnumerable<KeyValuePair<string, string>> metadata)
         {
+            if (_metadata == null && metadata is CopyOnWriteDictionary<string> copyOnWriteDictionary)
+            {
+                _metadata = copyOnWriteDictionary.Clone();
+                return;
+            }
+
             _metadata ??= new CopyOnWriteDictionary<string>(MSBuildNameIgnoreCaseComparer.Default);
             _metadata.SetItems(metadata.Select(kvp => new KeyValuePair<string, string>(kvp.Key, kvp.Value ?? string.Empty)));
         }
@@ -540,5 +591,19 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataLazy()
                 yield return unescaped;
             }
         }
+
+        bool IMetadataContainer.HasSameBackingCollection(ICollection<KeyValuePair<string, string>> backingCollection)
+        {
+            if (_metadata == null)
+            {
+                return backingCollection == null;
+            }
+            else if (backingCollection is CopyOnWriteDictionary<string> copyOnWriteDictionary)
+            {
+                return _metadata.HasSameBacking(copyOnWriteDictionary);
+            }
+
+            return false;
+        }
     }
 }
