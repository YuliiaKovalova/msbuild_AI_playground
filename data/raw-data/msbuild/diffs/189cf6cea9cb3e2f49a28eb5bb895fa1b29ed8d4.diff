diff --git a/.vsts-dotnet-ci.yml b/.vsts-dotnet-ci.yml
index 83ea156bfaf..dce7ac92550 100644
--- a/.vsts-dotnet-ci.yml
+++ b/.vsts-dotnet-ci.yml
@@ -228,47 +228,6 @@ jobs:
     continueOnError: true
     condition: always()
 
-- job: MonoOnMac
-  # Mono CI disabled until it can parse C# 9 syntax: https://github.com/dotnet/msbuild/issues/6058
-  condition: eq(1,2)
-  displayName: "macOS Mono"
-  pool:
-    vmImage: 'macOS-10.14'
-  steps:
-  # https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted?view=azure-devops&tabs=yaml#mono
-  - bash: |
-      SYMLINK=6_4_2
-      MONOPREFIX=/Library/Frameworks/Mono.framework/Versions/$SYMLINK
-      echo "##vso[task.setvariable variable=DYLD_FALLBACK_LIBRARY_PATH;]$MONOPREFIX/lib:/lib:/usr/lib:$DYLD_LIBRARY_FALLBACK_PATH"
-      echo "##vso[task.setvariable variable=PKG_CONFIG_PATH;]$MONOPREFIX/lib/pkgconfig:$MONOPREFIX/share/pkgconfig:$PKG_CONFIG_PATH"
-      echo "##vso[task.setvariable variable=PATH;]$MONOPREFIX/bin:$PATH"
-    displayName: Use Mono 6.4.2
-  - bash: 'eng/cibuild_bootstrapped_msbuild.sh --host_type mono /p:SuppressLicenseValidation=true'
-    displayName: CI Build
-  - task: PublishTestResults@2
-    displayName: Publish Mono Test Results
-    inputs:
-      testRunTitle: 'macOS Mono'
-      testRunner: XUnit
-      testResultsFiles: 'artifacts/TestResults/Debug-MONO/*UnitTests*.xml'
-      publishRunAttachments: true
-      mergeTestResults: true
-    continueOnError: true
-    condition: always()
-  - task: PublishBuildArtifacts@1
-    displayName: 'Publish Artifact: logs'
-    inputs:
-      PathtoPublish: 'artifacts/log'
-      ArtifactName: 'MonoOnMac build logs'
-    condition: always()
-  - task: PublishBuildArtifacts@1
-    displayName: 'Publish Artifact: TestResults'
-    inputs:
-      PathtoPublish: 'artifacts/TestResults'
-      ArtifactName: 'MonoOnMac test logs'
-    continueOnError: true
-    condition: always()
-
 - template: /eng/common/templates/job/source-build.yml
   parameters:
     platform:
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 0faa9a25dbc..966fea17b1e 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -6,13 +6,13 @@
       <Sha>249a53452a198b19cf6d3ac90ad25265ee77ee59</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.1.0-preview.1.47">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.1.0-preview.1.62">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>c14b85a00c03933c708c7d38fefeda9898a21488</Sha>
+      <Sha>9187a50daec29061772a2057490697c6c0e4c354</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.1.0-2.21574.9">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.1.0-2.21605.2">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>16333a806a64c3546faf0320063b66ff32936eaa</Sha>
+      <Sha>f8ef87e10cb633f07803b5b5abee1ceaa4efc2fb</Sha>
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.21573.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
diff --git a/eng/Versions.props b/eng/Versions.props
index 221ff51f5c4..11e6ece3772 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -34,8 +34,8 @@
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.21573.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.1.0-2.21574.9</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.1.0-preview.1.47</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.1.0-2.21605.2</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.1.0-preview.1.62</NuGetBuildTasksVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
     <!-- See https://github.com/dotnet/arcade/issues/3386
diff --git a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
index 4ac69f51f4f..ebbec93cd53 100644
--- a/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingServicesLogMethod_Tests.cs
@@ -19,6 +19,7 @@
 
 using MockHost = Microsoft.Build.UnitTests.BackEnd.MockHost;
 using Xunit;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.Logging
 {
@@ -54,6 +55,7 @@ public void LogBuildEventNullEvent()
             }
            );
         }
+
         /// <summary>
         /// Test LogBuildevent by logging a number of events with both OnlyLogCriticalEvents On and Off
         /// </summary>
@@ -104,6 +106,7 @@ public void LogErrorNullMessageResource()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternlErrorException is thrown when an empty MessageResourceName is passed in.
         /// </summary>
@@ -117,6 +120,7 @@ public void LogErrorEmptyMessageResource()
             }
            );
         }
+
         /// <summary>
         /// Verify a message is logged when all of the parameters are filled out correctly.
         /// </summary>
@@ -154,6 +158,7 @@ public void LogInvalidProjectFileErrorNullEventContext()
             }
            );
         }
+
         /// <summary>
         /// Verify an exception is thrown when a null Invalid ProjectFile exception is passed in
         /// </summary>
@@ -167,6 +172,7 @@ public void LogInvalidProjectFileErrorNullException()
             }
            );
         }
+
         /// <summary>
         /// Verify a message is logged when both parameters are good and
         /// the exception has not been logged yet. Verify with and without OnlyLogCriticalEvents.
@@ -215,6 +221,7 @@ public void LogFatalErrorNullContext()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when fileInfo is null
         /// </summary>
@@ -228,6 +235,7 @@ public void LogFatalErrorNullFileInfo()
             }
            );
         }
+
         /// <summary>
         /// Verify a error message is correctly logged when  the exception is null.
         /// </summary>
@@ -260,6 +268,7 @@ public void LogFatalErrorNullMessageResourceName()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when messageResourceName is empty
         /// </summary>
@@ -274,6 +283,7 @@ public void LogFatalErrorEmptyMessageResourceName()
             }
            );
         }
+
         /// <summary>
         /// Verify a error message is correctly logged when all of the inputs are valid.
         /// </summary>
@@ -334,6 +344,7 @@ public void LogFatalTaskErrorNullTaskNameName()
             }
            );
         }
+
         /// <summary>
         /// Verify a error message is correctly logged when all of the inputs are valid.
         /// </summary>
@@ -374,6 +385,7 @@ public void LogErrorFromTextNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException when a null FileInfo is passed in
         /// </summary>
@@ -387,6 +399,7 @@ public void LogErrorFromTextNullFileInfo()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when a null message is passed in
         /// </summary>
@@ -400,6 +413,7 @@ public void LogErrorFromTextNullMessage()
             }
            );
         }
+
         /// <summary>
         /// Test LogErrorFromText with a number of different inputs
         /// </summary>
@@ -509,6 +523,7 @@ public void LogTaskWarningFromExceptionNullTaskName()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when taskName is empty
         /// </summary>
@@ -523,6 +538,7 @@ public void LogTaskWarningFromExceptionEmptyTaskName()
             }
            );
         }
+
         /// <summary>
         /// Verify a LogTaskWarningFromException with a null exception and a non null exception
         /// with all of the other fields properly filled out.
@@ -566,6 +582,7 @@ public void LogWarningNullMessageResource()
             }
            );
         }
+
         /// <summary>
         /// Verify an exception is when a empty MessageResourceName is passed in.
         /// </summary>
@@ -579,6 +596,7 @@ public void LogWarningEmptyMessageResource()
             }
            );
         }
+
         /// <summary>
         /// Verify a message is logged when all of the parameters are filled out
         /// </summary>
@@ -606,6 +624,7 @@ public void LogWarningFromTextNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when a null fileInfo is passed in
         /// </summary>
@@ -619,6 +638,7 @@ public void LogWarningFromTextNullFileInfo()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when a null message is passed in
         /// </summary>
@@ -632,6 +652,7 @@ public void LogWarningFromTextNullMessage()
             }
            );
         }
+
         /// <summary>
         /// Test LogWarningFromText with a number of different inputs
         /// </summary>
@@ -676,6 +697,7 @@ public void LogCommentNullMessageResourceName()
             }
            );
         }
+
         /// <summary>
         /// Verify an InternalErrorException is thrown when a empty messageResource name is passed in
         /// </summary>
@@ -689,6 +711,7 @@ public void LogCommentEmptyMessageResourceName()
             }
            );
         }
+
         /// <summary>
         /// Verify LogComment by testing it with OnlyLogCriticalEvents On and Off when the rest of the fields are
         /// valid inputs.
@@ -729,6 +752,7 @@ public void LogCommentFromTextNullMessage()
             }
            );
         }
+
         /// <summary>
         /// Verify a message is logged when an empty message is passed in
         /// </summary>
@@ -752,6 +776,7 @@ public void LogCommentFromTextNullBuildEventContextMessage()
             }
            );
         }
+
         /// <summary>
         /// Make sure we can log a comment when everything should be working correctly
         /// </summary>
@@ -792,6 +817,7 @@ public void ProjectStartedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Expect an exception to be thrown if a null build event context is passed in
         /// and OnlyLogCriticalEvents is false
@@ -806,30 +832,157 @@ public void ProjectStartedNullParentBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the case where ProjectFile is good and TargetNames is null.
         /// Expect an event to be logged
         /// </summary>
+        [Theory]
+        [InlineData("ProjectFile", null)] // Good project File and null target names
+        [InlineData("ProjectFile", "")] // Good project File and empty target names
+        [InlineData(null, null)] // Null project file and null target names
+        [InlineData("", null)] // // Empty project file null target Names
+        [InlineData("", "")] // Empty project File and Empty target Names
+        [InlineData("ProjectFile", "TargetNames")] // Good inputs
+        public void ProjectStartedEventTests(string projectFile, string targetNames)
+        {
+            string message;
+            if (!String.IsNullOrEmpty(targetNames))
+            {
+                message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithTargetNames", Path.GetFileName(projectFile), targetNames);
+            }
+            else
+            {
+                message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", Path.GetFileName(projectFile));
+            }
+
+            MockHost componentHost = new MockHost();
+            ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1, componentHost);
+            ConfigCache cache = (ConfigCache)componentHost.GetComponent(BuildComponentType.ConfigCache);
+
+            BuildRequestData data = new BuildRequestData("file", new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase), "toolsVersion", new string[0], null);
+            BuildRequestConfiguration config = new BuildRequestConfiguration(2, data, "4.0");
+            cache.AddConfiguration(config);
+
+            BuildEventContext context = service.LogProjectStarted(s_buildEventContext, 1, 2, s_buildEventContext, projectFile, targetNames, null, null);
+            BuildEventContext parentBuildEventContext = s_buildEventContext;
+            VerifyProjectStartedEventArgs(service, context.ProjectContextId, message, projectFile, targetNames, parentBuildEventContext, context);
+
+            service.ResetProcessedBuildEvent();
+        }
+
+        /// <summary>
+        /// Expect the returned BuildEventContext to have the provided ProjectContextId
+        /// </summary>
+        [Fact]
+        public void ProjectStartedProvidedProjectContextId()
+        {
+            const int SubmissionId = 1;
+            const int EvaluationId = 2;
+            const int ConfigurationId = 3;
+            const string ProjectFile = "SomeProjectFile";
+
+            MockHost componentHost = new MockHost();
+            ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1, componentHost);
+            ConfigCache cache = (ConfigCache)componentHost.GetComponent(BuildComponentType.ConfigCache);
+
+            BuildRequestData data = new BuildRequestData(ProjectFile, new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase), "toolsVersion", Array.Empty<string>(), null);
+            BuildRequestConfiguration config = new BuildRequestConfiguration(ConfigurationId, data, "4.0");
+            cache.AddConfiguration(config);
+
+            BuildEventContext projectCacheBuildEventContext = service.CreateProjectCacheBuildEventContext(SubmissionId, EvaluationId, ConfigurationId, ProjectFile);
+            projectCacheBuildEventContext.NodeId.ShouldBe(Scheduler.InProcNodeId);
+            projectCacheBuildEventContext.ProjectContextId.ShouldNotBe(BuildEventContext.InvalidProjectContextId);
+
+            BuildEventContext nodeBuildEventContext = new BuildEventContext(Scheduler.InProcNodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+            BuildEventContext projectStartedBuildEventContext = service.LogProjectStarted(
+                nodeBuildEventContext,
+                submissionId: SubmissionId,
+                configurationId: ConfigurationId,
+                parentBuildEventContext: BuildEventContext.Invalid,
+                projectFile: ProjectFile,
+                targetNames: "TargetNames",
+                properties: null,
+                items: null,
+                evaluationId: EvaluationId,
+                projectContextId: projectCacheBuildEventContext.ProjectContextId);
+            projectStartedBuildEventContext.ProjectContextId.ShouldBe(projectCacheBuildEventContext.ProjectContextId);
+        }
+
+        /// <summary>
+        /// Expect an exception to be thrown if an unknown project context id is passed in for the in-proc node
+        /// </summary>
         [Fact]
-        public void ProjectStartedEventTests()
+        public void ProjectStartedProvidedUnknownProjectContextIdInProcNode()
         {
-            // Good project File and null target names
-            LogProjectStartedTestHelper("ProjectFile", null);
+            const int SubmissionId = 1;
+            const int EvaluationId = 2;
+            const int ConfigurationId = 3;
+            const string ProjectFile = "SomeProjectFile";
+            const int ProjectContextId = 123;
+
+            MockHost componentHost = new MockHost();
+            ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1, componentHost);
+            ConfigCache cache = (ConfigCache)componentHost.GetComponent(BuildComponentType.ConfigCache);
+
+            BuildRequestData data = new BuildRequestData(ProjectFile, new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase), "toolsVersion", Array.Empty<string>(), null);
+            BuildRequestConfiguration config = new BuildRequestConfiguration(ConfigurationId, data, "4.0");
+            cache.AddConfiguration(config);
+
+            BuildEventContext nodeBuildEventContext = new BuildEventContext(Scheduler.InProcNodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+            Assert.Throws<InternalErrorException>(() =>
+            {
+                service.LogProjectStarted(
+                    nodeBuildEventContext,
+                    submissionId: SubmissionId,
+                    configurationId: ConfigurationId,
+                    parentBuildEventContext: BuildEventContext.Invalid,
+                    projectFile: ProjectFile,
+                    targetNames: "TargetNames",
+                    properties: null,
+                    items: null,
+                    evaluationId: EvaluationId,
+                    projectContextId: ProjectContextId);
+            });
+        }
 
-            // Good project File and empty target names
-            LogProjectStartedTestHelper("ProjectFile", string.Empty);
+        /// <summary>
+        /// Expect an unknown project context id to be accepted on an out-of-proc node.
+        /// </summary>
+        [Fact]
+        public void ProjectStartedProvidedUnknownProjectContextIdOutOfProcNode()
+        {
+            const int SubmissionId = 1;
+            const int EvaluationId = 2;
+            const int ConfigurationId = 3;
+            const string ProjectFile = "SomeProjectFile";
+            const int NodeId = 2;
+            const int ProjectContextId = 123;
 
-            // Null project file and null target names
-            LogProjectStartedTestHelper(null, null);
+            // Ensure we didn't pick the one bad const value
+            NodeId.ShouldNotBe(Scheduler.InProcNodeId);
 
-            // Empty project file null target Names
-            LogProjectStartedTestHelper(string.Empty, null);
+            MockHost componentHost = new MockHost();
+            ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1, componentHost);
+            ConfigCache cache = (ConfigCache)componentHost.GetComponent(BuildComponentType.ConfigCache);
 
-            // Empty project File and Empty target Names
-            LogProjectStartedTestHelper(string.Empty, string.Empty);
+            BuildRequestData data = new BuildRequestData(ProjectFile, new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase), "toolsVersion", Array.Empty<string>(), null);
+            BuildRequestConfiguration config = new BuildRequestConfiguration(ConfigurationId, data, "4.0");
+            cache.AddConfiguration(config);
 
-            // TestGoodInputs
-            LogProjectStartedTestHelper("ProjectFile", "TargetNames");
+            BuildEventContext nodeBuildEventContext = new BuildEventContext(NodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+            BuildEventContext projectStartedBuildEventContext = service.LogProjectStarted(
+                nodeBuildEventContext,
+                submissionId: SubmissionId,
+                configurationId: ConfigurationId,
+                parentBuildEventContext: BuildEventContext.Invalid,
+                projectFile: ProjectFile,
+                targetNames: "TargetNames",
+                properties: null,
+                items: null,
+                evaluationId: EvaluationId,
+                projectContextId: ProjectContextId);
+            projectStartedBuildEventContext.ProjectContextId.ShouldBe(ProjectContextId);
         }
 
         #endregion
@@ -849,6 +1002,7 @@ public void ProjectFinishedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the project finished event
         /// </summary>
@@ -874,7 +1028,7 @@ public void ProjectFinished()
         public void LogBuildStarted()
         {
             ProcessBuildEventHelper service =
-                (ProcessBuildEventHelper) ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
+                (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
 
             service.LogBuildStarted();
 
@@ -885,7 +1039,7 @@ public void LogBuildStarted()
                     service.ProcessedBuildEvent.Timestamp);
 
             Assert.IsType<BuildStartedEventArgs>(service.ProcessedBuildEvent);
-            Assert.Equal(buildEvent, (BuildStartedEventArgs) service.ProcessedBuildEvent,
+            Assert.Equal(buildEvent, (BuildStartedEventArgs)service.ProcessedBuildEvent,
                 new EventArgsEqualityComparer<BuildStartedEventArgs>());
         }
 
@@ -896,7 +1050,7 @@ public void LogBuildStarted()
         public void LogBuildStartedCriticalOnly()
         {
             ProcessBuildEventHelper service =
-                (ProcessBuildEventHelper) ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
+                (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1);
             service.OnlyLogCriticalEvents = true;
             service.LogBuildStarted();
 
@@ -906,7 +1060,7 @@ public void LogBuildStartedCriticalOnly()
                     null /* no help keyword */);
 
             Assert.IsType<BuildStartedEventArgs>(service.ProcessedBuildEvent);
-            Assert.Equal(buildEvent, (BuildStartedEventArgs) service.ProcessedBuildEvent,
+            Assert.Equal(buildEvent, (BuildStartedEventArgs)service.ProcessedBuildEvent,
                 new EventArgsEqualityComparer<BuildStartedEventArgs>());
         }
 
@@ -965,6 +1119,7 @@ public void TaskStartedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the case where TaskName
         /// </summary>
@@ -1000,6 +1155,7 @@ public void TaskFinishedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the case where TaskName is null.
         /// </summary>
@@ -1040,6 +1196,7 @@ public void TargetStartedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the target started event with a null target name.
         /// </summary>
@@ -1088,6 +1245,7 @@ public void TargetFinishedNullBuildEventContext()
             }
            );
         }
+
         /// <summary>
         /// Test the case where TargetName is null.
         /// </summary>
@@ -1427,36 +1585,6 @@ private void TestTargetStartedWithParentTargetEvent(string targetName, string pr
             Assert.Null(service.ProcessedBuildEvent);
         }
 
-        /// <summary>
-        /// Test LogProjectStarted
-        /// </summary>
-        private void LogProjectStartedTestHelper(string projectFile, string targetNames)
-        {
-            string message;
-            if (!String.IsNullOrEmpty(targetNames))
-            {
-                message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithTargetNames", Path.GetFileName(projectFile), targetNames);
-            }
-            else
-            {
-                message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", Path.GetFileName(projectFile));
-            }
-
-            MockHost componentHost = new MockHost();
-            ProcessBuildEventHelper service = (ProcessBuildEventHelper)ProcessBuildEventHelper.CreateLoggingService(LoggerMode.Synchronous, 1, componentHost);
-            ConfigCache cache = (ConfigCache)componentHost.GetComponent(BuildComponentType.ConfigCache);
-
-            BuildRequestData data = new BuildRequestData("file", new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase), "toolsVersion", new string[0], null);
-            BuildRequestConfiguration config = new BuildRequestConfiguration(2, data, "4.0");
-            cache.AddConfiguration(config);
-
-            BuildEventContext context = service.LogProjectStarted(s_buildEventContext, 1, 2, s_buildEventContext, projectFile, targetNames, null, null);
-            BuildEventContext parentBuildEventContext = s_buildEventContext;
-            VerifyProjectStartedEventArgs(service, context.ProjectContextId, message, projectFile, targetNames, parentBuildEventContext, context);
-
-            service.ResetProcessedBuildEvent();
-        }
-
         /// <summary>
         /// Create a TargetFinished event to compare to the one which was passed into the ProcessedBuildEvent method.
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index 2d4ed73b93d..9dfc0009db4 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -474,9 +474,11 @@ public void LogBuildFinished(bool success)
 
         /// <inheritdoc />
         public BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId)
-        {
-            return new BuildEventContext(0, 0, 0, 0, 0, 0, 0);
-        }
+            => new BuildEventContext(0, 0, 0, 0, 0, 0, 0);
+
+        /// <inheritdoc />
+        public BuildEventContext CreateProjectCacheBuildEventContext(int submissionId, int evaluationId, int projectInstanceId, string projectFile)
+            => new BuildEventContext(0, 0, 0, 0, 0, 0, 0);
 
         /// <inheritdoc />
         public void LogProjectEvaluationStarted(BuildEventContext eventContext, string projectFile)
@@ -499,7 +501,17 @@ public void LogProjectEvaluationFinished(
         /// <summary>
         /// Logs a project started event
         /// </summary>
-        public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items, int evaluationId = BuildEventContext.InvalidEvaluationId)
+        public BuildEventContext LogProjectStarted(
+            BuildEventContext nodeBuildEventContext,
+            int submissionId,
+            int configurationId,
+            BuildEventContext parentBuildEventContext,
+            string projectFile,
+            string targetNames,
+            IEnumerable<DictionaryEntry> properties,
+            IEnumerable<DictionaryEntry> items,
+            int evaluationId = BuildEventContext.InvalidEvaluationId,
+            int projectContextId = BuildEventContext.InvalidProjectContextId)
         {
             return new BuildEventContext(0, 0, 0, 0);
         }
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index 50b4dd3b487..c4bd4727d4a 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -1,6 +1,7 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+using System.Collections.Generic;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Construction;
@@ -9,8 +10,12 @@
 using System.Xml;
 using Microsoft.Build.Framework;
 using System.IO;
+using System.Linq;
 using Xunit;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Collections;
+using Microsoft.Build.Execution;
+using Shouldly;
 
 namespace Microsoft.Build.UnitTests.OM.Instance
 {
@@ -19,6 +24,25 @@ namespace Microsoft.Build.UnitTests.OM.Instance
     /// </summary>
     public class TaskItem_Tests
     {
+        internal static readonly string[] s_builtInMetadataNames =
+        {
+            "FullPath",
+            "RootDir",
+            "Filename",
+            "Extension",
+            "RelativeDir",
+            "Directory",
+            "RecursiveDir",
+            "Identity",
+            "ModifiedTime",
+            "CreatedTime",
+            "AccessedTime",
+            "DefiningProjectFullPath",
+            "DefiningProjectDirectory",
+            "DefiningProjectName",
+            "DefiningProjectExtension"
+        };
+
         /// <summary>
         /// Test serialization
         /// </summary>
@@ -59,7 +83,7 @@ public void TestEquivalence()
             TaskItem right = new TaskItem("foo", "bar.proj");
 
             Assert.Equal(left, right);
-            Assert.Equal(left, right);
+            Assert.Equal(right, left);
         }
 
         /// <summary>
@@ -74,7 +98,7 @@ public void TestEquivalenceWithCustomMetadata()
             right.SetMetadata("a", "b");
 
             Assert.Equal(left, right);
-            Assert.Equal(left, right);
+            Assert.Equal(right, left);
         }
 
         /// <summary>
@@ -89,7 +113,7 @@ public void TestInequivalenceWithDifferentCustomMetadataValues()
             right.SetMetadata("a", "c");
 
             Assert.NotEqual(left, right);
-            Assert.NotEqual(left, right);
+            Assert.NotEqual(right, left);
         }
 
         /// <summary>
@@ -104,7 +128,7 @@ public void TestInequivalenceWithDifferentCustomMetadataKeys()
             right.SetMetadata("b", "b");
 
             Assert.NotEqual(left, right);
-            Assert.NotEqual(left, right);
+            Assert.NotEqual(right, left);
         }
 
         /// <summary>
@@ -118,7 +142,7 @@ public void TestInequivalenceWithDifferentCustomMetadataCount()
             TaskItem right = new TaskItem("foo", "bar.proj");
 
             Assert.NotEqual(left, right);
-            Assert.NotEqual(left, right);
+            Assert.NotEqual(right, left);
         }
 
         /// <summary>
@@ -134,7 +158,7 @@ public void TestInequivalenceWithDifferentCustomMetadataCount2()
             right.SetMetadata("c", "d");
 
             Assert.NotEqual(left, right);
-            Assert.NotEqual(left, right);
+            Assert.NotEqual(right, left);
         }
 
         /// <summary>
@@ -149,9 +173,65 @@ public void TestDeepClone()
 
             TaskItem clone = parent.DeepClone();
             Assert.True(parent.Equals(clone)); // "The parent and the clone should be equal"
+            Assert.True(clone.Equals(parent)); // "The parent and the clone should be equal"
             Assert.False(object.ReferenceEquals(parent, clone)); // "The parent and the child should not be the same object"
         }
 
+        /// <summary>
+        /// Validate the presentation of metadata on a TaskItem, both of direct values and those inherited from
+        /// item definitions.
+        /// </summary>
+        [Fact]
+        public void Metadata()
+        {
+            TaskItem item = BuildItem(
+                definitions: new[] { ("a", "base"), ("b", "base") },
+                metadata: new[] { ("a", "override") });
+
+            item.MetadataNames.Cast<string>().ShouldBeSetEquivalentTo(new[] { "a", "b" }.Concat(s_builtInMetadataNames));
+            item.MetadataCount.ShouldBe(s_builtInMetadataNames.Length + 2);
+            item.DirectMetadataCount.ShouldBe(1);
+
+            CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadata = item.MetadataCollection;
+            metadata.Count.ShouldBe(2);
+            metadata["a"].EvaluatedValue.ShouldBe("override");
+            metadata["b"].EvaluatedValue.ShouldBe("base");
+
+            item.EnumerateMetadata().ShouldBeSetEquivalentTo(new KeyValuePair<string, string>[] { new("a", "override"), new("b", "base") });
+
+            ((Dictionary<string, string>)item.CloneCustomMetadata()).ShouldBeSetEquivalentTo(new KeyValuePair<string, string>[] { new("a", "override"), new("b", "base") });
+
+            static TaskItem BuildItem(
+                IEnumerable<(string Name, string Value)> definitions = null,
+                IEnumerable<(string Name, string Value)> metadata = null)
+            {
+                List<ProjectItemDefinitionInstance> itemDefinitions = new();
+                if (definitions is not null)
+                {
+                    Project project = new();
+
+                    foreach ((string name, string value) in definitions)
+                    {
+                        ProjectItemDefinition projectItemDefinition = new ProjectItemDefinition(project, "MyItem");
+                        projectItemDefinition.SetMetadataValue(name, value);
+                        ProjectItemDefinitionInstance itemDefinition = new(projectItemDefinition);
+                        itemDefinitions.Add(itemDefinition);
+                    }
+                }
+
+                CopyOnWritePropertyDictionary<ProjectMetadataInstance> directMetadata = new();
+                if (metadata is not null)
+                {
+                    foreach ((string name, string value) in metadata)
+                    {
+                        directMetadata.Set(new(name, value));
+                    }
+                }
+
+                return new TaskItem("foo", "foo", directMetadata, itemDefinitions, "dir", immutable: false, "bar.proj");
+            }
+        }
+
         /// <summary>
         /// Flushing an item through a task should not mess up special characters on the metadata. 
         /// </summary>
@@ -196,7 +276,7 @@ public void Escaping1()
 
             Project project = new Project(xml);
             MockLogger logger = new MockLogger();
-            project.Build("Build", new ILogger[] { logger });
+            project.Build("Build", new ILogger[] { logger }).ShouldBeTrue();
 
             logger.AssertLogContains("[i1m1]");
             logger.AssertLogContains("[i1m2]");
@@ -253,7 +333,7 @@ public void Escaping2()
 
             Project project = new Project(xml);
             MockLogger logger = new MockLogger();
-            project.Build("Build", new ILogger[] { logger });
+            project.Build("Build", new ILogger[] { logger }).ShouldBeTrue();
 
             logger.AssertLogContains("[i1m1]");
             logger.AssertLogContains("[i1m2]");
@@ -291,7 +371,7 @@ public void Escaping3()
 
             Project project = new Project(xml);
             MockLogger logger = new MockLogger();
-            project.Build("Build", new ILogger[] { logger });
+            project.Build("Build", new ILogger[] { logger }).ShouldBeTrue();
 
             logger.AssertLogContains("i1%2ai2");
         }
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index c72968f4a76..4abd4c4929b 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1723,7 +1723,7 @@ private void HandleSubmissionException(GraphBuildSubmission submission, Exceptio
             }
         }
 
-        private static void AddBuildRequestToSubmission(BuildSubmission submission, int configurationId)
+        private static void AddBuildRequestToSubmission(BuildSubmission submission, int configurationId, int projectContextId = BuildEventContext.InvalidProjectContextId)
         {
             submission.BuildRequest = new BuildRequest(
                 submission.SubmissionId,
@@ -1731,17 +1731,23 @@ private static void AddBuildRequestToSubmission(BuildSubmission submission, int
                 configurationId,
                 submission.BuildRequestData.TargetNames,
                 submission.BuildRequestData.HostServices,
-                BuildEventContext.Invalid,
-                null,
+                parentBuildEventContext: BuildEventContext.Invalid,
+                parentRequest: null,
                 submission.BuildRequestData.Flags,
-                submission.BuildRequestData.RequestedProjectState)
+                submission.BuildRequestData.RequestedProjectState,
+                projectContextId: projectContextId)
             {
                 InputResultsCacheFiles = submission.BuildRequestData.InputResultsCacheFiles,
                 OutputResultsCacheFile = submission.BuildRequestData.OutputResultsCacheFile,
             };
         }
 
-        private static void AddProxyBuildRequestToSubmission(BuildSubmission submission, int configurationId, ProxyTargets proxyTargets)
+  
+      private static void AddProxyBuildRequestToSubmission(
+            BuildSubmission submission,
+            int configurationId,
+            ProxyTargets proxyTargets,
+            int projectContextId)
         {
             submission.BuildRequest = new BuildRequest(
                 submission.SubmissionId,
@@ -1750,7 +1756,8 @@ private static void AddProxyBuildRequestToSubmission(BuildSubmission submission,
                 proxyTargets,
                 submission.BuildRequestData.HostServices,
                 submission.BuildRequestData.Flags,
-                submission.BuildRequestData.RequestedProjectState)
+                submission.BuildRequestData.RequestedProjectState,
+                projectContextId)
             {
                 InputResultsCacheFiles = submission.BuildRequestData.InputResultsCacheFiles,
                 OutputResultsCacheFile = submission.BuildRequestData.OutputResultsCacheFile,
@@ -2426,7 +2433,7 @@ private BuildRequestConfiguration AddNewConfiguration(BuildRequestConfiguration
             return newConfiguration;
         }
 
-        internal void PostCacheResult(CacheRequest cacheRequest, CacheResult cacheResult)
+        internal void PostCacheResult(CacheRequest cacheRequest, CacheResult cacheResult, int projectContextId)
         {
             _workQueue.Post(() =>
             {
@@ -2451,14 +2458,14 @@ void HandleCacheResult()
                         if (cacheResult.ResultType != CacheResultType.CacheHit)
                         {
                             // Issue the real build request.
-                            AddBuildRequestToSubmission(submission, configuration.ConfigurationId);
+                            AddBuildRequestToSubmission(submission, configuration.ConfigurationId, projectContextId);
                             IssueBuildRequestForBuildSubmission(submission, configuration, allowMainThreadBuild: false);
                         }
                         else if (cacheResult.ResultType == CacheResultType.CacheHit && cacheResult.ProxyTargets != null)
                         {
                             // Setup submission.BuildRequest with proxy targets. The proxy request is built on the inproc node (to avoid
                             // ProjectInstance serialization). The proxy target results are used as results for the real targets.
-                            AddProxyBuildRequestToSubmission(submission, configuration.ConfigurationId, cacheResult.ProxyTargets);
+                            AddProxyBuildRequestToSubmission(submission, configuration.ConfigurationId, cacheResult.ProxyTargets, projectContextId);
                             IssueBuildRequestForBuildSubmission(submission, configuration, allowMainThreadBuild: false);
                         }
                         else if (cacheResult.ResultType == CacheResultType.CacheHit && cacheResult.BuildResult != null)
@@ -2466,7 +2473,7 @@ void HandleCacheResult()
                             // Mark the build submission as complete with the provided results and return.
 
                             // There must be a build request for the results, so fake one.
-                            AddBuildRequestToSubmission(submission, configuration.ConfigurationId);
+                            AddBuildRequestToSubmission(submission, configuration.ConfigurationId, projectContextId);
                             var result = new BuildResult(submission.BuildRequest);
 
                             foreach (var cacheResult in cacheResult.BuildResult.ResultsByTarget)
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index 096fb99283f..85538f7baa4 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -446,6 +446,16 @@ MessageImportance MinimumRequiredMessageImportance
         /// <returns></returns>
         BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId);
 
+        /// <summary>
+        /// Create a project cache context, by generating a new project context id.
+        /// </summary>
+        /// <param name="submissionId">The submission id</param>
+        /// <param name="evaluationId">The evaluation id</param>
+        /// <param name="projectInstanceId">The project instance id</param>
+        /// <param name="projectFile">Project file being built</param>
+        /// <returns></returns>
+        BuildEventContext CreateProjectCacheBuildEventContext(int submissionId, int evaluationId, int projectInstanceId, string projectFile);
+
         /// <summary>
         /// Logs that a project evaluation has started
         /// </summary>
@@ -477,15 +487,26 @@ void LogProjectEvaluationFinished(
         /// </summary>
         /// <param name="nodeBuildEventContext">The logging context of the node which is building this project.</param>
         /// <param name="submissionId">The id of the build submission.</param>
-        /// <param name="projectId">The id of the project instance which is about to start</param>
+        /// <param name="configurationId">The id of the project configuration which is about to start</param>
         /// <param name="parentBuildEventContext">The build context of the parent project which asked this project to build</param>
         /// <param name="projectFile">The project file path of the project about to be built</param>
         /// <param name="targetNames">The entrypoint target names for this project</param>
         /// <param name="properties">The initial properties of the project</param>
         /// <param name="items">The initial items of the project</param>
         /// <param name="evaluationId">EvaluationId of the project instance</param>
+        /// <param name="projectContextId">The project context id</param>
         /// <returns>The BuildEventContext to use for this project.</returns>
-        BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items, int evaluationId = BuildEventContext.InvalidEvaluationId);
+        BuildEventContext LogProjectStarted(
+            BuildEventContext nodeBuildEventContext,
+            int submissionId,
+            int configurationId,
+            BuildEventContext parentBuildEventContext,
+            string projectFile,
+            string targetNames,
+            IEnumerable<DictionaryEntry> properties,
+            IEnumerable<DictionaryEntry> items,
+            int evaluationId = BuildEventContext.InvalidEvaluationId,
+            int projectContextId = BuildEventContext.InvalidProjectContextId);
 
         /// <summary>
         /// Log that the project has finished
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index c5c3555f201..dcc79a8efcd 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -483,8 +483,28 @@ public void LogBuildFinished(bool success)
 
         /// <inheritdoc />
         public BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId)
+            => new BuildEventContext(submissionId, nodeId, NextEvaluationId, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+
+        /// <inheritdoc />
+        public BuildEventContext CreateProjectCacheBuildEventContext(
+            int submissionId,
+            int evaluationId,
+            int projectInstanceId,
+            string projectFile)
         {
-            return new BuildEventContext(submissionId, nodeId, NextEvaluationId, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+            lock (_lockObject)
+            {
+                int projectContextId = NextProjectId;
+
+                // In the future if some LogProjectCacheStarted event is created, move this there to align with evaluation and build execution.
+                _projectFileMap[projectContextId] = projectFile;
+
+                // Because the project cache runs in the BuildManager, it makes some sense to associate logging with the in-proc node.
+                // If a invalid node id is used the messages become deferred in the console logger and spit out at the end.
+                int nodeId = Scheduler.InProcNodeId;
+
+                return new BuildEventContext(submissionId, nodeId, evaluationId, projectInstanceId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+            }
         }
 
         /// <inheritdoc />
@@ -545,35 +565,75 @@ public void LogProjectEvaluationFinished(
         /// </summary>
         /// <param name="nodeBuildEventContext">The event context of the node which is spawning this project.</param>
         /// <param name="submissionId">The id of the submission.</param>
-        /// <param name="projectInstanceId">Id of the project instance which is being started</param>
+        /// <param name="configurationId">The id of the project configuration which is about to start</param>
         /// <param name="parentBuildEventContext">BuildEventContext of the project who is requesting "projectFile" to build</param>
         /// <param name="projectFile">Project file to build</param>
         /// <param name="targetNames">Target names to build</param>
         /// <param name="properties">Initial property list</param>
         /// <param name="items">Initial items list</param>
         /// <param name="evaluationId">EvaluationId of the project instance</param>
+        /// <param name="projectContextId">The project context id</param>
         /// <returns>The build event context for the project.</returns>
         /// <exception cref="InternalErrorException">parentBuildEventContext is null</exception>
         /// <exception cref="InternalErrorException">projectBuildEventContext is null</exception>
-        public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int projectInstanceId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable<DictionaryEntry> properties, IEnumerable<DictionaryEntry> items, int evaluationId = BuildEventContext.InvalidEvaluationId)
+        public BuildEventContext LogProjectStarted(
+            BuildEventContext nodeBuildEventContext,
+            int submissionId,
+            int configurationId,
+            BuildEventContext parentBuildEventContext,
+            string projectFile,
+            string targetNames,
+            IEnumerable<DictionaryEntry> properties,
+            IEnumerable<DictionaryEntry> items,
+            int evaluationId = BuildEventContext.InvalidEvaluationId,
+            int projectContextId = BuildEventContext.InvalidProjectContextId)
         {
             lock (_lockObject)
             {
                 ErrorUtilities.VerifyThrow(nodeBuildEventContext != null, "Need a nodeBuildEventContext");
-                BuildEventContext projectBuildEventContext = new BuildEventContext(submissionId, nodeBuildEventContext.NodeId, evaluationId, projectInstanceId, NextProjectId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
 
-                // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
-                if (_projectFileMap.ContainsKey(projectBuildEventContext.ProjectContextId))
+                if (projectContextId == BuildEventContext.InvalidProjectContextId)
                 {
-                    ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should not already be in the ID-to-file mapping!", projectBuildEventContext.ProjectContextId, projectFile);
+                    projectContextId = NextProjectId;
+
+                    // PERF: Not using VerifyThrow to avoid boxing of projectBuildEventContext.ProjectContextId in the non-error case.
+                    if (_projectFileMap.ContainsKey(projectContextId))
+                    {
+                        ErrorUtilities.ThrowInternalError("ContextID {0} for project {1} should not already be in the ID-to-file mapping!", projectContextId, projectFile);
+                    }
+
+                    _projectFileMap[projectContextId] = projectFile;
+                }
+                else
+                {
+                    // A projectContextId was provided, so use it with some sanity checks
+                    if (_projectFileMap.TryGetValue(projectContextId, out string existingProjectFile))
+                    {
+                        if (!projectFile.Equals(existingProjectFile, StringComparison.OrdinalIgnoreCase))
+                        {
+                            ErrorUtilities.ThrowInternalError("ContextID {0} was already in the ID-to-project file mapping but the project file {1} did not match the provided one {2}!", projectContextId, existingProjectFile, projectFile);
+                        }
+                    }
+                    else
+                    {
+                        // Currently, an existing projectContextId can only be provided in the project cache scenario, which runs on the in-proc node.
+                        // If there was a cache miss and the build was scheduled on a worker node, it may not have seen this projectContextId yet.
+                        // So we only need this sanity check for the in-proc node.
+                        if (nodeBuildEventContext.NodeId == Scheduler.InProcNodeId)
+                        {
+                            ErrorUtilities.ThrowInternalError("ContextID {0} should have been in the ID-to-project file mapping but wasn't!", projectContextId);
+                        }
+
+                        _projectFileMap[projectContextId] = projectFile;
+                    }
                 }
 
-                _projectFileMap[projectBuildEventContext.ProjectContextId] = projectFile;
+                BuildEventContext projectBuildEventContext = new BuildEventContext(submissionId, nodeBuildEventContext.NodeId, evaluationId, configurationId, projectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
 
                 ErrorUtilities.VerifyThrow(parentBuildEventContext != null, "Need a parentBuildEventContext");
 
-                ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(projectInstanceId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
-                var buildRequestConfiguration = _configCache.Value[projectInstanceId];
+                ErrorUtilities.VerifyThrow(_configCache.Value.HasConfiguration(configurationId), "Cannot find the project configuration while injecting non-serialized data from out-of-proc node.");
+                var buildRequestConfiguration = _configCache.Value[configurationId];
 
                 // Always log GlobalProperties on ProjectStarted
                 // See https://github.com/dotnet/msbuild/issues/6341 for details
@@ -581,7 +641,7 @@ public BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventConte
 
                 var buildEvent = new ProjectStartedEventArgs
                     (
-                        projectInstanceId,
+                        configurationId,
                         message: null,
                         helpKeyword: null,
                         projectFile,
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index bd98358c4ad..30ffe92df56 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -2,14 +2,14 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
-using Microsoft.Build.Framework;
+using System.Linq;
+using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
-using System.Collections;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
-using Microsoft.Build.Collections;
-using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd.Logging
 {
@@ -38,7 +38,8 @@ internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildReque
             requestEntry.RequestConfiguration.Project.PropertiesToBuildWith,
             requestEntry.RequestConfiguration.Project.ItemsToBuildWith,
             requestEntry.Request.ParentBuildEventContext,
-            requestEntry.RequestConfiguration.Project.EvaluationId
+            requestEntry.RequestConfiguration.Project.EvaluationId,
+            requestEntry.Request.ProjectContextId
             )
         {
         }
@@ -63,7 +64,8 @@ internal ProjectLoggingContext(
             projectProperties: null,
             projectItems: null,
             request.ParentBuildEventContext,
-            evaluationId
+            evaluationId,
+            request.ProjectContextId
             )
         {
         }
@@ -71,7 +73,18 @@ internal ProjectLoggingContext(
         /// <summary>
         /// Constructs a project logging contexts.
         /// </summary>
-        private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submissionId, int configurationId, string projectFullPath, List<string> targets, string toolsVersion, PropertyDictionary<ProjectPropertyInstance> projectProperties, ItemDictionary<ProjectItemInstance> projectItems, BuildEventContext parentBuildEventContext, int evaluationId = BuildEventContext.InvalidEvaluationId)
+        private ProjectLoggingContext(
+            NodeLoggingContext nodeLoggingContext,
+            int submissionId,
+            int configurationId,
+            string projectFullPath,
+            List<string> targets,
+            string toolsVersion,
+            PropertyDictionary<ProjectPropertyInstance> projectProperties,
+            ItemDictionary<ProjectItemInstance> projectItems,
+            BuildEventContext parentBuildEventContext,
+            int evaluationId,
+            int projectContextId)
             : base(nodeLoggingContext)
         {
             _projectFullPath = projectFullPath;
@@ -79,8 +92,8 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
             ProjectPropertyInstanceEnumeratorProxy properties = null;
             ProjectItemInstanceEnumeratorProxy items = null;
 
-            IEnumerable<ProjectPropertyInstance> projectPropertiesEnumerator = projectProperties == null ? Array.Empty<ProjectPropertyInstance>() : null;
-            IEnumerable<ProjectItemInstance> projectItemsEnumerator = projectItems == null ? Array.Empty<ProjectItemInstance>() : null;
+            IEnumerable<ProjectPropertyInstance> projectPropertiesEnumerator = projectProperties == null ? Enumerable.Empty<ProjectPropertyInstance>() : null;
+            IEnumerable<ProjectItemInstance> projectItemsEnumerator = projectItems == null ? Enumerable.Empty<ProjectItemInstance>() : null;
 
             string[] propertiesToSerialize = LoggingService.PropertiesToSerialize;
 
@@ -130,10 +143,12 @@ private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submiss
                 configurationId,
                 parentBuildEventContext,
                 projectFullPath,
-                String.Join(";", targets),
+                string.Join(";", targets),
                 properties,
                 items,
-                evaluationId);
+                evaluationId,
+                projectContextId
+                );
 
             // No need to log a redundant message in the common case
             if (toolsVersion != "Current")
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index a80f22d6a6d..1b69d9e04ba 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -219,22 +219,22 @@ public void PostCacheRequest(CacheRequest cacheRequest)
             {
                 try
                 {
-                    var cacheResult = await ProcessCacheRequest(cacheRequest);
-                    _buildManager.PostCacheResult(cacheRequest, cacheResult);
+                    (CacheResult cacheResult, int projectContextId) = await ProcessCacheRequest(cacheRequest);
+                    _buildManager.PostCacheResult(cacheRequest, cacheResult, projectContextId);
                 }
                 catch (Exception e)
                 {
-                    _buildManager.PostCacheResult(cacheRequest, CacheResult.IndicateException(e));
+                    _buildManager.PostCacheResult(cacheRequest, CacheResult.IndicateException(e), BuildEventContext.InvalidProjectContextId);
                 }
             }, _cancellationToken);
 
-            async Task<CacheResult> ProcessCacheRequest(CacheRequest request)
+            async Task<(CacheResult Result, int ProjectContextId)> ProcessCacheRequest(CacheRequest request)
             {
                 // Prevent needless evaluation if design time builds detected.
                 if (_projectCacheDescriptor.VsWorkaround && DesignTimeBuildsDetected)
                 {
                     // The BuildManager should disable the cache when it finds its servicing design time builds.
-                    return CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss);
+                    return (CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss), BuildEventContext.InvalidProjectContextId);
                 }
 
                 EvaluateProjectIfNecessary(request);
@@ -257,7 +257,7 @@ async Task<CacheResult> ProcessCacheRequest(CacheRequest request)
                     if (DesignTimeBuildsDetected)
                     {
                         // The BuildManager should disable the cache when it finds its servicing design time builds.
-                        return CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss);
+                        return (CacheResult.IndicateNonCacheHit(CacheResultType.CacheMiss), BuildEventContext.InvalidProjectContextId);
                     }
                 }
 
@@ -286,10 +286,27 @@ LateInitializationForVSWorkaroundCompleted is null ||
                     _projectCacheDescriptor.VsWorkaround && LateInitializationForVSWorkaroundCompleted.Task.IsCompleted,
                     "Completion source should be null when this is not the VS workaround");
 
-                return await GetCacheResultAsync(
-                    new BuildRequestData(
-                        request.Configuration.Project,
-                        request.Submission.BuildRequestData.TargetNames.ToArray()));
+                BuildRequestData buildRequest = new BuildRequestData(
+                    cacheRequest.Configuration.Project,
+                    cacheRequest.Submission.BuildRequestData.TargetNames.ToArray());
+                BuildEventContext buildEventContext = _loggingService.CreateProjectCacheBuildEventContext(
+                    cacheRequest.Submission.SubmissionId,
+                    evaluationId: cacheRequest.Configuration.Project.EvaluationId,
+                    projectInstanceId: cacheRequest.Configuration.ConfigurationId,
+                    projectFile: cacheRequest.Configuration.Project.FullPath);
+
+                CacheResult cacheResult;
+                try
+                {
+                    cacheResult = await GetCacheResultAsync(buildRequest, buildEventContext);
+                }
+                catch (Exception ex)
+                {
+                    // Wrap the exception here so we can preserve the ProjectContextId
+                    cacheResult = CacheResult.IndicateException(ex);
+                }
+
+                return (cacheResult, buildEventContext.ProjectContextId);
             }
 
             static bool IsDesignTimeBuild(ProjectInstance project)
@@ -448,7 +465,7 @@ static bool MSBuildStringIsTrue(string msbuildString) =>
                 ConversionUtilities.ConvertStringToBool(msbuildString, nullOrWhitespaceIsFalse: true);
         }
 
-        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest)
+        private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildEventContext buildEventContext)
         {
             lock (this)
             {
@@ -467,8 +484,6 @@ private async Task<CacheResult> GetCacheResultAsync(BuildRequestData buildReques
                                    $"\n\tTargets:[{string.Join(", ", buildRequest.TargetNames)}]" +
                                    $"\n\tGlobal Properties: {{{string.Join(",", buildRequest.GlobalProperties.Select(kvp => $"{kvp.Name}={kvp.EvaluatedValue}"))}}}";
 
-            // TODO: Get a valid BuildEventContext to correcctly associate cache-related log events with the build
-            var buildEventContext = BuildEventContext.Invalid;
             var buildEventFileInfo = new BuildEventFileInfo(buildRequest.ProjectFullPath);
             var logger = new LoggingServiceToPluginLoggerAdapter(
                 _loggingService,
diff --git a/src/Build/BackEnd/Shared/BuildRequest.cs b/src/Build/BackEnd/Shared/BuildRequest.cs
index 23bfbe2c7e6..d582dfdd5af 100644
--- a/src/Build/BackEnd/Shared/BuildRequest.cs
+++ b/src/Build/BackEnd/Shared/BuildRequest.cs
@@ -42,6 +42,11 @@ internal class BuildRequest : INodePacket
         /// </summary>
         private int _configurationId;
 
+        /// <summary>
+        /// The project context id, if already determined.
+        /// </summary>
+        private int _projectContextId;
+
         /// <summary>
         /// The global build request id, assigned by the Build Manager
         /// </summary>
@@ -98,11 +103,13 @@ private BuildRequest(
             int nodeRequestId,
             int configurationId,
             HostServices hostServices,
-            BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
-            RequestedProjectState requestedProjectState = null)
+            BuildRequestDataFlags buildRequestDataFlags,
+            RequestedProjectState requestedProjectState,
+            int projectContextId)
         {
             _submissionId = submissionId;
             _configurationId = configurationId;
+            _projectContextId = projectContextId;
 
             HostServices = hostServices;
             _buildEventContext = BuildEventContext.Invalid;
@@ -114,7 +121,7 @@ private BuildRequest(
         }
 
         /// <summary>
-        /// Initializes a build request with a parent context.
+        /// Initializes a build request with proxy targets.
         /// </summary>
         /// <param name="submissionId">The id of the build submission.</param>
         /// <param name="nodeRequestId">The id of the node issuing the request</param>
@@ -123,6 +130,7 @@ private BuildRequest(
         /// <param name="hostServices">Host services if any. May be null.</param>
         /// <param name="buildRequestDataFlags">Additional flags for the request.</param>
         /// <param name="requestedProjectState">Filter for desired build results.</param>
+        /// <param name="projectContextId">The project context id</param>
         public BuildRequest(
             int submissionId,
             int nodeRequestId,
@@ -130,9 +138,9 @@ public BuildRequest(
             ProxyTargets proxyTargets,
             HostServices hostServices,
             BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
-            RequestedProjectState requestedProjectState = null)
-            : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags,
-                requestedProjectState)
+            RequestedProjectState requestedProjectState = null,
+            int projectContextId = BuildEventContext.InvalidProjectContextId)
+            : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags, requestedProjectState, projectContextId)
         {
             _proxyTargets = proxyTargets;
             _targets = proxyTargets.ProxyTargetToRealTargetMap.Keys.ToList();
@@ -155,6 +163,7 @@ public BuildRequest(
         /// <param name="skipStaticGraphIsolationConstraints"></param>
         /// <param name="buildRequestDataFlags">Additional flags for the request.</param>
         /// <param name="requestedProjectState">Filter for desired build results.</param>
+        /// <param name="projectContextId">The project context id</param>
         public BuildRequest(
             int submissionId,
             int nodeRequestId,
@@ -165,8 +174,9 @@ public BuildRequest(
             BuildRequest parentRequest,
             BuildRequestDataFlags buildRequestDataFlags = BuildRequestDataFlags.None,
             RequestedProjectState requestedProjectState = null,
-            bool skipStaticGraphIsolationConstraints = false)
-        : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags, requestedProjectState)
+            bool skipStaticGraphIsolationConstraints = false,
+            int projectContextId = BuildEventContext.InvalidProjectContextId)
+        : this(submissionId, nodeRequestId, configurationId, hostServices, buildRequestDataFlags, requestedProjectState, projectContextId)
         {
             ErrorUtilities.VerifyThrowArgumentNull(escapedTargets, "targets");
             ErrorUtilities.VerifyThrowArgumentNull(parentBuildEventContext, nameof(parentBuildEventContext));
@@ -222,6 +232,16 @@ public int ConfigurationId
             { return _configurationId; }
         }
 
+        /// <summary>
+        /// Returns the project context id
+        /// </summary>
+        public int ProjectContextId
+        {
+            [DebuggerStepThrough]
+            get
+            { return _projectContextId; }
+        }
+
         /// <summary>
         /// Gets the global request id
         /// </summary>
@@ -428,6 +448,7 @@ public void Translate(ITranslator translator)
             translator.Translate(ref _requestedProjectState);
             translator.Translate(ref _hostServices);
             translator.Translate(ref _proxyTargets, ProxyTargets.FactoryForDeserialization);
+            translator.Translate(ref _projectContextId);
             translator.Translate(ref _inputResultsCacheFiles);
             translator.Translate(ref _outputResultsCacheFile);
 
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index edf5ddd2d91..36e23d8e45e 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -794,7 +794,7 @@ internal sealed class TaskItem :
             /// Creates an instance of this class given the item-spec.
             /// </summary>
             internal TaskItem(string includeEscaped, string definingFileEscaped)
-                : this(includeEscaped, includeEscaped, null, null, null, /* mutable */ false, definingFileEscaped)
+                : this(includeEscaped, includeEscaped, null, null, null, immutable: false, definingFileEscaped)
             {
             }
 
@@ -833,13 +833,6 @@ internal TaskItem(ProjectItemInstance item)
             {
             }
 
-            /// <summary>
-            /// Constructor for deserialization only.
-            /// </summary>
-            private TaskItem()
-            {
-            }
-
             /// <summary>
             /// Creates an instance of this class given the backing item.
             /// Does not copy immutability, since there is no connection with the original.
@@ -928,13 +921,17 @@ public ICollection MetadataNames
             {
                 get
                 {
-                    List<string> names = new List<string>((List<string>)CustomMetadataNames);
+                    CopyOnWritePropertyDictionary<ProjectMetadataInstance> metadataCollection = MetadataCollection;
+
+                    List<string> names = new List<string>(capacity: metadataCollection.Count + FileUtilities.ItemSpecModifiers.All.Length);
 
-                    foreach (string name in FileUtilities.ItemSpecModifiers.All)
+                    foreach (ProjectMetadataInstance metadatum in metadataCollection)
                     {
-                        names.Add(name);
+                        names.Add(metadatum.Name);
                     }
 
+                    names.AddRange(FileUtilities.ItemSpecModifiers.All);
+
                     return names;
                 }
             }
@@ -948,37 +945,6 @@ public int MetadataCount
                 get { return MetadataNames.Count; }
             }
 
-            /// <summary>
-            /// Gets the names of custom metadata on the item.
-            /// If there is none, returns an empty collection.
-            /// Does not include built-in metadata.
-            /// Computed, not necessarily fast.
-            /// </summary>
-            public ICollection CustomMetadataNames
-            {
-                get
-                {
-                    List<string> names = new List<string>();
-
-                    foreach (ProjectMetadataInstance metadatum in MetadataCollection)
-                    {
-                        names.Add(metadatum.Name);
-                    }
-
-                    return names;
-                }
-            }
-
-            /// <summary>
-            /// Gets the number of custom metadata set on the item.
-            /// Does not include built-in metadata.
-            /// Computed, not necessarily fast.
-            /// </summary>
-            public int CustomMetadataCount
-            {
-                get { return CustomMetadataNames.Count; }
-            }
-
             /// <summary>
             /// Gets the evaluated include for this item, unescaped.
             /// </summary>
@@ -1081,7 +1047,7 @@ public IEnumerable<KeyValuePair<string, string>> EnumerateMetadata()
                 }
                 else
                 {
-                    return Array.Empty<KeyValuePair<string, string>>();
+                    return Enumerable.Empty<KeyValuePair<string, string>>();
                 }
             }
 
@@ -1156,7 +1122,7 @@ internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollecti
                             }
                             else
                             {
-                                Debug.Fail($"metadatum from {_itemDefinitions[i]} is null, see https://github.com/microsoft/msbuild/issues/5267");
+                                Debug.Fail($"metadatum from {_itemDefinitions[i]} is null, see https://github.com/dotnet/msbuild/issues/5267");
                             }
                         }
                     }
@@ -1172,7 +1138,7 @@ internal CopyOnWritePropertyDictionary<ProjectMetadataInstance> MetadataCollecti
                             }
                             else
                             {
-                                Debug.Fail("metadatum in _directMetadata is null, see https://github.com/microsoft/msbuild/issues/5267");
+                                Debug.Fail("metadatum in _directMetadata is null, see https://github.com/dotnet/msbuild/issues/5267");
                             }
                         }
                     }
@@ -1574,9 +1540,8 @@ public bool Equals(TaskItem other)
                     return true;
                 }
 
-                // Since both sides are this class, we know both sides support ITaskItem2.
-                ITaskItem2 thisAsITaskItem2 = this as ITaskItem2;
-                ITaskItem2 otherAsITaskItem2 = other as ITaskItem2;
+                ITaskItem2 thisAsITaskItem2 = this;
+                ITaskItem2 otherAsITaskItem2 = other;
 
                 // This is case-insensitive. See GetHashCode().
                 if (!MSBuildNameIgnoreCaseComparer.Default.Equals(thisAsITaskItem2.EvaluatedIncludeEscaped, otherAsITaskItem2.EvaluatedIncludeEscaped))
@@ -1584,13 +1549,45 @@ public bool Equals(TaskItem other)
                     return false;
                 }
 
-                if (this.CustomMetadataCount != other.CustomMetadataCount)
+                // Metadata can come from both item definitions and direct values, and they must
+                // be applied in order, with later values overriding newer ones. Here we determine
+                // the set of metadata names on 'this', to avoid computing the full metadata collection
+                // of both 'this' and 'other'. Once we have the names for 'this', we enumerate 'other'
+                // and ensure the names we see there are set-equal to the names we produce here.
+                var thisNames = new HashSet<string>(MSBuildNameIgnoreCaseComparer.Default);
+
+                if (_itemDefinitions is not null)
+                {
+                    foreach (ProjectItemDefinitionInstance itemDefinition in _itemDefinitions)
+                    {
+                        thisNames.UnionWith(itemDefinition.MetadataNames);
+                    }
+                }
+
+                if (_directMetadata is not null)
+                {
+                    foreach (ProjectMetadataInstance metadatum in _directMetadata)
+                    {
+                        thisNames.Add(metadatum.Name);
+                    }
+                }
+
+                CopyOnWritePropertyDictionary<ProjectMetadataInstance> otherMetadata = other.MetadataCollection;
+
+                if (otherMetadata.Count != thisNames.Count)
                 {
                     return false;
                 }
 
-                foreach (string name in this.CustomMetadataNames)
+                foreach (ProjectMetadataInstance metadatum in otherMetadata)
                 {
+                    string name = metadatum.Name;
+
+                    if (!thisNames.Remove(name))
+                    {
+                        return false;
+                    }
+
                     // This is case-insensitive, so that for example "en-US" and "en-us" match and are bucketed together.
                     // In this respect, therefore, we have to consider item metadata value case as not significant.
                     if (!String.Equals
@@ -1606,7 +1603,7 @@ public bool Equals(TaskItem other)
                 }
 
                 // Do not consider mutability for equality comparison
-                return true;
+                return thisNames.Count == 0;
             }
 
 #endregion
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 536d31986cb..c398d3304a5 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -5,6 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
+using System.Linq;
 using System.Reflection;
 
 using Microsoft.Build.BackEnd;
@@ -1258,7 +1259,7 @@ private IEnumerable ReadProperties(ITranslator translator)
             int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
             if (count == 0)
             {
-                return Array.Empty<DictionaryEntry>();
+                return Enumerable.Empty<DictionaryEntry>();
             }
 
             var list = new ArrayList(count);
@@ -1280,7 +1281,7 @@ private IEnumerable ReadItems(ITranslator translator)
             int count = BinaryReaderExtensions.Read7BitEncodedInt(reader);
             if (count == 0)
             {
-                return Array.Empty<DictionaryEntry>();
+                return Enumerable.Empty<DictionaryEntry>();
             }
 
             var list = new ArrayList(count);
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 171fd428e47..9dbd4f83802 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -774,10 +774,10 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
                 if (_customEscapedMetadata == null || _customEscapedMetadata.Count == 0)
                 {
 #if TASKHOST
-                    // MSBuildTaskHost.dll compiles against .NET 3.5 which doesn't have Array.Empty()
+                    // MSBuildTaskHost.dll compiles against .NET 3.5 which doesn't have Enumerable.Empty()
                     return new KeyValuePair<string, string>[0];
 #else
-                    return Array.Empty<KeyValuePair<string, string>>();
+                    return Enumerable.Empty<KeyValuePair<string, string>>();
 #endif
                 }
 
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 29d5c673725..2e2bb8b2ab9 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -683,18 +683,24 @@ bool TryCacheAssemblyIdentityFromPath(string assemblyFile, out string candidateA
 
                 try
                 {
+                    // Framework and Utilities are default references but are often
+                    // specified in the UsingTask anyway; if so just ignore them.
+                    //
+                    // Do this with an explicit upfront check rather than loading the
+                    // assembly and then checking its name, because that can cause
+                    // the loader to have multiple copies of these assemblies as in
+                    // https://github.com/dotnet/msbuild/issues/7108.
+
+                    string name = AssemblyName.GetAssemblyName(assemblyFile).FullName;
+                    if (name == _msbuildFrameworkName ||
+                        name == _msbuildUtilitiesName)
+                    {
+                        return false;
+                    }
+
                     Assembly candidateAssembly = Assembly.UnsafeLoadFrom(assemblyFile);
                     if (candidateAssembly != null)
                     {
-                        string name = candidateAssembly.FullName;
-                        if (name == _msbuildFrameworkName ||
-                            name == _msbuildUtilitiesName)
-                        {
-                            // Framework and Utilities are default references but are often
-                            // specified in the UsingTask anyway; if so just ignore them.
-                            return false;
-                        }
-
                         candidateAssemblyLocation = candidateAssembly.Location;
                         s_knownReferenceAssemblies[candidateAssembly.FullName] = candidateAssembly;
                     }
diff --git a/src/Utilities.UnitTests/TaskItem_Tests.cs b/src/Utilities.UnitTests/TaskItem_Tests.cs
index 04e90914861..57b438459f3 100644
--- a/src/Utilities.UnitTests/TaskItem_Tests.cs
+++ b/src/Utilities.UnitTests/TaskItem_Tests.cs
@@ -5,7 +5,7 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.IO;
-
+using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
@@ -80,22 +80,20 @@ public void NullITaskItem()
             }
            );
         }
-        /// <summary>
-        /// Even without any custom metadata metadatanames should
-        /// return the built in metadata
-        /// </summary>
+
         [Fact]
-        public void MetadataNamesNoCustomMetadata()
+        public void MetadataNamesAndCount()
         {
             TaskItem taskItem = new TaskItem("x");
 
-            taskItem.MetadataNames.Count.ShouldBe(FileUtilities.ItemSpecModifiers.All.Length);
+            // Without custom metadata, should return the built in metadata
+            taskItem.MetadataNames.Cast<string>().ShouldBeSetEquivalentTo(FileUtilities.ItemSpecModifiers.All);
             taskItem.MetadataCount.ShouldBe(FileUtilities.ItemSpecModifiers.All.Length);
 
             // Now add one
             taskItem.SetMetadata("m", "m1");
 
-            taskItem.MetadataNames.Count.ShouldBe(FileUtilities.ItemSpecModifiers.All.Length + 1);
+            taskItem.MetadataNames.Cast<string>().ShouldBeSetEquivalentTo(FileUtilities.ItemSpecModifiers.All.Concat(new[] { "m" }));
             taskItem.MetadataCount.ShouldBe(FileUtilities.ItemSpecModifiers.All.Length + 1);
         }
 
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 1e66ad5bd33..ec7d74b763c 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -194,7 +194,15 @@ public ICollection MetadataNames
         {
             get
             {
-                var metadataNames = new List<string>(_metadata?.Keys ?? Array.Empty<string>());
+                int count = (_metadata?.Count ?? 0) + FileUtilities.ItemSpecModifiers.All.Length;
+
+                var metadataNames = new List<string>(capacity: count);
+
+                if (_metadata is not null)
+                {
+                    metadataNames.AddRange(_metadata.Keys);
+                }
+
                 metadataNames.AddRange(FileUtilities.ItemSpecModifiers.All);
 
                 return metadataNames;
@@ -483,7 +491,7 @@ private IEnumerable<KeyValuePair<string, string>> EnumerateMetadataEager()
         {
             if (_metadata == null)
             {
-                return Array.Empty<KeyValuePair<string, string>>();
+                return Enumerable.Empty<KeyValuePair<string, string>>();
             }
 
             int count = _metadata.Count;
