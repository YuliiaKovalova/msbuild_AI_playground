diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index 4e7d49cb87c..43b88ac45a8 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -911,7 +911,7 @@ private List<string> GetBatchableParametersForTarget()
                 batchableTargetParameters.Add(_target.Outputs);
             }
 
-            if (_target.Returns?.Length > 0)
+            if (!string.IsNullOrEmpty(_target.Returns))
             {
                 batchableTargetParameters.Add(_target.Returns);
             }
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index c551e6c16f1..d1872605c82 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -91,11 +91,11 @@ bool initializationException
          )
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message?.Length > 0), "Need error message.");
-            ErrorUtilities.VerifyThrow(innerException != null || initializationException == true, "Need the logger exception.");
-            ErrorUtilities.VerifyThrow((errorCode?.Length > 0), "Must specify the error message code.");
-            ErrorUtilities.VerifyThrow((helpKeyword?.Length > 0), "Must specify the help keyword for the IDE.");
-
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(message), "Need error message.");
+            ErrorUtilities.VerifyThrow(innerException != null || initializationException, "Need the logger exception.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(errorCode), "Must specify the error message code.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(helpKeyword), "Must specify the help keyword for the IDE.");
+            
             this.e = e;
             this.errorCode = errorCode;
             this.helpKeyword = helpKeyword;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 7c0686853ca..cbb95cb3f2b 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -2552,7 +2552,7 @@ internal static IEnumerable<Pair<string, S>> ExpandQuotedExpressionFunction(Expa
                         // the caller to possibly do correlation.
 
                         // We pass in the existing item so we can copy over its metadata
-                        if (include?.Length > 0)
+                        if (!string.IsNullOrEmpty(include))
                         {
                             yield return new Pair<string, S>(include, item.Value);
                         }
@@ -2651,7 +2651,7 @@ internal static IEnumerable<Pair<string, S>> HasMetadata(Expander<P, I> expander
 
                         // GetMetadataValueEscaped returns empty string for missing metadata,
                         // but IItem specifies it should return null
-                        if (metadataValue?.Length > 0)
+                        if (!string.IsNullOrEmpty(metadataValue))
                         {
                             // return a result through the enumerator
                             yield return new Pair<string, S>(item.Key, item.Value);
diff --git a/src/Build/Instance/ProjectItemInstance.cs b/src/Build/Instance/ProjectItemInstance.cs
index 0087b90ad60..60b50727729 100644
--- a/src/Build/Instance/ProjectItemInstance.cs
+++ b/src/Build/Instance/ProjectItemInstance.cs
@@ -1236,7 +1236,7 @@ public string GetMetadata(string metadataName)
             /// </summary>
             public string GetMetadataEscaped(string metadataName)
             {
-                if (metadataName == null || metadataName.Length == 0)
+                if (string.IsNullOrEmpty(metadataName))
                 {
                     ErrorUtilities.VerifyThrowArgumentLength(metadataName, "metadataName");
                 }
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 5a2eb9d20ae..1bff6ba9ef7 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1484,7 +1484,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                         WriteLinePrefix(projectStartedEvent.FullProjectKey, projectStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
                         string message;
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             message = ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedTopLevelProjectWithDefaultTargets", current, currentProjectNodeId);
                         }
@@ -1500,7 +1500,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                     {
                         WriteLinePrefix(parentStartedEvent.FullProjectKey, parentStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             WriteMessageAligned(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("ProjectStartedWithDefaultTargetsMultiProc", previous, parentStartedEvent.FullProjectKey, current, projectStartedEvent.FullProjectKey, currentProjectNodeId), true);
                         }
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 833fc16645c..5137ecc444a 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -636,7 +636,7 @@ private void WriteProjectStartedText(string current, string targetNames, string
 
                 if (previous == null)
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", current);
                     }
@@ -647,7 +647,7 @@ private void WriteProjectStartedText(string current, string targetNames, string
                 }
                 else
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForNestedProjectWithDefaultTargets", previous, current);
                     }
diff --git a/src/Deprecated/Conversion/ProjectFileConverter.cs b/src/Deprecated/Conversion/ProjectFileConverter.cs
index 80418eb0315..d524f3f84fb 100644
--- a/src/Deprecated/Conversion/ProjectFileConverter.cs
+++ b/src/Deprecated/Conversion/ProjectFileConverter.cs
@@ -372,9 +372,9 @@ private void DoConvert()
         {
             // Make sure we were passed in non-empty source and destination project
             // file names.
-            error.VerifyThrowArgument((this.oldProjectFile?.Length > 0),
+            error.VerifyThrowArgument(!string.IsNullOrEmpty(this.oldProjectFile),
                 "MissingOldProjectFile");
-            error.VerifyThrowArgument((this.newProjectFile?.Length > 0),
+            error.VerifyThrowArgument(!string.IsNullOrEmpty(this.newProjectFile),
                 "MissingNewProjectFile");
 
             ConvertInMemoryToMSBuildProject();
@@ -425,7 +425,7 @@ private void ConvertInMemoryToMSBuildProject()
         {
             // Make sure we were passed in non-empty source and destination project
             // file names.
-            error.VerifyThrowArgument((this.oldProjectFile?.Length > 0),
+            error.VerifyThrowArgument(!string.IsNullOrEmpty(this.oldProjectFile),
                 "MissingOldProjectFile");
 
             // Make sure the source project file exists.
@@ -1434,7 +1434,7 @@ XmlElementWithLocation      visualStudioProjectElement
             // to convert a VC++ or some other type of project, and give a more friendly
             // error message.
             string projectType = visualStudioProjectElement.GetAttribute(VSProjectAttributes.projectType);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((projectType == null) || (projectType.Length == 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(string.IsNullOrEmpty(projectType),
                 visualStudioProjectElement.Location, "ProjectTypeCannotBeConverted", projectType);
 
             // Make sure the <VisualStudioProject> tag doesn't have any attributes.
@@ -1514,8 +1514,8 @@ XmlElementWithLocation      languageElement
             // Get the project type for this project file.  We only support "Local".  We do not
             // convert web projects -- that's Venus's job.
             string projectType = languageElement.GetAttribute(VSProjectAttributes.projectType);
-            ProjectErrorUtilities.VerifyThrowInvalidProject(projectType == null || projectType.Length == 0 ||
-                (String.Equals(projectType, VSProjectAttributes.local, StringComparison.OrdinalIgnoreCase)),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(string.IsNullOrEmpty(projectType) ||
+                (String.Compare(projectType, VSProjectAttributes.local, StringComparison.OrdinalIgnoreCase) == 0),
                 languageElement.Location, "ProjectTypeCannotBeConverted", projectType);
 
             // All of the attributes on the language tag get converted to XMake
@@ -1553,7 +1553,7 @@ XmlElementWithLocation      languageElement
             // -----------------------------------------------------------------------
 
             string originalMyType = languageElement.GetAttribute(XMakeProjectStrings.myType);
-            if ((originalMyType != null) && (originalMyType.Length != 0))
+            if (!string.IsNullOrEmpty(originalMyType))
             {
                 // Flag the fact that the Everett project already had a MyType property in there,
                 // so we don't try to override it later.
@@ -1706,7 +1706,7 @@ private void AddFinalPropertiesAndImports(XmlElementWithLocation languageElement
                     !isTriumphProject        // Doesn't apply to Triumph->Trinity conversions.
                 )
                 {
-                    if (this.outputType?.Length > 0)
+                    if (!string.IsNullOrEmpty(this.outputType))
                     {
                         if (String.Equals(this.outputType, XMakeProjectStrings.winExe, StringComparison.OrdinalIgnoreCase))
                         {
@@ -2063,7 +2063,7 @@ XmlElementWithLocation      configElement
 
             // Get the "Name" attribute of the <Config> element.
             string configName = configElement.GetAttribute(VSProjectAttributes.name);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((configName?.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(configName),
                 configElement.Location, "MissingAttribute", VSProjectElements.config, VSProjectAttributes.name);
 
             // In the case of VSD projects, the "Name" attribute will have a pipe in it,
@@ -2101,7 +2101,7 @@ XmlElementWithLocation      configElement
 
             // Process OutputPath attribute separately to ensure it contains trailing backslash
             string outputPath = configElement.GetAttribute(VSProjectAttributes.outputPath);
-            if (outputPath?.Length > 0)
+            if (!string.IsNullOrEmpty(outputPath))
             {
                 if (outputPath[outputPath.Length-1] != Path.DirectorySeparatorChar)
                     outputPath += Path.DirectorySeparatorChar;
@@ -2126,7 +2126,7 @@ XmlElementWithLocation      configElement
 
             // Get rid of the "IncrementalBuild" attribute
             string incrementalBuild = configElement.GetAttribute ( VSProjectAttributes.incrementalBuild );
-            if (incrementalBuild?.Length > 0)
+            if (!string.IsNullOrEmpty(incrementalBuild))
             {
                 configElement.RemoveAttribute ( VSProjectAttributes.incrementalBuild );
             }
@@ -2270,7 +2270,7 @@ XmlElementWithLocation      platformElement
 
                 // Get the "Name" attribute of the <Platform> element.
                 platformForVSD = platformElement.GetAttribute(VSProjectAttributes.name);
-                ProjectErrorUtilities.VerifyThrowInvalidProject((platformForVSD?.Length > 0),
+                ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(platformForVSD),
                     platformElement.Location, "MissingAttribute", VSProjectElements.platform, VSProjectAttributes.name);
 
                 // Create a new property group, and add all of the XML attributes as XMake
@@ -2491,7 +2491,7 @@ ProjectItemGroupElement referencesItemGroup
             //   "-Designer", we need to disregard this reference entirely.
 
             string platform = referenceElement.GetAttribute(VSProjectAttributes.platform);
-            if ((platform?.Length > 0))
+            if (!string.IsNullOrEmpty(platform))
             {
                 if (platform.IndexOf("-Designer", 0, platform.Length, StringComparison.Ordinal) != -1)
                 {
@@ -2506,7 +2506,7 @@ ProjectItemGroupElement referencesItemGroup
             // Get the "Name" attribute.  This is a required attribute in the VS7/
             // Everett format.
             string referenceName = referenceElement.GetAttribute(VSProjectAttributes.name);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((referenceName?.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(referenceName),
                 referenceElement.Location, "MissingAttribute", VSProjectAttributes.name, VSProjectElements.reference);
 
             // Before we go any further, we must special-case some assemblies for VSD projects.
@@ -2548,12 +2548,12 @@ ProjectItemGroupElement referencesItemGroup
             // reference.
             string referencedProjectGuid = referenceElement.GetAttribute(VSProjectAttributes.project);
 
-            if ((comReferenceGuid?.Length > 0) &&
+            if (!string.IsNullOrEmpty(comReferenceGuid) &&
                 (comReferenceGuid != "{00000000-0000-0000-0000-000000000000}"))
             {
                 newReferenceItem = ConvertClassicComReference(referenceElement, referencesItemGroup, referenceName);
             }
-            else if ((referencedProjectGuid?.Length > 0))
+            else if (!string.IsNullOrEmpty(referencedProjectGuid))
             {
                 newReferenceItem = ConvertProjectToProjectReference(referenceElement, referencesItemGroup, referenceName, ref referencedProjectGuid);
             }
@@ -2727,7 +2727,7 @@ private ProjectItemElement ConvertAssemblyReference(XmlElementWithLocation refer
             // Get the "AssemblyName" attribute.  If not found, just use the value from the
             // "Name" attribute.  This is what the project loading code does in VS.
             string assemblyName = referenceElement.GetAttribute(VSProjectAttributes.assemblyName);
-            if ((assemblyName == null) || (assemblyName.Length == 0))
+            if (string.IsNullOrEmpty(assemblyName))
             {
                 assemblyName = referenceName;
             }
@@ -3009,7 +3009,7 @@ ProjectItemGroupElement importsItemGroup
 
             // Get the required "Namespace" attribute.
             string importNamespace = importElement.GetAttribute(VSProjectAttributes.importNamespace);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((importNamespace?.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(importNamespace),
                 importElement.Location, "MissingAttribute", VSProjectAttributes.importNamespace, VSProjectElements.import);
             // Remove the "Namespace" attribute, so it doesn't show up in our loop later.
             importElement.RemoveAttribute(VSProjectAttributes.importNamespace);
@@ -3196,7 +3196,7 @@ ProjectItemGroupElement filesItemGroup
 
             // Get the required "RelPath" attribute.
             string relPath = fileElement.GetAttribute(VSProjectAttributes.relPath);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((relPath?.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(relPath),
                 fileElement.Location, "MissingAttribute", VSProjectAttributes.relPath, VSProjectElements.file);
             // Remove the "RelPath" attribute, so we don't end up adding it twice.
             fileElement.RemoveAttribute(VSProjectAttributes.relPath);
@@ -3210,7 +3210,7 @@ ProjectItemGroupElement filesItemGroup
             // what the build action is based on the file extension.  This is
             // what the project loading code does in VS.
             string buildAction = fileElement.GetAttribute(VSProjectAttributes.buildAction);
-            if ((buildAction == null) || (buildAction.Length == 0))
+            if (string.IsNullOrEmpty(buildAction))
             {
                 buildAction = VSProjectAttributes.buildActionNone;
             }
@@ -3227,7 +3227,7 @@ ProjectItemGroupElement filesItemGroup
                )
             {
                 // Add the new item to XMake.
-                if ((linkPath == null) || (linkPath.Length == 0))
+                if (string.IsNullOrEmpty(linkPath))
                 {
                     // Normal item.
 
@@ -3322,7 +3322,7 @@ private bool IsFilePresentButEmpty(string relPath, string linkPath)
             // relpath is the filename
             // linkPath, if it exists, is the relative path from the project, or the absolute full path
             string path;
-            if (linkPath == null || linkPath.Length == 0)
+            if (string.IsNullOrEmpty(linkPath))
             {
                 path = Path.Combine(Path.GetDirectoryName(oldProjectFile), relPath);
             }
@@ -3384,7 +3384,7 @@ ProjectItemGroupElement filesItemGroup
 
             // Get the required "RelPath" attribute.
             string relPath = folderElement.GetAttribute(VSProjectAttributes.relPath);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((relPath?.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(relPath),
                 folderElement.Location, "MissingAttribute", VSProjectAttributes.relPath, VSProjectElements.folder);
             // Remove the "RelPath" attribute, so we don't end up adding it twice.
             folderElement.RemoveAttribute(VSProjectAttributes.relPath);
@@ -3428,8 +3428,7 @@ ProjectItemGroupElement filesItemGroup
                 newFolderItem = filesItemGroup.AddItem(XMakeProjectStrings.webReferences,
                     ProjectCollection.Escape(relPath));
             }
-            else if ((webReferenceUrl?.Length > 0))
-            {
+            else if (!string.IsNullOrEmpty(webReferenceUrl))
                 // This is an actual web reference URL.
 
                 // The <Folder> element gets converted to XMake as an item of type
@@ -3596,7 +3595,7 @@ ProjectItemGroupElement startupServicesItemGroup
 
             // Get the required "ID" attribute.
             string id = serviceElement.GetAttribute(VSProjectAttributes.id);
-            ProjectErrorUtilities.VerifyThrowInvalidProject((id?.Length > 0), serviceElement.Location,
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(id), serviceElement.Location,
                 "MissingAttribute", VSProjectAttributes.id, VSProjectElements.service);
             // Remove the "ID" attribute, so it doesn't show up in our loop later.
             serviceElement.RemoveAttribute(VSProjectAttributes.id);
@@ -3793,7 +3792,7 @@ out bool                    isTriumphProject
                 if (officeDocumentPathAttribute != null)
                 {
                     string officeDocumentPath = officeDocumentPathAttribute.Value;
-                    if ((officeDocumentPath?.Length > 0))
+                    if (!string.IsNullOrEmpty(officeDocumentPath))
                     {
                         string projectFileDirectory = Path.GetDirectoryName(Path.GetFullPath(this.oldProjectFile));
                         string officeDocumentFullPath = Path.GetFullPath(Path.Combine(projectFileDirectory, officeDocumentPath));
diff --git a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
index b14da78c739..8c336a5a973 100644
--- a/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
+++ b/src/Deprecated/Engine/Engine/EngineLoggingServices.cs
@@ -741,9 +741,8 @@ virtual internal void LogProjectStarted(int projectId, BuildEventContext parentB
             if (!OnlyLogCriticalEvents)
             {
                 ProjectStartedEventArgs e;
-
-               
-                if (targetNames?.Length > 0)
+              
+                if (!string.IsNullOrEmpty(targetNames))
                 {
                     e = new ProjectStartedEventArgs
                         (
diff --git a/src/Deprecated/Engine/Engine/Project.cs b/src/Deprecated/Engine/Engine/Project.cs
index 064ca7d6b4f..b853a6fc5dc 100644
--- a/src/Deprecated/Engine/Engine/Project.cs
+++ b/src/Deprecated/Engine/Engine/Project.cs
@@ -4064,9 +4064,8 @@ bool        importedProject
 
             for (int i = 0; i < importedFilenames.Length; i++)
             {
-                string importedFilename = EscapingUtilities.UnescapeAll(importedFilenames[i]);
-
-                ProjectErrorUtilities.VerifyThrowInvalidProject((importedFilename != null) && (importedFilename.Length != 0),
+                string importedFilename = EscapingUtilities.UnescapeAll(importedFilenames[i]);     
+                ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(importedFilename),
                     importElement, "MissingRequiredAttribute",
                     XMakeAttributes.project, XMakeElements.import);
 
diff --git a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
index 11401822424..0b37bf3c6de 100644
--- a/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
+++ b/src/Deprecated/Engine/Engine/ProjectSchemaValidationHandler.cs
@@ -115,7 +115,7 @@ string projectFile
             validatorSettings.XmlResolver = null;
             validatorSettings.ValidationEventHandler += new ValidationEventHandler(this.OnSchemaValidationError);
             
-            if ((schemaFile == null) || (schemaFile.Length == 0))
+            if (string.IsNullOrEmpty(schemaFile))
             {
                 schemaFile = Path.Combine(binPath, "Microsoft.Build.xsd");
             }
diff --git a/src/Deprecated/Engine/Engine/Target.cs b/src/Deprecated/Engine/Engine/Target.cs
index ea7489b7b76..03159d2fe48 100644
--- a/src/Deprecated/Engine/Engine/Target.cs
+++ b/src/Deprecated/Engine/Engine/Target.cs
@@ -226,7 +226,7 @@ bool        importedFromAnotherProject
             }
 
             // It's considered an error if a target does not have a name.
-            ProjectErrorUtilities.VerifyThrowInvalidProject((targetName?.Length > 0),
+            ProjectErrorUtilities.VerifyThrowInvalidProject(!string.IsNullOrEmpty(targetName),
                 targetElement, "MissingRequiredAttribute", XMakeAttributes.name, XMakeElements.target);
 
             this.taskElementList = new ArrayList();
diff --git a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
index 91bb481880c..1b8deddab72 100644
--- a/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
+++ b/src/Deprecated/Engine/Engine/TargetDependencyAnalyzer.cs
@@ -1138,7 +1138,7 @@ private void RecordComparisonResults(string input, string output, string inputIt
         /// </returns>
         private int CompareLastWriteTimes(string path1, string path2, out bool path1DoesNotExist, out bool path2DoesNotExist)
         {
-            ErrorUtilities.VerifyThrow(path1?.Length > 0 && path2?.Length > 0,
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(path1) && !string.IsNullOrEmpty(path2),
                 "Need to specify paths to compare.");
 
             FileInfo path1Info = null;
diff --git a/src/Deprecated/Engine/Engine/TaskEngine.cs b/src/Deprecated/Engine/Engine/TaskEngine.cs
index fef8afe8e60..6b4cee24ada 100644
--- a/src/Deprecated/Engine/Engine/TaskEngine.cs
+++ b/src/Deprecated/Engine/Engine/TaskEngine.cs
@@ -989,7 +989,7 @@ private void GatherArrayStringAndValueOutputs(Lookup lookup, TaskOutput taskOutp
 
                 if (taskOutputSpecification.IsItemVector)
                 {
-                    ErrorUtilities.VerifyThrow((itemName?.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(itemName), "Need item type.");
 
                     // to store the outputs as items, use the string representations of the outputs as item-specs
                     foreach (object output in convertibleOutputs)
@@ -1010,7 +1010,7 @@ private void GatherArrayStringAndValueOutputs(Lookup lookup, TaskOutput taskOutp
                 else
                 {
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName?.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(propertyName), "Need property name.");
 
                     // to store an object array in a property, join all the string representations of the objects with
                     // semi-colons to make the property value
@@ -1047,7 +1047,7 @@ private void GatherTaskItemOutputs(Lookup lookup, TaskOutput taskOutputSpecifica
 
                 if (taskOutputSpecification.IsItemVector)
                 {
-                    ErrorUtilities.VerifyThrow((itemName?.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(itemName), "Need item type.");
 
                     foreach (ITaskItem output in taskItemOutputs)
                     {
@@ -1061,7 +1061,7 @@ private void GatherTaskItemOutputs(Lookup lookup, TaskOutput taskOutputSpecifica
                 else
                 {
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName?.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(propertyName), "Need property name.");
 
                     // to store an ITaskItem array in a property, join all the item-specs with semi-colons to make the
                     // property value, and ignore/discard the attributes on the ITaskItems
@@ -1123,8 +1123,7 @@ ItemBucket bucket
                 if (taskOutputSpecification.IsItemVector)
                 {
                     // This is an output item.
-
-                    ErrorUtilities.VerifyThrow((itemName?.Length > 0), "Need item type.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(itemName), "Need item type.");
 
                     // Expand only with properties first, so that expressions like Include="@(foo)" will transfer the metadata of the "foo" items as well, not just their item specs.
                     Expander propertyAndMetadataExpander = new Expander(bucket.Expander, ExpanderOptions.ExpandPropertiesAndMetadata);
@@ -1157,9 +1156,8 @@ ItemBucket bucket
                 else
                 {
                     // This is an output property.
-
                     Debug.Assert(taskOutputSpecification.IsProperty);
-                    ErrorUtilities.VerifyThrow((propertyName?.Length > 0), "Need property name.");
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(propertyName), "Need property name.");
 
                     string taskParameterValue = bucket.Expander.ExpandAllIntoString(taskParameterAttribute);
 
diff --git a/src/Deprecated/Engine/Engine/XmlSearcher.cs b/src/Deprecated/Engine/Engine/XmlSearcher.cs
index 5d8ea7f8353..2dcc8cebef1 100644
--- a/src/Deprecated/Engine/Engine/XmlSearcher.cs
+++ b/src/Deprecated/Engine/Engine/XmlSearcher.cs
@@ -239,7 +239,7 @@ out int foundColumnNumber
             )
         {
             ErrorUtilities.VerifyThrow(xmlElementNumberToSearchFor != 0, "No element to search for!");
-            ErrorUtilities.VerifyThrow((projectFile != null) && (projectFile.Length != 0), "No project file!");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(projectFile), "No project file!");
 
             // Initialize output parameters.
             foundLineNumber = 0;
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index df33c9ffca7..22f730e348c 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -93,10 +93,10 @@ bool initializationException
          )
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message?.Length > 0), "Need error message.");
-            ErrorUtilities.VerifyThrow(innerException != null || initializationException == true, "Need the logger exception.");
-            ErrorUtilities.VerifyThrow((errorCode?.Length > 0), "Must specify the error message code.");
-            ErrorUtilities.VerifyThrow((helpKeyword?.Length > 0), "Must specify the help keyword for the IDE.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(message), "Need error message.");
+            ErrorUtilities.VerifyThrow(innerException != null || initializationException, "Need the logger exception.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(errorCode), "Must specify the error message code.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(helpKeyword), "Must specify the help keyword for the IDE.");
 
             this.e = e;
             this.errorCode = errorCode;
diff --git a/src/Deprecated/Engine/Errors/RemoteErrorException.cs b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
index f63005004de..00839224075 100644
--- a/src/Deprecated/Engine/Errors/RemoteErrorException.cs
+++ b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
@@ -19,7 +19,7 @@ public sealed class RemoteErrorException : Exception
         internal RemoteErrorException(string message, Exception innerException, BuildEventContext buildEventContext)
             : base(message, innerException)
         {
-            ErrorUtilities.VerifyThrow((message?.Length > 0), "Need error message.");
+            ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(message), "Need error message.");
             ErrorUtilities.VerifyThrow(innerException != null, "Need the logger exception.");
 
             this.buildEventContext = buildEventContext;
diff --git a/src/Deprecated/Engine/Items/TaskItem.cs b/src/Deprecated/Engine/Items/TaskItem.cs
index f30bd4b4077..7ef764b8393 100644
--- a/src/Deprecated/Engine/Items/TaskItem.cs
+++ b/src/Deprecated/Engine/Items/TaskItem.cs
@@ -183,7 +183,7 @@ ITaskItem destinationItem
 
                 string destinationValue = destinationItem.GetMetadata(key);
 
-                if ((destinationValue == null) || (destinationValue.Length == 0))
+                if (string.IsNullOrEmpty(destinationValue))
                 {
                     destinationItem.SetMetadata(key, EscapingUtilities.UnescapeAll((string)entry.Value));
                 }
@@ -193,7 +193,7 @@ ITaskItem destinationItem
             // between items, and need to know the source item where the metadata came from
             string originalItemSpec = destinationItem.GetMetadata("OriginalItemSpec");
 
-            if ((originalItemSpec == null) || (originalItemSpec.Length == 0))
+            if (string.IsNullOrEmpty(originalItemSpec))
             {
                 destinationItem.SetMetadata("OriginalItemSpec", ItemSpec);
             }
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 5c872e2d197..6ec726754cf 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1293,7 +1293,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                         WriteLinePrefix(projectStartedEvent.FullProjectKey, projectStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
                         string message = string.Empty;
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             message = ResourceUtilities.FormatResourceString("ProjectStartedTopLevelProjectWithDefaultTargets", current, currentProjectNodeId);
                         }
@@ -1309,7 +1309,7 @@ private void DisplayDeferredProjectStartedEvent(BuildEventContext e)
                     {
                         WriteLinePrefix(parentStartedEvent.FullProjectKey, parentStartedEvent.TimeStamp, false);
                         setColor(ConsoleColor.Cyan);
-                        if ((targetNames == null) || (targetNames.Length == 0))
+                        if (string.IsNullOrEmpty(targetNames))
                         {
                             WriteMessageAligned(ResourceUtilities.FormatResourceString("ProjectStartedWithDefaultTargetsMultiProc", previous, parentStartedEvent.FullProjectKey, current, projectStartedEvent.FullProjectKey, currentProjectNodeId), true);
                         }
diff --git a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
index a3a3193e116..9328e140c4a 100644
--- a/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/SerialConsoleLogger.cs
@@ -600,7 +600,7 @@ private void WriteProjectStartedText(string current, string targetNames, string
 
                 if (previous == null)
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForTopLevelProjectWithDefaultTargets", current);
                     }
@@ -611,7 +611,7 @@ private void WriteProjectStartedText(string current, string targetNames, string
                 }
                 else
                 {
-                    if ((targetNames == null) || (targetNames.Length == 0))
+                    if (string.IsNullOrEmpty(targetNames))
                     {
                         WriteLinePrettyFromResource(indentLevel, "ProjectStartedPrefixForNestedProjectWithDefaultTargets", previous, current);
                     }
diff --git a/src/Deprecated/Engine/Properties/BuildProperty.cs b/src/Deprecated/Engine/Properties/BuildProperty.cs
index 6083b4c799e..fb26bac6a00 100644
--- a/src/Deprecated/Engine/Properties/BuildProperty.cs
+++ b/src/Deprecated/Engine/Properties/BuildProperty.cs
@@ -384,7 +384,7 @@ public string Name
                 else
                 {
                     // If we are not persisted, propertyName and propertyValue must not be null.
-                    ErrorUtilities.VerifyThrow((this.propertyName?.Length > 0) && (this.propertyValue != null),
+                    ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(this.propertyName) && (this.propertyValue != null),
                         "BuildProperty object doesn't have a name/value pair.");
 
                     // Get the property name from the string variable
diff --git a/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs b/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
index adf31e1208d..52316d4fe4c 100644
--- a/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyLoadInfo.cs
@@ -22,7 +22,7 @@ internal sealed class AssemblyLoadInfo
         /// <param name="assemblyFile"></param>
         public AssemblyLoadInfo(string assemblyName, string assemblyFile)
         {
-            ErrorUtilities.VerifyThrow(((assemblyName?.Length > 0)) || ((assemblyFile?.Length > 0)),
+            ErrorUtilities.VerifyThrow((!string.IsNullOrEmpty(assemblyName)) || (!string.IsNullOrEmpty(assemblyFile)),
                 "We must have either the assembly name or the assembly file/path.");
             ErrorUtilities.VerifyThrow((assemblyName == null) || (assemblyFile == null),
                 "We must not have both the assembly name and the assembly file/path.");
diff --git a/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs b/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
index 16513362514..03d78fe93bd 100644
--- a/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
+++ b/src/Deprecated/Engine/Shared/ConfigurationInSolution.cs
@@ -31,7 +31,7 @@ internal ConfigurationInSolution(string configurationName, string platformName)
             this.platformName = platformName;
 
             // Some configurations don't have the platform part
-            if ((platformName?.Length > 0))
+            if (!string.IsNullOrEmpty(platformName))
             {
                 this.fullName = string.Format(CultureInfo.InvariantCulture, "{0}{1}{2}", configurationName, configurationPlatformSeparator, platformName);
             }
diff --git a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
index 53269f5305a..52f496e2b37 100644
--- a/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
+++ b/src/Deprecated/Engine/Shared/EventArgsFormatting.cs
@@ -129,7 +129,7 @@ int threadId
             }
             */
 
-            if ((file == null) || (file.Length == 0))
+            if (string.IsNullOrEmpty(file))
             {
                 format.Append("MSBUILD : ");    // Should not be localized.
             }
@@ -182,7 +182,7 @@ int threadId
                 }
             }
 
-            if ((subcategory != null) && (subcategory.Length != 0))
+            if (!string.IsNullOrEmpty(subcategory))
             {
                 format.Append("{9} ");
             }
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 2dc255497a1..93f6aa0d908 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -312,7 +312,7 @@ private string ReadLine()
         /// <owner>RGoel</owner>
         internal void ParseSolutionFile()
         {
-            error.VerifyThrow((solutionFile != null) && (solutionFile.Length != 0), "ParseSolutionFile() got a null solution file!");
+            error.VerifyThrow(!string.IsNullOrEmpty(solutionFile), "ParseSolutionFile() got a null solution file!");
 
             FileStream fileStream = null;
             reader = null;
@@ -523,7 +523,7 @@ private void ValidateSolutionFileVersion(string versionString)
         /// <owner>RGoel</owner>
         private void ParseProject(string firstLine)
         {
-            error.VerifyThrow((firstLine != null) && (firstLine.Length != 0), "ParseProject() got a null firstLine!");
+            error.VerifyThrow(!string.IsNullOrEmpty(firstLine), "ParseProject() got a null firstLine!");
             error.VerifyThrow(reader != null, "ParseProject() got a null reader!");
 
             ProjectInSolution proj = new ProjectInSolution(this);
@@ -976,7 +976,7 @@ string property
             )
         {
             // If the incoming string starts and ends with a double-quote, strip the double-quotes.
-            if ((property?.Length > 0) && (property[0] == '"') && (property[property.Length - 1] == '"'))
+            if (!string.IsNullOrEmpty(property) && (property[0] == '"') && (property[property.Length - 1] == '"'))
             {
                 return property.Substring(1, property.Length - 2);
             }
diff --git a/src/Deprecated/Engine/Shared/XmlUtilities.cs b/src/Deprecated/Engine/Shared/XmlUtilities.cs
index 9c1418ee16f..ae28f0b3ff8 100644
--- a/src/Deprecated/Engine/Shared/XmlUtilities.cs
+++ b/src/Deprecated/Engine/Shared/XmlUtilities.cs
@@ -69,7 +69,7 @@ internal static string GetXmlNodeFile(XmlNode node, string defaultFile)
             string file = defaultFile;
 
             // NOTE: the XML node may not have a filename if it's purely an in-memory node
-            if ((node.OwnerDocument.BaseURI?.Length > 0))
+            if (!string.IsNullOrEmpty(node.OwnerDocument.BaseURI))
             {
                 file = new Uri(node.OwnerDocument.BaseURI).LocalPath;
             }
diff --git a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
index 5166776fe9c..bac1408f63b 100644
--- a/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/SolutionWrapperProject.cs
@@ -514,7 +514,7 @@ bool specifyProjectToolsVersion
             BuildTask newTask = target.AddNewTask("MSBuild");
             newTask.SetParameterValue("Projects", projectPath, true /* treat as literal */);
 
-            if (msbuildTargetName?.Length > 0)
+            if (!string.IsNullOrEmpty(msbuildTargetName))
             {
                 newTask.SetParameterValue("Targets", msbuildTargetName);
             }
@@ -556,7 +556,7 @@ string subTargetName
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName?.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -899,7 +899,7 @@ string subTargetName
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName?.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -1341,7 +1341,7 @@ string subTargetName
             AddTargetForGetFrameworkPathAndRedistList(msbuildProject);
 
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName?.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -1538,7 +1538,7 @@ string errorMessage
         )
         {
             string targetName = ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName());
-            if (subTargetName?.Length > 0)
+            if (!string.IsNullOrEmpty(subTargetName))
             {
                 targetName = targetName + ":" + subTargetName;
             }
@@ -1621,7 +1621,7 @@ Dictionary<int, List<ProjectInSolution>> projectsByDependencyLevel
                 msbuildTask.SetParameterValue("Projects", buildItemReference);
                 msbuildTask.SetParameterValue("Properties", "Configuration=%(Configuration); Platform=%(Platform); BuildingSolutionFile=true; CurrentSolutionConfigurationContents=$(CurrentSolutionConfigurationContents); SolutionDir=$(SolutionDir); SolutionExt=$(SolutionExt); SolutionFileName=$(SolutionFileName); SolutionName=$(SolutionName); SolutionPath=$(SolutionPath)");
 
-                if (subTargetName?.Length > 0)
+                if (!string.IsNullOrEmpty(subTargetName))
                 {
                     msbuildTask.SetParameterValue("Targets", subTargetName);
                 }
@@ -1690,7 +1690,7 @@ static private string GetProjectDependencies(SolutionParser solution, ProjectInS
                     "SolutionParseProjectDepNotFoundError", project.ProjectGuid, dependency);
 
                 dependencies.Append(ProjectInSolution.DisambiguateProjectTargetName(projectUniqueName));
-                if (subTargetName?.Length > 0)
+                if (!string.IsNullOrEmpty(subTargetName))
                 {
                     dependencies.Append(":");
                     dependencies.Append(subTargetName);
@@ -1735,7 +1735,7 @@ string subTargetName
                 }
 
                 dependencies.Append(ProjectInSolution.DisambiguateProjectTargetName(proj.GetUniqueProjectName()));
-                if (subTargetName?.Length > 0)
+                if (!string.IsNullOrEmpty(subTargetName))
                 {
                     dependencies.Append(":");
                     dependencies.Append(subTargetName);
diff --git a/src/Deprecated/Engine/Solution/VCWrapperProject.cs b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
index 9e1f3c9a5f5..574ab4561a9 100644
--- a/src/Deprecated/Engine/Solution/VCWrapperProject.cs
+++ b/src/Deprecated/Engine/Solution/VCWrapperProject.cs
@@ -99,7 +99,7 @@ string fullConfigurationName
 
             newTask.SetParameterValue("SolutionFile", solutionPath);
 
-            if ((vcbuildTargetName?.Length > 0))
+            if (!string.IsNullOrEmpty(vcbuildTargetName))
             {
                 newTask.SetParameterValue(vcbuildTargetName, "true");
             }
diff --git a/src/MSBuild/ProjectSchemaValidationHandler.cs b/src/MSBuild/ProjectSchemaValidationHandler.cs
index 89a92070750..bd691f0f967 100644
--- a/src/MSBuild/ProjectSchemaValidationHandler.cs
+++ b/src/MSBuild/ProjectSchemaValidationHandler.cs
@@ -41,7 +41,7 @@ string binPath
             ErrorUtilities.VerifyThrowArgumentNull(projectFile, "projectFile");
             ErrorUtilities.VerifyThrowArgumentNull(binPath, "binPath");
 
-            if ((schemaFile == null) || (schemaFile.Length == 0))
+            if (string.IsNullOrEmpty(schemaFile))
             {
                 schemaFile = Path.Combine(binPath, "Microsoft.Build.xsd");
             }
diff --git a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
index 58df8312ba2..e36e10ad324 100644
--- a/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
+++ b/src/Shared/AssemblyFolders/AssemblyFoldersEx.cs
@@ -236,7 +236,7 @@ OpenBaseKey openBaseKey
                         {
                             if (keyPlatform?.ValueCount > 0)
                             {
-                                if (platform?.Length > 0)
+                                if (!string.IsNullOrEmpty(platform))
                                 {
                                     string platformValue = keyPlatform.GetValue("Platform", null) as string;
 
@@ -246,7 +246,7 @@ OpenBaseKey openBaseKey
                                     }
                                 }
 
-                                if (osVersion?.Length > 0)
+                                if (!string.IsNullOrEmpty(osVersion))
                                 {
                                     Version ver = VersionUtilities.ConvertToVersion(osVersion);
 
@@ -274,7 +274,7 @@ private bool MatchingPlatformExists(string platform, string platformValue)
         {
             bool match = false;
 
-            if (platformValue?.Length > 0)
+            if (!string.IsNullOrEmpty(platformValue))
             {
                 string[] platforms = platformValue.Split(MSBuildConstants.SemicolonChar);
                 foreach (string p in platforms)
diff --git a/src/Shared/AssemblyLoadInfo.cs b/src/Shared/AssemblyLoadInfo.cs
index e85dc68a2c8..8a331562a92 100644
--- a/src/Shared/AssemblyLoadInfo.cs
+++ b/src/Shared/AssemblyLoadInfo.cs
@@ -23,7 +23,7 @@ internal abstract class AssemblyLoadInfo : ITranslatable, IEquatable<AssemblyLoa
         /// </summary>
         internal static AssemblyLoadInfo Create(string assemblyName, string assemblyFile)
         {
-            ErrorUtilities.VerifyThrow(((assemblyName?.Length > 0)) || ((assemblyFile?.Length > 0)),
+            ErrorUtilities.VerifyThrow((!string.IsNullOrEmpty(assemblyName)) || (!string.IsNullOrEmpty(assemblyFile)),
                 "We must have either the assembly name or the assembly file/path.");
             ErrorUtilities.VerifyThrow((assemblyName == null) || (assemblyFile == null),
                 "We must not have both the assembly name and the assembly file/path.");
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index 05124895e55..34871308e62 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -228,7 +228,7 @@ string logOutputProperties
             }
             */
 
-            if ((file == null) || (file.Length == 0))
+            if (string.IsNullOrEmpty(file))
             {
                 format.Append("MSBUILD : ");    // Should not be localized.
             }
@@ -281,7 +281,7 @@ string logOutputProperties
                 }
             }
 
-            if ((subcategory != null) && (subcategory.Length != 0))
+            if (!string.IsNullOrEmpty(subcategory))
             {
                 format.Append("{9} ");
             }
diff --git a/src/Shared/MetadataConversionUtilities.cs b/src/Shared/MetadataConversionUtilities.cs
index bab097bf90c..39a454c6266 100644
--- a/src/Shared/MetadataConversionUtilities.cs
+++ b/src/Shared/MetadataConversionUtilities.cs
@@ -31,7 +31,7 @@ out bool metadataFound
             )
         {
             string metadataValue = item.GetMetadata(itemMetadataName);
-            if (metadataValue == null || metadataValue.Length == 0)
+            if (string.IsNullOrEmpty(metadataValue))
             {
                 metadataFound = false;
                 return false;
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 6a5b35b2c24..fe6d67f1c8c 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -736,7 +736,7 @@ params object[] messageArgs
             string messageCode;
             string throwAwayMessageBody = ResourceUtilities.ExtractMessageCode(true /* only msbuild codes */, FormatResourceString(messageResourceName, messageArgs), out messageCode);
 
-            ErrorUtilities.VerifyThrow(messageCode == null || messageCode.Length == 0, "Called LogErrorFromResources instead of LogErrorWithCodeFromResources, but message '" + throwAwayMessageBody + "' does have an error code '" + messageCode + "'");
+            ErrorUtilities.VerifyThrow(string.IsNullOrEmpty(messageCode), "Called LogErrorFromResources instead of LogErrorWithCodeFromResources, but message '" + throwAwayMessageBody + "' does have an error code '" + messageCode + "'");
 #endif
 
             LogError
@@ -1324,7 +1324,7 @@ public bool LogMessageFromText(string lineOfText, MessageImportance messageImpor
                 //  Log it as a warning or error.
                 string origin = messageParts.origin;
 
-                if ((origin == null) || (origin.Length == 0))
+                if (string.IsNullOrEmpty(origin))
                 {
                     // Use the task class name as the origin, if none specified.
                     origin = TaskNameUpperCase;
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index f66b2e7c182..c5c67e630e5 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -493,7 +493,7 @@ internal string FullPath
                     _fileNameWithoutExtension = null;
                     _directoryName = null;
 
-                    if (_fullPath == null || _fullPath.Length == 0)
+                    if (string.IsNullOrEmpty(_fullPath))
                     {
                         _scatterFiles = Array.Empty<string>();
                         _satelliteFiles = new List<string>();
@@ -521,7 +521,7 @@ internal string DirectoryName
         {
             get
             {
-                if ((_directoryName == null || _directoryName.Length == 0) && (_fullPath != null && _fullPath.Length != 0))
+                if ((string.IsNullOrEmpty(_directoryName)) && (!string.IsNullOrEmpty(_fullPath)))
                 {
                     _directoryName = Path.GetDirectoryName(_fullPath);
                     if (_directoryName.Length == 0)
@@ -541,7 +541,7 @@ internal string FileNameWithoutExtension
         {
             get
             {
-                if ((_fileNameWithoutExtension == null || _fileNameWithoutExtension.Length == 0) && (_fullPath != null && _fullPath.Length != 0))
+                if ((string.IsNullOrEmpty(_fileNameWithoutExtension)) && (!string.IsNullOrEmpty(_fullPath)))
                 {
                     _fileNameWithoutExtension = Path.GetFileNameWithoutExtension(_fullPath);
                 }
@@ -556,7 +556,7 @@ internal string FullPathWithoutExtension
         {
             get
             {
-                if ((_fullPathWithoutExtension == null || _fullPathWithoutExtension.Length == 0) && (_fullPath != null && _fullPath.Length != 0))
+                if ((string.IsNullOrEmpty(_fullPathWithoutExtension)) && (!string.IsNullOrEmpty(_fullPath)))
                 {
                     _fullPathWithoutExtension = Path.Combine(DirectoryName, FileNameWithoutExtension);
                 }
@@ -882,7 +882,7 @@ string executableExtension
             _primarySourceItem = sourceItem;
             SDKName = sourceItem.GetMetadata("SDKName");
 
-            if (executableExtension?.Length > 0)
+            if (!string.IsNullOrEmpty(executableExtension))
             {
                 // Set the expected extension.
                 SetExecutableExtension(executableExtension);
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 39698c45681..678fc01c0d4 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1421,7 +1421,7 @@ private void LogInputs()
         private void LogAttribute(ITaskItem item, string metadataName)
         {
             string metadataValue = item.GetMetadata(metadataName);
-            if (metadataValue?.Length > 0)
+            if (!string.IsNullOrEmpty(metadataValue))
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.EightSpaceIndent", Log.FormatResourceString("ResolveAssemblyReference.LogAttributeFormat", metadataName, metadataValue));
             }
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index a57e12a0413..c886278ade5 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -453,7 +453,7 @@ internal static bool GetPathOfTypeLib(TaskLoggingHelper log, bool silent, ref TY
                 return false;
             }
 
-            if (typeLibPath?.Length > 0)
+            if (!string.IsNullOrEmpty(typeLibPath))
             {
                 // We have to check for NULL here because QueryPathOfRegTypeLib() returns
                 // a BSTR with a NULL character appended to it.
diff --git a/src/Tasks/ManifestUtil/mansign2.cs b/src/Tasks/ManifestUtil/mansign2.cs
index ee6b8014c57..00acf4f5efc 100644
--- a/src/Tasks/ManifestUtil/mansign2.cs
+++ b/src/Tasks/ManifestUtil/mansign2.cs
@@ -756,7 +756,7 @@ private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManife
             issuerNode.AppendChild(licenseDom.ImportNode(xmlDigitalSignature, true));
 
             // Time stamp it if requested.
-            if (timeStampUrl != null && timeStampUrl.Length != 0)
+            if (!string.IsNullOrEmpty(timeStampUrl))
             {
                 TimestampSignedLicenseDom(licenseDom, timeStampUrl, useSha256);
             }
diff --git a/src/Tasks/Message.cs b/src/Tasks/Message.cs
index 0d6fc93f403..88b6dca9f84 100644
--- a/src/Tasks/Message.cs
+++ b/src/Tasks/Message.cs
@@ -47,7 +47,7 @@ public override bool Execute()
         {
             MessageImportance messageImportance;
 
-            if ((Importance == null) || (Importance.Length == 0))
+            if (string.IsNullOrEmpty(Importance))
             {
                 messageImportance = MessageImportance.Normal;
             }
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index 1ba5c201f6b..89ed55d4c40 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -1632,7 +1632,7 @@ internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List<ITaskItem> outputTa
 
                 // if Private is not set on the original item, we set CopyLocal to false for GAC items 
                 // and true for non-GAC items
-                if ((privateMetadata == null) || (privateMetadata.Length == 0))
+                if (string.IsNullOrEmpty(privateMetadata))
                 {
                     if (String.Compare(taskItem.ItemSpec, 0, gacPath, 0, gacPath.Length, StringComparison.OrdinalIgnoreCase) == 0)
                     {
