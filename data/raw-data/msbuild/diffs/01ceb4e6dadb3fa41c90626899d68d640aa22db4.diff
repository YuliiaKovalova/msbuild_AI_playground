diff --git a/src/Shared/FileDelegates.cs b/src/Shared/FileDelegates.cs
index bbe0c8e39a4..f13f4e74772 100644
--- a/src/Shared/FileDelegates.cs
+++ b/src/Shared/FileDelegates.cs
@@ -6,13 +6,22 @@
 namespace Microsoft.Build.Shared
 {
     /// <summary>
-    /// delegate for System.IO.Directory.GetFiles, used for testing
+    /// delegate for System.IO.Directory.GetFiles
     /// </summary>
     /// <param name="path">Directory path to start search for files in</param>
     /// <param name="searchPattern">pattern of files to match</param>
     /// <returns>string array of files which match search pattern</returns>
     internal delegate string[] DirectoryGetFiles(string path, string searchPattern);
 
+    /// <summary>
+    /// Delegate for optimized looking up files in directory.
+    /// Designed to be used for testing and to verify file existence by cached directory listing.
+    /// </summary>
+    /// <param name="path">Directory path to search files in</param>
+    /// <param name="fileName">name of file</param>
+    /// <returns>true if file exists</returns>
+    internal delegate bool FileExistsInDirectory(string path, string fileName);
+
     /// <summary>
     /// delegate for Directory.GetDirectories.
     /// </summary>
@@ -53,4 +62,4 @@ namespace Microsoft.Build.Shared
     /// </summary>
     /// <param name="path">The path to create.</param>
     internal delegate FileStream FileCreate(string path);
-}
\ No newline at end of file
+}
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index f942b9da01b..bdac68568e3 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -966,6 +966,20 @@ internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem =
             }
         }
 
+        /// <summary>
+        /// Get all files from directory matching pattern
+        /// </summary>
+        internal static string[] DirectoryGetFiles(string path, string pattern = "*", IFileSystem fileSystem = null)
+        {
+            if (path is null)
+                throw new ArgumentNullException(nameof(path));
+            if (path.Length == 0)
+                throw new ArgumentException("Unexpected empty string", nameof(path));
+
+            path = AttemptToShortenPath(path);
+            return (fileSystem ?? DefaultFileSystem).EnumerateFiles(path, pattern).ToArray();
+        }
+
         /// <summary>
         /// If there is a directory or file at the specified path, returns true.
         /// Otherwise, returns false.
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index 636c41df025..a893427c579 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -549,6 +549,7 @@ public void FileOrDirectoryExistsNoThrow()
 
             Assert.False(FileUtilities.FileOrDirectoryExistsNoThrow("||"));
             Assert.False(FileUtilities.FileOrDirectoryExistsNoThrow(isWindows ? @"c:\doesnot_exist" : "/doesnot_exist"));
+            Assert.False(FileUtilities.FileOrDirectoryExistsNoThrow(string.Empty));
             Assert.True(FileUtilities.FileOrDirectoryExistsNoThrow(isWindows ? @"c:\" : "/"));
             Assert.True(FileUtilities.FileOrDirectoryExistsNoThrow(Path.GetTempPath()));
 
@@ -666,6 +667,35 @@ public void DirectoryExistsNoThrowTooLongWithDotsRelative()
             }
         }
 
+        [Fact]
+        public void DirectoryGetFilesThrowsOnNull()
+        {
+            Assert.Throws<ArgumentNullException>(() => FileUtilities.DirectoryGetFiles(null));
+        }
+
+        [Fact]
+        public void DirectoryGetFilesThrowsOnEmpty()
+        {
+            Assert.Throws<ArgumentException>(() => FileUtilities.DirectoryGetFiles(string.Empty));
+        }
+
+        [ConditionalFact(nameof(RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241))]
+        public void DirectoryGetFilesTooLongWithDots()
+        {
+            Assert.Throws<ArgumentNullException>(() => FileUtilities.DirectoryGetFiles(null));
+
+            string systemDirectoryPath = Path.Combine(Environment.SystemDirectory) + Path.DirectorySeparatorChar;
+            string longPart = new string('x', NativeMethodsShared.MAX_PATH - systemDirectoryPath.Length); // We want the shortest that is > max path.
+
+            string inputPath = Path.Combine(new[] { Environment.SystemDirectory, longPart, "..", });
+
+            Console.WriteLine(inputPath.Length);
+
+            // "c:\windows\system32\<verylong>\.." > MAX_PATH
+            var files = FileUtilities.DirectoryGetFiles(inputPath);
+            Assert.NotEmpty(files);
+        }     
+
         public static bool RunTestsThatDependOnWindowsShortPathBehavior_Workaround4241()
         {
             // Run these tests only when we're not on Windows
diff --git a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
index d4b92d40fed..c419e46bfb7 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/GlobalAssemblyCacheTests.cs
@@ -288,6 +288,7 @@ public void SystemRuntimeDepends_No_Build()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -316,6 +317,7 @@ public void SystemRuntimeDepends_No_Build()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -364,6 +366,7 @@ public void SystemRuntimeDepends_Yes()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -391,6 +394,7 @@ public void SystemRuntimeDepends_Yes()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -438,6 +442,7 @@ public void SystemRuntimeDepends_Yes_Indirect()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -465,6 +470,7 @@ public void SystemRuntimeDepends_Yes_Indirect()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -509,6 +515,7 @@ public void SystemRuntimeDepends_Yes_Indirect_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -532,6 +539,7 @@ public void SystemRuntimeDepends_Yes_Indirect_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -572,6 +580,7 @@ public void NETStandardDepends_Yes()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -595,6 +604,7 @@ public void NETStandardDepends_Yes()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -636,6 +646,7 @@ public void NETStandardDepends_Yes_Indirect()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -659,6 +670,7 @@ public void NETStandardDepends_Yes_Indirect()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -702,6 +714,7 @@ public void NETStandardDepends_Yes_Indirect_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -725,6 +738,7 @@ public void NETStandardDepends_Yes_Indirect_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -768,6 +782,7 @@ public void DependsOn_NETStandard_and_SystemRuntime()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -792,6 +807,7 @@ public void DependsOn_NETStandard_and_SystemRuntime()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -838,6 +854,7 @@ public void DependsOn_NETStandard_and_SystemRuntime_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -862,6 +879,7 @@ public void DependsOn_NETStandard_and_SystemRuntime_ExternallyResolved()
                 fileExists,
                 directoryExists,
                 getDirectories,
+                getDirectoryFiles,
                 getAssemblyName,
                 getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 2d0aaec17b3..9a0b3b56078 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -3312,7 +3312,7 @@ public void ParentAssemblyResolvedFromAForGac()
         /// <returns></returns>
         private ReferenceTable GenerateTableWithAssemblyFromTheGlobalLocation(string location)
         {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,
+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, fileExistsInDirectory, null, null, null, null,
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
@@ -5467,31 +5467,22 @@ public void Regress46599_BogusInGACValueForAssemblyInRedistList()
             };
             t.TargetFrameworkDirectories = new string[] { @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx" };
 
-            FileExists cachedFileExists = fileExists;
-            GetAssemblyName cachedGetAssemblyName = getAssemblyName;
             string redistFile = CreateGenericRedistList();
-
+            List<string> preservedExistentFiles = s_existentFiles;
+            s_existentFiles = new List<string>(s_existentFiles);
             bool success = false;
             try
             {
-                fileExists = new FileExists(delegate (string path)
-                {
-                    if (String.Equals(path, @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\Microsoft.Build.Engine.dll", StringComparison.OrdinalIgnoreCase) ||
-                        String.Equals(path, @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\System.Xml.dll", StringComparison.OrdinalIgnoreCase) ||
-                        path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-                    {
-                        return true;
-                    }
-                    return false;
-                });
+                s_existentFiles.Add(@"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\Microsoft.Build.Engine.dll");
+                s_existentFiles.Add(@"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\System.Xml.dll");
+
                 t.InstalledAssemblyTables = new ITaskItem[] { new TaskItem(redistFile) };
 
                 success = Execute(t);
             }
             finally
             {
-                fileExists = cachedFileExists;
-                getAssemblyName = cachedGetAssemblyName;
+                s_existentFiles = preservedExistentFiles;
                 File.Delete(redistFile);
             }
 
@@ -5528,7 +5519,6 @@ public void VerifyFrameworkFileMetadataFiles()
             };
             t.TargetFrameworkDirectories = new string[] { @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx" };
 
-            FileExists cachedFileExists = fileExists;
             GetAssemblyName cachedGetAssemblyName = getAssemblyName;
 
             // Create a redist list which will contains both of the assemblies to search for
@@ -5542,22 +5532,17 @@ public void VerifyFrameworkFileMetadataFiles()
             string redistFile = FileUtilities.GetTemporaryFile();
             File.WriteAllText(redistFile, redistListContents);
 
+            List<string> preservedExistentFiles = s_existentFiles;
+            s_existentFiles = new List<string>(s_existentFiles);
+
             bool success = false;
             try
             {
-                fileExists = new FileExists(delegate (string path)
-                {
-                    if (String.Equals(path, @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\Microsoft.Build.Engine.dll", StringComparison.OrdinalIgnoreCase) ||
-                        String.Equals(path, @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\System.Xml.dll", StringComparison.OrdinalIgnoreCase) ||
-                        String.Equals(path, @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\B.dll", StringComparison.OrdinalIgnoreCase) ||
-                        String.Equals(path, @"c:\somewhere\c.dll", StringComparison.OrdinalIgnoreCase) ||
-                        String.Equals(path, @"c:\somewhere\d.dll", StringComparison.OrdinalIgnoreCase) ||
-                        path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-                    {
-                        return true;
-                    }
-                    return false;
-                });
+                s_existentFiles.Add(@"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\Microsoft.Build.Engine.dll");
+                s_existentFiles.Add(@"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\System.Xml.dll");
+                s_existentFiles.Add(@"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx\B.dll");
+                s_existentFiles.Add(@"c:\somewhere\c.dll");
+                s_existentFiles.Add(@"c:\somewhere\d.dll");
 
                 getAssemblyName = new GetAssemblyName(delegate (string path)
                 {
@@ -5579,7 +5564,7 @@ public void VerifyFrameworkFileMetadataFiles()
             }
             finally
             {
-                fileExists = cachedFileExists;
+                s_existentFiles = preservedExistentFiles;
                 getAssemblyName = cachedGetAssemblyName;
                 File.Delete(redistFile);
             }
@@ -6342,19 +6327,12 @@ public void IgnoreDefaultInstalledAssemblyTables()
             // Only the explicitly specified redist list should be used
             t.IgnoreDefaultInstalledAssemblyTables = true;
 
-            FileExists cachedFileExists = fileExists;
             GetAssemblyName cachedGetAssemblyName = getAssemblyName;
+            List<string> preservedExistentFiles = s_existentFiles;
+            s_existentFiles = new List<string>(s_existentFiles);
 
-            fileExists = new FileExists(delegate (string path)
-            {
-                if (String.Equals(path, microsoftBuildEnginePath, StringComparison.OrdinalIgnoreCase) ||
-                    String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase) ||
-                    path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-                {
-                    return true;
-                }
-                return false;
-            });
+            s_existentFiles.Add(microsoftBuildEnginePath);
+            s_existentFiles.Add(systemXmlPath);
 
             getAssemblyName = new GetAssemblyName(delegate (string path)
             {
@@ -6377,7 +6355,7 @@ public void IgnoreDefaultInstalledAssemblyTables()
             }
             finally
             {
-                fileExists = cachedFileExists;
+                s_existentFiles = preservedExistentFiles;
                 getAssemblyName = cachedGetAssemblyName;
             }
 
@@ -6817,7 +6795,7 @@ public void ReferenceTableDependentItemsInBlackList3()
         [Fact]
         public void ReferenceTableDependentItemsInBlackList4()
         {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null,
+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, fileExistsInDirectory, null, null, null,
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
@@ -6995,7 +6973,7 @@ public void ReferenceTableDependentItemsInBlackListPrimaryWithSpecificVersion()
 
         private static ReferenceTable MakeEmptyReferenceTable(TaskLoggingHelper log)
         {
-            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, null, null, null, null,
+            ReferenceTable referenceTable = new ReferenceTable(null, false, false, false, false, new string[0], null, null, null, null, null, null, SystemProcessorArchitecture.None, fileExists, fileExistsInDirectory, null, null, null, null,
 #if FEATURE_WIN32_REGISTRY
                 null, null, null,
 #endif
@@ -7258,18 +7236,12 @@ public void IgnoreDefaultInstalledSubsetTables()
         /// </summary>
         private bool GenerateHelperDelegatesAndExecuteTask(ResolveAssemblyReference t, string microsoftBuildEnginePath, string systemXmlPath)
         {
-            FileExists cachedFileExists = fileExists;
             GetAssemblyName cachedGetAssemblyName = getAssemblyName;
-            fileExists = new FileExists(delegate (string path)
-            {
-                if (String.Equals(path, microsoftBuildEnginePath, StringComparison.OrdinalIgnoreCase) ||
-                    String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase) ||
-                    path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-                {
-                    return true;
-                }
-                return false;
-            });
+            List<string> preservedExistentFiles = s_existentFiles;
+            s_existentFiles = new List<string>(s_existentFiles);
+
+            s_existentFiles.Add(microsoftBuildEnginePath);
+            s_existentFiles.Add(systemXmlPath);
 
             getAssemblyName = new GetAssemblyName(delegate (string path)
             {
@@ -7292,7 +7264,7 @@ private bool GenerateHelperDelegatesAndExecuteTask(ResolveAssemblyReference t, s
             }
             finally
             {
-                fileExists = cachedFileExists;
+                s_existentFiles = preservedExistentFiles;
                 getAssemblyName = cachedGetAssemblyName;
             }
             return success;
@@ -7609,33 +7581,26 @@ public void DoNotAssumeFilesDescribedByRedistListExistOnDisk()
                 t.BuildEngine = new MockEngine(_output);
 
                 t.Assemblies = new ITaskItem[]
-            {
-                new TaskItem("Microsoft.Build.Engine"),
-                new TaskItem("System.Xml")
-            };
+                {
+                    new TaskItem("Microsoft.Build.Engine"),
+                    new TaskItem("System.Xml")
+                };
 
-                t.SearchPaths = new string[]
-            {
-                @"{TargetFrameworkDirectory}"
-            };
+                    t.SearchPaths = new string[]
+                {
+                    @"{TargetFrameworkDirectory}"
+                };
                 t.TargetFrameworkDirectories = new string[] { Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5") };
                 string microsoftBuildEnginePath = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\Microsoft.Build.Engine");
                 string systemXmlPath = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\System.Xml.dll");
 
                 t.InstalledAssemblyTables = new ITaskItem[] { new TaskItem(redistListPath) };
 
-                FileExists cachedFileExists = fileExists;
                 GetAssemblyName cachedGetAssemblyName = getAssemblyName;
+                List<string> preservedExistentFiles = s_existentFiles;
+                s_existentFiles = new List<string>(s_existentFiles);
 
-                // Note that Microsoft.Build.Engine.dll does not exist
-                fileExists = new FileExists(delegate (string path)
-                {
-                    if (String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase) || path.EndsWith("RarCache", StringComparison.OrdinalIgnoreCase))
-                    {
-                        return true;
-                    }
-                    return false;
-                });
+                s_existentFiles.Add(systemXmlPath);
 
                 getAssemblyName = new GetAssemblyName(delegate (string path)
                 {
@@ -7658,7 +7623,74 @@ public void DoNotAssumeFilesDescribedByRedistListExistOnDisk()
                 }
                 finally
                 {
-                    fileExists = cachedFileExists;
+                    s_existentFiles = preservedExistentFiles;
+                    getAssemblyName = cachedGetAssemblyName;
+                }
+
+                Assert.True(success); // "Expected no errors."
+                Assert.Single(t.ResolvedFiles); // "Expected one resolved assembly."
+                Assert.Contains("System.Xml", t.ResolvedFiles[0].ItemSpec); // "Expected System.Xml to resolve."
+            }
+            finally
+            {
+                File.Delete(redistListPath);
+            }
+        }
+
+        [Fact]
+        [Trait("Category", "mono-osx-failing")]
+        public void HandleFilesInSearchPathsWhichDiffersOnlyInCasing()
+        {
+            string redistListPath = CreateGenericRedistList();
+            try
+            {
+                ResolveAssemblyReference t = new ResolveAssemblyReference();
+
+                t.BuildEngine = new MockEngine(_output);
+
+                t.Assemblies = new ITaskItem[]
+                {
+                    new TaskItem("System.Xml")
+                };
+
+                t.SearchPaths = new string[]
+                {
+                    @"{TargetFrameworkDirectory}"
+                };
+
+                t.TargetFrameworkDirectories = new string[] { Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5") };
+                string systemXmlPath = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\System.Xml.dll");
+                string aFile = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\A.File.dll");
+                string aFileLowercase = Path.Combine(ObjectModelHelpers.TempProjectDir, "v3.5\\a.file.dll");
+
+                t.InstalledAssemblyTables = new ITaskItem[] { new TaskItem(redistListPath) };
+
+                GetAssemblyName cachedGetAssemblyName = getAssemblyName;
+                List<string> preservedExistentFiles = s_existentFiles;
+                s_existentFiles = new List<string>(s_existentFiles);
+
+                s_existentFiles.Add(systemXmlPath);
+                s_existentFiles.Add(aFile);
+                s_existentFiles.Add(aFileLowercase);
+
+                getAssemblyName = new GetAssemblyName(delegate (string path)
+                {
+                    if (String.Equals(path, systemXmlPath, StringComparison.OrdinalIgnoreCase))
+                    {
+                        return new AssemblyNameExtension("System.Xml, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a");
+                    }
+
+                    return null;
+                });
+
+                bool success;
+                try
+                {
+                    success = Execute(t);
+                }
+                finally
+                {
+                    s_existentFiles = preservedExistentFiles;
                     getAssemblyName = cachedGetAssemblyName;
                 }
 
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
index eef70e698bf..ffc610d2b90 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Perf.cs
@@ -76,9 +76,7 @@ public void DependeeDirectoryIsProbedForDependency()
 
                 Assert.True(succeeded);
                 
-                uniqueFileExists[s_dependsOnNuGet_NWinMdPath].ShouldBe(1);
-                uniqueFileExists[s_dependsOnNuGet_NDllPath].ShouldBe(1);
-                uniqueFileExists[s_dependsOnNuGet_NExePath].ShouldBe(1);
+                uniqueGetDirectoryFiles[s_dependsOnNuGet_Path].ShouldBe(1);
             }
             finally
             {
@@ -121,9 +119,7 @@ public void DependeeDirectoryShouldNotBeProbedForDependencyWhenDependencyResolve
 
                 Assert.True(succeeded);
 
-                uniqueFileExists.ShouldNotContainKey(@"C:\DependsOnNuget\N.winmd");
-                uniqueFileExists.ShouldNotContainKey(@"C:\DependsOnNuget\N.dll");
-                uniqueFileExists.ShouldNotContainKey(@"C:\DependsOnNuget\N.exe");
+                uniqueGetDirectoryFiles.ShouldNotContainKey(s_dependsOnNuGet_Path);
             }
             finally
             {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 373805aa30f..839e5b70c6e 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -13,6 +13,7 @@
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 using Xunit;
 using Xunit.Abstractions;
+using System.Linq;
 
 namespace Microsoft.Build.UnitTests.ResolveAssemblyReference_Tests
 {
@@ -20,7 +21,9 @@ public class ResolveAssemblyReferenceTestFixture : IDisposable
     {
         // Create the mocks.
         internal static Microsoft.Build.Shared.FileExists fileExists = new Microsoft.Build.Shared.FileExists(FileExists);
+        internal static Microsoft.Build.Shared.FileExistsInDirectory fileExistsInDirectory = new Microsoft.Build.Shared.FileExistsInDirectory(FileExistsInDirectory);
         internal static Microsoft.Build.Shared.DirectoryExists directoryExists = new Microsoft.Build.Shared.DirectoryExists(DirectoryExists);
+        internal static Microsoft.Build.Shared.DirectoryGetFiles getDirectoryFiles = new Microsoft.Build.Shared.DirectoryGetFiles(GetDirectoryFiles);
         internal static Microsoft.Build.Tasks.GetDirectories getDirectories = new Microsoft.Build.Tasks.GetDirectories(GetDirectories);
         internal static Microsoft.Build.Tasks.GetAssemblyName getAssemblyName = new Microsoft.Build.Tasks.GetAssemblyName(GetAssemblyName);
         internal static Microsoft.Build.Tasks.GetAssemblyMetadata getAssemblyMetadata = new Microsoft.Build.Tasks.GetAssemblyMetadata(GetAssemblyMetadata);
@@ -41,6 +44,7 @@ public class ResolveAssemblyReferenceTestFixture : IDisposable
         // Performance checks.
         internal static Dictionary<string, int> uniqueFileExists = null;
         internal static Dictionary<string, int> uniqueGetAssemblyName = null;
+        internal static Dictionary<string, int> uniqueGetDirectoryFiles = null;
 
         internal static bool useFrameworkFileExists = false;
         internal const string REDISTLIST = @"<FileList  Redist=""Microsoft-Windows-CLRCoreComp.4.0"" Name="".NET Framework 4"" RuntimeVersion=""4.0"" ToolsVersion=""12.0"">
@@ -256,6 +260,7 @@ public void Dispose()
         protected static readonly string s_portableDllPath = Path.Combine(s_rootPathPrefix, "SystemRuntime", "Portable.dll");
         protected static readonly string s_systemRuntimeDllPath = Path.Combine(s_rootPathPrefix, "SystemRuntime", "System.Runtime.dll");
 
+        protected static readonly string s_dependsOnNuGet_Path = Path.Combine(s_rootPathPrefix, "DependsOnNuget");
         protected static readonly string s_dependsOnNuGet_ADllPath = Path.Combine(s_rootPathPrefix, "DependsOnNuget", "A.dll");
         protected static readonly string s_dependsOnNuGet_NDllPath = Path.Combine(s_rootPathPrefix, "DependsOnNuget", "N.dll");
         protected static readonly string s_dependsOnNuGet_NExePath = Path.Combine(s_rootPathPrefix, "DependsOnNuget", "N.exe");
@@ -300,6 +305,7 @@ internal void StartIOMonitoring()
             // If tables are present then the corresponding IO function will do some monitoring.
             uniqueFileExists = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
             uniqueGetAssemblyName = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
+            uniqueGetDirectoryFiles = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);
         }
 
         /// <summary>
@@ -861,6 +867,47 @@ internal static bool FileExists(string path)
             return false;
         }
 
+        /// <summary>
+        /// Mock the Directory.GetFiles method.
+        /// </summary>
+        /// <param name="path">The path to directory.</param>
+        /// <returns>'true' if the file is supposed to exist</returns>
+        internal static string[] GetDirectoryFiles(string path, string pattern)
+        {
+            if (!Path.IsPathRooted(path))
+            {
+                path = Path.GetFullPath(path);
+            }
+
+            // remove trailing path separator
+            path = Path.GetDirectoryName(Path.Combine(path, "a.txt"));
+
+            if (pattern != "*")
+            {
+                throw new InvalidOperationException("In this context, directory listing with pattern is neither supported not expected to be used.");
+            }
+
+            // Do IO monitoring if needed.
+            if (uniqueGetDirectoryFiles != null)
+            {
+                uniqueGetDirectoryFiles.TryGetValue(path, out int count);
+                uniqueGetDirectoryFiles[path] = count + 1;
+            }
+
+            return s_existentFiles
+                .Where(fn => Path.GetDirectoryName(fn).Equals(path, StringComparison.OrdinalIgnoreCase))
+                .Select(fn => Path.Combine(path, Path.GetFileName(fn)))
+                .Distinct()
+                .ToArray();
+        }
+
+        internal static bool FileExistsInDirectory(string path, string fileName)
+        {
+            string fullName = Path.Combine(path, fileName);
+
+            return FileExists(fullName);
+        }
+
         /// <summary>
         /// Mock the Directory.Exists method.
         /// </summary>
@@ -3001,26 +3048,27 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC
                     t.FindSerializationAssemblies = false;
                     t.FindRelatedFiles = false;
                     t.StateFile = null;
-	                t.Execute
-	                (
-	                    fileExists,
-	                    directoryExists,
-	                    getDirectories,
-	                    getAssemblyName,
-	                    getAssemblyMetadata,
-	#if FEATURE_WIN32_REGISTRY
-	                    getRegistrySubKeyNames,
-	                    getRegistrySubKeyDefaultValue,
-	#endif
-	                    getLastWriteTime,
-	                    getRuntimeVersion,
-	#if FEATURE_WIN32_REGISTRY
-	                    openBaseKey,
-	#endif
-	                    checkIfAssemblyIsInGac,
-	                    isWinMDFile,
-	                    readMachineTypeFromPEHeader
-	                );
+                    t.Execute
+                    (
+                        fileExists,
+                        directoryExists,
+                        getDirectories,
+                        getDirectoryFiles,
+                        getAssemblyName,
+                        getAssemblyMetadata,
+    #if FEATURE_WIN32_REGISTRY
+                        getRegistrySubKeyNames,
+                        getRegistrySubKeyDefaultValue,
+    #endif
+                        getLastWriteTime,
+                        getRuntimeVersion,
+    #if FEATURE_WIN32_REGISTRY
+                        openBaseKey,
+    #endif
+                        checkIfAssemblyIsInGac,
+                        isWinMDFile,
+                        readMachineTypeFromPEHeader
+                );
 
                     // A few checks. These should always be true or it may be a perf issue for project load.
                     ITaskItem[] loadModeResolvedFiles = new TaskItem[0];
@@ -3062,27 +3110,28 @@ protected static bool Execute(ResolveAssemblyReference t, bool buildConsistencyC
                     string cache = rarCacheFile;
                     t.StateFile = cache;
                     File.Delete(t.StateFile);
-	                succeeded =
-	                    t.Execute
-	                    (
-	                        fileExists,
-	                        directoryExists,
-	                        getDirectories,
-	                        getAssemblyName,
-	                        getAssemblyMetadata,
-	#if FEATURE_WIN32_REGISTRY
-	                        getRegistrySubKeyNames,
-	                        getRegistrySubKeyDefaultValue,
-	#endif
-	                        getLastWriteTime,
-	                        getRuntimeVersion,
-	#if FEATURE_WIN32_REGISTRY
-	                        openBaseKey,
-	#endif
-	                        checkIfAssemblyIsInGac,
-	                        isWinMDFile,
-	                        readMachineTypeFromPEHeader
-	                    );
+                    succeeded =
+                        t.Execute
+                        (
+                            fileExists,
+                            directoryExists,
+                            getDirectories,
+                            getDirectoryFiles,
+                            getAssemblyName,
+                            getAssemblyMetadata,
+    #if FEATURE_WIN32_REGISTRY
+                            getRegistrySubKeyNames,
+                            getRegistrySubKeyDefaultValue,
+    #endif
+                            getLastWriteTime,
+                            getRuntimeVersion,
+    #if FEATURE_WIN32_REGISTRY
+                            openBaseKey,
+    #endif
+                            checkIfAssemblyIsInGac,
+                            isWinMDFile,
+                            readMachineTypeFromPEHeader
+                        );
                     if (FileUtilities.FileExistsNoThrow(t.StateFile))
                     {
                         Assert.Single(t.FilesWritten);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
index a97a93c7a50..6baa714ce5f 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/VerifyTargetFrameworkAttribute.cs
@@ -372,6 +372,7 @@ public void HigherVersionDirectDependenciesFalse()
                     fileExists,
                     directoryExists,
                     getDirectories,
+                    getDirectoryFiles,
                     getAssemblyName,
                     getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
diff --git a/src/Tasks.UnitTests/HintPathResolver_Tests.cs b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
index 37f8f89445c..3b6daa56dc6 100644
--- a/src/Tasks.UnitTests/HintPathResolver_Tests.cs
+++ b/src/Tasks.UnitTests/HintPathResolver_Tests.cs
@@ -66,6 +66,7 @@ private bool ResolveHintPath(string hintPath)
                 searchPathElement: "{HintPathFromItem}",
                 getAssemblyName: (path) => throw new NotImplementedException(), // not called in this code path
                 fileExists: p => FileUtilities.FileExistsNoThrow(p),
+                fileExistsInDirectory: null, // not used
                 getRuntimeVersion: (path) => throw new NotImplementedException(), // not called in this code path
                 targetedRuntimeVesion: Version.Parse("4.0.30319"));
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
index ab6b685ba91..8a40638f1d8 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersExResolver.cs
@@ -99,8 +99,8 @@ internal class AssemblyFoldersExResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public AssemblyFoldersExResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, GetAssemblyRuntimeVersion getRuntimeVersion, OpenBaseKey openBaseKey, Version targetedRuntimeVesion, ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture, IBuildEngine buildEngine)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, compareProcessorArchitecture)
+        public AssemblyFoldersExResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, GetAssemblyRuntimeVersion getRuntimeVersion, OpenBaseKey openBaseKey, Version targetedRuntimeVesion, ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture, IBuildEngine buildEngine)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, compareProcessorArchitecture)
         {
             _buildEngine = buildEngine as IBuildEngine4;
             _getRegistrySubKeyNames = getRegistrySubKeyNames;
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
index e6e2a2bcb80..bcbe5b2fc99 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersFromConfig/AssemblyFoldersFromConfigResolver.cs
@@ -74,11 +74,11 @@ internal class AssemblyFoldersFromConfigResolver : Resolver
         /// Construct.
         /// </summary>
         public AssemblyFoldersFromConfigResolver(string searchPathElement, GetAssemblyName getAssemblyName,
-            FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion,
+            FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion,
             ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture,
             IBuildEngine buildEngine, TaskLoggingHelper log)
             : base(
-                searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion,
+                searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion,
                 targetProcessorArchitecture, compareProcessorArchitecture)
         {
             _buildEngine = buildEngine as IBuildEngine4;
diff --git a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
index 82fbcc95204..04355c6803b 100644
--- a/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyFoldersResolver.cs
@@ -18,10 +18,11 @@ internal class AssemblyFoldersResolver : Resolver
         /// <param name="searchPathElement">The corresponding element from the search path.</param>
         /// <param name="getAssemblyName">Delegate that gets the assembly name.</param>
         /// <param name="fileExists">Delegate that returns if the file exists.</param>
+        /// <param name="fileExistsInDirectory">Delegate to test if file exists in directory.</param>
         /// <param name="getRuntimeVersion">Delegate that returns the clr runtime version for the file.</param>
         /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
-        public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
         }
 
diff --git a/src/Tasks/AssemblyDependency/AssemblyResolution.cs b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
index f2fe396824f..1f604001d55 100644
--- a/src/Tasks/AssemblyDependency/AssemblyResolution.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyResolution.cs
@@ -109,6 +109,7 @@ out userRequestedSpecificFile
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
         /// <param name="frameworkPaths">Paths to FX folders.</param>
         /// <param name="fileExists"></param>
+        /// <param name="fileExistsInDirectory"></param>
         /// <param name="getAssemblyName"></param>
         /// <param name="getRegistrySubKeyNames"></param>
         /// <param name="getRegistrySubKeyDefaultValue"></param>
@@ -129,6 +130,7 @@ out userRequestedSpecificFile
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
         /// <param name="frameworkPaths">Paths to FX folders.</param>
         /// <param name="fileExists"></param>
+        /// <param name="fileExistsInDirectory"></param>
         /// <param name="getAssemblyName"></param>
         /// <param name="installedAssemblies"></param>
         /// <param name="getRuntimeVersion"></param>
@@ -145,6 +147,7 @@ public static Resolver[] CompileSearchPaths
             System.Reflection.ProcessorArchitecture targetProcessorArchitecture,
             string[] frameworkPaths,
             FileExists fileExists,
+            FileExistsInDirectory fileExistsInDirectory,
             GetAssemblyName getAssemblyName,
 #if FEATURE_WIN32_REGISTRY
             GetRegistrySubKeyNames getRegistrySubKeyNames,
@@ -168,44 +171,44 @@ TaskLoggingHelper log
                 // HintPath property.
                 if (String.Equals(basePath, AssemblyResolutionConstants.hintPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new HintPathResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new HintPathResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
                 else if (String.Equals(basePath, AssemblyResolutionConstants.frameworkPathSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new FrameworkPathResolver(frameworkPaths, installedAssemblies, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new FrameworkPathResolver(frameworkPaths, installedAssemblies, searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
                 else if (String.Equals(basePath, AssemblyResolutionConstants.rawFileNameSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new RawFilenameResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new RawFilenameResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
                 else if (String.Equals(basePath, AssemblyResolutionConstants.candidateAssemblyFilesSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new CandidateAssemblyFilesResolver(candidateAssemblyFiles, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new CandidateAssemblyFilesResolver(candidateAssemblyFiles, searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
 #if FEATURE_GAC
                 else if (String.Equals(basePath, AssemblyResolutionConstants.gacSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new GacResolver(targetProcessorArchitecture, searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, getAssemblyPathInGac);
+                    resolvers[p] = new GacResolver(targetProcessorArchitecture, searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion, getAssemblyPathInGac);
                 }
 #endif
                 else if (String.Equals(basePath, AssemblyResolutionConstants.assemblyFoldersSentinel, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new AssemblyFoldersResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new AssemblyFoldersResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
 #if FEATURE_WIN32_REGISTRY
                 // Check for AssemblyFoldersEx sentinel.
                 else if (0 == String.Compare(basePath, 0, AssemblyResolutionConstants.assemblyFoldersExSentinel, 0, AssemblyResolutionConstants.assemblyFoldersExSentinel.Length, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new AssemblyFoldersExResolver(searchPaths[p], getAssemblyName, fileExists, getRegistrySubKeyNames, getRegistrySubKeyDefaultValue, getRuntimeVersion, openBaseKey, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine);
+                    resolvers[p] = new AssemblyFoldersExResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRegistrySubKeyNames, getRegistrySubKeyDefaultValue, getRuntimeVersion, openBaseKey, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine);
                 }
 #endif
                 else if (0 == String.Compare(basePath, 0, AssemblyResolutionConstants.assemblyFoldersFromConfigSentinel, 0, AssemblyResolutionConstants.assemblyFoldersFromConfigSentinel.Length, StringComparison.OrdinalIgnoreCase))
                 {
-                    resolvers[p] = new AssemblyFoldersFromConfigResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine, log);
+                    resolvers[p] = new AssemblyFoldersFromConfigResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion, targetProcessorArchitecture, true, buildEngine, log);
                 }
                 else
                 {
-                    resolvers[p] = new DirectoryResolver(searchPaths[p], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                    resolvers[p] = new DirectoryResolver(searchPaths[p], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
                 }
             }
             return resolvers;
@@ -218,6 +221,7 @@ internal static Resolver[] CompileDirectories
         (
             List<string> directories,
             FileExists fileExists,
+            FileExistsInDirectory fileExistsInDirectory,
             GetAssemblyName getAssemblyName,
             GetAssemblyRuntimeVersion getRuntimeVersion,
             Version targetedRuntimeVersion
@@ -226,7 +230,7 @@ Version targetedRuntimeVersion
             var resolvers = new Resolver[directories.Count];
             for (int i = 0; i < directories.Count; i++)
             {
-                resolvers[i] = new DirectoryResolver(directories[i], getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVersion);
+                resolvers[i] = new DirectoryResolver(directories[i], getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVersion);
             }
 
             return resolvers;
diff --git a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
index 23ccac23cb2..cbb0d614185 100644
--- a/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
+++ b/src/Tasks/AssemblyDependency/CandidateAssemblyFilesResolver.cs
@@ -26,10 +26,11 @@ internal class CandidateAssemblyFilesResolver : Resolver
         /// <param name="searchPathElement">The corresponding element from the search path.</param>
         /// <param name="getAssemblyName">Delegate that gets the assembly name.</param>
         /// <param name="fileExists">Delegate that returns if the file exists.</param>
+        /// <param name="fileExistsInDirectory">Delegate to test if file exists in directory and return full file name</param>
         /// <param name="getRuntimeVersion">Delegate that returns the clr runtime version for the file.</param>
         /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
-        public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
+        public CandidateAssemblyFilesResolver(string[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
             _candidateAssemblyFiles = candidateAssemblyFiles;
         }
diff --git a/src/Tasks/AssemblyDependency/DirectoryResolver.cs b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
index 8f7be0e76ac..3ec833c0201 100644
--- a/src/Tasks/AssemblyDependency/DirectoryResolver.cs
+++ b/src/Tasks/AssemblyDependency/DirectoryResolver.cs
@@ -15,8 +15,8 @@ internal class DirectoryResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public DirectoryResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        public DirectoryResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
         }
 
diff --git a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
index bfee4b6dc71..e64f95aac69 100644
--- a/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/FrameworkPathResolver.cs
@@ -21,8 +21,8 @@ internal class FrameworkPathResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public FrameworkPathResolver(string[] frameworkPaths, InstalledAssemblies installedAssemblies, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        public FrameworkPathResolver(string[] frameworkPaths, InstalledAssemblies installedAssemblies, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
             _frameworkPaths = frameworkPaths;
             _installedAssemblies = installedAssemblies;
diff --git a/src/Tasks/AssemblyDependency/GacResolver.cs b/src/Tasks/AssemblyDependency/GacResolver.cs
index 16342d58a31..23e73349d61 100644
--- a/src/Tasks/AssemblyDependency/GacResolver.cs
+++ b/src/Tasks/AssemblyDependency/GacResolver.cs
@@ -24,11 +24,12 @@ internal class GacResolver : Resolver
         /// <param name="searchPathElement">The search path element.</param>
         /// <param name="getAssemblyName">Delegate to get the assembly name object.</param>
         /// <param name="fileExists">Delegate to check if the file exists.</param>
+        /// <param name="fileExistsInDirectory">Delegate to check if the file exists by cached list of files of directory.</param>
         /// <param name="getRuntimeVersion">Delegate to get the runtime version.</param>
         /// <param name="targetedRuntimeVesion">The targeted runtime version.</param>
         /// <param name="getAssemblyPathInGac">Delegate to get assembly path in the GAC.</param>
-        public GacResolver(System.Reflection.ProcessorArchitecture targetProcessorArchitecture, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, GetAssemblyPathInGac getAssemblyPathInGac)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, true)
+        public GacResolver(System.Reflection.ProcessorArchitecture targetProcessorArchitecture, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, GetAssemblyPathInGac getAssemblyPathInGac)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, targetProcessorArchitecture, true)
         {
             _getAssemblyPathInGac = getAssemblyPathInGac;
         }
diff --git a/src/Tasks/AssemblyDependency/HintPathResolver.cs b/src/Tasks/AssemblyDependency/HintPathResolver.cs
index d4a90c0e2b4..cf2787c9d92 100644
--- a/src/Tasks/AssemblyDependency/HintPathResolver.cs
+++ b/src/Tasks/AssemblyDependency/HintPathResolver.cs
@@ -16,8 +16,8 @@ internal class HintPathResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
+        public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
         }
 
diff --git a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
index b75ef96a73b..7f287fb65ca 100644
--- a/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
+++ b/src/Tasks/AssemblyDependency/RawFilenameResolver.cs
@@ -16,8 +16,8 @@ internal class RawFilenameResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public RawFilenameResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
+        public RawFilenameResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, ProcessorArchitecture.None, false)
         {
         }
 
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index dcc38343d3c..68b70aa8fb7 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -79,6 +79,8 @@ internal sealed class ReferenceTable
         private readonly DirectoryExists _directoryExists;
         /// <summary>Delegate used for getting directories.</summary>
         private readonly GetDirectories _getDirectories;
+        /// <summary>Delegate used for checking for the existence of a file in a directory.</summary>
+        private readonly FileExistsInDirectory _fileExistsInDirectory;
         /// <summary>Delegate used for getting assembly names.</summary>
         private readonly GetAssemblyName _getAssemblyName;
         /// <summary>Delegate used for finding dependencies of a file.</summary>
@@ -175,6 +177,7 @@ internal sealed class ReferenceTable
         /// <param name="installedAssemblies">Installed assembly XML tables.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
         /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
+        /// <param name="fileExistsInDirectory">Delegate used for checking for the existence of a file in a directory.</param>
         /// <param name="directoryExists">Delegate used for files.</param>
         /// <param name="getDirectories">Delegate used for getting directories.</param>
         /// <param name="getAssemblyName">Delegate used for getting assembly names.</param>
@@ -216,6 +219,7 @@ internal sealed class ReferenceTable
         /// <param name="installedAssemblies">Installed assembly XML tables.</param>
         /// <param name="targetProcessorArchitecture">Like x86 or IA64\AMD64, the processor architecture being targetted.</param>
         /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
+        /// <param name="fileExistsInDirectory">Delegate used for checking for the existence of a file in a directory.</param>
         /// <param name="directoryExists">Delegate used for files.</param>
         /// <param name="getDirectories">Delegate used for getting directories.</param>
         /// <param name="getAssemblyName">Delegate used for getting assembly names.</param>
@@ -254,6 +258,7 @@ internal ReferenceTable
             InstalledAssemblies installedAssemblies,
             System.Reflection.ProcessorArchitecture targetProcessorArchitecture,
             FileExists fileExists,
+            FileExistsInDirectory fileExistsInDirectory,
             DirectoryExists directoryExists,
             GetDirectories getDirectories,
             GetAssemblyName getAssemblyName,
@@ -293,6 +298,7 @@ internal ReferenceTable
             _fileExists = fileExists;
             _directoryExists = directoryExists;
             _getDirectories = getDirectories;
+            _fileExistsInDirectory = fileExistsInDirectory;
             _getAssemblyName = getAssemblyName;
             _getAssemblyMetadata = getAssemblyMetadata;
             _getRuntimeVersion = getRuntimeVersion;
@@ -348,6 +354,7 @@ internal ReferenceTable
                     targetProcessorArchitecture,
                     frameworkPaths,
                     fileExists,
+                    fileExistsInDirectory,
                     getAssemblyName,
 #if FEATURE_WIN32_REGISTRY
                     getRegistrySubKeyNames,
@@ -1302,14 +1309,14 @@ Reference reference
             // If a reference has the SDKName metadata on it then we will only search using a single resolver, that is the InstalledSDKResolver.
             if (reference.SDKName.Length > 0)
             {
-                jaggedResolvers.Add(new Resolver[] { new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _getRuntimeVersion, _targetedRuntimeVersion) });
+                jaggedResolvers.Add(new Resolver[] { new InstalledSDKResolver(_resolvedSDKReferences, "SDKResolver", _getAssemblyName, _fileExists, _fileExistsInDirectory, _getRuntimeVersion, _targetedRuntimeVersion) });
             }
             else
             {
                 // Do not probe near dependees if the reference is primary and resolved externally. If resolved externally, the search paths should have been specified in such a way to point to the assembly file.
                 if (assemblyName == null || !_externallyResolvedPrimaryReferences.Contains(assemblyName.Name))
                 {
-                    jaggedResolvers.Add(AssemblyResolution.CompileDirectories(parentReferenceFolders, _fileExists, _getAssemblyName, _getRuntimeVersion, _targetedRuntimeVersion));
+                    jaggedResolvers.Add(AssemblyResolution.CompileDirectories(parentReferenceFolders, _fileExists, _fileExistsInDirectory, _getAssemblyName, _getRuntimeVersion, _targetedRuntimeVersion));
                 }
 
                 jaggedResolvers.Add(Resolvers);
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index d03366aa29a..e3834148241 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -1934,6 +1934,7 @@ private List<DependentAssembly> GetAssemblyRemappingsFromAppConfig()
         /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
         /// <param name="directoryExists">Delegate used for checking for the existence of a directory.</param>
         /// <param name="getDirectories">Delegate used for finding directories.</param>
+        /// <param name="getDirectoryFiles">Delegate used to get files from directories.</param>
         /// <param name="getAssemblyName">Delegate used for finding fusion names of assemblyFiles.</param>
         /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
         /// <param name="getRegistrySubKeyNames">Used to get registry subkey names.</param>
@@ -1952,6 +1953,7 @@ private List<DependentAssembly> GetAssemblyRemappingsFromAppConfig()
         /// <param name="fileExists">Delegate used for checking for the existence of a file.</param>
         /// <param name="directoryExists">Delegate used for checking for the existence of a directory.</param>
         /// <param name="getDirectories">Delegate used for finding directories.</param>
+        /// <param name="getDirectoryFiles">Delegate used to get files from directories.</param>
         /// <param name="getAssemblyName">Delegate used for finding fusion names of assemblyFiles.</param>
         /// <param name="getAssemblyMetadata">Delegate used for finding dependencies of a file.</param>
         /// <param name="getLastWriteTime">Delegate used to get the last write time.</param>
@@ -1966,6 +1968,7 @@ internal bool Execute
             FileExists fileExists,
             DirectoryExists directoryExists,
             GetDirectories getDirectories,
+            DirectoryGetFiles getDirectoryFiles,
             GetAssemblyName getAssemblyName,
             GetAssemblyMetadata getAssemblyMetadata,
 #if FEATURE_WIN32_REGISTRY
@@ -2141,6 +2144,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                     getAssemblyMetadata = _cache.CacheDelegate(getAssemblyMetadata);
                     fileExists = _cache.CacheDelegate(fileExists);
                     directoryExists = _cache.CacheDelegate(directoryExists);
+                    FileExistsInDirectory fileExistsInDirectory = _cache.CacheDelegate(getDirectoryFiles);
                     getDirectories = _cache.CacheDelegate(getDirectories);
                     getRuntimeVersion = _cache.CacheDelegate(getRuntimeVersion);
 
@@ -2188,6 +2192,7 @@ ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader
                         installedAssemblies,
                         processorArchitecture,
                         fileExists,
+                        fileExistsInDirectory,
                         directoryExists,
                         getDirectories,
                         getAssemblyName,
@@ -3023,6 +3028,7 @@ public override bool Execute()
                 new FileExists(p => FileUtilities.FileExistsNoThrow(p)),
                 new DirectoryExists(p => FileUtilities.DirectoryExistsNoThrow(p)),
                 new GetDirectories(Directory.GetDirectories),
+                new DirectoryGetFiles((d, p) => FileUtilities.DirectoryGetFiles(d, p)),
                 new GetAssemblyName(AssemblyNameExtension.GetAssemblyNameEx),
                 new GetAssemblyMetadata(AssemblyInformation.GetAssemblyMetadata),
 #if FEATURE_WIN32_REGISTRY
diff --git a/src/Tasks/AssemblyDependency/Resolver.cs b/src/Tasks/AssemblyDependency/Resolver.cs
index be72b128729..72dd8c4a4c7 100644
--- a/src/Tasks/AssemblyDependency/Resolver.cs
+++ b/src/Tasks/AssemblyDependency/Resolver.cs
@@ -29,6 +29,11 @@ internal abstract class Resolver
         /// </summary>
         protected FileExists fileExists;
 
+        /// <summary>
+        /// Delegate.
+        /// </summary>
+        private readonly FileExistsInDirectory fileExistsInDirectory;
+
         /// <summary>
         /// Delegate
         /// </summary>
@@ -52,11 +57,12 @@ internal abstract class Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
+        protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture)
         {
             this.searchPathElement = searchPathElement;
             this.getAssemblyName = getAssemblyName;
             this.fileExists = fileExists;
+            this.fileExistsInDirectory = fileExistsInDirectory;
             this.getRuntimeVersion = getRuntimeVersion;
             this.targetedRuntimeVersion = targetedRuntimeVesion;
             this.targetProcessorArchitecture = targetedProcessorArchitecture;
@@ -109,7 +115,10 @@ protected bool ResolveAsFile
             bool isPrimaryProjectReference,
             bool wantSpecificVersion,
             bool allowMismatchBetweenFusionNameAndFileName,
-            List<ResolutionSearchLocation> assembliesConsideredAndRejected
+            List<ResolutionSearchLocation> assembliesConsideredAndRejected,
+            bool useDirectoryCache = false,
+            string directory = null,
+            string fileName = null
         )
         {
             ResolutionSearchLocation considered = null;
@@ -122,7 +131,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                 };
             }
 
-            if (FileMatchesAssemblyName(assemblyName, isPrimaryProjectReference, wantSpecificVersion, allowMismatchBetweenFusionNameAndFileName, fullPath, considered))
+            if (FileMatchesAssemblyName(assemblyName, isPrimaryProjectReference, wantSpecificVersion, allowMismatchBetweenFusionNameAndFileName, fullPath, considered, useDirectoryCache, directory, fileName))
             {
                 return true;
             }
@@ -142,6 +151,9 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
         /// <param name="allowMismatchBetweenFusionNameAndFileName">Whether to allow naming mismatch.</param>
         /// <param name="pathToCandidateAssembly">Path to a possible file.</param>
         /// <param name="searchLocation">Information about why the candidate file didn't match</param>
+        /// <param name="useDirectoryCache">Set it to true if file existence is verified by cached list of files in directory.</param>
+        /// <param name="directory">Directory of directory cache. Required if useDirectoryCache.</param>
+        /// <param name="fileName">Name of file in directory cache. Required if useDirectoryCache.</param>
         protected bool FileMatchesAssemblyName
         (
             AssemblyNameExtension assemblyName,
@@ -149,7 +161,10 @@ protected bool FileMatchesAssemblyName
             bool wantSpecificVersion,
             bool allowMismatchBetweenFusionNameAndFileName,
             string pathToCandidateAssembly,
-            ResolutionSearchLocation searchLocation
+            ResolutionSearchLocation searchLocation,
+            bool useDirectoryCache = false,
+            string directory = null,
+            string fileName = null
         )
         {
             if (searchLocation != null)
@@ -181,7 +196,27 @@ ResolutionSearchLocation searchLocation
 
             bool isSimpleAssemblyName = assemblyName?.IsSimpleName == true;
 
-            if (fileExists(pathToCandidateAssembly))
+            bool fileFound;
+            if (useDirectoryCache && Utilities.ChangeWaves.AreFeaturesEnabled(Utilities.ChangeWaves.Wave16_10))
+            {
+                // this verifies file existence using fileExistsInDirectory delegate which internally used cached set of all files in a particular directory
+                // if some cases it render better performance than one by one FileExists
+                try
+                {
+                    fileFound = fileExistsInDirectory(directory, fileName);
+                }
+                catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
+                {
+                    // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.
+                    throw new InvalidParameterValueException("SearchPaths", $"{directory.TrimEnd(Path.DirectorySeparatorChar)}{Path.DirectorySeparatorChar}{fileName}", e.Message);
+                }
+            }
+            else
+            {
+                fileFound = fileExists(pathToCandidateAssembly);
+            }
+
+            if (fileFound)
             {
                 // If the resolver we are using is targeting a given processor architecture then we must crack open the assembly and make sure the architecture is compatible
                 // We cannot do these simple name matches.
@@ -312,23 +347,25 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
             if (directory != null)
             {
                 string weakNameBase = assemblyName.Name;
+
                 foreach (string executableExtension in executableExtensions)
                 {
-                    string baseName = weakNameBase + executableExtension;
+                    string fileName = weakNameBase + executableExtension;
                     string fullPath;
 
                     try
                     {
-                        fullPath = Path.Combine(directory, baseName);
+                        fullPath = Path.Combine(directory, fileName);
                     }
                     catch (Exception e) when (ExceptionHandling.IsIoRelatedException(e))
                     {
                         // Assuming it's the search path that's bad. But combine them both so the error is visible if it's the reference itself.
-                        throw new InvalidParameterValueException("SearchPaths", directory + (directory.EndsWith("\\", StringComparison.OrdinalIgnoreCase) ? String.Empty : "\\") + baseName, e.Message);
+                        throw new InvalidParameterValueException("SearchPaths", $"{directory.TrimEnd(Path.DirectorySeparatorChar)}{Path.DirectorySeparatorChar}{fileName}", e.Message);
                     }
 
-                    // We have a full path returned 
-                    if (ResolveAsFile(fullPath, assemblyName, isPrimaryProjectReference, wantSpecificVersion, false, assembliesConsideredAndRejected))
+                    // We have a full path returned
+                    if (ResolveAsFile(fullPath, assemblyName, isPrimaryProjectReference, wantSpecificVersion, false, assembliesConsideredAndRejected,
+                        useDirectoryCache: true, directory: directory, fileName: fileName))
                     {
                         if (candidateFullPath == null)
                         {
@@ -341,7 +378,7 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                          * If targeting AMD64 / X86 / IA64 / ARM /NONE we will return the first assembly which has a matching processor architecture OR is an assembly with a processor architecture of MSIL or NONE
                          * 
                          * If targeting MSIL we will first look through all of the assemblies, if an MSIL assembly is found we will return that. If no MSIL assembly is found we will return 
-                         * the first assembly which matches reguardless of its processor architecture.
+                         * the first assembly which matches regardless of its processor architecture.
                          */
 
                         if (targetProcessorArchitecture == ProcessorArchitecture.MSIL)
@@ -378,7 +415,8 @@ List<ResolutionSearchLocation> assembliesConsideredAndRejected
                                 string fullPath = Path.Combine(directory, weakNameBase);
                                 var extensionlessAssemblyName = new AssemblyNameExtension(weakNameBaseFileName);
 
-                                if (ResolveAsFile(fullPath, extensionlessAssemblyName, isPrimaryProjectReference, wantSpecificVersion, false, assembliesConsideredAndRejected))
+                                if (ResolveAsFile(fullPath, extensionlessAssemblyName, isPrimaryProjectReference, wantSpecificVersion, false, assembliesConsideredAndRejected,
+                                    useDirectoryCache: true, directory: directory, fileName: weakNameBase))
                                 {
                                     return fullPath;
                                 }
diff --git a/src/Tasks/InstalledSDKResolver.cs b/src/Tasks/InstalledSDKResolver.cs
index 427cc8c86eb..eb091a657f8 100644
--- a/src/Tasks/InstalledSDKResolver.cs
+++ b/src/Tasks/InstalledSDKResolver.cs
@@ -22,8 +22,8 @@ internal class InstalledSDKResolver : Resolver
         /// <summary>
         /// Construct.
         /// </summary>
-        public InstalledSDKResolver(Dictionary<string, ITaskItem> resolvedSDKs, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
-            : base(searchPathElement, getAssemblyName, fileExists, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
+        public InstalledSDKResolver(Dictionary<string, ITaskItem> resolvedSDKs, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, FileExistsInDirectory fileExistsInDirectory, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion)
+            : base(searchPathElement, getAssemblyName, fileExists, fileExistsInDirectory, getRuntimeVersion, targetedRuntimeVesion, System.Reflection.ProcessorArchitecture.None, false)
         {
             _resolvedSDKs = resolvedSDKs;
         }
diff --git a/src/Tasks/SystemState.cs b/src/Tasks/SystemState.cs
index 1dd51c92c86..84c11a0b70e 100644
--- a/src/Tasks/SystemState.cs
+++ b/src/Tasks/SystemState.cs
@@ -8,6 +8,7 @@
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.IO;
+using System.Linq;
 using System.Runtime.Serialization;
 using System.Runtime.Versioning;
 using System.Security.Permissions;
@@ -54,6 +55,13 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// </summary>
         private Dictionary<string, string[]> instanceLocalDirectories = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);
 
+        /// <summary>
+        /// List of all files in directory is also purely instance-local. This information
+        /// is only considered good for the lifetime of the task (or whatever) that owns 
+        /// this instance.
+        /// </summary>
+        private Dictionary<string, HashSet<string>> instanceLocalDirectoryFiles = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);
+
         /// <summary>
         /// Additional level of caching kept at the process level.
         /// </summary>
@@ -94,6 +102,11 @@ internal sealed class SystemState : StateFileBase, ISerializable
         /// </summary>
         private DirectoryExists directoryExists;
 
+        /// <summary>
+        /// Cached delegate.
+        /// </summary>
+        private DirectoryGetFiles getFiles;
+
         /// <summary>
         /// Cached delegate.
         /// </summary>
@@ -332,6 +345,12 @@ public DirectoryExists CacheDelegate(DirectoryExists directoryExistsValue)
             return DirectoryExists;
         }
 
+        public FileExistsInDirectory CacheDelegate(DirectoryGetFiles getFilesValue)
+        {
+            getFiles = getFilesValue;
+            return FileExistsInDirectory;
+        }
+
         /// <summary>
         /// Cache the results of a GetDirectories delegate. 
         /// </summary>
@@ -573,6 +592,42 @@ private string[] GetDirectories(string path, string pattern)
             return getDirectories(path, pattern);
         }
 
+        /// <summary>
+        /// Cached implementation of GetFiles aimed to verify existence of a file in a directory.
+        /// It does not throw if directory does not exists.
+        /// </summary>
+        /// <param name="path"></param>
+        /// <param name="fileName"></param>
+        /// <returns>true if file exists</returns>
+        private bool FileExistsInDirectory(string path, string fileName)
+        {
+            // to behave same as File.Exists(Path.Combine("","file.cs") we have to map empty string to current directory
+            if (path.Length == 0)
+            {
+                path = ".";
+            }
+
+            instanceLocalDirectoryFiles.TryGetValue(path, out HashSet<string> cached);
+            if (cached == null)
+            {
+                string[] files;
+                try
+                {
+                    files = getFiles(path, "*");
+                }
+                catch (DirectoryNotFoundException)
+                {
+                    files = Array.Empty<string>();
+                }
+
+                cached = new HashSet<string>(files.Select(Path.GetFileName), StringComparer.OrdinalIgnoreCase);
+
+                instanceLocalDirectoryFiles[path] = cached;
+            }
+
+            return cached.Contains(fileName);
+        }
+
         /// <summary>
         /// Cached implementation of FileExists.
         /// </summary>
