diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 4a6847306a2..b91bebd35ca 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22601.5">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23060.6">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>4255f0e27aa7ca1065962df22b65e4f2b0cd9a4c</Sha>
+      <Sha>74b7648c106865057c78ca1e4b2ffcb5e9bce071</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.5.0-preview.3.126">
@@ -14,9 +14,9 @@
       <Uri>https://github.com/dotnet/roslyn</Uri>
       <Sha>716366a3830293571eaaad9b1b2b3929b5216f42</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22601.5">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23060.6">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>4255f0e27aa7ca1065962df22b65e4f2b0cd9a4c</Sha>
+      <Sha>74b7648c106865057c78ca1e4b2ffcb5e9bce071</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 902ab5b6c43..396469b9c9d 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,8 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.5.0</VersionPrefix>
-    <PackageValidationBaselineVersion>17.4.0</PackageValidationBaselineVersion>
+    <VersionPrefix>17.6.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.5.0-preview-23059-01</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -48,7 +48,7 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22601.5</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23060.6</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
     <MicrosoftNetCompilersToolsetVersion>4.5.0-2.22608.26</MicrosoftNetCompilersToolsetVersion>
diff --git a/global.json b/global.json
index e0b0ecc5d5d..39c8c57a412 100644
--- a/global.json
+++ b/global.json
@@ -11,6 +11,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22601.5"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23060.6"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
index 6c04b5ee80d..b04097bd028 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
@@ -653,7 +653,7 @@ private static void CreateProjectAndAssertEncoding(bool xmlDeclaration, bool byt
             content += @"<Project><Target Name=""Build""/></Project>";
             content = ObjectModelHelpers.CleanupFileContents(content);
 
-            var file = FileUtilities.GetTemporaryFile(".proj");
+            var file = FileUtilities.GetTemporaryFileName(".proj");
             try
             {
                 File.WriteAllText(file, content, new UTF8Encoding(encoderShouldEmitUTF8Identifier: byteOrderMark));
diff --git a/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
index d4c31dd57ef..c974eeb2915 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
@@ -163,12 +163,12 @@ public void SettingProjectDirties()
 
             try
             {
-                file1 = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                file1 = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                 ProjectRootElement importProject1 = ProjectRootElement.Create();
                 importProject1.AddProperty("p", "v1");
                 importProject1.Save(file1);
 
-                file2 = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                file2 = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                 ProjectRootElement importProject2 = ProjectRootElement.Create();
                 importProject2.AddProperty("p", "v2");
                 importProject2.Save(file2);
@@ -208,7 +208,7 @@ public void SettingConditionDirties()
 
             try
             {
-                file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                 ProjectRootElement importProject = ProjectRootElement.Create();
                 importProject.AddProperty("p", "v1");
                 importProject.Save(file);
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 7cbbae8a85a..da183efaaf8 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -172,7 +172,7 @@ public void SetFullPath()
         public void ConstructOverSameFileReturnsSame()
         {
             ProjectRootElement projectXml1 = ProjectRootElement.Create();
-            projectXml1.Save(FileUtilities.GetTemporaryFile());
+            projectXml1.Save(FileUtilities.GetTemporaryFileName());
 
             ProjectRootElement projectXml2 = ProjectRootElement.Open(projectXml1.FullPath);
 
@@ -429,7 +429,7 @@ public void ValidXmlInvalidSyntaxOpenFromDiskTwice()
                 {
                     try
                     {
-                        path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                        path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                         File.WriteAllText(path, content);
 
                         ProjectRootElement.Open(path);
@@ -462,7 +462,7 @@ public void ValidXmlXmlTextReaderNotCache()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(path, content);
 
                 var reader1 = XmlReader.Create(path);
@@ -499,7 +499,7 @@ public void ValidXmlXmlReaderCache()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(path, content);
 
                 ProjectRootElement root1 = ProjectRootElement.Create(path);
@@ -605,7 +605,7 @@ public void SaveWithTransformsToFile()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
 
                 project.Save(file);
 
@@ -730,7 +730,7 @@ public void EncodingGetterBasedOnXmlDeclaration()
         [Fact]
         public void EncodingGetterBasedOnActualEncodingWhenXmlDeclarationIsAbsent()
         {
-            string projectFullPath = FileUtilities.GetTemporaryFile();
+            string projectFullPath = FileUtilities.GetTemporaryFileName();
             try
             {
                 VerifyLoadedProjectHasEncoding(projectFullPath, Encoding.UTF8);
@@ -996,7 +996,7 @@ public void SolutionCorrupt()
 
                 try
                 {
-                    solutionFile = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    solutionFile = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
 
                     // Arbitrary corrupt content
                     string content = @"Microsoft Visual Studio Solution File, Format Version 10.00
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index 821da0c00f4..e739dcafc4f 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -1064,7 +1064,7 @@ public void ParseSolutionWithComments()
         private static SolutionFile ParseSolutionHelper(string solutionFileContents)
         {
             solutionFileContents = solutionFileContents.Replace('\'', '"');
-            string solutionPath = FileUtilities.GetTemporaryFile(".sln");
+            string solutionPath = FileUtilities.GetTemporaryFileName(".sln");
 
             try
             {
diff --git a/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs b/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs
index bdd6490ac91..8bbf86c4278 100644
--- a/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs
@@ -462,7 +462,7 @@ private void AssertWhiteSpacePreservation(
             // Using streams can cause issues with CRLF characters being replaced by LF going in to
             // ProjectRootElement. Saving to disk mimics the real-world behavior so we can specifically
             // test issues with CRLF characters being normalized. Related issue: #1340
-            var file = FileUtilities.GetTemporaryFile();
+            var file = FileUtilities.GetTemporaryFileName();
             var expected = ObjectModelHelpers.CleanupFileContents(updatedProject);
             string actual;
 
diff --git a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
index 09360ffbded..ca3f74502fe 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
@@ -63,7 +63,7 @@ public void AddProjectFromDisk()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement xml = ProjectRootElement.Create(path);
                 xml.Save();
 
@@ -95,7 +95,7 @@ public void AddProjectOnSave()
                 Project project = new Project();
                 Assert.Equal(0, ProjectCollection.GlobalProjectCollection.Count);
 
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 project.Save(path);
 
                 Project project2 = ProjectCollection.GlobalProjectCollection.LoadProject(path);
@@ -124,7 +124,7 @@ public void AddProjectOnSave_SpecifiedProjectCollection()
                 ProjectCollection collection = new ProjectCollection();
                 Project project = new Project(collection);
 
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 project.Save(path);
 
                 Project project2 = collection.LoadProject(path);
@@ -293,7 +293,7 @@ public void GetLoadedProjectNonExistent()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.Save(path);
                 Assert.Equal(0, ProjectCollection.GlobalProjectCollection.Count);
@@ -337,7 +337,7 @@ public void GetLoadedProjectRootElementWrongCollection()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement.Create(path).Save();
 
                 ProjectCollection collection1 = new ProjectCollection();
@@ -823,8 +823,8 @@ public void SaveToNewNameAndUnload()
 
             try
             {
-                file1 = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
+                file1 = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
 
                 Project project = new Project();
                 project.Save(file1);
@@ -855,8 +855,8 @@ public void LoadUnloadReloadSaveToNewName()
 
             try
             {
-                file1 = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
+                file1 = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
 
                 var project = new Project();
                 project.Save(file1);
@@ -891,8 +891,8 @@ public void LoadUnloadAllReloadSaveToNewName()
 
             try
             {
-                file1 = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
+                file1 = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
 
                 var project = new Project();
                 project.Save(file1);
@@ -1433,7 +1433,7 @@ public void ProjectCollectionVersionIsCorrect()
         private static string CreateProjectFile()
         {
             ProjectRootElement xml = ProjectRootElement.Create();
-            string path = FileUtilities.GetTemporaryFile();
+            string path = FileUtilities.GetTemporaryFileName();
             xml.Save(path);
             return path;
         }
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index e292037b857..0d44fcf3f06 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -319,7 +319,7 @@ public void BuiltInMetadataTimes()
 
             try
             {
-                path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(path, String.Empty);
                 FileInfo info = new FileInfo(path);
 
@@ -2063,7 +2063,7 @@ public void RenameImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     import.AddItem("i", "i1");
                     import.Save(file);
@@ -2095,7 +2095,7 @@ public void SetMetadataImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     import.AddItem("i", "i1");
                     import.Save(file);
@@ -2127,7 +2127,7 @@ public void RemoveMetadataImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     ProjectItem item = import.AddItem("i", "i1")[0];
                     item.SetMetadataValue("m", "m0");
diff --git a/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
index d2e0899334c..7dc0fae6b3f 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
@@ -263,7 +263,7 @@ public void SetPropertyImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     import.SetProperty("p", "v0");
                     import.Save(file);
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index a233c0b6477..a3457bbcd44 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -180,7 +180,7 @@ public void BasicFromFile()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
 
                 string content = GetSampleProjectContent();
                 File.WriteAllText(file, content);
@@ -413,7 +413,7 @@ public void ImportSelfIgnored()
                 Project project = new Project(collection);
                 project.Xml.AddImport("$(MSBuildProjectFullPath)");
 
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 project.Save(file);
                 project.ReevaluateIfNecessary();
 
@@ -440,8 +440,8 @@ public void ImportSelfIndirectIgnored()
                 MockLogger logger = new MockLogger();
                 collection.RegisterLogger(logger);
 
-                file = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
                 Project project = new Project(collection);
                 project.Xml.AddImport(file2);
                 project.Save(file);
@@ -476,8 +476,8 @@ public void DoubleImportIgnored()
                 MockLogger logger = new MockLogger();
                 collection.RegisterLogger(logger);
 
-                file = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
                 Project project = new Project(collection);
                 project.Xml.AddImport(file2);
                 project.Xml.AddImport(file2);
@@ -513,9 +513,9 @@ public void DoubleImportIndirectIgnored()
                 MockLogger logger = new MockLogger();
                 collection.RegisterLogger(logger);
 
-                file = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
-                file3 = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
+                file3 = FileUtilities.GetTemporaryFileName();
 
                 Project project = new Project(collection);
                 project.Xml.AddImport(file2);
@@ -649,7 +649,7 @@ public void TransformsUseCorrectDirectory_Basic()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 project.Save(file);
                 project.ReevaluateIfNecessary();
 
@@ -1359,7 +1359,7 @@ public void LastEvaluationIdAndUnload()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement.Create().Save(path);
 
                 Project project = new Project(path);
@@ -1387,7 +1387,7 @@ public void ImportedXmlModified()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement import = ProjectRootElement.Create(path);
                 import.Save();
 
@@ -2080,7 +2080,7 @@ public void BuildEvaluationUsesCustomLoggers()
                 ObjectModelHelpers.CleanupFileContents(@"<Project xmlns='msbuildnamespace'>
                 </Project>");
 
-            string importFileName = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile() + ".proj";
+            string importFileName = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName() + ".proj";
             File.WriteAllText(importFileName, importProjectContent);
 
             string projectContent =
@@ -2180,7 +2180,7 @@ public void SavingProjectClearsDirtyBit()
             string file = null;
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 project.Save(file);
             }
             finally
diff --git a/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs b/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
index b5e2c942092..880504db761 100644
--- a/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
@@ -104,7 +104,7 @@ public ProtectImports_Tests()
                 </Project>";
 
             importContents = Expand(importContents);
-            _importFilename = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile() + ".targets";
+            _importFilename = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName() + ".targets";
             File.WriteAllText(_importFilename, importContents);
         }
 
diff --git a/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
index 02211ee3081..c6866746365 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
@@ -112,7 +112,7 @@ public void FileLocationAvailableEvenAfterEdits()
 
             try
             {
-                path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                 ProjectRootElement projectXml = ProjectRootElement.Create(path);
                 projectXml.Save();
 
diff --git a/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs b/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
new file mode 100644
index 00000000000..ba4539b6d77
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
@@ -0,0 +1,79 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Xunit;
+
+#nullable disable
+
+namespace Microsoft.Build.UnitTests.BackEnd
+{
+    public class CacheSerialization_Tests
+    {
+        public static IEnumerable<object[]> CacheData
+        {
+            get
+            {
+                var configCache = new ConfigCache();
+                var brq1 = new BuildRequestConfiguration(
+                   1,
+                   new BuildRequestData("path1", new Dictionary<string, string> { ["a1"] = "b1" }, Constants.defaultToolsVersion, new[] { "target1" }, null),
+                   Constants.defaultToolsVersion);
+
+                var brq2 = new BuildRequestConfiguration(
+                    2,
+                    new BuildRequestData("path2", new Dictionary<string, string> { ["a2"] = "b2" }, Constants.defaultToolsVersion, new[] { "target2" }, null),
+                    Constants.defaultToolsVersion);
+                var brq3 = new BuildRequestConfiguration(
+                   3,
+                   new BuildRequestData("path3", new Dictionary<string, string> { ["a3"] = "b3" }, Constants.defaultToolsVersion, new[] { "target3" }, null),
+                   Constants.defaultToolsVersion);
+
+                configCache.AddConfiguration(brq1);
+                configCache.AddConfiguration(brq2);
+                configCache.AddConfiguration(brq3);
+
+                var resultsCache = new ResultsCache();
+                var request1 = new BuildRequest(1, 0, 1, new string[] { "target1" }, null, BuildEventContext.Invalid, null);
+                var request2 = new BuildRequest(2, 0, 2, new string[] { "target2" }, null, BuildEventContext.Invalid, null);
+                var request3 = new BuildRequest(3, 0, 3, new string[] { "target3" }, null, BuildEventContext.Invalid, null);
+
+                resultsCache.AddResult(new BuildResult(request1));
+                resultsCache.AddResult(new BuildResult(request2));
+                resultsCache.AddResult(new BuildResult(request3));
+
+                return new List<object[]>
+                {
+                    new object[] { configCache, resultsCache },
+                };
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(CacheData))]
+        public void OnlySerializeCacheEntryWithSmallestConfigId(object configCache, object resultsCache)
+        {
+            string cacheFile = null;
+            try
+            {
+                cacheFile = FileUtilities.GetTemporaryFile("MSBuildResultsCache");
+                Assert.Null(CacheSerialization.SerializeCaches((ConfigCache)configCache, (ResultsCache)resultsCache, cacheFile));
+
+                var result = CacheSerialization.DeserializeCaches(cacheFile);
+                Assert.True(result.ConfigCache.HasConfiguration(1));
+                Assert.False(result.ConfigCache.HasConfiguration(2));
+                Assert.False(result.ConfigCache.HasConfiguration(3));
+            }
+            finally
+            {
+                File.Delete(cacheFile);
+            }
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
index 7cfadc9a5e4..1593604ae74 100644
--- a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
@@ -5,6 +5,7 @@
 using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Shouldly;
 using Xunit;
@@ -55,6 +56,38 @@ public static IEnumerable<object[]> CacheSerializationTestData
             }
         }
 
+        public static IEnumerable<object[]> CacheSerializationTestDataNoConfigs
+        {
+            get
+            {
+                yield return new[] { new ConfigCache() };
+            }
+        }
+
+        public static IEnumerable<object[]> CacheSerializationTestDataMultipleConfigs
+        {
+            get
+            {
+                var configCache = new ConfigCache();
+                var brq1 = new BuildRequestConfiguration(
+                  1,
+                  new BuildRequestData("path1", new Dictionary<string, string> { ["a1"] = "b1" }, Constants.defaultToolsVersion, new[] { "target1" }, null),
+                  Constants.defaultToolsVersion);
+                var brq2 = new BuildRequestConfiguration(
+                  2,
+                  new BuildRequestData("path2", new Dictionary<string, string> { ["a2"] = "b2" }, Constants.defaultToolsVersion, new[] { "target2" }, null),
+                  Constants.defaultToolsVersion);
+                var brq3 = new BuildRequestConfiguration(
+                  3,
+                  new BuildRequestData("path3", new Dictionary<string, string> { ["a3"] = "b3" }, Constants.defaultToolsVersion, new[] { "target3" }, null),
+                  Constants.defaultToolsVersion);
+                configCache.AddConfiguration(brq1.ShallowCloneWithNewId(1));
+                configCache.AddConfiguration(brq2.ShallowCloneWithNewId(2));
+                configCache.AddConfiguration(brq3.ShallowCloneWithNewId(3));
+                yield return new[] { configCache };
+            }
+        }
+
         [Theory]
         [MemberData(nameof(CacheSerializationTestData))]
         public void ConfigCacheShouldBeTranslatable(object obj)
@@ -84,5 +117,19 @@ public void ConfigCacheShouldBeTranslatable(object obj)
                 copy[initialConfiguration.ConfigurationId].ProjectInitialTargets.ShouldBe(initialConfiguration.ProjectInitialTargets);
             }
         }
+
+        [Theory]
+        [MemberData(nameof(CacheSerializationTestDataNoConfigs))]
+        public void GetSmallestConfigIdThrows(object obj)
+        {
+            Assert.Throws<InternalErrorException>(() => ((ConfigCache)obj).GetSmallestConfigId());
+        }
+
+        [Theory]
+        [MemberData(nameof(CacheSerializationTestDataMultipleConfigs))]
+        public void HappyGetSmallestConfigId(object obj)
+        {
+            Assert.Equal(1, ((ConfigCache)obj).GetSmallestConfigId());
+        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
index 4370f5a3dff..6497b641bbc 100644
--- a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
@@ -3325,7 +3325,7 @@ public void RemoveItemInImportedFile()
 
             try
             {
-                importedFile = FileUtilities.GetTemporaryFile();
+                importedFile = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(importedFile, ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                   <ItemGroup>
@@ -3363,7 +3363,7 @@ public void ModifyItemInImportedFile()
 
             try
             {
-                importedFile = FileUtilities.GetTemporaryFile();
+                importedFile = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(importedFile, ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                   <ItemGroup>
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index f2abb27be9c..ae3e2cd371c 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -872,28 +872,28 @@ bool includeOutput2
             {
                 if (input1Time != null)
                 {
-                    input1 = FileUtilities.GetTemporaryFile();
+                    input1 = FileUtilities.GetTemporaryFileName();
                     File.WriteAllText(input1, String.Empty);
                     File.SetLastWriteTime(input1, (DateTime)input1Time);
                 }
 
                 if (input2Time != null)
                 {
-                    input2 = FileUtilities.GetTemporaryFile();
+                    input2 = FileUtilities.GetTemporaryFileName();
                     File.WriteAllText(input2, String.Empty);
                     File.SetLastWriteTime(input2, (DateTime)input2Time);
                 }
 
                 if (output1Time != null)
                 {
-                    output1 = FileUtilities.GetTemporaryFile();
+                    output1 = FileUtilities.GetTemporaryFileName();
                     File.WriteAllText(output1, String.Empty);
                     File.SetLastWriteTime(output1, (DateTime)output1Time);
                 }
 
                 if (output2Time != null)
                 {
-                    output2 = FileUtilities.GetTemporaryFile();
+                    output2 = FileUtilities.GetTemporaryFileName();
                     File.WriteAllText(output2, String.Empty);
                     File.SetLastWriteTime(output2, (DateTime)output2Time);
                 }
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index addc0b8858e..eb5211d2908 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -213,11 +213,13 @@ public void BinaryLoggerShouldEmbedSymlinkFilesViaTaskOutput()
             string testFileName = "foobar.txt";
             string symlinkName = "symlink1.txt";
             string symlinkLvl2Name = "symlink2.txt";
+            string emptyFileName = "empty.txt";
             TransientTestFolder testFolder = _env.DefaultTestDirectory.CreateDirectory("TestDir");
             TransientTestFolder testFolder2 = _env.DefaultTestDirectory.CreateDirectory("TestDir2");
             TransientTestFile testFile = testFolder.CreateFile(testFileName, string.Join(Environment.NewLine, new[] { "123", "456" }));
             string symlinkPath = Path.Combine(testFolder2.Path, symlinkName);
             string symlinkLvl2Path = Path.Combine(testFolder2.Path, symlinkLvl2Name);
+            string emptyFile = testFolder.CreateFile(emptyFileName).Path;
 
             string errorMessage = string.Empty;
             Assert.True(NativeMethodsShared.MakeSymbolicLink(symlinkPath, testFile.Path, ref errorMessage), errorMessage);
@@ -248,9 +250,12 @@ public void BinaryLoggerShouldEmbedSymlinkFilesViaTaskOutput()
         <CreateItem Include=""{1}"">
             <Output TaskParameter=""Include"" ItemName=""EmbedInBinlog"" />
         </CreateItem>
+        <CreateItem Include=""{2}"">
+            <Output TaskParameter=""Include"" ItemName=""EmbedInBinlog"" />
+        </CreateItem>
     </Target>
 </Project>";
-            var testProject = string.Format(testProjectFmt, symlinkPath, symlinkLvl2Path);
+            var testProject = string.Format(testProjectFmt, symlinkPath, symlinkLvl2Path, emptyFile);
             ObjectModelHelpers.BuildProjectExpectSuccess(testProject, binaryLogger);
             var projectImportsZipPath = Path.ChangeExtension(_logFile, ".ProjectImports.zip");
             using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
@@ -261,6 +266,7 @@ public void BinaryLoggerShouldEmbedSymlinkFilesViaTaskOutput()
             zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
             zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkName));
             zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkLvl2Name));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(emptyFileName));
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
index 1c797174b5c..38dcb87dd5d 100644
--- a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
+++ b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
@@ -403,7 +403,7 @@ public void SaveReadOnly4()
             var doc = new XmlDocumentWithLocation(loadAsReadOnly: true);
             doc.Load(_pathToCommonTargets);
             Assert.True(doc.IsReadOnly);
-            using (XmlWriter wr = XmlWriter.Create(new FileStream(FileUtilities.GetTemporaryFile(), FileMode.Create)))
+            using (XmlWriter wr = XmlWriter.Create(new FileStream(FileUtilities.GetTemporaryFileName(), FileMode.Create)))
             {
                 Assert.Throws<InvalidOperationException>(() =>
                 {
@@ -421,7 +421,7 @@ private string GetLocations(string content, bool readOnly)
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(file, content);
                 var doc = new XmlDocumentWithLocation(loadAsReadOnly: readOnly);
                 doc.Load(file);
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 6c726a5476d..92a1591a313 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -1947,8 +1947,7 @@ public void SolutionGeneratorCanEmitSolutions()
         [Trait("Category", "mono-osx-failing")]
         public void TestSkipInvalidConfigurationsCase()
         {
-            string tmpFileName = FileUtilities.GetTemporaryFile();
-            File.Delete(tmpFileName);
+            string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
             string solutionContents =
@@ -2024,8 +2023,7 @@ public void TestSkipInvalidConfigurationsCase()
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
         public void BadFrameworkMonkierExpectBuildToFail()
         {
-            string tmpFileName = FileUtilities.GetTemporaryFile();
-            File.Delete(tmpFileName);
+            string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
             string solutionFileContents =
@@ -2112,8 +2110,7 @@ public void BadFrameworkMonkierExpectBuildToFail()
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
         public void BadFrameworkMonkierExpectBuildToFail2()
         {
-            string tmpFileName = FileUtilities.GetTemporaryFile();
-            File.Delete(tmpFileName);
+            string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
             string solutionFileContents =
@@ -2200,8 +2197,7 @@ public void BadFrameworkMonkierExpectBuildToFail2()
         [Fact]
         public void TestTargetFrameworkVersionGreaterThan4()
         {
-            string tmpFileName = FileUtilities.GetTemporaryFile();
-            File.Delete(tmpFileName);
+            string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
             string solutionFileContents =
diff --git a/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs b/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
index 94626b132d4..3d766374a9e 100644
--- a/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
+++ b/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
@@ -1188,7 +1188,7 @@ public void DefinitionInImportedFile()
 
             try
             {
-                importedFile = FileUtilities.GetTemporaryFile();
+                importedFile = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(importedFile, @"
                 <Project ToolsVersion='msbuilddefaulttoolsversion'>
                   <ItemDefinitionGroup>
@@ -1710,7 +1710,7 @@ public void MSBuildCallDoesNotAffectCallingProjectsDefinitions()
 
             try
             {
-                otherProject = FileUtilities.GetTemporaryFile();
+                otherProject = FileUtilities.GetTemporaryFileName();
                 string otherProjectContent = @"<Project ToolsVersion=""msbuilddefaulttoolsversion"">
                   <ItemGroup>
                     <i Include='i1'/>
@@ -1766,7 +1766,7 @@ public void DefaultMetadataTravelWithTargetOutputs()
 
             try
             {
-                otherProject = FileUtilities.GetTemporaryFile();
+                otherProject = FileUtilities.GetTemporaryFileName();
                 string otherProjectContent = @"<Project ToolsVersion=""msbuilddefaulttoolsversion"">
                   <ItemGroup>
                     <i Include='i1'>
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 92781d593a1..43e9e639f96 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -788,7 +788,7 @@ public void ImportsOnlyIncludedOnce()
 
             try
             {
-                importPath = FileUtilities.GetTemporaryFile();
+                importPath = FileUtilities.GetTemporaryFileName();
 
                 string import = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns='msbuildnamespace' >
@@ -850,9 +850,9 @@ public void MultipleImportsVerifyImportsIncludingDuplicates()
 
             try
             {
-                importPath = FileUtilities.GetTemporaryFile();
-                importPath2 = FileUtilities.GetTemporaryFile();
-                importPath3 = FileUtilities.GetTemporaryFile();
+                importPath = FileUtilities.GetTemporaryFileName();
+                importPath2 = FileUtilities.GetTemporaryFileName();
+                importPath3 = FileUtilities.GetTemporaryFileName();
 
                 string import = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns='msbuildnamespace' >
@@ -926,8 +926,8 @@ public void RecordDuplicateButNotCircularImportsWithCircularImports()
 
             try
             {
-                importPath1 = FileUtilities.GetTemporaryFile();
-                importPath2 = FileUtilities.GetTemporaryFile();
+                importPath1 = FileUtilities.GetTemporaryFileName();
+                importPath2 = FileUtilities.GetTemporaryFileName();
 
                 // "import1" imports "import2" and vice versa.
                 string import1 = ObjectModelHelpers.CleanupFileContents(@"
@@ -986,8 +986,8 @@ public void RejectCircularImportsWithCircularImports()
 
                 try
                 {
-                    importPath1 = FileUtilities.GetTemporaryFile();
-                    importPath2 = FileUtilities.GetTemporaryFile();
+                    importPath1 = FileUtilities.GetTemporaryFileName();
+                    importPath2 = FileUtilities.GetTemporaryFileName();
 
                     // "import1" imports "import2" and vice versa.
                     string import1 = ObjectModelHelpers.CleanupFileContents(@"
@@ -1761,7 +1761,7 @@ public void ItemPredecessorsAndImports()
                 ProjectRootElement import = ProjectRootElement.Create();
                 import.AddItemDefinition("i").AddMetadata("m", "%(m);m1");
 
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 import.Save(file);
 
                 string content = ObjectModelHelpers.CleanupFileContents(@"
@@ -1907,7 +1907,7 @@ public void AllEvaluatedItems()
             try
             {
                 // Should include imported items
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement import = ProjectRootElement.Create(file);
                 import.AddItem("i", "i10");
                 import.Save();
@@ -1991,7 +1991,7 @@ public void AllEvaluatedPropertiesAndImports()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement import = ProjectRootElement.Create(file);
                 import.AddProperty("p", "0").Condition = "false";
                 import.AddProperty("p", "1");
diff --git a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
index 7b82202bd2d..32b32efdea2 100644
--- a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
@@ -117,7 +117,7 @@ public void GetProjectRootElementChangedOnDisk1()
             {
                 ProjectRootElementCache cache = new ProjectRootElementCache(true /* auto reload from disk */);
 
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
 
                 ProjectRootElement xml0 = ProjectRootElement.Create(path);
                 xml0.Save();
@@ -151,7 +151,7 @@ public void GetProjectRootElementChangedOnDisk2()
             {
                 ProjectRootElementCache cache = new ProjectRootElementCache(false /* do not auto reload from disk */);
 
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
 
                 ProjectRootElement xml0 = ProjectRootElement.Create(path);
                 xml0.Save();
diff --git a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
index 397e67fbecc..ab6af32e07f 100644
--- a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
@@ -42,7 +42,7 @@ Item group content
                     </Project>
                     ");
 
-                string path = FileUtilities.GetTemporaryFile();
+                string path = FileUtilities.GetTemporaryFileName();
 
                 try
                 {
@@ -100,7 +100,7 @@ Item group content
                     </Project>
                     ");
 
-                string path = FileUtilities.GetTemporaryFile();
+                string path = FileUtilities.GetTemporaryFileName();
 
                 try
                 {
@@ -176,7 +176,7 @@ public void RemovingFilesRemovesEntries()
                     </Project>
                     ");
 
-                string path = FileUtilities.GetTemporaryFile();
+                string path = FileUtilities.GetTemporaryFileName();
 
                 try
                 {
diff --git a/src/Build.UnitTests/ExpressionTree_Tests.cs b/src/Build.UnitTests/ExpressionTree_Tests.cs
index 7ab7ee1b247..4601c894936 100644
--- a/src/Build.UnitTests/ExpressionTree_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTree_Tests.cs
@@ -103,7 +103,7 @@ public void FunctionTests()
             expander.Metadata = new StringMetadataTable(null);
             bool value;
 
-            string fileThatMustAlwaysExist = FileUtilities.GetTemporaryFile();
+            string fileThatMustAlwaysExist = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(fileThatMustAlwaysExist, "foo");
             string command = "Exists('" + fileThatMustAlwaysExist + "')";
             tree = p.Parse(command, ParserOptions.AllowAll, ElementLocation.EmptyLocation);
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 96a16735cad..e7e6db9e2fe 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -58,7 +58,7 @@ public void BasicNoExistingFile()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 SetUpFileLoggerAndLogMessage("logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 VerifyFileContent(log, "message here");
 
@@ -105,7 +105,7 @@ public void SpecificVerbosity()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 FileLogger fl = new FileLogger();
                 EventSourceSink es = new EventSourceSink();
                 fl.Parameters = "verbosity=diagnostic;logfile=" + log;  // diagnostic specific setting
@@ -184,7 +184,7 @@ public void InvalidEncoding()
 
                 try
                 {
-                    log = GetTempFilename();
+                    log = FileUtilities.GetTemporaryFileName();
                     FileLogger fl = new FileLogger();
                     EventSourceSink es = new EventSourceSink();
                     fl.Parameters = "encoding=foo;logfile=" + log;
@@ -208,7 +208,7 @@ public void ValidEncoding()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 SetUpFileLoggerAndLogMessage("encoding=utf-16;logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 byte[] content = ReadRawBytes(log);
 
@@ -232,7 +232,7 @@ public void ValidEncoding2()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 SetUpFileLoggerAndLogMessage("encoding=utf-8;logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 byte[] content = ReadRawBytes(log);
 
@@ -278,7 +278,7 @@ public void BasicExistingFileNoAppend()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 WriteContentToFile(log);
                 SetUpFileLoggerAndLogMessage("logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 VerifyFileContent(log, "message here");
@@ -299,7 +299,7 @@ public void BasicExistingFileAppend()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 WriteContentToFile(log);
                 SetUpFileLoggerAndLogMessage("append;logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 VerifyFileContent(log, "existing content\nmessage here");
@@ -406,17 +406,6 @@ public void LogVerbosityMessage(LoggerVerbosity loggerVerbosity, bool shouldCont
             }
         }
 
-        /// <summary>
-        /// Gets a filename for a nonexistent temporary file.
-        /// </summary>
-        /// <returns></returns>
-        private string GetTempFilename()
-        {
-            string path = FileUtilities.GetTemporaryFile();
-            File.Delete(path);
-            return path;
-        }
-
         /// <summary>
         /// Writes a string to a file.
         /// </summary>
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 318c2c6f92f..4d28600f8a1 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -585,7 +585,7 @@ public void SolutionEdgesShouldNotOverwriteMultitargetingEdges()
             var graph = new ProjectGraph(_env.CreateFile("solution.sln", solutionContents).Path);
 
             var edges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
-            edges.Count.ShouldBe(8);
+            edges.Count.ShouldBe(10);
 
             var node1 = GetFirstNodeWithProjectNumber(graph, 1);
             node1.ProjectReferences.Count.ShouldBe(3);
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index 65b1b86965c..fd6e5a951c3 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -6,6 +6,7 @@
 using System.IO;
 using System.Linq;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Shouldly;
@@ -36,40 +37,50 @@ internal static class GraphTestingUtilities
                                                                                             <AddTransitiveProjectReferencesInStaticGraph>true</AddTransitiveProjectReferencesInStaticGraph>
                                                                                          </PropertyGroup>";
 
-        public static void AssertOuterBuildAsNonRoot(
+        public static void AssertOuterBuild(
             ProjectGraphNode outerBuild,
             ProjectGraph graph,
             Dictionary<string, string> additionalGlobalProperties = null,
             int expectedInnerBuildCount = 2)
         {
-            additionalGlobalProperties ??= new Dictionary<string, string>();
+            additionalGlobalProperties ??= new Dictionary<string, string>(0);
 
             AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
 
-            outerBuild.ProjectReferences.ShouldBeEmpty();
-            outerBuild.ReferencingProjects.ShouldNotBeEmpty();
+            outerBuild.ProjectReferences.Count.ShouldBe(expectedInnerBuildCount);
 
-            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)
+            // Outer -> Inner build edges
+            foreach (ProjectGraphNode innerBuild in outerBuild.ProjectReferences)
             {
-                var innerBuilds =
-                    outerBuildReferencer.ProjectReferences.Where(
-                        p =>
-                            IsInnerBuild(p) 
-                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();
+                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
+
+                ProjectItemInstance edge = graph.TestOnly_Edges[(outerBuild, innerBuild)];
+                edge.DirectMetadataCount.ShouldBe(1);
+
+                string expectedPropertiesMetadata = $"{InnerBuildPropertyName}={innerBuild.ProjectInstance.GlobalProperties[InnerBuildPropertyName]}";
+                edge.GetMetadata("Properties").EvaluatedValue.ShouldBe(expectedPropertiesMetadata);
+            }
+
+            // Ensure edges were added directly to the inner builds
+            foreach (ProjectGraphNode outerBuildReferencer in outerBuild.ReferencingProjects)
+            {
+                ProjectGraphNode[] innerBuilds = outerBuildReferencer.ProjectReferences
+                    .Where(p => IsInnerBuild(p) && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath)
+                    .ToArray();
 
                 innerBuilds.Length.ShouldBe(expectedInnerBuildCount);
 
-                foreach (var innerBuild in innerBuilds)
+                foreach (ProjectGraphNode innerBuild in innerBuilds)
                 {
                     AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
 
                     innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);
-                    innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);
+                    innerBuild.ReferencingProjects.ShouldContain(outerBuild);
 
-                    graph.TestOnly_Edges.HasEdge((outerBuild, innerBuild)).ShouldBeFalse();
+                    graph.TestOnly_Edges.HasEdge((outerBuild, innerBuild)).ShouldBeTrue();
 
-                    var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
-                    var edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
+                    ProjectItemInstance edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
+                    ProjectItemInstance edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
 
                     edgeToOuterBuild.ShouldBe(edgeToInnerBuild);
                 }
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 2a17d2e97d0..273d6d4a7eb 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -971,13 +971,13 @@ public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()
         [Fact]
         public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBuilds()
         {
-            var projectReferenceTargetsProtocol =
+            string projectReferenceTargetsProtocol =
 $@"<ItemGroup>
      <ProjectReferenceTargets Include='A' Targets='{MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker};A;AInner' />
      <ProjectReferenceTargets Include='A' Targets='{MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker};A;AOuter' OuterBuild='true' />
    </ItemGroup>";
 
-            var entryProject = CreateProjectFile(
+            string entryProject = CreateProjectFile(
                 env: _env,
                 projectNumber: 1,
                 projectReferences: null,
@@ -1015,28 +1015,28 @@ public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBui
 
             var dot = graph.ToDot();
 
-            var rootOuterBuild = GetOuterBuild(graph, 1);
-            var nonRootOuterBuild = GetOuterBuild(graph, 3);
+            ProjectGraphNode rootOuterBuild = GetOuterBuild(graph, 1);
+            ProjectGraphNode nonRootOuterBuild = GetOuterBuild(graph, 3);
 
-            AssertOuterBuildAsRoot(rootOuterBuild, graph);
-            AssertOuterBuildAsNonRoot(nonRootOuterBuild, graph);
+            AssertOuterBuild(rootOuterBuild, graph);
+            AssertOuterBuild(nonRootOuterBuild, graph);
 
-            var targetLists = graph.GetTargetLists(new[] {"A"});
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(new[] { "A" });
 
-            targetLists[rootOuterBuild].ShouldBe(new []{"A"});
+            targetLists[rootOuterBuild].ShouldBe(new[] { "A" });
 
-            foreach (var innerBuild in GetInnerBuilds(graph, 1))
+            foreach (ProjectGraphNode innerBuild in GetInnerBuilds(graph, 1))
             {
-                targetLists[innerBuild].ShouldBe(new []{"D1", "A", "AOuter", "AInner"});
+                targetLists[innerBuild].ShouldBe(new[] { "D1", "A", "AOuter", "AInner" });
             }
 
-            targetLists[GetFirstNodeWithProjectNumber(graph, 2)].ShouldBe(new []{"T2", "A", "AOuter", "AInner"});
+            targetLists[GetFirstNodeWithProjectNumber(graph, 2)].ShouldBe(new[] { "T2", "A", "AOuter", "AInner" });
 
-            targetLists[nonRootOuterBuild].ShouldBe(new []{"T3", "A", "AOuter"});
+            targetLists[nonRootOuterBuild].ShouldBe(new[] { "T3", "A", "AOuter" });
 
-            foreach (var innerBuild in GetInnerBuilds(graph, 3))
+            foreach (ProjectGraphNode innerBuild in GetInnerBuilds(graph, 3))
             {
-                targetLists[innerBuild].ShouldBe(new []{"T3", "A", "AOuter", "AInner"});
+                targetLists[innerBuild].ShouldBe(new[] { "T3", "A", "AOuter", "AInner", "D3" });
             }
         }
 
@@ -1531,31 +1531,6 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
             Regex.Matches(dot,"label").Count.ShouldBe(graph.ProjectNodes.Count);
         }
 
-        private static void AssertOuterBuildAsRoot(
-            ProjectGraphNode outerBuild,
-            ProjectGraph graph,
-            Dictionary<string, string> additionalGlobalProperties = null,
-            int expectedInnerBuildCount = 2)
-        {
-            additionalGlobalProperties ??= new Dictionary<string, string>();
-
-            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
-
-            outerBuild.ReferencingProjects.ShouldBeEmpty();
-            outerBuild.ProjectReferences.Count.ShouldBe(expectedInnerBuildCount);
-
-            foreach (var innerBuild in outerBuild.ProjectReferences)
-            {
-                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
-
-                var edge = graph.TestOnly_Edges[(outerBuild, innerBuild)];
-                edge.DirectMetadataCount.ShouldBe(1);
-
-                var expectedPropertiesMetadata = $"{InnerBuildPropertyName}={innerBuild.ProjectInstance.GlobalProperties[InnerBuildPropertyName]}";
-                edge.GetMetadata("Properties").EvaluatedValue.ShouldBe(expectedPropertiesMetadata);
-            }
-        }
-
         [Fact]
         public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
         {
@@ -1569,7 +1544,7 @@ public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
 
             var outerBuild = graph.GraphRoots.First();
 
-            AssertOuterBuildAsRoot(outerBuild, graph);
+            AssertOuterBuild(outerBuild, graph);
         }
 
         [Fact]
@@ -1596,7 +1571,7 @@ public void OuterBuildAsNonRootShouldNotReferenceInnerBuilds()
 
             var outerBuild = GetOuterBuild(graph, 2);
 
-            AssertOuterBuildAsNonRoot(outerBuild, graph);
+            AssertOuterBuild(outerBuild, graph);
         }
 
         [Fact]
@@ -1630,7 +1605,7 @@ public void InnerBuildsFromNonRootOuterBuildInheritEdgesToOuterBuild()
 
             var outerBuild = GetOuterBuild(graph, 2);
 
-            AssertOuterBuildAsNonRoot(outerBuild, graph);
+            AssertOuterBuild(outerBuild, graph);
 
             var outerBuildReferencingNode = GetFirstNodeWithProjectNumber(graph, 1);
 
@@ -1652,7 +1627,7 @@ public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
                                                     <InnerBuildProperties>a;a</InnerBuildProperties>
                                                 </PropertyGroup>";
 
-            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, multitargetingSpecification).Path;
+            var root = CreateProjectFile(_env, 1, new[] { 2 }, null, null, multitargetingSpecification).Path;
             CreateProjectFile(_env, 2, null, null, null, multitargetingSpecification);
 
             var graph = new ProjectGraph(root);
@@ -1664,8 +1639,8 @@ public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
             var rootOuterBuild = GetOuterBuild(graph, 1);
             var nonRootOuterBuild = GetOuterBuild(graph, 2);
 
-            AssertOuterBuildAsRoot(rootOuterBuild, graph, null, 1);
-            AssertOuterBuildAsNonRoot(nonRootOuterBuild, graph, null, 1);
+            AssertOuterBuild(rootOuterBuild, graph, null, 1);
+            AssertOuterBuild(nonRootOuterBuild, graph, null, 1);
         }
 
         [Fact]
@@ -1680,7 +1655,7 @@ public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGl
 
             graph.ProjectNodes.Count.ShouldBe(4);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
+            AssertOuterBuild(graph.GraphRoots.First(), graph);
 
             var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);
 
@@ -1748,8 +1723,8 @@ public void NonMultitargetingProjectsAreCompatibleWithMultitargetingProjects()
 
             graph.ProjectNodes.Count.ShouldBe(8);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
-            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 4), graph);
+            AssertOuterBuild(graph.GraphRoots.First(), graph);
+            AssertOuterBuild(GetOuterBuild(graph, 4), graph);
 
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2));
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));
@@ -1775,9 +1750,9 @@ public void InnerBuildsCanHaveSeparateReferences()
 
             graph.ProjectNodes.Count.ShouldBe(11);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
-            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 2), graph);
-            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 2), graph);
+            AssertOuterBuild(graph.GraphRoots.First(), graph);
+            AssertOuterBuild(GetOuterBuild(graph, 2), graph);
+            AssertOuterBuild(GetOuterBuild(graph, 2), graph);
 
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 5));
@@ -1817,7 +1792,7 @@ public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
 
             var outerBuild = graph.GraphRoots.First(IsOuterBuild);
 
-            AssertOuterBuildAsRoot(outerBuild, graph, additionalGlobalProperties);
+            AssertOuterBuild(outerBuild, graph, additionalGlobalProperties);
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2), additionalGlobalProperties);
 
             var referencedInnerBuild = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GetPropertyValue(InnerBuildPropertyName) == "a");
@@ -1895,7 +1870,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
 
             var outerBuild1 = GetOuterBuild(graph, 1);
 
-            AssertOuterBuildAsRoot(outerBuild1, graph, additionalGlobalProperties);
+            AssertOuterBuild(outerBuild1, graph, additionalGlobalProperties);
 
             var innerBuild1WithReferenceToInnerBuild2 = outerBuild1.ProjectReferences.FirstOrDefault(n => IsInnerBuild(n) && n.ProjectInstance.GlobalProperties[InnerBuildPropertyName] == "a");
             innerBuild1WithReferenceToInnerBuild2.ShouldNotBeNull();
@@ -2226,9 +2201,9 @@ public void TransitiveReferencesShouldNotBeAddedToOuterBuilds()
                 innerBuild.AssertReferencesIgnoringOrder(new []{3, 4, 4, 4, 5, 6, 6, 6});
             }
 
-            GetFirstNodeWithProjectNumber(graph, 2).AssertReferencesIgnoringOrder(new []{3, 4, 4, 4, 5, 6, 6, 6});
+            GetFirstNodeWithProjectNumber(graph, 2).AssertReferencesIgnoringOrder(new[] { 3, 4, 4, 4, 5, 6, 6, 6 });
 
-            GetOuterBuild(graph, 4).AssertReferencesIgnoringOrder(Array.Empty<int>());
+            GetOuterBuild(graph, 4).AssertReferencesIgnoringOrder(new[] { 4, 4 });
 
             var innerBuilds4 = GetInnerBuilds(graph, 4);
             innerBuilds4.Count.ShouldBe(2);
@@ -2303,7 +2278,7 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
             var outerBuild1 = GetOuterBuild(graph, 1);
             targetLists[outerBuild1].ShouldBe(new[] {"Build"});
 
-            AssertOuterBuildAsRoot(outerBuild1, graph, expectedInnerBuildCount: 2);
+            AssertOuterBuild(outerBuild1, graph, expectedInnerBuildCount: 2);
 
             var innerBuildsFor1 = GetInnerBuilds(graph, 1);
             innerBuildsFor1.Count.ShouldBe(2);
@@ -2316,7 +2291,7 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
 
             var outerBuild2 = GetOuterBuild(graph, 2);
             targetLists[outerBuild2].ShouldBe(new[] {"BuildForOuterBuild"});
-            AssertOuterBuildAsNonRoot(outerBuild2, graph, expectedInnerBuildCount: 2);
+            AssertOuterBuild(outerBuild2, graph, expectedInnerBuildCount: 2);
 
             var innerBuildsFor2 = GetInnerBuilds(graph, 2);
             innerBuildsFor2.Count.ShouldBe(2);
@@ -2331,13 +2306,13 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
 
             outerBuild3.ReferencingProjects.Count.ShouldBe(4);
 
-            AssertOuterBuildAsNonRoot(outerBuild3, graph, expectedInnerBuildCount: 2);
+            AssertOuterBuild(outerBuild3, graph, expectedInnerBuildCount: 2);
             var innerBuildsFor3 = GetInnerBuilds(graph, 3);
             innerBuildsFor3.Count.ShouldBe(2);
 
             foreach (var inner3 in innerBuildsFor3)
             {
-                inner3.ReferencingProjects.Count.ShouldBe(4);
+                inner3.ReferencingProjects.Count.ShouldBe(5);
 
                 // 3 does not get called with 1ATarget or 1BTarget because those apply only to direct references
                 targetLists[inner3]
diff --git a/src/Build/BackEnd/BuildManager/CacheSerialization.cs b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
index 4c337378637..950182296ab 100644
--- a/src/Build/BackEnd/BuildManager/CacheSerialization.cs
+++ b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.IO;
+using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 
@@ -61,6 +62,27 @@ public static string SerializeCaches(IConfigCache configCache, IResultsCache res
                             break;
                     }
 
+                    // Avoid creating new config and results caches if no projects were built in violation
+                    // of isolation mode.
+                    if (configCacheToSerialize.Count() > 1)
+                    {
+                        // We need to preserve all configurations to enable the scheduler to dump them and their
+                        // associated requests, so create new caches to serialize storing solely data
+                        // associated with the project specified to be built in isolation (and not any
+                        // data associated with referenced projects needed for said project to complete
+                        // its build).
+                        var tempConfigCacheToSerialize = new ConfigCache();
+
+                        // The project that was built in isolation mode has the
+                        // smallest configuration id.
+                        int smallestCacheConfigId = configCacheToSerialize.GetSmallestConfigId();
+                        tempConfigCacheToSerialize.AddConfiguration(configCacheToSerialize[smallestCacheConfigId]);
+                        configCacheToSerialize = tempConfigCacheToSerialize;
+                        var tempResultsCacheToSerialize = new ResultsCache();
+                        tempResultsCacheToSerialize.AddResult(resultsCacheToSerialize.GetResultsForConfiguration(smallestCacheConfigId));
+                        resultsCacheToSerialize = tempResultsCacheToSerialize;
+                    }
+
                     translator.Translate(ref configCacheToSerialize);
                     translator.Translate(ref resultsCacheToSerialize);
                 }
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index d2821aee570..f2eac09484f 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -200,6 +201,21 @@ public void ClearConfigurations()
             }
         }
 
+        /// <summary>
+        /// Gets the smallest configuration id of any configuration
+        /// in this cache.
+        /// </summary>
+        /// <returns>Gets the smallest configuration id of any
+        /// configuration in this cache.</returns>
+        public int GetSmallestConfigId()
+        {
+            lock (_lockObject)
+            {
+                ErrorUtilities.VerifyThrow(_configurations.Count > 0, "No configurations exist from which to obtain the smallest configuration id.");
+                return _configurations.OrderBy(kvp => kvp.Key).First().Key;
+            }
+        }
+    
         /// <summary>
         /// Clears configurations from the configuration cache which have not been explicitly loaded.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/CurrentHost.cs b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
index 81116ecb054..5eec58d2d0b 100644
--- a/src/Build/BackEnd/Components/Communications/CurrentHost.cs
+++ b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
@@ -1,9 +1,11 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if RUNTIME_TYPE_NETCORE || MONO
 using System.Diagnostics;
 using System.IO;
 using Microsoft.Build.Shared;
+#endif
 
 #nullable disable
 
diff --git a/src/Build/BackEnd/Components/Communications/INodeProvider.cs b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
index 0da32af6678..810dc4d9011 100644
--- a/src/Build/BackEnd/Components/Communications/INodeProvider.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
@@ -3,7 +3,6 @@
 
 using System;
 
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
index 9a08a3940a7..b39bcc78b9e 100644
--- a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Diagnostics;
 using System.Globalization;
-using System.IO;
 using System.Runtime.InteropServices;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 88f5feea51b..337cbd76f03 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -9,7 +9,9 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
+#if FEATURE_THREAD_CULTURE
 using BuildParameters = Microsoft.Build.Execution.BuildParameters;
+#endif
 using NodeEngineShutdownReason = Microsoft.Build.Execution.NodeEngineShutdownReason;
 
 #nullable disable
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index cd5a88127e0..77741a46412 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -10,15 +10,15 @@
 using System.IO.Pipes;
 using System.Diagnostics;
 using System.Linq;
-using System.Threading;
 using System.Threading.Tasks;
-using System.Runtime.InteropServices;
 #if FEATURE_PIPE_SECURITY
 using System.Security.Principal;
 #endif
 
 #if FEATURE_APM
 using Microsoft.Build.Eventing;
+#else
+using System.Threading;
 #endif
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index cfd6c3a61da..11aea7b2c52 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Concurrent;
-using System.Linq;
 using System.Reflection;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
diff --git a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
index c1fa3e463a7..1a4d63c65a9 100644
--- a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections;
-using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
index cb85cae4558..9f51cf9e10a 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.ProjectCache
diff --git a/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs b/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
index 505fa0ed693..4ebc567c45d 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
@@ -1,14 +1,14 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.IO;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
index 7888b1a6679..71f82542916 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 62510fe9f4a..2807134993f 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -10,8 +10,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
-using System.Transactions;
 
 #nullable disable
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 0a048df26d4..38bc4c3c23a 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index 7ccb8008ceb..ce94320a586 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -14,7 +14,6 @@
 using Microsoft.Build.Eventing;
 using System.Linq;
 using System.Text.RegularExpressions;
-using System.Diagnostics;
 
 #nullable disable
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index fb7c35ad18e..ce0b8db4ad0 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -23,7 +23,6 @@
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Task = System.Threading.Tasks.Task;
-using System.Linq;
 
 #nullable disable
 
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index e5c1677ee6a..b581d671b9d 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -7,9 +7,6 @@
 using System.Diagnostics;
 using System.Diagnostics.Contracts;
 using System.Runtime.Serialization;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 using System.Diagnostics.CodeAnalysis;
 using System.Security;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index caae6ee03a0..db1aa93901e 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -8,10 +8,8 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 645181ce8f7..f8f74e0686a 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -5,9 +5,7 @@
 using System;
 using System.Diagnostics;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index 79d4de04eb6..a49654cefca 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using Microsoft.Build.Collections;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index ce0dc977426..cbbc06d0cef 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using Microsoft.CodeAnalysis.Collections;
 using System;
 using System.Collections.Generic;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index f0c19a5c681..2e0cf86d90d 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -3,7 +3,6 @@
 
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using System;
 using System.Collections.Generic;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index b742bb23311..8fbcc487daa 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -4,7 +4,6 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index 612c1a8d9d1..88c299dd571 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Framework;
 using System.Collections.Immutable;
 using System.Linq;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 871ad820e6a..cddd1390eda 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -9,12 +9,13 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 
 using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using System.Linq;
 using System.Threading;
 
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index d9843d908e9..92464daafd4 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -6,9 +6,7 @@
 using System.IO;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
 
 #nullable disable
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 09263b6b97c..776514e4d7d 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -6,7 +6,6 @@
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
-using System.Security.Cryptography.Xml;
 using System.Text;
 using System.Threading;
 using Microsoft.Build.BackEnd;
@@ -117,7 +116,7 @@ private void AddEdges(Dictionary<ConfigurationMetadata, ParsedProject> allParsed
 
             AddEdgesFromProjectReferenceItems(allParsedProjects, Edges);
 
-            _projectInterpretation.ReparentInnerBuilds(allParsedProjects, this);
+            _projectInterpretation.AddInnerBuildEdges(allParsedProjects, this);
 
             if (_solutionDependencies != null && _solutionDependencies.Count != 0)
             {
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index bbd597033fb..a293483551b 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -105,12 +105,12 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                 var requesterPlatform = "";
                 var requesterPlatformLookupTable = "";
 
-                if ( !projectReferenceItem.HasMetadata(SetPlatformMetadataName) && ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
+                if (!projectReferenceItem.HasMetadata(SetPlatformMetadataName) && ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
                 {
                     requesterPlatform = requesterInstance.GetPropertyValue("Platform");
                     requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
 
-                    var  projectInstance = _projectInstanceFactory(
+                    var projectInstance = _projectInstanceFactory(
                         projectReferenceFullPath,
                         null, // Platform negotiation requires an evaluation with no global properties first
                         _projectCollection);
@@ -164,30 +164,28 @@ internal static ProjectType GetProjectType(ProjectInstance project)
         }
 
         /// <summary>
-        /// To avoid calling nuget at graph construction time, the graph is initially constructed with outer build nodes referencing inner build nodes.
-        /// However, at build time, for non root outer builds, the inner builds are NOT referenced by the outer build, but by the nodes referencing the
-        /// outer build. Change the graph to mimic this behaviour.
-        /// Examples
-        /// OuterAsRoot -> Inner go to OuterAsRoot -> Inner. Inner builds remain the same, parented to their outer build
-        /// Node -> Outer -> Inner go to: Node -> Outer; Node->Inner; Outer -> empty. Inner builds get reparented to Node
+        /// To avoid calling nuget at graph construction time, the graph is initially constructed with nodes referencing outer build nodes which in turn
+        /// reference inner build nodes. However at build time, the inner builds are referenced directly by the nodes referencing the outer build.
+        /// Change the graph to mimic this behaviour.
+        /// Example: Node -> Outer -> Inner go to: Node -> Outer; Node->Inner; Outer -> Inner. Inner build edges get added to Node.
         /// </summary>
-        public void ReparentInnerBuilds(Dictionary<ConfigurationMetadata, ParsedProject> allNodes, GraphBuilder graphBuilder)
+        public void AddInnerBuildEdges(Dictionary<ConfigurationMetadata, ParsedProject> allNodes, GraphBuilder graphBuilder)
         {
-            foreach (var node in allNodes)
+            foreach (KeyValuePair<ConfigurationMetadata, ParsedProject> node in allNodes)
             {
-                var outerBuild = node.Value.GraphNode;
+                ProjectGraphNode outerBuild = node.Value.GraphNode;
 
                 if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)
                 {
-                    foreach (var innerBuild in outerBuild.ProjectReferences)
+                    foreach (ProjectGraphNode innerBuild in outerBuild.ProjectReferences)
                     {
-                        foreach (var outerBuildReferencingProject in outerBuild.ReferencingProjects)
+                        foreach (ProjectGraphNode outerBuildReferencingProject in outerBuild.ReferencingProjects)
                         {
                             // Which edge should be used to connect the outerBuildReferencingProject to the inner builds?
                             // Decided to use the outerBuildBuildReferencingProject -> outerBuild edge in order to preserve any extra metadata
                             // information that may be present on the edge, like the "Targets" metadata which specifies what
                             // targets to call on the references.
-                            var newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
+                            ProjectItemInstance newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
 
                             if (outerBuildReferencingProject.ProjectReferences.Contains(innerBuild))
                             {
@@ -204,8 +202,6 @@ public void ReparentInnerBuilds(Dictionary<ConfigurationMetadata, ParsedProject>
                             outerBuildReferencingProject.AddProjectReference(innerBuild, newInnerBuildEdge, graphBuilder.Edges);
                         }
                     }
-
-                    outerBuild.RemoveReferences(graphBuilder.Edges);
                 }
             }
         }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index de9f9d01451..d3cb5c170a7 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -23,7 +23,6 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using ObjectModel = System.Collections.ObjectModel;
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index bc191a256a9..41135bc767b 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -3,13 +3,11 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 using System.Reflection;
 #if FEATURE_APPDOMAIN
 using System.Threading.Tasks;
 #endif
 
-using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index e7aac941dd4..3e29b27e99e 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -3,7 +3,6 @@
 using System.IO.Compression;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
index 4e6973c3ed4..15f5a816ccf 100644
--- a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
+++ b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
@@ -130,7 +130,7 @@ private void AddFileCore(string filePath)
                 return;
             }
 
-            if (!NativeMethodsShared.ExistAndHasContent(filePath))
+            if (!File.Exists(filePath))
             {
                 _processedFiles.Add(filePath);
                 return;
@@ -144,8 +144,8 @@ private void AddFileCore(string filePath)
                 return;
             }
 
-            using Stream entryStream = OpenArchiveEntry(filePath);
             using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);
+            using Stream entryStream = OpenArchiveEntry(filePath);
             content.CopyTo(entryStream);
         }
 
diff --git a/src/Build/Logging/FancyLogger/ANSIBuilder.cs b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
index 2a161bd6667..79b4e833241 100644
--- a/src/Build/Logging/FancyLogger/ANSIBuilder.cs
+++ b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
@@ -3,11 +3,7 @@
 //
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using System.Text.RegularExpressions;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Logging.FancyLogger
 {
@@ -239,6 +235,16 @@ public static string SavePosition()
             public static string RestorePosition() {
                 return String.Format("\x1b[u");
             }
+
+            public static string Invisible()
+            {
+                return "\x1b[?25l";
+            }
+
+            public static string Visible()
+            {
+                return "\x1b[?25h";
+            }
         }
 
         public static class Tabulator
diff --git a/src/Build/Logging/FancyLogger/FancyLogger.cs b/src/Build/Logging/FancyLogger/FancyLogger.cs
index 2eb3d10200e..19238214324 100644
--- a/src/Build/Logging/FancyLogger/FancyLogger.cs
+++ b/src/Build/Logging/FancyLogger/FancyLogger.cs
@@ -1,29 +1,17 @@
-// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
 using System.Collections.Generic;
-
 using Microsoft.Build.Framework;
-using System.Runtime.InteropServices;
-using System.Threading;
-using System.Threading.Tasks;
-using System.IO;
 
 namespace Microsoft.Build.Logging.FancyLogger
 {
     public class FancyLogger : ILogger
-    {
-        // TODO: Move somewhere else
-        public string GetUnambiguousPath(string path)
-        {
-            // Get last part of path
-            return Path.GetFileName(path);
-        }
-
-        public FancyLoggerNode root = new FancyLoggerNode(-1, FancyLoggerNodeType.None);
+    {   
+        private Dictionary<int, FancyLoggerProjectNode> projects = new Dictionary<int, FancyLoggerProjectNode>();
 
-        public Dictionary<int, FancyLoggerBufferLine> projectConsoleLines = new Dictionary<int, FancyLoggerBufferLine>();
+        private bool Succeeded;
 
         private float existingTasks = 1;
         private float completedTasks = 0;
@@ -43,17 +31,19 @@ public void Initialize(IEventSource eventSource)
             // Started
             eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);
             eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);
-            // eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);
-            // eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);
+            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);
+            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);
             // Finished
             eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);
             eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);
-            // eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);
+            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);
             // eventSource.TaskFinished += new TaskFinishedEventHandler(eventSource_TaskFinished);
             // Raised
             eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);
             eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);
             eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);
+            // Cancelled
+            Console.CancelKeyPress += new ConsoleCancelEventHandler(console_CancelKeyPressed);
             // Initialize FancyLoggerBuffer
             FancyLoggerBuffer.Initialize();
         }
@@ -64,6 +54,7 @@ void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
         }
         void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
         {
+            Succeeded = e.Succeeded;
             // Console.WriteLine(LoggerFormatting.Bold("[Build]") + "\t Finished");
         }
 
@@ -73,43 +64,52 @@ void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
             // If id already exists...
-            if (projectConsoleLines.ContainsKey(id)) return;
-            // Create line
-            FancyLoggerBufferLine line = FancyLoggerBuffer.WriteNewLine(
-                ANSIBuilder.Alignment.SpaceBetween(
-                    $"{ANSIBuilder.Graphics.Spinner()} {ANSIBuilder.Formatting.Dim("Project - ")} {GetUnambiguousPath(e.ProjectFile!)}",
-                    "(5 targets completed)",
-                    Console.WindowWidth
-                )
-            );
-
-            projectConsoleLines.Add(id, line);
+            if (projects.ContainsKey(id)) return;
+            // Add project
+            FancyLoggerProjectNode node = new FancyLoggerProjectNode(e);
+            projects[id] = node;
+            // Log
+            node.Log();
         }
         void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
         {
             // Get project id
             int id = e.BuildEventContext!.ProjectInstanceId;
-            if(!projectConsoleLines.TryGetValue(id, out FancyLoggerBufferLine? line)) return;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
             // Update line
-            FancyLoggerBuffer.UpdateLine(line.Id,
-                ANSIBuilder.Alignment.SpaceBetween(
-                    $"{ANSIBuilder.Formatting.Color("", ANSIBuilder.Formatting.ForegroundColor.Green)} {ANSIBuilder.Formatting.Dim("Project - ")} {ANSIBuilder.Formatting.Color(GetUnambiguousPath(e.ProjectFile!), ANSIBuilder.Formatting.ForegroundColor.Green)}",
-                    "(5 targets completed)",
-                    Console.WindowWidth
-                )
-            );
+            node.Finished = true;
+            node.Log();
         }
         // Target
         void eventSource_TargetStarted(object sender, TargetStartedEventArgs e)
         {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddTarget(e);
+            node.Log();
         }
         void eventSource_TargetFinished(object sender, TargetFinishedEventArgs e)
         {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.FinishedTargets++;
+            node.Log();
         }
 
         // Task
         void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
         {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddTask(e);
+            node.Log();
             existingTasks++;
         }
 
@@ -120,25 +120,69 @@ void eventSource_TaskFinished(object sender, TaskFinishedEventArgs e)
 
         void eventSource_MessageRaised(object sender, BuildMessageEventArgs e)
         {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddMessage(e);
+            node.Log();
         }
         void eventSource_WarningRaised(object sender, BuildWarningEventArgs e)
         {
-            FancyLoggerBuffer.WriteNewLine("Warning");
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddWarning(e);
+            node.Log();
         }
         void eventSource_ErrorRaised(object sender, BuildErrorEventArgs e)
         {
-            // TODO: Try to redirect to stderr
-            FancyLoggerBuffer.WriteNewLine("Error");
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddError(e);
+            node.Log();
         }
 
+        void console_CancelKeyPressed(object? sender, ConsoleCancelEventArgs eventArgs)
+        {
+            // Shutdown logger
+            Shutdown();
+        }
 
-        public void Shutdown() {
-            // Keep open if autoscroll disabled (the user is reading info)
-            while (FancyLoggerBuffer.AutoScrollEnabled || !FancyLoggerBuffer.IsTerminated)
+        public void Shutdown()
+        {
+            FancyLoggerBuffer.Terminate();
+            // TODO: Remove. There is a bug that causes switching to main buffer without deleting the contents of the alternate buffer
+            Console.Clear();
+            Console.Out.Flush();
+            int errorCount = 0;
+            int warningCount = 0;
+            foreach (var project in projects)
             {
+                errorCount += project.Value.ErrorCount;
+                warningCount += project.Value.WarningCount;
+                foreach (var message in project.Value.AdditionalDetails)
+                {
+                    Console.WriteLine(message.ToANSIString());
+                }
+            }
+            // Emmpty line
+            Console.WriteLine();
+            if (Succeeded)
+            {
+                Console.WriteLine(ANSIBuilder.Formatting.Color("Build succeeded.", ANSIBuilder.Formatting.ForegroundColor.Green));
+                Console.WriteLine($"\t{warningCount} Warning(s)");
+                Console.WriteLine($"\t{errorCount} Error(s)");
+            }
+            else
+            {
+                Console.WriteLine(ANSIBuilder.Formatting.Color("Build failed.", ANSIBuilder.Formatting.ForegroundColor.Red));
+                Console.WriteLine($"\t{warningCount} Warnings(s)");
+                Console.WriteLine($"\t{errorCount} Errors(s)");
             }
-            FancyLoggerBuffer.Terminate();
-            Console.WriteLine("Build status, warnings and errors will be shown here after the build has ended and the interactive logger has closed");
         }
     }
 }
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs b/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
index cac4aafd7ef..25280e06101 100644
--- a/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
+++ b/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
@@ -1,5 +1,6 @@
-// Licensed to the .NET Foundation under one or more agreements.
+// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
+//
 
 using System;
 using System.Collections.Generic;
@@ -9,257 +10,194 @@
 
 namespace Microsoft.Build.Logging.FancyLogger
 {
-    /// <summary>
-    /// Represents an identifiable line inside the fancylogger buffer.
-    /// </summary>
     public class FancyLoggerBufferLine
     {
-        private static int counter = 0;
+        private static int Counter = 0;
         public int Id;
         public string Text;
-        public bool IsHidden;
-        public int IdentationLevel = -1;
+
         public FancyLoggerBufferLine()
         {
-            Id = counter++;
+            Id = Counter++;
             Text = String.Empty;
         }
         public FancyLoggerBufferLine(string text)
+            : this()
         {
-            Id = counter++;
             Text = text;
         }
-        public FancyLoggerBufferLine(string text, int identationLevel) : this(text)
-        {
-            IdentationLevel = identationLevel;
-        }
-        public void Hide()
-        {
-            IsHidden = true;
-        }
-        public void Unhide()
-        {
-            IsHidden = false;
-        }
-        public int GetIndex()
-        {
-            return FancyLoggerBuffer.GetLineIndexById(Id);
-        }
     }
 
-    /// <summary>
-    /// Buffer manager for FancyLogger
-    /// </summary>
-    internal static class FancyLoggerBuffer
+    public class FancyLoggerBuffer
     {
-        // Status
-        public static bool AutoScrollEnabled { get; private set; }
-        public static bool IsTerminated { get; private set; }
-        public static int CurrentTopLineIndex { get; private set; }
-        public static int Height { get { return Console.WindowHeight; } }
-        // Lines to be presented by the buffer
-        private static List<FancyLoggerBufferLine> lines = new();
+        private static List<FancyLoggerBufferLine> Lines = new();
+        private static int TopLineIndex = 0;
+        private static bool AutoScrollEnabled = true;
         public static void Initialize()
         {
-            // Setup event listeners
+            // Use alternate buffer
+            // TODO: Remove. Tries to solve a bug when switching from and to the alternate buffer
+            // Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
+            Console.OutputEncoding = Encoding.UTF8;
+            Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
+
+            Console.Write(ANSIBuilder.Cursor.Invisible());
+
+            Task.Run(async () => {
+                while (true)
+                {
+                    await Task.Delay(500 / 60);
+                    Render();
+                }
+            });
+
             Task.Run(() =>
             {
                 while (true)
                 {
-                    if (IsTerminated) return;
                     switch (Console.ReadKey().Key)
                     {
-                        case ConsoleKey.Q:
-                            IsTerminated = true;
-                        break;
                         case ConsoleKey.UpArrow:
-                            ScrollToLine(CurrentTopLineIndex - 1);
+                            if (TopLineIndex > 0) TopLineIndex--;
                             break;
                         case ConsoleKey.DownArrow:
-                            ScrollToLine(CurrentTopLineIndex + 1);
-                            break;
-                        case ConsoleKey.Home:
-                            ScrollToLine(0);
-                            break;
-                        case ConsoleKey.End:
-                            ScrollToEnd();
+                            if (TopLineIndex < Console.BufferHeight - 3) TopLineIndex++;
                             break;
                         case ConsoleKey.Spacebar:
                         case ConsoleKey.Escape:
-                            ToggleAutoScroll();
+                            AutoScrollEnabled = !AutoScrollEnabled;
                             break;
                     }
                 }
             });
-            // Switch to alternate
-            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
-            Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
-            // Settings
-            AutoScrollEnabled = true;
-            // Render contents
-            WriteTitleBar();
-            WriteFooter("~~~~~~~~~~~~~~~~~~~~~~~~~~~");
-            ScrollToEnd();
         }
+
         public static void Terminate()
         {
-            // Switch to main buffer
+            // TODO: Remove. Tries to solve a bug when switching from and to the alternate buffer
+            Console.Clear();
             Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
-            // Dispose event listeners
-            IsTerminated = true;
-            // Delete lines
-            lines = new();
+            Console.Write(ANSIBuilder.Eraser.Display());
+
+            Console.Write(ANSIBuilder.Cursor.Visible());
+            Lines = new();
         }
 
-        #region Scrolling
-        private static void ScrollToLine(int firstLineIndex)
-        {
-            if (firstLineIndex < 0 || firstLineIndex >= lines.Count) return;
-            CurrentTopLineIndex = firstLineIndex;
-            int i = 0;
-            while (i < Height - 4)
+        #region Rendering
+        public static void Render()
+        {
+            if (Lines.Count == 0) return;
+            // Write Header
+            Console.Write(
+                // Write header
+                ANSIBuilder.Cursor.Home() +
+                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center("MSBuild - Build in progress")) +
+                // Write footer
+                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
+                // TODO: Remove and replace with actual footer
+                new string('-', Console.BufferWidth) + '\n' + "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
+            );
+            // Write lines
+            for (int i = 0; i < Console.BufferHeight - 3; i++)
             {
-                int lineIndex = i + firstLineIndex;
-                Console.Write(""
-                    + ANSIBuilder.Cursor.Position(i + 2, 0)
-                    + ANSIBuilder.Eraser.LineCursorToEnd()
-                    // + ((lineIndex < lines.Count && lines[lineIndex].IsHidden) ? " Hidden" : "")
-                    + ((lineIndex < lines.Count) ? ANSIBuilder.Tabulator.ForwardTab(lines[lineIndex].IdentationLevel) + lines[lineIndex].Text : "")
+                int lineIndex = i + TopLineIndex;
+                Console.Write(
+                    ANSIBuilder.Cursor.Position(i + 2, 0) +
+                    ANSIBuilder.Eraser.LineCursorToEnd() + 
+                    (lineIndex < Lines.Count ? Lines[lineIndex].Text : String.Empty)
                 );
-                i++;
-            }
-
-            Console.Write(ANSIBuilder.Cursor.Position(Height, 0));
-        }
-        private static void ScrollToEnd()
-        { 
-            // If number of lines is smaller than height
-            if (lines.Count < Height - 2)
-            {
-                ScrollToLine(0);
-            }
-            else
-            {
-                ScrollToLine(lines.Count - Height + 4);
             }
-            // Go to end
-            Console.Write(ANSIBuilder.Cursor.Position(Height, 0));
-        }
-        private static void ToggleAutoScroll()
-        {
-            AutoScrollEnabled = !AutoScrollEnabled;
         }
         #endregion
-        #region Line Referencing
+
+        #region Line identification
         public static int GetLineIndexById(int lineId)
         {
-            for (int i = 0; i < lines.Count; i++)
+            for (int i = 0; i < Lines.Count; i++)
             {
-                if (lines[i].Id == lineId) return i;
+                if (Lines[i].Id == lineId) return i;
             }
             return -1;
         }
+
         public static FancyLoggerBufferLine? GetLineById(int lineId)
         {
-            int i = GetLineIndexById(lineId);
-            if (i == -1) return null;
-            return lines[i];
+            int index = GetLineIndexById(lineId);
+            if (index == -1) return null;
+            return Lines[index];
         }
         #endregion
-        #region Writing
-        public static void WriteTitleBar()
-        {
-            Console.Write(""
-                + ANSIBuilder.Cursor.Home()
-                + ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center("MSBuild - Build in progress"))
-            );
-        }
-        public static void WriteFooter(string text)
-        {
-            Console.Write(""
-                + ANSIBuilder.Cursor.Position(Height - 2, 0) // Position at bottom
-                + new string('-', Console.BufferWidth) + "\n"
-                + ANSIBuilder.Eraser.LineCursorToEnd()
-                + text
-            );
-        }
-        public static FancyLoggerBufferLine WriteNewLine(string text)
-        {
-            // Create line
-            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
-            return WriteNewLine(line);
-        }
-        public static FancyLoggerBufferLine WriteNewLine(FancyLoggerBufferLine line)
-        {
-            // Add line
-            lines.Add(line);
-            // Update contents
-            if (AutoScrollEnabled) ScrollToEnd();
-            else ScrollToLine(CurrentTopLineIndex);
-            return line;
-        }
-        public static FancyLoggerBufferLine? WriteNewLineAfter(string text, int lineId)
-        {
-            // get line
-            int lineIndex = GetLineIndexById(lineId);
-            if (lineIndex == -1) return null;
 
+        #region Line create, update and delete
+        // Write new line
+        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, string text)
+        {
             FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
-            return WriteNewLineAfterIndex(line, lineIndex);
+            return WriteNewLineAfter(lineId, line);
         }
-
-        public static FancyLoggerBufferLine? WriteNewLineAfter(FancyLoggerBufferLine line, int lineId)
+        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, FancyLoggerBufferLine line)
         {
-            // get line
+            // Get line index
             int lineIndex = GetLineIndexById(lineId);
             if (lineIndex == -1) return null;
-
-            return WriteNewLineAfterIndex(line, lineIndex);
+            // Save top line
+            int topLineId = Lines[TopLineIndex].Id;
+            // Add
+            Lines.Insert(lineIndex + 1, line);
+            // Get updated top line index
+            TopLineIndex = GetLineIndexById(topLineId);
+            // Return
+            return line;
         }
 
-        public static FancyLoggerBufferLine? WriteNewLineAfterIndex(FancyLoggerBufferLine line, int lineIndex)
+        public static FancyLoggerBufferLine? WriteNewLine(string text)
         {
-            if (lineIndex == -1) return null;
-            lines.Insert(lineIndex + 1, line);
-            // Scroll to end if lineIndex >= lines
-            // if (lineIndex >= lines.Count -2 && AutoScrollEnabled) ScrollToEnd();
-            // else ScrollToLine(CurrentTopLineIndex);
-            ScrollToEnd();
-            return line;
+            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
+            return WriteNewLine(line);
         }
-
-        public static void DeleteLine(int lineId)
+        public static FancyLoggerBufferLine? WriteNewLine(FancyLoggerBufferLine line)
         {
-            int lineIndex = GetLineIndexById(lineId);
-            if (lineIndex == -1) return;
-            lines.RemoveAt(lineIndex);
-            ScrollToLine(CurrentTopLineIndex);
+            // Get last id
+            if (Lines.Count > 0)
+            {
+                int lineId = Lines.Last().Id;
+                return WriteNewLineAfter(lineId, line);
+            }
+            else
+            {
+                Lines.Add(line);
+                return line;
+            }
         }
 
+        // Update line
         public static FancyLoggerBufferLine? UpdateLine(int lineId, string text)
         {
+            // Get line
             FancyLoggerBufferLine? line = GetLineById(lineId);
             if (line == null) return null;
-
             line.Text = text;
-            ScrollToLine(CurrentTopLineIndex);
+            // Return
             return line;
         }
-        #endregion
 
-        public static void HideLine(int lineId)
-        {
-            FancyLoggerBufferLine? line = GetLineById(lineId);
-            if (line == null) return;
-            line.Hide();
-            ScrollToLine(CurrentTopLineIndex);
-        }
-        public static void UnhideLine(int lineId)
+        // Delete line
+        public static void DeleteLine(int lineId)
         {
-            FancyLoggerBufferLine? line = GetLineById(lineId);
-            if (line == null) return;
-            line.Unhide();
-            ScrollToLine(CurrentTopLineIndex);
+            // TODO: What if line id is equal to topLineId?????
+            // Get line index
+            int lineIndex = GetLineIndexById(lineId);
+            if (lineIndex == -1) return;
+            // Save top line
+            int topLineId = Lines[TopLineIndex].Id;
+            // Delete
+            Lines.RemoveAt(lineIndex);
+            // Get updated top line index
+            if (topLineId != lineId)
+            {
+                TopLineIndex = GetLineIndexById(topLineId);
+            }
         }
+        #endregion
     }
 }
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
new file mode 100644
index 00000000000..3fd242849b9
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
@@ -0,0 +1,90 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    public class FancyLoggerMessageNode
+    {
+        public enum MessageType
+        {
+            HighPriorityMessage,
+            Warning,
+            Error
+        }
+        public string Message;
+        public FancyLoggerBufferLine? Line;
+        public MessageType Type;
+        //
+        public string? Code;
+        public string? FilePath;
+        public int? LineNumber;
+        public int? ColumnNumber;
+        public FancyLoggerMessageNode(LazyFormattedBuildEventArgs args)
+        {
+            // Get type
+            switch (args)
+            {
+                case BuildMessageEventArgs:
+                    Type = MessageType.HighPriorityMessage;
+                    break;
+                case BuildWarningEventArgs warning:
+                    Type = MessageType.Warning;
+                    Code = warning.Code;
+                    FilePath = warning.File;
+                    LineNumber = warning.LineNumber;
+                    ColumnNumber = warning.ColumnNumber;
+                    break;
+                case BuildErrorEventArgs error:
+                    Type = MessageType.Error;
+                    Code = error.Code;
+                    FilePath = error.File;
+                    LineNumber = error.LineNumber;
+                    ColumnNumber = error.ColumnNumber;
+                    break;
+            }
+
+            // TODO: Replace
+            if (args.Message == null)
+            {
+                Message = string.Empty;
+            }
+            else if (args.Message.Length > Console.WindowWidth - 1)
+            {
+                Message = args.Message.Substring(0, Console.WindowWidth - 1);
+            }
+            else
+            {
+                Message = args.Message;
+            }
+        }
+
+        public string ToANSIString()
+        {
+            switch (Type)
+            {
+                case MessageType.Warning:
+                    return $" {ANSIBuilder.Formatting.Color(
+                        $"Warning {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
+                        ANSIBuilder.Formatting.ForegroundColor.Yellow)}";
+                case MessageType.Error:
+                    return $" {ANSIBuilder.Formatting.Color(
+                        $"Error {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
+                        ANSIBuilder.Formatting.ForegroundColor.Red)}";
+                case MessageType.HighPriorityMessage:
+                default:
+                    return $" {ANSIBuilder.Formatting.Italic(Message)}";
+            }
+        }
+
+        public void Log()
+        {
+            if (Line == null) return;
+            FancyLoggerBuffer.UpdateLine(Line.Id, $"     {ToANSIString()}");
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerNode.cs
deleted file mode 100644
index b3021f042eb..00000000000
--- a/src/Build/Logging/FancyLogger/FancyLoggerNode.cs
+++ /dev/null
@@ -1,151 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-//
-
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Logging.FancyLogger
-{ 
-    // TODO: Maybe remove
-    public enum FancyLoggerNodeType
-    {
-        None,
-        Build,
-        Project,
-        Target,
-        Task,
-        Message,
-        Warning,
-        Error
-    }
-
-    public class FancyLoggerNode
-    {
-        public string Id;
-        public Dictionary<string, FancyLoggerNode> Children = new Dictionary<string, FancyLoggerNode>();
-        public FancyLoggerNode? Parent;
-        public FancyLoggerBufferLine? Line;
-        public int Depth = 0;
-        public FancyLoggerNode(string id)
-        {
-            Id = id;
-        }
-        public FancyLoggerNode(int id, FancyLoggerNodeType type)
-        {
-            switch (type)
-            {
-                case FancyLoggerNodeType.Build:
-                    Id = $"build-{id}";
-                    break;
-                case FancyLoggerNodeType.Project:
-                    Id = $"project-{id}";
-                    break;
-                case FancyLoggerNodeType.Target:
-                    Id = $"target-{id}";
-                    break;
-                case FancyLoggerNodeType.Task:
-                    Id = $"task-{id}";
-                    break;
-                case FancyLoggerNodeType.Message:
-                    Id = $"message-{id}";
-                    break;
-                case FancyLoggerNodeType.Warning:
-                    Id = $"warning-{id}";
-                    break;
-                case FancyLoggerNodeType.Error:
-                    Id = $"error-{id}";
-                    break;
-                default:
-                    Id = id.ToString(); break;
-            }
-        }
-        public FancyLoggerNode? Find(string id)
-        {
-            // If self
-            if(Id == id) return this;
-            // If no children
-            if(Children.Count == 0) return null;
-            // Iterate
-            foreach (var child in Children)
-            {
-                FancyLoggerNode? node = child.Value.Find(id);
-                if (node != null) return node;
-            }
-            return null;
-        }
-
-        public void Add(FancyLoggerNode node)
-        {
-            if (Children.ContainsKey(node.Id)) return;
-            Children.Add(node.Id, node);
-            node.Depth = Depth + 1;
-            node.Parent = this;
-        }
-
-        public int GetLastLineIndex()
-        {
-            // If no line, return -1
-            if (Line == null) return -1;
-            // Get line index and id
-            int lastLineIndex = FancyLoggerBuffer.GetLineIndexById(Line.Id);
-            int lastLineId = Line.Id;
-            if (lastLineIndex == -1) return -1;
-            // Get max of children
-            foreach (var child in Children)
-            {
-                int childLastLineIndex = child.Value.GetLastLineIndex();
-                if (childLastLineIndex > lastLineIndex)
-                {
-                    lastLineIndex = childLastLineIndex;
-                    lastLineId = child.Value.Line!.Id;
-                }
-            }
-            return lastLineIndex;
-        }
-
-        public void Write()
-        {
-            if (Line == null) { return; }
-            // Adjust identation
-            Line.IdentationLevel = Depth - 1;
-            // If line not in the buffer, add
-            if (FancyLoggerBuffer.GetLineIndexById(Line.Id) == -1)
-            {
-                // Get parent last line index
-                if (Parent != null)
-                {
-                    int parentLastLineId = Parent.GetLastLineIndex();
-                    // if (parentLastLineId == -1) throw new Exception("Oops something went wrong");
-                    if (parentLastLineId == -1) return;
-                    // FancyLoggerBuffer.WriteNewLineAfter(Line, parentLastLineId);
-                    FancyLoggerBuffer.WriteNewLineAfterIndex(Line, parentLastLineId);
-                }
-            }
-        }
-
-        public void Collapse()
-        {
-            foreach (var child in Children)
-            {
-                if (child.Value.Line == null) continue;
-                FancyLoggerBuffer.HideLine(child.Value.Line.Id);
-                child.Value.Collapse();
-            }
-        }
-
-        public void Expand()
-        {
-            foreach (var child in Children)
-            {
-                if (child.Value.Line == null) continue;
-                FancyLoggerBuffer.UnhideLine(child.Value.Line.Id);
-                child.Value.Expand();
-            }
-        }
-    }
-}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
new file mode 100644
index 00000000000..50effc76709
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
@@ -0,0 +1,138 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+    internal class FancyLoggerProjectNode
+    {
+        /// <summary>
+        /// Given a list of paths, this method will get the shortest not ambiguous path for a project.
+        /// Example: for `/users/documents/foo/project.csproj` and `/users/documents/bar/project.csproj`, the respective non ambiguous paths would be `foo/project.csproj` and `bar/project.csproj`
+        /// Still work in progress...
+        /// </summary>
+        private static string GetUnambiguousPath(string path)
+        {
+            return Path.GetFileName(path);
+        }
+
+        public int Id;
+        public string ProjectPath;
+        public string TargetFramework;
+        public bool Finished;
+        // Line to display project info
+        public FancyLoggerBufferLine? Line;
+        // Targets
+        public int FinishedTargets;
+        public FancyLoggerBufferLine? CurrentTargetLine;
+        public FancyLoggerTargetNode? CurrentTargetNode;
+        // Messages, errors and warnings
+        public List<FancyLoggerMessageNode> AdditionalDetails = new();
+        // Count messages, warnings and errors
+        public int MessageCount = 0;
+        public int WarningCount = 0;
+        public int ErrorCount = 0;
+        public FancyLoggerProjectNode(ProjectStartedEventArgs args)
+        {
+            Id = args.ProjectId;
+            ProjectPath = args.ProjectFile!;
+            Finished = false;
+            FinishedTargets = 0;
+            if (args.GlobalProperties != null && args.GlobalProperties.ContainsKey("TargetFramework"))
+            {
+                TargetFramework = args.GlobalProperties["TargetFramework"];
+            }
+            else
+            {
+                TargetFramework = "";
+            }
+        }
+
+        public void Log()
+        {
+            // Project details
+            string lineContents = ANSIBuilder.Alignment.SpaceBetween(
+                // Show indicator
+                (Finished ? ANSIBuilder.Formatting.Color("", ANSIBuilder.Formatting.ForegroundColor.Green) : ANSIBuilder.Formatting.Blinking(ANSIBuilder.Graphics.Spinner())) +
+                // Project
+                ANSIBuilder.Formatting.Dim("Project: ") +
+                // Project file path with color
+                $"{ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), Finished ? ANSIBuilder.Formatting.ForegroundColor.Green : ANSIBuilder.Formatting.ForegroundColor.Default )} [{TargetFramework ?? "*"}]",
+                $"({MessageCount} Messages, {WarningCount} Warnings, {ErrorCount} Errors)",
+                Console.WindowWidth
+            );
+
+            // Create or update line
+            if (Line == null) Line = FancyLoggerBuffer.WriteNewLine(lineContents);
+            else FancyLoggerBuffer.UpdateLine(Line.Id, lineContents);
+
+            // For finished projects
+            if (Finished)
+            {
+                if (CurrentTargetLine != null) FancyLoggerBuffer.DeleteLine(CurrentTargetLine.Id);
+                foreach (FancyLoggerMessageNode node in AdditionalDetails.ToList())
+                {
+                    // Only delete high priority messages
+                    if (node.Type != FancyLoggerMessageNode.MessageType.HighPriorityMessage) continue;
+                    if (node.Line != null) FancyLoggerBuffer.DeleteLine(node.Line.Id);
+                    // AdditionalDetails.Remove(node);
+                }
+            }
+
+            // Current target details
+            if (CurrentTargetNode == null) return;
+            string currentTargetLineContents = $"     {CurrentTargetNode.TargetName} : {CurrentTargetNode.CurrentTaskNode?.TaskName ?? String.Empty}";
+            if (CurrentTargetLine == null) CurrentTargetLine = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
+            else FancyLoggerBuffer.UpdateLine(CurrentTargetLine.Id, currentTargetLineContents);
+
+            // Messages, warnings and errors
+            foreach (FancyLoggerMessageNode node in AdditionalDetails)
+            {
+                if (Finished && node.Type == FancyLoggerMessageNode.MessageType.HighPriorityMessage) continue;
+                if (node.Line == null) node.Line = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, "Message");
+                node.Log();
+            }
+        }
+
+        public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)
+        {
+            CurrentTargetNode = new FancyLoggerTargetNode(args);
+            return CurrentTargetNode;
+        }
+        public FancyLoggerTaskNode? AddTask(TaskStartedEventArgs args)
+        {
+            // Get target id
+            int targetId = args.BuildEventContext!.TargetId;
+            if (CurrentTargetNode?.Id == targetId) return CurrentTargetNode.AddTask(args);
+            else return null;
+        }
+        public FancyLoggerMessageNode? AddMessage(BuildMessageEventArgs args)
+        {
+            if (args.Importance != MessageImportance.High) return null;
+            MessageCount++;
+            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            AdditionalDetails.Add(node);
+            return node;
+        }
+        public FancyLoggerMessageNode? AddWarning(BuildWarningEventArgs args)
+        {
+            WarningCount++;
+            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            AdditionalDetails.Add(node);
+            return node;
+        }
+        public FancyLoggerMessageNode? AddError(BuildErrorEventArgs args)
+        {
+            ErrorCount++;
+            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            AdditionalDetails.Add(node);
+            return node;
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs
new file mode 100644
index 00000000000..0c5ad00ed4f
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs
@@ -0,0 +1,26 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    public class FancyLoggerTargetNode
+    {
+        public int Id;
+        public string TargetName;
+        public FancyLoggerTaskNode? CurrentTaskNode;
+        public FancyLoggerTargetNode(TargetStartedEventArgs args)
+        {
+            Id = args.BuildEventContext!.TargetId;
+            TargetName = args.TargetName;
+        }
+        public FancyLoggerTaskNode AddTask(TaskStartedEventArgs args)
+        {
+            CurrentTaskNode = new FancyLoggerTaskNode(args);
+            return CurrentTaskNode;
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs
new file mode 100644
index 00000000000..d645a5daedc
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs
@@ -0,0 +1,20 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    public class FancyLoggerTaskNode
+    {
+        public int Id;
+        public string TaskName;
+        public FancyLoggerTaskNode(TaskStartedEventArgs args)
+        {
+            Id = args.BuildEventContext!.TaskId;
+            TaskName = args.TaskName;
+        }
+    }
+}
diff --git a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
index 84c2508d8e1..2e92c39751e 100644
--- a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
+++ b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Diagnostics;
 using System.Text;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 62d277bbdb2..8d7cf63540a 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using ColorSetter = Microsoft.Build.Logging.ColorSetter;
 using ColorResetter = Microsoft.Build.Logging.ColorResetter;
 using WriteHandler = Microsoft.Build.Logging.WriteHandler;
diff --git a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
index edd9b7ee18a..1cac0aa734f 100644
--- a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
@@ -5,7 +5,9 @@
 using System.Text;
 using System.Reflection;
 using System.Globalization;
+#if DEBUG
 using System.Diagnostics;
+#endif
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
diff --git a/src/Deprecated/Engine/Shared/ResourceUtilities.cs b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
index d6443759b87..3be5976f2aa 100644
--- a/src/Deprecated/Engine/Shared/ResourceUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
@@ -2,8 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+#if !BUILDINGAPPXTASKS && DEBUG
 using System.Resources;
 using System.Diagnostics;
+#endif
 using System.Globalization;
 using System.Text.RegularExpressions;
 
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index e3020e9de14..f6809d2e4bf 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -56,6 +56,7 @@
     <GenerateResourceMSBuildArchitecture>CurrentArchitecture</GenerateResourceMSBuildArchitecture>
     <GenerateResourceMSBuildRuntime>CurrentRuntime</GenerateResourceMSBuildRuntime>
 
+    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
 
     <PackageLicenseUrl Condition="'$(PackageLicenseExpression)' == ''">http://go.microsoft.com/fwlink/?LinkId=329770</PackageLicenseUrl>
diff --git a/src/Framework/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
index 32948ee3d39..e625642076d 100644
--- a/src/Framework/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -3,10 +3,13 @@
 
 using System;
 using System.Globalization;
-using System.Linq;
 using System.Reflection;
 
+#if !FEATURE_CULTUREINFO_GETCULTURES
+using System.Linq;
 using Microsoft.Build.Framework;
+#endif
+
 
 // Declare this to get init properties. See https://github.com/dotnet/roslyn/issues/45510#issuecomment-694977239
 #nullable disable
diff --git a/src/Framework/ErrorUtilities.cs b/src/Framework/ErrorUtilities.cs
index 20792056fb0..f90c6cc9d82 100644
--- a/src/Framework/ErrorUtilities.cs
+++ b/src/Framework/ErrorUtilities.cs
@@ -2,10 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 #nullable disable
 
diff --git a/src/Framework/FileClassifier.cs b/src/Framework/FileClassifier.cs
index a214a751443..9ea92f4fccb 100644
--- a/src/Framework/FileClassifier.cs
+++ b/src/Framework/FileClassifier.cs
@@ -4,11 +4,13 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
-using System.Linq;
 using System.Runtime.InteropServices;
+#if !RUNTIME_TYPE_NETCORE
+using System.Diagnostics;
+using System.Linq;
 using System.Text.RegularExpressions;
+#endif
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index f871d073876..cac89847adf 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -10,8 +10,6 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-using System.Text;
-using System.Threading;
 
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
@@ -1043,99 +1041,6 @@ internal static MemoryStatus GetMemoryStatus()
         return null;
     }
 
-    internal static bool ExistAndHasContent(string path)
-    {
-        var fileInfo = new FileInfo(path);
-
-        // File exist and has some content
-        return fileInfo.Exists &&
-               (fileInfo.Length > 0 ||
-                    // Or final destination of the link is nonempty file
-                    (
-                        IsSymLink(fileInfo) &&
-                        TryGetFinalLinkTarget(fileInfo, out string finalTarget, out _) &&
-                        File.Exists(finalTarget) &&
-                        new FileInfo(finalTarget).Length > 0
-                    )
-               );
-    }
-
-    internal static bool IsSymLink(FileInfo fileInfo)
-    {
-#if NET
-        return fileInfo.Exists && !string.IsNullOrEmpty(fileInfo.LinkTarget);
-#else
-        if (!IsWindows)
-        {
-            return false;
-        }
-
-        WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
-
-        return NativeMethods.GetFileAttributesEx(fileInfo.FullName, 0, ref data) &&
-               (data.fileAttributes & NativeMethods.FILE_ATTRIBUTE_DIRECTORY) == 0 &&
-               (data.fileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;
-#endif
-    }
-
-    internal static bool IsSymLink(string path)
-    {
-        return IsSymLink(new FileInfo(path));
-    }
-
-    internal static bool TryGetFinalLinkTarget(FileInfo fileInfo, out string finalTarget, out string errorMessage)
-    {
-        if (!IsWindows)
-        {
-            errorMessage = null;
-#if NET
-            while(!string.IsNullOrEmpty(fileInfo.LinkTarget))
-            {
-                fileInfo = new FileInfo(fileInfo.LinkTarget);
-            }
-            finalTarget = fileInfo.FullName;
-            return true;
-#else
-
-            finalTarget = null;
-            return false;
-#endif
-        }
-
-        using SafeFileHandle handle = OpenFileThroughSymlinks(fileInfo.FullName);
-        if (handle.IsInvalid)
-        {
-            // Link is broken.
-            errorMessage = Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;
-            finalTarget = null;
-            return false;
-        }
-
-        const int initialBufferSize = 4096;
-        char[] targetPathBuffer = new char[initialBufferSize];
-        uint result = GetFinalPathNameByHandle(handle, targetPathBuffer);
-
-        // Buffer too small
-        if (result > targetPathBuffer.Length)
-        {
-            targetPathBuffer = new char[(int)result];
-            result = GetFinalPathNameByHandle(handle, targetPathBuffer);
-        }
-
-        // Error
-        if (result == 0)
-        {
-            errorMessage = Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;
-            finalTarget = null;
-            return false;
-        }
-
-        // Normalize \\?\ and \??\ syntax.
-        finalTarget = new string(targetPathBuffer, 0, (int)result).TrimStart(new char[] { '\\', '?' });
-        errorMessage = null;
-        return true;
-    }
-
     internal static bool MakeSymbolicLink(string newFileName, string exitingFileName, ref string errorMessage)
     {
         bool symbolicLinkCreated;
@@ -1778,20 +1683,6 @@ out FILETIME lpLastWriteTime
     [DllImport("libc", SetLastError = true)]
     internal static extern int symlink(string oldpath, string newpath);
 
-    internal const uint FILE_NAME_NORMALIZED = 0x0;
-
-    [SupportedOSPlatform("windows")]
-    static uint GetFinalPathNameByHandle(SafeFileHandle fileHandle, char[] filePath) =>
-        GetFinalPathNameByHandle(fileHandle, filePath, (uint) filePath.Length, FILE_NAME_NORMALIZED);
-
-    [DllImport("Kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
-    [SupportedOSPlatform("windows")]
-    static extern uint GetFinalPathNameByHandle(
-        SafeFileHandle hFile,
-        [Out] char[] lpszFilePath,
-        uint cchFilePath,
-        uint dwFlags);
-
     #endregion
 
     #region helper methods
diff --git a/src/Framework/Sdk/SdkResultItem.cs b/src/Framework/Sdk/SdkResultItem.cs
index febbbeffabc..7feba81b7e6 100644
--- a/src/Framework/Sdk/SdkResultItem.cs
+++ b/src/Framework/Sdk/SdkResultItem.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics.CodeAnalysis;
 using System.Linq;
 
 namespace Microsoft.Build.Framework
diff --git a/src/Framework/StringBuilderCache.cs b/src/Framework/StringBuilderCache.cs
index e8b0ebb30cb..5b21061d9ae 100644
--- a/src/Framework/StringBuilderCache.cs
+++ b/src/Framework/StringBuilderCache.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Diagnostics;
 using System.Text;
-#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
 using Microsoft.Build.Eventing;
 #endif
 
diff --git a/src/Framework/VisualStudioLocationHelper.cs b/src/Framework/VisualStudioLocationHelper.cs
index 4ec70063990..be2ec623f5b 100644
--- a/src/Framework/VisualStudioLocationHelper.cs
+++ b/src/Framework/VisualStudioLocationHelper.cs
@@ -1,7 +1,7 @@
 using System;
 using System.Collections.Generic;
-using System.Runtime.InteropServices;
 #if FEATURE_VISUALSTUDIOSETUP
+using System.Runtime.InteropServices;
 using Microsoft.VisualStudio.Setup.Configuration;
 #endif
 
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 7de79854e86..3597bc3fa3d 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -990,7 +990,7 @@ public void InvalidToolsVersionErrors()
                 string filename = null;
                 try
                 {
-                    filename = FileUtilities.GetTemporaryFile();
+                    filename = FileUtilities.GetTemporaryFileName();
                     ProjectRootElement project = ProjectRootElement.Create();
                     project.Save(filename);
                     MSBuildApp.BuildProject(
diff --git a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
index 31985adeda6..91839f18a69 100644
--- a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
+++ b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
@@ -80,7 +80,7 @@ public void VerifyInvalidSchemaItself1()
                 Environment.SetEnvironmentVariable("MSBuildOldOM", "");
 
                 // Create schema files in the temp folder
-                invalidSchemaFile = FileUtilities.GetTemporaryFile();
+                invalidSchemaFile = FileUtilities.GetTemporaryFileName();
 
                 File.WriteAllText(invalidSchemaFile, "<this_is_invalid_schema_content/>");
 
@@ -120,7 +120,7 @@ public void VerifyInvalidSchemaItself2()
                 Environment.SetEnvironmentVariable("MSBuildOldOM", "");
 
                 // Create schema files in the temp folder
-                invalidSchemaFile = FileUtilities.GetTemporaryFile();
+                invalidSchemaFile = FileUtilities.GetTemporaryFileName();
 
                 File.WriteAllText(invalidSchemaFile, @"<?xml version=""1.0"" encoding=""UTF-8""?>
 <xs:schema targetNamespace=""http://schemas.microsoft.com/developer/msbuild/2003"" xmlns:msb=""http://schemas.microsoft.com/developer/msbuild/2003"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" elementFormDefault=""qualified"">
@@ -342,7 +342,7 @@ static internal string CreateTempFileOnDisk(string fileContents, params object[]
         /// this project everything that ObjectModelHelpers depends on</remarks>
         static internal string CreateTempFileOnDiskNoFormat(string fileContents)
         {
-            string projectFilePath = FileUtilities.GetTemporaryFile();
+            string projectFilePath = FileUtilities.GetTemporaryFileName();
 
             File.WriteAllText(projectFilePath, CleanupFileContents(fileContents));
 
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 90d1c081d5c..a2a6120ec55 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -10,10 +10,6 @@
 using System.Runtime.Serialization;
 using System.IO;
 using Microsoft.Build.BackEnd;
-#if FEATURE_ASSEMBLYLOADCONTEXT
-using System.Reflection.PortableExecutable;
-using System.Reflection.Metadata;
-#endif
 
 #nullable disable
 
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 86438f1da31..05abbdbab95 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Globalization;
-using System.Reflection;
 
 #nullable disable
 
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 6d5d9ebfd74..e67cbcbd153 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -10,7 +10,6 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
-using System.Reflection;
 
 #nullable disable
 
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 9251c6a3bcf..e21e214cb78 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -8,7 +8,9 @@
 using System.IO;
 using System.IO.Pipes;
 using System.Runtime.InteropServices;
+#if FEATURE_SECURITY_PRINCIPAL_WINDOWS
 using System.Security.Principal;
+#endif
 using System.Threading;
 
 using Microsoft.Build.Framework;
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 71af8039f57..74afacbce8a 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -2,7 +2,6 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
diff --git a/src/Shared/Debugging/DebugUtils.cs b/src/Shared/Debugging/DebugUtils.cs
index 3ae6cf16891..3ebdad82043 100644
--- a/src/Shared/Debugging/DebugUtils.cs
+++ b/src/Shared/Debugging/DebugUtils.cs
@@ -5,7 +5,6 @@
 using System;
 using System.Diagnostics;
 using System.IO;
-using System.Security;
 using System.Text.RegularExpressions;
 
 #nullable disable
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index 7584322ff2b..62110039952 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -3,11 +3,9 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Reflection;
 using System.Runtime.CompilerServices;
-using System.Text.RegularExpressions;
 using Microsoft.Build.Framework;
 using CommonWriterType = System.Action<string, string, System.Collections.Generic.IEnumerable<string>>;
 
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index 51a9e9465d2..905e705fcf9 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
 using System.Text;
 
 using Microsoft.Build.Framework;
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index 7c0db803f70..ace6e1e8159 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Globalization;
-using System.Text;
 
 using Microsoft.Build.Framework;
 
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index 6edc65786a8..c36cc5dee1b 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -1,7 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
 using System;
 using System.Collections.Generic;
 using System.IO;
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 2105da9a21a..28f8a292848 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -7,7 +7,9 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.Versioning;
+#if FEATURE_WIN32_REGISTRY
 using Microsoft.Win32;
+#endif
 
 using Microsoft.Build.Shared.FileSystem;
 
diff --git a/src/Shared/InprocTrackingNativeMethods.cs b/src/Shared/InprocTrackingNativeMethods.cs
index cbdd7b59d96..bd0bae9633a 100644
--- a/src/Shared/InprocTrackingNativeMethods.cs
+++ b/src/Shared/InprocTrackingNativeMethods.cs
@@ -11,9 +11,6 @@
 #endif
 using System.Security;
 using Microsoft.Build.Shared.FileSystem;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 #if FEATURE_RESOURCE_EXPOSURE
 using System.Runtime.Versioning;
 #endif
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index c7181787b69..0b2500390a3 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -2,10 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index 0e0e2913faf..d3ff339ced3 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -1,9 +1,11 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
+#if BUILD_ENGINE
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Evaluation;
+#else
+using Microsoft.Build.Utilities;
+#endif
 
 namespace Microsoft.Build.Shared
 {
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index 1146f026158..bf7fe3035c8 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -2,8 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+#if !BUILDINGAPPXTASKS && DEBUG
 using System.Resources;
 using System.Diagnostics;
+#endif
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.ComponentModel;
diff --git a/src/Shared/StrongNameHelpers.cs b/src/Shared/StrongNameHelpers.cs
index d0187a100da..d176b2c40a8 100644
--- a/src/Shared/StrongNameHelpers.cs
+++ b/src/Shared/StrongNameHelpers.cs
@@ -1,14 +1,14 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_STRONG_NAMES
+
 using System;
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 using System.Diagnostics.CodeAnalysis;
 using System.Reflection;
 
-#if FEATURE_STRONG_NAMES
-
 #nullable disable
 
 namespace Microsoft.Runtime.Hosting
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index c7e900625b8..c9dd8991a6a 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -8,7 +8,9 @@
 using System.Globalization;
 using System.Linq;
 using System.Reflection;
+#if FEATURE_APPDOMAIN
 using System.Security;
+#endif
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Shared/TaskParameterTypeVerifier.cs b/src/Shared/TaskParameterTypeVerifier.cs
index 4048d4f736d..7ac8fa58f67 100644
--- a/src/Shared/TaskParameterTypeVerifier.cs
+++ b/src/Shared/TaskParameterTypeVerifier.cs
@@ -2,9 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Reflection;
 using Microsoft.Build.Framework;
+#if NET35
 using Microsoft.Build.Shared;
-using System.Reflection;
+#endif
 
 #nullable disable
 
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index c0583acb483..50c2e6628be 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -85,6 +85,18 @@ internal static string GetTemporaryDirectory(bool createDirectory = true, string
             return temporaryDirectory;
         }
 
+        /// <summary>
+        /// Generates a unique temporary file name with a given extension in the temporary folder.
+        /// File is guaranteed to be unique.
+        /// Extension may have an initial period.
+        /// File will NOT be created.
+        /// May throw IOException.
+        /// </summary>
+        internal static string GetTemporaryFileName()
+        {
+            return GetTemporaryFileName(".tmp");
+        }
+
         /// <summary>
         /// Generates a unique temporary file name with a given extension in the temporary folder.
         /// File is guaranteed to be unique.
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 1111b257726..21c374dea84 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -6,7 +6,6 @@
 using System.Configuration;
 using System.IO;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index 09184fe4666..625006b9718 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -5,7 +5,9 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
+#if DEBUG
 using System.Reflection;
+#endif
 
 #nullable disable
 
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 825bc0a41d3..40d28f23b29 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -8,9 +8,6 @@
 using System.IO;
 using System.Reflection;
 using System.Runtime.InteropServices;
-#if !NETFRAMEWORK
-using System.Runtime.Loader;
-#endif
 using System.Threading;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
diff --git a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
index 825ccaeb1d4..a5652d24cf0 100644
--- a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
+++ b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
@@ -77,9 +77,7 @@ public void TestGetProcAddress()
         [Fact]
         public void GetLastWriteFileUtcTimeReturnsMinValueForMissingFile()
         {
-            string nonexistentFile = FileUtilities.GetTemporaryFile();
-            // Make sure that the file does not, in fact, exist.
-            File.Delete(nonexistentFile);
+            string nonexistentFile = FileUtilities.GetTemporaryFileName();
 
             DateTime nonexistentFileTime = NativeMethodsShared.GetLastWriteFileUtcTime(nonexistentFile);
             Assert.Equal(DateTime.MinValue, nonexistentFileTime);
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index 1018c4b79aa..94cd21f7169 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -6,7 +6,6 @@
 #if !CLR2COMPATIBILITY
 using System.Runtime.InteropServices;
 #endif
-using System.Runtime.CompilerServices;
 
 #nullable disable
 
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
index 59da6520dcb..7dd2b72b9ac 100644
--- a/src/StringTools/InternableString.Simple.cs
+++ b/src/StringTools/InternableString.Simple.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Linq.Expressions;
 using System.Text;
 
 namespace System
diff --git a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
index e7f155ac3b0..2f60c7dcd48 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
@@ -210,8 +210,8 @@ public void ExistsPromotedDependencyInTheBlackList()
                 "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             string appConfigFile = null;
             try
             {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 4e9c4f61589..01d46289a95 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -2538,7 +2538,7 @@ public void TestDuplicateHandlingForRedistLists()
                   "<File AssemblyName='Microsoft.BuildEngine' Version='3.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='false' />" +
               "</FileList >";
 
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(redistFile, fullRedistListContentsDuplicates);
@@ -2691,7 +2691,7 @@ public void TestDuplicateHandlingDifferentVersion()
         /// </summary>
         private static List<AssemblyEntry> ExpectRedistEntries(string fullRedistListContentsDuplicates, int numberOfExpectedEntries, int numberofExpectedRemapEntries)
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             List<AssemblyEntry> assembliesReadIn = new List<AssemblyEntry>();
             List<AssemblyRemapping> remapEntries = new List<AssemblyRemapping>();
             try
@@ -5303,10 +5303,9 @@ public void Regress407623_RedistListDoesNotImplyPresenceInFrameworks()
                 @"c:\Regress407623"                    // Assembly is here.
             };
 
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -5389,12 +5388,10 @@ public void Regress435487_FxFileResolvedByHintPathShouldByCopyLocal()
             };
             t.TargetFrameworkDirectories = new string[] { @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx" };
 
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
 
             try
             {
-                File.Delete(redistFile);
-
                 File.WriteAllText
                 (
                     redistFile,
@@ -5422,12 +5419,10 @@ public void Regress435487_FxFileResolvedByHintPathShouldByCopyLocal()
         [Fact]
         public void PartialNameMatchingFromRedist()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
 
             try
             {
-                File.Delete(redistFile);
-
                 File.WriteAllText
                 (
                     redistFile,
@@ -5570,7 +5565,7 @@ public void VerifyFrameworkFileMetadataFiles()
                          "<File AssemblyName='C' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                     "</FileList >";
 
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(redistFile, redistListContents);
 
             bool success = false;
@@ -5637,7 +5632,7 @@ private static string CreateGenericRedistList()
                         "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                     "</FileList >";
 
-            string tempFile = FileUtilities.GetTemporaryFile();
+            string tempFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(tempFile, redistListContents);
             return tempFile;
         }
@@ -5743,7 +5738,7 @@ public void RedistListGenerateBlackListNotFoundSubsetFiles()
         public void RedistListGenerateBlackListGarbageSubsetListFiles()
         {
             string redistFile = CreateGenericRedistList();
-            string garbageSubsetFile = FileUtilities.GetTemporaryFile();
+            string garbageSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText
@@ -5787,7 +5782,7 @@ public void RedistListGenerateBlackListGarbageSubsetListFiles()
         public void RedistListNoSubsetListName()
         {
             string redistFile = CreateGenericRedistList();
-            string subsetFile = FileUtilities.GetTemporaryFile();
+            string subsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 string subsetListContents =
@@ -5832,8 +5827,8 @@ public void RedistListNoSubsetListName()
         [Fact]
         public void RedistListNullkRedistListName()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
-            string subsetFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
+            string subsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 string subsetListContents =
@@ -5885,7 +5880,7 @@ public void RedistListNullkRedistListName()
         public void RedistListDifferentNameToSubSet()
         {
             string redistFile = CreateGenericRedistList();
-            string subsetFile = FileUtilities.GetTemporaryFile();
+            string subsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 string subsetListContents =
@@ -5922,7 +5917,7 @@ public void RedistListDifferentNameToSubSet()
         public void RedistListEmptySubsetMatchingName()
         {
             string redistFile = CreateGenericRedistList();
-            string subsetFile = FileUtilities.GetTemporaryFile();
+            string subsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 string subsetListContents =
@@ -5979,8 +5974,8 @@ public void RedistListNoAssembliesinRedistList()
                 @"{TargetFrameworkDirectory}"
             };
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(subsetListPath, _xmlOnlySubset);
             try
             {
@@ -6013,7 +6008,7 @@ public void RedistListNoAssembliesinRedistList()
         public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
         {
             string redistFile = CreateGenericRedistList();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(goodSubsetFile, _engineOnlySubset);
@@ -6046,7 +6041,7 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
         public void RedistListGenerateBlackListVerifyBlackListCache()
         {
             string redistFile = CreateGenericRedistList();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(goodSubsetFile, _engineOnlySubset);
@@ -6087,8 +6082,8 @@ public void RedistListGenerateBlackListVerifyBlackListCache()
         public void RedistListGenerateBlackListGoodListsSubsetIsSameAsRedistList()
         {
             string redistFile = CreateGenericRedistList();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
-            string goodSubsetFile2 = FileUtilities.GetTemporaryFile();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
+            string goodSubsetFile2 = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(goodSubsetFile, _engineOnlySubset);
@@ -6124,7 +6119,7 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSameAsRedistList()
         public void RedistListGenerateBlackListGoodListsSubsetIsSuperSet()
         {
             string redistFile = CreateGenericRedistList();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText
@@ -6164,7 +6159,7 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSuperSet()
         public void RedistListGenerateBlackListGoodListsCheckCaseInsensitive()
         {
             string redistFile = CreateGenericRedistList();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(goodSubsetFile, _engineAndXmlSubset.ToUpperInvariant());
@@ -6195,8 +6190,8 @@ public void RedistListGenerateBlackListGoodListsCheckCaseInsensitive()
         [Fact]
         public void RedistListGenerateBlackListGoodListsMultipleIdenticalAssembliesInRedistList()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 // Create a redist list which will contains both of the assemblies to search for
@@ -7982,13 +7977,12 @@ public void ForwardRedistRoot()
                 @"c:\MyRedist"
             };
 
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
 
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
-(
+                (
                     redistFile,
                     "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
                         "<File IsRedistRoot='true' AssemblyName='MyRedistRootAssembly' Version='0.0.0.0' PublicKeyToken='null' Culture='Neutral' FileVersion='2.0.40824.0' InGAC='true'/>" +
@@ -8114,10 +8108,9 @@ public void TargetFrameworkFiltering()
         [Fact]
         public void VerifyGetSimpleNamesIsSorted()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8162,10 +8155,9 @@ public void VerifyGetSimpleNamesIsSorted()
         [Fact]
         public void VerifyAssemblyInRedistListNonWindowsRedistName()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8193,10 +8185,9 @@ public void VerifyAssemblyInRedistListNonWindowsRedistName()
         [Fact]
         public void VerifyAssemblyInRedistListWindowsRedistName()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8224,10 +8215,9 @@ public void VerifyAssemblyInRedistListWindowsRedistName()
         [Fact]
         public void VerifyAssemblyInRedistListPartialMatches()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8267,10 +8257,9 @@ public void VerifyAssemblyInRedistListPartialMatches()
         [Fact]
         public void VerifyAssemblyInRedistListDiffVersion()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8299,10 +8288,9 @@ public void VerifyAssemblyInRedistListDiffVersion()
         [Fact]
         public void VerifyAssemblyInRedistListDiffPublicKey()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8331,10 +8319,9 @@ public void VerifyAssemblyInRedistListDiffPublicKey()
         [Fact]
         public void VerifyAssemblyInRedistListDiffCulture()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8363,10 +8350,9 @@ public void VerifyAssemblyInRedistListDiffCulture()
         [Fact]
         public void VerifyAssemblyInRedistListDiffSimpleName()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 7ca93cd930e..0ac1240605f 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -2936,7 +2936,7 @@ protected static string WriteAppConfig(string redirects)
             "    </runtime>\n" +
             "</configuration>";
 
-            string appConfigFile = FileUtilities.GetTemporaryFile();
+            string appConfigFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(appConfigFile, appConfigContents);
             return appConfigFile;
         }
@@ -3150,10 +3150,9 @@ internal void ExecuteRAROnItemsAndRedist(ResolveAssemblyReference t, MockEngine
 
             t.Assemblies = items;
             t.SearchPaths = searchPaths.ToArray();
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
index c4f78439042..3bb0ff19545 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
@@ -109,8 +109,8 @@ public void ExistsPromotedDependencyInTheBlackList()
                 "<File AssemblyName='UniFYme' Version='2.0.0.0' Culture='neutral' PublicKeyToken='b77a5c561934e089' InGAC='false' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             string appConfigFile = null;
             try
             {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
index 10694971b29..dc4c11e5ef6 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
@@ -121,8 +121,8 @@ public void ExistsWithPrimaryReferenceOnBlackList()
                 "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(redistListPath, implicitRedistListContents);
@@ -204,8 +204,8 @@ public void ExistsPromotedDependencyInTheBlackList()
                 "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             string appConfigFile = null;
             try
             {
@@ -286,8 +286,8 @@ public void ExistsWithBothDependentReferenceOnBlackList()
                 "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(redistListPath, implicitRedistListContents);
@@ -362,8 +362,8 @@ public void MultipleUnifiedFromNamesMiddlePrimaryOnBlackList()
                 "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(redistListPath, implicitRedistListContents);
             File.WriteAllText(subsetListPath, engineOnlySubset);
 
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index 2ac0ecd66f6..adf456748bc 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -467,7 +467,7 @@ public void MoveLockedFile()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 bool result;
                 Move move = null;
 
diff --git a/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs b/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
index e7ba35224bf..29999daefa9 100644
--- a/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
+++ b/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
@@ -24,12 +24,10 @@ public sealed class ReadLinesFromFile_Tests
         [Fact]
         public void Basic()
         {
-            var file = FileUtilities.GetTemporaryFile();
+            // Start with a missing file.
+            var file = FileUtilities.GetTemporaryFileName();
             try
             {
-                // Start with a missing file.
-                File.Delete(file);
-
                 // Append one line to the file.
                 var a = new WriteLinesToFile
                 {
@@ -73,12 +71,10 @@ public void Basic()
         [Fact]
         public void Escaping()
         {
-            var file = FileUtilities.GetTemporaryFile();
+            // Start with a missing file.
+            var file = FileUtilities.GetTemporaryFileName();
             try
             {
-                // Start with a missing file.
-                File.Delete(file);
-
                 // Append one line to the file.
                 var a = new WriteLinesToFile
                 {
@@ -120,12 +116,10 @@ public void Escaping()
         [Fact]
         public void ANSINonASCII()
         {
-            var file = FileUtilities.GetTemporaryFile();
+            // Start with a missing file.
+            var file = FileUtilities.GetTemporaryFileName();
             try
             {
-                // Start with a missing file.
-                File.Delete(file);
-
                 // Append one line to the file.
                 var a = new WriteLinesToFile
                 {
@@ -156,8 +150,7 @@ public void ANSINonASCII()
         [Fact]
         public void ReadMissing()
         {
-            var file = FileUtilities.GetTemporaryFile();
-            File.Delete(file);
+            var file = FileUtilities.GetTemporaryFileName();
 
             // Read the line from the file.
             var r = new ReadLinesFromFile
@@ -175,12 +168,10 @@ public void ReadMissing()
         [Fact]
         public void IgnoreBlankLines()
         {
-            var file = FileUtilities.GetTemporaryFile();
+            // Start with a missing file.
+            var file = FileUtilities.GetTemporaryFileName();
             try
             {
-                // Start with a missing file.
-                File.Delete(file);
-
                 // Append one line to the file.
                 var a = new WriteLinesToFile
                 {
@@ -227,12 +218,10 @@ public void ReadNoAccess()
                 return; // "The security API is not the same under Unix"
             }
 
-            var file = FileUtilities.GetTemporaryFile();
+            // Start with a missing file.
+            var file = FileUtilities.GetTemporaryFileName();
             try
             {
-                // Start with a missing file.
-                File.Delete(file);
-
                 // Append one line to the file.
                 var a = new WriteLinesToFile
                 {
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 64383a4c4b7..aea579d8787 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -3826,9 +3826,8 @@ public static MethodInfo GetPrivateMethod(object o, string methodName)
         /// </summary>
         public static string GetTempFileName(string extension)
         {
-            string f = FileUtilities.GetTemporaryFile();
+            string f = FileUtilities.GetTemporaryFileName();
             string filename = Path.ChangeExtension(f, extension);
-            File.Delete(f);
             // Make sure that the new file doesn't already exist, since the test is probably
             // expecting it not to
             File.Delete(filename);
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
index b4eed6f9a10..1cd7d218fa3 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
@@ -92,8 +92,7 @@ public void DirtyCleanScenario(bool useMSBuildResXReader)
         /// <returns></returns>
         private string CreateSampleResx()
         {
-            string resx = FileUtilities.GetTemporaryFile();
-            File.Delete(resx);
+            string resx = FileUtilities.GetTemporaryFileName();
             Stream fileToSend = Assembly.GetExecutingAssembly().GetManifestResourceStream("Microsoft.Build.Tasks.UnitTests.SampleResx");
             using (FileStream f = new FileStream(resx, FileMode.CreateNew))
             {
diff --git a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
index 17d45366bca..050975f0c98 100644
--- a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
@@ -338,7 +338,7 @@ public void TestLoadAndParseFromAbsoluteFilePath()
                                        <StringProperty Name=`TargetAssembly` Switch=`/target:&quot;[value]&quot;` />
                                      </Rule>
                                    </ProjectSchemaDefinitions>";
-            string tmpXamlFile = FileUtilities.GetTemporaryFile();
+            string tmpXamlFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(tmpXamlFile, xmlContents.Replace("`", "\""));
diff --git a/src/Tasks.UnitTests/XmlPoke_Tests.cs b/src/Tasks.UnitTests/XmlPoke_Tests.cs
index 05e3f05860c..88caa456fad 100644
--- a/src/Tasks.UnitTests/XmlPoke_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPoke_Tests.cs
@@ -142,7 +142,7 @@ public void PokeMissingParams()
             string xmlInputPath;
             Prepare(_xmlFileNoNs, out xmlInputPath);
 
-            for (int i = 0; i < 8; i++)
+            for (int i = 0; i < 4; i++)
             {
                 XmlPoke p = new XmlPoke();
                 p.BuildEngine = engine;
@@ -157,13 +157,8 @@ public void PokeMissingParams()
                     p.Query = "//variable/@Name";
                 }
 
-                if ((i & 4) == 4)
-                {
-                    p.Value = new TaskItem("Mert");
-                }
-
-                // "Expecting argumentnullexception for the first 7 tests"
-                if (i < 7)
+                // "Expecting argumentnullexception for the first 3 tests"
+                if (i < 3)
                 {
                     Should.Throw<ArgumentNullException>(() => p.Execute());
                 }
@@ -174,6 +169,33 @@ public void PokeMissingParams()
             }
         }
 
+        [Fact]
+        // https://github.com/dotnet/msbuild/issues/5814
+        public void XmlPokeWithEmptyValue()
+        {
+            string xmlInputPath;
+            string query = "//class/variable/@Name";
+            Prepare(_xmlFileNoNs, out xmlInputPath);
+            string projectContents = $"""
+                <Project ToolsVersion='msbuilddefaulttoolsversion'>
+                <Target Name='Poke'>
+                    <XmlPoke Value='' Query='{query}' XmlInputPath='{xmlInputPath}'/>
+                </Target>
+                </Project>
+                """;
+
+            ObjectModelHelpers.BuildProjectExpectSuccess(projectContents);
+
+            string result = File.ReadAllText(xmlInputPath);
+            XmlDocument xmlDocument = new XmlDocument();
+            xmlDocument.LoadXml(result);
+            List<XmlAttribute> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlAttribute>().ToList();
+            foreach (var node in nodes)
+            {
+                node.Value.ShouldBe(string.Empty);
+            }
+        }
+
         [Fact]
         public void ErrorInNamespaceDecl()
         {
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index 97d6ab34104..e1768f2bd0d 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 
 #nullable disable
 
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index e1edb44349c..b1c843ffdd7 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -3001,23 +3001,16 @@ private AssemblyTableInfo[] GetInstalledAssemblyTableInfo(bool ignoreInstalledAs
                 // Whidbey behavior was to accept a single TargetFrameworkDirectory, and multiple
                 // InstalledAssemblyTables, under the assumption that all of the InstalledAssemblyTables
                 // were related to the single TargetFrameworkDirectory.  If inputs look like the Whidbey
-                // case, let's make sure we behave the same way.
-
+                // case, let's make sure we behave the same way. Otherwise, use non-empty metadata.
                 if (String.IsNullOrEmpty(frameworkDirectory))
                 {
                     if (TargetFrameworkDirectories?.Length == 1)
                     {
                         // Exactly one TargetFrameworkDirectory, so assume it's related to this
                         // InstalledAssemblyTable.
-
                         frameworkDirectory = TargetFrameworkDirectories[0];
                     }
                 }
-                else
-                {
-                    // The metadata on the item was non-empty, so use it.
-                    frameworkDirectory = FileUtilities.EnsureTrailingSlash(frameworkDirectory);
-                }
 
                 tableMap[installedAssemblyTable.ItemSpec] = new AssemblyTableInfo(installedAssemblyTable.ItemSpec, frameworkDirectory);
             }
diff --git a/src/Tasks/AssemblyFolder.cs b/src/Tasks/AssemblyFolder.cs
index 6f5da7d008f..d8cafc0a6d6 100644
--- a/src/Tasks/AssemblyFolder.cs
+++ b/src/Tasks/AssemblyFolder.cs
@@ -3,7 +3,6 @@
 #if FEATURE_WIN32_REGISTRY
 
 using System;
-using System.IO;
 using System.Collections.Generic;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index bf29ead3d01..f7c09a4c3d4 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -3,7 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index e3fd34e9fc6..c47cd7f6f9a 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 #nullable disable
@@ -23,6 +22,7 @@ namespace Microsoft.Build.Tasks
     using System.Reflection;
     using System.Text;
     using System.Xml;
+    using Microsoft.Build.Shared.FileSystem;
 
     /// <summary>
     /// A task factory which can take code dom supported languages and create a task out of it
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index eaf732c4ec4..f1aa4c82c3f 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Runtime.InteropServices.ComTypes;
-using System.Text;
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 6b0a1f18a25..27c60d89d2a 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -4,7 +4,6 @@
 using System;
 using System.IO;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 #nullable disable
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index 1a4786a6477..0c2a3672ad0 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -4,8 +4,10 @@
 using System;
 using System.Collections.Generic;
 using System.Globalization;
+#if NET5_0_OR_GREATER
 using System.Linq;
 using Microsoft.Build.Framework;
+#endif
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index c05a3afb682..9e6eca86c59 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -196,7 +196,7 @@ private void CreateTemporaryBatchFile()
             var encoding = EncodingUtilities.BatchFileEncoding(Command + WorkingDirectory, UseUtf8Encoding);
 
             // Temporary file with the extension .Exec.bat
-            _batchFile = FileUtilities.GetTemporaryFile(".exec.cmd");
+            _batchFile = FileUtilities.GetTemporaryFileName(".exec.cmd");
 
             // UNICODE Batch files are not allowed as of WinXP. We can't use normal ANSI code pages either,
             // since console-related apps use OEM code pages "for historical reasons". Sigh.
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index a9e46233824..5d7ef6a9107 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -23,9 +23,9 @@
 using System.Runtime.InteropServices;
 #if FEATURE_APPDOMAIN
 using System.Runtime.Remoting;
+using System.Runtime.Serialization.Formatters.Binary;
 #endif
 using System.Runtime.Serialization;
-using System.Runtime.Serialization.Formatters.Binary;
 #if !FEATURE_ASSEMBLYLOADCONTEXT
 using System.Runtime.Versioning;
 using System.Security;
@@ -40,7 +40,9 @@
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.ResourceHandling;
 using Microsoft.Build.Utilities;
+#if FEATURE_RESXREADER_LIVEDESERIALIZATION
 using Microsoft.Win32;
+#endif
 
 #nullable disable
 
@@ -905,24 +907,29 @@ public override bool Execute()
             return !Log.HasLoggedErrors && outOfProcExecutionSucceeded;
         }
 
+#if FEATURE_RESXREADER_LIVEDESERIALIZATION
         private static readonly bool AllowMOTW = !NativeMethodsShared.IsWindows || (Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\SDK", "AllowProcessOfUntrustedResourceFiles", null) is string allowUntrustedFiles && allowUntrustedFiles.Equals("true", StringComparison.OrdinalIgnoreCase));
 
         private const string CLSID_InternetSecurityManager = "7b8a2d94-0ac9-11d1-896c-00c04fb6bfc4";
         private const uint ZoneInternet = 3;
         private static IInternetSecurityManager internetSecurityManager = null;
+#endif
 
         // Resources can have arbitrarily serialized objects in them which can execute arbitrary code
         // so check to see if we should trust them before analyzing them
         private bool IsDangerous(String filename)
         {
+#if !FEATURE_RESXREADER_LIVEDESERIALIZATION
+            return false;
+        }
+#else
             // If they are opted out, there's no work to do
-            if (AllowMOTW || !NativeMethodsShared.IsWindows)
+            if (AllowMOTW)
             {
                 return false;
             }
 
             // First check the zone, if they are not an untrusted zone, they aren't dangerous
-
             if (internetSecurityManager == null)
             {
                 Type iismType = Type.GetTypeFromCLSID(new Guid(CLSID_InternetSecurityManager));
@@ -989,7 +996,6 @@ private bool IsDangerous(String filename)
             return dangerous;
         }
 
-#if FEATURE_APPDOMAIN
         /// <summary>
         /// For setting OutputResources and ensuring it can be read after the second AppDomain has been unloaded.
         /// </summary>
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
index 9787b51e366..c68f60f13f9 100644
--- a/src/Tasks/GetCompatiblePlatform.cs
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -5,7 +5,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using System;
-using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks
 {
diff --git a/src/Tasks/LockCheck.cs b/src/Tasks/LockCheck.cs
index fd499d4bc93..237a138dd64 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Tasks/LockCheck.cs
@@ -7,7 +7,6 @@
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-using System.Text;
 
 #nullable disable
 
diff --git a/src/Tasks/ManifestUtil/ManifestWriter.cs b/src/Tasks/ManifestUtil/ManifestWriter.cs
index 1c85fae10f0..cc076b2a08a 100644
--- a/src/Tasks/ManifestUtil/ManifestWriter.cs
+++ b/src/Tasks/ManifestUtil/ManifestWriter.cs
@@ -123,7 +123,7 @@ private static void WriteManifest(Manifest manifest, Stream output, string targe
                 else
                 {
                     // May throw IO-related exceptions
-                    string temp = FileUtilities.GetTemporaryFile();
+                    string temp = FileUtilities.GetTemporaryFileName();
 
                     am.TrustInfo.Write(temp);
                     if (Util.logging)
diff --git a/src/Tasks/ManifestUtil/MetadataReader.cs b/src/Tasks/ManifestUtil/MetadataReader.cs
index dc7fc6529d4..1b2dbef040f 100644
--- a/src/Tasks/ManifestUtil/MetadataReader.cs
+++ b/src/Tasks/ManifestUtil/MetadataReader.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Diagnostics.CodeAnalysis;
-using System.Runtime.InteropServices;
 using System.Collections.Specialized;
 #if RUNTIME_TYPE_NETCORE
 using System.Collections.Generic;
@@ -11,6 +9,9 @@
 using System.Reflection;
 using System.Reflection.Metadata;
 using System.Reflection.PortableExecutable;
+#else
+using System.Diagnostics.CodeAnalysis;
+using System.Runtime.InteropServices;
 #endif
 
 #nullable disable
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 986370caf84..8e16ee1a599 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -1,11 +1,11 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Win32;
 using System;
 #if !RUNTIME_TYPE_NETCORE
+using Microsoft.Build.Framework;
 using System.Collections.Generic;
 #endif
 using System.ComponentModel;
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index ce5a2b4843e..dc7880cd52a 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -8,8 +8,10 @@
 using System.Globalization;
 using System.IO;
 using System.Runtime.InteropServices;
+#if !RUNTIME_TYPE_NETCORE
 using System.Security;
 using System.Security.Permissions;
+#endif
 using System.Xml;
 using Microsoft.Build.Shared.FileSystem;
 
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index 85434a45d44..fd197c183f5 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -510,7 +510,7 @@ public static void WriteLogFile(string filename, System.Xml.XmlElement element)
         public static string WriteTempFile(Stream s)
         {
             // May throw IO-related exceptions
-            string path = FileUtilities.GetTemporaryFile();
+            string path = FileUtilities.GetTemporaryFileName();
 
             WriteFile(path, s);
             return path;
@@ -519,7 +519,7 @@ public static string WriteTempFile(Stream s)
         public static string WriteTempFile(string s)
         {
             // May throw IO-related exceptions
-            string path = FileUtilities.GetTemporaryFile();
+            string path = FileUtilities.GetTemporaryFileName();
 
             WriteFile(path, s);
             return path;
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 0ff4125961f..b7f212ebe43 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -13,7 +13,9 @@
 using System.Collections;
 using System.Globalization;
 using System.Linq;
+#if FEATURE_HANDLEPROCESSCORRUPTEDSTATEEXCEPTIONS
 using System.Runtime.ExceptionServices;
+#endif
 using System.Text.RegularExpressions;
 using System.Runtime.Versioning;
 
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 6d2862fac49..2fdd200203a 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -918,8 +918,8 @@ internal class AssemblyTableInfo : IComparable
 
         internal AssemblyTableInfo(string path, string frameworkDirectory)
         {
-            Path = path;
-            FrameworkDirectory = frameworkDirectory;
+            Path = FileUtilities.NormalizeForPathComparison(path);
+            FrameworkDirectory = FileUtilities.NormalizeForPathComparison(frameworkDirectory);
         }
 
         internal string Path { get; }
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 143d69af4c5..530982c0f32 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -2,11 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
+#if FEATURE_RESXREADER_LIVEDESERIALIZATION
+using System.Collections;
 using System.Resources;
+#endif
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index c39a2eb609b..bdca81a2457 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -2,21 +2,25 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+#if !RUNTIME_TYPE_NETCORE
 using System.Collections.Generic;
+#endif
+#if !NET7_0_OR_GREATER
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Reflection;
 using System.Runtime.InteropServices;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 // TYPELIBATTR clashes with the one in InteropServices.
 using TYPELIBATTR = System.Runtime.InteropServices.ComTypes.TYPELIBATTR;
 using UtilitiesProcessorArchitecture = Microsoft.Build.Utilities.ProcessorArchitecture;
+#endif
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index 95e3a2ecf68..9960105ee1d 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -2,16 +2,16 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using System.IO;
-using System.Security.Cryptography;
 using System.Security.Cryptography.X509Certificates;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 #if FEATURE_PFX_SIGNING
+using System.Globalization;
+using System.Security.Cryptography;
 using Microsoft.Runtime.Hosting;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 #endif
 
 #nullable disable
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 0f2b3752dbe..a765f4a4d7a 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -5,7 +5,9 @@
 using System.IO;
 using System.Collections;
 using System.Collections.Generic;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/SetRidAgnosticValueForProjects.cs b/src/Tasks/SetRidAgnosticValueForProjects.cs
index 7e45e76f163..689a4eb9711 100644
--- a/src/Tasks/SetRidAgnosticValueForProjects.cs
+++ b/src/Tasks/SetRidAgnosticValueForProjects.cs
@@ -3,10 +3,7 @@
 //
 
 using System;
-using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 2ee63116123..88e0ed11611 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -4,7 +4,9 @@
 #if FEATURE_APPDOMAIN
 
 using System;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using System.IO;
 using System.Reflection;
 using System.Runtime.InteropServices;
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 5088a0ff87e..a781f20b2c3 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -6,12 +6,14 @@
 using System.CodeDom.Compiler;
 using System.Collections;
 using System.Collections.Generic;
-using System.Configuration;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
 using System.Linq;
+#if FEATURE_SYSTEM_CONFIGURATION
+using System.Configuration;
 using System.Security;
+#endif
 using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 7378f094c43..eec457b6a96 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -20,7 +20,6 @@ namespace Microsoft.Build.Tasks
     using System.Reflection;
     using System.Text;
     using System.Threading;
-    using System.Xml;
 
     /// <summary>
     /// The task factory provider for XAML tasks.
diff --git a/src/Tasks/XmlPoke.cs b/src/Tasks/XmlPoke.cs
index b64579109fd..78f0fa6c50c 100644
--- a/src/Tasks/XmlPoke.cs
+++ b/src/Tasks/XmlPoke.cs
@@ -8,6 +8,7 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -30,11 +31,6 @@ public class XmlPoke : TaskExtension
         /// </summary>
         private string _query;
 
-        /// <summary>
-        /// The property that this task will set.
-        /// </summary>
-        private ITaskItem _value;
-
         #endregion
 
         #region Properties
@@ -68,18 +64,8 @@ public string Query
 
         /// <summary>
         /// The value to be inserted into the specified location.
-        /// </summary>
-        [Required]
-        public ITaskItem Value
-        {
-            get
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(_value, nameof(Value));
-                return _value;
-            }
-
-            set => _value = value;
-        }
+        /// </summary>        
+        public ITaskItem Value { get; set; }
 
         /// <summary>
         /// The namespaces for XPath query's prefixes.
@@ -95,8 +81,12 @@ public ITaskItem Value
         public override bool Execute()
         {
             ErrorUtilities.VerifyThrowArgumentNull(_query, "Query");
-            ErrorUtilities.VerifyThrowArgumentNull(_value, "Value");
             ErrorUtilities.VerifyThrowArgumentNull(_xmlInputPath, "XmlInputPath");
+            if (Value == null)
+            {
+                // When Value is null, it means Value is not set or empty. Here we treat them all as empty.
+                Value = new TaskItem(String.Empty);
+            }
 
             // Load the XPath Document
             XmlDocument xmlDoc = new XmlDocument();
@@ -164,12 +154,12 @@ public override bool Execute()
                 try
                 {
                     count++;
-                    iter.Current.InnerXml = _value.ItemSpec;
-                    Log.LogMessageFromResources(MessageImportance.Low, "XmlPoke.Replaced", iter.Current.Name, _value.ItemSpec);
+                    iter.Current.InnerXml = Value.ItemSpec;
+                    Log.LogMessageFromResources(MessageImportance.Low, "XmlPoke.Replaced", iter.Current.Name, Value.ItemSpec);
                 }
                 catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
                 {
-                    Log.LogErrorWithCodeFromResources("XmlPoke.PokeError", _value.ItemSpec, e.Message);
+                    Log.LogErrorWithCodeFromResources("XmlPoke.PokeError", Value.ItemSpec, e.Message);
                     return false;
                 }
             }
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index 0facabc1b83..2a0ecc35e16 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -23,7 +23,9 @@
 
 using System;
 using System.IO;
+#if FEATURE_RESXREADER_LIVEDESERIALIZATION
 using System.Collections;
+#endif
 using System.Collections.Generic;
 using System.Resources;
 using System.CodeDom;
diff --git a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
index 36670c64bc3..b37dbed11db 100644
--- a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
+++ b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
@@ -171,7 +171,7 @@ public void CheckLogMessageFromFile()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
 
                 string contents = @"a message here
                     error abcd12345: hey jude.
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index b5df279597a..d6004dc55d6 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -416,7 +416,7 @@ public void TaskFoundOnPath()
         [Fact]
         public void OverrideStdOutImportanceToLow()
         {
-            string tempFile = FileUtilities.GetTemporaryFile();
+            string tempFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(tempFile, @"hello world");
 
             using (MyTool t = new MyTool())
@@ -444,7 +444,7 @@ public void OverrideStdOutImportanceToLow()
         [Fact]
         public void OverrideStdOutImportanceToHigh()
         {
-            string tempFile = FileUtilities.GetTemporaryFile();
+            string tempFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(tempFile, @"hello world");
 
             using (MyTool t = new MyTool())
@@ -475,7 +475,7 @@ public void OverrideStdOutImportanceToHigh()
         [Fact]
         public void ToolTaskCanChangeCanonicalErrorFormat()
         {
-            string tempFile = FileUtilities.GetTemporaryFile();
+            string tempFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(tempFile, @"
                 Main.cs(17,20): warning CS0168: The variable 'foo' is declared but never used.
                 BADTHINGHAPPENED: This is my custom error format that's not in canonical error format.
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index c5dd50492ca..14cd1e7820f 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -314,7 +314,7 @@ static void Main(string[] args)
 
             try
             {
-                codeFile = FileUtilities.GetTemporaryFile();
+                codeFile = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(codeFile, codeContent);
                 Csc csc = new Csc();
                 csc.BuildEngine = new MockEngine();
@@ -418,7 +418,7 @@ public void FileTrackerFindStrInIncludeDuplicates()
             try
             {
                 string inputPath = Path.GetFullPath("test.in");
-                codeFile = FileUtilities.GetTemporaryFile();
+                codeFile = FileUtilities.GetTemporaryFileName();
                 string codeContent = @"using System.IO; class X { static void Main() { File.ReadAllText(@""" + inputPath + @"""); File.ReadAllText(@""" + inputPath + @"""); }}";
                 File.WriteAllText(codeFile, codeContent);
                 Csc csc = new Csc();
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index 67cb313a50e..dc79f6c8cc1 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -1,6 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#pragma warning disable 0219
+
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.IO;
@@ -12,10 +16,6 @@
 using Microsoft.Build.Utilities;
 using Xunit;
 
-#pragma warning disable 0219
-
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.UnitTests.TrackedDependencies
diff --git a/src/Utilities/ProcessorArchitecture.cs b/src/Utilities/ProcessorArchitecture.cs
index 6c846b7f094..188b0c6b2ef 100644
--- a/src/Utilities/ProcessorArchitecture.cs
+++ b/src/Utilities/ProcessorArchitecture.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Diagnostics.CodeAnalysis;
-using Microsoft.Build.Shared;
 
 #nullable disable
 
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 53f3d588300..edba3b1af42 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -5,9 +5,8 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
-using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
+using System.Security;
 #endif
 
 using Microsoft.Build.Framework;
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index cc316e7ad5e..a275a3be4fa 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -545,7 +545,7 @@ private string GetTemporaryResponseFile(string responseFileCommands, out string
                 // have to worry about how long the command-line is going to be
 
                 // May throw IO-related exceptions
-                responseFile = FileUtilities.GetTemporaryFile(".rsp");
+                responseFile = FileUtilities.GetTemporaryFileName(".rsp");
 
                 // Use the encoding specified by the overridable ResponseFileEncoding property
                 using (StreamWriter responseFileStream = FileUtilities.OpenWrite(responseFile, false, ResponseFileEncoding))
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
index 1d59803aa05..2343b93060f 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
@@ -1,13 +1,13 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 285bf48d056..35ccc199d3e 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -1,6 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.Collections.Concurrent;
@@ -11,8 +13,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 27f29ab1227..055708ea058 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -1,6 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
@@ -9,8 +11,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/DependencyTableCache.cs b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
index ac4d674e0a8..d87e3ea9507 100644
--- a/src/Utilities/TrackedDependencies/DependencyTableCache.cs
+++ b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
@@ -1,6 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -9,8 +11,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index a6fa201acc7..e2812d295ca 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -343,7 +343,7 @@ public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] output
         /// <returns>The response file path.</returns>
         public static string CreateRootingMarkerResponseFile(string rootMarker)
         {
-            string trackerResponseFile = FileUtilities.GetTemporaryFile(".rsp");
+            string trackerResponseFile = FileUtilities.GetTemporaryFileName(".rsp");
             File.WriteAllText(trackerResponseFile, "/r \"" + rootMarker + "\"", Encoding.Unicode);
 
             return trackerResponseFile;
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index 1c6529ac55d..3a3b9d71130 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -1,6 +1,8 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
@@ -12,8 +14,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
