diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 35d8f22a0bd..2d6003a389c 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -909,19 +909,19 @@ public void ForwardCompatibleRead_HandleAppendOnlyChanges()
 
             buildEventArgsWriter.Write(error);
 
-            //Some future data that are not known in current version
+            // Some future data that are not known in current version
             binaryWriter.Write(new byte[] { 1, 2, 3, 4 });
 
 
             int positionAfterFirstEvent = (int)memoryStream.Position;
             memoryStream.Position = 0;
-            //event type
+            // event type
             Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
             int eventSizePos = (int)memoryStream.Position;
             int eventSize = Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
             int positionAfterFirstEventSize = (int)memoryStream.Position;
             memoryStream.Position = eventSizePos;
-            //the extra 4 bytes
+            // the extra 4 bytes
             Microsoft.Build.Shared.BinaryWriterExtensions.Write7BitEncodedInt(binaryWriter, eventSize + 4);
             memoryStream.Position.ShouldBe(positionAfterFirstEventSize, "The event size need to be overwritten in place - without overwriting any bytes after the size info");
             memoryStream.Position = positionAfterFirstEvent;
@@ -975,7 +975,7 @@ public void ForwardCompatibleRead_HandleUnknownEvent()
 
             int positionAfterFirstEvent = (int)memoryStream.Position;
             memoryStream.Position = 0;
-            //event type
+            // event type
             Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
             int eventSizePos = (int)memoryStream.Position;
             memoryStream.Position = 0;
@@ -1001,7 +1001,7 @@ public void ForwardCompatibleRead_HandleUnknownEvent()
             List<(ReaderErrorType errorType, BinaryLogRecordKind recordKind, string error)> readerErrors = new();
             buildEventArgsReader.OnRecoverableReadError += (t, et, e) => readerErrors.Add((t, et, e));
 
-            var deserializedEvent = /*(BuildErrorEventArgs)*/buildEventArgsReader.Read();
+            var deserializedEvent = buildEventArgsReader.Read();
 
             readerErrors.Count.ShouldBe(1);
             readerErrors[0].errorType.ShouldBe(ReaderErrorType.UnkownEventType);
@@ -1016,7 +1016,7 @@ public void ForwardCompatibleRead_HandleUnknownEvent()
         [Fact]
         public void ForwardCompatibleRead_HandleMismatchedFormatOfEvent()
         {
-            //BuildErrorEventArgs error = new("Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "SenderName");
+            // BuildErrorEventArgs error = new("Subcategory", "Code", "File", 1, 2, 3, 4, "Message", "HelpKeyword", "SenderName");
             BuildErrorEventArgs error = new(null, null, null, 1, 2, 3, 4, null, null, null);
             BuildFinishedEventArgs finished = new("Message", "HelpKeyword", true);
 
@@ -1029,10 +1029,10 @@ public void ForwardCompatibleRead_HandleMismatchedFormatOfEvent()
 
             int positionAfterFirstEvent = (int)memoryStream.Position;
             memoryStream.Position = 0;
-            //event type
+            // event type
             Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
             int eventSize = Microsoft.Build.Shared.BinaryReaderExtensions.Read7BitEncodedInt(binaryReader);
-            //overwrite the entire event with garbage
+            // overwrite the entire event with garbage
             binaryWriter.Write(Enumerable.Repeat(byte.MaxValue, eventSize).ToArray());
 
             memoryStream.Position.ShouldBe(positionAfterFirstEvent, "The event need to be overwritten in place - without overwriting any bytes after the size info");
@@ -1052,7 +1052,7 @@ public void ForwardCompatibleRead_HandleMismatchedFormatOfEvent()
             List<(ReaderErrorType errorType, BinaryLogRecordKind recordKind, string error)> readerErrors = new();
             buildEventArgsReader.OnRecoverableReadError += (t, et, e) => readerErrors.Add((t, et, e));
 
-            var deserializedEvent = /*(BuildErrorEventArgs)*/buildEventArgsReader.Read();
+            var deserializedEvent = buildEventArgsReader.Read();
 
             readerErrors.Count.ShouldBe(1);
             readerErrors[0].errorType.ShouldBe(ReaderErrorType.UnknownFormatOfEventData);
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
index bc8744e36fb..034c019d466 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogReplayEventSource.cs
@@ -217,7 +217,7 @@ public void Replay(BuildEventArgsReader reader, CancellationToken cancellationTo
                         ResourceUtilities.GetResourceString("Binlog_Source_MultiSubscribeError"));
                 }
 
-                // Forward compatibile reading makes sense only for structured events reading.
+                // Forward compatible reading makes sense only for structured events reading.
                 reader.SkipUnknownEvents = supportsForwardCompatibility && AllowForwardCompatibility;
                 reader.SkipUnknownEventParts = supportsForwardCompatibility && AllowForwardCompatibility;
                 reader.OnRecoverableReadError += OnRecoverableReadError;
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 142bd50b8ed..a211abea99d 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -276,7 +276,6 @@ public void Shutdown()
 
             Traits.Instance.EscapeHatches.LogProjectImports = _initialLogImports;
 
-
             if (projectImportsCollector != null)
             {
                 projectImportsCollector.Close();
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 095ca07e20c..28fbc25ae22 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -30,6 +30,7 @@ public class BuildEventArgsReader : IBuildEventArgsReaderNotifications, IDisposa
         private long recordNumber = 0;
         private bool _skipUnknownEvents;
         private bool _skipUnknownEventParts;
+        private const int ForwardCompatibilityMinimalVersion = 18;
 
         /// <summary>
         /// A list of string records we've encountered so far. If it's a small string, it will be the string directly.
@@ -115,7 +116,7 @@ public bool SkipUnknownEventParts
 
         private void EnsureForwardCompatibleReadingSupported()
         {
-            if (fileFormatVersion < 18)
+            if (fileFormatVersion < ForwardCompatibilityMinimalVersion)
             {
                 throw new InvalidOperationException(
                     ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Binlog_FwdCompatUnsupported",
@@ -169,7 +170,7 @@ public void Dispose()
             ////                           $"Raw data reading is not supported for file format version {fileFormatVersion} (needs >=18).");
             ////}
 
-            if (!(_lastSubStream?.IsAtEnd ?? true))
+            if (_lastSubStream?.IsAtEnd == false)
             {
                 throw new InvalidDataException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Binlog_RawDataUnread", recordNumber));
             }
@@ -209,7 +210,7 @@ public void Dispose()
                 }
 
                 int serializedEventLength = 0;
-                if (fileFormatVersion >= 18)
+                if (fileFormatVersion >= ForwardCompatibilityMinimalVersion)
                 {
                     serializedEventLength = ReadInt32(); // record length
                     _readStream.BytesCountAllowedToRead = serializedEventLength;
@@ -274,61 +275,34 @@ void HandleError(string msg, bool noThrow, ReaderErrorType readerErrorType, Bina
         }
 
         private BuildEventArgs? ReadBuildEventArgs(BinaryLogRecordKind recordKind)
-        {
-            switch (recordKind)
-            {
-                case BinaryLogRecordKind.BuildStarted:
-                    return ReadBuildStartedEventArgs();
-                case BinaryLogRecordKind.BuildFinished:
-                    return ReadBuildFinishedEventArgs();
-                case BinaryLogRecordKind.ProjectStarted:
-                    return ReadProjectStartedEventArgs();
-                case BinaryLogRecordKind.ProjectFinished:
-                    return ReadProjectFinishedEventArgs();
-                case BinaryLogRecordKind.TargetStarted:
-                    return ReadTargetStartedEventArgs();
-                case BinaryLogRecordKind.TargetFinished:
-                    return ReadTargetFinishedEventArgs();
-                case BinaryLogRecordKind.TaskStarted:
-                    return ReadTaskStartedEventArgs();
-                case BinaryLogRecordKind.TaskFinished:
-                    return ReadTaskFinishedEventArgs();
-                case BinaryLogRecordKind.Error:
-                    return ReadBuildErrorEventArgs();
-                case BinaryLogRecordKind.Warning:
-                    return ReadBuildWarningEventArgs();
-                case BinaryLogRecordKind.Message:
-                    return ReadBuildMessageEventArgs();
-                case BinaryLogRecordKind.CriticalBuildMessage:
-                    return ReadCriticalBuildMessageEventArgs();
-                case BinaryLogRecordKind.TaskCommandLine:
-                    return ReadTaskCommandLineEventArgs();
-                case BinaryLogRecordKind.TaskParameter:
-                    return ReadTaskParameterEventArgs();
-                case BinaryLogRecordKind.ProjectEvaluationStarted:
-                    return ReadProjectEvaluationStartedEventArgs();
-                case BinaryLogRecordKind.ProjectEvaluationFinished:
-                    return ReadProjectEvaluationFinishedEventArgs();
-                case BinaryLogRecordKind.ProjectImported:
-                    return ReadProjectImportedEventArgs();
-                case BinaryLogRecordKind.TargetSkipped:
-                    return ReadTargetSkippedEventArgs();
-                case BinaryLogRecordKind.EnvironmentVariableRead:
-                    return ReadEnvironmentVariableReadEventArgs();
-                case BinaryLogRecordKind.ResponseFileUsed:
-                    return ReadResponseFileUsedEventArgs();
-                case BinaryLogRecordKind.PropertyReassignment:
-                    return ReadPropertyReassignmentEventArgs();
-                case BinaryLogRecordKind.UninitializedPropertyRead:
-                    return ReadUninitializedPropertyReadEventArgs();
-                case BinaryLogRecordKind.PropertyInitialValueSet:
-                    return ReadPropertyInitialValueSetEventArgs();
-                case BinaryLogRecordKind.AssemblyLoad:
-                    return ReadAssemblyLoadEventArgs();
-                default:
-                    return null;
-            }
-        }
+            => recordKind switch
+            {
+                BinaryLogRecordKind.BuildStarted => ReadBuildStartedEventArgs(),
+                BinaryLogRecordKind.BuildFinished => ReadBuildFinishedEventArgs(),
+                BinaryLogRecordKind.ProjectStarted => ReadProjectStartedEventArgs(),
+                BinaryLogRecordKind.ProjectFinished => ReadProjectFinishedEventArgs(),
+                BinaryLogRecordKind.TargetStarted => ReadTargetStartedEventArgs(),
+                BinaryLogRecordKind.TargetFinished => ReadTargetFinishedEventArgs(),
+                BinaryLogRecordKind.TaskStarted => ReadTaskStartedEventArgs(),
+                BinaryLogRecordKind.TaskFinished => ReadTaskFinishedEventArgs(),
+                BinaryLogRecordKind.Error => ReadBuildErrorEventArgs(),
+                BinaryLogRecordKind.Warning => ReadBuildWarningEventArgs(),
+                BinaryLogRecordKind.Message => ReadBuildMessageEventArgs(),
+                BinaryLogRecordKind.CriticalBuildMessage => ReadCriticalBuildMessageEventArgs(),
+                BinaryLogRecordKind.TaskCommandLine => ReadTaskCommandLineEventArgs(),
+                BinaryLogRecordKind.TaskParameter => ReadTaskParameterEventArgs(),
+                BinaryLogRecordKind.ProjectEvaluationStarted => ReadProjectEvaluationStartedEventArgs(),
+                BinaryLogRecordKind.ProjectEvaluationFinished => ReadProjectEvaluationFinishedEventArgs(),
+                BinaryLogRecordKind.ProjectImported => ReadProjectImportedEventArgs(),
+                BinaryLogRecordKind.TargetSkipped => ReadTargetSkippedEventArgs(),
+                BinaryLogRecordKind.EnvironmentVariableRead => ReadEnvironmentVariableReadEventArgs(),
+                BinaryLogRecordKind.ResponseFileUsed => ReadResponseFileUsedEventArgs(),
+                BinaryLogRecordKind.PropertyReassignment => ReadPropertyReassignmentEventArgs(),
+                BinaryLogRecordKind.UninitializedPropertyRead => ReadUninitializedPropertyReadEventArgs(),
+                BinaryLogRecordKind.PropertyInitialValueSet => ReadPropertyInitialValueSetEventArgs(),
+                BinaryLogRecordKind.AssemblyLoad => ReadAssemblyLoadEventArgs(),
+                _ => null
+            };
 
         private void SkipBytes(int count)
         {
@@ -458,7 +432,7 @@ private void ReadEmbeddedContent(BinaryLogRecordKind recordKind)
 
         private void ReadNameValueList()
         {
-            if (fileFormatVersion >= 18)
+            if (fileFormatVersion >= ForwardCompatibilityMinimalVersion)
             {
                 _readStream.BytesCountAllowedToRead = ReadInt32();
             }
@@ -661,7 +635,7 @@ private BuildEventArgs ReadProjectEvaluationFinishedEventArgs()
 
             if (fileFormatVersion >= 12)
             {
-                if (fileFormatVersion < 18)
+                if (fileFormatVersion < ForwardCompatibilityMinimalVersion)
                 {
                     // Throw away, but need to advance past it
                     ReadBoolean();
@@ -717,7 +691,7 @@ private BuildEventArgs ReadProjectStartedEventArgs()
 
             if (fileFormatVersion > 6)
             {
-                if (fileFormatVersion < 18)
+                if (fileFormatVersion < ForwardCompatibilityMinimalVersion)
                 {
                     // Throw away, but need to advance past it
                     ReadBoolean();
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs
index 067857c9355..85ea32a9125 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFile.cs
@@ -9,8 +9,16 @@
 
 namespace Microsoft.Build.Logging
 {
+    /// <summary>
+    /// An object model for binlog embedded files.
+    /// </summary>
     public sealed class ArchiveFile
     {
+        private bool _streamAcquired;
+        private bool _stringAcquired;
+        private readonly StreamReader _contentReader;
+        private string? _content;
+
         public ArchiveFile(string fullPath, Stream contentStream)
         {
             FullPath = fullPath;
@@ -73,11 +81,6 @@ public string GetContent()
             return _content!;
         }
 
-        private bool _streamAcquired;
-        private bool _stringAcquired;
-        private readonly StreamReader _contentReader;
-        private string? _content;
-
         // Intentionally not exposing this publicly (e.g. as IDisposable implementation)
         // as we don't want to user to be bothered with ownership and disposing concerns.
         internal void Dispose() => _contentReader.Dispose();
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgs.cs b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgs.cs
index 684a4e92384..16ae1a3130d 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgs.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/ArchiveFileEventArgs.cs
@@ -7,9 +7,12 @@
 
 namespace Microsoft.Build.Logging;
 
+/// <summary>
+/// Event arguments for <see cref="IBuildFileReader.ArchiveFileEncountered"/> event.
+/// </summary>
 public sealed class ArchiveFileEventArgs : EventArgs
 {
-    private ArchiveFile  _archiveFile;
+    private ArchiveFile _archiveFile;
     private bool _resultSet;
     private Action _disposeAction;
 
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/IBinlogReaderErrors.cs b/src/Build/Logging/BinaryLogger/Postprocessing/IBinlogReaderErrors.cs
index f663c9bc967..3a28038c82d 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/IBinlogReaderErrors.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/IBinlogReaderErrors.cs
@@ -2,10 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 namespace Microsoft.Build.Logging
 {
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/IEmbeddedContentSource.cs b/src/Build/Logging/BinaryLogger/Postprocessing/IEmbeddedContentSource.cs
index c07c3b2ee78..02c31a80f8a 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/IEmbeddedContentSource.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/IEmbeddedContentSource.cs
@@ -7,7 +7,6 @@ namespace Microsoft.Build.Logging
 {
     internal interface IEmbeddedContentSource
     {
-        
         /// <summary>
         /// Raised when the log reader encounters a project import archive (embedded content) in the stream.
         /// The subscriber must read the exactly given length of binary data from the stream - otherwise exception is raised.
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
index b2104f2dc03..b335f80f0fc 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/StreamExtensions.cs
@@ -5,38 +5,30 @@
 using System.Buffers;
 using System.Diagnostics;
 using System.IO;
+using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
 {
     internal static class StreamExtensions
     {
-        public static int ReadAtLeast(this Stream stream, byte[] buffer, int offset, int minimumBytes, bool throwOnEndOfStream)
+        private static bool CheckIsSkipNeeded(long bytesCount)
         {
-            Debug.Assert(offset + minimumBytes <= buffer.Length);
-
-            int totalRead = 0;
-            while (totalRead < minimumBytes)
+            if(bytesCount is < 0 or > int.MaxValue)
             {
-                int read = stream.Read(buffer, offset, minimumBytes - totalRead);
-                if (read == 0)
-                {
-                    if (throwOnEndOfStream)
-                    {
-                        throw new InvalidDataException("Unexpected end of stream.");
-                    }
-
-                    return totalRead;
-                }
-
-                totalRead += read;
-                offset += read;
+                throw new ArgumentOutOfRangeException(nameof(bytesCount), ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Binlog_StreamUtils_UnsupportedSkipOffset",
+                    bytesCount));
             }
 
-            return totalRead;
+            return bytesCount > 0;
         }
 
         public static long SkipBytes(this Stream stream, long bytesCount, bool throwOnEndOfStream)
         {
+            if (!CheckIsSkipNeeded(bytesCount))
+            {
+                return 0;
+            }
+
             byte[] buffer = ArrayPool<byte>.Shared.Rent(4096);
             using var _ = new CleanupScope(() => ArrayPool<byte>.Shared.Return(buffer));
             return SkipBytes(stream, bytesCount, throwOnEndOfStream, buffer);
@@ -44,10 +36,15 @@ public static long SkipBytes(this Stream stream, long bytesCount, bool throwOnEn
 
         public static long SkipBytes(this Stream stream, long bytesCount, bool throwOnEndOfStream, byte[] buffer)
         {
+            if (!CheckIsSkipNeeded(bytesCount))
+            {
+                return 0;
+            }
+
             long totalRead = 0;
             while (totalRead < bytesCount)
             {
-                int read = stream.Read(buffer, 0,  (int)Math.Min(bytesCount - totalRead, buffer.Length));
+                int read = stream.Read(buffer, 0, (int)Math.Min(bytesCount - totalRead, buffer.Length));
                 if (read == 0)
                 {
                     if (throwOnEndOfStream)
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
index 3f81adb3558..ff5caf9bfdf 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/SubStream.cs
@@ -2,11 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
@@ -14,7 +10,7 @@ namespace Microsoft.Build.Logging
     /// <summary>
     /// Bounded read-only, forward-only view over an underlying stream.
     /// </summary>
-    internal class SubStream : Stream
+    internal sealed class SubStream : Stream
     {
         // Do not Dispose/Close on Dispose/Close !!
         private readonly Stream _stream;
@@ -28,7 +24,7 @@ public SubStream(Stream stream, long length)
 
             if (!stream.CanRead)
             {
-                throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_MustBeReadable"));
+                throw new NotSupportedException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_MustBeReadable"));
             }
         }
 
diff --git a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
index f8818f9353f..4e1452f299d 100644
--- a/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
+++ b/src/Build/Logging/BinaryLogger/Postprocessing/TransparentReadStream.cs
@@ -2,13 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Buffers;
-using System.Collections.Generic;
 using System.IO;
-using System.Linq;
-using System.Runtime.InteropServices.ComTypes;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Logging
@@ -16,10 +10,11 @@ namespace Microsoft.Build.Logging
     /// <summary>
     /// A wrapper stream that allows position tracking and forward seeking.
     /// </summary>
-    internal class TransparentReadStream : Stream
+    internal sealed class TransparentReadStream : Stream
     {
         private readonly Stream _stream;
         private long _position;
+        private long _maxAllowedPosition = long.MaxValue;
 
         public static Stream EnsureSeekableStream(Stream stream)
         {
@@ -28,7 +23,7 @@ public static Stream EnsureSeekableStream(Stream stream)
                 return stream;
             }
 
-            if(!stream.CanRead)
+            if (!stream.CanRead)
             {
                 throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_MustBeReadable"));
             }
@@ -65,7 +60,6 @@ public int? BytesCountAllowedToRead
         public int BytesCountAllowedToReadRemaining =>
             _maxAllowedPosition == long.MaxValue ? 0 : (int)(_maxAllowedPosition - _position);
 
-        private long _maxAllowedPosition = long.MaxValue;
         public override bool CanRead => _stream.CanRead;
         public override bool CanSeek => true;
         public override bool CanWrite => false;
@@ -73,7 +67,7 @@ public int? BytesCountAllowedToRead
         public override long Position
         {
             get => _position;
-            set => this.SkipBytes((int)(value - _position), true);
+            set => this.SkipBytes(value - _position, true);
         }
 
         public override void Flush()
@@ -97,24 +91,24 @@ public override int Read(byte[] buffer, int offset, int count)
 
         public override long Seek(long offset, SeekOrigin origin)
         {
-            if(origin != SeekOrigin.Current)
+            if (origin != SeekOrigin.Current)
             {
-                throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_SeekNonOrigin"));
+                throw new NotSupportedException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_SeekNonOrigin"));
             }
 
-            this.SkipBytes((int)offset, true);
+            this.SkipBytes(offset, true);
 
             return _position;
         }
 
         public override void SetLength(long value)
         {
-            throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_ExpandUnsupported"));
+            throw new NotSupportedException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_ExpandUnsupported"));
         }
 
         public override void Write(byte[] buffer, int offset, int count)
         {
-            throw new InvalidOperationException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_WriteUnsupported"));
+            throw new NotSupportedException(ResourceUtilities.GetResourceString("Binlog_StreamUtils_WriteUnsupported"));
         }
 
         public override void Close() => _stream.Close();
diff --git a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
index b609f54bd25..f17f403e3e5 100644
--- a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
+++ b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
@@ -47,7 +47,6 @@ internal static void FlushBlobToFile(
         // Archive file will be stored alongside the binlog
         private static string GetArchiveFilePath(string logFilePath, string sourcesArchiveExtension)
             => Path.ChangeExtension(logFilePath, sourcesArchiveExtension);
-        
 
         public ProjectImportsCollector(
             string logFilePath,
@@ -212,7 +211,7 @@ private bool ShouldAddFile(ref string filePath, bool checkFileExistence, bool ma
             }
 
             // Only make the path absolute if it's request. In the replay scenario, the file entries
-            //  are read from zip archive - where ':' is stripped and path can then seem relative.
+            // are read from zip archive - where ':' is stripped and path can then seem relative.
             if (makeAbsolute)
             {
                 filePath = Path.GetFullPath(filePath);
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index e9cff203b6e..450782c697b 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -2073,6 +2073,12 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
   <data name="Binlog_StreamUtils_WriteUnsupported" xml:space="preserve">
     <value>Writing is not supported.</value>
   </data>
+  <data name="Binlog_StreamUtils_UnsupportedSkipOffset" xml:space="preserve">
+    <value>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</value>
+    <comment>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </comment>
+  </data>
   <!--
         The Build message bucket is: MSB4000 - MSB4999
 
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 1c99e0f99af..5853168dd14 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 7a096c2b497..d003e7ba4c8 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 3de28d9fb1e..c5c3d84ca9f 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 7f04fa7b453..8c6f1ab83b5 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 9c257d259d8..da6f69c264d 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 2e38611fe8a..1f36992445e 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 1accbcc70ea..1824e77ef5d 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index eda94d4c3e8..2020bb8debe 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 894404d3186..44692088722 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 189b30e70ed..2be702fa978 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index c314d07bbfa..54cb48f0e9e 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 2afc3c8e920..4909b0f8e6a 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index ea8e46289e6..bcae4b02063 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -118,6 +118,13 @@
         <target state="new">Only seeking from SeekOrigin.Current is supported.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Binlog_StreamUtils_UnsupportedSkipOffset">
+        <source>"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</source>
+        <target state="new">"Attempt to skip {0} bytes, only non-negative offset up to int.MaxValue is allowed.</target>
+        <note>
+      LOCALIZATION: {0} is integer number denoting number of bytes. 'int.MaxValue' should not be translated.
+    </note>
+      </trans-unit>
       <trans-unit id="Binlog_StreamUtils_WriteUnsupported">
         <source>Writing is not supported.</source>
         <target state="new">Writing is not supported.</target>
