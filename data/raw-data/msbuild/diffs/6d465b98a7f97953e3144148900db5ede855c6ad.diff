diff --git a/src/Build/BuildCheck/.editorconfig b/src/Build/BuildCheck/.editorconfig
new file mode 100644
index 00000000000..731ad1c1785
--- /dev/null
+++ b/src/Build/BuildCheck/.editorconfig
@@ -0,0 +1,2 @@
+[*.cs]
+csharp_style_namespace_declarations = file_scoped:warning
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
index faefc2499d9..4472f92dddb 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigFile.cs
@@ -18,168 +18,167 @@
 using System.Text.RegularExpressions;
 using System.Threading.Tasks;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure.EditorConfig
+namespace Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;
+
+internal partial class EditorConfigFile
 {
-    internal partial class EditorConfigFile
-    {
-        // Matches EditorConfig section header such as "[*.{js,py}]", see https://editorconfig.org for details
-        private const string s_sectionMatcherPattern = @"^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$";
+    // Matches EditorConfig section header such as "[*.{js,py}]", see https://editorconfig.org for details
+    private const string s_sectionMatcherPattern = @"^\s*\[(([^#;]|\\#|\\;)+)\]\s*([#;].*)?$";
 
-        // Matches EditorConfig property such as "indent_style = space", see https://editorconfig.org for details
-        private const string s_propertyMatcherPattern = @"^\s*([\w\.\-_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$";
+    // Matches EditorConfig property such as "indent_style = space", see https://editorconfig.org for details
+    private const string s_propertyMatcherPattern = @"^\s*([\w\.\-_]+)\s*[=:]\s*(.*?)\s*([#;].*)?$";
 
 #if NETCOREAPP
 
-    [GeneratedRegex(s_sectionMatcherPattern)]
-    private static partial Regex GetSectionMatcherRegex();
+[GeneratedRegex(s_sectionMatcherPattern)]
+private static partial Regex GetSectionMatcherRegex();
 
-    [GeneratedRegex(s_propertyMatcherPattern)]
-    private static partial Regex GetPropertyMatcherRegex();
+[GeneratedRegex(s_propertyMatcherPattern)]
+private static partial Regex GetPropertyMatcherRegex();
 
 #else
-        private static readonly Regex s_sectionMatcher = new Regex(s_sectionMatcherPattern, RegexOptions.Compiled);
+    private static readonly Regex s_sectionMatcher = new Regex(s_sectionMatcherPattern, RegexOptions.Compiled);
 
-        private static readonly Regex s_propertyMatcher = new Regex(s_propertyMatcherPattern, RegexOptions.Compiled);
+    private static readonly Regex s_propertyMatcher = new Regex(s_propertyMatcherPattern, RegexOptions.Compiled);
 
-        private static Regex GetSectionMatcherRegex() => s_sectionMatcher;
+    private static Regex GetSectionMatcherRegex() => s_sectionMatcher;
 
-        private static Regex GetPropertyMatcherRegex() => s_propertyMatcher;
+    private static Regex GetPropertyMatcherRegex() => s_propertyMatcher;
 
 #endif
 
-        internal Section GlobalSection { get; }
+    internal Section GlobalSection { get; }
 
-        internal ImmutableArray<Section> NamedSections { get; }
+    internal ImmutableArray<Section> NamedSections { get; }
 
-        /// <summary>
-        /// Gets whether this editorconfig is a topmost editorconfig.
-        /// </summary>
-        internal bool IsRoot => GlobalSection.Properties.TryGetValue("root", out string? val) && val?.ToLower() == "true";
+    /// <summary>
+    /// Gets whether this editorconfig is a topmost editorconfig.
+    /// </summary>
+    internal bool IsRoot => GlobalSection.Properties.TryGetValue("root", out string? val) && val?.ToLower() == "true";
 
-        private EditorConfigFile(
-            Section globalSection,
-            ImmutableArray<Section> namedSections)
-        {
-            GlobalSection = globalSection;
-            NamedSections = namedSections;
-        }
+    private EditorConfigFile(
+        Section globalSection,
+        ImmutableArray<Section> namedSections)
+    {
+        GlobalSection = globalSection;
+        NamedSections = namedSections;
+    }
 
-        /// <summary>
-        /// Parses an editor config file text located at the given path. No parsing
-        /// errors are reported. If any line contains a parse error, it is dropped.
-        /// </summary>
-        internal static EditorConfigFile Parse(string text)
+    /// <summary>
+    /// Parses an editor config file text located at the given path. No parsing
+    /// errors are reported. If any line contains a parse error, it is dropped.
+    /// </summary>
+    internal static EditorConfigFile Parse(string text)
+    {
+        Section? globalSection = null;
+        var namedSectionBuilder = ImmutableArray.CreateBuilder<Section>();
+
+        // N.B. The editorconfig documentation is quite loose on property interpretation.
+        // Specifically, it says:
+        //      Currently all properties and values are case-insensitive.
+        //      They are lowercased when parsed.
+        // To accommodate this, we use a lower case Unicode mapping when adding to the
+        // dictionary, but we also use a case-insensitive key comparer when doing lookups
+        var activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>(StringComparer.OrdinalIgnoreCase);
+        string activeSectionName = "";
+        var lines = string.IsNullOrEmpty(text) ? Array.Empty<string>() : text.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
+
+        foreach(var line in lines)
         {
-            Section? globalSection = null;
-            var namedSectionBuilder = ImmutableArray.CreateBuilder<Section>();
-
-            // N.B. The editorconfig documentation is quite loose on property interpretation.
-            // Specifically, it says:
-            //      Currently all properties and values are case-insensitive.
-            //      They are lowercased when parsed.
-            // To accommodate this, we use a lower case Unicode mapping when adding to the
-            // dictionary, but we also use a case-insensitive key comparer when doing lookups
-            var activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>(StringComparer.OrdinalIgnoreCase);
-            string activeSectionName = "";
-            var lines = string.IsNullOrEmpty(text) ? Array.Empty<string>() : text.Split(new string[] { Environment.NewLine }, StringSplitOptions.None);
-
-            foreach(var line in lines)
+            if (string.IsNullOrWhiteSpace(line))
             {
-                if (string.IsNullOrWhiteSpace(line))
-                {
-                    continue;
-                }
-
-                if (IsComment(line))
-                {
-                    continue;
-                }
-
-                var sectionMatches = GetSectionMatcherRegex().Matches(line);
-                if (sectionMatches.Count > 0 && sectionMatches[0].Groups.Count > 0)
-                {
-                    addNewSection();
-
-                    var sectionName = sectionMatches[0].Groups[1].Value;
-                    Debug.Assert(!string.IsNullOrEmpty(sectionName));
-
-                    activeSectionName = sectionName;
-                    activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>();
-                    continue;
-                }
-
-                var propMatches = GetPropertyMatcherRegex().Matches(line);
-                if (propMatches.Count > 0 && propMatches[0].Groups.Count > 1)
-                {
-                    var key = propMatches[0].Groups[1].Value.ToLower();
-                    var value = propMatches[0].Groups[2].Value;
-
-                    Debug.Assert(!string.IsNullOrEmpty(key));
-                    Debug.Assert(key == key.Trim());
-                    Debug.Assert(value == value?.Trim());
-
-                    activeSectionProperties[key] = value ?? "";
-                    continue;
-                }
+                continue;
             }
 
-            // Add the last section
-            addNewSection();
+            if (IsComment(line))
+            {
+                continue;
+            }
+
+            var sectionMatches = GetSectionMatcherRegex().Matches(line);
+            if (sectionMatches.Count > 0 && sectionMatches[0].Groups.Count > 0)
+            {
+                addNewSection();
+
+                var sectionName = sectionMatches[0].Groups[1].Value;
+                Debug.Assert(!string.IsNullOrEmpty(sectionName));
 
-            return new EditorConfigFile(globalSection!, namedSectionBuilder.ToImmutable());
+                activeSectionName = sectionName;
+                activeSectionProperties = ImmutableDictionary.CreateBuilder<string, string>();
+                continue;
+            }
 
-            void addNewSection()
+            var propMatches = GetPropertyMatcherRegex().Matches(line);
+            if (propMatches.Count > 0 && propMatches[0].Groups.Count > 1)
             {
-                // Close out the previous section
-                var previousSection = new Section(activeSectionName, activeSectionProperties.ToImmutable());
-                if (activeSectionName == "")
-                {
-                    // This is the global section
-                    globalSection = previousSection;
-                }
-                else
-                {
-                    namedSectionBuilder.Add(previousSection);
-                }
+                var key = propMatches[0].Groups[1].Value.ToLower();
+                var value = propMatches[0].Groups[2].Value;
+
+                Debug.Assert(!string.IsNullOrEmpty(key));
+                Debug.Assert(key == key.Trim());
+                Debug.Assert(value == value?.Trim());
+
+                activeSectionProperties[key] = value ?? "";
+                continue;
             }
         }
 
-        private static bool IsComment(string line)
+        // Add the last section
+        addNewSection();
+
+        return new EditorConfigFile(globalSection!, namedSectionBuilder.ToImmutable());
+
+        void addNewSection()
         {
-            foreach (char c in line)
+            // Close out the previous section
+            var previousSection = new Section(activeSectionName, activeSectionProperties.ToImmutable());
+            if (activeSectionName == "")
             {
-                if (!char.IsWhiteSpace(c))
-                {
-                    return c == '#' || c == ';';
-                }
+                // This is the global section
+                globalSection = previousSection;
+            }
+            else
+            {
+                namedSectionBuilder.Add(previousSection);
             }
-
-            return false;
         }
+    }
 
-        /// <summary>
-        /// Represents a named section of the editorconfig file, which consists of a name followed by a set
-        /// of key-value pairs.
-        /// </summary>
-        internal sealed class Section
+    private static bool IsComment(string line)
+    {
+        foreach (char c in line)
         {
-            public Section(string name, ImmutableDictionary<string, string> properties)
+            if (!char.IsWhiteSpace(c))
             {
-                Name = name;
-                Properties = properties;
+                return c == '#' || c == ';';
             }
+        }
 
-            /// <summary>
-            /// For regular files, the name as present directly in the section specification of the editorconfig file. For sections in
-            /// global configs, this is the unescaped full file path.
-            /// </summary>
-            public string Name { get; }
-
-            /// <summary>
-            /// Keys and values for this section. All keys are lower-cased according to the
-            /// EditorConfig specification and keys are compared case-insensitively. 
-            /// </summary>
-            public ImmutableDictionary<string, string> Properties { get; }
+        return false;
+    }
+
+    /// <summary>
+    /// Represents a named section of the editorconfig file, which consists of a name followed by a set
+    /// of key-value pairs.
+    /// </summary>
+    internal sealed class Section
+    {
+        public Section(string name, ImmutableDictionary<string, string> properties)
+        {
+            Name = name;
+            Properties = properties;
         }
+
+        /// <summary>
+        /// For regular files, the name as present directly in the section specification of the editorconfig file. For sections in
+        /// global configs, this is the unescaped full file path.
+        /// </summary>
+        public string Name { get; }
+
+        /// <summary>
+        /// Keys and values for this section. All keys are lower-cased according to the
+        /// EditorConfig specification and keys are compared case-insensitively. 
+        /// </summary>
+        public ImmutableDictionary<string, string> Properties { get; }
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
index 092859a5113..516190c2ab3 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigGlobsMatcher.cs
@@ -19,597 +19,596 @@
 using System.Text.RegularExpressions;
 using System.Threading.Tasks;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure.EditorConfig
+namespace Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;
+
+internal class EditorConfigGlobsMatcher
 {
-    internal class EditorConfigGlobsMatcher
+    internal readonly struct SectionNameMatcher
     {
-        internal readonly struct SectionNameMatcher
-        {
-            private readonly ImmutableArray<(int minValue, int maxValue)> _numberRangePairs;
+        private readonly ImmutableArray<(int minValue, int maxValue)> _numberRangePairs;
 
-            internal Regex Regex { get; }
+        internal Regex Regex { get; }
+
+        internal SectionNameMatcher(
+            Regex regex,
+            ImmutableArray<(int minValue, int maxValue)> numberRangePairs)
+        {
+            Debug.Assert(regex.GetGroupNumbers().Length - 1 == numberRangePairs.Length);
+            Regex = regex;
+            _numberRangePairs = numberRangePairs;
+        }
 
-            internal SectionNameMatcher(
-                Regex regex,
-                ImmutableArray<(int minValue, int maxValue)> numberRangePairs)
+        internal bool IsMatch(string s)
+        {
+            if (_numberRangePairs.IsEmpty)
             {
-                Debug.Assert(regex.GetGroupNumbers().Length - 1 == numberRangePairs.Length);
-                Regex = regex;
-                _numberRangePairs = numberRangePairs;
+                return Regex.IsMatch(s);
             }
 
-            internal bool IsMatch(string s)
+            var match = Regex.Match(s);
+            if (!match.Success)
             {
-                if (_numberRangePairs.IsEmpty)
-                {
-                    return Regex.IsMatch(s);
-                }
+                return false;
+            }
 
-                var match = Regex.Match(s);
-                if (!match.Success)
+            Debug.Assert(match.Groups.Count - 1 == _numberRangePairs.Length);
+            for (int i = 0; i < _numberRangePairs.Length; i++)
+            {
+                var (minValue, maxValue) = _numberRangePairs[i];
+                // Index 0 is the whole regex
+                if (!int.TryParse(match.Groups[i + 1].Value, out int matchedNum) ||
+                    matchedNum < minValue ||
+                    matchedNum > maxValue)
                 {
                     return false;
                 }
-
-                Debug.Assert(match.Groups.Count - 1 == _numberRangePairs.Length);
-                for (int i = 0; i < _numberRangePairs.Length; i++)
-                {
-                    var (minValue, maxValue) = _numberRangePairs[i];
-                    // Index 0 is the whole regex
-                    if (!int.TryParse(match.Groups[i + 1].Value, out int matchedNum) ||
-                        matchedNum < minValue ||
-                        matchedNum > maxValue)
-                    {
-                        return false;
-                    }
-                }
-                return true;
             }
+            return true;
         }
+    }
 
-        /// <summary>
-        /// Takes a <see cref="EditorConfigFile.Section.Name"/> and creates a matcher that
-        /// matches the given language. Returns null if the section name is
-        /// invalid.
-        /// </summary>
-        internal static SectionNameMatcher? TryCreateSectionNameMatcher(string sectionName)
+    /// <summary>
+    /// Takes a <see cref="EditorConfigFile.Section.Name"/> and creates a matcher that
+    /// matches the given language. Returns null if the section name is
+    /// invalid.
+    /// </summary>
+    internal static SectionNameMatcher? TryCreateSectionNameMatcher(string sectionName)
+    {
+        // An editorconfig section name is a language for recognizing file paths
+        // defined by the following grammar:
+        //
+        // <path> ::= <path-list>
+        // <path-list> ::= <path-item> | <path-item> <path-list>
+        // <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+        // <char> ::= any unicode character
+        // <choice> ::= "{" <choice-list> "}"
+        // <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+        // <range> ::= "{" <integer> ".." <integer> "}"
+        // <integer> ::= "-" <digit-list> | <digit-list>
+        // <digit-list> ::= <digit> | <digit> <digit-list>
+        // <digit> ::= 0-9
+
+        var sb = new StringBuilder();
+        sb.Append('^');
+
+        // EditorConfig matching depends on the whether or not there are
+        // directory separators and where they are located in the section
+        // name. Specifically, the editorconfig core parser says:
+        // https://github.com/editorconfig/editorconfig-core-c/blob/5d3996811e962a717a7d7fdd0a941192382241a7/src/lib/editorconfig.c#L231
+        //
+        //     Pattern would be:
+        //     /dir/of/editorconfig/file[double_star]/[section] if section does not contain '/',
+        //     /dir/of/editorconfig/file[section] if section starts with a '/', or
+        //     /dir/of/editorconfig/file/[section] if section contains '/' but does not start with '/'.
+
+        if (!sectionName.Contains("/"))
+        {
+            sb.Append(".*/");
+        }
+        else if (sectionName[0] != '/')
         {
-            // An editorconfig section name is a language for recognizing file paths
-            // defined by the following grammar:
-            //
-            // <path> ::= <path-list>
-            // <path-list> ::= <path-item> | <path-item> <path-list>
-            // <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
-            // <char> ::= any unicode character
-            // <choice> ::= "{" <choice-list> "}"
-            // <choice-list> ::= <path-list> | <path-list> "," <choice-list>
-            // <range> ::= "{" <integer> ".." <integer> "}"
-            // <integer> ::= "-" <digit-list> | <digit-list>
-            // <digit-list> ::= <digit> | <digit> <digit-list>
-            // <digit> ::= 0-9
+            sb.Append('/');
+        }
 
-            var sb = new StringBuilder();
-            sb.Append('^');
+        var lexer = new SectionNameLexer(sectionName);
+        var numberRangePairs = new List<(int minValue, int maxValue)>();
+        if (!TryCompilePathList(ref lexer, sb, parsingChoice: false, numberRangePairs))
+        {
+            numberRangePairs.Clear();
+            return null;
+        }
+        sb.Append('$');
 
-            // EditorConfig matching depends on the whether or not there are
-            // directory separators and where they are located in the section
-            // name. Specifically, the editorconfig core parser says:
-            // https://github.com/editorconfig/editorconfig-core-c/blob/5d3996811e962a717a7d7fdd0a941192382241a7/src/lib/editorconfig.c#L231
-            //
-            //     Pattern would be:
-            //     /dir/of/editorconfig/file[double_star]/[section] if section does not contain '/',
-            //     /dir/of/editorconfig/file[section] if section starts with a '/', or
-            //     /dir/of/editorconfig/file/[section] if section contains '/' but does not start with '/'.
-
-            if (!sectionName.Contains("/"))
-            {
-                sb.Append(".*/");
-            }
-            else if (sectionName[0] != '/')
-            {
-                sb.Append('/');
-            }
 
-            var lexer = new SectionNameLexer(sectionName);
-            var numberRangePairs = new List<(int minValue, int maxValue)>();
-            if (!TryCompilePathList(ref lexer, sb, parsingChoice: false, numberRangePairs))
-            {
-                numberRangePairs.Clear();
-                return null;
-            }
-            sb.Append('$');
+        var imArray = ImmutableArray.CreateBuilder<(int, int)>(numberRangePairs is null ? 0 : numberRangePairs.Count);
+        if (numberRangePairs?.Count > 0)
+        {
+            imArray.AddRange(numberRangePairs);
+        }
 
+        return new SectionNameMatcher(
+            new Regex(sb.ToString(), RegexOptions.Compiled),
+            imArray.ToImmutableArray());
+    }
 
-            var imArray = ImmutableArray.CreateBuilder<(int, int)>(numberRangePairs is null ? 0 : numberRangePairs.Count);
-            if (numberRangePairs?.Count > 0)
+    internal static string UnescapeSectionName(string sectionName)
+    {
+        var sb = new StringBuilder();
+        SectionNameLexer lexer = new SectionNameLexer(sectionName);
+        while (!lexer.IsDone)
+        {
+            var tokenKind = lexer.Lex();
+            if (tokenKind == TokenKind.SimpleCharacter)
             {
-                imArray.AddRange(numberRangePairs);
+                sb.Append(lexer.EatCurrentCharacter());
             }
-
-            return new SectionNameMatcher(
-                new Regex(sb.ToString(), RegexOptions.Compiled),
-                imArray.ToImmutableArray());
-        }
-
-        internal static string UnescapeSectionName(string sectionName)
-        {
-            var sb = new StringBuilder();
-            SectionNameLexer lexer = new SectionNameLexer(sectionName);
-            while (!lexer.IsDone)
+            else
             {
-                var tokenKind = lexer.Lex();
-                if (tokenKind == TokenKind.SimpleCharacter)
-                {
-                    sb.Append(lexer.EatCurrentCharacter());
-                }
-                else
-                {
-                    // We only call this on strings that were already passed through IsAbsoluteEditorConfigPath, so
-                    // we shouldn't have any other token kinds here.
-                    throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
-                }
+                // We only call this on strings that were already passed through IsAbsoluteEditorConfigPath, so
+                // we shouldn't have any other token kinds here.
+                throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
             }
-            return sb.ToString();
         }
+        return sb.ToString();
+    }
 
-        internal static bool IsAbsoluteEditorConfigPath(string sectionName)
-        {
-            // NOTE: editorconfig paths must use '/' as a directory separator character on all OS.
+    internal static bool IsAbsoluteEditorConfigPath(string sectionName)
+    {
+        // NOTE: editorconfig paths must use '/' as a directory separator character on all OS.
 
-            // on all unix systems this is thus a simple test: does the path start with '/'
-            // and contain no special chars?
+        // on all unix systems this is thus a simple test: does the path start with '/'
+        // and contain no special chars?
 
-            // on windows, a path can be either drive rooted or not (e.g. start with 'c:' or just '')
-            // in addition to being absolute or relative.
-            // for example c:myfile.cs is a relative path, but rooted on drive c:
-            // /myfile2.cs is an absolute path but rooted to the current drive.
+        // on windows, a path can be either drive rooted or not (e.g. start with 'c:' or just '')
+        // in addition to being absolute or relative.
+        // for example c:myfile.cs is a relative path, but rooted on drive c:
+        // /myfile2.cs is an absolute path but rooted to the current drive.
 
-            // in addition there are UNC paths and volume guids (see https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats)
-            // but these start with \\ (and thus '/' in editor config terminology)
+        // in addition there are UNC paths and volume guids (see https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats)
+        // but these start with \\ (and thus '/' in editor config terminology)
 
-            // in this implementation we choose to ignore the drive root for the purposes of
-            // determining validity. On windows c:/file.cs and /file.cs are both assumed to be
-            // valid absolute paths, even though the second one is technically relative to
-            // the current drive of the compiler working directory. 
+        // in this implementation we choose to ignore the drive root for the purposes of
+        // determining validity. On windows c:/file.cs and /file.cs are both assumed to be
+        // valid absolute paths, even though the second one is technically relative to
+        // the current drive of the compiler working directory. 
 
-            // Note that this check has no impact on config correctness. Files on windows
-            // will still be compared using their full path (including drive root) so it's
-            // not possible to target the wrong file. It's just possible that the user won't
-            // receive a warning that this section is ignored on windows in this edge case.
+        // Note that this check has no impact on config correctness. Files on windows
+        // will still be compared using their full path (including drive root) so it's
+        // not possible to target the wrong file. It's just possible that the user won't
+        // receive a warning that this section is ignored on windows in this edge case.
 
-            SectionNameLexer nameLexer = new SectionNameLexer(sectionName);
-            bool sawStartChar = false;
-            int logicalIndex = 0;
-            while (!nameLexer.IsDone)
+        SectionNameLexer nameLexer = new SectionNameLexer(sectionName);
+        bool sawStartChar = false;
+        int logicalIndex = 0;
+        while (!nameLexer.IsDone)
+        {
+            if (nameLexer.Lex() != TokenKind.SimpleCharacter)
             {
-                if (nameLexer.Lex() != TokenKind.SimpleCharacter)
+                return false;
+            }
+            var simpleChar = nameLexer.EatCurrentCharacter();
+
+            // check the path starts with '/'
+            if (logicalIndex == 0)
+            {
+                if (simpleChar == '/')
+                {
+                    sawStartChar = true;
+                }
+                else if (Path.DirectorySeparatorChar == '/')
                 {
                     return false;
                 }
-                var simpleChar = nameLexer.EatCurrentCharacter();
-
-                // check the path starts with '/'
-                if (logicalIndex == 0)
+            }
+            // on windows we get a second chance to find the start char
+            else if (!sawStartChar && Path.DirectorySeparatorChar == '\\')
+            {
+                if (logicalIndex == 1 && simpleChar != ':')
                 {
-                    if (simpleChar == '/')
-                    {
-                        sawStartChar = true;
-                    }
-                    else if (Path.DirectorySeparatorChar == '/')
-                    {
-                        return false;
-                    }
+                    return false;
                 }
-                // on windows we get a second chance to find the start char
-                else if (!sawStartChar && Path.DirectorySeparatorChar == '\\')
+                else if (logicalIndex == 2)
                 {
-                    if (logicalIndex == 1 && simpleChar != ':')
+                    if (simpleChar != '/')
                     {
                         return false;
                     }
-                    else if (logicalIndex == 2)
+                    else
                     {
-                        if (simpleChar != '/')
-                        {
-                            return false;
-                        }
-                        else
-                        {
-                            sawStartChar = true;
-                        }
+                        sawStartChar = true;
                     }
                 }
-                logicalIndex++;
             }
-            return sawStartChar;
+            logicalIndex++;
         }
+        return sawStartChar;
+    }
 
 
-        /// <summary>
-        /// <![CDATA[
-        /// <path-list> ::= <path-item> | <path-item> <path-list>
-        /// <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
-        /// <char> ::= any unicode character
-        /// <choice> ::= "{" <choice-list> "}"
-        /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
-        /// ]]>
-        /// </summary>
-        private static bool TryCompilePathList(
-            ref SectionNameLexer lexer,
-            StringBuilder sb,
-            bool parsingChoice,
-            List<(int minValue, int maxValue)> numberRangePairs)
+    /// <summary>
+    /// <![CDATA[
+    /// <path-list> ::= <path-item> | <path-item> <path-list>
+    /// <path-item> ::= "*"  | "**" | "?" | <char> | <choice> | <range>
+    /// <char> ::= any unicode character
+    /// <choice> ::= "{" <choice-list> "}"
+    /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+    /// ]]>
+    /// </summary>
+    private static bool TryCompilePathList(
+        ref SectionNameLexer lexer,
+        StringBuilder sb,
+        bool parsingChoice,
+        List<(int minValue, int maxValue)> numberRangePairs)
+    {
+        while (!lexer.IsDone)
         {
-            while (!lexer.IsDone)
+            var tokenKind = lexer.Lex();
+            switch (tokenKind)
             {
-                var tokenKind = lexer.Lex();
-                switch (tokenKind)
-                {
-                    case TokenKind.BadToken:
-                        // Parsing failure
-                        return false;
-                    case TokenKind.SimpleCharacter:
-                        // Matches just this character
-                        sb.Append(Regex.Escape(lexer.EatCurrentCharacter().ToString()));
-                        break;
-                    case TokenKind.Question:
-                        // '?' matches any single character
-                        sb.Append('.');
-                        break;
-                    case TokenKind.Star:
-                        // Matches any string of characters except directory separator
-                        // Directory separator is defined in editorconfig spec as '/'
-                        sb.Append("[^/]*");
-                        break;
-                    case TokenKind.StarStar:
-                        // Matches any string of characters
-                        sb.Append(".*");
-                        break;
-                    case TokenKind.OpenCurly:
-                        // Back up token stream. The following helpers all expect a '{'
-                        lexer.Position--;
-                        // This is ambiguous between {num..num} and {item1,item2}
-                        // We need to look ahead to disambiguate. Looking for {num..num}
-                        // is easier because it can't be recursive.
-                        (string numStart, string numEnd)? rangeOpt = TryParseNumberRange(ref lexer);
-                        if (rangeOpt is null)
-                        {
-                            // Not a number range. Try a choice expression
-                            if (!TryCompileChoice(ref lexer, sb, numberRangePairs))
-                            {
-                                return false;
-                            }
-                            // Keep looping. There may be more after the '}'.
-                            break;
-                        }
-                        else
+                case TokenKind.BadToken:
+                    // Parsing failure
+                    return false;
+                case TokenKind.SimpleCharacter:
+                    // Matches just this character
+                    sb.Append(Regex.Escape(lexer.EatCurrentCharacter().ToString()));
+                    break;
+                case TokenKind.Question:
+                    // '?' matches any single character
+                    sb.Append('.');
+                    break;
+                case TokenKind.Star:
+                    // Matches any string of characters except directory separator
+                    // Directory separator is defined in editorconfig spec as '/'
+                    sb.Append("[^/]*");
+                    break;
+                case TokenKind.StarStar:
+                    // Matches any string of characters
+                    sb.Append(".*");
+                    break;
+                case TokenKind.OpenCurly:
+                    // Back up token stream. The following helpers all expect a '{'
+                    lexer.Position--;
+                    // This is ambiguous between {num..num} and {item1,item2}
+                    // We need to look ahead to disambiguate. Looking for {num..num}
+                    // is easier because it can't be recursive.
+                    (string numStart, string numEnd)? rangeOpt = TryParseNumberRange(ref lexer);
+                    if (rangeOpt is null)
+                    {
+                        // Not a number range. Try a choice expression
+                        if (!TryCompileChoice(ref lexer, sb, numberRangePairs))
                         {
-                            (string numStart, string numEnd) = rangeOpt.GetValueOrDefault();
-                            if (int.TryParse(numStart, out var intStart) && int.TryParse(numEnd, out var intEnd))
-                            {
-                                var pair = intStart < intEnd ? (intStart, intEnd) : (intEnd, intStart);
-                                numberRangePairs.Add(pair);
-                                // Group allowing any digit sequence. The validity will be checked outside of the regex
-                                sb.Append("(-?[0-9]+)");
-                                // Keep looping
-                                break;
-                            }
                             return false;
                         }
-                    case TokenKind.CloseCurly:
-                        // Either the end of a choice, or a failed parse
-                        return parsingChoice;
-                    case TokenKind.Comma:
-                        // The end of a choice section, or a failed parse
-                        return parsingChoice;
-                    case TokenKind.OpenBracket:
-                        sb.Append('[');
-                        if (!TryCompileCharacterClass(ref lexer, sb))
+                        // Keep looping. There may be more after the '}'.
+                        break;
+                    }
+                    else
+                    {
+                        (string numStart, string numEnd) = rangeOpt.GetValueOrDefault();
+                        if (int.TryParse(numStart, out var intStart) && int.TryParse(numEnd, out var intEnd))
                         {
-                            return false;
+                            var pair = intStart < intEnd ? (intStart, intEnd) : (intEnd, intStart);
+                            numberRangePairs.Add(pair);
+                            // Group allowing any digit sequence. The validity will be checked outside of the regex
+                            sb.Append("(-?[0-9]+)");
+                            // Keep looping
+                            break;
                         }
-                        break;
-                    default:
-                        throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
-                }
+                        return false;
+                    }
+                case TokenKind.CloseCurly:
+                    // Either the end of a choice, or a failed parse
+                    return parsingChoice;
+                case TokenKind.Comma:
+                    // The end of a choice section, or a failed parse
+                    return parsingChoice;
+                case TokenKind.OpenBracket:
+                    sb.Append('[');
+                    if (!TryCompileCharacterClass(ref lexer, sb))
+                    {
+                        return false;
+                    }
+                    break;
+                default:
+                    throw new BuildCheckConfigurationException($"UnexpectedToken: {tokenKind}", BuildCheckConfigurationErrorScope.EditorConfigParser);
             }
-            // If we're parsing a choice we should not exit without a closing '}'
-            return !parsingChoice;
         }
+        // If we're parsing a choice we should not exit without a closing '}'
+        return !parsingChoice;
+    }
 
-        /// <summary>
-        /// Compile a globbing character class of the form [...]. Returns true if
-        /// the character class was successfully compiled. False if there was a syntax
-        /// error. The starting character is expected to be directly after the '['.
-        /// </summary>
-        private static bool TryCompileCharacterClass(ref SectionNameLexer lexer, StringBuilder sb)
+    /// <summary>
+    /// Compile a globbing character class of the form [...]. Returns true if
+    /// the character class was successfully compiled. False if there was a syntax
+    /// error. The starting character is expected to be directly after the '['.
+    /// </summary>
+    private static bool TryCompileCharacterClass(ref SectionNameLexer lexer, StringBuilder sb)
+    {
+        // [...] should match any of the characters in the brackets, with special
+        // behavior for four characters: '!' immediately after the opening bracket
+        // implies the negation of the character class, '-' implies matching
+        // between the locale-dependent range of the previous and next characters,
+        // '\' escapes the following character, and ']' ends the range
+        if (!lexer.IsDone && lexer.CurrentCharacter == '!')
         {
-            // [...] should match any of the characters in the brackets, with special
-            // behavior for four characters: '!' immediately after the opening bracket
-            // implies the negation of the character class, '-' implies matching
-            // between the locale-dependent range of the previous and next characters,
-            // '\' escapes the following character, and ']' ends the range
-            if (!lexer.IsDone && lexer.CurrentCharacter == '!')
-            {
-                sb.Append('^');
-                lexer.Position++;
-            }
-            while (!lexer.IsDone)
-            {
-                var currentChar = lexer.EatCurrentCharacter();
-                switch (currentChar)
-                {
-                    case '-':
-                        // '-' means the same thing in regex as it does in the glob, so
-                        // put it in verbatim
-                        sb.Append(currentChar);
-                        break;
-
-                    case '\\':
-                        // Escape the next char
-                        if (lexer.IsDone)
-                        {
-                            return false;
-                        }
-                        sb.Append('\\');
-                        sb.Append(lexer.EatCurrentCharacter());
-                        break;
-
-                    case ']':
-                        sb.Append(currentChar);
-                        return true;
-
-                    default:
-                        sb.Append(Regex.Escape(currentChar.ToString()));
-                        break;
-                }
-            }
-            // Stream ended without a closing bracket
-            return false;
+            sb.Append('^');
+            lexer.Position++;
         }
-
-        /// <summary>
-        /// Parses choice defined by the following grammar:
-        /// <![CDATA[
-        /// <choice> ::= "{" <choice-list> "}"
-        /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
-        /// ]]>
-        /// </summary>
-        private static bool TryCompileChoice(
-            ref SectionNameLexer lexer,
-            StringBuilder sb,
-            List<(int, int)> numberRangePairs)
+        while (!lexer.IsDone)
         {
-            if (lexer.Lex() != TokenKind.OpenCurly)
+            var currentChar = lexer.EatCurrentCharacter();
+            switch (currentChar)
             {
-                return false;
-            }
-
-            // Start a non-capturing group for the choice
-            sb.Append("(?:");
+                case '-':
+                    // '-' means the same thing in regex as it does in the glob, so
+                    // put it in verbatim
+                    sb.Append(currentChar);
+                    break;
+
+                case '\\':
+                    // Escape the next char
+                    if (lexer.IsDone)
+                    {
+                        return false;
+                    }
+                    sb.Append('\\');
+                    sb.Append(lexer.EatCurrentCharacter());
+                    break;
 
-            // We start immediately after a '{'
-            // Try to compile the nested <path-list>
-            while (TryCompilePathList(ref lexer, sb, parsingChoice: true, numberRangePairs))
-            {
-                // If we've successfully compiled a <path-list> the last token should
-                // have been a ',' or a '}'
-                char lastChar = lexer[lexer.Position - 1];
-                if (lastChar == ',')
-                {
-                    // Another option
-                    sb.Append('|');
-                }
-                else if (lastChar == '}')
-                {
-                    // Close out the capture group
-                    sb.Append(')');
+                case ']':
+                    sb.Append(currentChar);
                     return true;
-                }
-                else
-                {
-                    throw new BuildCheckConfigurationException($"UnexpectedValue: {lastChar}", BuildCheckConfigurationErrorScope.EditorConfigParser);
-                }
+
+                default:
+                    sb.Append(Regex.Escape(currentChar.ToString()));
+                    break;
             }
+        }
+        // Stream ended without a closing bracket
+        return false;
+    }
 
-            // Propagate failure
+    /// <summary>
+    /// Parses choice defined by the following grammar:
+    /// <![CDATA[
+    /// <choice> ::= "{" <choice-list> "}"
+    /// <choice-list> ::= <path-list> | <path-list> "," <choice-list>
+    /// ]]>
+    /// </summary>
+    private static bool TryCompileChoice(
+        ref SectionNameLexer lexer,
+        StringBuilder sb,
+        List<(int, int)> numberRangePairs)
+    {
+        if (lexer.Lex() != TokenKind.OpenCurly)
+        {
             return false;
         }
 
-        /// <summary>
-        /// Parses range defined by the following grammar.
-        /// <![CDATA[
-        /// <range> ::= "{" <integer> ".." <integer> "}"
-        /// <integer> ::= "-" <digit-list> | <digit-list>
-        /// <digit-list> ::= <digit> | <digit> <digit-list>
-        /// <digit> ::= 0-9
-        /// ]]>
-        /// </summary>
-        private static (string numStart, string numEnd)? TryParseNumberRange(ref SectionNameLexer lexer)
+        // Start a non-capturing group for the choice
+        sb.Append("(?:");
+
+        // We start immediately after a '{'
+        // Try to compile the nested <path-list>
+        while (TryCompilePathList(ref lexer, sb, parsingChoice: true, numberRangePairs))
         {
-            var saved = lexer.Position;
-            if (lexer.Lex() != TokenKind.OpenCurly)
+            // If we've successfully compiled a <path-list> the last token should
+            // have been a ',' or a '}'
+            char lastChar = lexer[lexer.Position - 1];
+            if (lastChar == ',')
             {
-                lexer.Position = saved;
-                return null;
+                // Another option
+                sb.Append('|');
             }
-
-            var numStart = lexer.TryLexNumber();
-            if (numStart is null)
+            else if (lastChar == '}')
             {
-                // Not a number
-                lexer.Position = saved;
-                return null;
+                // Close out the capture group
+                sb.Append(')');
+                return true;
             }
-
-            // The next two characters must be ".."
-            if (!lexer.TryEatCurrentCharacter(out char c) || c != '.' ||
-                !lexer.TryEatCurrentCharacter(out c) || c != '.')
+            else
             {
-                lexer.Position = saved;
-                return null;
+                throw new BuildCheckConfigurationException($"UnexpectedValue: {lastChar}", BuildCheckConfigurationErrorScope.EditorConfigParser);
             }
+        }
 
-            // Now another number
-            var numEnd = lexer.TryLexNumber();
-            if (numEnd is null || lexer.IsDone || lexer.Lex() != TokenKind.CloseCurly)
-            {
-                // Not a number or no '}'
-                lexer.Position = saved;
-                return null;
-            }
+        // Propagate failure
+        return false;
+    }
 
-            return (numStart, numEnd);
+    /// <summary>
+    /// Parses range defined by the following grammar.
+    /// <![CDATA[
+    /// <range> ::= "{" <integer> ".." <integer> "}"
+    /// <integer> ::= "-" <digit-list> | <digit-list>
+    /// <digit-list> ::= <digit> | <digit> <digit-list>
+    /// <digit> ::= 0-9
+    /// ]]>
+    /// </summary>
+    private static (string numStart, string numEnd)? TryParseNumberRange(ref SectionNameLexer lexer)
+    {
+        var saved = lexer.Position;
+        if (lexer.Lex() != TokenKind.OpenCurly)
+        {
+            lexer.Position = saved;
+            return null;
         }
 
-        private struct SectionNameLexer
+        var numStart = lexer.TryLexNumber();
+        if (numStart is null)
         {
-            private readonly string _sectionName;
+            // Not a number
+            lexer.Position = saved;
+            return null;
+        }
 
-            internal int Position { get; set; }
+        // The next two characters must be ".."
+        if (!lexer.TryEatCurrentCharacter(out char c) || c != '.' ||
+            !lexer.TryEatCurrentCharacter(out c) || c != '.')
+        {
+            lexer.Position = saved;
+            return null;
+        }
 
-            internal SectionNameLexer(string sectionName)
-            {
-                _sectionName = sectionName;
-                Position = 0;
-            }
+        // Now another number
+        var numEnd = lexer.TryLexNumber();
+        if (numEnd is null || lexer.IsDone || lexer.Lex() != TokenKind.CloseCurly)
+        {
+            // Not a number or no '}'
+            lexer.Position = saved;
+            return null;
+        }
+
+        return (numStart, numEnd);
+    }
+
+    private struct SectionNameLexer
+    {
+        private readonly string _sectionName;
 
-            internal bool IsDone => Position >= _sectionName.Length;
+        internal int Position { get; set; }
 
-            internal TokenKind Lex()
+        internal SectionNameLexer(string sectionName)
+        {
+            _sectionName = sectionName;
+            Position = 0;
+        }
+
+        internal bool IsDone => Position >= _sectionName.Length;
+
+        internal TokenKind Lex()
+        {
+            int lexemeStart = Position;
+            switch (_sectionName[Position])
             {
-                int lexemeStart = Position;
-                switch (_sectionName[Position])
-                {
-                    case '*':
+                case '*':
+                    {
+                        int nextPos = Position + 1;
+                        if (nextPos < _sectionName.Length &&
+                            _sectionName[nextPos] == '*')
                         {
-                            int nextPos = Position + 1;
-                            if (nextPos < _sectionName.Length &&
-                                _sectionName[nextPos] == '*')
-                            {
-                                Position += 2;
-                                return TokenKind.StarStar;
-                            }
-                            else
-                            {
-                                Position++;
-                                return TokenKind.Star;
-                            }
+                            Position += 2;
+                            return TokenKind.StarStar;
                         }
+                        else
+                        {
+                            Position++;
+                            return TokenKind.Star;
+                        }
+                    }
 
-                    case '?':
-                        Position++;
-                        return TokenKind.Question;
+                case '?':
+                    Position++;
+                    return TokenKind.Question;
 
-                    case '{':
-                        Position++;
-                        return TokenKind.OpenCurly;
+                case '{':
+                    Position++;
+                    return TokenKind.OpenCurly;
 
-                    case ',':
-                        Position++;
-                        return TokenKind.Comma;
+                case ',':
+                    Position++;
+                    return TokenKind.Comma;
 
-                    case '}':
-                        Position++;
-                        return TokenKind.CloseCurly;
+                case '}':
+                    Position++;
+                    return TokenKind.CloseCurly;
 
-                    case '[':
-                        Position++;
-                        return TokenKind.OpenBracket;
+                case '[':
+                    Position++;
+                    return TokenKind.OpenBracket;
 
-                    case '\\':
+                case '\\':
+                    {
+                        // Backslash escapes the next character
+                        Position++;
+                        if (IsDone)
                         {
-                            // Backslash escapes the next character
-                            Position++;
-                            if (IsDone)
-                            {
-                                return TokenKind.BadToken;
-                            }
-
-                            return TokenKind.SimpleCharacter;
+                            return TokenKind.BadToken;
                         }
 
-                    default:
-                        // Don't increment position, since caller needs to fetch the character
                         return TokenKind.SimpleCharacter;
-                }
+                    }
+
+                default:
+                    // Don't increment position, since caller needs to fetch the character
+                    return TokenKind.SimpleCharacter;
             }
+        }
 
-            internal char CurrentCharacter => _sectionName[Position];
+        internal char CurrentCharacter => _sectionName[Position];
 
-            /// <summary>
-            /// Call after getting <see cref="TokenKind.SimpleCharacter" /> from <see cref="Lex()" />
-            /// </summary>
-            internal char EatCurrentCharacter() => _sectionName[Position++];
+        /// <summary>
+        /// Call after getting <see cref="TokenKind.SimpleCharacter" /> from <see cref="Lex()" />
+        /// </summary>
+        internal char EatCurrentCharacter() => _sectionName[Position++];
 
-            /// <summary>
-            /// Returns false if there are no more characters in the lex stream.
-            /// Otherwise, produces the next character in the stream and returns true.
-            /// </summary>
-            internal bool TryEatCurrentCharacter(out char nextChar)
+        /// <summary>
+        /// Returns false if there are no more characters in the lex stream.
+        /// Otherwise, produces the next character in the stream and returns true.
+        /// </summary>
+        internal bool TryEatCurrentCharacter(out char nextChar)
+        {
+            if (IsDone)
             {
-                if (IsDone)
-                {
-                    nextChar = default;
-                    return false;
-                }
-                else
-                {
-                    nextChar = EatCurrentCharacter();
-                    return true;
-                }
+                nextChar = default;
+                return false;
             }
+            else
+            {
+                nextChar = EatCurrentCharacter();
+                return true;
+            }
+        }
 
-            internal char this[int position] => _sectionName[position];
+        internal char this[int position] => _sectionName[position];
 
-            /// <summary>
-            /// Returns the string representation of a decimal integer, or null if
-            /// the current lexeme is not an integer.
-            /// </summary>
-            internal string? TryLexNumber()
-            {
-                bool start = true;
-                var sb = new StringBuilder();
+        /// <summary>
+        /// Returns the string representation of a decimal integer, or null if
+        /// the current lexeme is not an integer.
+        /// </summary>
+        internal string? TryLexNumber()
+        {
+            bool start = true;
+            var sb = new StringBuilder();
 
-                while (!IsDone)
+            while (!IsDone)
+            {
+                char currentChar = CurrentCharacter;
+                if (start && currentChar == '-')
                 {
-                    char currentChar = CurrentCharacter;
-                    if (start && currentChar == '-')
-                    {
-                        Position++;
-                        sb.Append('-');
-                    }
-                    else if (char.IsDigit(currentChar))
-                    {
-                        Position++;
-                        sb.Append(currentChar);
-                    }
-                    else
-                    {
-                        break;
-                    }
-                    start = false;
+                    Position++;
+                    sb.Append('-');
                 }
-
-                var str = sb.ToString();
-                return str.Length == 0 || str == "-"
-                    ? null
-                    : str;
+                else if (char.IsDigit(currentChar))
+                {
+                    Position++;
+                    sb.Append(currentChar);
+                }
+                else
+                {
+                    break;
+                }
+                start = false;
             }
-        }
 
-        private enum TokenKind
-        {
-            BadToken,
-            SimpleCharacter,
-            Star,
-            StarStar,
-            Question,
-            OpenCurly,
-            CloseCurly,
-            Comma,
-            DoubleDot,
-            OpenBracket,
+            var str = sb.ToString();
+            return str.Length == 0 || str == "-"
+                ? null
+                : str;
         }
     }
+
+    private enum TokenKind
+    {
+        BadToken,
+        SimpleCharacter,
+        Star,
+        StarStar,
+        Question,
+        OpenCurly,
+        CloseCurly,
+        Comma,
+        DoubleDot,
+        OpenBracket,
+    }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
index da1ede9ec39..e7b895c495b 100644
--- a/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
+++ b/src/Build/BuildCheck/Infrastructure/EditorConfig/EditorConfigParser.cs
@@ -13,94 +13,93 @@
 using Microsoft.Build.Shared;
 using static Microsoft.Build.BuildCheck.Infrastructure.EditorConfig.EditorConfigGlobsMatcher;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure.EditorConfig
+namespace Microsoft.Build.BuildCheck.Infrastructure.EditorConfig;
+
+internal sealed class EditorConfigParser
 {
-    internal sealed class EditorConfigParser
-    {
-        private const string EditorconfigFile = ".editorconfig";
+    private const string EditorconfigFile = ".editorconfig";
 
-        /// <summary>
-        /// Cache layer of the parsed editor configs the key is the path to the .editorconfig file.
-        /// </summary>
-        private readonly ConcurrentDictionary<string, EditorConfigFile> _editorConfigFileCache = new ConcurrentDictionary<string, EditorConfigFile>(StringComparer.InvariantCultureIgnoreCase);
+    /// <summary>
+    /// Cache layer of the parsed editor configs the key is the path to the .editorconfig file.
+    /// </summary>
+    private readonly ConcurrentDictionary<string, EditorConfigFile> _editorConfigFileCache = new ConcurrentDictionary<string, EditorConfigFile>(StringComparer.InvariantCultureIgnoreCase);
 
-        internal Dictionary<string, string> Parse(string filePath)
-        {
-            var editorConfigs = DiscoverEditorConfigFiles(filePath);
-            return MergeEditorConfigFiles(editorConfigs, filePath);
-        }
+    internal Dictionary<string, string> Parse(string filePath)
+    {
+        var editorConfigs = DiscoverEditorConfigFiles(filePath);
+        return MergeEditorConfigFiles(editorConfigs, filePath);
+    }
 
-        /// <summary>
-        /// Fetches the list of EditorconfigFile ordered from the nearest to the filePath.
-        /// </summary>
-        /// <param name="filePath"></param>
-        internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
-        {
-            var editorConfigDataFromFilesList = new List<EditorConfigFile>();
+    /// <summary>
+    /// Fetches the list of EditorconfigFile ordered from the nearest to the filePath.
+    /// </summary>
+    /// <param name="filePath"></param>
+    internal List<EditorConfigFile> DiscoverEditorConfigFiles(string filePath)
+    {
+        var editorConfigDataFromFilesList = new List<EditorConfigFile>();
 
-            var directoryOfTheProject = Path.GetDirectoryName(filePath);
-            // The method will look for the file in parent directory if not found in current until found or the directory is root. 
-            var editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);
+        var directoryOfTheProject = Path.GetDirectoryName(filePath);
+        // The method will look for the file in parent directory if not found in current until found or the directory is root. 
+        var editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, directoryOfTheProject);
 
-            while (editorConfigFilePath != string.Empty)
+        while (editorConfigFilePath != string.Empty)
+        {
+            if (!_editorConfigFileCache.TryGetValue(editorConfigFilePath, out var editorConfig))
             {
-                if (!_editorConfigFileCache.TryGetValue(editorConfigFilePath, out var editorConfig))
+                using (FileStream stream = new FileStream(editorConfigFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
                 {
-                    using (FileStream stream = new FileStream(editorConfigFilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
-                    {
-                        using StreamReader sr = new StreamReader(editorConfigFilePath);
-                        var editorConfigfileContent = sr.ReadToEnd();
-                        editorConfig = EditorConfigFile.Parse(editorConfigfileContent);
-                        _editorConfigFileCache[editorConfigFilePath] = editorConfig;
-                    }
+                    using StreamReader sr = new StreamReader(editorConfigFilePath);
+                    var editorConfigfileContent = sr.ReadToEnd();
+                    editorConfig = EditorConfigFile.Parse(editorConfigfileContent);
+                    _editorConfigFileCache[editorConfigFilePath] = editorConfig;
                 }
+            }
 
-                editorConfigDataFromFilesList.Add(editorConfig);
+            editorConfigDataFromFilesList.Add(editorConfig);
 
-                if (editorConfig.IsRoot)
-                {
-                    break;
-                }
-                else
-                {
-                    // search in upper directory
-                    editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, Path.GetDirectoryName(Path.GetDirectoryName(editorConfigFilePath)));
-                }
+            if (editorConfig.IsRoot)
+            {
+                break;
+            }
+            else
+            {
+                // search in upper directory
+                editorConfigFilePath = FileUtilities.GetPathOfFileAbove(EditorconfigFile, Path.GetDirectoryName(Path.GetDirectoryName(editorConfigFilePath)));
             }
-
-            return editorConfigDataFromFilesList;
         }
 
-        /// <summary>
-        /// Retrieves the config dictionary from the sections that matched the filePath. 
-        /// </summary>
-        /// <param name="editorConfigFiles"></param>
-        /// <param name="filePath"></param>
-        internal Dictionary<string, string> MergeEditorConfigFiles(List<EditorConfigFile> editorConfigFiles, string filePath)
-        {
-            var resultingDictionary = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
+        return editorConfigDataFromFilesList;
+    }
+
+    /// <summary>
+    /// Retrieves the config dictionary from the sections that matched the filePath. 
+    /// </summary>
+    /// <param name="editorConfigFiles"></param>
+    /// <param name="filePath"></param>
+    internal Dictionary<string, string> MergeEditorConfigFiles(List<EditorConfigFile> editorConfigFiles, string filePath)
+    {
+        var resultingDictionary = new Dictionary<string, string>(StringComparer.InvariantCultureIgnoreCase);
 
-            for (int i = editorConfigFiles.Count - 1; i >= 0; i--)
+        for (int i = editorConfigFiles.Count - 1; i >= 0; i--)
+        {
+            foreach (var section in editorConfigFiles[i].NamedSections)
             {
-                foreach (var section in editorConfigFiles[i].NamedSections)
+                SectionNameMatcher? sectionNameMatcher = TryCreateSectionNameMatcher(section.Name);
+                if (sectionNameMatcher != null)
                 {
-                    SectionNameMatcher? sectionNameMatcher = TryCreateSectionNameMatcher(section.Name);
-                    if (sectionNameMatcher != null)
+                    if (sectionNameMatcher.Value.IsMatch(NormalizeWithForwardSlash(filePath)))
                     {
-                        if (sectionNameMatcher.Value.IsMatch(NormalizeWithForwardSlash(filePath)))
+                        foreach (var property in section.Properties)
                         {
-                            foreach (var property in section.Properties)
-                            {
-                                resultingDictionary[property.Key] = property.Value;
-                            }
+                            resultingDictionary[property.Key] = property.Value;
                         }
                     }
                 }
             }
-            
-            return resultingDictionary;
         }
-
-        internal static string NormalizeWithForwardSlash(string p) => Path.DirectorySeparatorChar == '/' ? p : p.Replace(Path.DirectorySeparatorChar, '/');
+        
+        return resultingDictionary;
     }
+
+    internal static string NormalizeWithForwardSlash(string p) => Path.DirectorySeparatorChar == '/' ? p : p.Replace(Path.DirectorySeparatorChar, '/');
 }
