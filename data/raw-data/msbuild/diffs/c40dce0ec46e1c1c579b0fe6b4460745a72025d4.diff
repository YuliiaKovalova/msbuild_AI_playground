diff --git a/.opt-prof.yml b/.opt-prof.yml
new file mode 100644
index 00000000000..35a5a5382d8
--- /dev/null
+++ b/.opt-prof.yml
@@ -0,0 +1,84 @@
+# Runs OptProf for MSBuild binaries based on an insertion build
+
+trigger: none # Prevents this pipeline from triggering on check-ins
+pr: none # don't run this on PR as well, this should only trigger off on MSBuild runs
+schedules:
+  - cron: "0 9 * * Wed,Sat"
+    displayName: Weekly OptProf Run
+    branches:
+      include:
+      - main
+    always: true
+
+resources:
+  pipelines:
+  - pipeline: ComponentBuildUnderTest
+    source: MSBuild\MSBuild # The name of the pipeline that produces the artifact
+    trigger:
+      branches:
+        - vs*
+  - pipeline: DartLab
+    project: DevDiv
+    source: DartLab
+    branch: main
+  - pipeline: DartLab.OptProf
+    source: DartLab.OptProf
+    branch: main
+  repositories:
+  - repository: DartLabTemplates
+    type: git
+    name: DartLab.Templates
+    ref: refs/heads/main
+  - repository: DartLabOptProfTemplates
+    type: git
+    name: DartLab.OptProf
+    ref: refs/heads/main
+
+stages:
+- template: \templates\stages\visual-studio\single-runsettings.yml@DartLabOptProfTemplates
+  parameters:
+    ##### Required #####
+    runSettingsURI: $(Pipeline.Workspace)\ComponentBuildUnderTest\VSSetup\Insertion\OptProf\Training.runsettings
+    visualStudioBootstrapperURI: $(VisualStudio.InstallationUnderTest.BootstrapperURL)
+    ##### Optional #####
+    name: OptProfProfilingWorkflow
+    displayName: OptProf Profiling Workflow
+    optOptimizationInputsDropName: $(OptimizationInputsDropName)
+    testLabPoolName: VS-Platform # The test lab pool to run your tests in
+    testMachineImageName: Windows-10-Enterprise-20H2
+    visualStudioSigning: Test
+    variables:
+    - name: branchName # The branch in the VS repo the bootstrapper was based on
+      value: $[replace(variables['resources.pipeline.ComponentBuildUnderTest.sourceBranch'],'refs/heads/','')]
+    - name: OptimizationInputsDropName # The naming convention of the OptimizationInputsDrop
+      value: OptimizationData/DotNet-msbuild-Trusted/$(branchName)/$(resources.pipeline.ComponentBuildUnderTest.runName)/$(Build.BuildId)/$(System.StageAttempt)
+    ##### Step Hooks #####
+    preTestMachineConfigurationStepList:
+    - download: ComponentBuildUnderTest
+      artifact: MicroBuildOutputs
+      patterns: '**\BootstrapperInfo.json'
+      displayName: Download Bootstrapper Information
+    - download: ComponentBuildUnderTest
+      artifact: VSSetup
+      patterns: '**\*.runsettings'
+      displayName: Download OptProf Information
+    - powershell: |
+        try {
+          $bootstrapperInfoJson = Get-Content -Raw -Path '$(Pipeline.Workspace)\ComponentBuildUnderTest\MicroBuildOutputs\BootstrapperInfo.json' | ConvertFrom-Json
+          $vsBranch = $bootstrapperInfoJson[0].VSBranch
+          Write-Host "VSBootstrapperBranch: $vsBranch"
+          Set-AzurePipelinesVariable 'VSBootstrapperBranch' $vsBranch
+        }        
+        catch {
+          Write-Host $_
+          Write-Error "Failed to set VSBootstrapperBranch pipeline variable"
+          throw
+        }
+      displayName: Set 'VSBootstrapperBranch' variable
+    - task: PowerShell@2
+      displayName: Set 'VisualStudio.InstallationUnderTest.BootstrapperURL' variable
+      inputs:
+        filePath: $(DartLab.Path)\Scripts\VisualStudio\Bootstrapper\Get-BootstrapperURL.ps1
+        arguments: -BootstrapperInfoJsonURI '$(Pipeline.Workspace)\ComponentBuildUnderTest\MicroBuildOutputs\BootstrapperInfo.json' -VSBranch '$(VSBootstrapperBranch)' -OutVariableName 'VisualStudio.InstallationUnderTest.BootstrapperURL'
+    preDeployAndRunTestsStepList:
+    - download: ComponentBuildUnderTest
\ No newline at end of file
diff --git a/.vsconfig b/.vsconfig
index e31519321f2..a3598fb5a7f 100644
--- a/.vsconfig
+++ b/.vsconfig
@@ -5,7 +5,6 @@
     "Microsoft.Net.Component.4.7.2.SDK",
     "Microsoft.Net.Component.4.TargetingPack",
     "Microsoft.Net.Component.4.7.2.TargetingPack",
-    "Microsoft.Net.Core.Component.SDK.2.1",
     "Microsoft.VisualStudio.Workload.ManagedDesktop",
     "Microsoft.Net.Component.3.5.DeveloperTools",
     "Microsoft.VisualStudio.Workload.NetCoreTools"
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 209e287bb6d..fe3485b6f5c 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -23,12 +23,9 @@ variables:
   - name: SourceBranch
     value: $(IbcSourceBranchName)
   # If we're not on a vs* branch, use main as our optprof collection branch
-  # NOTE: the code is temporarily fixed. For the branches that should use opt-prof from the main branch we should use the latest working Opt-Prof 20220901.6-001 collected from main 20220901.6.
   - ${{ if not(startsWith(variables['Build.SourceBranch'], 'refs/heads/vs')) }}:
-    - name: OptProfDrop
-      value: 'OptimizationData/DotNet-msbuild-Trusted/main/20220901.6/1387996/1'
     - name: SourceBranch
-      value: ''
+      value: main
   # if OptProfDropName is set as a parameter, set OptProfDrop to the parameter and unset SourceBranch
   - ${{ if ne(parameters.OptProfDropName, 'default') }}:
     - name: OptProfDrop
@@ -165,6 +162,7 @@ stages:
                   -task VisualStudio.BuildIbcTrainingSettings
                   /p:VisualStudioDropName=$(VisualStudio.DropName)
                   /p:BootstrapperInfoPath=$(Build.StagingDirectory)\MicroBuild\Output\BootstrapperInfo.json
+                  /p:VisualStudioIbcTrainingSettingsPath=$(Build.SourcesDirectory)\eng\config\OptProf.runsettings
       displayName: 'OptProf - Build IBC training settings'
       condition: succeeded()
 
diff --git a/MSBuild.sln b/MSBuild.sln
index 75b985cb7be..01e91980f6a 100644
--- a/MSBuild.sln
+++ b/MSBuild.sln
@@ -6,6 +6,7 @@ MinimumVisualStudioVersion = 17.0.31903.59
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{4900B3B8-4310-4D5B-B1F7-2FDF9199765F}"
 	ProjectSection(SolutionItems) = preProject
 		NuGet.Config = NuGet.Config
+		testenvironments.json = testenvironments.json
 		src\Shared\UnitTests\xunit.runner.json = src\Shared\UnitTests\xunit.runner.json
 	EndProjectSection
 EndProject
diff --git a/README.md b/README.md
index 690fc1608a1..28ed1ca7fcf 100644
--- a/README.md
+++ b/README.md
@@ -6,30 +6,6 @@ For more information on MSBuild, see the [MSBuild documentation](https://docs.mi
 
 The [changelog](documentation/Changelog.md) has detailed information about changes made in different releases.
 
-### Build Status
-
-The current development branch is `main`. Changes in `main` will go into a future update of MSBuild, which will release with Visual Studio 17.5 and a corresponding version of the .NET Core SDK.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=main)
-
-We have forked for MSBuild 17.4 in the branch [`vs17.4`](https://github.com/Microsoft/msbuild/tree/vs17.4). Changes to that branch need special approval.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.4)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.4)
-
-17.2 builds from the branch [`vs17.2`](https://github.com/Microsoft/msbuild/tree/vs17.2). Only high-priority bugfixes will be considered for servicing 17.2.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.2)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.2)
-
-17.0 builds from the branch [`vs17.0`](https://github.com/Microsoft/msbuild/tree/vs17.0). Only high-priority bugfixes will be considered for servicing 17.0.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.0)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.0)
-
-16.11 builds from the branch [`vs16.11`](https://github.com/Microsoft/msbuild/tree/vs16.11). Only high-priority bugfixes will be considered for servicing 16.11.
-
-[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.11)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs16.11)
-
-MSBuild 15.9 builds from the branch [`vs15.9`](https://github.com/dotnet/msbuild/tree/vs15.9). Only very-high-priority bugfixes will be considered for servicing 15.9.
-
 ## Building
 
 ### Building MSBuild with Visual Studio 2022 on Windows
@@ -48,9 +24,6 @@ To get started on **Visual Studio 2022**:
 5. Run `.\build.cmd` from the root of the repo to build the code. This also restores packages needed to open the projects in Visual Studio.
 6. Open `MSBuild.sln` or `MSBuild.Dev.slnf` in Visual Studio 2022.
 
-Note: To create a usable MSBuild with your changes, run `.\build.cmd /p:CreateBootstrap=true`.
-To build release, add `-c Release`: `.\build.cmd -c Release /p:CreateBootstrap=true`.
-
 This newly-built MSBuild will be located at `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe`. It may not work for all scenarios, including C++ builds.
 
 ### Building MSBuild in Unix (Mac & Linux)
diff --git a/documentation/ProjectReference-Protocol.md b/documentation/ProjectReference-Protocol.md
index 9dc2f404fa2..f2e6b6e4753 100644
--- a/documentation/ProjectReference-Protocol.md
+++ b/documentation/ProjectReference-Protocol.md
@@ -138,13 +138,12 @@ In addition to the above task and target, `.vcxproj` and `.nativeproj` projects
 This means most projects will see an evaluation with no global properties defined, unless set by the user.
 
 ### How To Opt In
-First, set the properties `EnableDynamicPlatformResolution` and `DisableTransitiveProjectReferences` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:
+First, set the property `EnableDynamicPlatformResolution` to `true` for **every project** in your solution. The easiest way to do this is by creating a `Directory.Build.props` file and placing it at the root of your project directory:
 
 ```xml
 <Project>
   <PropertyGroup>
     <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
-    <DisableTransitiveProjectReferences>true</DisableTransitiveProjectReferences>
   </PropertyGroup>
 </Project>
 ```
diff --git a/documentation/fancylogger/Opt-In-Mechanism.md b/documentation/fancylogger/Opt-In-Mechanism.md
new file mode 100644
index 00000000000..d0df44b69dd
--- /dev/null
+++ b/documentation/fancylogger/Opt-In-Mechanism.md
@@ -0,0 +1,21 @@
+# When should we use FancyLogger
+
+The FancyLogger presents the user with the build's most relevant information at the time, automatically hiding all the information that is no longer relevant (as to prevent huge log outputs). However, many users might find this not very useful (or even counterproductive) such as those using a terminal without proper ANSI support or when redirecting the output to a file. For that reason, the users must be able to turn this feature on/off at will.
+
+# Proposal
+Using the `/fancylogger` or `/flg` command line switches, users are able to opt-in and use the FancyLogger, EXCEPT when:
+- The terminal does not support ANSI codes or color
+    - [ ] Detect if terminal does not support ANSI codes or color
+ - Output is redirected to a file or pipe
+    - [x] Detect if terminal output is redirected
+
+For early development stages, an environment variable `$MSBUILDFANCYLOGGER` should be enabled to prevent accidental access to an unfinished feature. 
+
+In cases where the FancyLogger should not be enabled, the default ConsoleLogger should be used instead.
+
+# Considerations
+## Should FancyLogger be used with other loggers (eg, BinaryLogger, FileLogger, custom loggers)?
+FancyLogger should only replace the current ConsoleLogger for the aforementioned cases. Additionally, other loggers can be used in conjunction. 
+
+## Should output be ignored with the `/noconsolelogger` flag enabled?
+FancyLogger serves as a replacement for ConsoleLogger, so it should behave similarly. When attaching the `/noconsolelogger` flag, it should not output anything.
\ No newline at end of file
diff --git a/documentation/wiki/Binary-Log.md b/documentation/wiki/Binary-Log.md
index caaf9d52580..550ec068398 100644
--- a/documentation/wiki/Binary-Log.md
+++ b/documentation/wiki/Binary-Log.md
@@ -9,7 +9,7 @@ Goals:
  * structure (preserves the exact build event args that can later be replayed to reconstruct the exact events and information as if a real build was running). File logs erase structure and are harder to parse (especially for multicore /m builds). Build analyzer tools are conceivable that could benefit from the structure in a binary log. An API is available to load and query binary logs.
  * optionally collect the project files (and all imported targets files) used during the build. This can help analyzing the logs and even view preprocessed source for all projects (with all imported projects inlined).
 
-See http://msbuildlog.com for more information.
+See https://msbuildlog.com/ for more information.
 
 # Creating a binary log during a build
 
@@ -62,7 +62,7 @@ Once you have the `StructuredLogger.dll` on disk you can pass it to MSBuild like
 # Using MSBuild Structured Log Viewer
 
 You can use the MSBuild Structured Log Viewer tool to view `.binlog` files:
-http://msbuildlog.com
+https://msbuildlog.com/
 
 # Collecting binary logs from Visual Studio builds
 
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
index 7df20c12b5f..6410b01cb11 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md
@@ -6,17 +6,21 @@ MSBuild can be successfully built on Windows, OS X 10.13, Ubuntu 14.04, and Ubun
 
 `build.cmd -msbuildEngine dotnet`
 
+## Tests
+
+Follow [Running Unit Tests](Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md#running-unit-tests) section of the developer guide chapter for .NET Framework
+
 # Unix
 
 ## The easy way
 
-Install the latest .NET Core SDK from http://dot.net/core. That will ensure all prerequisites for our build are met.
+Install the latest .NET SDK from https://dotnet.microsoft.com/download. That will ensure all prerequisites for our build are met.
 
 ## Manually installing required packages for OSX & Ubuntu
 
-[.NET Core prerequisites](https://github.com/dotnet/core/blob/master/Documentation/prereqs.md).
+[.NET Core prerequisites](https://github.com/dotnet/core/blob/main/Documentation/prereqs.md).
 
-* *OpenSSL*: MSBuild uses the .Net CLI during its build process. The CLI requires a recent OpenSSL library available in `/usr/lib`. This can be downloaded using [brew](http://brew.sh/) on OS X (`brew install openssl`) and apt-get (`apt-get install openssl`) on Ubuntu, or [building from source](https://wiki.openssl.org/index.php/Compilation_and_Installation#Mac). If you use a different package manager and see an error that says `Unable to load DLL 'System.Security.Cryptography.Native'`, `dotnet` may be looking in the wrong place for the library.
+* *OpenSSL*: MSBuild uses the .Net CLI during its build process. The CLI requires a recent OpenSSL library available in `/usr/lib`. This can be downloaded using [brew](https://brew.sh/) on OS X (`brew install openssl`) and apt-get (`apt-get install openssl`) on Ubuntu, or [building from source](https://wiki.openssl.org/index.php/Compilation_and_Installation#Mac). If you use a different package manager and see an error that says `Unable to load DLL 'System.Security.Cryptography.Native'`, `dotnet` may be looking in the wrong place for the library.
 
 ## Build
 
@@ -28,21 +32,21 @@ If you encounter errors, see [Something's wrong in my build](Something's-wrong-i
 
 `./build.sh --test`
 
-## Getting .Net Core MSBuild binaries without building the code
+# Getting .Net Core MSBuild binaries without building the code
 
 The best way to get .NET Core MSBuild is by installing the [.NET Core SDK](https://github.com/dotnet/core-sdk), which redistributes us. This will get you the latest released version of MSBuild for .NET Core. After installing it, you can use MSBuild through `dotnet build` or by manual invocation of the `MSBuild.dll` in the dotnet distribution.
 
-## Debugging
+# Debugging
 
-### Wait in Main
+## Wait in Main
 
 Set the environment variable `MSBUILDDEBUGONSTART` to `2`, then attach a debugger to the process manually after it starts.
 
-### Using the repository binaries to perform builds
+## Using the repository binaries to perform builds
 
-To build projects using the MSBuild binaries from the repository, you first need to do a build (command: `build.cmd /p:CreateBootstrap=true`) which produces a bootstrap directory mimicking a Visual Studio (full framework flavor) or dotnet CLI (.net core flavor) installation.
+To build projects using the MSBuild binaries from the repository, you first need to do a build (command: `build.cmd`) which produces a bootstrap directory mimicking a Visual Studio (full framework flavor) or dotnet CLI (.net core flavor) installation.
 
-Now, just point `dotnet ./artifacts/bin/bootstrap/netcoreapp2.1/MSBuild/MSBuild.dll` at a project file.
+Now, just point `dotnet ./artifacts/bin/bootstrap/<TARGET_FRAMEWORK>/MSBuild/MSBuild.dll` at a project file. (Change <TARGET_FRAMEWORK> to current target framework, for example net7.0, net8.0) 
 
 Alternatively, if you want to test the msbuild binaries in a more realistic environment, you can overwrite the dotnet CLI msbuild binaries (found under a path like `~/dotnet/sdk/3.0.100-alpha1-009428/`) with the just-built MSBuild . You might have to kill existing `dotnet` processes before doing this. You can use [`Deploy-MSBuild.ps1 -runtime Core`](../Deploy-MSBuild.md#.NET-(Core)-SDK) to do the copy. Then, (using the previous dotnet example directory) just point `~/dotnet/dotnet build` at a project file.
 
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
index 20c962598de..a71155be41e 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md
@@ -4,7 +4,7 @@ These instructions refer to working with the `master` branch.
 
 ## Required Software
 
-**Latest Microsoft Visual Studio 2022**: You can download the Visual Studio Community edition from [https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx](https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx).
+**Latest Microsoft Visual Studio 2022**: You can download the Visual Studio Community edition from [visualstudio.microsoft.com/vs/community/](https://visualstudio.microsoft.com/vs/community/).
 
 All command lines should be executed from a Visual Studio developer command prompt.
 
@@ -25,22 +25,45 @@ To run the unit tests from Visual Studio:
 
 To build MSBuild and run all unit tests from the command line, use `.\build.cmd -test`.
 
+Some tests are creating symlinks to test associated functionality - in order for them to succeed you have two options:
+* Enable [Development Mode](https://learn.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development) on your machine.
+* Or run those tests elevated
+
 To mimic our CI job use `eng\CIBuild.cmd`. Be aware that this command may delete your local NuGet cache.
 
 The CI does two builds. In the second build, it uses the binaries from the first build to build the repository again.
 
+### Unit testing inside virtualized environment 
+
+In case you develop on Windows OS, but need to run/debug tests on other platforms - unit tests can be run and debugged on a local virtualized environment supported by [Visual Studio Remote Testing](https://learn.microsoft.com/en-us/visualstudio/test/remote-testing?view=vs-2022).
+Initial configurations have been added for `WSL` and net 7.0 linux docker via [`testenvironments.json`](../../testenvironments.json).
+Upon opening the Tests Explorer the advanced environments are available in the GUI: 
+
+![TestExplorrerEnvironments](TestExplorerEnvironments.png)
+
+This readme will not discuss definitive list of details for proper setup of the environments instead we defer reader to the following information sources and warn about particular gotchas:
+
+ * WSL runs
+   * Install [WSL](https://learn.microsoft.com/en-us/windows/wsl/about).
+   * Install the [distribution](https://aka.ms/wslstore) of your choice.
+   * [Install .NET Runtime](https://learn.microsoft.com/en-us/dotnet/core/install/linux-ubuntu)
+ * Docker runs
+   * Install [Docker Desktop](https://www.docker.com/products/docker-desktop/)
+   * First run of docker scenario might need elevation ([Test project does not reference any .NET NuGet adapter](https://developercommunity.visualstudio.com/t/test-project-does-not-reference-any-net-nuget-adap/1311698) error)  
+ * Third party test runners might not support this feature. Use [Visual Studio Test Explorer](https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer).
+
 ## Contributing
 
-Please see [Contributing Code](https://github.com/dotnet/msbuild/blob/master/documentation/wiki/Contributing-Code.md) for details on contributing changes back to the code. Please read this carefully and engage with us early to ensure work is not wasted.
+Please see [Contributing Code](https://github.com/dotnet/msbuild/blob/main/documentation/wiki/Contributing-Code.md) for details on contributing changes back to the code. Please read this carefully and engage with us early to ensure work is not wasted.
 
 ## Walkthroughs
 
 ### Using the repository binaries to perform builds
 
 To build projects using the MSBuild binaries from the repository, you first need to do a build which produces
-a "bootstrap" directory. The "bootstrap" directory mimics a Visual Studio installation by aquiring additional
+a "bootstrap" directory. The "bootstrap" directory mimics a Visual Studio installation by acquiring additional
 dependencies (Roslyn compilers, NuGet, etc.) from packages or from your local machine (e.g. props/targets
-from Visual Studio). To produce a bootstrap build, run `.\build.cmd /p:CreateBootstrap=true` from the root of your enlistment.
+from Visual Studio). This will happen by default when running `.\build.cmd`. The bootstrap can be disabled by running `.\build.cmd /p:CreateBootstrap=false`.
 
 Now, just point `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe` at a project file.
 
@@ -49,7 +72,7 @@ Now, just point `artifacts\bin\bootstrap\net472\MSBuild\Current\Bin\MSBuild.exe`
 Sometimes it's useful to patch your copy of Visual Studio in order to test or debug your local MSBuild changes from Visual Studio. You can use the [Deploy-MSBuild script](../Deploy-MSBuild.md) for copying your locally built MSBuild binaries over the MSBuild binaries shipping with Visual Studio. Example usage:
 ```
 # bootstrap build
-.\build.cmd /p:CreateBootstrap=true
+.\build.cmd
 
 # copy the bootstrap build output over the MSBuild binaries in Visual Studio
 .\scripts\Deploy-MSBuild.ps1 -destination "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin"
@@ -74,4 +97,4 @@ Like with breakpoints, you can filter which processes emit the logs by setting `
 
 ##### Dumping specific logs:
 - scheduler state: set `MSBUILDDEBUGSCHEDULER` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
-- node communication: set `MSBUILDDEBUGCOMM` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
\ No newline at end of file
+- node communication: set `MSBUILDDEBUGCOMM` to 1; set `MSBUILDDEBUGPATH` to a directory to dump the scheduling state files.
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md b/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
index 859cf202824..c78f554b272 100644
--- a/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
+++ b/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
@@ -6,7 +6,7 @@ Mono maintains a fork of msbuild (for now) at `https://github.com/mono/msbuild/`
 
 **Required packages for OSX & Ubuntu**
 
-MSBuild requires a stable version of [Mono](http://www.mono-project.com/download/) to build itself.
+MSBuild requires a stable version of [Mono](https://www.mono-project.com/download/stable/) to build itself.
 
 ## Build process ##
 
@@ -23,9 +23,9 @@ If you encounter errors, see [Something's wrong in my build](Something's-wrong-i
 `./install-mono-prefix.sh </your/mono/prefix>`
 
 ## Getting Mono MSBuild binaries without building the code ##
-The best way to get Mono MSBuild for OSX/macOS is to get the official [Mono package](http://www.mono-project.com/download/#download-mac). After installing it, you can run `msbuild`.
+The best way to get Mono MSBuild for OSX/macOS is to get the official [Mono package](https://www.mono-project.com/download/stable/#download-mac). After installing it, you can run `msbuild`.
 <br/>
-For Linux, you can install mono and msbuild from [here](http://www.mono-project.com/download/#download-lin).
+For Linux, you can install mono and msbuild from [here](https://www.mono-project.com/download/stable/#download-lin).
 
 ## Debugging
 
diff --git a/documentation/wiki/ChangeWaves-Dev.md b/documentation/wiki/ChangeWaves-Dev.md
index bb4f143ac4c..de8d8e11725 100644
--- a/documentation/wiki/ChangeWaves-Dev.md
+++ b/documentation/wiki/ChangeWaves-Dev.md
@@ -51,7 +51,7 @@ Surround your feature with the following:
 
 If you need to condition a Task or Target, use the built in `AreFeaturesEnabled` function.
 ```xml
-<Target Name="SomeRiskyChange" Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))"">
+<Target Name="SomeRiskyChange" Condition="$([MSBuild]::AreFeaturesEnabled('17.4'))">
 <!-- Where '17.4' is the change wave assigned to your feature. -->
 ```
 
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 29b2352c349..5d3feeccf3a 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -24,7 +24,9 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 ## Current Rotation of Change Waves
 
 ### 17.6
+- [Parse invalid property under target](https://github.com/dotnet/msbuild/pull/8190)
 - [Eliminate project string cache](https://github.com/dotnet/msbuild/pull/7965)
+- [Log an error when no provided search path for an import exists](https://github.com/dotnet/msbuild/pull/8095)
 
 ### 17.4
 - [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
@@ -33,19 +35,6 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Throw warning indicating invalid project types](https://github.com/dotnet/msbuild/pull/7708)
 - [MSBuild server](https://github.com/dotnet/msbuild/pull/7634)
 
-### 17.0
-- [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
-- [Don't compile globbing regexes on .NET Framework](https://github.com/dotnet/msbuild/pull/6632)
-- [Default to transitively copying content items](https://github.com/dotnet/msbuild/pull/6622)
-- [Reference assemblies are now no longer placed in the `bin` directory by default](https://github.com/dotnet/msbuild/pull/6560) (reverted [here](https://github.com/dotnet/msbuild/pull/6718) and brought back [here](https://github.com/dotnet/msbuild/pull/7075))
-- [Improve debugging experience: add global switch MSBuildDebugEngine; Inject binary logger from BuildManager; print static graph as .dot file](https://github.com/dotnet/msbuild/pull/6639)
-- [Fix deadlock in BuildManager vs LoggingService](https://github.com/dotnet/msbuild/pull/6837)
-- [Optimize diag level for file logger and console logger](https://github.com/dotnet/msbuild/pull/7026)
-- [Optimized immutable files up to date checks](https://github.com/dotnet/msbuild/pull/6974)
-- [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
-- [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
-- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
-
 ## Change Waves No Longer In Rotation
 ### 16.8
 - [Enable NoWarn](https://github.com/dotnet/msbuild/pull/5671)
@@ -58,3 +47,16 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Allow users that have certain special characters in their username to build successfully when using exec](https://github.com/dotnet/msbuild/pull/6223)
 - [Fail restore operations when an SDK is unresolveable](https://github.com/dotnet/msbuild/pull/6430)
 - [Optimize glob evaluation](https://github.com/dotnet/msbuild/pull/6151)
+
+### 17.0
+- [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
+- [Don't compile globbing regexes on .NET Framework](https://github.com/dotnet/msbuild/pull/6632)
+- [Default to transitively copying content items](https://github.com/dotnet/msbuild/pull/6622)
+- [Reference assemblies are now no longer placed in the `bin` directory by default](https://github.com/dotnet/msbuild/pull/6560) (reverted [here](https://github.com/dotnet/msbuild/pull/6718) and brought back [here](https://github.com/dotnet/msbuild/pull/7075))
+- [Improve debugging experience: add global switch MSBuildDebugEngine; Inject binary logger from BuildManager; print static graph as .dot file](https://github.com/dotnet/msbuild/pull/6639)
+- [Fix deadlock in BuildManager vs LoggingService](https://github.com/dotnet/msbuild/pull/6837)
+- [Optimize diag level for file logger and console logger](https://github.com/dotnet/msbuild/pull/7026)
+- [Optimized immutable files up to date checks](https://github.com/dotnet/msbuild/pull/6974)
+- [Add Microsoft.IO.Redist for directory enumeration](https://github.com/dotnet/msbuild/pull/6771)
+- [Process-wide caching of ToolsetConfigurationSection](https://github.com/dotnet/msbuild/pull/6832)
+- [Normalize RAR output paths](https://github.com/dotnet/msbuild/pull/6533)
\ No newline at end of file
diff --git a/documentation/wiki/Contributing-Code.md b/documentation/wiki/Contributing-Code.md
index 71db1a4961d..690cf797972 100644
--- a/documentation/wiki/Contributing-Code.md
+++ b/documentation/wiki/Contributing-Code.md
@@ -7,7 +7,7 @@ Because our focus right now is on maintaining backwards compatibility, the team
 - Only contributions referencing an approved Issue will be accepted.
 - Pull requests that do not merge easily with the tip of the master branch will be declined. The author will be asked to merge with tip and submit a new pull request.
 - Submissions must meet functional and performance expectations, including scenarios for which the team doesn't yet have open source tests. This means you may be asked to fix and resubmit your pull request against a new open test case if it fails one of these tests.
-- Submissions must follow the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/coding-style.md)
+- Submissions must follow the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)
 
 When you are ready to proceed with making a change, get set up to [build](Home.md "See 'Building Testing and Debugging'") the code and familiarize yourself with our workflow and our coding conventions. These two blogs posts on contributing code to open source projects are good too: [Open Source Contribution Etiquette by Miguel de Icaza](https://tirania.org/blog/archive/2010/Dec-31.html) and [Don’t “Push” Your Pull Requests by Ilya Grigorik](https://www.igvita.com/2011/12/19/dont-push-your-pull-requests/).
 
@@ -33,4 +33,4 @@ Please follow these guidelines when creating new issues in the issue tracker:
 - Subscribe to notifications for the created issue in case there are any follow up questions.
 
 ### Coding Conventions
-- Use the coding style outlined in the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/coding-style.md)
+- Use the coding style outlined in the [.NET Runtime Coding Guidelines](https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/coding-style.md)
diff --git a/documentation/wiki/Contributing-Tasks.md b/documentation/wiki/Contributing-Tasks.md
index 23327755575..c77aaa7cd02 100644
--- a/documentation/wiki/Contributing-Tasks.md
+++ b/documentation/wiki/Contributing-Tasks.md
@@ -13,15 +13,15 @@ The following requirements are in place for contributed tasks:
 3. The task must have unit tests in place to prevent regressions.
 
 ## Developing a new Task
-Review the existing documentation on [Task Writing](https://docs.microsoft.com/en-us/visualstudio/msbuild/task-writing) to learn about the fundamentals.  You can also looking at existing tasks in the [Microsoft.Build.Tasks.Core assembly](https://github.com/dotnet/msbuild/tree/master/src/Tasks) for a great starting point.
+Review the existing documentation on [Task Writing](https://learn.microsoft.com/visualstudio/msbuild/task-writing) to learn about the fundamentals.  You can also looking at existing tasks in the [Microsoft.Build.Tasks.Core assembly](https://github.com/dotnet/msbuild/tree/main/src/Tasks) for a great starting point.
 
 Tasks are generally simple and should not require much effort to develop.  If you find a task becoming very complicated, consider breaking it up into smaller tasks which can be run together in a target.
 
 ## Developing unit tests
-Contributed tasks must have unit tests in place to prove they work and to prevent regressions caused by other code changes.  There are a lot of examples in the [Microsoft.Build.Tasks.UnitTests](https://github.com/dotnet/msbuild/tree/master/src/Tasks.UnitTests) project.  Please provide a reasonable amount of test coverage so ensure the quality of the product.
+Contributed tasks must have unit tests in place to prove they work and to prevent regressions caused by other code changes.  There are a lot of examples in the [Microsoft.Build.Tasks.UnitTests](https://github.com/dotnet/msbuild/tree/main/src/Tasks.UnitTests) project.  Please provide a reasonable amount of test coverage so ensure the quality of the product.
 
 ## Documentation
-You can document the new task in the [visualstudio-docs](https://github.com/MicrosoftDocs/visualstudio-docs/tree/master/docs/msbuild) repository.  This helps users discover the new functionality.  The easiest way is to copy the documentation page for an existing task as a template.
+You can document the new task in the [visualstudio-docs](https://github.com/MicrosoftDocs/visualstudio-docs/tree/main/docs/msbuild) repository.  This helps users discover the new functionality.  The easiest way is to copy the documentation page for an existing task as a template.
 
 ## Ship schedule
 MSBuild ships regularly with Visual Studio.  It also is updated in Preview releases.  Once your contribution is merged, expect it to be available in the next release.
diff --git a/documentation/wiki/Localization.md b/documentation/wiki/Localization.md
index 4bf09bf0123..919d9f4a883 100644
--- a/documentation/wiki/Localization.md
+++ b/documentation/wiki/Localization.md
@@ -6,7 +6,7 @@
 - `Strings.shared.resx` is a shared resource and gets embedded into all msbuild dlls
 - each neutral resource has a directory named `xlf` besides it which contains its localized strings in .xlf format
 - there is one language per xlf
-- the logical name for a resource is: `<Assembly Name>.<Neutral Resx File Name>.resources`. In the ResourceManager this appears as `<Assembly Name>.<Neutral Resx File Name>` (without the trailing `.resources`). For example, the `Microsoft.Build` assembly uses the `Microsoft.Build.Strings.resources` [logical resource name](https://github.com/dotnet/msbuild/blob/master/src/XMakeBuildEngine/Microsoft.Build.csproj#L659) (the resource file is `Strings.resx`), and its corresponding [ResourceManager](https://github.com/dotnet/msbuild/blob/master/src/XMakeBuildEngine/Resources/AssemblyResources.cs#L116) uses `Microsoft.Build.Strings`.
+- the logical name for a resource is: `<Assembly Name>.<Neutral Resx File Name>.resources`. In the ResourceManager this appears as `<Assembly Name>.<Neutral Resx File Name>` (without the trailing `.resources`). For example, the `Microsoft.Build` assembly uses the `Microsoft.Build.Strings.resources` [logical resource name](https://github.com/dotnet/msbuild/blob/cc3db358d34ad4cd1ec0c67e17582d7ca2a15040/src/Build/Microsoft.Build.csproj#L792) (the resource file is `Strings.resx`), and its corresponding [ResourceManager](https://github.com/dotnet/msbuild/blob/518c041f4511a6bc23eb40703b69a94ea46c65fd/src/Build/Resources/AssemblyResources.cs#L118) uses `Microsoft.Build.Strings`.
 
 ## How to edit a resource
 
diff --git a/documentation/wiki/MSBuild-Resources.md b/documentation/wiki/MSBuild-Resources.md
index 4e3f64c3dc2..506e407258d 100644
--- a/documentation/wiki/MSBuild-Resources.md
+++ b/documentation/wiki/MSBuild-Resources.md
@@ -1,21 +1,21 @@
 # General Resources
- * [MSBuild Concepts](https://msdn.microsoft.com/en-us/library/dd637714.aspx)
- * [MSBuild Reserved and Well-Known Properties](https://msdn.microsoft.com/en-us/library/ms164309.aspx)
+ * [MSBuild Concepts](https://learn.microsoft.com/visualstudio/msbuild/msbuild-concepts)
+ * [MSBuild Reserved and Well-Known Properties](https://learn.microsoft.com/visualstudio/msbuild/msbuild-reserved-and-well-known-properties)
  * [MSBuild Tips & Tricks](MSBuild-Tips-&-Tricks.md)
  * [Target Maps](Target-Maps.md)
 
 # MSBuild Source Code
  * [https://github.com/dotnet/msbuild](https://github.com/dotnet/msbuild)
  * [https://source.dot.net](https://source.dot.net)
- * Use [http://referencesource.microsoft.com](http://referencesource.microsoft.com) or [http://source.roslyn.io](http://source.roslyn.io) to browse Microsoft MSBuild targets. Examples:
-   * search for "[_FindDependencies MSBuildProperty](http://referencesource.microsoft.com/#q=_FindDependencies%20MSBuildProperty)"
-   * find targets [http://referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences](http://referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences)
+ * Use [referencesource.microsoft.com](https://referencesource.microsoft.com) or [sourceroslyn.io/](https://sourceroslyn.io/) to browse Microsoft MSBuild targets. Examples:
+   * search for "[_FindDependencies MSBuildProperty](https://referencesource.microsoft.com/#q=_FindDependencies%20MSBuildProperty)"
+   * find targets [referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences](https://referencesource.microsoft.com/#MSBuildTarget=ResolveAssemblyReferences)
 
 # Tools
 **Note:** These are third party tools
- * [MSBuildStructuredLog](http://msbuildlog.com/)
+ * [MSBuildStructuredLog](https://msbuildlog.com/)
    * A log viewer that displays a structured representation of executed targets, tasks, property and item values.
- * [MSBuildExtensionPack](http://www.msbuildextensionpack.com)
+ * [MSBuildExtensionPack](https://github.com/mikefourie-zz/MSBuildExtensionPack) (also via [NuGet](https://www.nuget.org/packages/MSBuild.Extension.Pack))
    * Provides a large collection of MSBuild Tasks, MSBuild Loggers and MSBuild TaskFactories.
  * [MSBuilder](https://github.com/MobileEssentials/MSBuilder)
    * Reusable blocks of MSBuild helpers; MSBuilder's goal is to provide fine-grained nuget packages that can be installed when only a certain MSBuild extension (task, property, target) is needed.
@@ -34,13 +34,13 @@
    * Lets you build Visual Studio solutions and projects as well as any MSBuild file through a context menu without opening Visual Studio.
 
 # Books
- * [Inside the Microsoft Build Engine: Using MSBuild and Team Foundation Build (2nd Edition) by Sayed Hashimi, William Bartholomew](http://www.amazon.com/Inside-Microsoft-Build-Engine-Foundation/dp/0735645248)
- * [MSBuild Trickery: 99 Ways to Bend the Build Engine to Your Will, by Brian Kretzler](http://www.amazon.com/MSBuild-Trickery-Ways-Build-Engine/dp/061550907X)
+ * [Inside the Microsoft Build Engine: Using MSBuild and Team Foundation Build (2nd Edition) by Sayed Hashimi, William Bartholomew](https://www.amazon.com/Inside-Microsoft-Build-Engine-Foundation/dp/0735645248)
+ * [MSBuild Trickery: 99 Ways to Bend the Build Engine to Your Will, by Brian Kretzler](https://www.amazon.com/MSBuild-Trickery-Ways-Build-Engine/dp/061550907X)
 
 # Blogs
- * [https://blogs.msdn.microsoft.com/msbuild](https://blogs.msdn.microsoft.com/msbuild)
- * [Sayed Hashimi's blog http://sedodream.com](http://sedodream.com)
+ * [MSBuild Team Blog](https://learn.microsoft.com/archive/blogs/msbuild/) (archive)
+ * [Sayed Hashimi's blog at sedodream.com](http://sedodream.com)
  * [Mike Fourie's blog https://mikefourie.wordpress.com](https://mikefourie.wordpress.com)
 
 # MSBuild Assemblies
-![MSBuild Assemblies](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/MSBuildAssemblies.png)
+![MSBuild Assemblies](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/MSBuildAssemblies.png)
diff --git a/documentation/wiki/MSBuild-Tips-&-Tricks.md b/documentation/wiki/MSBuild-Tips-&-Tricks.md
index a66255a037e..3a833348b66 100644
--- a/documentation/wiki/MSBuild-Tips-&-Tricks.md
+++ b/documentation/wiki/MSBuild-Tips-&-Tricks.md
@@ -1,5 +1,5 @@
 # MSBuild Command-Line Switches
-See the [MSBuild Command-Line Reference](https://docs.microsoft.com/visualstudio/msbuild/msbuild-command-line-reference) for more information on switches.
+See the [MSBuild Command-Line Reference](https://learn.microsoft.com/visualstudio/msbuild/msbuild-command-line-reference) for more information on switches.
  * `MSBuild.exe -pp:<FILE>`
    * MSBuild preprocessor. Pass /pp to the command line to create a single huge XML project file with all project imports inlined in the correct order. This is useful to investigate the ordering of imports and property and target overrides during evaluation.
    * Example usage: `msbuild MyProject.csproj /pp:inlined.xml`
@@ -13,14 +13,17 @@ See the [MSBuild Command-Line Reference](https://docs.microsoft.com/visualstudio
    * Passes parameters to the file logger. If you want to attach multiple file loggers, you do so by specifying additional parameters in the switches /flp1, /flp2, /flp3, and so on.
 
 # Environment Variables
+
+ * `MSBuildDebugEngine=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
+  * Set this to cause any MSBuild invocation launched within this environment to emit binary logs and additional debugging information to `<DIRECTORY>`. Useful when debugging build or evaluation issues when you can't directly influence the MSBuild invocation, such as in Visual Studio.
  * `MSBUILDTARGETOUTPUTLOGGING=1`
-   * Set this to enable [printing all target outputs to the log](https://blogs.msdn.microsoft.com/msbuild/2010/03/31/displaying-target-output-items-using-the-console-logger).
+   * Set this to enable [printing all target outputs to the log](https://learn.microsoft.com/archive/blogs/msbuild/displaying-target-output-items-using-the-console-logger).
  * `MSBUILDLOGTASKINPUTS=1`
    * Log task inputs (not needed if there are any diagnostic loggers already).
  * `MSBUILDEMITSOLUTION=1`
    * Save the generated .proj file for the .sln that is used to build the solution.
  * `MSBUILDENABLEALLPROPERTYFUNCTIONS=1`
-   * Enable [additional property functions](https://blogs.msdn.microsoft.com/visualstudio/2010/04/02/msbuild-property-functions).
+   * Enable [additional property functions](https://devblogs.microsoft.com/visualstudio/msbuild-property-functions/).
  * `MSBUILDLOGVERBOSERARSEARCHRESULTS=1`
    * In ResolveAssemblyReference task, log verbose search results.
  * `MSBUILDLOGCODETASKFACTORYOUTPUT=1`
@@ -33,7 +36,7 @@ See the [MSBuild Command-Line Reference](https://docs.microsoft.com/visualstudio
    * Launch debugger on build start.
    * Setting the value of 2 allows for manually attaching a debugger to a process ID.
  * `MSBUILDDEBUGSCHEDULER=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
-   * Dumps scheduler state at specified directory
+   * Dumps scheduler state at specified directory (`MSBUILDDEBUGSCHEDULER` is implied by `MSBuildDebugEngine`).
 
 # TreatAsLocalProperty
 If MSBuild.exe is passed properties on the command line, such as `/p:Platform=AnyCPU` then this value overrides whatever assignments you have to that property inside property groups. For instance, `<Platform>x86</Platform>` will be ignored. To make sure your local assignment to properties overrides whatever they pass on the command line, add the following at the top of your MSBuild project file:
@@ -45,7 +48,7 @@ If MSBuild.exe is passed properties on the command line, such as `/p:Platform=An
 This will make sure that your local assignments to the `Platform` property are respected. You can specify multiple properties in `TreatAsLocalProperty` separated by semicolon.
 
 # Visual Studio Background Builds
-Set the `TRACEDESIGNTIME=true` environment variable to output design-time build logs to TEMP: read more here: https://blogs.msdn.microsoft.com/jeremykuhne/2016/06/06/vs-background-builds
+Set the `TRACEDESIGNTIME=true` environment variable to output design-time build logs to TEMP: read more here: https://learn.microsoft.com/archive/blogs/jeremykuhne/vs-background-builds
 
 # Visual Studio Design-time (IntelliSense) builds
 
@@ -56,7 +59,7 @@ Use this command-line to approximate what the design-time build does:
 ```
 
 # Extend all builds (at system-wide level)
-See https://www.simple-talk.com/dotnet/.net-tools/extending-msbuild, "Extending all builds" section. Also read about [MSBuildUserExtensionsPath](http://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,33), [CustomBeforeMicrosoftCommonProps](http://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,68), [CustomBeforeMicrosoftCommonTargets](http://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.targets,71), and CustomAfterMicrosoftCommonProps/CustomAfterMicrosoftCommonTargets.
+See https://www.simple-talk.com/dotnet/.net-tools/extending-msbuild, "Extending all builds" section. Also read about [MSBuildUserExtensionsPath](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,33), [CustomBeforeMicrosoftCommonProps](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/Microsoft.Common.props,68), [CustomBeforeMicrosoftCommonTargets](https://referencesource.microsoft.com/#MSBuildFiles/C/ProgramFiles(x86)/MSBuild/14.0/bin_/amd64/Microsoft.Common.targets,71), and CustomAfterMicrosoftCommonProps/CustomAfterMicrosoftCommonTargets.
 
 Example:
 Create this file (Custom.props) in `C:\Users\username\AppData\Local\Microsoft\MSBuild\Current\Microsoft.Common.targets\ImportAfter`:
diff --git a/documentation/wiki/Microsoft.Build.Framework.md b/documentation/wiki/Microsoft.Build.Framework.md
index c72abbf4578..658d8d6c57f 100644
--- a/documentation/wiki/Microsoft.Build.Framework.md
+++ b/documentation/wiki/Microsoft.Build.Framework.md
@@ -1,7 +1,7 @@
 ### Microsoft.Build.Framework
 It you have looked carefully, you might notice some odd behavior around this assembly (Microsoft.Build.Framework). We released the source here, but in some cases if you use our `BuildAndCopy.cmd` script, you will reference the one on your machine instead of the one you just built! Here's why.
 
-Microsoft.Build.Framework contains the types and interfaces for extensibility in MSBuild. If you've ever written a custom Task, you might recognize them as ITask, ITaskItem, etc. After you build your Task, let's say targeting `Microsoft.Build.Framework, Version=12.0.0.0, PublicKeyToken=b03f5f7f11d50a3a` (Visual Studio 2013), anyone with MSBuild 12.0 or later can use your Task. In later versions of MSBuild, say version 14.0, we will use a [binding redirect](https://msdn.microsoft.com/en-us/library/eftw1fys(v=vs.110).aspx) to point you to the newer version of Microsoft.Build.Framework. Assuming we did our jobs right with compatibility, your Task should run without ever knowing the difference. The crucial point of detail here is that the public key token for the Framework assembly **did not change** between version. If it does, binding redirection is not allowed.
+Microsoft.Build.Framework contains the types and interfaces for extensibility in MSBuild. If you've ever written a custom Task, you might recognize them as ITask, ITaskItem, etc. After you build your Task, let's say targeting `Microsoft.Build.Framework, Version=12.0.0.0, PublicKeyToken=b03f5f7f11d50a3a` (Visual Studio 2013), anyone with MSBuild 12.0 or later can use your Task. In later versions of MSBuild, say version 14.0, we will use a [binding redirect](https://learn.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/bindingredirect-element) to point you to the newer version of Microsoft.Build.Framework. Assuming we did our jobs right with compatibility, your Task should run without ever knowing the difference. The crucial point of detail here is that the public key token for the Framework assembly **did not change** between version. If it does, binding redirection is not allowed.
 
 ## Option 1 - Project Reference
 By default this is enabled. This means that all MSBuild code will reference Microsoft.Build.Framework as a project reference and therefore will not have the same public key token as the retail version.
@@ -25,7 +25,7 @@ This will set the property for you and create a drop of MSBuild and dependencies
 
 ## Option 3 - Test or Delay Signing
 For the advanced user, another option here is to delay sign this version of MSBuild with our public key. Since that part of the key is public, it's very easy to extract (using `Sn.exe`) and delay sign. You can get more information on that here:
- * [Delay Signing](https://blogs.msdn.microsoft.com/shawnfa/2004/03/17/delay-signing/)
- * [Test Key Signing](http://blogs.msdn.com/b/shawnfa/archive/2005/10/24/484170.aspx)
+ * [Delay Signing](https://learn.microsoft.com/archive/blogs/shawnfa/delay-signing)
+ * [Test Key Signing](https://web.archive.org/web/20101005012428/http://blogs.msdn.com/b/shawnfa/archive/2005/10/24/484170.aspx)
 
 Delay signing is the easiest, but it modifies your system to allow it to load and trust an assembly (Microsoft.Build.Framework) even when it's not signed at all, from any source. The Test Key Signing allows for a much more secure approach (as long as you keep your private key private), but is more complicated to setup. We are providing this as a reference, but please only try this if you: really want to customize Microsoft.Build.Framework and use existing custom Tasks, you feel comfortable with the security implications, and you acknowledge this is all at your own risk.
\ No newline at end of file
diff --git a/documentation/wiki/Rebuilding-when-nothing-changed.md b/documentation/wiki/Rebuilding-when-nothing-changed.md
index 9355b3a21bb..5f9fc83bd52 100644
--- a/documentation/wiki/Rebuilding-when-nothing-changed.md
+++ b/documentation/wiki/Rebuilding-when-nothing-changed.md
@@ -4,11 +4,11 @@ There is a class of problems with build where when you build twice, it still reb
 
 There are multiple tools to investigate and fix broken incrementality. Start with the blog posts below.
 
- * [https://blogs.msdn.microsoft.com/kirillosenkov/2014/08/04/how-to-investigate-rebuilding-in-visual-studio-when-nothing-has-changed/](https://blogs.msdn.microsoft.com/kirillosenkov/2014/08/04/how-to-investigate-rebuilding-in-visual-studio-when-nothing-has-changed/)
- * [https://blogs.msdn.microsoft.com/kirillosenkov/2015/05/12/msbuild-unnecessary-rebuilds-because-of-generated-assemblyattributes-cs/](https://blogs.msdn.microsoft.com/kirillosenkov/2015/05/12/msbuild-unnecessary-rebuilds-because-of-generated-assemblyattributes-cs/)
- * [http://www.andreas-reiff.de/2012/02/when-visual-studio-keeps-rebuilding-projects-that-have-not-changed/](http://www.andreas-reiff.de/2012/02/when-visual-studio-keeps-rebuilding-projects-that-have-not-changed/)
- * [MSDN: How to build incrementally](https://msdn.microsoft.com/en-us/library/ms171483.aspx)
- * [https://docs.microsoft.com/en-us/visualstudio/msbuild/incremental-builds?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/msbuild/incremental-builds?view=vs-2019)
+ * [How to investigate Rebuilding in Visual Studio when nothing has changed](https://learn.microsoft.com/archive/blogs/kirillosenkov/how-to-investigate-rebuilding-in-visual-studio-when-nothing-has-changed)
+ * [MSBuild: unnecessary rebuilds because of generated AssemblyAttributes.cs](https://learn.microsoft.com/archive/blogs/kirillosenkov/msbuild-unnecessary-rebuilds-because-of-generated-assemblyattributes-cs)
+ * [When Visual Studio keeps rebuilding Projects that have not changed](https://web.archive.org/web/20120321204616/http://www.andreas-reiff.de/2012/02/when-visual-studio-keeps-rebuilding-projects-that-have-not-changed/)
+ * [How to build incrementally](https://learn.microsoft.com/visualstudio/msbuild/how-to-build-incrementally)
+ * [Incremental builds](https://learn.microsoft.com/visualstudio/msbuild/incremental-builds)
 
 Strings to search for in the build logs:
  * `Building target "CoreCompile" completely`
@@ -16,4 +16,4 @@ Strings to search for in the build logs:
  * `out-of-date`
  * `missing`
 
-Consider using http://msbuildlog.com to help with searching through the build log.
\ No newline at end of file
+Consider using https://msbuildlog.com to help with searching through the build log.
\ No newline at end of file
diff --git a/documentation/wiki/ResolveAssemblyReference.md b/documentation/wiki/ResolveAssemblyReference.md
index 27241f5dbd5..1dff452245f 100644
--- a/documentation/wiki/ResolveAssemblyReference.md
+++ b/documentation/wiki/ResolveAssemblyReference.md
@@ -13,7 +13,7 @@ https://github.com/dotnet/msbuild/blob/a936b97e30679dcea4d99c362efa6f732c9d3587/
 This is where the RAR task is invoked in the targets file.
 
 The source code for RAR is at:
-https://github.com/dotnet/msbuild/blob/master/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+https://github.com/dotnet/msbuild/blob/main/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
 
 ## Inputs
 RAR is very detailed about logging its inputs:
diff --git a/documentation/wiki/Target-Maps.md b/documentation/wiki/Target-Maps.md
index 9f721c90075..722b28119c6 100644
--- a/documentation/wiki/Target-Maps.md
+++ b/documentation/wiki/Target-Maps.md
@@ -1,4 +1,4 @@
-[Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/BuildTargets.png)
-![Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/BuildTargets.png)
-[Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/CompileTargets.png)
-![Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/master/docs/CompileTargets.png)
\ No newline at end of file
+[Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/BuildTargets.png)
+![Build Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/BuildTargets.png)
+[Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/CompileTargets.png)
+![Compile Target Map](https://raw.githubusercontent.com/KirillOsenkov/MSBuildStructuredLog/main/docs/CompileTargets.png)
\ No newline at end of file
diff --git a/documentation/wiki/TestExplorerEnvironments.png b/documentation/wiki/TestExplorerEnvironments.png
new file mode 100644
index 00000000000..36a852dda07
Binary files /dev/null and b/documentation/wiki/TestExplorerEnvironments.png differ
diff --git a/documentation/wiki/UnGAC.md b/documentation/wiki/UnGAC.md
index e0d45d729ee..a5b796f3edd 100644
--- a/documentation/wiki/UnGAC.md
+++ b/documentation/wiki/UnGAC.md
@@ -2,7 +2,7 @@
 
 ## What is the GAC?
 
-See the [public documentation](https://docs.microsoft.com/dotnet/framework/app-domains/gac). The GAC is a folder where different installations of VS on the same machine look for assemblies that are commonly used. If an assembly is in the GAC, it will be prioritized over any other assembly.
+See the [public documentation](https://learn.microsoft.com/dotnet/framework/app-domains/gac). The GAC is a folder where different installations of VS on the same machine look for assemblies that are commonly used. If an assembly is in the GAC, it will be prioritized over any other assembly.
 
 The only MSBuild assemblies you may see in the GAC are version 4.8. There is no reason any modern (15.1+) MSBuild assembly should be in the GAC today.
 
diff --git a/eng/BootStrapMSBuild.targets b/eng/BootStrapMSBuild.targets
index a69fff9c6df..5f09f79ddbc 100644
--- a/eng/BootStrapMSBuild.targets
+++ b/eng/BootStrapMSBuild.targets
@@ -36,6 +36,7 @@
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('NuGet.'))' == 'True'" />
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Newtonsoft.Json'))' == 'True'" />
         <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('NuGetSdkResolver'))' == 'True'" />
+        <_NuGetRuntimeDependencies Include="%(RuntimeCopyLocalItems.Identity)" Condition="'@(RuntimeCopyLocalItems->Contains('Microsoft.Extensions.'))' == 'True'" />
 
         <!-- NuGet.targets will be in the ResolvedRuntimeTargets ItemGroup -->
         <_NuGetRuntimeDependencies Include="%(RuntimeTargetsCopyLocalItems.Identity)" Condition="'@(RuntimeTargetsCopyLocalItems->Contains('NuGet.'))' == 'True'" />
@@ -56,6 +57,7 @@
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGet.'))' == 'True'" />
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Newtonsoft.Json'))' == 'True'" />
         <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('NuGetSdkResolver'))' == 'True'" />
+        <Reference Remove="%(Reference.Identity)" Condition="'@(Reference->Contains('Microsoft.Extensions.'))' == 'True'" />
     </ItemGroup>
   </Target>
 
@@ -102,6 +104,7 @@
       <FreshlyBuiltBinariesx64 Include="$(X64BinPath)**\*.dll.config" />
 
       <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.Tasks.Core.dll" />
+      <FreshlyBuiltBinariesArm64 Include="$(X64BinPath)\Microsoft.Build.dll" />
       <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.exe" />
       <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.tlb" />
       <FreshlyBuiltBinariesArm64 Include="$(Arm64BinPath)**\*.pdb" />
diff --git a/eng/SourceBuild.props b/eng/SourceBuild.props
index d0989ae9c8b..0bc1c2b8324 100644
--- a/eng/SourceBuild.props
+++ b/eng/SourceBuild.props
@@ -8,6 +8,8 @@
   <Target Name="ConfigureInnerBuildArgs" BeforeTargets="GetSourceBuildCommandConfiguration">
     <PropertyGroup>
       <InnerBuildArgs>$(InnerBuildArgs) /p:Projects="$(InnerSourceBuildRepoRoot)\MSBuild.SourceBuild.slnf"</InnerBuildArgs>
+      <!-- Disable package validation as source build filters out target frameworks. -->
+      <InnerBuildArgs>$(InnerBuildArgs) /p:EnablePackageValidation=false</InnerBuildArgs>
     </PropertyGroup>
   </Target>
 
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 70a03422fa5..7310d68883a 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22458.2">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.23060.6">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>6812704fe5a1baead5da5c1c8bf723752ab728b5</Sha>
+      <Sha>74b7648c106865057c78ca1e4b2ffcb5e9bce071</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.4.0-preview.3.107">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.5.0-preview.3.136">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>1a082949ae5b6da7ca2cce047396c53ae1afdde7</Sha>
+      <Sha>743503cb3c7e9ced2602ee2e29c38d63cc339451</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.4.0-2.22458.3">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.5.0-3.23062.15">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>85f9dbfea5955ec9cdad3417dba40034da74fb93</Sha>
+      <Sha>7061c64ddbd931d55b9a97f95243fcf91d04d7b1</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22458.2">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.23060.6">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>6812704fe5a1baead5da5c1c8bf723752ab728b5</Sha>
+      <Sha>74b7648c106865057c78ca1e4b2ffcb5e9bce071</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 0329938655f..774ac3743d4 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,7 +2,8 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.5.0</VersionPrefix>
+    <VersionPrefix>17.6.0</VersionPrefix>
+    <PackageValidationBaselineVersion>17.5.0-preview-23059-01</PackageValidationBaselineVersion>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -27,9 +28,9 @@
   <PropertyGroup>
     <SystemCollectionsImmutableVersion>6.0.0</SystemCollectionsImmutableVersion>
     <SystemConfigurationConfigurationManagerVersion>6.0.0</SystemConfigurationConfigurationManagerVersion>
-    <!-- 
+    <!--
         Modifying the version of System.Memory is very high impact and causes downstream breaks in third-party tooling that uses the MSBuild API.
-        When updating the version of System.Memory file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+ 
+        When updating the version of System.Memory file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+
         and follow the guidelines written here (internal-link): https://dev.azure.com/devdiv/DevDiv/_wiki/wikis/DevDiv.wiki/1796/How-to-add-a-Known-Issue
     -->
     <SystemMemoryVersion>4.5.5</SystemMemoryVersion>
@@ -47,11 +48,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22458.2</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.23060.6</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.4.0-2.22458.3</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.4.0-preview.3.107</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.5.0-3.23062.15</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.5.0-preview.3.136</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>6.0.0</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>6.0.0</SystemThreadingTasksDataflowVersion>
diff --git a/eng/common/build.ps1 b/eng/common/build.ps1
index 8943da242f6..33a6f2d0e24 100644
--- a/eng/common/build.ps1
+++ b/eng/common/build.ps1
@@ -26,6 +26,7 @@ Param(
   [string] $runtimeSourceFeed = '',
   [string] $runtimeSourceFeedKey = '',
   [switch] $excludePrereleaseVS,
+  [switch] $nativeToolsOnMachine,
   [switch] $help,
   [Parameter(ValueFromRemainingArguments=$true)][String[]]$properties
 )
@@ -67,6 +68,7 @@ function Print-Usage() {
   Write-Host "  -warnAsError <value>    Sets warnaserror msbuild parameter ('true' or 'false')"
   Write-Host "  -msbuildEngine <value>  Msbuild engine to use to run build ('dotnet', 'vs', or unspecified)."
   Write-Host "  -excludePrereleaseVS    Set to exclude build engines in prerelease versions of Visual Studio"
+  Write-Host "  -nativeToolsOnMachine   Sets the native tools on machine environment variable (indicating that the script should use native tools on machine)"
   Write-Host ""
 
   Write-Host "Command line arguments not listed above are passed thru to msbuild."
@@ -146,6 +148,9 @@ try {
     $nodeReuse = $false
   }
 
+  if ($nativeToolsOnMachine) {
+    $env:NativeToolsOnMachine = $true
+  }
   if ($restore) {
     InitializeNativeTools
   }
diff --git a/eng/common/cross/toolchain.cmake b/eng/common/cross/toolchain.cmake
index ec8971eb019..51f30e53dd4 100644
--- a/eng/common/cross/toolchain.cmake
+++ b/eng/common/cross/toolchain.cmake
@@ -1,5 +1,12 @@
 set(CROSS_ROOTFS $ENV{ROOTFS_DIR})
 
+# reset platform variables (e.g. cmake 3.25 sets LINUX=1)
+unset(LINUX)
+unset(FREEBSD)
+unset(ILLUMOS)
+unset(ANDROID)
+unset(TIZEN)
+
 set(TARGET_ARCH_NAME $ENV{TARGET_BUILD_ARCH})
 if(EXISTS ${CROSS_ROOTFS}/bin/freebsd-version)
   set(CMAKE_SYSTEM_NAME FreeBSD)
diff --git a/eng/common/dotnet-install.sh b/eng/common/dotnet-install.sh
index fdfeea66e7d..b09ea669f9c 100755
--- a/eng/common/dotnet-install.sh
+++ b/eng/common/dotnet-install.sh
@@ -52,7 +52,7 @@ done
 # Use uname to determine what the CPU is, see https://en.wikipedia.org/wiki/Uname#Examples
 cpuname=$(uname -m)
 case $cpuname in
-  aarch64)
+  arm64|aarch64)
     buildarch=arm64
     ;;
   amd64|x86_64)
@@ -61,7 +61,7 @@ case $cpuname in
   armv*l)
     buildarch=arm
     ;;
-  i686)
+  i[3-6]86)
     buildarch=x86
     ;;
   *)
diff --git a/eng/common/init-tools-native.ps1 b/eng/common/init-tools-native.ps1
index 7428ef88084..6c7a851a808 100644
--- a/eng/common/init-tools-native.ps1
+++ b/eng/common/init-tools-native.ps1
@@ -112,6 +112,7 @@ try {
             $ToolPath = Convert-Path -Path $BinPath
             Write-Host "Adding $ToolName to the path ($ToolPath)..."
             Write-Host "##vso[task.prependpath]$ToolPath"
+            $env:PATH = "$ToolPath;$env:PATH"
             $InstalledTools += @{ $ToolName = $ToolDirectory.FullName }
           }
         }
diff --git a/eng/common/sdl/sdl.ps1 b/eng/common/sdl/sdl.ps1
new file mode 100644
index 00000000000..648c5068d7d
--- /dev/null
+++ b/eng/common/sdl/sdl.ps1
@@ -0,0 +1,38 @@
+
+function Install-Gdn {
+    param(
+        [Parameter(Mandatory=$true)]
+        [string]$Path,
+
+        # If omitted, install the latest version of Guardian, otherwise install that specific version.
+        [string]$Version
+    )
+
+    $ErrorActionPreference = 'Stop'
+    Set-StrictMode -Version 2.0
+    $disableConfigureToolsetImport = $true
+    $global:LASTEXITCODE = 0
+
+    # `tools.ps1` checks $ci to perform some actions. Since the SDL
+    # scripts don't necessarily execute in the same agent that run the
+    # build.ps1/sh script this variable isn't automatically set.
+    $ci = $true
+    . $PSScriptRoot\..\tools.ps1
+
+    $argumentList = @("install", "Microsoft.Guardian.Cli", "-Source https://securitytools.pkgs.visualstudio.com/_packaging/Guardian/nuget/v3/index.json", "-OutputDirectory $Path", "-NonInteractive", "-NoCache")
+
+    if ($Version) {
+        $argumentList += "-Version $Version"
+    }
+    
+    Start-Process nuget -Verbose -ArgumentList $argumentList -NoNewWindow -Wait
+
+    $gdnCliPath = Get-ChildItem -Filter guardian.cmd -Recurse -Path $Path
+
+    if (!$gdnCliPath)
+    {
+        Write-PipelineTelemetryError -Category 'Sdl' -Message 'Failure installing Guardian'
+    }
+
+    return $gdnCliPath.FullName
+}
\ No newline at end of file
diff --git a/eng/common/templates/steps/execute-sdl.yml b/eng/common/templates/steps/execute-sdl.yml
index 7b8ee18a28d..9dd5709f66d 100644
--- a/eng/common/templates/steps/execute-sdl.yml
+++ b/eng/common/templates/steps/execute-sdl.yml
@@ -8,29 +8,28 @@ parameters:
   condition: ''
 
 steps:
-- ${{ if ne(parameters.overrideGuardianVersion, '') }}:
-  - powershell: |
-      $content = Get-Content $(GuardianPackagesConfigFile)
-
-      Write-Host "packages.config content was:`n$content"
-
-      $content = $content.Replace('$(DefaultGuardianVersion)', '$(GuardianVersion)')
-      $content | Set-Content $(GuardianPackagesConfigFile)
-
-      Write-Host "packages.config content updated to:`n$content"
-    displayName: Use overridden Guardian version ${{ parameters.overrideGuardianVersion }}
+- task: NuGetAuthenticate@1
+  inputs:
+    nuGetServiceConnections: GuardianConnect
 
 - task: NuGetToolInstaller@1
   displayName: 'Install NuGet.exe'
   
-- task: NuGetCommand@2
-  displayName: 'Install Guardian'
-  inputs:
-    restoreSolution: $(Build.SourcesDirectory)\eng\common\sdl\packages.config
-    feedsToUse: config
-    nugetConfigPath: $(Build.SourcesDirectory)\eng\common\sdl\NuGet.config
-    externalFeedCredentials: GuardianConnect
-    restoreDirectory: $(Build.SourcesDirectory)\.packages
+- ${{ if ne(parameters.overrideGuardianVersion, '') }}:
+  - pwsh: |
+      Set-Location -Path $(Build.SourcesDirectory)\eng\common\sdl
+      . .\sdl.ps1
+      $guardianCliLocation = Install-Gdn -Path $(Build.SourcesDirectory)\.artifacts -Version ${{ parameters.overrideGuardianVersion }}
+      Write-Host "##vso[task.setvariable variable=GuardianCliLocation]$guardianCliLocation"
+    displayName: Install Guardian (Overridden)
+
+- ${{ if eq(parameters.overrideGuardianVersion, '') }}:
+  - pwsh: |
+      Set-Location -Path $(Build.SourcesDirectory)\eng\common\sdl
+      . .\sdl.ps1
+      $guardianCliLocation = Install-Gdn -Path $(Build.SourcesDirectory)\.artifacts
+      Write-Host "##vso[task.setvariable variable=GuardianCliLocation]$guardianCliLocation"
+    displayName: Install Guardian
 
 - ${{ if ne(parameters.overrideParameters, '') }}:
   - powershell: ${{ parameters.executeAllSdlToolsScript }} ${{ parameters.overrideParameters }}
@@ -40,7 +39,7 @@ steps:
 
 - ${{ if eq(parameters.overrideParameters, '') }}:
   - powershell: ${{ parameters.executeAllSdlToolsScript }}
-      -GuardianPackageName Microsoft.Guardian.Cli.$(GuardianVersion)
+      -GuardianCliLocation $(GuardianCliLocation)
       -NugetPackageDirectory $(Build.SourcesDirectory)\.packages
       -AzureDevOpsAccessToken $(dn-bot-dotnet-build-rw-code-rw)
       ${{ parameters.additionalParameters }}
@@ -62,7 +61,28 @@ steps:
         c
         i
     condition: succeededOrFailed()
+
   - publish: $(Agent.BuildDirectory)/.gdn
     artifact: GuardianConfiguration
     displayName: Publish GuardianConfiguration
+    condition: succeededOrFailed()
+
+  # Publish the SARIF files in a container named CodeAnalysisLogs to enable integration
+  # with the "SARIF SAST Scans Tab" Azure DevOps extension
+  - task: CopyFiles@2
+    displayName: Copy SARIF files
+    inputs:
+      flattenFolders: true
+      sourceFolder:  $(Agent.BuildDirectory)/.gdn/rc/
+      contents: '**/*.sarif'
+      targetFolder: $(Build.SourcesDirectory)/CodeAnalysisLogs
+    condition: succeededOrFailed()
+
+  # Use PublishBuildArtifacts because the SARIF extension only checks this case
+  # see microsoft/sarif-azuredevops-extension#4
+  - task: PublishBuildArtifacts@1
+    displayName: Publish SARIF files to CodeAnalysisLogs container
+    inputs:
+      pathToPublish:  $(Build.SourcesDirectory)/CodeAnalysisLogs
+      artifactName: CodeAnalysisLogs
     condition: succeededOrFailed()
\ No newline at end of file
diff --git a/eng/common/templates/steps/source-build.yml b/eng/common/templates/steps/source-build.yml
index abb1b2bcda4..b5b3e5aeb3b 100644
--- a/eng/common/templates/steps/source-build.yml
+++ b/eng/common/templates/steps/source-build.yml
@@ -63,6 +63,11 @@ steps:
       targetRidArgs='/p:TargetRid=${{ parameters.platform.targetRID }}'
     fi
 
+    runtimeOsArgs=
+    if [ '${{ parameters.platform.runtimeOS }}' != '' ]; then
+      runtimeOsArgs='/p:RuntimeOS=${{ parameters.platform.runtimeOS }}'
+    fi
+
     publishArgs=
     if [ '${{ parameters.platform.skipPublishValidation }}' != 'true' ]; then
       publishArgs='--publish'
@@ -75,6 +80,7 @@ steps:
       $internalRuntimeDownloadArgs \
       $internalRestoreArgs \
       $targetRidArgs \
+      $runtimeOsArgs \
       /p:SourceBuildNonPortable=${{ parameters.platform.nonPortable }} \
       /p:ArcadeBuildFromSource=true
   displayName: Build
diff --git a/eng/config/OptProf.runsettings b/eng/config/OptProf.runsettings
new file mode 100644
index 00000000000..3c5f7566a46
--- /dev/null
+++ b/eng/config/OptProf.runsettings
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="utf-8"?>
+<RunSettings>
+  <RunConfiguration>
+    <ResultsDirectory>C:\Test\Results</ResultsDirectory>
+    <TargetPlatform>X86</TargetPlatform>
+    <MaxCpuCount>1</MaxCpuCount>
+    <BatchSize>10</BatchSize>
+    <TestSessionTimeout>21600000</TestSessionTimeout>
+    <DesignMode>False</DesignMode>
+    <InIsolation>False</InIsolation>
+    <CollectSourceInformation>False</CollectSourceInformation>
+    <DisableAppDomain>False</DisableAppDomain>
+    <DisableParallelization>False</DisableParallelization>
+    <TargetFrameworkVersion>.NETFramework,Version=v4.0</TargetFrameworkVersion>
+    <ExecutionThreadApartmentState>STA</ExecutionThreadApartmentState>
+    <TestAdaptersPaths>%SystemDrive%\Test</TestAdaptersPaths>
+    <TreatTestAdapterErrorsAsWarnings>False</TreatTestAdapterErrorsAsWarnings>
+  </RunConfiguration>
+  <SessionConfiguration>
+    <!-- Generated -->
+  </SessionConfiguration>
+  <DataCollectionRunSettings>
+    <DataCollectors>
+      <DataCollector uri="datacollector://microsoft/DevDiv/TestExtensions/ProcDumpCollector/v1" friendlyName="ProcDump Collector" enabled="True">
+        <Configuration>
+          <RootDumpDirectory>C:\Test\Dumps</RootDumpDirectory>
+          <Deployment PackageName = "Microsoft.DevDiv.TestExtensions.ProcDumpCollector" />
+        </Configuration>
+      </DataCollector>
+      <DataCollector uri="datacollector://microsoft/DevDiv/TestExtensions/LingeringProcessCollector/v1" friendlyName="Lingering Process Collector" enabled="True">
+        <Configuration>
+          <KillLingeringProcesses>true</KillLingeringProcesses>          
+          <ShutdownCommands>
+            <ShutdownCommand Process="VBCSCompiler" Command="%ProcessPath%" Arguments="-shutdown" Timeout="60000" />
+          </ShutdownCommands>
+          <LoggingBehavior>Warning</LoggingBehavior>
+          <Deployment PackageName = "Microsoft.DevDiv.TestExtensions.LingeringProcessCollector" />
+        </Configuration>
+      </DataCollector>
+      <DataCollector uri="datacollector://microsoft/DevDiv/VideoRecorder/2.0" friendlyName="Screen and Voice Recorder" enabled="True">
+        <Configuration>
+          <Deployment PackageName = "Microsoft.DevDiv.Validation.MediaRecorder" />
+        </Configuration>
+      </DataCollector>
+    </DataCollectors>
+  </DataCollectionRunSettings>
+  <InProcDataCollectionRunSettings>
+    <InProcDataCollectors>
+      <InProcDataCollector uri="datacollector://microsoft/DevDiv/TestExtensions/OptProfDataCollector/v2" assemblyQualifiedName="Microsoft.DevDiv.TestExtensions.OptProfDataCollector, Microsoft.DevDiv.TestExtensions.OptProfDataCollector, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null" friendlyName="OptProf Data Collector" enabled="True" codebase="C:\Test\Extensions\Microsoft.DevDiv.TestExtensions.OptProfDataCollector\lib\net461\Microsoft.DevDiv.TestExtensions.OptProfDataCollector.dll">
+        <Configuration>
+          <WorkingDirectory>C:\OptProf</WorkingDirectory>
+          <ProfilesDirectory>C:\Profiles</ProfilesDirectory>
+          <IgnoreProfileNotGeneratedExceptions>true</IgnoreProfileNotGeneratedExceptions>
+          <Deployment PackageName="Microsoft.DevDiv.TestExtensions.OptProfDataCollector" />
+        </Configuration>
+      </InProcDataCollector>
+    </InProcDataCollectors>
+  </InProcDataCollectionRunSettings>
+  <TestRunParameters />
+  <LoggerRunSettings>
+    <Loggers />
+  </LoggerRunSettings>
+  <VisualStudioConfiguration>
+    <!-- MSBuild-OptProf specific VS configuration element -->
+    <InstallationUnderTest>
+      <Components All="false">
+        <Include ID="Microsoft.VisualStudio.Component.VC.CLI.Support" />
+        <Include ID="Microsoft.VisualStudio.Component.Windows81SDK" />
+        <Include ID="Microsoft.VisualStudio.ComponentGroup.UWP.VC" />
+        <Include ID="Microsoft.VisualStudio.Component.VC.ATLMFC" />
+        <Include ID="Microsoft.VisualStudio.Component.Windows10SDK.15063.Desktop" />
+        <Include ID="Microsoft.VisualStudio.Component.Windows10SDK.16299" />
+        <Include ID="Microsoft.VisualStudio.Component.Windows10SDK.16299.UWP" />
+        <Include ID="Microsoft.Net.ComponentGroup.4.7.2.DeveloperTools" />
+        <Exclude ID="Component.Incredibuild" />
+        <Exclude ID="Component.JavaJDK" />
+        <Exclude ID="Microsoft.VisualStudio.Component.AspNet45" />
+      </Components>
+      <Workloads All="false" IncludeComponents="Required,Recommended">
+        <Include ID="Microsoft.VisualStudio.Workload.CoreEditor" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.ManagedDesktop" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.NativeCrossPlat" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.NativeDesktop" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.NetWeb" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.Office" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.Universal" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.VisualStudioExtension" IncludeComponents="Required" />
+        <Include ID="Microsoft.VisualStudio.Workload.Webcrossplat" IncludeComponents="Required" />
+      </Workloads>
+    </InstallationUnderTest>
+  </VisualStudioConfiguration>
+</RunSettings>
\ No newline at end of file
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index dabc0805ea8..dc823e73741 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -16,9 +16,6 @@
     <PackageReference Update="LargeAddressAware" Version="1.0.5" />
     <PackageReference Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
 
-    <PackageReference Update="Microsoft.CodeAnalysis.PublicApiAnalyzers" Version="3.3.3" />
-    <PackageReference Update="Microsoft.CodeAnalysis.PublicApiAnalyzers" Condition="'$(MicrosoftCodeAnalysisPublicApiAnalyzersVersion)' != ''" Version="$(MicrosoftCodeAnalysisPublicApiAnalyzersVersion)" />
-
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" />
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Condition="'$(MicrosoftVisualStudioSDKEmbedInteropTypesVersion)' != ''" Version="$(MicrosoftVisualStudioSDKEmbedInteropTypesVersion)" />
 
@@ -28,7 +25,7 @@
     <PackageReference Update="Microsoft.Win32.Registry" Version="5.0.0" />
     <PackageReference Update="Microsoft.Win32.Registry" Condition="'$(MicrosoftWin32RegistryVersion)' != ''" Version="$(MicrosoftWin32RegistryVersion)" />
 
-    <PackageReference Update="Newtonsoft.Json" Version="13.0.1" />
+    <PackageReference Update="Newtonsoft.Json" Version="13.0.2" />
     <PackageReference Update="Newtonsoft.Json" Condition="'$(NewtonsoftJsonVersion)' != ''" Version="$(NewtonsoftJsonVersion)" />
 
     <PackageReference Update="PdbGit" Version="3.0.41" />
@@ -49,7 +46,7 @@
     <PackageReference Update="System.Security.Cryptography.Pkcs" Version="6.0.1" />
     <PackageReference Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
 
-    <PackageReference Update="System.Security.Cryptography.Xml" Version="6.0.0" />
+    <PackageReference Update="System.Security.Cryptography.Xml" Version="6.0.1" />
     <PackageReference Update="System.Security.Cryptography.Xml" Condition="'$(SystemSecurityCryptographyXmlVersion)' != ''" Version="$(SystemSecurityCryptographyXmlVersion)" />
 
     <PackageReference Update="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
diff --git a/global.json b/global.json
index 7cd88120047..39c8c57a412 100644
--- a/global.json
+++ b/global.json
@@ -3,14 +3,14 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "7.0.100-rc.2.22477.23",
+    "dotnet": "7.0.101",
     "vs": {
-      "version": "17.3.1"
+      "version": "17.4.1"
     },
-    "xcopy-msbuild": "17.3.1"
+    "xcopy-msbuild": "17.4.1"
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22458.2"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.23060.6"
   }
 }
diff --git a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
index c6cd195c9d0..bc6e78a22fd 100644
--- a/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ConstructionEditing_Tests.cs
@@ -787,7 +787,7 @@ public void AddItemWithRemoveToItemGroupOutsideTarget()
 
         public delegate void AddMetadata(ProjectItemElement element);
 
-        public static IEnumerable<object[]> InsertMetadataElemenetAfterSiblingsTestData
+        public static IEnumerable<object[]> InsertMetadataElementAfterSiblingsTestData
         {
             get
             {
@@ -892,7 +892,7 @@ public static IEnumerable<object[]> InsertMetadataElemenetAfterSiblingsTestData
         }
 
         [Theory]
-        [MemberData(nameof(InsertMetadataElemenetAfterSiblingsTestData))]
+        [MemberData(nameof(InsertMetadataElementAfterSiblingsTestData))]
         public void InsertMetadataElementAfterSiblings(AddMetadata addMetadata, int position, string expectedItem)
         {
             Action<ProjectItemElement, ProjectMetadataElement, ProjectMetadataElement> act = (i, c, r) => { i.InsertAfterChild(c, r); };
@@ -900,7 +900,7 @@ public void InsertMetadataElementAfterSiblings(AddMetadata addMetadata, int posi
             AssertMetadataConstruction(addMetadata, position, expectedItem, act);
         }
 
-        public static IEnumerable<object[]> InsertMetadataElemenetBeforeSiblingsTestData
+        public static IEnumerable<object[]> InsertMetadataElementBeforeSiblingsTestData
         {
             get
             {
@@ -934,7 +934,7 @@ public static IEnumerable<object[]> InsertMetadataElemenetBeforeSiblingsTestData
         }
 
         [Theory]
-        [MemberData(nameof(InsertMetadataElemenetBeforeSiblingsTestData))]
+        [MemberData(nameof(InsertMetadataElementBeforeSiblingsTestData))]
         public void InsertMetadataElementBeforeSiblings(AddMetadata addMetadata, int position, string expectedItem)
         {
             Action<ProjectItemElement, ProjectMetadataElement, ProjectMetadataElement> act = (i, c, r) => { i.InsertBeforeChild(c, r); };
diff --git a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
index 6c04b5ee80d..b04097bd028 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectFormatting_Tests.cs
@@ -653,7 +653,7 @@ private static void CreateProjectAndAssertEncoding(bool xmlDeclaration, bool byt
             content += @"<Project><Target Name=""Build""/></Project>";
             content = ObjectModelHelpers.CleanupFileContents(content);
 
-            var file = FileUtilities.GetTemporaryFile(".proj");
+            var file = FileUtilities.GetTemporaryFileName(".proj");
             try
             {
                 File.WriteAllText(file, content, new UTF8Encoding(encoderShouldEmitUTF8Identifier: byteOrderMark));
diff --git a/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
index d4c31dd57ef..c974eeb2915 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectImportElement_Tests.cs
@@ -163,12 +163,12 @@ public void SettingProjectDirties()
 
             try
             {
-                file1 = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                file1 = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                 ProjectRootElement importProject1 = ProjectRootElement.Create();
                 importProject1.AddProperty("p", "v1");
                 importProject1.Save(file1);
 
-                file2 = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                file2 = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                 ProjectRootElement importProject2 = ProjectRootElement.Create();
                 importProject2.AddProperty("p", "v2");
                 importProject2.Save(file2);
@@ -208,7 +208,7 @@ public void SettingConditionDirties()
 
             try
             {
-                file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                 ProjectRootElement importProject = ProjectRootElement.Create();
                 importProject.AddProperty("p", "v1");
                 importProject.Save(file);
diff --git a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
index 7cbbae8a85a..da183efaaf8 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectRootElement_Tests.cs
@@ -172,7 +172,7 @@ public void SetFullPath()
         public void ConstructOverSameFileReturnsSame()
         {
             ProjectRootElement projectXml1 = ProjectRootElement.Create();
-            projectXml1.Save(FileUtilities.GetTemporaryFile());
+            projectXml1.Save(FileUtilities.GetTemporaryFileName());
 
             ProjectRootElement projectXml2 = ProjectRootElement.Open(projectXml1.FullPath);
 
@@ -429,7 +429,7 @@ public void ValidXmlInvalidSyntaxOpenFromDiskTwice()
                 {
                     try
                     {
-                        path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                        path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                         File.WriteAllText(path, content);
 
                         ProjectRootElement.Open(path);
@@ -462,7 +462,7 @@ public void ValidXmlXmlTextReaderNotCache()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(path, content);
 
                 var reader1 = XmlReader.Create(path);
@@ -499,7 +499,7 @@ public void ValidXmlXmlReaderCache()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(path, content);
 
                 ProjectRootElement root1 = ProjectRootElement.Create(path);
@@ -605,7 +605,7 @@ public void SaveWithTransformsToFile()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
 
                 project.Save(file);
 
@@ -730,7 +730,7 @@ public void EncodingGetterBasedOnXmlDeclaration()
         [Fact]
         public void EncodingGetterBasedOnActualEncodingWhenXmlDeclarationIsAbsent()
         {
-            string projectFullPath = FileUtilities.GetTemporaryFile();
+            string projectFullPath = FileUtilities.GetTemporaryFileName();
             try
             {
                 VerifyLoadedProjectHasEncoding(projectFullPath, Encoding.UTF8);
@@ -996,7 +996,7 @@ public void SolutionCorrupt()
 
                 try
                 {
-                    solutionFile = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    solutionFile = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
 
                     // Arbitrary corrupt content
                     string content = @"Microsoft Visual Studio Solution File, Format Version 10.00
diff --git a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
index eb7d71c2634..585c10071f7 100644
--- a/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/ProjectTargetElement_Tests.cs
@@ -5,9 +5,13 @@
 using System.IO;
 using System.Xml;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Shouldly;
+using Xunit;
 
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
-using Xunit;
 
 #nullable disable
 
@@ -339,6 +343,49 @@ public void SetReturns()
             Assert.True(project.HasUnsavedChanges);
         }
 
+        /// <summary>
+        /// Parse invalid property under target
+        /// </summary>
+        [Theory]
+        [InlineData(true)]
+        [InlineData(false)]
+        public void ReadInvalidPropertyUnderTarget(bool enableNewBehavior)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                ChangeWaves.ResetStateForTests();
+                if (!enableNewBehavior)
+                {
+                    env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                    BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+                }
+
+                string projectFile = @"
+                    <Project>
+                        <Target Name='t'>
+                            <test>m</test>
+                        </Target>
+                    </Project>";
+                TransientTestFile file = env.CreateFile("proj.csproj", projectFile);
+                ProjectCollection collection = new ProjectCollection();
+                var error = Assert.Throws<InvalidProjectFileException>(() =>
+                {
+                    collection.LoadProject(file.Path).Build().ShouldBeTrue();
+                });
+
+                error.ErrorCode.ShouldMatch("MSB4067");
+                var expectedString = "<PropertyGroup>";
+                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+                {
+                    error.Message.ShouldMatch(expectedString);
+                }
+                else
+                {
+                    error.Message.ShouldNotMatch(expectedString);
+                }
+            }
+        }
+
         /// <summary>
         /// Helper to get an empty ProjectTargetElement with various attributes and two tasks
         /// </summary>
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index 821da0c00f4..e739dcafc4f 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -1064,7 +1064,7 @@ public void ParseSolutionWithComments()
         private static SolutionFile ParseSolutionHelper(string solutionFileContents)
         {
             solutionFileContents = solutionFileContents.Replace('\'', '"');
-            string solutionPath = FileUtilities.GetTemporaryFile(".sln");
+            string solutionPath = FileUtilities.GetTemporaryFileName(".sln");
 
             try
             {
diff --git a/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs b/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs
index bdd6490ac91..8bbf86c4278 100644
--- a/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/WhiteSpacePreservation_Tests.cs
@@ -462,7 +462,7 @@ private void AssertWhiteSpacePreservation(
             // Using streams can cause issues with CRLF characters being replaced by LF going in to
             // ProjectRootElement. Saving to disk mimics the real-world behavior so we can specifically
             // test issues with CRLF characters being normalized. Related issue: #1340
-            var file = FileUtilities.GetTemporaryFile();
+            var file = FileUtilities.GetTemporaryFileName();
             var expected = ObjectModelHelpers.CleanupFileContents(updatedProject);
             string actual;
 
diff --git a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
index 09360ffbded..ca3f74502fe 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
@@ -63,7 +63,7 @@ public void AddProjectFromDisk()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement xml = ProjectRootElement.Create(path);
                 xml.Save();
 
@@ -95,7 +95,7 @@ public void AddProjectOnSave()
                 Project project = new Project();
                 Assert.Equal(0, ProjectCollection.GlobalProjectCollection.Count);
 
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 project.Save(path);
 
                 Project project2 = ProjectCollection.GlobalProjectCollection.LoadProject(path);
@@ -124,7 +124,7 @@ public void AddProjectOnSave_SpecifiedProjectCollection()
                 ProjectCollection collection = new ProjectCollection();
                 Project project = new Project(collection);
 
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 project.Save(path);
 
                 Project project2 = collection.LoadProject(path);
@@ -293,7 +293,7 @@ public void GetLoadedProjectNonExistent()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement xml = ProjectRootElement.Create();
                 xml.Save(path);
                 Assert.Equal(0, ProjectCollection.GlobalProjectCollection.Count);
@@ -337,7 +337,7 @@ public void GetLoadedProjectRootElementWrongCollection()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement.Create(path).Save();
 
                 ProjectCollection collection1 = new ProjectCollection();
@@ -823,8 +823,8 @@ public void SaveToNewNameAndUnload()
 
             try
             {
-                file1 = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
+                file1 = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
 
                 Project project = new Project();
                 project.Save(file1);
@@ -855,8 +855,8 @@ public void LoadUnloadReloadSaveToNewName()
 
             try
             {
-                file1 = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
+                file1 = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
 
                 var project = new Project();
                 project.Save(file1);
@@ -891,8 +891,8 @@ public void LoadUnloadAllReloadSaveToNewName()
 
             try
             {
-                file1 = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
+                file1 = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
 
                 var project = new Project();
                 project.Save(file1);
@@ -1433,7 +1433,7 @@ public void ProjectCollectionVersionIsCorrect()
         private static string CreateProjectFile()
         {
             ProjectRootElement xml = ProjectRootElement.Create();
-            string path = FileUtilities.GetTemporaryFile();
+            string path = FileUtilities.GetTemporaryFileName();
             xml.Save(path);
             return path;
         }
diff --git a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
index e292037b857..0d44fcf3f06 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectItem_Tests.cs
@@ -319,7 +319,7 @@ public void BuiltInMetadataTimes()
 
             try
             {
-                path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(path, String.Empty);
                 FileInfo info = new FileInfo(path);
 
@@ -2063,7 +2063,7 @@ public void RenameImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     import.AddItem("i", "i1");
                     import.Save(file);
@@ -2095,7 +2095,7 @@ public void SetMetadataImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     import.AddItem("i", "i1");
                     import.Save(file);
@@ -2127,7 +2127,7 @@ public void RemoveMetadataImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     ProjectItem item = import.AddItem("i", "i1")[0];
                     item.SetMetadataValue("m", "m0");
diff --git a/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
index d2e0899334c..7dc0fae6b3f 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectProperty_Tests.cs
@@ -263,7 +263,7 @@ public void SetPropertyImported()
 
                 try
                 {
-                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                    file = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                     Project import = new Project();
                     import.SetProperty("p", "v0");
                     import.Save(file);
diff --git a/src/Build.OM.UnitTests/Definition/Project_Tests.cs b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
index beb78eec2ae..a3457bbcd44 100644
--- a/src/Build.OM.UnitTests/Definition/Project_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/Project_Tests.cs
@@ -180,7 +180,7 @@ public void BasicFromFile()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
 
                 string content = GetSampleProjectContent();
                 File.WriteAllText(file, content);
@@ -413,7 +413,7 @@ public void ImportSelfIgnored()
                 Project project = new Project(collection);
                 project.Xml.AddImport("$(MSBuildProjectFullPath)");
 
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 project.Save(file);
                 project.ReevaluateIfNecessary();
 
@@ -440,8 +440,8 @@ public void ImportSelfIndirectIgnored()
                 MockLogger logger = new MockLogger();
                 collection.RegisterLogger(logger);
 
-                file = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
                 Project project = new Project(collection);
                 project.Xml.AddImport(file2);
                 project.Save(file);
@@ -476,8 +476,8 @@ public void DoubleImportIgnored()
                 MockLogger logger = new MockLogger();
                 collection.RegisterLogger(logger);
 
-                file = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
                 Project project = new Project(collection);
                 project.Xml.AddImport(file2);
                 project.Xml.AddImport(file2);
@@ -513,9 +513,9 @@ public void DoubleImportIndirectIgnored()
                 MockLogger logger = new MockLogger();
                 collection.RegisterLogger(logger);
 
-                file = FileUtilities.GetTemporaryFile();
-                file2 = FileUtilities.GetTemporaryFile();
-                file3 = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
+                file2 = FileUtilities.GetTemporaryFileName();
+                file3 = FileUtilities.GetTemporaryFileName();
 
                 Project project = new Project(collection);
                 project.Xml.AddImport(file2);
@@ -649,12 +649,12 @@ public void TransformsUseCorrectDirectory_Basic()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 project.Save(file);
                 project.ReevaluateIfNecessary();
 
                 project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(
-                        Path.Combine(FileUtilities.TempFileDirectory, "obj", "i386", "foo.dll"));
+                    Path.Combine(FileUtilities.TempFileDirectory, "obj", "i386", "foo.dll"));
             }
             finally
             {
@@ -792,8 +792,8 @@ public void TransformsUseCorrectDirectory_DirectoryNameItemFunction()
                 ProjectInstance projectInstance = new ProjectInstance(xml);
 
                 // Should be the full path to the directory
-                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(FileUtilities.TempFileDirectory /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"));
-                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(FileUtilities.TempFileDirectory /* remove c:\ */, "obj" + Path.DirectorySeparatorChar + "i386"));
+                project.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(FileUtilities.TempFileDirectory /* remove c:\ */, "obj", "i386"));
+                projectInstance.GetItems("BuiltProjectOutputGroupKeyOutput").First().EvaluatedInclude.ShouldBe(Path.Combine(FileUtilities.TempFileDirectory /* remove c:\ */, "obj", "i386"));
             }
             finally
             {
@@ -1359,7 +1359,7 @@ public void LastEvaluationIdAndUnload()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement.Create().Save(path);
 
                 Project project = new Project(path);
@@ -1387,7 +1387,7 @@ public void ImportedXmlModified()
 
             try
             {
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement import = ProjectRootElement.Create(path);
                 import.Save();
 
@@ -2080,7 +2080,7 @@ public void BuildEvaluationUsesCustomLoggers()
                 ObjectModelHelpers.CleanupFileContents(@"<Project xmlns='msbuildnamespace'>
                 </Project>");
 
-            string importFileName = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile() + ".proj";
+            string importFileName = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName() + ".proj";
             File.WriteAllText(importFileName, importProjectContent);
 
             string projectContent =
@@ -2180,7 +2180,7 @@ public void SavingProjectClearsDirtyBit()
             string file = null;
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 project.Save(file);
             }
             finally
@@ -2959,7 +2959,7 @@ public void GetItemProvenanceByItemType()
             };
 
             AssertProvenanceResult(expected, project, "1.foo", "B");
-            AssertProvenanceResult(new ProvenanceResultTupleList(), project, "1.foo", "NotExistant");
+            AssertProvenanceResult(new ProvenanceResultTupleList(), project, "1.foo", "NotExistent");
         }
 
         public static IEnumerable<Object[]> GetItemProvenanceByProjectItemTestData
diff --git a/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs b/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
index b5e2c942092..880504db761 100644
--- a/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProtectImports_Tests.cs
@@ -104,7 +104,7 @@ public ProtectImports_Tests()
                 </Project>";
 
             importContents = Expand(importContents);
-            _importFilename = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile() + ".targets";
+            _importFilename = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName() + ".targets";
             File.WriteAllText(_importFilename, importContents);
         }
 
diff --git a/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs b/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
index 02211ee3081..c6866746365 100644
--- a/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
+++ b/src/Build.OM.UnitTests/Instance/ProjectTargetInstance_Tests.cs
@@ -112,7 +112,7 @@ public void FileLocationAvailableEvenAfterEdits()
 
             try
             {
-                path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFile();
+                path = Microsoft.Build.Shared.FileUtilities.GetTemporaryFileName();
                 ProjectRootElement projectXml = ProjectRootElement.Create(path);
                 projectXml.Save();
 
diff --git a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
index 12fbe5d15d9..dc3d33b9784 100644
--- a/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildRequestConfiguration_Tests.cs
@@ -424,7 +424,7 @@ public void TestCache()
         [Trait("Category", "netcore-osx-failing")]
         [Trait("Category", "netcore-linux-failing")]
         [Trait("Category", "mono-osx-failing")]
-        public void TestCache2()
+        public void WorksCorrectlyWithCurlyBraces()
         {
             string projectBody = ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
@@ -471,7 +471,8 @@ public void TestCache2()
 
             try
             {
-                string problematicTmpPath = @"C:\Users\}\blabla\temp";
+                // Check if } do not cause it to crash due to usage of String.Format or such on code path
+                string problematicTmpPath = Path.Combine(originalTmp,  "}", "blabla", "temp");
                 Environment.SetEnvironmentVariable("TMP", problematicTmpPath);
                 Environment.SetEnvironmentVariable("TEMP", problematicTmpPath);
 
diff --git a/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs b/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
new file mode 100644
index 00000000000..ba4539b6d77
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/CacheSerialization_Tests.cs
@@ -0,0 +1,79 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Collections.Generic;
+using System.IO;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Xunit;
+
+#nullable disable
+
+namespace Microsoft.Build.UnitTests.BackEnd
+{
+    public class CacheSerialization_Tests
+    {
+        public static IEnumerable<object[]> CacheData
+        {
+            get
+            {
+                var configCache = new ConfigCache();
+                var brq1 = new BuildRequestConfiguration(
+                   1,
+                   new BuildRequestData("path1", new Dictionary<string, string> { ["a1"] = "b1" }, Constants.defaultToolsVersion, new[] { "target1" }, null),
+                   Constants.defaultToolsVersion);
+
+                var brq2 = new BuildRequestConfiguration(
+                    2,
+                    new BuildRequestData("path2", new Dictionary<string, string> { ["a2"] = "b2" }, Constants.defaultToolsVersion, new[] { "target2" }, null),
+                    Constants.defaultToolsVersion);
+                var brq3 = new BuildRequestConfiguration(
+                   3,
+                   new BuildRequestData("path3", new Dictionary<string, string> { ["a3"] = "b3" }, Constants.defaultToolsVersion, new[] { "target3" }, null),
+                   Constants.defaultToolsVersion);
+
+                configCache.AddConfiguration(brq1);
+                configCache.AddConfiguration(brq2);
+                configCache.AddConfiguration(brq3);
+
+                var resultsCache = new ResultsCache();
+                var request1 = new BuildRequest(1, 0, 1, new string[] { "target1" }, null, BuildEventContext.Invalid, null);
+                var request2 = new BuildRequest(2, 0, 2, new string[] { "target2" }, null, BuildEventContext.Invalid, null);
+                var request3 = new BuildRequest(3, 0, 3, new string[] { "target3" }, null, BuildEventContext.Invalid, null);
+
+                resultsCache.AddResult(new BuildResult(request1));
+                resultsCache.AddResult(new BuildResult(request2));
+                resultsCache.AddResult(new BuildResult(request3));
+
+                return new List<object[]>
+                {
+                    new object[] { configCache, resultsCache },
+                };
+            }
+        }
+
+        [Theory]
+        [MemberData(nameof(CacheData))]
+        public void OnlySerializeCacheEntryWithSmallestConfigId(object configCache, object resultsCache)
+        {
+            string cacheFile = null;
+            try
+            {
+                cacheFile = FileUtilities.GetTemporaryFile("MSBuildResultsCache");
+                Assert.Null(CacheSerialization.SerializeCaches((ConfigCache)configCache, (ResultsCache)resultsCache, cacheFile));
+
+                var result = CacheSerialization.DeserializeCaches(cacheFile);
+                Assert.True(result.ConfigCache.HasConfiguration(1));
+                Assert.False(result.ConfigCache.HasConfiguration(2));
+                Assert.False(result.ConfigCache.HasConfiguration(3));
+            }
+            finally
+            {
+                File.Delete(cacheFile);
+            }
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
index 7cfadc9a5e4..1593604ae74 100644
--- a/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/ConfigCache_Tests.cs
@@ -5,6 +5,7 @@
 using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Shouldly;
 using Xunit;
@@ -55,6 +56,38 @@ public static IEnumerable<object[]> CacheSerializationTestData
             }
         }
 
+        public static IEnumerable<object[]> CacheSerializationTestDataNoConfigs
+        {
+            get
+            {
+                yield return new[] { new ConfigCache() };
+            }
+        }
+
+        public static IEnumerable<object[]> CacheSerializationTestDataMultipleConfigs
+        {
+            get
+            {
+                var configCache = new ConfigCache();
+                var brq1 = new BuildRequestConfiguration(
+                  1,
+                  new BuildRequestData("path1", new Dictionary<string, string> { ["a1"] = "b1" }, Constants.defaultToolsVersion, new[] { "target1" }, null),
+                  Constants.defaultToolsVersion);
+                var brq2 = new BuildRequestConfiguration(
+                  2,
+                  new BuildRequestData("path2", new Dictionary<string, string> { ["a2"] = "b2" }, Constants.defaultToolsVersion, new[] { "target2" }, null),
+                  Constants.defaultToolsVersion);
+                var brq3 = new BuildRequestConfiguration(
+                  3,
+                  new BuildRequestData("path3", new Dictionary<string, string> { ["a3"] = "b3" }, Constants.defaultToolsVersion, new[] { "target3" }, null),
+                  Constants.defaultToolsVersion);
+                configCache.AddConfiguration(brq1.ShallowCloneWithNewId(1));
+                configCache.AddConfiguration(brq2.ShallowCloneWithNewId(2));
+                configCache.AddConfiguration(brq3.ShallowCloneWithNewId(3));
+                yield return new[] { configCache };
+            }
+        }
+
         [Theory]
         [MemberData(nameof(CacheSerializationTestData))]
         public void ConfigCacheShouldBeTranslatable(object obj)
@@ -84,5 +117,19 @@ public void ConfigCacheShouldBeTranslatable(object obj)
                 copy[initialConfiguration.ConfigurationId].ProjectInitialTargets.ShouldBe(initialConfiguration.ProjectInitialTargets);
             }
         }
+
+        [Theory]
+        [MemberData(nameof(CacheSerializationTestDataNoConfigs))]
+        public void GetSmallestConfigIdThrows(object obj)
+        {
+            Assert.Throws<InternalErrorException>(() => ((ConfigCache)obj).GetSmallestConfigId());
+        }
+
+        [Theory]
+        [MemberData(nameof(CacheSerializationTestDataMultipleConfigs))]
+        public void HappyGetSmallestConfigId(object obj)
+        {
+            Assert.Equal(1, ((ConfigCache)obj).GetSmallestConfigId());
+        }
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
index a22156f33f0..6497b641bbc 100644
--- a/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/IntrinsicTask_Tests.cs
@@ -457,7 +457,7 @@ public void ItemKeepMetadata()
 
 
         [Fact]
-        public void ItemKeepMetadataNotExistant()
+        public void ItemKeepMetadataNotExistent()
         {
             string content = ObjectModelHelpers.CleanupFileContents(@"
             <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
@@ -468,7 +468,7 @@ public void ItemKeepMetadataNotExistant()
                       <m2>m2</m2>
                       <m3>m3</m3>
                     </i1>
-                    <i2 Include='@(i1)' KeepMetadata='NONEXISTANT' />
+                    <i2 Include='@(i1)' KeepMetadata='NONEXISTENT' />
                 </ItemGroup>
             </Target>
             </Project>");
@@ -3325,7 +3325,7 @@ public void RemoveItemInImportedFile()
 
             try
             {
-                importedFile = FileUtilities.GetTemporaryFile();
+                importedFile = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(importedFile, ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                   <ItemGroup>
@@ -3363,7 +3363,7 @@ public void ModifyItemInImportedFile()
 
             try
             {
-                importedFile = FileUtilities.GetTemporaryFile();
+                importedFile = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(importedFile, ObjectModelHelpers.CleanupFileContents(@"
                 <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                   <ItemGroup>
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index 0226f87e7a7..c802415a697 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -700,6 +700,78 @@ public void VariousPropertiesToMSBuildTask()
             }
         }
 
+
+        /// <summary>
+        /// Include and Exclude items outside and inside targets should result in same behavior on
+        ///  platform specific paths.
+        /// </summary>
+        [Fact]
+        public void ItemsIncludeExcludePathsCombinations()
+        {
+            string projectFile = null;
+
+            try
+            {
+                projectFile = ObjectModelHelpers.CreateTempFileOnDisk(@"
+                    <Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+                      <ItemGroup>
+                        <iout1 Include='a/b.foo' Exclude='a\b.foo' />
+                        <iout2 Include='a\b.foo' Exclude='a/b.foo' />
+                        <iout3 Include='a/b.foo' Exclude='a/b.foo' />
+                        <iout4 Include='a\b.foo' Exclude='a\b.foo' />
+                        <iout5 Include='a/b.foo' Exclude='a\c.foo' />
+                        <iout6 Include='a\b.foo' Exclude='a\c.foo' />
+                      </ItemGroup>
+                      <Target Name='a'>
+                        <ItemGroup>
+                          <iin1 Include='a/b.foo' Exclude='a\b.foo' />
+                          <iin2 Include='a\b.foo' Exclude='a/b.foo' />
+                          <iin3 Include='a/b.foo' Exclude='a/b.foo' />
+                          <iin4 Include='a\b.foo' Exclude='a\b.foo' />
+                          <iin5 Include='a/b.foo' Exclude='a\c.foo' />
+                          <iin6 Include='a\b.foo' Exclude='a\c.foo' />
+                        </ItemGroup>
+                        <Message Text='iout1=[@(iout1)]' Importance='High' />
+                        <Message Text='iout2=[@(iout2)]' Importance='High' />
+                        <Message Text='iout3=[@(iout3)]' Importance='High' />
+                        <Message Text='iout4=[@(iout4)]' Importance='High' />
+                        <Message Text='iout5=[@(iout5)]' Importance='High' />
+                        <Message Text='iout6=[@(iout6)]' Importance='High' />
+
+                        <Message Text='iin1=[@(iin1)]' Importance='High' />
+                        <Message Text='iin2=[@(iin2)]' Importance='High' />
+                        <Message Text='iin3=[@(iin3)]' Importance='High' />
+                        <Message Text='iin4=[@(iin4)]' Importance='High' />
+                        <Message Text='iin5=[@(iin5)]' Importance='High' />
+                        <Message Text='iin6=[@(iin6)]' Importance='High' />
+                      </Target>
+                    </Project>
+                ");
+
+                MockLogger logger = new MockLogger(_testOutput);
+                ObjectModelHelpers.BuildTempProjectFileExpectSuccess(projectFile, logger);
+
+                Console.WriteLine(logger.FullLog);
+
+                logger.AssertLogContains("iout1=[]");
+                logger.AssertLogContains("iout2=[]");
+                logger.AssertLogContains("iout3=[]");
+                logger.AssertLogContains("iout4=[]");
+                logger.AssertLogContains("iout5=[a/b.foo]");
+                logger.AssertLogContains($"iout6=[a{Path.DirectorySeparatorChar}b.foo]");
+                logger.AssertLogContains("iin1=[]");
+                logger.AssertLogContains("iin2=[]");
+                logger.AssertLogContains("iin3=[]");
+                logger.AssertLogContains("iin4=[]");
+                logger.AssertLogContains("iin5=[a/b.foo]");
+                logger.AssertLogContains($"iin6=[a{Path.DirectorySeparatorChar}b.foo]");
+            }
+            finally
+            {
+                File.Delete(projectFile);
+            }
+        }
+
         /// <summary>
         /// Check if passing different global properties via metadata works
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/MockLoggingService.cs b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
index bed66bdaaf2..681e0d155c4 100644
--- a/src/Build.UnitTests/BackEnd/MockLoggingService.cs
+++ b/src/Build.UnitTests/BackEnd/MockLoggingService.cs
@@ -633,6 +633,11 @@ public ICollection<string> GetWarningsAsMessages(BuildEventContext context)
             throw new NotImplementedException();
         }
 
+        public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
+        {
+            throw new NotImplementedException();
+        }
+
         #endregion
     }
 }
diff --git a/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs b/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs
index b963f89756d..b1c4ccd843f 100644
--- a/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs
+++ b/src/Build.UnitTests/BackEnd/MockSdkResolverService.cs
@@ -21,7 +21,7 @@ public void ClearCaches()
         {
         }
 
-        public Build.BackEnd.SdkResolution.SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        public Build.BackEnd.SdkResolution.SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             return null;
         }
diff --git a/src/Build.UnitTests/BackEnd/OnError_Tests.cs b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
index 164bbd71800..bc8849c9dfe 100644
--- a/src/Build.UnitTests/BackEnd/OnError_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/OnError_Tests.cs
@@ -583,6 +583,7 @@ public void ErrorWhenTaskFailsWithoutLoggingErrorEscapeHatch(string failureRespo
             else
             {
                 logger.ErrorCount.ShouldBe(0);
+                logger.AssertLogContains( String.Format(MockLogger.GetString("TaskReturnedFalseButDidNotLogError"), "FailingTask") );
             }
         }
 
diff --git a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
index 87d3efd618d..e63f9733bec 100644
--- a/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/SdkResolverService_Tests.cs
@@ -48,7 +48,7 @@ public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
 
             SdkReference sdk = new SdkReference("notfound", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Success.ShouldBeFalse();
             result.ShouldNotBeNull();
@@ -61,7 +61,15 @@ public void AssertAllResolverErrorsLoggedWhenSdkNotResolved()
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver2 running");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldNotContain("MockSdkResolverWithResolvableSdkPattern1 running");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern2 running");
-            _logger.Errors.Select(i => i.Message).ShouldBe(new [] { "ERROR4", "ERROR1", "ERROR2" });
+
+            // First error is a generic "we failed" message.
+            _logger.Errors[0].Message.ShouldBe(ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("FailedToResolveSDK", "notfound", string.Join($"{Environment.NewLine}  ", new[] {
+                "ERROR4",
+                ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverReturnedNull", "MockResolverReturnsNull"),
+                "ERROR1",
+                "ERROR2",
+                "notfound"
+            })));
             _logger.Warnings.Select(i => i.Message).ShouldBe(new[] { "WARNING4", "WARNING2" });
         }
 
@@ -83,7 +91,7 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
                             ))
                 });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Path.ShouldBe("path");
 
@@ -99,7 +107,7 @@ public void AssertResolverThrows()
             SdkReference sdk = new SdkReference("1sdkName", "version1", "minimumVersion");
 
             // When an SDK resolver throws, the expander will catch it and stop the build.
-            SdkResolverException e = Should.Throw<SdkResolverException>(() => SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false));
+            SdkResolverException e = Should.Throw<SdkResolverException>(() => SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true));
             e.Resolver.Name.ShouldBe("MockSdkResolverThrows");
             e.Sdk.Name.ShouldBe("1sdkName");
         }
@@ -114,7 +122,7 @@ public void AssertSecondResolverWithPatternCanResolve()
 
             SdkReference sdk = new SdkReference("2sdkName", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Path.ShouldBe("resolverpathwithresolvablesdkpattern2");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern2 running");
@@ -131,7 +139,7 @@ public void AssertFirstResolverCanResolve()
 
             SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Path.ShouldBe("resolverpath1");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
@@ -152,7 +160,7 @@ public void AssertFirstResolverWithPatternCantResolveChangeWave17_4()
 
                 SdkReference sdk = new SdkReference("1sdkName", "referencedVersion", "minimumVersion");
 
-                var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+                var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
                 result.Path.ShouldBe("resolverpath1");
                 _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolver1 running");
@@ -170,7 +178,7 @@ public void AssertFirstResolverWithPatternCanResolve()
 
             SdkReference sdk = new SdkReference("11sdkName", "referencedVersion", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Path.ShouldBe("resolverpathwithresolvablesdkpattern1");
             _logger.BuildMessageEvents.Select(i => i.Message).ShouldContain("MockSdkResolverWithResolvableSdkPattern1 running");
@@ -186,7 +194,7 @@ public void AssertFirstResolverErrorsSupressedWhenResolved()
             // be logged because MockSdkResolver2 will succeed.
             SdkReference sdk = new SdkReference("2sdkName", "version2", "minimumVersion");
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Path.ShouldBe("resolverpath2");
 
@@ -209,10 +217,10 @@ public void AssertResolverHasStatePreserved()
             SdkReference sdk = new SdkReference("othersdk", "1.0", "minimumVersion");
 
             // First call should not know state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true).Path.ShouldBe("resolverpath");
 
             // Second call should have received state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe(MockSdkResolverWithState.Expected);
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true).Path.ShouldBe(MockSdkResolverWithState.Expected);
         }
 
         [Fact]
@@ -225,10 +233,10 @@ public void AssertResolverStateNotPreserved()
             SdkReference sdk = new SdkReference("othersdk", "1.0", "minimumVersion");
 
             // First call should not know state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true).Path.ShouldBe("resolverpath");
 
             // Second call should have received state
-            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false).Path.ShouldBe("resolverpath");
+            SdkResolverService.Instance.ResolveSdk(submissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true).Path.ShouldBe("resolverpath");
         }
 
         [Theory]
@@ -269,13 +277,13 @@ public void CachingWrapperShouldWarnWhenMultipleVersionsAreReferenced()
                     resolver
                 });
 
-            var result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
             resolver.ResolvedCalls.Count.ShouldBe(1);
             result.Path.ShouldBe("path");
             result.Version.ShouldBe("1.0.0");
             _logger.WarningCount.ShouldBe(0);
 
-            result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, new SdkReference("foo", "2.0.0", null), _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            result = service.ResolveSdk(BuildEventContext.InvalidSubmissionId, new SdkReference("foo", "2.0.0", null), _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
             resolver.ResolvedCalls.Count.ShouldBe(1);
             result.Path.ShouldBe("path");
             result.Version.ShouldBe("1.0.0");
@@ -351,7 +359,7 @@ public void SdkResolverCanReturnNoPaths(bool includePropertiesAndItems)
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Success.ShouldBeTrue();
             result.Path.ShouldBeNull();
@@ -388,7 +396,7 @@ public void SdkResultCanReturnPropertiesAndItems()
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Success.ShouldBeTrue();
             result.Path.ShouldBe(expectedPath);
@@ -435,7 +443,7 @@ public void SdkResultCanReturnMultiplePaths(bool includePropertiesAndItems)
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Success.ShouldBeTrue();
 
@@ -481,7 +489,7 @@ public void AssertResolutionWarnsIfResolvedVersionIsDifferentFromReferencedVersi
 
             SdkResolverService.Instance.InitializeForTests(null, new List<SdkResolver>() { resolver });
 
-            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false);
+            var result = SdkResolverService.Instance.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true);
 
             result.Success.ShouldBeTrue();
 
@@ -529,7 +537,7 @@ public void CachingWrapperShouldOnlyResolveOnce()
             Parallel.For(
                 0,
                 10,
-                _ => service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false));
+                _ => service.ResolveSdk(BuildEventContext.InvalidSubmissionId, sdk, _loggingContext, new MockElementLocation("file"), "sln", "projectPath", interactive: false, isRunningInVisualStudio: false, failOnUnresolvedSdk: true));
 
             var result = resolver.ResolvedCalls.ShouldHaveSingleItem();
 
@@ -567,7 +575,8 @@ public void InteractiveIsSetForResolverContext()
                 "projectPath",
                 // Pass along interactive and expect it to be received in the SdkResolverContext
                 interactive: true,
-                false);
+                isRunningInVisualStudio: false,
+                failOnUnresolvedSdk: true);
 
             interactive.ShouldBeTrue();
         }
@@ -597,7 +606,8 @@ public void IsRunningInVisualStudioIsSetForResolverContext()
                 "projectPath",
                 false,
                 // Pass along isRunningInVisualStudio and expect it to be received in the SdkResolverContext
-                isRunningInVisualStudio: true);
+                isRunningInVisualStudio: true,
+                failOnUnresolvedSdk: true);
 
             isRunningInVisualStudio.ShouldBeTrue();
         }
@@ -776,7 +786,7 @@ public override SdkResultBase Resolve(SdkReference sdkReference, SdkResolverCont
             {
                 if (sdkReference.Name.Equals("notfound"))
                 {
-                    return null;
+                    return factory.IndicateFailure(new string[] { "notfound" });
                 }
                 if (resolverContext.State != null)
                 {
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 102facdb9fb..9c3443db145 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -872,28 +872,28 @@ bool includeOutput2
             {
                 if (input1Time != null)
                 {
-                    input1 = FileUtilities.GetTemporaryFile();
+                    input1 = FileUtilities.GetTemporaryFileName();
                     File.WriteAllText(input1, String.Empty);
                     File.SetLastWriteTime(input1, (DateTime)input1Time);
                 }
 
                 if (input2Time != null)
                 {
-                    input2 = FileUtilities.GetTemporaryFile();
+                    input2 = FileUtilities.GetTemporaryFileName();
                     File.WriteAllText(input2, String.Empty);
                     File.SetLastWriteTime(input2, (DateTime)input2Time);
                 }
 
                 if (output1Time != null)
                 {
-                    output1 = FileUtilities.GetTemporaryFile();
+                    output1 = FileUtilities.GetTemporaryFileName();
                     File.WriteAllText(output1, String.Empty);
                     File.SetLastWriteTime(output1, (DateTime)output1Time);
                 }
 
                 if (output2Time != null)
                 {
-                    output2 = FileUtilities.GetTemporaryFile();
+                    output2 = FileUtilities.GetTemporaryFileName();
                     File.WriteAllText(output2, String.Empty);
                     File.SetLastWriteTime(output2, (DateTime)output2Time);
                 }
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
index 76202f316ef..153cf643cec 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilder_Tests.cs
@@ -71,7 +71,7 @@ public void TasksAreDiscoveredWhenTaskConditionTrue()
             string projectFileContents = ObjectModelHelpers.CleanupFileContents(
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                       <Target Name='t'>
-                         <NonExistantTask Condition=""'1'=='1'""/>
+                         <NonExistentTask Condition=""'1'=='1'""/>
                          <Message Text='Made it'/>
                       </Target>
                       </Project>");
@@ -97,7 +97,7 @@ public void TasksNotDiscoveredWhenTaskConditionFalse()
             string projectFileContents = ObjectModelHelpers.CleanupFileContents(
                 @"<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
                       <Target Name='t'>
-                         <NonExistantTask Condition=""'1'=='2'""/>
+                         <NonExistentTask Condition=""'1'=='2'""/>
                          <Message Text='Made it'/>
                       </Target>
                       </Project>");
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index ed7e39fdcca..a858d3fb9a4 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -163,10 +163,10 @@ public void ValidateNoParameters_MissingRequired()
         /// Validate that setting a non-existent parameter fails, but does not throw an exception.
         /// </summary>
         [Fact]
-        public void ValidateNonExistantParameter()
+        public void ValidateNonExistentParameter()
         {
             var parameters = new Dictionary<string, (string, ElementLocation)>(StringComparer.OrdinalIgnoreCase);
-            parameters["NonExistantParam"] = ("foo", ElementLocation.Create("foo.proj"));
+            parameters["NonExistentParam"] = ("foo", ElementLocation.Create("foo.proj"));
             Assert.False(_host.SetTaskParameters(parameters));
         }
 
@@ -205,7 +205,7 @@ public void TestSetBoolParamEmptyAttribute()
         [Fact]
         public void TestSetBoolParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("BoolParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("BoolParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -214,7 +214,7 @@ public void TestSetBoolParamEmptyProperty()
         [Fact]
         public void TestSetBoolParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("BoolParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("BoolParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -254,7 +254,7 @@ public void TestSetBoolArrayParamEmptyAttribute()
         [Fact]
         public void TestSetBoolArrayParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("BoolArrayParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("BoolArrayParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -263,7 +263,7 @@ public void TestSetBoolArrayParamEmptyProperty()
         [Fact]
         public void TestSetBoolArrayParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("BoolArrayParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("BoolArrayParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -303,7 +303,7 @@ public void TestSetIntParamEmptyAttribute()
         [Fact]
         public void TestSetIntParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("IntParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("IntParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -312,7 +312,7 @@ public void TestSetIntParamEmptyProperty()
         [Fact]
         public void TestSetIntParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("IntParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("IntParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -357,7 +357,7 @@ public void TestSetIntArrayParamEmptyAttribute()
         [Fact]
         public void TestSetIntArrayParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("IntArrayParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("IntArrayParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -366,7 +366,7 @@ public void TestSetIntArrayParamEmptyProperty()
         [Fact]
         public void TestSetIntArrayParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("IntArrayParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("IntArrayParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -406,7 +406,7 @@ public void TestSetStringParamEmptyAttribute()
         [Fact]
         public void TestSetStringParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("StringParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("StringParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -415,7 +415,7 @@ public void TestSetStringParamEmptyProperty()
         [Fact]
         public void TestSetStringParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("StringParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("StringParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -455,7 +455,7 @@ public void TestSetStringArrayParamEmptyAttribute()
         [Fact]
         public void TestSetStringArrayParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("StringArrayParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("StringArrayParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -464,7 +464,7 @@ public void TestSetStringArrayParamEmptyProperty()
         [Fact]
         public void TestSetStringArrayParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("StringArrayParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("StringArrayParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -516,7 +516,7 @@ public void TestSetItemParamEmptyAttribute()
         [Fact]
         public void TestSetItemParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("ItemParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("ItemParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -525,7 +525,7 @@ public void TestSetItemParamEmptyProperty()
         [Fact]
         public void TestSetItemParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("ItemParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("ItemParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -583,7 +583,7 @@ public void TestSetItemArrayParamEmptyAttribute()
         [Fact]
         public void TestSetItemArrayParamEmptyProperty()
         {
-            ValidateTaskParameterNotSet("ItemArrayParam", "$(NonExistantProperty)");
+            ValidateTaskParameterNotSet("ItemArrayParam", "$(NonExistentProperty)");
         }
 
         /// <summary>
@@ -592,7 +592,7 @@ public void TestSetItemArrayParamEmptyProperty()
         [Fact]
         public void TestSetItemArrayParamEmptyItem()
         {
-            ValidateTaskParameterNotSet("ItemArrayParam", "@(NonExistantItem)");
+            ValidateTaskParameterNotSet("ItemArrayParam", "@(NonExistentItem)");
         }
 
         #endregion
@@ -942,7 +942,7 @@ public void TestNonexistantOutput()
         {
             Assert.Throws<InvalidProjectFileException>(() =>
             {
-                Assert.False(_host.GatherTaskOutputs("NonExistantOutput", ElementLocation.Create(".", 1, 1), true, "output"));
+                Assert.False(_host.GatherTaskOutputs("NonExistentOutput", ElementLocation.Create(".", 1, 1), true, "output"));
             }
            );
         }
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index dcb4529c011..eb5211d2908 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -207,6 +207,68 @@ public void BinaryLoggerShouldEmbedFilesViaTaskOutput()
             zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
         }
 
+        [Fact]
+        public void BinaryLoggerShouldEmbedSymlinkFilesViaTaskOutput()
+        {
+            string testFileName = "foobar.txt";
+            string symlinkName = "symlink1.txt";
+            string symlinkLvl2Name = "symlink2.txt";
+            string emptyFileName = "empty.txt";
+            TransientTestFolder testFolder = _env.DefaultTestDirectory.CreateDirectory("TestDir");
+            TransientTestFolder testFolder2 = _env.DefaultTestDirectory.CreateDirectory("TestDir2");
+            TransientTestFile testFile = testFolder.CreateFile(testFileName, string.Join(Environment.NewLine, new[] { "123", "456" }));
+            string symlinkPath = Path.Combine(testFolder2.Path, symlinkName);
+            string symlinkLvl2Path = Path.Combine(testFolder2.Path, symlinkLvl2Name);
+            string emptyFile = testFolder.CreateFile(emptyFileName).Path;
+
+            string errorMessage = string.Empty;
+            Assert.True(NativeMethodsShared.MakeSymbolicLink(symlinkPath, testFile.Path, ref errorMessage), errorMessage);
+            Assert.True(NativeMethodsShared.MakeSymbolicLink(symlinkLvl2Path, symlinkPath, ref errorMessage), errorMessage);
+
+            using var buildManager = new BuildManager();
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={_logFile}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+            var testProjectFmt = @"
+<Project>
+    <Target Name=""Build"" Inputs=""{0}"" Outputs=""testtaskoutputfile.txt"">
+        <ReadLinesFromFile
+            File=""{0}"" >
+            <Output
+                TaskParameter=""Lines""
+                ItemName=""ItemsFromFile""/>
+        </ReadLinesFromFile>
+        <WriteLinesToFile File=""testtaskoutputfile.txt"" Lines=""@(ItemsFromFile);abc;def;ghi""/>
+        <CreateItem Include=""testtaskoutputfile.txt"">
+            <Output TaskParameter=""Include"" ItemName=""EmbedInBinlog"" />
+        </CreateItem>
+        <CreateItem Include=""{0}"">
+            <Output TaskParameter=""Include"" ItemName=""EmbedInBinlog"" />
+        </CreateItem>
+        <CreateItem Include=""{1}"">
+            <Output TaskParameter=""Include"" ItemName=""EmbedInBinlog"" />
+        </CreateItem>
+        <CreateItem Include=""{2}"">
+            <Output TaskParameter=""Include"" ItemName=""EmbedInBinlog"" />
+        </CreateItem>
+    </Target>
+</Project>";
+            var testProject = string.Format(testProjectFmt, symlinkPath, symlinkLvl2Path, emptyFile);
+            ObjectModelHelpers.BuildProjectExpectSuccess(testProject, binaryLogger);
+            var projectImportsZipPath = Path.ChangeExtension(_logFile, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith("testtaskoutputfile.txt"));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkName));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(symlinkLvl2Name));
+            zipArchive.Entries.ShouldContain(zE => zE.Name.EndsWith(emptyFileName));
+        }
+
         [Fact]
         public void BinaryLoggerShouldNotThrowWhenMetadataCannotBeExpanded()
         {
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index dd5d0c8a1fc..177526e3650 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -305,6 +305,14 @@ public void RoundtripBuildMessageEventArgs(bool useArguments)
                 e => string.Join(", ", e.RawArguments ?? Array.Empty<object>()));
         }
 
+        [Fact]
+        public void RoundtripResponseFileUsedEventArgs()
+        {
+            var args = new ResponseFileUsedEventArgs("MSBuild.rsp"); 
+            Roundtrip(args,
+                e => e.ResponseFilePath);
+        }
+         
         [Fact]
         public void RoundtripCriticalBuildMessageEventArgs()
         {
diff --git a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
index 1c797174b5c..38dcb87dd5d 100644
--- a/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
+++ b/src/Build.UnitTests/Construction/ElementLocation_Tests.cs
@@ -403,7 +403,7 @@ public void SaveReadOnly4()
             var doc = new XmlDocumentWithLocation(loadAsReadOnly: true);
             doc.Load(_pathToCommonTargets);
             Assert.True(doc.IsReadOnly);
-            using (XmlWriter wr = XmlWriter.Create(new FileStream(FileUtilities.GetTemporaryFile(), FileMode.Create)))
+            using (XmlWriter wr = XmlWriter.Create(new FileStream(FileUtilities.GetTemporaryFileName(), FileMode.Create)))
             {
                 Assert.Throws<InvalidOperationException>(() =>
                 {
@@ -421,7 +421,7 @@ private string GetLocations(string content, bool readOnly)
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(file, content);
                 var doc = new XmlDocumentWithLocation(loadAsReadOnly: readOnly);
                 doc.Load(file);
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index 16c1c196883..819688c22a2 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -566,6 +566,7 @@ public void ParseNestedEtpProjectMultipleLevel()
                         </References>
                     </GENERAL>
                 </EFPROJECT>";
+
                 // Create the directory for the third project
                 Directory.CreateDirectory(Path.Combine(FileUtilities.TempFileDirectory, "ETPProjUpgradeTest"));
                 File.WriteAllText(proj3Path, etpProjContent);
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 6c726a5476d..92a1591a313 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -1947,8 +1947,7 @@ public void SolutionGeneratorCanEmitSolutions()
         [Trait("Category", "mono-osx-failing")]
         public void TestSkipInvalidConfigurationsCase()
         {
-            string tmpFileName = FileUtilities.GetTemporaryFile();
-            File.Delete(tmpFileName);
+            string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
             string solutionContents =
@@ -2024,8 +2023,7 @@ public void TestSkipInvalidConfigurationsCase()
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
         public void BadFrameworkMonkierExpectBuildToFail()
         {
-            string tmpFileName = FileUtilities.GetTemporaryFile();
-            File.Delete(tmpFileName);
+            string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
             string solutionFileContents =
@@ -2112,8 +2110,7 @@ public void BadFrameworkMonkierExpectBuildToFail()
         [Fact(Skip = "https://github.com/dotnet/msbuild/issues/515")]
         public void BadFrameworkMonkierExpectBuildToFail2()
         {
-            string tmpFileName = FileUtilities.GetTemporaryFile();
-            File.Delete(tmpFileName);
+            string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
             string solutionFileContents =
@@ -2200,8 +2197,7 @@ public void BadFrameworkMonkierExpectBuildToFail2()
         [Fact]
         public void TestTargetFrameworkVersionGreaterThan4()
         {
-            string tmpFileName = FileUtilities.GetTemporaryFile();
-            File.Delete(tmpFileName);
+            string tmpFileName = FileUtilities.GetTemporaryFileName();
             string projectFilePath = tmpFileName + ".sln";
 
             string solutionFileContents =
diff --git a/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs b/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
index 94626b132d4..3d766374a9e 100644
--- a/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
+++ b/src/Build.UnitTests/Definition/ItemDefinitionGroup_Tests.cs
@@ -1188,7 +1188,7 @@ public void DefinitionInImportedFile()
 
             try
             {
-                importedFile = FileUtilities.GetTemporaryFile();
+                importedFile = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(importedFile, @"
                 <Project ToolsVersion='msbuilddefaulttoolsversion'>
                   <ItemDefinitionGroup>
@@ -1710,7 +1710,7 @@ public void MSBuildCallDoesNotAffectCallingProjectsDefinitions()
 
             try
             {
-                otherProject = FileUtilities.GetTemporaryFile();
+                otherProject = FileUtilities.GetTemporaryFileName();
                 string otherProjectContent = @"<Project ToolsVersion=""msbuilddefaulttoolsversion"">
                   <ItemGroup>
                     <i Include='i1'/>
@@ -1766,7 +1766,7 @@ public void DefaultMetadataTravelWithTargetOutputs()
 
             try
             {
-                otherProject = FileUtilities.GetTemporaryFile();
+                otherProject = FileUtilities.GetTemporaryFileName();
                 string otherProjectContent = @"<Project ToolsVersion=""msbuilddefaulttoolsversion"">
                   <ItemGroup>
                     <i Include='i1'>
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 51d649107b5..43e9e639f96 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -50,6 +50,69 @@ public void Dispose()
             GC.Collect();
         }
 
+        [Theory]
+        [MemberData(nameof(ImportLoadingScenarioTestData))]
+        public void VerifyLoadingImportScenarios(string importParameter, bool shouldSucceed)
+        {
+            using (TestEnvironment env = TestEnvironment.Create())
+            {
+                TransientTestFolder existentDirectory = env.CreateFolder(createFolder: true);
+                TransientTestFile realFile = env.CreateFile(existentDirectory, "realFile.csproj", @"<Project> </Project>");
+                TransientTestFile projectFile = env.CreateFile("project.proj", @$"
+<Project>
+  <Import {importParameter.Replace("realFolder", existentDirectory.Path)} />
+
+  <Target Name=""MyTarget"">
+    <Message Text=""Target working!"" />
+  </Target>
+</Project>
+");
+                bool result = false;
+                try
+                {
+                    Project project = new(projectFile.Path);
+                    MockLogger logger = new();
+                    result = project.Build(logger);
+                }
+                catch (InvalidProjectFileException) { }
+                result.ShouldBe(shouldSucceed);
+            }
+        }
+
+        // Some of these are also tested elsewhere, but this consolidates related tests in one spot.
+        public static IEnumerable<object[]> ImportLoadingScenarioTestData
+        {
+            get
+            {
+                // This first section tests our behavior if a folder does not exist. Conditions and whether there are wildcards should affect whether it fails if it fails to find a file.
+                yield return new object[] { $@"Project=""{Path.Combine("nonexistentDirectory", "projectThatDoesNotExist.csproj")}"" Condition=""Exists('{Path.Combine("nonexistentDirectory", "projectThatDoesNotExist.csproj")}')""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("nonexistentDirectory", "projectThatDoesNotExist.csproj")}"" Condition=""'true'""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("nonexistentDirectory", "projectThatDoesNotExist.csproj")}""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("nonexistentDirectory", "*.*proj")}""", true };
+
+                // This section tests if the folder does exist, but the project does not.
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "projectThatDoesNotExist.csproj")}"" Condition=""Exists('{Path.Combine("realFolder", "projectThatDoesNotExist.csproj")}')""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "projectThatDoesNotExist.csproj")}"" Condition=""'true'""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "projectThatDoesNotExist.csproj")}""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "*.*proj")}""", true };
+
+                // This tests if the folder and the file exist.
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "realFile.csproj")}"" Condition=""Exists('{Path.Combine("realFolder", "realFile.csproj")}')""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "realFile.csproj")}"" Condition=""'true'""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "realFile.csproj")}""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("realFolder", "*.*proj")}""", true };
+
+                // If we fail to find a particular import along one project path, we have a few properties that can be expanded in different ways, including VSToolsPath. In other words,
+                // if the property isn't defined to somewhere that exists, we may still find it in a fallback path. Error behavior in this case is more complicated, as the file may
+                // exist along one search path but not another, in which case we should not error.
+                yield return new object[] { $@"Project=""{Path.Combine("$(VSToolsPath)", "nonexistentDirectory", "projectThatDoesNotExist.csproj")}"" Condition=""Exists('{Path.Combine("$(VSToolsPath)", "nonexistentDirectory", "projectThatDoesNotExist.csproj")}')""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("$(VSToolsPath)", "nonexistentDirectory", "projectThatDoesNotExist.csproj")}"" Condition=""'true'""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("$(VSToolsPath)", "nonexistentDirectory", "projectThatDoesNotExist.csproj")}""", false };
+                yield return new object[] { $@"Project=""{Path.Combine("$(VSToolsPath)", "nonexistentDirectory", "*.*proj")}""", true };
+                yield return new object[] { $@"Project=""{Path.Combine("$(VSToolsPath)", "*.*proj")}""", true };
+            }
+        }
+
         /// <summary>
         /// Verify Exist condition used in Import or ImportGroup elements will succeed when in-memory project is available inside projectCollection.
         /// </summary>
@@ -725,7 +788,7 @@ public void ImportsOnlyIncludedOnce()
 
             try
             {
-                importPath = FileUtilities.GetTemporaryFile();
+                importPath = FileUtilities.GetTemporaryFileName();
 
                 string import = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns='msbuildnamespace' >
@@ -787,9 +850,9 @@ public void MultipleImportsVerifyImportsIncludingDuplicates()
 
             try
             {
-                importPath = FileUtilities.GetTemporaryFile();
-                importPath2 = FileUtilities.GetTemporaryFile();
-                importPath3 = FileUtilities.GetTemporaryFile();
+                importPath = FileUtilities.GetTemporaryFileName();
+                importPath2 = FileUtilities.GetTemporaryFileName();
+                importPath3 = FileUtilities.GetTemporaryFileName();
 
                 string import = ObjectModelHelpers.CleanupFileContents(@"
                     <Project ToolsVersion=""msbuilddefaulttoolsversion"" xmlns='msbuildnamespace' >
@@ -863,8 +926,8 @@ public void RecordDuplicateButNotCircularImportsWithCircularImports()
 
             try
             {
-                importPath1 = FileUtilities.GetTemporaryFile();
-                importPath2 = FileUtilities.GetTemporaryFile();
+                importPath1 = FileUtilities.GetTemporaryFileName();
+                importPath2 = FileUtilities.GetTemporaryFileName();
 
                 // "import1" imports "import2" and vice versa.
                 string import1 = ObjectModelHelpers.CleanupFileContents(@"
@@ -923,8 +986,8 @@ public void RejectCircularImportsWithCircularImports()
 
                 try
                 {
-                    importPath1 = FileUtilities.GetTemporaryFile();
-                    importPath2 = FileUtilities.GetTemporaryFile();
+                    importPath1 = FileUtilities.GetTemporaryFileName();
+                    importPath2 = FileUtilities.GetTemporaryFileName();
 
                     // "import1" imports "import2" and vice versa.
                     string import1 = ObjectModelHelpers.CleanupFileContents(@"
@@ -1618,7 +1681,7 @@ public void ItemPredecessorToItemViaTransform()
                           <h Include='h1'>
                             <m>1</m>
                           </h>
-                          <i Include=""@(h->'%(identity))"">
+                          <i Include=""@(h->'%(identity)')"">
                             <m>2;%(m)</m>
                           </i>
                         </ItemGroup>
@@ -1628,8 +1691,8 @@ public void ItemPredecessorToItemViaTransform()
 
             ProjectMetadata metadatum = project.GetItems("i").ElementAt(0).GetMetadata("m");
 
-            Assert.Equal("2;", metadatum.EvaluatedValue);
-            Assert.Null(metadatum.Predecessor);
+            Assert.Equal("2;1", metadatum.EvaluatedValue);
+            Assert.Equal("1", metadatum.Predecessor.EvaluatedValue);
         }
 
         [Fact]
@@ -1698,7 +1761,7 @@ public void ItemPredecessorsAndImports()
                 ProjectRootElement import = ProjectRootElement.Create();
                 import.AddItemDefinition("i").AddMetadata("m", "%(m);m1");
 
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 import.Save(file);
 
                 string content = ObjectModelHelpers.CleanupFileContents(@"
@@ -1844,7 +1907,7 @@ public void AllEvaluatedItems()
             try
             {
                 // Should include imported items
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement import = ProjectRootElement.Create(file);
                 import.AddItem("i", "i10");
                 import.Save();
@@ -1928,7 +1991,7 @@ public void AllEvaluatedPropertiesAndImports()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 ProjectRootElement import = ProjectRootElement.Create(file);
                 import.AddProperty("p", "0").Condition = "false";
                 import.AddProperty("p", "1");
diff --git a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
index df80473fc4e..21b48075b58 100644
--- a/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ImportFromMSBuildExtensionsPath_Tests.cs
@@ -276,7 +276,7 @@ public void ImportFromExtensionsPathWithWildCardNothingFound()
                     <Target Name='FromExtn'>
                         <Message Text='Running FromExtn'/>
                     </Target>
-                    <Import Project='$(MSBuildExtensionsPath)\non-existant\*.proj'/>
+                    <Import Project='$(MSBuildExtensionsPath)\non-existent\*.proj'/>
                 </Project>
                 ";
 
diff --git a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
index 7b82202bd2d..32b32efdea2 100644
--- a/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectRootElementCache_Tests.cs
@@ -117,7 +117,7 @@ public void GetProjectRootElementChangedOnDisk1()
             {
                 ProjectRootElementCache cache = new ProjectRootElementCache(true /* auto reload from disk */);
 
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
 
                 ProjectRootElement xml0 = ProjectRootElement.Create(path);
                 xml0.Save();
@@ -151,7 +151,7 @@ public void GetProjectRootElementChangedOnDisk2()
             {
                 ProjectRootElementCache cache = new ProjectRootElementCache(false /* do not auto reload from disk */);
 
-                path = FileUtilities.GetTemporaryFile();
+                path = FileUtilities.GetTemporaryFileName();
 
                 ProjectRootElement xml0 = ProjectRootElement.Create(path);
                 xml0.Save();
diff --git a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
index 397e67fbecc..ab6af32e07f 100644
--- a/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/ProjectStringCache_Tests.cs
@@ -42,7 +42,7 @@ Item group content
                     </Project>
                     ");
 
-                string path = FileUtilities.GetTemporaryFile();
+                string path = FileUtilities.GetTemporaryFileName();
 
                 try
                 {
@@ -100,7 +100,7 @@ Item group content
                     </Project>
                     ");
 
-                string path = FileUtilities.GetTemporaryFile();
+                string path = FileUtilities.GetTemporaryFileName();
 
                 try
                 {
@@ -176,7 +176,7 @@ public void RemovingFilesRemovesEntries()
                     </Project>
                     ");
 
-                string path = FileUtilities.GetTemporaryFile();
+                string path = FileUtilities.GetTemporaryFileName();
 
                 try
                 {
diff --git a/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs b/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
index 55f05760f31..3bb784def3e 100644
--- a/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/SimpleVersion_Tests.cs
@@ -213,9 +213,9 @@ public static void Equals_Other_ReturnsExpected(object version1Object, object ve
 
         public static IEnumerable<object[]> Parse_Valid_TestData()
         {
-            foreach (var prefix in new[] { "", "v",  "V"})
+            foreach (var prefix in new[] { "", "v", "V", " ", "\t", "\tv" })
             {
-                foreach (var suffix in new[] { "", "-pre", "-pre+metadata", "+metadata"})
+                foreach (var suffix in new[] { "", "-pre", "-pre+metadata", "+metadata", " ", "\n", "-pre \r\n" })
                 {
                     yield return new object[] { $"{prefix}1{suffix}", new SimpleVersion(1) };
                     yield return new object[] { $"{prefix}1.2{suffix}", new SimpleVersion(1, 2) };
@@ -257,7 +257,7 @@ public static IEnumerable<object[]> Parse_Invalid_TestData()
             yield return new object[] { "1.2.2147483648.4", typeof(FormatException) }; // Input contains a value > int.MaxValue
             yield return new object[] { "1.2.3.2147483648", typeof(FormatException) }; // Input contains a value > int.MaxValue
 
-            // System.Version allows whitespace around components, but we don't
+            // System.Version allows whitespace around components, but we only allow it at the beginning and end of the string.
             yield return new object[] { "2  .3.    4.  \t\r\n15  ", typeof(FormatException) };
             yield return new object[] { "   2  .3.    4.  \t\r\n15  ", typeof(FormatException) };
 
diff --git a/src/Build.UnitTests/ExpressionTree_Tests.cs b/src/Build.UnitTests/ExpressionTree_Tests.cs
index 7ab7ee1b247..4601c894936 100644
--- a/src/Build.UnitTests/ExpressionTree_Tests.cs
+++ b/src/Build.UnitTests/ExpressionTree_Tests.cs
@@ -103,7 +103,7 @@ public void FunctionTests()
             expander.Metadata = new StringMetadataTable(null);
             bool value;
 
-            string fileThatMustAlwaysExist = FileUtilities.GetTemporaryFile();
+            string fileThatMustAlwaysExist = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(fileThatMustAlwaysExist, "foo");
             string command = "Exists('" + fileThatMustAlwaysExist + "')";
             tree = p.Parse(command, ParserOptions.AllowAll, ElementLocation.EmptyLocation);
diff --git a/src/Build.UnitTests/FileLogger_Tests.cs b/src/Build.UnitTests/FileLogger_Tests.cs
index 96a16735cad..e7e6db9e2fe 100644
--- a/src/Build.UnitTests/FileLogger_Tests.cs
+++ b/src/Build.UnitTests/FileLogger_Tests.cs
@@ -58,7 +58,7 @@ public void BasicNoExistingFile()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 SetUpFileLoggerAndLogMessage("logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 VerifyFileContent(log, "message here");
 
@@ -105,7 +105,7 @@ public void SpecificVerbosity()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 FileLogger fl = new FileLogger();
                 EventSourceSink es = new EventSourceSink();
                 fl.Parameters = "verbosity=diagnostic;logfile=" + log;  // diagnostic specific setting
@@ -184,7 +184,7 @@ public void InvalidEncoding()
 
                 try
                 {
-                    log = GetTempFilename();
+                    log = FileUtilities.GetTemporaryFileName();
                     FileLogger fl = new FileLogger();
                     EventSourceSink es = new EventSourceSink();
                     fl.Parameters = "encoding=foo;logfile=" + log;
@@ -208,7 +208,7 @@ public void ValidEncoding()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 SetUpFileLoggerAndLogMessage("encoding=utf-16;logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 byte[] content = ReadRawBytes(log);
 
@@ -232,7 +232,7 @@ public void ValidEncoding2()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 SetUpFileLoggerAndLogMessage("encoding=utf-8;logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 byte[] content = ReadRawBytes(log);
 
@@ -278,7 +278,7 @@ public void BasicExistingFileNoAppend()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 WriteContentToFile(log);
                 SetUpFileLoggerAndLogMessage("logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 VerifyFileContent(log, "message here");
@@ -299,7 +299,7 @@ public void BasicExistingFileAppend()
 
             try
             {
-                log = GetTempFilename();
+                log = FileUtilities.GetTemporaryFileName();
                 WriteContentToFile(log);
                 SetUpFileLoggerAndLogMessage("append;logfile=" + log, new BuildMessageEventArgs("message here", null, null, MessageImportance.High));
                 VerifyFileContent(log, "existing content\nmessage here");
@@ -406,17 +406,6 @@ public void LogVerbosityMessage(LoggerVerbosity loggerVerbosity, bool shouldCont
             }
         }
 
-        /// <summary>
-        /// Gets a filename for a nonexistent temporary file.
-        /// </summary>
-        /// <returns></returns>
-        private string GetTempFilename()
-        {
-            string path = FileUtilities.GetTemporaryFile();
-            File.Delete(path);
-            return path;
-        }
-
         /// <summary>
         /// Writes a string to a file.
         /// </summary>
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 318c2c6f92f..4d28600f8a1 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -585,7 +585,7 @@ public void SolutionEdgesShouldNotOverwriteMultitargetingEdges()
             var graph = new ProjectGraph(_env.CreateFile("solution.sln", solutionContents).Path);
 
             var edges = graph.TestOnly_Edges.TestOnly_AsConfigurationMetadata();
-            edges.Count.ShouldBe(8);
+            edges.Count.ShouldBe(10);
 
             var node1 = GetFirstNodeWithProjectNumber(graph, 1);
             node1.ProjectReferences.Count.ShouldBe(3);
diff --git a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
index 65b1b86965c..fd6e5a951c3 100644
--- a/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
+++ b/src/Build.UnitTests/Graph/GraphTestingUtilities.cs
@@ -6,6 +6,7 @@
 using System.IO;
 using System.Linq;
 using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Shouldly;
@@ -36,40 +37,50 @@ internal static class GraphTestingUtilities
                                                                                             <AddTransitiveProjectReferencesInStaticGraph>true</AddTransitiveProjectReferencesInStaticGraph>
                                                                                          </PropertyGroup>";
 
-        public static void AssertOuterBuildAsNonRoot(
+        public static void AssertOuterBuild(
             ProjectGraphNode outerBuild,
             ProjectGraph graph,
             Dictionary<string, string> additionalGlobalProperties = null,
             int expectedInnerBuildCount = 2)
         {
-            additionalGlobalProperties ??= new Dictionary<string, string>();
+            additionalGlobalProperties ??= new Dictionary<string, string>(0);
 
             AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
 
-            outerBuild.ProjectReferences.ShouldBeEmpty();
-            outerBuild.ReferencingProjects.ShouldNotBeEmpty();
+            outerBuild.ProjectReferences.Count.ShouldBe(expectedInnerBuildCount);
 
-            foreach (var outerBuildReferencer in outerBuild.ReferencingProjects)
+            // Outer -> Inner build edges
+            foreach (ProjectGraphNode innerBuild in outerBuild.ProjectReferences)
             {
-                var innerBuilds =
-                    outerBuildReferencer.ProjectReferences.Where(
-                        p =>
-                            IsInnerBuild(p) 
-                            && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath).ToArray();
+                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
+
+                ProjectItemInstance edge = graph.TestOnly_Edges[(outerBuild, innerBuild)];
+                edge.DirectMetadataCount.ShouldBe(1);
+
+                string expectedPropertiesMetadata = $"{InnerBuildPropertyName}={innerBuild.ProjectInstance.GlobalProperties[InnerBuildPropertyName]}";
+                edge.GetMetadata("Properties").EvaluatedValue.ShouldBe(expectedPropertiesMetadata);
+            }
+
+            // Ensure edges were added directly to the inner builds
+            foreach (ProjectGraphNode outerBuildReferencer in outerBuild.ReferencingProjects)
+            {
+                ProjectGraphNode[] innerBuilds = outerBuildReferencer.ProjectReferences
+                    .Where(p => IsInnerBuild(p) && p.ProjectInstance.FullPath == outerBuild.ProjectInstance.FullPath)
+                    .ToArray();
 
                 innerBuilds.Length.ShouldBe(expectedInnerBuildCount);
 
-                foreach (var innerBuild in innerBuilds)
+                foreach (ProjectGraphNode innerBuild in innerBuilds)
                 {
                     AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
 
                     innerBuild.ReferencingProjects.ShouldContain(outerBuildReferencer);
-                    innerBuild.ReferencingProjects.ShouldNotContain(outerBuild);
+                    innerBuild.ReferencingProjects.ShouldContain(outerBuild);
 
-                    graph.TestOnly_Edges.HasEdge((outerBuild, innerBuild)).ShouldBeFalse();
+                    graph.TestOnly_Edges.HasEdge((outerBuild, innerBuild)).ShouldBeTrue();
 
-                    var edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
-                    var edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
+                    ProjectItemInstance edgeToOuterBuild = graph.TestOnly_Edges[(outerBuildReferencer, outerBuild)];
+                    ProjectItemInstance edgeToInnerBuild = graph.TestOnly_Edges[(outerBuildReferencer, innerBuild)];
 
                     edgeToOuterBuild.ShouldBe(edgeToInnerBuild);
                 }
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 7c278ef5d8e..273d6d4a7eb 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -775,28 +775,6 @@ public void GetTargetListsNullEntryTargets()
             }
         }
 
-        [Fact]
-        public void GetTargetsListsShouldApplyDefaultTargetsOnlyToGraphRoots()
-        {
-            using (var env = TestEnvironment.Create())
-            {
-                var root1 = CreateProjectFile(env: env, projectNumber: 1, projectReferences: new[] {2}, projectReferenceTargets: new Dictionary<string, string[]> {{"A", new[] {"B"}}}, defaultTargets: "A").Path;
-                var root2 = CreateProjectFile(env: env, projectNumber: 2, projectReferences: new[] {3}, projectReferenceTargets: new Dictionary<string, string[]> {{"B", new[] {"C"}}, {"X", new[] {"Y"}}}, defaultTargets: "X").Path;
-                CreateProjectFile(env: env, projectNumber: 3);
-
-
-                var projectGraph = new ProjectGraph(new []{root1, root2});
-                projectGraph.ProjectNodes.Count.ShouldBe(3);
-
-                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = projectGraph.GetTargetLists(null);
-
-                targetLists.Count.ShouldBe(projectGraph.ProjectNodes.Count);
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 1)].ShouldBe(new[] { "A" });
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 2)].ShouldBe(new[] { "B" });
-                targetLists[GetFirstNodeWithProjectNumber(projectGraph, 3)].ShouldBe(new[] { "C" });
-            }
-        }
-
         [Fact]
         public void GetTargetsListReturnsEmptyTargetsForNodeIfNoTargetsPropagatedToIt()
         {
@@ -993,13 +971,13 @@ public void GetTargetListsFiltersTargetsForOuterAndInnerBuilds()
         [Fact]
         public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBuilds()
         {
-            var projectReferenceTargetsProtocol =
+            string projectReferenceTargetsProtocol =
 $@"<ItemGroup>
      <ProjectReferenceTargets Include='A' Targets='{MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker};A;AInner' />
      <ProjectReferenceTargets Include='A' Targets='{MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker};A;AOuter' OuterBuild='true' />
    </ItemGroup>";
 
-            var entryProject = CreateProjectFile(
+            string entryProject = CreateProjectFile(
                 env: _env,
                 projectNumber: 1,
                 projectReferences: null,
@@ -1037,28 +1015,28 @@ public void GetTargetListsDoesNotUseTargetsMetadataOnInnerBuildsFromRootOuterBui
 
             var dot = graph.ToDot();
 
-            var rootOuterBuild = GetOuterBuild(graph, 1);
-            var nonRootOuterBuild = GetOuterBuild(graph, 3);
+            ProjectGraphNode rootOuterBuild = GetOuterBuild(graph, 1);
+            ProjectGraphNode nonRootOuterBuild = GetOuterBuild(graph, 3);
 
-            AssertOuterBuildAsRoot(rootOuterBuild, graph);
-            AssertOuterBuildAsNonRoot(nonRootOuterBuild, graph);
+            AssertOuterBuild(rootOuterBuild, graph);
+            AssertOuterBuild(nonRootOuterBuild, graph);
 
-            var targetLists = graph.GetTargetLists(new[] {"A"});
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(new[] { "A" });
 
-            targetLists[rootOuterBuild].ShouldBe(new []{"A"});
+            targetLists[rootOuterBuild].ShouldBe(new[] { "A" });
 
-            foreach (var innerBuild in GetInnerBuilds(graph, 1))
+            foreach (ProjectGraphNode innerBuild in GetInnerBuilds(graph, 1))
             {
-                targetLists[innerBuild].ShouldBe(new []{"D1", "A", "AOuter", "AInner"});
+                targetLists[innerBuild].ShouldBe(new[] { "D1", "A", "AOuter", "AInner" });
             }
 
-            targetLists[GetFirstNodeWithProjectNumber(graph, 2)].ShouldBe(new []{"T2", "A", "AOuter", "AInner"});
+            targetLists[GetFirstNodeWithProjectNumber(graph, 2)].ShouldBe(new[] { "T2", "A", "AOuter", "AInner" });
 
-            targetLists[nonRootOuterBuild].ShouldBe(new []{"T3", "A", "AOuter"});
+            targetLists[nonRootOuterBuild].ShouldBe(new[] { "T3", "A", "AOuter" });
 
-            foreach (var innerBuild in GetInnerBuilds(graph, 3))
+            foreach (ProjectGraphNode innerBuild in GetInnerBuilds(graph, 3))
             {
-                targetLists[innerBuild].ShouldBe(new []{"T3", "A", "AOuter", "AInner"});
+                targetLists[innerBuild].ShouldBe(new[] { "T3", "A", "AOuter", "AInner", "D3" });
             }
         }
 
@@ -1299,6 +1277,19 @@ public void GetTargetsListProjectReferenceTargetsOrDefaultComplexPropagation()
             }
         }
 
+        [Fact]
+        public void ReferencedMultitargetingEntryPointNodeTargetListContainsDefaultTarget()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+                TransientTestFile entryProject1 = CreateProjectFile(env, 1, projectReferences: new[] { 2 }, defaultTargets: "A", extraContent: ProjectReferenceTargetsWithMultitargeting);
+                TransientTestFile entryProject2 = CreateProjectFile(env, 2, defaultTargets: "A", extraContent: OuterBuildSpecificationWithProjectReferenceTargets);
+                var graph = new ProjectGraph(new HashSet<string> { entryProject1.Path, entryProject2.Path });
+                IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(null);
+                targetLists[key: GetOuterBuild(graph, 2)].ShouldBe(expected: OuterBuildTargets.Prepend("A"));
+            }
+        }
+
         public static IEnumerable<object[]> Graphs
         {
             get
@@ -1540,31 +1531,6 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
             Regex.Matches(dot,"label").Count.ShouldBe(graph.ProjectNodes.Count);
         }
 
-        private static void AssertOuterBuildAsRoot(
-            ProjectGraphNode outerBuild,
-            ProjectGraph graph,
-            Dictionary<string, string> additionalGlobalProperties = null,
-            int expectedInnerBuildCount = 2)
-        {
-            additionalGlobalProperties ??= new Dictionary<string, string>();
-
-            AssertOuterBuildEvaluation(outerBuild, additionalGlobalProperties);
-
-            outerBuild.ReferencingProjects.ShouldBeEmpty();
-            outerBuild.ProjectReferences.Count.ShouldBe(expectedInnerBuildCount);
-
-            foreach (var innerBuild in outerBuild.ProjectReferences)
-            {
-                AssertInnerBuildEvaluation(innerBuild, true, additionalGlobalProperties);
-
-                var edge = graph.TestOnly_Edges[(outerBuild, innerBuild)];
-                edge.DirectMetadataCount.ShouldBe(1);
-
-                var expectedPropertiesMetadata = $"{InnerBuildPropertyName}={innerBuild.ProjectInstance.GlobalProperties[InnerBuildPropertyName]}";
-                edge.GetMetadata("Properties").EvaluatedValue.ShouldBe(expectedPropertiesMetadata);
-            }
-        }
-
         [Fact]
         public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
         {
@@ -1578,7 +1544,7 @@ public void OuterBuildAsRootShouldDirectlyReferenceInnerBuilds()
 
             var outerBuild = graph.GraphRoots.First();
 
-            AssertOuterBuildAsRoot(outerBuild, graph);
+            AssertOuterBuild(outerBuild, graph);
         }
 
         [Fact]
@@ -1605,7 +1571,7 @@ public void OuterBuildAsNonRootShouldNotReferenceInnerBuilds()
 
             var outerBuild = GetOuterBuild(graph, 2);
 
-            AssertOuterBuildAsNonRoot(outerBuild, graph);
+            AssertOuterBuild(outerBuild, graph);
         }
 
         [Fact]
@@ -1639,7 +1605,7 @@ public void InnerBuildsFromNonRootOuterBuildInheritEdgesToOuterBuild()
 
             var outerBuild = GetOuterBuild(graph, 2);
 
-            AssertOuterBuildAsNonRoot(outerBuild, graph);
+            AssertOuterBuild(outerBuild, graph);
 
             var outerBuildReferencingNode = GetFirstNodeWithProjectNumber(graph, 1);
 
@@ -1661,7 +1627,7 @@ public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
                                                     <InnerBuildProperties>a;a</InnerBuildProperties>
                                                 </PropertyGroup>";
 
-            var root = CreateProjectFile(_env, 1, new[] {2}, null, null, multitargetingSpecification).Path;
+            var root = CreateProjectFile(_env, 1, new[] { 2 }, null, null, multitargetingSpecification).Path;
             CreateProjectFile(_env, 2, null, null, null, multitargetingSpecification);
 
             var graph = new ProjectGraph(root);
@@ -1673,8 +1639,8 @@ public void DuplicatedInnerBuildMonikersShouldGetDeduplicated()
             var rootOuterBuild = GetOuterBuild(graph, 1);
             var nonRootOuterBuild = GetOuterBuild(graph, 2);
 
-            AssertOuterBuildAsRoot(rootOuterBuild, graph, null, 1);
-            AssertOuterBuildAsNonRoot(nonRootOuterBuild, graph, null, 1);
+            AssertOuterBuild(rootOuterBuild, graph, null, 1);
+            AssertOuterBuild(nonRootOuterBuild, graph, null, 1);
         }
 
         [Fact]
@@ -1689,7 +1655,7 @@ public void ReferenceOfMultitargetingProjectShouldNotInheritInnerBuildSpecificGl
 
             graph.ProjectNodes.Count.ShouldBe(4);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
+            AssertOuterBuild(graph.GraphRoots.First(), graph);
 
             var nonMultitargetingNode = GetFirstNodeWithProjectNumber(graph, 2);
 
@@ -1757,8 +1723,8 @@ public void NonMultitargetingProjectsAreCompatibleWithMultitargetingProjects()
 
             graph.ProjectNodes.Count.ShouldBe(8);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
-            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 4), graph);
+            AssertOuterBuild(graph.GraphRoots.First(), graph);
+            AssertOuterBuild(GetOuterBuild(graph, 4), graph);
 
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2));
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));
@@ -1784,9 +1750,9 @@ public void InnerBuildsCanHaveSeparateReferences()
 
             graph.ProjectNodes.Count.ShouldBe(11);
 
-            AssertOuterBuildAsRoot(graph.GraphRoots.First(), graph);
-            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 2), graph);
-            AssertOuterBuildAsNonRoot(GetOuterBuild(graph, 2), graph);
+            AssertOuterBuild(graph.GraphRoots.First(), graph);
+            AssertOuterBuild(GetOuterBuild(graph, 2), graph);
+            AssertOuterBuild(GetOuterBuild(graph, 2), graph);
 
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 3));
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 5));
@@ -1826,7 +1792,7 @@ public void InnerBuildProducedByOuterBuildCanBeReferencedByAnotherNode()
 
             var outerBuild = graph.GraphRoots.First(IsOuterBuild);
 
-            AssertOuterBuildAsRoot(outerBuild, graph, additionalGlobalProperties);
+            AssertOuterBuild(outerBuild, graph, additionalGlobalProperties);
             AssertNonMultitargetingNode(GetFirstNodeWithProjectNumber(graph, 2), additionalGlobalProperties);
 
             var referencedInnerBuild = GetNodesWithProjectNumber(graph, 1).First(n => n.ProjectInstance.GetPropertyValue(InnerBuildPropertyName) == "a");
@@ -1904,7 +1870,7 @@ public void InnerBuildsProducedByOuterBuildsCanBeReferencedByOtherInnerBuilds()
 
             var outerBuild1 = GetOuterBuild(graph, 1);
 
-            AssertOuterBuildAsRoot(outerBuild1, graph, additionalGlobalProperties);
+            AssertOuterBuild(outerBuild1, graph, additionalGlobalProperties);
 
             var innerBuild1WithReferenceToInnerBuild2 = outerBuild1.ProjectReferences.FirstOrDefault(n => IsInnerBuild(n) && n.ProjectInstance.GlobalProperties[InnerBuildPropertyName] == "a");
             innerBuild1WithReferenceToInnerBuild2.ShouldNotBeNull();
@@ -2235,9 +2201,9 @@ public void TransitiveReferencesShouldNotBeAddedToOuterBuilds()
                 innerBuild.AssertReferencesIgnoringOrder(new []{3, 4, 4, 4, 5, 6, 6, 6});
             }
 
-            GetFirstNodeWithProjectNumber(graph, 2).AssertReferencesIgnoringOrder(new []{3, 4, 4, 4, 5, 6, 6, 6});
+            GetFirstNodeWithProjectNumber(graph, 2).AssertReferencesIgnoringOrder(new[] { 3, 4, 4, 4, 5, 6, 6, 6 });
 
-            GetOuterBuild(graph, 4).AssertReferencesIgnoringOrder(Array.Empty<int>());
+            GetOuterBuild(graph, 4).AssertReferencesIgnoringOrder(new[] { 4, 4 });
 
             var innerBuilds4 = GetInnerBuilds(graph, 4);
             innerBuilds4.Count.ShouldBe(2);
@@ -2312,7 +2278,7 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
             var outerBuild1 = GetOuterBuild(graph, 1);
             targetLists[outerBuild1].ShouldBe(new[] {"Build"});
 
-            AssertOuterBuildAsRoot(outerBuild1, graph, expectedInnerBuildCount: 2);
+            AssertOuterBuild(outerBuild1, graph, expectedInnerBuildCount: 2);
 
             var innerBuildsFor1 = GetInnerBuilds(graph, 1);
             innerBuildsFor1.Count.ShouldBe(2);
@@ -2325,7 +2291,7 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
 
             var outerBuild2 = GetOuterBuild(graph, 2);
             targetLists[outerBuild2].ShouldBe(new[] {"BuildForOuterBuild"});
-            AssertOuterBuildAsNonRoot(outerBuild2, graph, expectedInnerBuildCount: 2);
+            AssertOuterBuild(outerBuild2, graph, expectedInnerBuildCount: 2);
 
             var innerBuildsFor2 = GetInnerBuilds(graph, 2);
             innerBuildsFor2.Count.ShouldBe(2);
@@ -2340,13 +2306,13 @@ public void TransitiveReferencesShouldNotOverwriteMultitargetingEdges()
 
             outerBuild3.ReferencingProjects.Count.ShouldBe(4);
 
-            AssertOuterBuildAsNonRoot(outerBuild3, graph, expectedInnerBuildCount: 2);
+            AssertOuterBuild(outerBuild3, graph, expectedInnerBuildCount: 2);
             var innerBuildsFor3 = GetInnerBuilds(graph, 3);
             innerBuildsFor3.Count.ShouldBe(2);
 
             foreach (var inner3 in innerBuildsFor3)
             {
-                inner3.ReferencingProjects.Count.ShouldBe(4);
+                inner3.ReferencingProjects.Count.ShouldBe(5);
 
                 // 3 does not get called with 1ATarget or 1BTarget because those apply only to direct references
                 targetLists[inner3]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 6670fbc468e..12a3d83376e 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -251,6 +251,9 @@ public class BuildManager : INodePacketHandler, IBuildComponentHost, IDisposable
         /// </summary>
         private DateTime _instantiationTimeUtc;
 
+        /// <summary>
+        /// Messages to be logged
+        /// </summary>
         private IEnumerable<DeferredBuildMessage> _deferredBuildMessages;
 
         private ProjectCacheService _projectCacheService;
@@ -394,10 +397,20 @@ public readonly struct DeferredBuildMessage
 
             public string Text { get; }
 
+            public string FilePath { get; }
+
             public DeferredBuildMessage(string text, MessageImportance importance)
             {
                 Importance = importance;
                 Text = text;
+                FilePath = null;
+            }
+
+            public DeferredBuildMessage(string text, MessageImportance importance, string filePath)
+            {
+                Importance = importance;
+                Text = text;
+                FilePath = filePath;
             }
         }
 
@@ -527,6 +540,7 @@ public void BeginBuild(BuildParameters parameters)
 
                 var loggingService = InitializeLoggingService();
 
+                // Log deferred messages and response files
                 LogDeferredMessages(loggingService, _deferredBuildMessages);
 
                 InitializeCaches();
@@ -912,10 +926,7 @@ public void EndBuild()
                 // but the top level exception handler there should catch everything and have forwarded it to the
                 // OnThreadException method in this class already.
                 _workQueue.Complete();
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-                {
-                    _workQueue.Completion.Wait();
-                }
+                _workQueue.Completion.Wait();
 
                 Task projectCacheDispose = _projectCacheService.DisposeAsync().AsTask();
 
@@ -2745,14 +2756,7 @@ private void OnThreadException(Exception e)
         /// </summary>
         private void OnLoggingThreadException(Exception e)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                _workQueue.Post(() => OnThreadException(e));
-            }
-            else
-            {
-                OnThreadException(e);
-            }
+            _workQueue.Post(() => OnThreadException(e));
         }
 
         /// <summary>
@@ -2760,16 +2764,7 @@ private void OnLoggingThreadException(Exception e)
         /// </summary>
         private void OnProjectFinished(object sender, ProjectFinishedEventArgs e)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                _workQueue.Post(() => OnProjectFinishedBody(e));
-            }
-            else
-            {
-                OnProjectFinishedBody(e);
-            }
-
-            void OnProjectFinishedBody(ProjectFinishedEventArgs e)
+            _workQueue.Post(() =>
             {
                 lock (_syncLock)
                 {
@@ -2786,7 +2781,7 @@ void OnProjectFinishedBody(ProjectFinishedEventArgs e)
                         }
                     }
                 }
-            }
+            });
         }
 
         /// <summary>
@@ -2794,16 +2789,7 @@ void OnProjectFinishedBody(ProjectFinishedEventArgs e)
         /// </summary>
         private void OnProjectStarted(object sender, ProjectStartedEventArgs e)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                _workQueue.Post(() => OnProjectStartedBody(e));
-            }
-            else
-            {
-                OnProjectStartedBody(e);
-            }
-
-            void OnProjectStartedBody(ProjectStartedEventArgs e)
+            _workQueue.Post(() =>
             {
                 lock (_syncLock)
                 {
@@ -2812,7 +2798,7 @@ void OnProjectStartedBody(ProjectStartedEventArgs e)
                         _projectStartedEvents[e.BuildEventContext.SubmissionId] = e;
                     }
                 }
-            }
+            });
         }
 
         /// <summary>
@@ -2894,6 +2880,12 @@ private static void LogDeferredMessages(ILoggingService loggingService, IEnumera
             foreach (var message in deferredBuildMessages)
             {
                 loggingService.LogCommentFromText(BuildEventContext.Invalid, message.Importance, message.Text);
+
+                // If message includes a file path, include that file
+                if (message.FilePath is not null)
+                {
+                    loggingService.LogIncludeFile(BuildEventContext.Invalid, message.FilePath);
+                }
             }
         }
 
diff --git a/src/Build/BackEnd/BuildManager/BuildParameters.cs b/src/Build/BackEnd/BuildManager/BuildParameters.cs
index 8f2de9bfc4e..6a9d9cd0329 100644
--- a/src/Build/BackEnd/BuildManager/BuildParameters.cs
+++ b/src/Build/BackEnd/BuildManager/BuildParameters.cs
@@ -633,8 +633,16 @@ public bool ShutdownInProcNodeOnBuildFinish
 
         /// <summary>
         /// Gets the startup directory.
+        /// It is current directory from which MSBuild command line was recently invoked.
+        /// It is communicated to working nodes as part of NodeConfiguration deserialization once the node manager acquires a particular node.
+        /// This deserialization assign this value to static backing field making it accessible from rest of build thread.
+        /// In MSBuild server node, this value is set once <see cref="ServerNodeBuildCommand"></see> is received.
         /// </summary>
-        internal static string StartupDirectory => s_startupDirectory;
+        internal static string StartupDirectory
+        {
+            get { return s_startupDirectory; }
+            set { s_startupDirectory = value; }
+        }
 
         /// <summary>
         /// Indicates whether the build plan is enabled or not.
diff --git a/src/Build/BackEnd/BuildManager/CacheSerialization.cs b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
index 4c337378637..950182296ab 100644
--- a/src/Build/BackEnd/BuildManager/CacheSerialization.cs
+++ b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.IO;
+using System.Linq;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
 
@@ -61,6 +62,27 @@ public static string SerializeCaches(IConfigCache configCache, IResultsCache res
                             break;
                     }
 
+                    // Avoid creating new config and results caches if no projects were built in violation
+                    // of isolation mode.
+                    if (configCacheToSerialize.Count() > 1)
+                    {
+                        // We need to preserve all configurations to enable the scheduler to dump them and their
+                        // associated requests, so create new caches to serialize storing solely data
+                        // associated with the project specified to be built in isolation (and not any
+                        // data associated with referenced projects needed for said project to complete
+                        // its build).
+                        var tempConfigCacheToSerialize = new ConfigCache();
+
+                        // The project that was built in isolation mode has the
+                        // smallest configuration id.
+                        int smallestCacheConfigId = configCacheToSerialize.GetSmallestConfigId();
+                        tempConfigCacheToSerialize.AddConfiguration(configCacheToSerialize[smallestCacheConfigId]);
+                        configCacheToSerialize = tempConfigCacheToSerialize;
+                        var tempResultsCacheToSerialize = new ResultsCache();
+                        tempResultsCacheToSerialize.AddResult(resultsCacheToSerialize.GetResultsForConfiguration(smallestCacheConfigId));
+                        resultsCacheToSerialize = tempResultsCacheToSerialize;
+                    }
+
                     translator.Translate(ref configCacheToSerialize);
                     translator.Translate(ref resultsCacheToSerialize);
                 }
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index d635c661da9..6618dc945c8 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -120,9 +120,7 @@ internal class BuildRequestEngine : IBuildRequestEngine, IBuildComponent
         internal BuildRequestEngine()
         {
             _debugDumpState = Traits.Instance.DebugScheduler;
-            _debugDumpPath = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? DebugUtils.DebugPath
-                : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            _debugDumpPath = DebugUtils.DebugPath;
             _debugForceCaching = Environment.GetEnvironmentVariable("MSBUILDDEBUGFORCECACHING") == "1";
 
             if (String.IsNullOrEmpty(_debugDumpPath))
diff --git a/src/Build/BackEnd/Components/Caching/ConfigCache.cs b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
index d2821aee570..f2eac09484f 100644
--- a/src/Build/BackEnd/Components/Caching/ConfigCache.cs
+++ b/src/Build/BackEnd/Components/Caching/ConfigCache.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -200,6 +201,21 @@ public void ClearConfigurations()
             }
         }
 
+        /// <summary>
+        /// Gets the smallest configuration id of any configuration
+        /// in this cache.
+        /// </summary>
+        /// <returns>Gets the smallest configuration id of any
+        /// configuration in this cache.</returns>
+        public int GetSmallestConfigId()
+        {
+            lock (_lockObject)
+            {
+                ErrorUtilities.VerifyThrow(_configurations.Count > 0, "No configurations exist from which to obtain the smallest configuration id.");
+                return _configurations.OrderBy(kvp => kvp.Key).First().Key;
+            }
+        }
+    
         /// <summary>
         /// Clears configurations from the configuration cache which have not been explicitly loaded.
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Communications/CurrentHost.cs b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
index 81116ecb054..5eec58d2d0b 100644
--- a/src/Build/BackEnd/Components/Communications/CurrentHost.cs
+++ b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
@@ -1,9 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if RUNTIME_TYPE_NETCORE || MONO
 using System.Diagnostics;
 using System.IO;
 using Microsoft.Build.Shared;
+#endif
 
 #nullable disable
 
diff --git a/src/Build/BackEnd/Components/Communications/INodeProvider.cs b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
index 0da32af6678..810dc4d9011 100644
--- a/src/Build/BackEnd/Components/Communications/INodeProvider.cs
+++ b/src/Build/BackEnd/Components/Communications/INodeProvider.cs
@@ -3,7 +3,6 @@
 
 using System;
 
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
index 9a08a3940a7..b39bcc78b9e 100644
--- a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Diagnostics;
 using System.Globalization;
-using System.IO;
 using System.Runtime.InteropServices;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Framework;
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
index 88f5feea51b..337cbd76f03 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderInProc.cs
@@ -9,7 +9,9 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
+#if FEATURE_THREAD_CULTURE
 using BuildParameters = Microsoft.Build.Execution.BuildParameters;
+#endif
 using NodeEngineShutdownReason = Microsoft.Build.Execution.NodeEngineShutdownReason;
 
 #nullable disable
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index cd5a88127e0..77741a46412 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -10,15 +10,15 @@
 using System.IO.Pipes;
 using System.Diagnostics;
 using System.Linq;
-using System.Threading;
 using System.Threading.Tasks;
-using System.Runtime.InteropServices;
 #if FEATURE_PIPE_SECURITY
 using System.Security.Principal;
 #endif
 
 #if FEATURE_APM
 using Microsoft.Build.Eventing;
+#else
+using System.Threading;
 #endif
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
diff --git a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
index cfd6c3a61da..11aea7b2c52 100644
--- a/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
+++ b/src/Build/BackEnd/Components/Communications/TranslatorExtensions.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Concurrent;
-using System.Linq;
 using System.Reflection;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
diff --git a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
index c1fa3e463a7..1a4d63c65a9 100644
--- a/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/EvaluationLoggingContext.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections;
-using System.Collections.Generic;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
diff --git a/src/Build/BackEnd/Components/Logging/ILoggingService.cs b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
index c261563d0e7..d5ceccb6dfc 100644
--- a/src/Build/BackEnd/Components/Logging/ILoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/ILoggingService.cs
@@ -605,6 +605,15 @@ BuildEventContext LogProjectStarted(
         /// <param name="properties">The list of properties associated with the event.</param>
         void LogTelemetry(BuildEventContext buildEventContext, string eventName, IDictionary<string, string> properties);
         #endregion
+
+        #region Log response files
+        /// <summary>
+        /// Helper method to create an event for including files. Typically response files
+        /// </summary>
+        /// <param name="buildEventContext">Event context information which describes where is the event getting logged</param>
+        /// <param name="filePath">Full path to the response file</param>
+        void LogIncludeFile(BuildEventContext buildEventContext, string filePath);
+        #endregion
     }
 
     /// <summary>
diff --git a/src/Build/BackEnd/Components/Logging/LoggingContext.cs b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
index a81fd673b27..c8018767633 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingContext.cs
@@ -269,5 +269,15 @@ internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file)
             LoggingService.LogFatalBuildError(BuildEventContext, exception, file);
             _hasLoggedErrors = true;
         }
+
+        /// <summary>
+        /// Logs a file to be included in the binary logger
+        /// </summary>
+        /// <param name="filePath">Path to response file</param>
+        internal void LogIncludeFile(string filePath)
+        { 
+            ErrorUtilities.VerifyThrow(IsValid, "must be valid");
+            _loggingService.LogIncludeFile(BuildEventContext, filePath);
+        }
     }
 }
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index 5a4d694f427..e9c1cde6045 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -815,5 +815,22 @@ public void LogTelemetry(BuildEventContext buildEventContext, string eventName,
         }
 
         #endregion
+
+        #region log response files
+        /// <summary>
+        /// Logs a file to include in the binlogs
+        /// </summary>
+        /// <param name="buildEventContext">Event context information which describes who is logging the event</param>
+        /// <param name="filePath">Full path to response file</param>
+        public void LogIncludeFile(BuildEventContext buildEventContext, string filePath)
+        {
+            ErrorUtilities.VerifyThrow(buildEventContext != null, "buildEventContext was null");
+            ErrorUtilities.VerifyThrow(filePath != null, "response file path was null");
+            ResponseFileUsedEventArgs responseFileUsedEvent = new ResponseFileUsedEventArgs(filePath);
+            responseFileUsedEvent.BuildEventContext = buildEventContext;
+            ProcessLoggingEvent(responseFileUsedEvent);
+        }
+
+        #endregion
     }
 }
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
index cb85cae4558..9f51cf9e10a 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheDescriptorEqualityComparer.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.Experimental.ProjectCache
diff --git a/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs b/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
index 505fa0ed693..4ebc567c45d 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/FullTracking.cs
@@ -1,14 +1,14 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.IO;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.BackEnd
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 32b7c6b1b1a..446ef6e4c85 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -472,7 +472,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
 
                 foreach (string excludeSplitFile in excludeSplitFiles)
                 {
-                    excludesUnescapedForComparison.Add(excludeSplitFile);
+                    excludesUnescapedForComparison.Add(excludeSplitFile.NormalizeForPathComparison());
                 }
             }
 
@@ -480,7 +480,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
 
             for (int i = 0; i < items.Count; i++)
             {
-                if (!excludesUnescapedForComparison.Contains(((IItem)items[i]).EvaluatedInclude))
+                if (!excludesUnescapedForComparison.Contains(((IItem)items[i]).EvaluatedInclude.NormalizeForPathComparison()))
                 {
                     remainingItems.Add(items[i]);
                 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 924b3abb698..8679287cd8a 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -961,11 +961,15 @@ private async Task<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost ta
                     && !taskResult // and it returned false
                     && !taskLoggingContext.HasLoggedErrors // and it didn't log any errors
                     && (be is TaskHost th ? th.BuildRequestsSucceeded : false)
-                    && (be is IBuildEngine7 be7 ? !be7.AllowFailureWithoutError : true) // and it's not allowed to fail unless it logs an error
                     && !(_cancellationToken.CanBeCanceled && _cancellationToken.IsCancellationRequested)) // and it wasn't cancelled
                 {
                     // Then decide how to log MSB4181
-                    if (_continueOnError == ContinueOnError.WarnAndContinue)
+                    if (be is IBuildEngine7 be7 && be7.AllowFailureWithoutError)
+                    {
+                        // If it's allowed to fail without error, log as a message
+                        taskLoggingContext.LogComment(MessageImportance.Normal, "TaskReturnedFalseButDidNotLogError", _taskNode.Name);
+                    }
+                    else if (_continueOnError == ContinueOnError.WarnAndContinue)
                     {
                         taskLoggingContext.LogWarning(null,
                             new BuildEventFileInfo(_targetChildInstance.Location),
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
index 2b55265cd9a..4ee0c78cae4 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskHost.cs
@@ -123,9 +123,7 @@ public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, Elemen
             _continueOnError = false;
             _activeProxy = true;
             _callbackMonitor = new object();
-            _disableInprocNode = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? Traits.Instance.InProcNodeDisabled || host.BuildParameters.DisableInProcNode
-                : Traits.Instance.InProcNodeDisabled;
+            _disableInprocNode = Traits.Instance.InProcNodeDisabled || host.BuildParameters.DisableInProcNode;
             EngineServices = new EngineServicesImpl(this);
         }
 
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index f166c13d9fa..de7bd580e4a 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -144,9 +144,7 @@ internal class Scheduler : IScheduler
         /// Flag used for debugging by forcing all scheduling to go out-of-proc.
         /// </summary>
         internal bool ForceAffinityOutOfProc
-            => ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? Traits.Instance.InProcNodeDisabled || _componentHost.BuildParameters.DisableInProcNode
-                : Traits.Instance.InProcNodeDisabled;
+            => Traits.Instance.InProcNodeDisabled || _componentHost.BuildParameters.DisableInProcNode;
 
         /// <summary>
         /// The path into which debug files will be written.
@@ -183,9 +181,7 @@ public Scheduler()
         {
             // Be careful moving these to Traits, changing the timing of reading environment variables has a breaking potential.
             _debugDumpState = Traits.Instance.DebugScheduler;
-            _debugDumpPath = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                ? DebugUtils.DebugPath
-                : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            _debugDumpPath = DebugUtils.DebugPath;
             _schedulingUnlimitedVariable = Environment.GetEnvironmentVariable("MSBUILDSCHEDULINGUNLIMITED");
             _nodeLimitOffset = 0;
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
index 7888b1a6679..71f82542916 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingData.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Collections;
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index 9fdc4c5f8bc..f411afbd2b2 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -10,7 +10,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
index 4ec872e6718..38bc4c3c23a 100644
--- a/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/CachingSdkResolverService.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -36,7 +35,7 @@ public override void ClearCaches()
             _cache.Clear();
         }
 
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             SdkResult result;
 
@@ -46,7 +45,7 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
 
             if (Traits.Instance.EscapeHatches.DisableSdkResolutionCache)
             {
-                result = base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                result = base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
             }
             else
             {
@@ -65,7 +64,7 @@ public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, Logging
                     {
                         wasResultCached = false;
 
-                        return base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                        return base.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
                     }));
 
                 // Get the lazy value which will block all waiting threads until the SDK is resolved at least once while subsequent calls get cached results.
diff --git a/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs b/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
index ef3e569dd06..0777e2ee6f3 100644
--- a/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/DefaultSdkResolver.cs
@@ -31,12 +31,11 @@ internal class DefaultSdkResolver : SdkResolverBase
 
         public override SdkResultBase Resolve(SdkReference sdk, SdkResolverContextBase context, SdkResultFactoryBase factory)
         {
-            var sdkPath = Path.Combine(BuildEnvironmentHelper.Instance.MSBuildSDKsPath, sdk.Name, "Sdk");
+            string sdkPath = Path.Combine(BuildEnvironmentHelper.Instance.MSBuildSDKsPath, sdk.Name, "Sdk");
 
-            // Note: On failure MSBuild will log a generic message, no need to indicate a failure reason here.
             return FileUtilities.DirectoryExistsNoThrow(sdkPath)
                 ? factory.IndicateSuccess(sdkPath, string.Empty)
-                : factory.IndicateFailure(null);
+                : factory.IndicateFailure(new string[] { ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("DefaultSDKResolverError", sdk.Name, sdkPath) }, null);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs b/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs
index 46edc4f4a4d..84da3c1f818 100644
--- a/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/HostedSdkResolverServiceBase.cs
@@ -49,7 +49,7 @@ public virtual void InitializeComponent(IBuildComponentHost host)
         public abstract void PacketReceived(int node, INodePacket packet);
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public abstract SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio);
+        public abstract SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
 
         /// <inheritdoc cref="IBuildComponent.ShutdownComponent"/>
         public virtual void ShutdownComponent()
diff --git a/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs
index f2f4544ccd1..9a33b60ccbc 100644
--- a/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/ISdkResolverService.cs
@@ -42,7 +42,8 @@ internal interface ISdkResolverService
         /// <param name="projectPath">The full path to the project file that is resolving the SDK.</param>
         /// <param name="interactive">Indicates whether or not the resolver is allowed to be interactive.</param>
         /// <param name="isRunningInVisualStudio">Indicates whether or not the resolver is running in Visual Studio.</param>
+        /// <param name="failOnUnresolvedSdk">Whether to throw an exception should the SDK fail to be resolved.</param>
         /// <returns>An <see cref="SdkResult"/> containing information about the resolved SDK. If no resolver was able to resolve it, then <see cref="Framework.SdkResult.Success"/> == false. </returns>
-        SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio);
+        SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
index 6e1e26c4258..8dc3f79b60a 100644
--- a/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/MainNodeSdkResolverService.cs
@@ -4,6 +4,7 @@
 using Microsoft.Build.BackEnd.Components.Logging;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System;
@@ -72,9 +73,10 @@ public override void PacketReceived(int node, INodePacket packet)
             try
             {
                 ILoggingService loggingService = Host.GetComponent(BuildComponentType.LoggingService) as ILoggingService;
+                bool failOnUnresolvedSdk = !Host.BuildParameters.ProjectLoadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) || Host.BuildParameters.ProjectLoadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk);
 
                 // This call is usually cached so is very fast but can take longer for a new SDK that is downloaded.  Other queued threads for different SDKs will complete sooner and continue on which unblocks evaluations
-                response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio);
+                response = ResolveSdk(request.SubmissionId, sdkReference, new EvaluationLoggingContext(loggingService, request.BuildEventContext, request.ProjectPath), request.ElementLocation, request.SolutionPath, request.ProjectPath, request.Interactive, request.IsRunningInVisualStudio, failOnUnresolvedSdk);
             }
             catch (Exception e)
             {
@@ -94,14 +96,14 @@ public override void PacketReceived(int node, INodePacket packet)
         }
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             ErrorUtilities.VerifyThrowInternalNull(sdk, nameof(sdk));
             ErrorUtilities.VerifyThrowInternalNull(loggingContext, nameof(loggingContext));
             ErrorUtilities.VerifyThrowInternalNull(sdkReferenceLocation, nameof(sdkReferenceLocation));
             ErrorUtilities.VerifyThrowInternalLength(projectPath, nameof(projectPath));
 
-            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+            return _cachedSdkResolver.ResolveSdk(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
         }
     }
 }
diff --git a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
index 9db962d2a21..0b9e5ceecb8 100644
--- a/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/OutOfProcNodeSdkResolverService.cs
@@ -64,7 +64,7 @@ public override void PacketReceived(int node, INodePacket packet)
         }
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        public override SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             bool wasResultCached = true;
 
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
index c38afed1d3b..ce94320a586 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverService.cs
@@ -110,15 +110,28 @@ public virtual void ClearCaches()
         }
 
         /// <inheritdoc cref="ISdkResolverService.ResolveSdk"/>
-        public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4))
             {
-                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                return ResolveSdkUsingResolversWithPatternsFirst(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, failOnUnresolvedSdk);
             }
             else
             {
-                return ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio);
+                SdkResult result = ResolveSdkUsingAllResolvers(submissionId, sdk, loggingContext, sdkReferenceLocation, solutionPath, projectPath, interactive, isRunningInVisualStudio, out IEnumerable<string> errors, out IEnumerable<string> warnings);
+
+                // Warnings are already logged on success.
+                if (!result.Success)
+                {
+                    if (failOnUnresolvedSdk)
+                    {
+                        loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "FailedToResolveSDK", sdk.Name, string.Join($"{Environment.NewLine}  ", errors));
+                    }
+
+                    LogWarnings(loggingContext, sdkReferenceLocation, warnings);
+                }
+
+                return result;
             }
         }
 
@@ -128,7 +141,7 @@ public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingC
         /// If the first pass is unsuccessful, on the second pass all the general resolvers (i.e. resolvers without pattern), ordered by their priority, are tried one after one.
         /// After that, if the second pass is unsuccessful, sdk resolution is unsuccessful.
         /// </remarks>
-        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk)
         {
             if (_specificResolversManifestsRegistry == null || _generalResolversManifestsRegistry == null)
             {
@@ -154,6 +167,8 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
 
             List<SdkResolver> resolvers;
             SdkResult sdkResult;
+            List<string> errors = new List<string>(0);
+            List<string> warnings = new List<string>(0);
             if (matchingResolversManifests.Count != 0)
             {
                 // First pass.
@@ -169,10 +184,15 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
                     projectPath,
                     interactive,
                     isRunningInVisualStudio,
-                    out sdkResult))
+                    out sdkResult,
+                    out IEnumerable<string> firstErrors,
+                    out IEnumerable<string> firstWarnings))
                 {
                     return sdkResult;
                 }
+
+                errors.AddRange(firstErrors);
+                warnings.AddRange(firstWarnings);
             }
 
             // Second pass: fallback to general resolvers. 
@@ -191,11 +211,23 @@ private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, Sd
                 projectPath,
                 interactive,
                 isRunningInVisualStudio,
-                out sdkResult))
+                out sdkResult,
+                out IEnumerable<string> moreErrors,
+                out IEnumerable<string> moreWarnings))
             {
                 return sdkResult;
             }
 
+            errors.AddRange(moreErrors);
+            warnings.AddRange(moreWarnings);
+
+            if (failOnUnresolvedSdk)
+            {
+                loggingContext.LogError(new BuildEventFileInfo(sdkReferenceLocation), "FailedToResolveSDK", sdk.Name, string.Join($"{Environment.NewLine}  ", errors));
+            }
+
+            LogWarnings(loggingContext, sdkReferenceLocation, warnings);
+
             // No resolvers resolved the sdk.
             return new SdkResult(sdk, null, null);
         }
@@ -228,7 +260,7 @@ private List<SdkResolver> GetResolvers(IList<SdkResolverManifest> resolversManif
             return resolvers;
         }
 
-        private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio)
+        private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, out IEnumerable<string> errors, out IEnumerable<string> warnings)
         {
             // Lazy initialize all SDK resolvers
             if (_resolversList == null)
@@ -246,14 +278,30 @@ private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk
                 projectPath,
                 interactive,
                 isRunningInVisualStudio,
-                out SdkResult sdkResult);
+                out SdkResult sdkResult,
+                out errors,
+                out warnings);
 
             return sdkResult;
         }
 
-        private bool TryResolveSdkUsingSpecifiedResolvers(IList<SdkResolver> resolvers, int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, out SdkResult sdkResult)
+        private bool TryResolveSdkUsingSpecifiedResolvers(
+            IList<SdkResolver> resolvers,
+            int submissionId,
+            SdkReference sdk,
+            LoggingContext loggingContext,
+            ElementLocation sdkReferenceLocation,
+            string solutionPath,
+            string projectPath,
+            bool interactive,
+            bool isRunningInVisualStudio,
+            out SdkResult sdkResult,
+            out IEnumerable<string> errors,
+            out IEnumerable<string> warnings)
         {
             List<SdkResult> results = new List<SdkResult>();
+            errors = null;
+            warnings = null;
 
             // Loop through resolvers which have already been sorted by priority, returning the first result that was successful
             SdkLogger buildEngineLogger = new SdkLogger(loggingContext);
@@ -294,14 +342,11 @@ private bool TryResolveSdkUsingSpecifiedResolvers(IList<SdkResolver> resolvers,
 
                 SetResolverState(submissionId, sdkResolver, context.State);
 
-                if (result == null)
-                {
-                    continue;
-                }
+                result ??= (SdkResult)resultFactory.IndicateFailure(new string[] { ResourceUtilities.FormatResourceStringStripCodeAndKeyword("SDKResolverReturnedNull", sdkResolver.Name) }, Array.Empty<string>());
 
                 if (result.Success)
                 {
-                    LogWarnings(loggingContext, sdkReferenceLocation, result);
+                    LogWarnings(loggingContext, sdkReferenceLocation, result.Warnings);
 
                     if (!IsReferenceSameVersion(sdk, result.Version))
                     {
@@ -319,18 +364,8 @@ private bool TryResolveSdkUsingSpecifiedResolvers(IList<SdkResolver> resolvers,
                 results.Add(result);
             }
 
-            foreach (SdkResult result in results)
-            {
-                LogWarnings(loggingContext, sdkReferenceLocation, result);
-
-                if (result.Errors != null)
-                {
-                    foreach (string error in result.Errors)
-                    {
-                        loggingContext.LogErrorFromText(subcategoryResourceName: null, errorCode: null, helpKeyword: null, file: new BuildEventFileInfo(sdkReferenceLocation), message: error);
-                    }
-                }
-            }
+            warnings = results.SelectMany(r => r.Warnings ?? Array.Empty<string>());
+            errors = results.SelectMany(r => r.Errors ?? Array.Empty<string>());
 
             sdkResult = new SdkResult(sdk, null, null);
             return false;
@@ -372,14 +407,14 @@ internal void InitializeForTests(SdkResolverLoader resolverLoader = null, IList<
             }
         }
 
-        private static void LogWarnings(LoggingContext loggingContext, ElementLocation location, SdkResult result)
+        private static void LogWarnings(LoggingContext loggingContext, ElementLocation location, IEnumerable<string> warnings)
         {
-            if (result.Warnings == null)
+            if (warnings == null)
             {
                 return;
             }
 
-            foreach (string warning in result.Warnings)
+            foreach (string warning in warnings)
             {
                 loggingContext.LogWarningFromText(null, null, null, new BuildEventFileInfo(location), warning);
             }
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
index 2901298ed0a..18297977aaa 100644
--- a/src/Build/BackEnd/Node/OutOfProcServerNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -361,6 +361,10 @@ private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)
             Thread.CurrentThread.CurrentCulture = command.Culture;
             Thread.CurrentThread.CurrentUICulture = command.UICulture;
 
+            // Reconfigure static BuildParameters.StartupDirectory to have this value
+            // same as startup directory of msbuild entry client or dotnet CLI.
+            BuildParameters.StartupDirectory = command.StartupDirectory;
+
             // Configure console configuration so Loggers can change their behavior based on Target (client) Console properties.
             ConsoleConfiguration.Provider = command.ConsoleConfiguration;
 
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 628a635a158..2577a04dd71 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -23,7 +23,6 @@
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Task = System.Threading.Tasks.Task;
-using System.Linq;
 
 #nullable disable
 
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index e5c1677ee6a..b581d671b9d 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -7,9 +7,6 @@
 using System.Diagnostics;
 using System.Diagnostics.Contracts;
 using System.Runtime.Serialization;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 using System.Diagnostics.CodeAnalysis;
 using System.Security;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 254d11158b4..0ba22cdf4e7 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -56,7 +56,7 @@ public class Project : ILinkableObject
         /// <summary>
         /// * and ? are invalid file name characters, but they occur in globs as wild cards.
         /// </summary>
-        private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c!= '/' && c != '\\' && c != ':').ToArray();
+        private static readonly char[] s_invalidGlobChars = FileUtilities.InvalidFileNameChars.Where(c => c != '*' && c != '?' && c != '/' && c != '\\' && c != ':').ToArray();
 
         /// <summary>
         /// Context to log messages and events in.
@@ -2782,12 +2782,13 @@ private List<ProvenanceResult> GetItemProvenance(string itemToMatch, IEnumerable
                     return new List<ProvenanceResult>();
                 }
 
-                return
-                    projectItemElements
+                return projectItemElements
                     .AsParallel()
-                    .AsOrdered()
-                    .Select(i => ComputeProvenanceResult(itemToMatch, i))
-                    .Where(r => r != null)
+                    .Select((item, index) => (Result: ComputeProvenanceResult(itemToMatch, item), Index: index))
+                    .Where(pair => pair.Result != null)
+                    .AsSequential()
+                    .OrderBy(pair => pair.Index)
+                    .Select(pair => pair.Result)
                     .ToList();
             }
 
diff --git a/src/Build/Definition/ToolsetConfigurationReader.cs b/src/Build/Definition/ToolsetConfigurationReader.cs
index 8d8f3251768..db1aa93901e 100644
--- a/src/Build/Definition/ToolsetConfigurationReader.cs
+++ b/src/Build/Definition/ToolsetConfigurationReader.cs
@@ -8,10 +8,8 @@
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
 using Microsoft.Build.Execution;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 
@@ -262,14 +260,7 @@ private Dictionary<string, ProjectImportPathMatch> ComputeDistinctListOfSearchPa
         /// </summary>
         private static Configuration ReadApplicationConfiguration()
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-            {
-                return s_configurationCache.Value;
-            }
-            else
-            {
-                return ReadOpenMappedExeConfiguration();
-            }
+            return s_configurationCache.Value;
         }
 
         private static Configuration ReadOpenMappedExeConfiguration()
diff --git a/src/Build/Evaluation/Conditionals/Scanner.cs b/src/Build/Evaluation/Conditionals/Scanner.cs
index 645181ce8f7..f8f74e0686a 100644
--- a/src/Build/Evaluation/Conditionals/Scanner.cs
+++ b/src/Build/Evaluation/Conditionals/Scanner.cs
@@ -5,9 +5,7 @@
 using System;
 using System.Diagnostics;
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index 1ee727c33ea..59dba0b96ad 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -1638,6 +1638,7 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
             // paths will be returned (union of all files that match).
             var allProjects = new List<ProjectRootElement>();
             bool containsWildcards = FileMatcher.HasWildcards(importElement.Project);
+            bool missingDirectoryDespiteTrueCondition = false;
 
             // Try every extension search path, till we get a Hit:
             // 1. 1 or more project files loaded
@@ -1651,15 +1652,19 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
 
                 string extensionPathExpanded = _data.ExpandString(extensionPath);
 
-                if (!_fallbackSearchPathsCache.DirectoryExists(extensionPathExpanded))
+                var newExpandedCondition = importElement.Condition.Replace(extensionPropertyRefAsString, extensionPathExpanded, StringComparison.OrdinalIgnoreCase);
+                if (!EvaluateConditionCollectingConditionedProperties(importElement, newExpandedCondition, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties,
+                            _projectRootElementCache))
                 {
                     continue;
                 }
 
-                var newExpandedCondition = importElement.Condition.Replace(extensionPropertyRefAsString, extensionPathExpanded, StringComparison.OrdinalIgnoreCase);
-                if (!EvaluateConditionCollectingConditionedProperties(importElement, newExpandedCondition, ExpanderOptions.ExpandProperties, ParserOptions.AllowProperties,
-                            _projectRootElementCache))
+                // If the whole fallback folder doesn't exist, short-circuit and don't
+                // bother constructing an exact file path.
+                if (!_fallbackSearchPathsCache.DirectoryExists(extensionPathExpanded))
                 {
+                    // Set to log an error only if the change wave is enabled.
+                    missingDirectoryDespiteTrueCondition = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6) && !containsWildcards;
                     continue;
                 }
 
@@ -1712,7 +1717,7 @@ private List<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportin
             // atleastOneExactFilePathWasLookedAtAndNotFound would be false, eg, if the expression
             // was a wildcard and it resolved to zero files!
             if (allProjects.Count == 0 &&
-                atleastOneExactFilePathWasLookedAtAndNotFound &&
+                (atleastOneExactFilePathWasLookedAtAndNotFound || missingDirectoryDespiteTrueCondition) &&
                 (_loadSettings & ProjectLoadSettings.IgnoreMissingImports) == 0)
             {
                 ThrowForImportedProjectWithSearchPathsNotFound(fallbackSearchPathMatch, importElement);
@@ -1842,7 +1847,8 @@ static string EvaluateProperty(string value, IElementLocation location,
                 // Combine SDK path with the "project" relative path
                 try
                 {
-                    sdkResult = _sdkResolverService.ResolveSdk(_submissionId, sdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive, _isRunningInVisualStudio);
+                    sdkResult = _sdkResolverService.ResolveSdk(_submissionId, sdkReference, _evaluationLoggingContext, importElement.Location, solutionPath, projectPath, _interactive, _isRunningInVisualStudio,
+                        failOnUnresolvedSdk: !_loadSettings.HasFlag(ProjectLoadSettings.IgnoreMissingImports) || _loadSettings.HasFlag(ProjectLoadSettings.FailOnUnresolvedSdk));
                 }
                 catch (SdkResolverException e)
                 {
diff --git a/src/Build/Evaluation/ExpressionShredder.cs b/src/Build/Evaluation/ExpressionShredder.cs
index 79d4de04eb6..a49654cefca 100644
--- a/src/Build/Evaluation/ExpressionShredder.cs
+++ b/src/Build/Evaluation/ExpressionShredder.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 using Microsoft.Build.Shared;
 using System.Collections.Generic;
 using Microsoft.Build.Collections;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
index ce0dc977426..cbbc06d0cef 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.IncludeOperation.cs
@@ -6,7 +6,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using Microsoft.CodeAnalysis.Collections;
 using System;
 using System.Collections.Generic;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index f0c19a5c681..2e0cf86d90d 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -3,7 +3,6 @@
 
 using Microsoft.Build.Construction;
 using Microsoft.Build.Eventing;
-using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using System;
 using System.Collections.Generic;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
index b742bb23311..8fbcc487daa 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.RemoveOperation.cs
@@ -4,7 +4,6 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
index 612c1a8d9d1..88c299dd571 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.UpdateOperation.cs
@@ -7,7 +7,6 @@
 using Microsoft.Build.Framework;
 using System.Collections.Immutable;
 using System.Linq;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 871ad820e6a..cddd1390eda 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -9,12 +9,13 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 
 using System;
 using System.Collections.Generic;
 using System.Collections.Immutable;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using System.Linq;
 using System.Threading;
 
diff --git a/src/Build/Evaluation/ProjectParser.cs b/src/Build/Evaluation/ProjectParser.cs
index 6959e3709b0..fd9f087f7a9 100644
--- a/src/Build/Evaluation/ProjectParser.cs
+++ b/src/Build/Evaluation/ProjectParser.cs
@@ -6,6 +6,7 @@
 using Microsoft.Build.Shared;
 using System;
 using System.Collections.Generic;
+using System.Xml;
 
 using Expander = Microsoft.Build.Evaluation.Expander<Microsoft.Build.Evaluation.ProjectProperty, Microsoft.Build.Evaluation.ProjectItem>;
 using ProjectXmlUtilities = Microsoft.Build.Internal.ProjectXmlUtilities;
@@ -634,6 +635,14 @@ private ProjectTargetElement ParseProjectTargetElement(XmlElementWithLocation el
                         if (onError != null)
                         {
                             ProjectErrorUtilities.ThrowInvalidProject(onError.Location, "NodeMustBeLastUnderElement", XMakeElements.onError, XMakeElements.target, childElement.Name);
+                        }                       
+                        if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_6))
+                        {
+                            if (childElement.ChildNodes.Count == 1 && childElement.FirstChild.NodeType == XmlNodeType.Text)
+                            {
+                                // If the element has inner text and no other child elements except text, then this should be a property and throw invalid child element of <Target>
+                                ProjectErrorUtilities.ThrowInvalidProject(childElement.Location, "PropertyOutsidePropertyGroupInTarget", childElement.Name, childElement.ParentNode.Name);
+                            }
                         }
 
                         child = ParseProjectTaskElement(childElement, target);
diff --git a/src/Build/Globbing/MSBuildGlob.cs b/src/Build/Globbing/MSBuildGlob.cs
index ce624d60323..92464daafd4 100644
--- a/src/Build/Globbing/MSBuildGlob.cs
+++ b/src/Build/Globbing/MSBuildGlob.cs
@@ -6,9 +6,7 @@
 using System.IO;
 using System.Text.RegularExpressions;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using Microsoft.NET.StringTools;
 
 #nullable disable
@@ -212,16 +210,10 @@ public static MSBuildGlob Parse(string globRoot, string fileSpec)
                         RegexOptions regexOptions = FileMatcher.DefaultRegexOptions;
                         // compile the regex since it's expected to be used multiple times
                         // For the kind of regexes used here, compilation on .NET Framework tends to be expensive and not worth the small
-                        // run-time boost so it's enabled only on .NET Core by default.
+                        // run-time boost so it's enabled only on .NET Core.
 #if RUNTIME_TYPE_NETCORE
-                        bool compileRegex = true;
-#else
-                        bool compileRegex = !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0);
+                        regexOptions |= RegexOptions.Compiled;
 #endif
-                        if (compileRegex)
-                        {
-                            regexOptions |= RegexOptions.Compiled;
-                        }
                         Regex newRegex = new Regex(matchFileExpression, regexOptions);
                         lock (s_regexCache)
                         {
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 09263b6b97c..776514e4d7d 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -6,7 +6,6 @@
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Linq;
-using System.Security.Cryptography.Xml;
 using System.Text;
 using System.Threading;
 using Microsoft.Build.BackEnd;
@@ -117,7 +116,7 @@ private void AddEdges(Dictionary<ConfigurationMetadata, ParsedProject> allParsed
 
             AddEdgesFromProjectReferenceItems(allParsedProjects, Edges);
 
-            _projectInterpretation.ReparentInnerBuilds(allParsedProjects, this);
+            _projectInterpretation.AddInnerBuildEdges(allParsedProjects, this);
 
             if (_solutionDependencies != null && _solutionDependencies.Count != 0)
             {
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index e8a6624faf2..b64b17cee58 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -588,9 +588,8 @@ private static IReadOnlyCollection<ProjectGraphNode> TopologicalSort(
         ///     This method uses the ProjectReferenceTargets items to determine the targets to run per node. The results can then
         ///     be used to start building each project individually, assuming a given project is built after its references.
         /// </remarks>
-        /// <param name="entryProjectTargets">
-        ///     The target list for the <see cref="GraphRoots" />. May be null or empty, in which case the entry projects' default
-        ///     targets will be used.
+        /// <param name="entryProjectTargets">The target list for the entry project. May be null or empty, in which case the entry
+        /// projects' default targets will be used.
         /// </param>
         /// <returns>
         ///     A dictionary containing the target list for each node. If a node's target list is empty, then no targets were
@@ -606,8 +605,7 @@ public IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> GetTargetLis
             var encounteredEdges = new HashSet<ProjectGraphBuildRequest>();
             var edgesToVisit = new Queue<ProjectGraphBuildRequest>();
 
-            // Initial state for the graph roots
-            foreach (var entryPointNode in GraphRoots)
+            foreach (ProjectGraphNode entryPointNode in EntryPointNodes)
             {
                 var entryTargets = entryProjectTargets == null || entryProjectTargets.Count == 0
                     ? ImmutableList.CreateRange(entryPointNode.ProjectInstance.DefaultTargets)
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index bbd597033fb..a293483551b 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -105,12 +105,12 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                 var requesterPlatform = "";
                 var requesterPlatformLookupTable = "";
 
-                if ( !projectReferenceItem.HasMetadata(SetPlatformMetadataName) && ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
+                if (!projectReferenceItem.HasMetadata(SetPlatformMetadataName) && ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
                 {
                     requesterPlatform = requesterInstance.GetPropertyValue("Platform");
                     requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
 
-                    var  projectInstance = _projectInstanceFactory(
+                    var projectInstance = _projectInstanceFactory(
                         projectReferenceFullPath,
                         null, // Platform negotiation requires an evaluation with no global properties first
                         _projectCollection);
@@ -164,30 +164,28 @@ internal static ProjectType GetProjectType(ProjectInstance project)
         }
 
         /// <summary>
-        /// To avoid calling nuget at graph construction time, the graph is initially constructed with outer build nodes referencing inner build nodes.
-        /// However, at build time, for non root outer builds, the inner builds are NOT referenced by the outer build, but by the nodes referencing the
-        /// outer build. Change the graph to mimic this behaviour.
-        /// Examples
-        /// OuterAsRoot -> Inner go to OuterAsRoot -> Inner. Inner builds remain the same, parented to their outer build
-        /// Node -> Outer -> Inner go to: Node -> Outer; Node->Inner; Outer -> empty. Inner builds get reparented to Node
+        /// To avoid calling nuget at graph construction time, the graph is initially constructed with nodes referencing outer build nodes which in turn
+        /// reference inner build nodes. However at build time, the inner builds are referenced directly by the nodes referencing the outer build.
+        /// Change the graph to mimic this behaviour.
+        /// Example: Node -> Outer -> Inner go to: Node -> Outer; Node->Inner; Outer -> Inner. Inner build edges get added to Node.
         /// </summary>
-        public void ReparentInnerBuilds(Dictionary<ConfigurationMetadata, ParsedProject> allNodes, GraphBuilder graphBuilder)
+        public void AddInnerBuildEdges(Dictionary<ConfigurationMetadata, ParsedProject> allNodes, GraphBuilder graphBuilder)
         {
-            foreach (var node in allNodes)
+            foreach (KeyValuePair<ConfigurationMetadata, ParsedProject> node in allNodes)
             {
-                var outerBuild = node.Value.GraphNode;
+                ProjectGraphNode outerBuild = node.Value.GraphNode;
 
                 if (GetProjectType(outerBuild.ProjectInstance) == ProjectType.OuterBuild && outerBuild.ReferencingProjects.Count != 0)
                 {
-                    foreach (var innerBuild in outerBuild.ProjectReferences)
+                    foreach (ProjectGraphNode innerBuild in outerBuild.ProjectReferences)
                     {
-                        foreach (var outerBuildReferencingProject in outerBuild.ReferencingProjects)
+                        foreach (ProjectGraphNode outerBuildReferencingProject in outerBuild.ReferencingProjects)
                         {
                             // Which edge should be used to connect the outerBuildReferencingProject to the inner builds?
                             // Decided to use the outerBuildBuildReferencingProject -> outerBuild edge in order to preserve any extra metadata
                             // information that may be present on the edge, like the "Targets" metadata which specifies what
                             // targets to call on the references.
-                            var newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
+                            ProjectItemInstance newInnerBuildEdge = graphBuilder.Edges[(outerBuildReferencingProject, outerBuild)];
 
                             if (outerBuildReferencingProject.ProjectReferences.Contains(innerBuild))
                             {
@@ -204,8 +202,6 @@ public void ReparentInnerBuilds(Dictionary<ConfigurationMetadata, ParsedProject>
                             outerBuildReferencingProject.AddProjectReference(innerBuild, newInnerBuildEdge, graphBuilder.Edges);
                         }
                     }
-
-                    outerBuild.RemoveReferences(graphBuilder.Edges);
                 }
             }
         }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index de9f9d01451..d3cb5c170a7 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -23,7 +23,6 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using ObjectModel = System.Collections.ObjectModel;
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index bc191a256a9..41135bc767b 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -3,13 +3,11 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
 using System.Reflection;
 #if FEATURE_APPDOMAIN
 using System.Threading.Tasks;
 #endif
 
-using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
index 5ea0941cde1..46c583f3472 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogRecordKind.cs
@@ -29,6 +29,7 @@ internal enum BinaryLogRecordKind
         PropertyInitialValueSet,
         NameValueList,
         String,
-        TaskParameter
+        TaskParameter,
+        ResponseFileUsed, 
     }
 }
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 7fbddddf7ee..3e29b27e99e 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -3,7 +3,6 @@
 using System.IO.Compression;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -53,7 +52,9 @@ public sealed class BinaryLogger : ILogger
         //   - TargetSkippedEventArgs: added OriginallySucceeded, Condition, EvaluatedCondition
         // version 14:
         //   - TargetSkippedEventArgs: added SkipReason, OriginalBuildEventContext
-        internal const int FileFormatVersion = 14;
+        // version 15:
+        //   - new record kind: ResponseFileUsedEventArgs
+        internal const int FileFormatVersion = 15;
 
         private Stream stream;
         private BinaryWriter binaryWriter;
@@ -270,6 +271,10 @@ private void CollectImports(BuildEventArgs e)
             {
                 projectImportsCollector.AddFileFromMemory(metaprojectArgs.ProjectFile, metaprojectArgs.metaprojectXml);
             }
+            else if (e is ResponseFileUsedEventArgs responseFileArgs && responseFileArgs.ResponseFilePath != null)
+            {
+                projectImportsCollector.AddFile(responseFileArgs.ResponseFilePath);
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
index 64a26269a78..a93e2074044 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsReader.cs
@@ -176,6 +176,9 @@ public BuildEventArgs Read()
                 case BinaryLogRecordKind.EnvironmentVariableRead:
                     result = ReadEnvironmentVariableReadEventArgs();
                     break;
+                case BinaryLogRecordKind.ResponseFileUsed:
+                    result = ReadResponseFileUsedEventArgs();
+                    break;
                 case BinaryLogRecordKind.PropertyReassignment:
                     result = ReadPropertyReassignmentEventArgs();
                     break;
@@ -727,6 +730,16 @@ private BuildEventArgs ReadEnvironmentVariableReadEventArgs()
             return e;
         }
 
+        private BuildEventArgs ReadResponseFileUsedEventArgs()
+        {
+            var fields = ReadBuildEventArgsFields();
+            var responseFilePath = ReadDeduplicatedString();
+            var e = new ResponseFileUsedEventArgs(responseFilePath);
+            SetCommonFields(e, fields);
+
+            return e;
+        }
+
         private BuildEventArgs ReadPropertyReassignmentEventArgs()
         {
             var fields = ReadBuildEventArgsFields(readImportance: true);
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 46f8eb085de..79dac4ce124 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -428,6 +428,7 @@ private void Write(BuildMessageEventArgs e)
         {
             switch (e)
             {
+                case ResponseFileUsedEventArgs responseFileUsed: Write(responseFileUsed); break;
                 case TaskParameterEventArgs taskParameter: Write(taskParameter); break;
                 case ProjectImportedEventArgs projectImported: Write(projectImported); break;
                 case TargetSkippedEventArgs targetSkipped: Write(targetSkipped); break;
@@ -506,7 +507,12 @@ private void Write(EnvironmentVariableReadEventArgs e)
             WriteMessageFields(e, writeImportance: true);
             WriteDeduplicatedString(e.EnvironmentVariableName);
         }
-
+        private void Write(ResponseFileUsedEventArgs e)
+        {
+            Write(BinaryLogRecordKind.ResponseFileUsed);
+            WriteMessageFields(e);
+            WriteDeduplicatedString(e.ResponseFilePath);
+        }
         private void Write(TaskCommandLineEventArgs e)
         {
             Write(BinaryLogRecordKind.TaskCommandLine);
diff --git a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
index e56f4750920..15f5a816ccf 100644
--- a/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
+++ b/src/Build/Logging/BinaryLogger/ProjectImportsCollector.cs
@@ -130,8 +130,7 @@ private void AddFileCore(string filePath)
                 return;
             }
 
-            var fileInfo = new FileInfo(filePath);
-            if (!fileInfo.Exists || fileInfo.Length == 0)
+            if (!File.Exists(filePath))
             {
                 _processedFiles.Add(filePath);
                 return;
@@ -145,11 +144,9 @@ private void AddFileCore(string filePath)
                 return;
             }
 
-            using (Stream entryStream = OpenArchiveEntry(filePath))
-            using (FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete))
-            {
-                content.CopyTo(entryStream);
-            }
+            using FileStream content = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete);
+            using Stream entryStream = OpenArchiveEntry(filePath);
+            content.CopyTo(entryStream);
         }
 
         /// <remarks>
diff --git a/src/Build/Logging/FancyLogger/ANSIBuilder.cs b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
new file mode 100644
index 00000000000..79b4e833241
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/ANSIBuilder.cs
@@ -0,0 +1,392 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Text.RegularExpressions;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    internal static class ANSIBuilder
+    {
+        public static string ANSIRemove(string text)
+        {
+            return Regex.Replace(text, "\\x1b(?:[@-Z\\-_]|\\[[0-?]*[ -\\/]*[@-~])", "");
+        }
+
+        public static class Alignment
+        {
+            public static string Center(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth) return text;
+                int space = (Console.BufferWidth - noFormatString.Length) / 2;
+                result += new string(' ', space);
+                result += text;
+                result += new string(' ', space);
+                return result;
+            }
+
+            public static string Right(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth) return text;
+                int space = Console.BufferWidth - noFormatString.Length;
+                result += new string(' ', space);
+                result += text;
+                return result;
+            }
+
+            public static string Left(string text)
+            {
+                string result = String.Empty;
+                string noFormatString = ANSIRemove(text);
+                if (noFormatString.Length > Console.BufferWidth) return text;
+                int space = Console.BufferWidth - noFormatString.Length;
+                result += text;
+                result += new string(' ', space);
+                return result;
+            }
+
+            public static string SpaceBetween(string leftText, string rightText, int width)
+            {
+                string result = String.Empty;
+                string leftNoFormatString = ANSIRemove(leftText);
+                string rightNoFormatString = ANSIRemove(rightText);
+                if (leftNoFormatString.Length + rightNoFormatString.Length > Console.BufferWidth) return leftText + rightText;
+                int space = Console.BufferWidth - (leftNoFormatString.Length + rightNoFormatString.Length) - 1;
+                result += leftText;
+                result += new string(' ', space);
+                result += rightText;
+                return result;
+            }
+        }
+
+        public static class Formatting
+        {
+            public enum ForegroundColor
+            {
+                Black = 30,
+                Red = 31,
+                Green = 32,
+                Yellow = 33,
+                Blue = 34,
+                Magenta = 35,
+                Cyan = 36,
+                White = 37,
+                Default = 39
+            };
+
+            public enum BackgroundColor
+            {
+                Black = 40,
+                Red = 41,
+                Green = 42,
+                Yellow = 43,
+                Blue = 44,
+                Magenta = 45,
+                Cyan = 46,
+                White = 47,
+                Default = 49
+            }
+
+            public static string Color(string text, ForegroundColor color)
+            {
+                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
+            }
+
+            public static string Color(string text, BackgroundColor color)
+            {
+                return String.Format("\x1b[{0}m{1}\x1b[0m", (int)color, text);
+            }
+
+            public static string Color(string text, BackgroundColor backgrdoundColor, ForegroundColor foregroundColor)
+            {
+                return String.Format("\x1b[{0};{1}m{2}\x1b[0m", (int)backgrdoundColor, (int)foregroundColor, text);
+            }
+
+            public static string Bold(string text)
+            {
+                return String.Format("\x1b[1m{0}\x1b[22m", text);
+            }
+
+            public static string Dim(string text)
+            {
+                return String.Format("\x1b[2m{0}\x1b[22m", text);
+            }
+
+            public static string Italic(string text)
+            {
+                return String.Format("\x1b[3m{0}\x1b[23m", text);
+            }
+
+            public static string Underlined(string text)
+            {
+                return String.Format("\x1b[4m{0}\x1b[24m", text);
+            }
+
+            public static string DoubleUnderlined(string text)
+            {
+                return String.Format("\x1b[21m{0}\x1b[24m", text);
+            }
+
+            public static string Blinking(string text)
+            {
+                return String.Format("\x1b[5m{0}\x1b[25m", text);
+            }
+
+            public static string Inverse(string text)
+            {
+                return String.Format("\x1b[7m{0}\x1b[27m", text);
+            }
+
+            public static string Invisible(string text)
+            {
+                return String.Format("\x1b[8m{0}\x1b[28m", text);
+            }
+
+            public static string CrossedOut(string text)
+            {
+                return String.Format("\x1b[9m{0}\x1b[29m", text);
+            }
+
+            public static string Overlined(string text)
+            {
+                return String.Format("\x1b[53m{0}\x1b[55m", text);
+            }
+
+            // TODO: Right now only replaces \ with /. Needs review to make sure it works on all or most terminal emulators.
+            public static string Hyperlink(string text, string url)
+            {
+                // return String.Format("\x1b[]8;;{0}\x1b\\{1}\x1b[]8;\x1b\\", text, url);
+                return url.Replace("\\", "/");
+            }
+
+            public static string DECLineDrawing(string text)
+            {
+                return String.Format("\x1b(0{0}\x1b(B", text);
+            }
+        }
+
+        public static class Cursor
+        {
+            public enum CursorStyle
+            {
+                Default = 0,
+                BlockBlinking = 1,
+                BlockSteady = 2,
+                UnderlineBlinking = 3,
+                UnderlineSteady = 4,
+                BarBlinking = 5,
+                BarSteady = 6,
+            }
+
+            public static string Style(CursorStyle style)
+            {
+                return String.Format("\x1b[{0} q", (int)style);
+            }
+
+            public static string Up(int n = 1)
+            {
+                return String.Format("\x1b[{0}A", n);
+            }
+
+            public static string UpAndScroll(int n)
+            {
+                string result = "";
+                for (int i = 0; i < n; i++) {
+                    result += "\x1bM";
+                }
+                return result;
+            }
+
+            public static string Down(int n = 1)
+            {
+                return String.Format("\x1b[{0}B", n);
+            }
+
+            public static string Forward(int n = 1)
+            {
+                return String.Format("\x1b[{0}C", n);
+            }
+
+            public static string Backward(int n = 1)
+            {
+                return String.Format("\x1b[{0}D", n);
+            }
+
+            public static string Home()
+            {
+                return String.Format("\x1b[H");
+            }
+
+            public static string Position(int row, int column)
+            {
+                return String.Format("\x1b[{0};{1}H", row, column);
+            }
+
+            public static string SavePosition()
+            {
+                return String.Format("\x1b[s");
+            }
+
+            public static string RestorePosition() {
+                return String.Format("\x1b[u");
+            }
+
+            public static string Invisible()
+            {
+                return "\x1b[?25l";
+            }
+
+            public static string Visible()
+            {
+                return "\x1b[?25h";
+            }
+        }
+
+        public static class Tabulator
+        {
+            public static string SetStop()
+            {
+                return String.Format("\x1bH");
+            }
+
+            public static string ForwardTab(int n)
+            {
+                if (n == 0) return "";
+                return String.Format("\x1b[{0}I", n);
+            }
+
+            public static string BackwardTab(int n)
+            {
+                return String.Format("\x1b[{0}Z", n);
+            }
+
+            public static string UnsetStop()
+            {
+                return String.Format("\x1b[0g");
+            }
+
+            public static string UnserAlStops()
+            {
+                return String.Format("\x1b[3g");
+            }
+        }
+
+        public static class Viewport
+        {
+            public static string ScrollDown(int n)
+            {
+                return String.Format("\x1b[{0}T", n);
+            }
+
+            public static string ScrollUp(int n)
+            {
+                return String.Format("\x1b[{0}S", n);
+            }
+
+            public static string SetScrollingRegion(int start, int end)
+            {
+                return String.Format("\x1b[{0};{1}r", start, end);
+            }
+
+            public static string PrependLines(int n)
+            {
+                return String.Format("\x1b[{0}L", n);
+            }
+
+            public static string DeleteLines(int n)
+            {
+                return String.Format("\x1b[{0}M", n);
+            }
+        }
+
+        public static class Eraser
+        {
+            public static string DisplayCursorToEnd()
+            {
+                return String.Format("\x1b[0J");
+            }
+
+            public static string DisplayStartToCursor()
+            {
+                return String.Format("\x1b[1J");
+            }
+
+            public static string Display()
+            {
+                return String.Format("\x1b[2J");
+            }
+
+            public static string LineCursorToEnd()
+            {
+                return String.Format("\x1b[0K");
+            }
+
+            public static string LineStartToCursor()
+            {
+                return String.Format("\x1b[1K");
+            }
+
+            public static string Line()
+            {
+                return String.Format("\x1b[2k");
+            }
+        }
+
+        public static class Graphics
+        {
+            private static int spinnerCounter = 0;
+            public static string Spinner()
+            {
+                return Spinner(spinnerCounter++);
+            }
+
+            public static string Spinner(int n)
+            {
+                char[] chars = { '\\', '|', '/', '-'};
+                return chars[n % (chars.Length - 1)].ToString();
+            }
+
+            public static string ProgressBar(float percentage, int width = 10, char completedChar = '█', char remainingChar = '░')
+            {
+                string result = String.Empty;
+                for (int i = 0; i < (int)Math.Floor(width * percentage); i++)
+                {
+                    result += completedChar;
+                }
+                for (int i = (int)Math.Floor(width * percentage); i < width; i++)
+                {
+                    result += remainingChar;
+                }
+                return result;
+            }
+
+            public static string Bell()
+            {
+                return String.Format("\x07");
+            }
+        }
+
+        public static class Buffer
+        {
+            public static string Fill()
+            {
+                return String.Format("\x1b#8");
+            }
+
+            public static string UseAlternateBuffer()
+            {
+                return "\x1b[?1049h";
+            }
+
+            public static string UseMainBuffer()
+            {
+                return "\x1b[?1049l";
+            }
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLogger.cs b/src/Build/Logging/FancyLogger/FancyLogger.cs
new file mode 100644
index 00000000000..19238214324
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLogger.cs
@@ -0,0 +1,188 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    public class FancyLogger : ILogger
+    {   
+        private Dictionary<int, FancyLoggerProjectNode> projects = new Dictionary<int, FancyLoggerProjectNode>();
+
+        private bool Succeeded;
+
+        private float existingTasks = 1;
+        private float completedTasks = 0;
+
+        public string Parameters {  get; set; }
+
+        public LoggerVerbosity Verbosity { get; set; }
+
+        public FancyLogger()
+        {
+            Parameters = "";
+        }
+
+        public void Initialize(IEventSource eventSource)
+        {
+            // Register for different events
+            // Started
+            eventSource.BuildStarted += new BuildStartedEventHandler(eventSource_BuildStarted);
+            eventSource.ProjectStarted += new ProjectStartedEventHandler(eventSource_ProjectStarted);
+            eventSource.TargetStarted += new TargetStartedEventHandler(eventSource_TargetStarted);
+            eventSource.TaskStarted += new TaskStartedEventHandler(eventSource_TaskStarted);
+            // Finished
+            eventSource.BuildFinished += new BuildFinishedEventHandler(eventSource_BuildFinished);
+            eventSource.ProjectFinished += new ProjectFinishedEventHandler(eventSource_ProjectFinished);
+            eventSource.TargetFinished += new TargetFinishedEventHandler(eventSource_TargetFinished);
+            // eventSource.TaskFinished += new TaskFinishedEventHandler(eventSource_TaskFinished);
+            // Raised
+            eventSource.MessageRaised += new BuildMessageEventHandler(eventSource_MessageRaised);
+            eventSource.WarningRaised += new BuildWarningEventHandler(eventSource_WarningRaised);
+            eventSource.ErrorRaised += new BuildErrorEventHandler(eventSource_ErrorRaised);
+            // Cancelled
+            Console.CancelKeyPress += new ConsoleCancelEventHandler(console_CancelKeyPressed);
+            // Initialize FancyLoggerBuffer
+            FancyLoggerBuffer.Initialize();
+        }
+
+        // Build
+        void eventSource_BuildStarted(object sender, BuildStartedEventArgs e)
+        {
+        }
+        void eventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
+        {
+            Succeeded = e.Succeeded;
+            // Console.WriteLine(LoggerFormatting.Bold("[Build]") + "\t Finished");
+        }
+
+        // Project
+        void eventSource_ProjectStarted(object sender, ProjectStartedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            // If id already exists...
+            if (projects.ContainsKey(id)) return;
+            // Add project
+            FancyLoggerProjectNode node = new FancyLoggerProjectNode(e);
+            projects[id] = node;
+            // Log
+            node.Log();
+        }
+        void eventSource_ProjectFinished(object sender, ProjectFinishedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update line
+            node.Finished = true;
+            node.Log();
+        }
+        // Target
+        void eventSource_TargetStarted(object sender, TargetStartedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddTarget(e);
+            node.Log();
+        }
+        void eventSource_TargetFinished(object sender, TargetFinishedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.FinishedTargets++;
+            node.Log();
+        }
+
+        // Task
+        void eventSource_TaskStarted(object sender, TaskStartedEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddTask(e);
+            node.Log();
+            existingTasks++;
+        }
+
+        void eventSource_TaskFinished(object sender, TaskFinishedEventArgs e)
+        {
+            completedTasks++;
+        }
+
+        void eventSource_MessageRaised(object sender, BuildMessageEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddMessage(e);
+            node.Log();
+        }
+        void eventSource_WarningRaised(object sender, BuildWarningEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddWarning(e);
+            node.Log();
+        }
+        void eventSource_ErrorRaised(object sender, BuildErrorEventArgs e)
+        {
+            // Get project id
+            int id = e.BuildEventContext!.ProjectInstanceId;
+            if (!projects.TryGetValue(id, out FancyLoggerProjectNode? node)) return;
+            // Update
+            node.AddError(e);
+            node.Log();
+        }
+
+        void console_CancelKeyPressed(object? sender, ConsoleCancelEventArgs eventArgs)
+        {
+            // Shutdown logger
+            Shutdown();
+        }
+
+        public void Shutdown()
+        {
+            FancyLoggerBuffer.Terminate();
+            // TODO: Remove. There is a bug that causes switching to main buffer without deleting the contents of the alternate buffer
+            Console.Clear();
+            Console.Out.Flush();
+            int errorCount = 0;
+            int warningCount = 0;
+            foreach (var project in projects)
+            {
+                errorCount += project.Value.ErrorCount;
+                warningCount += project.Value.WarningCount;
+                foreach (var message in project.Value.AdditionalDetails)
+                {
+                    Console.WriteLine(message.ToANSIString());
+                }
+            }
+            // Emmpty line
+            Console.WriteLine();
+            if (Succeeded)
+            {
+                Console.WriteLine(ANSIBuilder.Formatting.Color("Build succeeded.", ANSIBuilder.Formatting.ForegroundColor.Green));
+                Console.WriteLine($"\t{warningCount} Warning(s)");
+                Console.WriteLine($"\t{errorCount} Error(s)");
+            }
+            else
+            {
+                Console.WriteLine(ANSIBuilder.Formatting.Color("Build failed.", ANSIBuilder.Formatting.ForegroundColor.Red));
+                Console.WriteLine($"\t{warningCount} Warnings(s)");
+                Console.WriteLine($"\t{errorCount} Errors(s)");
+            }
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs b/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
new file mode 100644
index 00000000000..25280e06101
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerBuffer.cs
@@ -0,0 +1,203 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{
+    public class FancyLoggerBufferLine
+    {
+        private static int Counter = 0;
+        public int Id;
+        public string Text;
+
+        public FancyLoggerBufferLine()
+        {
+            Id = Counter++;
+            Text = String.Empty;
+        }
+        public FancyLoggerBufferLine(string text)
+            : this()
+        {
+            Text = text;
+        }
+    }
+
+    public class FancyLoggerBuffer
+    {
+        private static List<FancyLoggerBufferLine> Lines = new();
+        private static int TopLineIndex = 0;
+        private static bool AutoScrollEnabled = true;
+        public static void Initialize()
+        {
+            // Use alternate buffer
+            // TODO: Remove. Tries to solve a bug when switching from and to the alternate buffer
+            // Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
+            Console.OutputEncoding = Encoding.UTF8;
+            Console.Write(ANSIBuilder.Buffer.UseAlternateBuffer());
+
+            Console.Write(ANSIBuilder.Cursor.Invisible());
+
+            Task.Run(async () => {
+                while (true)
+                {
+                    await Task.Delay(500 / 60);
+                    Render();
+                }
+            });
+
+            Task.Run(() =>
+            {
+                while (true)
+                {
+                    switch (Console.ReadKey().Key)
+                    {
+                        case ConsoleKey.UpArrow:
+                            if (TopLineIndex > 0) TopLineIndex--;
+                            break;
+                        case ConsoleKey.DownArrow:
+                            if (TopLineIndex < Console.BufferHeight - 3) TopLineIndex++;
+                            break;
+                        case ConsoleKey.Spacebar:
+                        case ConsoleKey.Escape:
+                            AutoScrollEnabled = !AutoScrollEnabled;
+                            break;
+                    }
+                }
+            });
+        }
+
+        public static void Terminate()
+        {
+            // TODO: Remove. Tries to solve a bug when switching from and to the alternate buffer
+            Console.Clear();
+            Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
+            Console.Write(ANSIBuilder.Eraser.Display());
+
+            Console.Write(ANSIBuilder.Cursor.Visible());
+            Lines = new();
+        }
+
+        #region Rendering
+        public static void Render()
+        {
+            if (Lines.Count == 0) return;
+            // Write Header
+            Console.Write(
+                // Write header
+                ANSIBuilder.Cursor.Home() +
+                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Formatting.Inverse(ANSIBuilder.Alignment.Center("MSBuild - Build in progress")) +
+                // Write footer
+                ANSIBuilder.Eraser.LineCursorToEnd() + ANSIBuilder.Cursor.Position(Console.BufferHeight - 1, 0) +
+                // TODO: Remove and replace with actual footer
+                new string('-', Console.BufferWidth) + '\n' + "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
+            );
+            // Write lines
+            for (int i = 0; i < Console.BufferHeight - 3; i++)
+            {
+                int lineIndex = i + TopLineIndex;
+                Console.Write(
+                    ANSIBuilder.Cursor.Position(i + 2, 0) +
+                    ANSIBuilder.Eraser.LineCursorToEnd() + 
+                    (lineIndex < Lines.Count ? Lines[lineIndex].Text : String.Empty)
+                );
+            }
+        }
+        #endregion
+
+        #region Line identification
+        public static int GetLineIndexById(int lineId)
+        {
+            for (int i = 0; i < Lines.Count; i++)
+            {
+                if (Lines[i].Id == lineId) return i;
+            }
+            return -1;
+        }
+
+        public static FancyLoggerBufferLine? GetLineById(int lineId)
+        {
+            int index = GetLineIndexById(lineId);
+            if (index == -1) return null;
+            return Lines[index];
+        }
+        #endregion
+
+        #region Line create, update and delete
+        // Write new line
+        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, string text)
+        {
+            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
+            return WriteNewLineAfter(lineId, line);
+        }
+        public static FancyLoggerBufferLine? WriteNewLineAfter(int lineId, FancyLoggerBufferLine line)
+        {
+            // Get line index
+            int lineIndex = GetLineIndexById(lineId);
+            if (lineIndex == -1) return null;
+            // Save top line
+            int topLineId = Lines[TopLineIndex].Id;
+            // Add
+            Lines.Insert(lineIndex + 1, line);
+            // Get updated top line index
+            TopLineIndex = GetLineIndexById(topLineId);
+            // Return
+            return line;
+        }
+
+        public static FancyLoggerBufferLine? WriteNewLine(string text)
+        {
+            FancyLoggerBufferLine line = new FancyLoggerBufferLine(text);
+            return WriteNewLine(line);
+        }
+        public static FancyLoggerBufferLine? WriteNewLine(FancyLoggerBufferLine line)
+        {
+            // Get last id
+            if (Lines.Count > 0)
+            {
+                int lineId = Lines.Last().Id;
+                return WriteNewLineAfter(lineId, line);
+            }
+            else
+            {
+                Lines.Add(line);
+                return line;
+            }
+        }
+
+        // Update line
+        public static FancyLoggerBufferLine? UpdateLine(int lineId, string text)
+        {
+            // Get line
+            FancyLoggerBufferLine? line = GetLineById(lineId);
+            if (line == null) return null;
+            line.Text = text;
+            // Return
+            return line;
+        }
+
+        // Delete line
+        public static void DeleteLine(int lineId)
+        {
+            // TODO: What if line id is equal to topLineId?????
+            // Get line index
+            int lineIndex = GetLineIndexById(lineId);
+            if (lineIndex == -1) return;
+            // Save top line
+            int topLineId = Lines[TopLineIndex].Id;
+            // Delete
+            Lines.RemoveAt(lineIndex);
+            // Get updated top line index
+            if (topLineId != lineId)
+            {
+                TopLineIndex = GetLineIndexById(topLineId);
+            }
+        }
+        #endregion
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
new file mode 100644
index 00000000000..3fd242849b9
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerMessageNode.cs
@@ -0,0 +1,90 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    public class FancyLoggerMessageNode
+    {
+        public enum MessageType
+        {
+            HighPriorityMessage,
+            Warning,
+            Error
+        }
+        public string Message;
+        public FancyLoggerBufferLine? Line;
+        public MessageType Type;
+        //
+        public string? Code;
+        public string? FilePath;
+        public int? LineNumber;
+        public int? ColumnNumber;
+        public FancyLoggerMessageNode(LazyFormattedBuildEventArgs args)
+        {
+            // Get type
+            switch (args)
+            {
+                case BuildMessageEventArgs:
+                    Type = MessageType.HighPriorityMessage;
+                    break;
+                case BuildWarningEventArgs warning:
+                    Type = MessageType.Warning;
+                    Code = warning.Code;
+                    FilePath = warning.File;
+                    LineNumber = warning.LineNumber;
+                    ColumnNumber = warning.ColumnNumber;
+                    break;
+                case BuildErrorEventArgs error:
+                    Type = MessageType.Error;
+                    Code = error.Code;
+                    FilePath = error.File;
+                    LineNumber = error.LineNumber;
+                    ColumnNumber = error.ColumnNumber;
+                    break;
+            }
+
+            // TODO: Replace
+            if (args.Message == null)
+            {
+                Message = string.Empty;
+            }
+            else if (args.Message.Length > Console.WindowWidth - 1)
+            {
+                Message = args.Message.Substring(0, Console.WindowWidth - 1);
+            }
+            else
+            {
+                Message = args.Message;
+            }
+        }
+
+        public string ToANSIString()
+        {
+            switch (Type)
+            {
+                case MessageType.Warning:
+                    return $"⚠️ {ANSIBuilder.Formatting.Color(
+                        $"Warning {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
+                        ANSIBuilder.Formatting.ForegroundColor.Yellow)}";
+                case MessageType.Error:
+                    return $"❌ {ANSIBuilder.Formatting.Color(
+                        $"Error {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
+                        ANSIBuilder.Formatting.ForegroundColor.Red)}";
+                case MessageType.HighPriorityMessage:
+                default:
+                    return $"ℹ️ {ANSIBuilder.Formatting.Italic(Message)}";
+            }
+        }
+
+        public void Log()
+        {
+            if (Line == null) return;
+            FancyLoggerBuffer.UpdateLine(Line.Id, $"    └── {ToANSIString()}");
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
new file mode 100644
index 00000000000..50effc76709
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerProjectNode.cs
@@ -0,0 +1,138 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+    internal class FancyLoggerProjectNode
+    {
+        /// <summary>
+        /// Given a list of paths, this method will get the shortest not ambiguous path for a project.
+        /// Example: for `/users/documents/foo/project.csproj` and `/users/documents/bar/project.csproj`, the respective non ambiguous paths would be `foo/project.csproj` and `bar/project.csproj`
+        /// Still work in progress...
+        /// </summary>
+        private static string GetUnambiguousPath(string path)
+        {
+            return Path.GetFileName(path);
+        }
+
+        public int Id;
+        public string ProjectPath;
+        public string TargetFramework;
+        public bool Finished;
+        // Line to display project info
+        public FancyLoggerBufferLine? Line;
+        // Targets
+        public int FinishedTargets;
+        public FancyLoggerBufferLine? CurrentTargetLine;
+        public FancyLoggerTargetNode? CurrentTargetNode;
+        // Messages, errors and warnings
+        public List<FancyLoggerMessageNode> AdditionalDetails = new();
+        // Count messages, warnings and errors
+        public int MessageCount = 0;
+        public int WarningCount = 0;
+        public int ErrorCount = 0;
+        public FancyLoggerProjectNode(ProjectStartedEventArgs args)
+        {
+            Id = args.ProjectId;
+            ProjectPath = args.ProjectFile!;
+            Finished = false;
+            FinishedTargets = 0;
+            if (args.GlobalProperties != null && args.GlobalProperties.ContainsKey("TargetFramework"))
+            {
+                TargetFramework = args.GlobalProperties["TargetFramework"];
+            }
+            else
+            {
+                TargetFramework = "";
+            }
+        }
+
+        public void Log()
+        {
+            // Project details
+            string lineContents = ANSIBuilder.Alignment.SpaceBetween(
+                // Show indicator
+                (Finished ? ANSIBuilder.Formatting.Color("✓", ANSIBuilder.Formatting.ForegroundColor.Green) : ANSIBuilder.Formatting.Blinking(ANSIBuilder.Graphics.Spinner())) +
+                // Project
+                ANSIBuilder.Formatting.Dim("Project: ") +
+                // Project file path with color
+                $"{ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), Finished ? ANSIBuilder.Formatting.ForegroundColor.Green : ANSIBuilder.Formatting.ForegroundColor.Default )} [{TargetFramework ?? "*"}]",
+                $"({MessageCount} Messages, {WarningCount} Warnings, {ErrorCount} Errors)",
+                Console.WindowWidth
+            );
+
+            // Create or update line
+            if (Line == null) Line = FancyLoggerBuffer.WriteNewLine(lineContents);
+            else FancyLoggerBuffer.UpdateLine(Line.Id, lineContents);
+
+            // For finished projects
+            if (Finished)
+            {
+                if (CurrentTargetLine != null) FancyLoggerBuffer.DeleteLine(CurrentTargetLine.Id);
+                foreach (FancyLoggerMessageNode node in AdditionalDetails.ToList())
+                {
+                    // Only delete high priority messages
+                    if (node.Type != FancyLoggerMessageNode.MessageType.HighPriorityMessage) continue;
+                    if (node.Line != null) FancyLoggerBuffer.DeleteLine(node.Line.Id);
+                    // AdditionalDetails.Remove(node);
+                }
+            }
+
+            // Current target details
+            if (CurrentTargetNode == null) return;
+            string currentTargetLineContents = $"    └── {CurrentTargetNode.TargetName} : {CurrentTargetNode.CurrentTaskNode?.TaskName ?? String.Empty}";
+            if (CurrentTargetLine == null) CurrentTargetLine = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, currentTargetLineContents);
+            else FancyLoggerBuffer.UpdateLine(CurrentTargetLine.Id, currentTargetLineContents);
+
+            // Messages, warnings and errors
+            foreach (FancyLoggerMessageNode node in AdditionalDetails)
+            {
+                if (Finished && node.Type == FancyLoggerMessageNode.MessageType.HighPriorityMessage) continue;
+                if (node.Line == null) node.Line = FancyLoggerBuffer.WriteNewLineAfter(Line!.Id, "Message");
+                node.Log();
+            }
+        }
+
+        public FancyLoggerTargetNode AddTarget(TargetStartedEventArgs args)
+        {
+            CurrentTargetNode = new FancyLoggerTargetNode(args);
+            return CurrentTargetNode;
+        }
+        public FancyLoggerTaskNode? AddTask(TaskStartedEventArgs args)
+        {
+            // Get target id
+            int targetId = args.BuildEventContext!.TargetId;
+            if (CurrentTargetNode?.Id == targetId) return CurrentTargetNode.AddTask(args);
+            else return null;
+        }
+        public FancyLoggerMessageNode? AddMessage(BuildMessageEventArgs args)
+        {
+            if (args.Importance != MessageImportance.High) return null;
+            MessageCount++;
+            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            AdditionalDetails.Add(node);
+            return node;
+        }
+        public FancyLoggerMessageNode? AddWarning(BuildWarningEventArgs args)
+        {
+            WarningCount++;
+            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            AdditionalDetails.Add(node);
+            return node;
+        }
+        public FancyLoggerMessageNode? AddError(BuildErrorEventArgs args)
+        {
+            ErrorCount++;
+            FancyLoggerMessageNode node = new FancyLoggerMessageNode(args);
+            AdditionalDetails.Add(node);
+            return node;
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs
new file mode 100644
index 00000000000..0c5ad00ed4f
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerTargetNode.cs
@@ -0,0 +1,26 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    public class FancyLoggerTargetNode
+    {
+        public int Id;
+        public string TargetName;
+        public FancyLoggerTaskNode? CurrentTaskNode;
+        public FancyLoggerTargetNode(TargetStartedEventArgs args)
+        {
+            Id = args.BuildEventContext!.TargetId;
+            TargetName = args.TargetName;
+        }
+        public FancyLoggerTaskNode AddTask(TaskStartedEventArgs args)
+        {
+            CurrentTaskNode = new FancyLoggerTaskNode(args);
+            return CurrentTaskNode;
+        }
+    }
+}
diff --git a/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs b/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs
new file mode 100644
index 00000000000..d645a5daedc
--- /dev/null
+++ b/src/Build/Logging/FancyLogger/FancyLoggerTaskNode.cs
@@ -0,0 +1,20 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+//
+
+using Microsoft.Build.Framework;
+
+namespace Microsoft.Build.Logging.FancyLogger
+{ 
+
+    public class FancyLoggerTaskNode
+    {
+        public int Id;
+        public string TaskName;
+        public FancyLoggerTaskNode(TaskStartedEventArgs args)
+        {
+            Id = args.BuildEventContext!.TaskId;
+            TaskName = args.TaskName;
+        }
+    }
+}
diff --git a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
index 84c2508d8e1..2e92c39751e 100644
--- a/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
+++ b/src/Build/Logging/ParallelLogger/ConsoleOutputAligner.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Diagnostics;
 using System.Text;
 using Microsoft.Build.Shared;
 
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 3d184b648f1..8d7cf63540a 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using ColorSetter = Microsoft.Build.Logging.ColorSetter;
 using ColorResetter = Microsoft.Build.Logging.ColorResetter;
 using WriteHandler = Microsoft.Build.Logging.WriteHandler;
@@ -1364,50 +1363,7 @@ private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int
             lock (_lockObject)
             {
                 int adjustedPrefixWidth = _prefixWidth + prefixAdjustment;
-
-                if (!ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-                {
-                    // The string may contain new lines, treat each new line as a different string to format and send to the console
-                    string[] nonNullMessages = SplitStringOnNewLines(message);
-                    for (int i = 0; i < nonNullMessages.Length; i++)
-                    {
-                        string nonNullMessage = nonNullMessages[i];
-                        // Take into account the new line char which will be added to the end or each reformatted string
-                        int bufferWidthMinusNewLine = _bufferWidth - 1;
-
-                        // If the buffer is larger then the prefix information (timestamp and key) then reformat the messages. 
-                        // If there is not enough room just print the message out and let the console do the formatting
-                        bool bufferIsLargerThanPrefix = bufferWidthMinusNewLine > adjustedPrefixWidth;
-                        bool messageAndPrefixTooLargeForBuffer = (nonNullMessage.Length + adjustedPrefixWidth) > bufferWidthMinusNewLine;
-                        if (bufferIsLargerThanPrefix && messageAndPrefixTooLargeForBuffer && _alignMessages)
-                        {
-                            // Our message may have embedded tab characters, so expand those to their space
-                            // equivalent so that wrapping works as expected.
-                            nonNullMessage = nonNullMessage.Replace("\t", consoleTab);
-
-                            // If the message and the prefix are too large for one line in the console, split the string to fit
-                            int index = 0;
-                            int messageLength = nonNullMessage.Length;
-                            // Loop until all the string has been sent to the console
-                            while (index < messageLength)
-                            {
-                                // Calculate how many chars will fit on the console buffer
-                                int amountToCopy = (messageLength - index) < (bufferWidthMinusNewLine - adjustedPrefixWidth) ? (messageLength - index) : (bufferWidthMinusNewLine - adjustedPrefixWidth);
-                                WriteBasedOnPrefix(nonNullMessage.Substring(index, amountToCopy), prefixAlreadyWritten && index == 0 && i == 0, adjustedPrefixWidth);
-                                index += amountToCopy;
-                            }
-                        }
-                        else
-                        {
-                            // there is not enough room just print the message out and let the console do the formatting
-                            WriteBasedOnPrefix(nonNullMessage, prefixAlreadyWritten, adjustedPrefixWidth);
-                        }
-                    }
-                }
-                else
-                {
-                    WriteHandler(_consoleOutputAligner.AlignConsoleOutput(message, prefixAlreadyWritten, adjustedPrefixWidth));
-                }
+                WriteHandler(_consoleOutputAligner.AlignConsoleOutput(message, prefixAlreadyWritten, adjustedPrefixWidth));
             }
         }
 
@@ -1793,7 +1749,6 @@ internal override void PrintCounterMessage(WriteLinePrettyFromResourceDelegate W
         private bool _forceNoAlign;
         private bool _showEventId;
         // According to the documentation for ENABLE_PROCESSED_OUTPUT tab width for the console is 8 characters
-        private const string consoleTab = "        ";
         #endregion
 
         #region Per-build Members
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 7ec2ec46738..a0bc0207854 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -20,6 +20,7 @@
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which is used to create, edit, and evaluate MSBuild projects.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <ApplyNgenOptimization Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">full</ApplyNgenOptimization>
+    <EnablePackageValidation>true</EnablePackageValidation>
 
     <!-- Do not generate a warning that our 'stable' package should not have a prerelease dependency. -->
     <NoWarn>$(NoWarn);NU5104</NoWarn>
@@ -159,6 +160,7 @@
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="Logging\FancyLogger\*.cs" />
     <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
     <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
     <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
diff --git a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt b/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index b006f76520c..00000000000
--- a/src/Build/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,1836 +0,0 @@
-abstract Microsoft.Build.Construction.ElementLocation.Column.get -> int
-abstract Microsoft.Build.Construction.ElementLocation.File.get -> string
-abstract Microsoft.Build.Construction.ElementLocation.Line.get -> int
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsEnvironmentProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsGlobalProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsImported.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsReservedProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.Name.get -> string
-abstract Microsoft.Build.Evaluation.ProjectProperty.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.get -> string
-abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.set -> void
-abstract Microsoft.Build.Evaluation.ProjectProperty.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Condition.get -> string
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Condition.get -> string
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.get -> bool
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.set -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogError(string error) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogMessage(string message, Microsoft.Build.Framework.MessageImportance? messageImportance = null) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogWarning(string warning) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult>
-abstract Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.GetLoadedProjects(string filePath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElement child) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.Count.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.LastChild.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Attributes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ElementName.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(string attributeName) -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(string attributeName, bool nullIfNotExists) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.OuterElement.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PureText.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(string name, string value, bool clearAttributeCache, string reason, string param) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.GetSubElement(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.SetSubElement(string name, string value) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadataValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ItemType.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ChangeItemType(string newType) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ChangeItemType(string newItemType) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.DirectMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.EvaluatedInclude.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadataValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.HasMetadata(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.MetadataCollection.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.RemoveMetadata(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Rename(string name) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ExpandString(string unexpandedValue) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetPropertyValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsDirty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.LastEvaluationId.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.MarkDirty() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveGlobalProperty(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SaveLogicalProject(System.IO.TextWriter writer) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetGlobalProperty(string name, string escapedValue) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SubToolsetVersion.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ToolsVersion.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Unload() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ChangeName(string newName) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.EvaluatedValueEscaped.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Parent.get -> object
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ChangeName(string newName) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.EvaluatedIncludeEscaped.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsEnvironmentProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsGlobalProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsImported.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsReservedProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.DirectoryPath.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Encoding.get -> System.Text.Encoding
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.HasUnsavedChanges.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.LastWriteTimeWhenRead.get -> System.DateTime
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.MarkDirty(string reason, string param) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.PreserveFormatting.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.RawXml.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.IO.TextWriter writer) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.Text.Encoding saveEncoding) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.TimeLastChanged.get -> System.DateTime
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Version.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Returns.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.GetParameter(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveAllParameters() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveParameter(string name) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.SetParameter(string name, string unevaluatedValue) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.set -> void
-const Microsoft.Build.Evaluation.MatchOnMetadataConstants.MatchOnMetadataOptionsDefaultValue = Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Resolver.get -> Microsoft.Build.Framework.SdkResolver
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Sdk.get -> Microsoft.Build.Framework.SdkReference
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.SdkResolverException(string resourceName, Microsoft.Build.Framework.SdkResolver resolver, Microsoft.Build.Framework.SdkReference sdk, System.Exception innerException, params string[] args) -> void
-Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ElementLocation.ElementLocation() -> void
-Microsoft.Build.Construction.ElementLocation.LocationString.get -> string
-Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.Bottom = 2 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.None = 0 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.Top = 1 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.Construction.ProjectChooseElement.OtherwiseElement.get -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectChooseElement.WhenElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectWhenElement>
-Microsoft.Build.Construction.ProjectConfigurationInSolution
-Microsoft.Build.Construction.ProjectConfigurationInSolution.ConfigurationName.get -> string
-Microsoft.Build.Construction.ProjectConfigurationInSolution.FullName.get -> string
-Microsoft.Build.Construction.ProjectConfigurationInSolution.IncludeInBuild.get -> bool
-Microsoft.Build.Construction.ProjectConfigurationInSolution.PlatformName.get -> string
-Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.AllParents.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElementContainer>
-Microsoft.Build.Construction.ProjectElement.Clone() -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectElement.ElementName.get -> string
-Microsoft.Build.Construction.ProjectElement.Label.get -> string
-Microsoft.Build.Construction.ProjectElement.Label.set -> void
-Microsoft.Build.Construction.ProjectElement.LabelLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectElement.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectElement.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.OuterElement.get -> string
-Microsoft.Build.Construction.ProjectElement.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
-Microsoft.Build.Construction.ProjectElement.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer
-Microsoft.Build.Construction.ProjectElementContainer.AllChildren.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.AppendChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectElementContainer.Children.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.ChildrenReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.Count.get -> int
-Microsoft.Build.Construction.ProjectElementContainer.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-Microsoft.Build.Construction.ProjectElementContainer.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-Microsoft.Build.Construction.ProjectElementContainer.LastChild.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer.PrependChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectElementContainer.RemoveAllChildren() -> void
-Microsoft.Build.Construction.ProjectElementContainer.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.Construction.ProjectExtensionsElement.Content.get -> string
-Microsoft.Build.Construction.ProjectExtensionsElement.Content.set -> void
-Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].get -> string
-Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].set -> void
-Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectImportElement.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.get -> string
-Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.set -> void
-Microsoft.Build.Construction.ProjectImportElement.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectImportElement.Project.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Project.set -> void
-Microsoft.Build.Construction.ProjectImportElement.ProjectLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectImportElement.Sdk.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Sdk.set -> void
-Microsoft.Build.Construction.ProjectImportElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectImportElement.Version.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Version.set -> void
-Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectImportGroupElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectImportGroupElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
-Microsoft.Build.Construction.ProjectInSolution
-Microsoft.Build.Construction.ProjectInSolution.AbsolutePath.get -> string
-Microsoft.Build.Construction.ProjectInSolution.Dependencies.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Construction.ProjectInSolution.ParentProjectGuid.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectConfigurations.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectConfigurationInSolution>
-Microsoft.Build.Construction.ProjectInSolution.ProjectGuid.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectName.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectType.get -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.ProjectInSolution.ProjectType.set -> void
-Microsoft.Build.Construction.ProjectInSolution.RelativePath.get -> string
-Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectItemDefinitionElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
-Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemElement.Exclude.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Exclude.set -> void
-Microsoft.Build.Construction.ProjectItemElement.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.HasMetadata.get -> bool
-Microsoft.Build.Construction.ProjectItemElement.Include.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Include.set -> void
-Microsoft.Build.Construction.ProjectItemElement.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectItemElement.ItemType.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.get -> string
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.get -> string
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.set -> void
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
-Microsoft.Build.Construction.ProjectItemElement.Remove.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Remove.set -> void
-Microsoft.Build.Construction.ProjectItemElement.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.Update.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Update.set -> void
-Microsoft.Build.Construction.ProjectItemElement.UpdateLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemGroupElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.get -> bool
-Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.set -> void
-Microsoft.Build.Construction.ProjectMetadataElement.Name.get -> string
-Microsoft.Build.Construction.ProjectMetadataElement.Name.set -> void
-Microsoft.Build.Construction.ProjectMetadataElement.Value.get -> string
-Microsoft.Build.Construction.ProjectMetadataElement.Value.set -> void
-Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.get -> string
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.set -> void
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectOtherwiseElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectOtherwiseElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectOtherwiseElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectOutputElement.IsOutputItem.get -> bool
-Microsoft.Build.Construction.ProjectOutputElement.IsOutputProperty.get -> bool
-Microsoft.Build.Construction.ProjectOutputElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.ItemType.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOutputElement.PropertyName.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.PropertyName.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectPropertyElement.Name.get -> string
-Microsoft.Build.Construction.ProjectPropertyElement.Name.set -> void
-Microsoft.Build.Construction.ProjectPropertyElement.Value.get -> string
-Microsoft.Build.Construction.ProjectPropertyElement.Value.set -> void
-Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectPropertyGroupElement.AddProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectPropertyGroupElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectPropertyGroupElement.PropertiesReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectPropertyGroupElement.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectRootElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectRootElement.AddImportGroup() -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemDefinitionGroup() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddProperty(string name, string value) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddTarget(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectRootElement.AddUsingTask(string name, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectRootElement.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.Construction.ProjectRootElement.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectRootElement.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectRootElement.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.Construction.ProjectRootElement.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.Construction.ProjectRootElement.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectRootElement.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.Construction.ProjectRootElement.DeepClone() -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.get -> string
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.set -> void
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.DirectoryPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Encoding.get -> System.Text.Encoding
-Microsoft.Build.Construction.ProjectRootElement.EscapedFullPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.FullPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.FullPath.set -> void
-Microsoft.Build.Construction.ProjectRootElement.HasUnsavedChanges.get -> bool
-Microsoft.Build.Construction.ProjectRootElement.ImportGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ImportGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
-Microsoft.Build.Construction.ProjectRootElement.InitialTargets.get -> string
-Microsoft.Build.Construction.ProjectRootElement.InitialTargets.set -> void
-Microsoft.Build.Construction.ProjectRootElement.InitialTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Construction.ProjectRootElement.LastWriteTimeWhenRead.get -> System.DateTime
-Microsoft.Build.Construction.ProjectRootElement.PreserveFormatting.get -> bool
-Microsoft.Build.Construction.ProjectRootElement.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectRootElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.PropertyGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.RawXml.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save() -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(string path) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(string path, System.Text.Encoding encoding) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(System.IO.TextWriter writer) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(System.Text.Encoding saveEncoding) -> void
-Microsoft.Build.Construction.ProjectRootElement.Sdk.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Sdk.set -> void
-Microsoft.Build.Construction.ProjectRootElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.Targets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTargetElement>
-Microsoft.Build.Construction.ProjectRootElement.TimeLastChanged.get -> System.DateTime
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.get -> string
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.set -> void
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.get -> string
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.set -> void
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalPropertyLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.UsingTasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskElement>
-Microsoft.Build.Construction.ProjectRootElement.Version.get -> int
-Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.set -> void
-Microsoft.Build.Construction.ProjectSdkElement.Name.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.Name.set -> void
-Microsoft.Build.Construction.ProjectSdkElement.Version.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.Version.set -> void
-Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectTargetElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectTargetElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectTargetElement.AddTask(string taskName) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Inputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Inputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Name.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Name.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.NameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.OnErrors.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOnErrorElement>
-Microsoft.Build.Construction.ProjectTargetElement.Outputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Outputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectTargetElement.Returns.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Returns.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTaskElement>
-Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.GetParameter(string name) -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.Name.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.Outputs.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOutputElement>
-Microsoft.Build.Construction.ProjectTaskElement.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
-Microsoft.Build.Construction.ProjectTaskElement.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Construction.ProjectTaskElement.RemoveAllParameters() -> void
-Microsoft.Build.Construction.ProjectTaskElement.RemoveParameter(string name) -> void
-Microsoft.Build.Construction.ProjectTaskElement.SetParameter(string name, string unevaluatedValue) -> void
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.EvaluateLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.AddParameterGroup() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.AddUsingTaskBody(string evaluate, string taskBody) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.ArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.ParameterGroup.get -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.RuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskBody.get -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactoryLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.OutputLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.RequiredLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.Construction.ProjectWhenElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectWhenElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectWhenElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.SolutionConfigurationInSolution
-Microsoft.Build.Construction.SolutionConfigurationInSolution.ConfigurationName.get -> string
-Microsoft.Build.Construction.SolutionConfigurationInSolution.FullName.get -> string
-Microsoft.Build.Construction.SolutionConfigurationInSolution.PlatformName.get -> string
-Microsoft.Build.Construction.SolutionFile
-Microsoft.Build.Construction.SolutionFile.GetDefaultConfigurationName() -> string
-Microsoft.Build.Construction.SolutionFile.GetDefaultPlatformName() -> string
-Microsoft.Build.Construction.SolutionFile.ProjectsByGuid.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectInSolution>
-Microsoft.Build.Construction.SolutionFile.ProjectsInOrder.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.ProjectInSolution>
-Microsoft.Build.Construction.SolutionFile.SolutionConfigurations.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.SolutionConfigurationInSolution>
-Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.EtpSubProject = 5 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.KnownToBeMSBuildFormat = 1 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.SharedProject = 6 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.SolutionFolder = 2 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.Unknown = 0 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.WebDeploymentProject = 4 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.WebProject = 3 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.Parameters.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskParameterElement>
-Microsoft.Build.Definition.ProjectOptions
-Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.get -> Microsoft.Build.FileSystem.IDirectoryCacheFactory
-Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.set -> void
-Microsoft.Build.Definition.ProjectOptions.EvaluationContext.get -> Microsoft.Build.Evaluation.Context.EvaluationContext
-Microsoft.Build.Definition.ProjectOptions.EvaluationContext.set -> void
-Microsoft.Build.Definition.ProjectOptions.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Definition.ProjectOptions.GlobalProperties.set -> void
-Microsoft.Build.Definition.ProjectOptions.LoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Definition.ProjectOptions.LoadSettings.set -> void
-Microsoft.Build.Definition.ProjectOptions.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Definition.ProjectOptions.ProjectCollection.set -> void
-Microsoft.Build.Definition.ProjectOptions.ProjectOptions() -> void
-Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.get -> string
-Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.set -> void
-Microsoft.Build.Definition.ProjectOptions.ToolsVersion.get -> string
-Microsoft.Build.Definition.ProjectOptions.ToolsVersion.set -> void
-Microsoft.Build.Evaluation.Context.EvaluationContext
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Isolated = 1 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Shared = 0 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.GlobResult
-Microsoft.Build.Evaluation.GlobResult.Excludes.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.GlobResult(Microsoft.Build.Construction.ProjectItemElement itemElement, System.Collections.Generic.IEnumerable<string> includeGlobStrings, Microsoft.Build.Globbing.IMSBuildGlob globWithGaps, System.Collections.Generic.IEnumerable<string> excludeFragmentStrings, System.Collections.Generic.IEnumerable<string> removeFragmentStrings) -> void
-Microsoft.Build.Evaluation.GlobResult.IncludeGlobs.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.set -> void
-Microsoft.Build.Evaluation.GlobResult.Removes.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.Removes.set -> void
-Microsoft.Build.Evaluation.MatchOnMetadataConstants
-Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseInsensitive = 1 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive = 0 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.PathLike = 2 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeAllOptions = -1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeToolsVersion = 2 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlDeclaration = 1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlNamespace = 4 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.None = 0 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Exclude = 1 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Include = 0 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Remove = 3 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Update = 2 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.Project.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-Microsoft.Build.Evaluation.Project.Build() -> bool
-Microsoft.Build.Evaluation.Project.Build(Microsoft.Build.Framework.ILogger logger) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
-Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-Microsoft.Build.Evaluation.Project.CreateProjectInstance() -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.DirectoryPath.get -> string
-Microsoft.Build.Evaluation.Project.DisableMarkDirty.get -> bool
-Microsoft.Build.Evaluation.Project.DisableMarkDirty.set -> void
-Microsoft.Build.Evaluation.Project.EvaluationCounter.get -> int
-Microsoft.Build.Evaluation.Project.ExpandString(string unexpandedValue) -> string
-Microsoft.Build.Evaluation.Project.FullPath.get -> string
-Microsoft.Build.Evaluation.Project.FullPath.set -> void
-Microsoft.Build.Evaluation.Project.GetAllGlobs() -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Evaluation.Project.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.Project.GetPropertyValue(string name) -> string
-Microsoft.Build.Evaluation.Project.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Evaluation.Project.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-Microsoft.Build.Evaluation.Project.IsBuildEnabled.get -> bool
-Microsoft.Build.Evaluation.Project.IsBuildEnabled.set -> void
-Microsoft.Build.Evaluation.Project.IsDirty.get -> bool
-Microsoft.Build.Evaluation.Project.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
-Microsoft.Build.Evaluation.Project.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Evaluation.Project.LastEvaluationId.get -> int
-Microsoft.Build.Evaluation.Project.MarkDirty() -> void
-Microsoft.Build.Evaluation.Project.Project() -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Evaluation.Project.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.Project.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary() -> void
-Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
-Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(string name) -> bool
-Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
-Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
-Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
-Microsoft.Build.Evaluation.Project.Save() -> void
-Microsoft.Build.Evaluation.Project.Save(string path) -> void
-Microsoft.Build.Evaluation.Project.Save(string path, System.Text.Encoding encoding) -> void
-Microsoft.Build.Evaluation.Project.Save(System.IO.TextWriter writer) -> void
-Microsoft.Build.Evaluation.Project.Save(System.Text.Encoding encoding) -> void
-Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter writer) -> void
-Microsoft.Build.Evaluation.Project.SetGlobalProperty(string name, string escapedValue) -> bool
-Microsoft.Build.Evaluation.Project.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.Project.SkipEvaluation.get -> bool
-Microsoft.Build.Evaluation.Project.SkipEvaluation.set -> void
-Microsoft.Build.Evaluation.Project.SubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Project.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.get -> bool
-Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.set -> void
-Microsoft.Build.Evaluation.Project.ToolsVersion.get -> string
-Microsoft.Build.Evaluation.Project.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectChangedEventArgs
-Microsoft.Build.Evaluation.ProjectChangedEventArgs.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Evaluation.ProjectCollection.AddToolset(Microsoft.Build.Evaluation.Toolset toolset) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ContainsToolset(string toolsVersion) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.Count.get -> int
-Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.get -> string
-Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.Dispose() -> void
-Microsoft.Build.Evaluation.ProjectCollection.GetEffectiveToolsVersion(string explicitToolsVersion, string toolsVersionFromProject) -> string
-Microsoft.Build.Evaluation.ProjectCollection.GetGlobalProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Evaluation.ProjectCollection.GetLoadedProjects(string fullPath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-Microsoft.Build.Evaluation.ProjectCollection.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Evaluation.ProjectCollection.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Evaluation.ProjectCollection.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Evaluation.ProjectCollection.HostServices.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.LoadedProjects.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.Loggers.get -> System.Collections.Generic.ICollection<Microsoft.Build.Framework.ILogger>
-Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAdded -> Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectAddedToProjectCollectionEventArgs(Microsoft.Build.Construction.ProjectRootElement element) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectRootElement.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectCollection.ProjectChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection() -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetLocations) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollectionChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.ProjectXmlChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.RegisterForwardingLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RegisterLogger(Microsoft.Build.Framework.ILogger logger) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RegisterLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RemoveAllToolsets() -> void
-Microsoft.Build.Evaluation.ProjectCollection.RemoveGlobalProperty(string name) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.RemoveToolset(string toolsVersion) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.SetGlobalProperty(string name, string value) -> void
-Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.ToolsetLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ProjectCollection.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
-Microsoft.Build.Evaluation.ProjectCollection.TryUnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.UnloadAllProjects() -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Evaluation.Project project) -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnregisterAllLoggers() -> void
-Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs
-Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs.Changed.get -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.DefaultToolsVersion = 0 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.DisableMarkDirty = 7 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.GlobalProperties = 3 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.HostServices = 6 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.IsBuildEnabled = 4 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.Loggers = 2 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.OnlyLogCriticalEvents = 5 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.SkipEvaluation = 8 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.Toolsets = 1 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectItem
-Microsoft.Build.Evaluation.ProjectItem.DirectMetadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItem.DirectMetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItem.EvaluatedInclude.get -> string
-Microsoft.Build.Evaluation.ProjectItem.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(string name) -> string
-Microsoft.Build.Evaluation.ProjectItem.HasMetadata(string name) -> bool
-Microsoft.Build.Evaluation.ProjectItem.IsImported.get -> bool
-Microsoft.Build.Evaluation.ProjectItem.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectItem.ItemType.set -> void
-Microsoft.Build.Evaluation.ProjectItem.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItem.MetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItem.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(string name) -> bool
-Microsoft.Build.Evaluation.ProjectItem.Rename(string name) -> void
-Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.get -> string
-Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.set -> void
-Microsoft.Build.Evaluation.ProjectItem.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.ProjectItemDefinition
-Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadataValue(string name) -> string
-Microsoft.Build.Evaluation.ProjectItemDefinition.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectItemDefinition.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItemDefinition.MetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItemDefinition.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectItemDefinition.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.Default = 0 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.DoNotEvaluateElementsWithFalseCondition = 32 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.FailOnUnresolvedSdk = 256 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreEmptyImports = 16 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreInvalidImports = 64 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreMissingImports = 1 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.ProfileEvaluation = 128 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RecordDuplicateButNotCircularImports = 2 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements = 8 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RejectCircularImports = 4 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectMetadata.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.ProjectMetadata.EvaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.IsImported.get -> bool
-Microsoft.Build.Evaluation.ProjectMetadata.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.ProjectMetadata.Name.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectMetadata.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.set -> void
-Microsoft.Build.Evaluation.ProjectMetadata.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.ProjectProperty.EvaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectProperty.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.ProjectXml.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.Reason.get -> string
-Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Glob = 2 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Inconclusive = 4 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.StringLiteral = 1 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Undefined = 0 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.ProvenanceResult
-Microsoft.Build.Evaluation.ProvenanceResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.ProvenanceResult.Occurrences.get -> int
-Microsoft.Build.Evaluation.ProvenanceResult.Operation.get -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.ProvenanceResult.Provenance.get -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.ProvenanceResult.ProvenanceResult(Microsoft.Build.Construction.ProjectItemElement itemElement, Microsoft.Build.Evaluation.Operation operation, Microsoft.Build.Evaluation.Provenance provenance, int occurrences) -> void
-Microsoft.Build.Evaluation.ResolvedImport
-Microsoft.Build.Evaluation.ResolvedImport.ImportedProject.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ResolvedImport.ImportingElement.get -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Evaluation.ResolvedImport.IsImported.get -> bool
-Microsoft.Build.Evaluation.ResolvedImport.ResolvedImport() -> void
-Microsoft.Build.Evaluation.ResolvedImport.SdkResult.get -> Microsoft.Build.Framework.SdkResult
-Microsoft.Build.Evaluation.SubToolset
-Microsoft.Build.Evaluation.SubToolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Evaluation.SubToolset.SubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Evaluation.Toolset.DefaultSubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion() -> string
-Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion(System.Collections.Generic.IDictionary<string, string> overrideGlobalProperties, int solutionVersion) -> string
-Microsoft.Build.Evaluation.Toolset.GetProperty(string propertyName, string subToolsetVersion) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Evaluation.Toolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Evaluation.Toolset.SubToolsets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset>
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset> subToolsets, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.ToolsPath.get -> string
-Microsoft.Build.Evaluation.Toolset.ToolsVersion.get -> string
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile = 1 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Default = Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile | Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Local = 4 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.None = 0 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry = 2 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Exceptions.BuildAbortedException
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException() -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.CircularDependencyException
-Microsoft.Build.Exceptions.CircularDependencyException.CircularDependencyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Exceptions.InternalLoggerException
-Microsoft.Build.Exceptions.InternalLoggerException.BuildEventArgs.get -> Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Exceptions.InternalLoggerException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InternalLoggerException.HelpKeyword.get -> string
-Microsoft.Build.Exceptions.InternalLoggerException.InitializationException.get -> bool
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException() -> void
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message) -> void
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException
-Microsoft.Build.Exceptions.InvalidProjectFileException.BaseMessage.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.ColumnNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.EndColumnNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.EndLineNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorSubcategory.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.HasBeenLogged.get -> bool
-Microsoft.Build.Exceptions.InvalidProjectFileException.HelpKeyword.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException() -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.LineNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.ProjectFile.get -> string
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException() -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters) -> void
-Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters, System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.BuildManager.DeferredBuildMessage> deferredBuildMessages) -> void
-Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Execution.BuildManager.BuildManager() -> void
-Microsoft.Build.Execution.BuildManager.BuildManager(string hostName) -> void
-Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Execution.BuildManager.CancelAllSubmissions() -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage() -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Importance.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Text.get -> string
-Microsoft.Build.Execution.BuildManager.Dispose() -> void
-Microsoft.Build.Execution.BuildManager.EndBuild() -> void
-Microsoft.Build.Execution.BuildManager.GetProjectInstanceForBuild(Microsoft.Build.Evaluation.Project project) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildSubmission
-Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildSubmission
-Microsoft.Build.Execution.BuildManager.ResetCaches() -> void
-Microsoft.Build.Execution.BuildManager.ShutdownAllNodes() -> void
-Microsoft.Build.Execution.BuildManager.~BuildManager() -> void
-Microsoft.Build.Execution.BuildParameters
-Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.get -> bool
-Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.set -> void
-Microsoft.Build.Execution.BuildParameters.BuildParameters() -> void
-Microsoft.Build.Execution.BuildParameters.BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.BuildParameters.BuildProcessEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.get -> System.Threading.ThreadPriority
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.set -> void
-Microsoft.Build.Execution.BuildParameters.Clone() -> Microsoft.Build.Execution.BuildParameters
-Microsoft.Build.Execution.BuildParameters.Culture.get -> System.Globalization.CultureInfo
-Microsoft.Build.Execution.BuildParameters.Culture.set -> void
-Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.get -> string
-Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.set -> void
-Microsoft.Build.Execution.BuildParameters.DetailedSummary.get -> bool
-Microsoft.Build.Execution.BuildParameters.DetailedSummary.set -> void
-Microsoft.Build.Execution.BuildParameters.DisableInProcNode.get -> bool
-Microsoft.Build.Execution.BuildParameters.DisableInProcNode.set -> void
-Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.get -> bool
-Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.set -> void
-Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.get -> bool
-Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.set -> void
-Microsoft.Build.Execution.BuildParameters.EnvironmentProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord>
-Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.set -> void
-Microsoft.Build.Execution.BuildParameters.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Execution.BuildParameters.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.GlobalProperties.set -> void
-Microsoft.Build.Execution.BuildParameters.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.BuildParameters.HostServices.set -> void
-Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.get -> string[]
-Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.set -> void
-Microsoft.Build.Execution.BuildParameters.Interactive.get -> bool
-Microsoft.Build.Execution.BuildParameters.Interactive.set -> void
-Microsoft.Build.Execution.BuildParameters.IsolateProjects.get -> bool
-Microsoft.Build.Execution.BuildParameters.IsolateProjects.set -> void
-Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.get -> bool
-Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.set -> void
-Microsoft.Build.Execution.BuildParameters.Loggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger>
-Microsoft.Build.Execution.BuildParameters.Loggers.set -> void
-Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.get -> bool
-Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.set -> void
-Microsoft.Build.Execution.BuildParameters.LogTaskInputs.get -> bool
-Microsoft.Build.Execution.BuildParameters.LogTaskInputs.set -> void
-Microsoft.Build.Execution.BuildParameters.LowPriority.get -> bool
-Microsoft.Build.Execution.BuildParameters.LowPriority.set -> void
-Microsoft.Build.Execution.BuildParameters.MaxNodeCount.get -> int
-Microsoft.Build.Execution.BuildParameters.MaxNodeCount.set -> void
-Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.get -> int
-Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.set -> void
-Microsoft.Build.Execution.BuildParameters.NodeExeLocation.get -> string
-Microsoft.Build.Execution.BuildParameters.NodeExeLocation.set -> void
-Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.get -> bool
-Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.set -> void
-Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.get -> string
-Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.set -> void
-Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.set -> void
-Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.set -> void
-Microsoft.Build.Execution.BuildParameters.ResetCaches.get -> bool
-Microsoft.Build.Execution.BuildParameters.ResetCaches.set -> void
-Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.get -> bool
-Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.set -> void
-Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.get -> bool
-Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.set -> void
-Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.set -> void
-Microsoft.Build.Execution.BuildParameters.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
-Microsoft.Build.Execution.BuildParameters.UICulture.get -> System.Globalization.CultureInfo
-Microsoft.Build.Execution.BuildParameters.UICulture.set -> void
-Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.get -> bool
-Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
-Microsoft.Build.Execution.BuildRequestData
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
-Microsoft.Build.Execution.BuildRequestData.ExplicitlySpecifiedToolsVersion.get -> string
-Microsoft.Build.Execution.BuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestData.GlobalProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Execution.BuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.BuildRequestData.ProjectFullPath.get -> string
-Microsoft.Build.Execution.BuildRequestData.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildRequestData.PropertiesToTransfer.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Execution.BuildRequestData.RequestedProjectState.get -> Microsoft.Build.Execution.RequestedProjectState
-Microsoft.Build.Execution.BuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ClearCachesAfterBuild = 8 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.FailOnUnresolvedSdk = 128 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState = 4 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports = 64 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.None = 0 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild = 2 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild = 32 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance = 1 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.SkipNonexistentTargets = 16 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildResult.AddResultsForTarget(string target, Microsoft.Build.Execution.TargetResult result) -> void
-Microsoft.Build.Execution.BuildResult.BuildResult() -> void
-Microsoft.Build.Execution.BuildResult.CircularDependency.get -> bool
-Microsoft.Build.Execution.BuildResult.ConfigurationId.get -> int
-Microsoft.Build.Execution.BuildResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.BuildResult.GlobalRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.HasResultsForTarget(string target) -> bool
-Microsoft.Build.Execution.BuildResult.MergeResults(Microsoft.Build.Execution.BuildResult results) -> void
-Microsoft.Build.Execution.BuildResult.NodeRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResult.ParentGlobalRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.set -> void
-Microsoft.Build.Execution.BuildResult.ResultsByTarget.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult>
-Microsoft.Build.Execution.BuildResult.SubmissionId.get -> int
-Microsoft.Build.Execution.BuildResult.this[string target].get -> Microsoft.Build.Execution.ITargetResult
-Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResultCode.Failure = 1 -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResultCode.Success = 0 -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildSubmission
-Microsoft.Build.Execution.BuildSubmission.AsyncContext.get -> object
-Microsoft.Build.Execution.BuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Execution.BuildSubmission.BuildResult.get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildSubmission.BuildResult.set -> void
-Microsoft.Build.Execution.BuildSubmission.Execute() -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback callback, object context) -> void
-Microsoft.Build.Execution.BuildSubmission.IsCompleted.get -> bool
-Microsoft.Build.Execution.BuildSubmission.SubmissionId.get -> int
-Microsoft.Build.Execution.BuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
-Microsoft.Build.Execution.BuildSubmissionCompleteCallback
-Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.HostServices.GetHostObject(string projectFile, string targetName, string taskName) -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Execution.HostServices.GetNodeAffinity(string projectFile) -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.HostServices.HostServices() -> void
-Microsoft.Build.Execution.HostServices.OnRenameProject(string oldFullPath, string newFullPath) -> void
-Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, Microsoft.Build.Framework.ITaskHost hostObject) -> void
-Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName) -> void
-Microsoft.Build.Execution.HostServices.SetNodeAffinity(string projectFile, Microsoft.Build.Execution.NodeAffinity nodeAffinity) -> void
-Microsoft.Build.Execution.HostServices.UnregisterProject(string projectFullPath) -> void
-Microsoft.Build.Execution.ITargetResult
-Microsoft.Build.Execution.ITargetResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.ITargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Execution.ITargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.Any = 2 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.InProc = 0 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.OutOfProc = 1 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.BuildComplete = 0 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.BuildCompleteReuse = 1 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.ConnectionFailed = 2 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.Error = 3 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode
-Microsoft.Build.Execution.OutOfProcNode.OutOfProcNode() -> void
-Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude) -> Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectInstance.Build() -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.DeepCopy() -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.DeepCopy(bool isImmutable) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.DefaultTargets.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.ProjectInstance.Directory.get -> string
-Microsoft.Build.Execution.ProjectInstance.EvaluateCondition(string condition) -> bool
-Microsoft.Build.Execution.ProjectInstance.EvaluatedItemElements.get -> System.Collections.Generic.List<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Execution.ProjectInstance.EvaluationId.get -> int
-Microsoft.Build.Execution.ProjectInstance.EvaluationId.set -> void
-Microsoft.Build.Execution.ProjectInstance.ExpandString(string unexpandedValue) -> string
-Microsoft.Build.Execution.ProjectInstance.FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.FullPath.get -> string
-Microsoft.Build.Execution.ProjectInstance.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.GetItemsByItemTypeAndEvaluatedInclude(string itemType, string evaluatedInclude) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.GetProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectInstance.GetPropertyValue(string name) -> string
-Microsoft.Build.Execution.ProjectInstance.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.ProjectInstance.ImportPaths.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Execution.ProjectInstance.ImportPathsIncludingDuplicates.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Execution.ProjectInstance.InitialTargets.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.ProjectInstance.IsImmutable.get -> bool
-Microsoft.Build.Execution.ProjectInstance.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectItemDefinitionInstance>
-Microsoft.Build.Execution.ProjectInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.ProjectInstance.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Execution.ProjectInstance.RemoveItem(Microsoft.Build.Execution.ProjectItemInstance item) -> bool
-Microsoft.Build.Execution.ProjectInstance.RemoveProperty(string name) -> bool
-Microsoft.Build.Execution.ProjectInstance.SetProperty(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectInstance.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-Microsoft.Build.Execution.ProjectInstance.ToolsVersion.get -> string
-Microsoft.Build.Execution.ProjectInstance.ToProjectRootElement() -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.get -> bool
-Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.set -> void
-Microsoft.Build.Execution.ProjectInstance.UpdateStateFrom(Microsoft.Build.Execution.ProjectInstance projectState) -> void
-Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.Immutable = 1 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.ImmutableWithFastItemLookup = 3 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.None = 0 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectItemDefinitionInstance
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectMetadataInstance>
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataNames.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Execution.ProjectItemGroupTaskInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance>
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Exclude.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Include.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicates.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptions.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance>
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Remove.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Value.get -> string
-Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectItemInstance.DirectMetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.get -> string
-Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.set -> void
-Microsoft.Build.Execution.ProjectItemInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemInstance.GetMetadataValue(string name) -> string
-Microsoft.Build.Execution.ProjectItemInstance.HasMetadata(string name) -> bool
-Microsoft.Build.Execution.ProjectItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemInstance.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectMetadataInstance>
-Microsoft.Build.Execution.ProjectItemInstance.MetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemInstance.MetadataNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.ProjectItemInstance.Project.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectItemInstance.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadataDictionary) -> void
-Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectMetadataInstance.DeepClone() -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectMetadataInstance.EvaluatedValue.get -> string
-Microsoft.Build.Execution.ProjectMetadataInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectOnErrorInstance
-Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargets.get -> string
-Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance
-Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance>
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Value.get -> string
-Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.get -> string
-Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.set -> void
-Microsoft.Build.Execution.ProjectPropertyInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance
-Microsoft.Build.Execution.ProjectTargetInstance.AfterTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Children.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTargetInstanceChild>
-Microsoft.Build.Execution.ProjectTargetInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.FullPath.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.Inputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.OnErrorChildren.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectOnErrorInstance>
-Microsoft.Build.Execution.ProjectTargetInstance.Outputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Returns.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectTaskInstance>
-Microsoft.Build.Execution.ProjectTargetInstanceChild
-Microsoft.Build.Execution.ProjectTargetInstanceChild.FullPath.get -> string
-Microsoft.Build.Execution.ProjectTargetInstanceChild.ProjectTargetInstanceChild() -> void
-Microsoft.Build.Execution.ProjectTaskInstance
-Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnError.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitecture.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntime.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.Outputs.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTaskInstanceChild>
-Microsoft.Build.Execution.ProjectTaskInstance.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.ProjectTaskInstanceChild
-Microsoft.Build.Execution.ProjectTaskInstanceChild.ProjectTaskInstanceChild() -> void
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameter.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyName.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameter.get -> string
-Microsoft.Build.Execution.RequestedProjectState
-Microsoft.Build.Execution.RequestedProjectState.ItemFilters.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-Microsoft.Build.Execution.RequestedProjectState.ItemFilters.set -> void
-Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.set -> void
-Microsoft.Build.Execution.RequestedProjectState.RequestedProjectState() -> void
-Microsoft.Build.Execution.TargetResult
-Microsoft.Build.Execution.TargetResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.TargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Execution.TargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Failure = 2 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Skipped = 0 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Success = 1 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Experimental.ProjectCache.CacheContext
-Microsoft.Build.Experimental.ProjectCache.CacheContext.CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph = null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints = null) -> void
-Microsoft.Build.Experimental.ProjectCache.CacheContext.FileSystem.get -> Microsoft.Build.FileSystem.MSBuildFileSystemBase
-Microsoft.Build.Experimental.ProjectCache.CacheContext.Graph.get -> Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Experimental.ProjectCache.CacheContext.GraphEntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Experimental.ProjectCache.CacheContext.MSBuildExePath.get -> string
-Microsoft.Build.Experimental.ProjectCache.CacheContext.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.CacheResult
-Microsoft.Build.Experimental.ProjectCache.CacheResult.BuildResult.get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Experimental.ProjectCache.CacheResult.ProxyTargets.get -> Microsoft.Build.Experimental.ProjectCache.ProxyTargets
-Microsoft.Build.Experimental.ProjectCache.CacheResult.ResultType.get -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheHit = 1 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheMiss = 2 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheNotApplicable = 3 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.None = 0 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase
-Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.PluginLoggerBase() -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult() -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
-Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
-Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.ProjectCachePluginBase() -> void
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) -> void
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargetToRealTargetMap.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.FileSystem.FindPredicate
-Microsoft.Build.FileSystem.FindTransform<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache
-Microsoft.Build.FileSystem.IDirectoryCache.DirectoryExists(string path) -> bool
-Microsoft.Build.FileSystem.IDirectoryCache.EnumerateDirectories<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache.EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache.FileExists(string path) -> bool
-Microsoft.Build.FileSystem.IDirectoryCacheFactory
-Microsoft.Build.FileSystem.IDirectoryCacheFactory.GetDirectoryCacheForEvaluation(int evaluationId) -> Microsoft.Build.FileSystem.IDirectoryCache
-Microsoft.Build.FileSystem.MSBuildFileSystemBase
-Microsoft.Build.FileSystem.MSBuildFileSystemBase.MSBuildFileSystemBase() -> void
-Microsoft.Build.Globbing.CompositeGlob
-Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(params Microsoft.Build.Globbing.IMSBuildGlob[] globs) -> void
-Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> void
-Microsoft.Build.Globbing.CompositeGlob.Globs.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob>
-Microsoft.Build.Globbing.CompositeGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions
-Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.IMSBuildGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlob.FilenamePart.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.FixedDirectoryPart.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.IsLegal.get -> bool
-Microsoft.Build.Globbing.MSBuildGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfo(string stringToMatch) -> Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FilenamePartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FixedDirectoryPartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.IsMatch.get -> bool
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.MatchInfoResult() -> void
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.WildcardDirectoryPartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.WildcardDirectoryPart.get -> string
-Microsoft.Build.Globbing.MSBuildGlobWithGaps
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.Gaps.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MainGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, params Microsoft.Build.Globbing.IMSBuildGlob[] gaps) -> void
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> gaps) -> void
-Microsoft.Build.Graph.GraphBuildOptions
-Microsoft.Build.Graph.GraphBuildOptions.Build.get -> bool
-Microsoft.Build.Graph.GraphBuildOptions.Build.init -> void
-Microsoft.Build.Graph.GraphBuildRequestData
-Microsoft.Build.Graph.GraphBuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildOptions.get -> Microsoft.Build.Graph.GraphBuildOptions
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraphEntryPoints.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Graph.GraphBuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildResult.CircularDependency.get -> bool
-Microsoft.Build.Graph.GraphBuildResult.Exception.get -> System.Exception
-Microsoft.Build.Graph.GraphBuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Graph.GraphBuildResult.ResultsByNode.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, Microsoft.Build.Execution.BuildResult>
-Microsoft.Build.Graph.GraphBuildResult.SubmissionId.get -> int
-Microsoft.Build.Graph.GraphBuildResult.this[Microsoft.Build.Graph.ProjectGraphNode node].get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Graph.GraphBuildSubmission
-Microsoft.Build.Graph.GraphBuildSubmission.AsyncContext.get -> object
-Microsoft.Build.Graph.GraphBuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Graph.GraphBuildSubmission.BuildResult.get -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildSubmission.Execute() -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildSubmission.ExecuteAsync(Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback callback, object context) -> void
-Microsoft.Build.Graph.GraphBuildSubmission.IsCompleted.get -> bool
-Microsoft.Build.Graph.GraphBuildSubmission.SubmissionId.get -> int
-Microsoft.Build.Graph.GraphBuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
-Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback
-Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Graph.ProjectGraph.ConstructionMetrics.get -> Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
-Microsoft.Build.Graph.ProjectGraph.EntryPointNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>>
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.ConstructionTime.get -> System.TimeSpan
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.EdgeCount.get -> int
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics() -> void
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) -> void
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.NodeCount.get -> int
-Microsoft.Build.Graph.ProjectGraph.GraphRoots.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, int degreeOfParallelism, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc
-Microsoft.Build.Graph.ProjectGraph.ProjectNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.ProjectNodesTopologicallySorted.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraphEntryPoint
-Microsoft.Build.Graph.ProjectGraphEntryPoint.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectFile.get -> string
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint() -> void
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile) -> void
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraphNode
-Microsoft.Build.Graph.ProjectGraphNode.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Graph.ProjectGraphNode.ProjectReferences.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraphNode.ReferencingProjects.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Logging.BinaryLogger
-Microsoft.Build.Logging.BinaryLogger.BinaryLogger() -> void
-Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.get -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.set -> void
-Microsoft.Build.Logging.BinaryLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.BinaryLogger.Parameters.get -> string
-Microsoft.Build.Logging.BinaryLogger.Parameters.set -> void
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.Embed = 1 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.None = 0 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.ZipFile = 2 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.Shutdown() -> void
-Microsoft.Build.Logging.BinaryLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.BinaryLogger.Verbosity.set -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource
-Microsoft.Build.Logging.BinaryLogReplayEventSource.BinaryLogReplayEventSource() -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath) -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Logging.BuildEventArgsReader
-Microsoft.Build.Logging.BuildEventArgsReader.BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) -> void
-Microsoft.Build.Logging.BuildEventArgsReader.Dispose() -> void
-Microsoft.Build.Logging.BuildEventArgsReader.Read() -> Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Logging.ColorResetter
-Microsoft.Build.Logging.ColorSetter
-Microsoft.Build.Logging.ConfigurableForwardingLogger
-Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.ConfigurableForwardingLogger() -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.get -> int
-Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.get -> string
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.set -> void
-Microsoft.Build.Logging.ConsoleLogger
-Microsoft.Build.Logging.ConsoleLogger.ApplyParameter(string parameterName, string parameterValue) -> void
-Microsoft.Build.Logging.ConsoleLogger.BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger() -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.Logging.WriteHandler write, Microsoft.Build.Logging.ColorSetter colorSet, Microsoft.Build.Logging.ColorResetter colorReset) -> void
-Microsoft.Build.Logging.ConsoleLogger.CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.Parameters.get -> string
-Microsoft.Build.Logging.ConsoleLogger.Parameters.set -> void
-Microsoft.Build.Logging.ConsoleLogger.ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ShowSummary.get -> bool
-Microsoft.Build.Logging.ConsoleLogger.ShowSummary.set -> void
-Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.get -> bool
-Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.set -> void
-Microsoft.Build.Logging.ConsoleLogger.TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ConsoleLogger.Verbosity.set -> void
-Microsoft.Build.Logging.ConsoleLogger.WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.WriteHandler.get -> Microsoft.Build.Logging.WriteHandler
-Microsoft.Build.Logging.ConsoleLogger.WriteHandler.set -> void
-Microsoft.Build.Logging.DistributedFileLogger
-Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.DistributedFileLogger() -> void
-Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Logging.DistributedFileLogger.NodeId.get -> int
-Microsoft.Build.Logging.DistributedFileLogger.NodeId.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.Parameters.get -> string
-Microsoft.Build.Logging.DistributedFileLogger.Parameters.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.Shutdown() -> void
-Microsoft.Build.Logging.DistributedFileLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.DistributedFileLogger.Verbosity.set -> void
-Microsoft.Build.Logging.EventArgsDispatcher
-Microsoft.Build.Logging.EventArgsDispatcher.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.Dispatch(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
-Microsoft.Build.Logging.EventArgsDispatcher.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.EventArgsDispatcher() -> void
-Microsoft.Build.Logging.EventArgsDispatcher.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Logging.FileLogger
-Microsoft.Build.Logging.FileLogger.FileLogger() -> void
-Microsoft.Build.Logging.ForwardingLoggerRecord
-Microsoft.Build.Logging.ForwardingLoggerRecord.CentralLogger.get -> Microsoft.Build.Framework.ILogger
-Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerDescription.get -> Microsoft.Build.Logging.LoggerDescription
-Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerRecord(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.Logging.LoggerDescription forwardingLoggerDescription) -> void
-Microsoft.Build.Logging.LoggerDescription
-Microsoft.Build.Logging.LoggerDescription.CreateLogger() -> Microsoft.Build.Framework.ILogger
-Microsoft.Build.Logging.LoggerDescription.IsOptional.get -> bool
-Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity, bool isOptional) -> void
-Microsoft.Build.Logging.LoggerDescription.LoggerSwitchParameters.get -> string
-Microsoft.Build.Logging.LoggerDescription.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ProfilerLogger
-Microsoft.Build.Logging.ProfilerLogger.FileToLog.get -> string
-Microsoft.Build.Logging.ProfilerLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.ProfilerLogger.Parameters.get -> string
-Microsoft.Build.Logging.ProfilerLogger.Parameters.set -> void
-Microsoft.Build.Logging.ProfilerLogger.ProfilerLogger(string fileToLog) -> void
-Microsoft.Build.Logging.ProfilerLogger.Shutdown() -> void
-Microsoft.Build.Logging.ProfilerLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ProfilerLogger.Verbosity.set -> void
-Microsoft.Build.Logging.WriteHandler
-Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider
-Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.ExternalProjectsProvider() -> void
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Collection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.Construction.ProjectImportElement importingElement, Microsoft.Build.Construction.ProjectRootElement importedProject, int versionEvaluated, Microsoft.Build.Framework.SdkResult sdkResult, bool isImported) -> Microsoft.Build.Evaluation.ResolvedImport
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink link) -> Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink link) -> Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink link) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink link) -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectItemDefinition
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink link) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project = null, Microsoft.Build.Construction.ProjectItemElement xml = null) -> Microsoft.Build.Evaluation.ProjectItem
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectLink link) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink link) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent = null) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink link) -> Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink link) -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink link) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink link) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink link) -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink link) -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink link) -> Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink link) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink link) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink link) -> Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink link) -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink.ProjectChooseElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.ProjectElementContainerLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ProjectElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.ProjectExtensionsElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ProjectImportElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink.ProjectImportGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink.ProjectItemDefinitionElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink.ProjectItemDefinitionGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ProjectItemDefinitionLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ProjectItemElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink.ProjectItemGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ProjectItemLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectLink
-Microsoft.Build.ObjectModelRemoting.ProjectLink.ProjectLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ProjectMetadataElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.ProjectMetadataLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink.ProjectOnErrorElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink.ProjectOtherwiseElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink.ProjectOutputElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ProjectPropertyElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink.ProjectPropertyGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.ProjectPropertyLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectRootElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink.ProjectSdkElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.ProjectTargetElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ProjectTaskElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.ProjectUsingTaskBodyElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink.ProjectUsingTaskElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.ProjectUsingTaskParameterElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink.ProjectWhenElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink
-Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink.UsingTaskParameterGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.LocalName.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.NamespaceURI.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.Value.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink() -> void
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink(string localName, string value, string namespaceUri) -> void
-override Microsoft.Build.Construction.ElementLocation.Equals(object obj) -> bool
-override Microsoft.Build.Construction.ElementLocation.GetHashCode() -> int
-override Microsoft.Build.Construction.ElementLocation.ToString() -> string
-override Microsoft.Build.Construction.ProjectChooseElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectChooseElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectChooseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectExtensionsElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectExtensionsElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectItemElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectItemGroupElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectOtherwiseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectRootElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectRootElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectRootElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectTargetElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectTaskElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.get -> string
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.set -> void
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Exceptions.BuildAbortedException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InternalLoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InvalidProjectFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InvalidProjectFileException.Message.get -> string
-override Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectItemInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectMetadataInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectOnErrorInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectOnErrorInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectOnErrorInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-override Microsoft.Build.Logging.FileLogger.Shutdown() -> void
-static Microsoft.Build.Construction.ProjectRootElement.Create() -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.SolutionFile.Parse(string solutionFile) -> Microsoft.Build.Construction.SolutionFile
-static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) -> Microsoft.Build.Evaluation.Context.EvaluationContext
-static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) -> Microsoft.Build.Evaluation.Context.EvaluationContext
-static Microsoft.Build.Evaluation.Project.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.FromXmlReader(System.Xml.XmlReader reader, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem item) -> string
-static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem item, string name) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadatum) -> string
-static Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.DisplayVersion.get -> string
-static Microsoft.Build.Evaluation.ProjectCollection.Escape(string unescapedString) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-static Microsoft.Build.Evaluation.ProjectCollection.Unescape(string escapedString) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.Version.get -> System.Version
-static Microsoft.Build.Execution.BuildManager.DefaultBuildManager.get -> Microsoft.Build.Execution.BuildManager
-static Microsoft.Build.Execution.ProjectInstance.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
-static Microsoft.Build.Execution.ProjectInstance.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
-static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item, string name) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemInstance item, string name) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectMetadataInstance metadatum) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetPropertyValueEscaped(Microsoft.Build.Execution.ProjectPropertyInstance property) -> string
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
-static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
-static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
-static Microsoft.Build.Globbing.MSBuildGlob.Parse(string globRoot, string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
-static Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.SetExternalProjectsProvider(Microsoft.Build.Evaluation.ProjectCollection collection, Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider link) -> void
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Get(Microsoft.Build.Evaluation.ProjectCollection collection) -> Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLink(object obj) -> object
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile = null) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project>
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.IsLocal(object obj) -> bool
-static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectElement child) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectElement xml, Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(Microsoft.Build.Construction.ProjectElement xml, string attributeName) -> Microsoft.Build.Construction.ElementLocation
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributes(Microsoft.Build.Construction.ProjectElement xml) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(Microsoft.Build.Construction.ProjectElement xml, string attributeName, bool nullIfNotExists) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml) -> bool
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetPureText(Microsoft.Build.Construction.ProjectElement xml) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.MarkDirty(Microsoft.Build.Construction.ProjectElement xml, string reason, string param) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml, bool value) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(Microsoft.Build.Construction.ProjectElement xml, string name, string value, bool clearAttributeCache, string reason, string param) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetParent(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> object
-static Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
-virtual Microsoft.Build.Construction.ProjectElement.Condition.get -> string
-virtual Microsoft.Build.Construction.ProjectElement.Condition.set -> void
-virtual Microsoft.Build.Construction.ProjectElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-virtual Microsoft.Build.Construction.ProjectElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-virtual Microsoft.Build.Construction.ProjectElementContainer.DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer element) -> void
-virtual Microsoft.Build.Evaluation.ProjectCollection.Dispose(bool disposing) -> void
-virtual Microsoft.Build.Execution.ProjectPropertyInstance.IsImmutable.get -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.DirectoryExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileOrDirectoryExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetAttributes(string path) -> System.IO.FileAttributes
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) -> System.IO.Stream
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetLastWriteTimeUtc(string path) -> System.DateTime
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFile(string path) -> System.IO.TextReader
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllBytes(string path) -> byte[]
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllText(string path) -> string
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) -> void
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
-virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index 57af35851fb..00000000000
--- a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging, bool reuseProjectRootElementCache) -> void
-Microsoft.Build.Experimental.MSBuildClient
-Microsoft.Build.Experimental.MSBuildClient.Execute(System.Threading.CancellationToken cancellationToken) -> Microsoft.Build.Experimental.MSBuildClientExitResult
-Microsoft.Build.Experimental.MSBuildClient.MSBuildClient(string commandLine, string msbuildLocation) -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.get -> string
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.set -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitResult() -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.get -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.set -> void
-Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.LaunchError = 3 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.ServerBusy = 1 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.Success = 0 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.UnableToConnect = 2 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.Unexpected = 4 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.OutOfProcServerNode
-Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback
-Microsoft.Build.Experimental.OutOfProcServerNode.OutOfProcServerNode(Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback buildFunction) -> void
-Microsoft.Build.Experimental.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-static Microsoft.Build.Experimental.MSBuildClient.ShutdownServer(System.Threading.CancellationToken cancellationToken) -> bool
-virtual Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalPropertiesContains(string key) -> bool
-virtual Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalPropertiesCount() -> int
-virtual Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalPropertiesEnumerable() -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>>
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
deleted file mode 100644
index 38f8853c43d..00000000000
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,1836 +0,0 @@
-abstract Microsoft.Build.Construction.ElementLocation.Column.get -> int
-abstract Microsoft.Build.Construction.ElementLocation.File.get -> string
-abstract Microsoft.Build.Construction.ElementLocation.Line.get -> int
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsEnvironmentProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsGlobalProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsImported.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.IsReservedProperty.get -> bool
-abstract Microsoft.Build.Evaluation.ProjectProperty.Name.get -> string
-abstract Microsoft.Build.Evaluation.ProjectProperty.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.get -> string
-abstract Microsoft.Build.Evaluation.ProjectProperty.UnevaluatedValue.set -> void
-abstract Microsoft.Build.Evaluation.ProjectProperty.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Condition.get -> string
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTargetInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Condition.get -> string
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Execution.ProjectTaskInstanceChild.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.get -> bool
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.HasLoggedErrors.set -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogError(string error) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogMessage(string message, Microsoft.Build.Framework.MessageImportance? messageImportance = null) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.LogWarning(string warning) -> void
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.BeginBuildAsync(Microsoft.Build.Experimental.ProjectCache.CacheContext context, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.EndBuildAsync(Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task
-abstract Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.GetCacheResultAsync(Microsoft.Build.Execution.BuildRequestData buildRequest, Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<Microsoft.Build.Experimental.ProjectCache.CacheResult>
-abstract Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.GetLoadedProjects(string filePath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElement child) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.Count.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.LastChild.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Attributes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ElementName.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ExpressedAsAttribute.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(string attributeName) -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(string attributeName, bool nullIfNotExists) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Location.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.OuterElement.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.PureText.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(string name, string value, bool clearAttributeCache, string reason, string param) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.Content.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.GetSubElement(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.SetSubElement(string name, string value) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.GetMetadataValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ItemType.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ChangeItemType(string newType) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ChangeItemType(string newItemType) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.DirectMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.EvaluatedInclude.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.GetMetadataValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.HasMetadata(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.MetadataCollection.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.RemoveMetadata(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Rename(string name) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectItemLink.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.DisableMarkDirty.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ExpandString(string unexpandedValue) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GetPropertyValue(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsBuildEnabled.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.IsDirty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.LastEvaluationId.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.MarkDirty() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveGlobalProperty(string name) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SaveLogicalProject(System.IO.TextWriter writer) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetGlobalProperty(string name, string escapedValue) -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SkipEvaluation.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.SubToolsetVersion.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ThrowInsteadOfSplittingItemElement.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.ToolsVersion.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Unload() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectLink.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ChangeName(string newName) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.Value.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.EvaluatedValueEscaped.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Parent.get -> object
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
-abstract Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ChangeName(string newName) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.Value.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.EvaluatedIncludeEscaped.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsEnvironmentProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsGlobalProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsImported.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.IsReservedProperty.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Predecessor.get -> Microsoft.Build.Evaluation.ProjectProperty
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Project.get -> Microsoft.Build.Evaluation.Project
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.UnevaluatedValue.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.Xml.get -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.DirectoryPath.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Encoding.get -> System.Text.Encoding
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.FullPath.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.HasUnsavedChanges.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.LastWriteTimeWhenRead.get -> System.DateTime
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.MarkDirty(string reason, string param) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.PreserveFormatting.get -> bool
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.RawXml.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.IO.TextWriter writer) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Save(System.Text.Encoding saveEncoding) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.TimeLastChanged.get -> System.DateTime
-abstract Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.Version.get -> int
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Name.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.Returns.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.GetParameter(string name) -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveAllParameters() -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.RemoveParameter(string name) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.SetParameter(string name, string unevaluatedValue) -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.TaskBody.set -> void
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.get -> string
-abstract Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.Name.set -> void
-const Microsoft.Build.Evaluation.MatchOnMetadataConstants.MatchOnMetadataOptionsDefaultValue = Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Resolver.get -> Microsoft.Build.Framework.SdkResolver
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.Sdk.get -> Microsoft.Build.Framework.SdkReference
-Microsoft.Build.BackEnd.SdkResolution.SdkResolverException.SdkResolverException(string resourceName, Microsoft.Build.Framework.SdkResolver resolver, Microsoft.Build.Framework.SdkReference sdk, System.Exception innerException, params string[] args) -> void
-Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ElementLocation.ElementLocation() -> void
-Microsoft.Build.Construction.ElementLocation.LocationString.get -> string
-Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.Bottom = 2 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.None = 0 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ImplicitImportLocation.Top = 1 -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.Construction.ProjectChooseElement.OtherwiseElement.get -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectChooseElement.WhenElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectWhenElement>
-Microsoft.Build.Construction.ProjectConfigurationInSolution
-Microsoft.Build.Construction.ProjectConfigurationInSolution.ConfigurationName.get -> string
-Microsoft.Build.Construction.ProjectConfigurationInSolution.FullName.get -> string
-Microsoft.Build.Construction.ProjectConfigurationInSolution.IncludeInBuild.get -> bool
-Microsoft.Build.Construction.ProjectConfigurationInSolution.PlatformName.get -> string
-Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.AllParents.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElementContainer>
-Microsoft.Build.Construction.ProjectElement.Clone() -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.ContainingProject.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectElement.ElementName.get -> string
-Microsoft.Build.Construction.ProjectElement.Label.get -> string
-Microsoft.Build.Construction.ProjectElement.Label.set -> void
-Microsoft.Build.Construction.ProjectElement.LabelLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectElement.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectElement.NextSibling.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElement.OuterElement.get -> string
-Microsoft.Build.Construction.ProjectElement.Parent.get -> Microsoft.Build.Construction.ProjectElementContainer
-Microsoft.Build.Construction.ProjectElement.PreviousSibling.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer
-Microsoft.Build.Construction.ProjectElementContainer.AllChildren.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.AppendChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectElementContainer.Children.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.ChildrenReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Construction.ProjectElementContainer.Count.get -> int
-Microsoft.Build.Construction.ProjectElementContainer.FirstChild.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer.InsertAfterChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-Microsoft.Build.Construction.ProjectElementContainer.InsertBeforeChild(Microsoft.Build.Construction.ProjectElement child, Microsoft.Build.Construction.ProjectElement reference) -> void
-Microsoft.Build.Construction.ProjectElementContainer.LastChild.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectElementContainer.PrependChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectElementContainer.RemoveAllChildren() -> void
-Microsoft.Build.Construction.ProjectElementContainer.RemoveChild(Microsoft.Build.Construction.ProjectElement child) -> void
-Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.Construction.ProjectExtensionsElement.Content.get -> string
-Microsoft.Build.Construction.ProjectExtensionsElement.Content.set -> void
-Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].get -> string
-Microsoft.Build.Construction.ProjectExtensionsElement.this[string name].set -> void
-Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectImportElement.ImplicitImportLocation.get -> Microsoft.Build.Construction.ImplicitImportLocation
-Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.get -> string
-Microsoft.Build.Construction.ProjectImportElement.MinimumVersion.set -> void
-Microsoft.Build.Construction.ProjectImportElement.OriginalElement.get -> Microsoft.Build.Construction.ProjectElement
-Microsoft.Build.Construction.ProjectImportElement.Project.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Project.set -> void
-Microsoft.Build.Construction.ProjectImportElement.ProjectLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectImportElement.Sdk.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Sdk.set -> void
-Microsoft.Build.Construction.ProjectImportElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectImportElement.Version.get -> string
-Microsoft.Build.Construction.ProjectImportElement.Version.set -> void
-Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectImportGroupElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectImportGroupElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
-Microsoft.Build.Construction.ProjectInSolution
-Microsoft.Build.Construction.ProjectInSolution.AbsolutePath.get -> string
-Microsoft.Build.Construction.ProjectInSolution.Dependencies.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Construction.ProjectInSolution.ParentProjectGuid.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectConfigurations.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectConfigurationInSolution>
-Microsoft.Build.Construction.ProjectInSolution.ProjectGuid.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectName.get -> string
-Microsoft.Build.Construction.ProjectInSolution.ProjectType.get -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.ProjectInSolution.ProjectType.set -> void
-Microsoft.Build.Construction.ProjectInSolution.RelativePath.get -> string
-Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemDefinitionElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectItemDefinitionElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectItemDefinitionGroupElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
-Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemElement.AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectItemElement.Exclude.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Exclude.set -> void
-Microsoft.Build.Construction.ProjectItemElement.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.HasMetadata.get -> bool
-Microsoft.Build.Construction.ProjectItemElement.Include.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Include.set -> void
-Microsoft.Build.Construction.ProjectItemElement.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectItemElement.ItemType.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.get -> string
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicates.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.get -> string
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptions.set -> void
-Microsoft.Build.Construction.ProjectItemElement.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectMetadataElement>
-Microsoft.Build.Construction.ProjectItemElement.Remove.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Remove.set -> void
-Microsoft.Build.Construction.ProjectItemElement.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.get -> string
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadata.set -> void
-Microsoft.Build.Construction.ProjectItemElement.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemElement.Update.get -> string
-Microsoft.Build.Construction.ProjectItemElement.Update.set -> void
-Microsoft.Build.Construction.ProjectItemElement.UpdateLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemGroupElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectItemGroupElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.get -> bool
-Microsoft.Build.Construction.ProjectMetadataElement.ExpressedAsAttribute.set -> void
-Microsoft.Build.Construction.ProjectMetadataElement.Name.get -> string
-Microsoft.Build.Construction.ProjectMetadataElement.Name.set -> void
-Microsoft.Build.Construction.ProjectMetadataElement.Value.get -> string
-Microsoft.Build.Construction.ProjectMetadataElement.Value.set -> void
-Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.get -> string
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsAttribute.set -> void
-Microsoft.Build.Construction.ProjectOnErrorElement.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectOtherwiseElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectOtherwiseElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectOtherwiseElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectOutputElement.IsOutputItem.get -> bool
-Microsoft.Build.Construction.ProjectOutputElement.IsOutputProperty.get -> bool
-Microsoft.Build.Construction.ProjectOutputElement.ItemType.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.ItemType.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOutputElement.PropertyName.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.PropertyName.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.get -> string
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameter.set -> void
-Microsoft.Build.Construction.ProjectOutputElement.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectPropertyElement.Name.get -> string
-Microsoft.Build.Construction.ProjectPropertyElement.Name.set -> void
-Microsoft.Build.Construction.ProjectPropertyElement.Value.get -> string
-Microsoft.Build.Construction.ProjectPropertyElement.Value.set -> void
-Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectPropertyGroupElement.AddProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectPropertyGroupElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectPropertyGroupElement.PropertiesReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectPropertyGroupElement.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectRootElement.AddImport(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectRootElement.AddImportGroup() -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.AddItem(string itemType, string include, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemDefinition(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemDefinitionGroup() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddProperty(string name, string value) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectRootElement.AddTarget(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectRootElement.AddUsingTask(string name, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectRootElement.CreateChooseElement() -> Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.Construction.ProjectRootElement.CreateImportElement(string project) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Construction.ProjectRootElement.CreateImportGroupElement() -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionElement(string itemType) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemDefinitionGroupElement() -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemElement(string itemType, string include) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Construction.ProjectRootElement.CreateItemGroupElement() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectRootElement.CreateMetadataElement(string name, string unevaluatedValue) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOnErrorElement(string executeTargets) -> Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOtherwiseElement() -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.Construction.ProjectRootElement.CreateOutputElement(string taskParameter, string itemType, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectRootElement.CreateProjectExtensionsElement() -> Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.Construction.ProjectRootElement.CreateProjectSdkElement(string sdkName, string sdkVersion) -> Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.Construction.ProjectRootElement.CreatePropertyElement(string name) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.Construction.ProjectRootElement.CreatePropertyGroupElement() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateTargetElement(string name) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectRootElement.CreateTaskElement(string name) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskBodyElement(string evaluate, string body) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterElement(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.ProjectRootElement.CreateUsingTaskParameterGroupElement() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectRootElement.CreateWhenElement(string condition) -> Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.Construction.ProjectRootElement.DeepClone() -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.get -> string
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargets.set -> void
-Microsoft.Build.Construction.ProjectRootElement.DefaultTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.DirectoryPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Encoding.get -> System.Text.Encoding
-Microsoft.Build.Construction.ProjectRootElement.EscapedFullPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.FullPath.get -> string
-Microsoft.Build.Construction.ProjectRootElement.FullPath.set -> void
-Microsoft.Build.Construction.ProjectRootElement.HasUnsavedChanges.get -> bool
-Microsoft.Build.Construction.ProjectRootElement.ImportGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ImportGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.Imports.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectImportElement>
-Microsoft.Build.Construction.ProjectRootElement.InitialTargets.get -> string
-Microsoft.Build.Construction.ProjectRootElement.InitialTargets.set -> void
-Microsoft.Build.Construction.ProjectRootElement.InitialTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitionGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemDefinitions.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemDefinitionElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.ItemGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Construction.ProjectRootElement.LastWriteTimeWhenRead.get -> System.DateTime
-Microsoft.Build.Construction.ProjectRootElement.PreserveFormatting.get -> bool
-Microsoft.Build.Construction.ProjectRootElement.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyElement>
-Microsoft.Build.Construction.ProjectRootElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.PropertyGroupsReversed.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectRootElement.RawXml.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Reload(bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(string path, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.ReloadFrom(System.Xml.XmlReader reader, bool throwIfUnsavedChanges = true, bool? preserveFormatting = null) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save() -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(string path) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(string path, System.Text.Encoding encoding) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(System.IO.TextWriter writer) -> void
-Microsoft.Build.Construction.ProjectRootElement.Save(System.Text.Encoding saveEncoding) -> void
-Microsoft.Build.Construction.ProjectRootElement.Sdk.get -> string
-Microsoft.Build.Construction.ProjectRootElement.Sdk.set -> void
-Microsoft.Build.Construction.ProjectRootElement.SdkLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.Targets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTargetElement>
-Microsoft.Build.Construction.ProjectRootElement.TimeLastChanged.get -> System.DateTime
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.get -> string
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersion.set -> void
-Microsoft.Build.Construction.ProjectRootElement.ToolsVersionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.get -> string
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalProperty.set -> void
-Microsoft.Build.Construction.ProjectRootElement.TreatAsLocalPropertyLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectRootElement.UsingTasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskElement>
-Microsoft.Build.Construction.ProjectRootElement.Version.get -> int
-Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.MinimumVersion.set -> void
-Microsoft.Build.Construction.ProjectSdkElement.Name.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.Name.set -> void
-Microsoft.Build.Construction.ProjectSdkElement.Version.get -> string
-Microsoft.Build.Construction.ProjectSdkElement.Version.set -> void
-Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.Construction.ProjectTargetElement.AddItemGroup() -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.Construction.ProjectTargetElement.AddPropertyGroup() -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.Construction.ProjectTargetElement.AddTask(string taskName) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargets.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Inputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Inputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Name.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Name.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.NameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.OnErrors.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOnErrorElement>
-Microsoft.Build.Construction.ProjectTargetElement.Outputs.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Outputs.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.ProjectTargetElement.Returns.get -> string
-Microsoft.Build.Construction.ProjectTargetElement.Returns.set -> void
-Microsoft.Build.Construction.ProjectTargetElement.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTargetElement.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectTaskElement>
-Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputItem(string taskParameter, string itemType, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.AddOutputProperty(string taskParameter, string propertyName, string condition) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnError.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.GetParameter(string name) -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitecture.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntime.set -> void
-Microsoft.Build.Construction.ProjectTaskElement.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectTaskElement.Name.get -> string
-Microsoft.Build.Construction.ProjectTaskElement.Outputs.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectOutputElement>
-Microsoft.Build.Construction.ProjectTaskElement.ParameterLocations.get -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, Microsoft.Build.Construction.ElementLocation>>
-Microsoft.Build.Construction.ProjectTaskElement.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Construction.ProjectTaskElement.RemoveAllParameters() -> void
-Microsoft.Build.Construction.ProjectTaskElement.RemoveParameter(string name) -> void
-Microsoft.Build.Construction.ProjectTaskElement.SetParameter(string name, string unevaluatedValue) -> void
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Evaluate.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.EvaluateLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskBodyElement.TaskBody.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.AddParameterGroup() -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.AddUsingTaskBody(string evaluate, string taskBody) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Architecture.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.ArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFile.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyName.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.AssemblyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Override.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.OverrideLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.ParameterGroup.get -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.Runtime.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.RuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskBody.get -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactory.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskFactoryLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskName.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskElement.TaskNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Name.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Output.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.OutputLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterType.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ParameterTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.get -> string
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Required.set -> void
-Microsoft.Build.Construction.ProjectUsingTaskParameterElement.RequiredLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.Construction.ProjectWhenElement.ChooseElements.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectChooseElement>
-Microsoft.Build.Construction.ProjectWhenElement.ItemGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectItemGroupElement>
-Microsoft.Build.Construction.ProjectWhenElement.PropertyGroups.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectPropertyGroupElement>
-Microsoft.Build.Construction.SolutionConfigurationInSolution
-Microsoft.Build.Construction.SolutionConfigurationInSolution.ConfigurationName.get -> string
-Microsoft.Build.Construction.SolutionConfigurationInSolution.FullName.get -> string
-Microsoft.Build.Construction.SolutionConfigurationInSolution.PlatformName.get -> string
-Microsoft.Build.Construction.SolutionFile
-Microsoft.Build.Construction.SolutionFile.GetDefaultConfigurationName() -> string
-Microsoft.Build.Construction.SolutionFile.GetDefaultPlatformName() -> string
-Microsoft.Build.Construction.SolutionFile.ProjectsByGuid.get -> System.Collections.Generic.IReadOnlyDictionary<string, Microsoft.Build.Construction.ProjectInSolution>
-Microsoft.Build.Construction.SolutionFile.ProjectsInOrder.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.ProjectInSolution>
-Microsoft.Build.Construction.SolutionFile.SolutionConfigurations.get -> System.Collections.Generic.IReadOnlyList<Microsoft.Build.Construction.SolutionConfigurationInSolution>
-Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.EtpSubProject = 5 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.KnownToBeMSBuildFormat = 1 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.SharedProject = 6 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.SolutionFolder = 2 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.Unknown = 0 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.WebDeploymentProject = 4 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.SolutionProjectType.WebProject = 3 -> Microsoft.Build.Construction.SolutionProjectType
-Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.AddParameter(string name, string output, string required, string parameterType) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.Construction.UsingTaskParameterGroupElement.Parameters.get -> System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectUsingTaskParameterElement>
-Microsoft.Build.Definition.ProjectOptions
-Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.get -> Microsoft.Build.FileSystem.IDirectoryCacheFactory
-Microsoft.Build.Definition.ProjectOptions.DirectoryCacheFactory.set -> void
-Microsoft.Build.Definition.ProjectOptions.EvaluationContext.get -> Microsoft.Build.Evaluation.Context.EvaluationContext
-Microsoft.Build.Definition.ProjectOptions.EvaluationContext.set -> void
-Microsoft.Build.Definition.ProjectOptions.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Definition.ProjectOptions.GlobalProperties.set -> void
-Microsoft.Build.Definition.ProjectOptions.LoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Definition.ProjectOptions.LoadSettings.set -> void
-Microsoft.Build.Definition.ProjectOptions.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Definition.ProjectOptions.ProjectCollection.set -> void
-Microsoft.Build.Definition.ProjectOptions.ProjectOptions() -> void
-Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.get -> string
-Microsoft.Build.Definition.ProjectOptions.SubToolsetVersion.set -> void
-Microsoft.Build.Definition.ProjectOptions.ToolsVersion.get -> string
-Microsoft.Build.Definition.ProjectOptions.ToolsVersion.set -> void
-Microsoft.Build.Evaluation.Context.EvaluationContext
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Isolated = 1 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy.Shared = 0 -> Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy
-Microsoft.Build.Evaluation.GlobResult
-Microsoft.Build.Evaluation.GlobResult.Excludes.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.GlobResult(Microsoft.Build.Construction.ProjectItemElement itemElement, System.Collections.Generic.IEnumerable<string> includeGlobStrings, Microsoft.Build.Globbing.IMSBuildGlob globWithGaps, System.Collections.Generic.IEnumerable<string> excludeFragmentStrings, System.Collections.Generic.IEnumerable<string> removeFragmentStrings) -> void
-Microsoft.Build.Evaluation.GlobResult.IncludeGlobs.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Evaluation.GlobResult.MsBuildGlob.set -> void
-Microsoft.Build.Evaluation.GlobResult.Removes.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Evaluation.GlobResult.Removes.set -> void
-Microsoft.Build.Evaluation.MatchOnMetadataConstants
-Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseInsensitive = 1 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.CaseSensitive = 0 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.MatchOnMetadataOptions.PathLike = 2 -> Microsoft.Build.Evaluation.MatchOnMetadataOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeAllOptions = -1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeToolsVersion = 2 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlDeclaration = 1 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.IncludeXmlNamespace = 4 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.NewProjectFileOptions.None = 0 -> Microsoft.Build.Evaluation.NewProjectFileOptions
-Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Exclude = 1 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Include = 0 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Remove = 3 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Operation.Update = 2 -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AddItemFast(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.Project.AllEvaluatedItems.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.AllEvaluatedProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-Microsoft.Build.Evaluation.Project.Build() -> bool
-Microsoft.Build.Evaluation.Project.Build(Microsoft.Build.Framework.ILogger logger) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> bool
-Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Evaluation.Project.ConditionedProperties.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-Microsoft.Build.Evaluation.Project.CreateProjectInstance() -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Evaluation.Project.DirectoryPath.get -> string
-Microsoft.Build.Evaluation.Project.DisableMarkDirty.get -> bool
-Microsoft.Build.Evaluation.Project.DisableMarkDirty.set -> void
-Microsoft.Build.Evaluation.Project.EvaluationCounter.get -> int
-Microsoft.Build.Evaluation.Project.ExpandString(string unexpandedValue) -> string
-Microsoft.Build.Evaluation.Project.FullPath.get -> string
-Microsoft.Build.Evaluation.Project.FullPath.set -> void
-Microsoft.Build.Evaluation.Project.GetAllGlobs() -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetAllGlobs(string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.GlobResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItemProvenance(string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> System.Collections.Generic.List<Microsoft.Build.Evaluation.ProvenanceResult>
-Microsoft.Build.Evaluation.Project.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(string evaluatedInclude) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.GetLogicalProject() -> System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement>
-Microsoft.Build.Evaluation.Project.GetProperty(string name) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.Project.GetPropertyValue(string name) -> string
-Microsoft.Build.Evaluation.Project.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Evaluation.Project.Imports.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates.get -> System.Collections.Generic.IList<Microsoft.Build.Evaluation.ResolvedImport>
-Microsoft.Build.Evaluation.Project.IsBuildEnabled.get -> bool
-Microsoft.Build.Evaluation.Project.IsBuildEnabled.set -> void
-Microsoft.Build.Evaluation.Project.IsDirty.get -> bool
-Microsoft.Build.Evaluation.Project.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.ProjectItemDefinition>
-Microsoft.Build.Evaluation.Project.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem>
-Microsoft.Build.Evaluation.Project.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Evaluation.Project.LastEvaluationId.get -> int
-Microsoft.Build.Evaluation.Project.MarkDirty() -> void
-Microsoft.Build.Evaluation.Project.Project() -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) -> void
-Microsoft.Build.Evaluation.Project.ProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Evaluation.Project.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.Project.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty>
-Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary() -> void
-Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) -> void
-Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(string name) -> bool
-Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem item) -> bool
-Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectItem> items) -> void
-Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty property) -> bool
-Microsoft.Build.Evaluation.Project.Save() -> void
-Microsoft.Build.Evaluation.Project.Save(string path) -> void
-Microsoft.Build.Evaluation.Project.Save(string path, System.Text.Encoding encoding) -> void
-Microsoft.Build.Evaluation.Project.Save(System.IO.TextWriter writer) -> void
-Microsoft.Build.Evaluation.Project.Save(System.Text.Encoding encoding) -> void
-Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter writer) -> void
-Microsoft.Build.Evaluation.Project.SetGlobalProperty(string name, string escapedValue) -> bool
-Microsoft.Build.Evaluation.Project.SetProperty(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.Project.SkipEvaluation.get -> bool
-Microsoft.Build.Evaluation.Project.SkipEvaluation.set -> void
-Microsoft.Build.Evaluation.Project.SubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Project.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.get -> bool
-Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement.set -> void
-Microsoft.Build.Evaluation.Project.ToolsVersion.get -> string
-Microsoft.Build.Evaluation.Project.Xml.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectChangedEventArgs
-Microsoft.Build.Evaluation.ProjectChangedEventArgs.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.Evaluation.ProjectCollection.AddToolset(Microsoft.Build.Evaluation.Toolset toolset) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ContainsToolset(string toolsVersion) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.Count.get -> int
-Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.get -> string
-Microsoft.Build.Evaluation.ProjectCollection.DefaultToolsVersion.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.DisableMarkDirty.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.Dispose() -> void
-Microsoft.Build.Evaluation.ProjectCollection.GetEffectiveToolsVersion(string explicitToolsVersion, string toolsVersionFromProject) -> string
-Microsoft.Build.Evaluation.ProjectCollection.GetGlobalProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Evaluation.ProjectCollection.GetLoadedProjects(string fullPath) -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-Microsoft.Build.Evaluation.ProjectCollection.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Evaluation.ProjectCollection.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Evaluation.ProjectCollection.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Evaluation.ProjectCollection.HostServices.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.IsBuildEnabled.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.LoadedProjects.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Project>
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(string fileName, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.LoadProject(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectCollection.Loggers.get -> System.Collections.Generic.ICollection<Microsoft.Build.Framework.ILogger>
-Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.OnlyLogCriticalEvents.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAdded -> Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedEventHandler
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectAddedToProjectCollectionEventArgs(Microsoft.Build.Construction.ProjectRootElement element) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectAddedToProjectCollectionEventArgs.ProjectRootElement.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectCollection.ProjectChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection() -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetLocations) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly) -> void
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollectionChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.ProjectXmlChanged -> System.EventHandler<Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs>
-Microsoft.Build.Evaluation.ProjectCollection.RegisterForwardingLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RegisterLogger(Microsoft.Build.Framework.ILogger logger) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RegisterLoggers(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> void
-Microsoft.Build.Evaluation.ProjectCollection.RemoveAllToolsets() -> void
-Microsoft.Build.Evaluation.ProjectCollection.RemoveGlobalProperty(string name) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.RemoveToolset(string toolsVersion) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.SetGlobalProperty(string name, string value) -> void
-Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.get -> bool
-Microsoft.Build.Evaluation.ProjectCollection.SkipEvaluation.set -> void
-Microsoft.Build.Evaluation.ProjectCollection.ToolsetLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ProjectCollection.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
-Microsoft.Build.Evaluation.ProjectCollection.TryUnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> bool
-Microsoft.Build.Evaluation.ProjectCollection.UnloadAllProjects() -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Construction.ProjectRootElement projectRootElement) -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnloadProject(Microsoft.Build.Evaluation.Project project) -> void
-Microsoft.Build.Evaluation.ProjectCollection.UnregisterAllLoggers() -> void
-Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs
-Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs.Changed.get -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.DefaultToolsVersion = 0 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.DisableMarkDirty = 7 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.GlobalProperties = 3 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.HostServices = 6 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.IsBuildEnabled = 4 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.Loggers = 2 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.OnlyLogCriticalEvents = 5 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.SkipEvaluation = 8 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectCollectionChangedState.Toolsets = 1 -> Microsoft.Build.Evaluation.ProjectCollectionChangedState
-Microsoft.Build.Evaluation.ProjectItem
-Microsoft.Build.Evaluation.ProjectItem.DirectMetadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItem.DirectMetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItem.EvaluatedInclude.get -> string
-Microsoft.Build.Evaluation.ProjectItem.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.GetMetadataValue(string name) -> string
-Microsoft.Build.Evaluation.ProjectItem.HasMetadata(string name) -> bool
-Microsoft.Build.Evaluation.ProjectItem.IsImported.get -> bool
-Microsoft.Build.Evaluation.ProjectItem.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectItem.ItemType.set -> void
-Microsoft.Build.Evaluation.ProjectItem.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItem.MetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItem.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(string name) -> bool
-Microsoft.Build.Evaluation.ProjectItem.Rename(string name) -> void
-Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.get -> string
-Microsoft.Build.Evaluation.ProjectItem.UnevaluatedInclude.set -> void
-Microsoft.Build.Evaluation.ProjectItem.Xml.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.ProjectItemDefinition
-Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadata(string name) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectItemDefinition.GetMetadataValue(string name) -> string
-Microsoft.Build.Evaluation.ProjectItemDefinition.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectItemDefinition.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Evaluation.ProjectMetadata>
-Microsoft.Build.Evaluation.ProjectItemDefinition.MetadataCount.get -> int
-Microsoft.Build.Evaluation.ProjectItemDefinition.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectItemDefinition.SetMetadataValue(string name, string unevaluatedValue) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.Default = 0 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.DoNotEvaluateElementsWithFalseCondition = 32 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.FailOnUnresolvedSdk = 256 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreEmptyImports = 16 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreInvalidImports = 64 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreMissingImports = 1 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.ProfileEvaluation = 128 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RecordDuplicateButNotCircularImports = 2 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements = 8 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectLoadSettings.RejectCircularImports = 4 -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectMetadata.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.ProjectMetadata.EvaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.IsImported.get -> bool
-Microsoft.Build.Evaluation.ProjectMetadata.ItemType.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Evaluation.ProjectMetadata.Name.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.Predecessor.get -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.Evaluation.ProjectMetadata.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectMetadata.UnevaluatedValue.set -> void
-Microsoft.Build.Evaluation.ProjectMetadata.Xml.get -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.Evaluation.ProjectProperty.EvaluatedValue.get -> string
-Microsoft.Build.Evaluation.ProjectProperty.Project.get -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.ProjectXml.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs.Reason.get -> string
-Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Glob = 2 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Inconclusive = 4 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.StringLiteral = 1 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.Provenance.Undefined = 0 -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.ProvenanceResult
-Microsoft.Build.Evaluation.ProvenanceResult.ItemElement.get -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.Evaluation.ProvenanceResult.Occurrences.get -> int
-Microsoft.Build.Evaluation.ProvenanceResult.Operation.get -> Microsoft.Build.Evaluation.Operation
-Microsoft.Build.Evaluation.ProvenanceResult.Provenance.get -> Microsoft.Build.Evaluation.Provenance
-Microsoft.Build.Evaluation.ProvenanceResult.ProvenanceResult(Microsoft.Build.Construction.ProjectItemElement itemElement, Microsoft.Build.Evaluation.Operation operation, Microsoft.Build.Evaluation.Provenance provenance, int occurrences) -> void
-Microsoft.Build.Evaluation.ResolvedImport
-Microsoft.Build.Evaluation.ResolvedImport.ImportedProject.get -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Evaluation.ResolvedImport.ImportingElement.get -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.Evaluation.ResolvedImport.IsImported.get -> bool
-Microsoft.Build.Evaluation.ResolvedImport.ResolvedImport() -> void
-Microsoft.Build.Evaluation.ResolvedImport.SdkResult.get -> Microsoft.Build.Framework.SdkResult
-Microsoft.Build.Evaluation.SubToolset
-Microsoft.Build.Evaluation.SubToolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Evaluation.SubToolset.SubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Evaluation.Toolset.DefaultSubToolsetVersion.get -> string
-Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion() -> string
-Microsoft.Build.Evaluation.Toolset.GenerateSubToolsetVersion(System.Collections.Generic.IDictionary<string, string> overrideGlobalProperties, int solutionVersion) -> string
-Microsoft.Build.Evaluation.Toolset.GetProperty(string propertyName, string subToolsetVersion) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Evaluation.Toolset.Properties.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Evaluation.Toolset.SubToolsets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset>
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.Toolset(string toolsVersion, string toolsPath, System.Collections.Generic.IDictionary<string, string> buildProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection, System.Collections.Generic.IDictionary<string, Microsoft.Build.Evaluation.SubToolset> subToolsets, string msbuildOverrideTasksPath) -> void
-Microsoft.Build.Evaluation.Toolset.ToolsPath.get -> string
-Microsoft.Build.Evaluation.Toolset.ToolsVersion.get -> string
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.ConfigurationFile = 1 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Default = 4 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Local = 4 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.None = 0 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Evaluation.ToolsetDefinitionLocations.Registry = 2 -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Exceptions.BuildAbortedException
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException() -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.BuildAbortedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Exceptions.BuildAbortedException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.CircularDependencyException
-Microsoft.Build.Exceptions.CircularDependencyException.CircularDependencyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Exceptions.InternalLoggerException
-Microsoft.Build.Exceptions.InternalLoggerException.BuildEventArgs.get -> Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Exceptions.InternalLoggerException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InternalLoggerException.HelpKeyword.get -> string
-Microsoft.Build.Exceptions.InternalLoggerException.InitializationException.get -> bool
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException() -> void
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message) -> void
-Microsoft.Build.Exceptions.InternalLoggerException.InternalLoggerException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException
-Microsoft.Build.Exceptions.InvalidProjectFileException.BaseMessage.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.ColumnNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.EndColumnNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.EndLineNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.ErrorSubcategory.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.HasBeenLogged.get -> bool
-Microsoft.Build.Exceptions.InvalidProjectFileException.HelpKeyword.get -> string
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException() -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
-Microsoft.Build.Exceptions.InvalidProjectFileException.LineNumber.get -> int
-Microsoft.Build.Exceptions.InvalidProjectFileException.ProjectFile.get -> string
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.ErrorCode.get -> string
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException() -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, System.Exception innerException) -> void
-Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters) -> void
-Microsoft.Build.Execution.BuildManager.BeginBuild(Microsoft.Build.Execution.BuildParameters parameters, System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.BuildManager.DeferredBuildMessage> deferredBuildMessages) -> void
-Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildManager.Build(Microsoft.Build.Execution.BuildParameters parameters, Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Execution.BuildManager.BuildManager() -> void
-Microsoft.Build.Execution.BuildManager.BuildManager(string hostName) -> void
-Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildManager.BuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Execution.BuildManager.CancelAllSubmissions() -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage() -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.DeferredBuildMessage(string text, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Importance.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Execution.BuildManager.DeferredBuildMessage.Text.get -> string
-Microsoft.Build.Execution.BuildManager.Dispose() -> void
-Microsoft.Build.Execution.BuildManager.EndBuild() -> void
-Microsoft.Build.Execution.BuildManager.GetProjectInstanceForBuild(Microsoft.Build.Evaluation.Project project) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Execution.BuildRequestData requestData) -> Microsoft.Build.Execution.BuildSubmission
-Microsoft.Build.Execution.BuildManager.PendBuildRequest(Microsoft.Build.Graph.GraphBuildRequestData requestData) -> Microsoft.Build.Graph.GraphBuildSubmission
-Microsoft.Build.Execution.BuildManager.ResetCaches() -> void
-Microsoft.Build.Execution.BuildManager.ShutdownAllNodes() -> void
-Microsoft.Build.Execution.BuildManager.~BuildManager() -> void
-Microsoft.Build.Execution.BuildParameters
-Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.get -> bool
-Microsoft.Build.Execution.BuildParameters.AllowFailureWithoutError.set -> void
-Microsoft.Build.Execution.BuildParameters.BuildParameters() -> void
-Microsoft.Build.Execution.BuildParameters.BuildParameters(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.BuildParameters.BuildProcessEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.get -> System.Threading.ThreadPriority
-Microsoft.Build.Execution.BuildParameters.BuildThreadPriority.set -> void
-Microsoft.Build.Execution.BuildParameters.Clone() -> Microsoft.Build.Execution.BuildParameters
-Microsoft.Build.Execution.BuildParameters.Culture.get -> System.Globalization.CultureInfo
-Microsoft.Build.Execution.BuildParameters.Culture.set -> void
-Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.get -> string
-Microsoft.Build.Execution.BuildParameters.DefaultToolsVersion.set -> void
-Microsoft.Build.Execution.BuildParameters.DetailedSummary.get -> bool
-Microsoft.Build.Execution.BuildParameters.DetailedSummary.set -> void
-Microsoft.Build.Execution.BuildParameters.DisableInProcNode.get -> bool
-Microsoft.Build.Execution.BuildParameters.DisableInProcNode.set -> void
-Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.get -> bool
-Microsoft.Build.Execution.BuildParameters.DiscardBuildResults.set -> void
-Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.get -> bool
-Microsoft.Build.Execution.BuildParameters.EnableNodeReuse.set -> void
-Microsoft.Build.Execution.BuildParameters.EnvironmentProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord>
-Microsoft.Build.Execution.BuildParameters.ForwardingLoggers.set -> void
-Microsoft.Build.Execution.BuildParameters.GetToolset(string toolsVersion) -> Microsoft.Build.Evaluation.Toolset
-Microsoft.Build.Execution.BuildParameters.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.BuildParameters.GlobalProperties.set -> void
-Microsoft.Build.Execution.BuildParameters.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.BuildParameters.HostServices.set -> void
-Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.get -> string[]
-Microsoft.Build.Execution.BuildParameters.InputResultsCacheFiles.set -> void
-Microsoft.Build.Execution.BuildParameters.Interactive.get -> bool
-Microsoft.Build.Execution.BuildParameters.Interactive.set -> void
-Microsoft.Build.Execution.BuildParameters.IsolateProjects.get -> bool
-Microsoft.Build.Execution.BuildParameters.IsolateProjects.set -> void
-Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.get -> bool
-Microsoft.Build.Execution.BuildParameters.LegacyThreadingSemantics.set -> void
-Microsoft.Build.Execution.BuildParameters.Loggers.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger>
-Microsoft.Build.Execution.BuildParameters.Loggers.set -> void
-Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.get -> bool
-Microsoft.Build.Execution.BuildParameters.LogInitialPropertiesAndItems.set -> void
-Microsoft.Build.Execution.BuildParameters.LogTaskInputs.get -> bool
-Microsoft.Build.Execution.BuildParameters.LogTaskInputs.set -> void
-Microsoft.Build.Execution.BuildParameters.LowPriority.get -> bool
-Microsoft.Build.Execution.BuildParameters.LowPriority.set -> void
-Microsoft.Build.Execution.BuildParameters.MaxNodeCount.get -> int
-Microsoft.Build.Execution.BuildParameters.MaxNodeCount.set -> void
-Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.get -> int
-Microsoft.Build.Execution.BuildParameters.MemoryUseLimit.set -> void
-Microsoft.Build.Execution.BuildParameters.NodeExeLocation.get -> string
-Microsoft.Build.Execution.BuildParameters.NodeExeLocation.set -> void
-Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.get -> bool
-Microsoft.Build.Execution.BuildParameters.OnlyLogCriticalEvents.set -> void
-Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.get -> string
-Microsoft.Build.Execution.BuildParameters.OutputResultsCacheFile.set -> void
-Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Execution.BuildParameters.ProjectCacheDescriptor.set -> void
-Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.get -> Microsoft.Build.Evaluation.ProjectLoadSettings
-Microsoft.Build.Execution.BuildParameters.ProjectLoadSettings.set -> void
-Microsoft.Build.Execution.BuildParameters.ResetCaches.get -> bool
-Microsoft.Build.Execution.BuildParameters.ResetCaches.set -> void
-Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.get -> bool
-Microsoft.Build.Execution.BuildParameters.SaveOperatingEnvironment.set -> void
-Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.get -> bool
-Microsoft.Build.Execution.BuildParameters.ShutdownInProcNodeOnBuildFinish.set -> void
-Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.get -> Microsoft.Build.Evaluation.ToolsetDefinitionLocations
-Microsoft.Build.Execution.BuildParameters.ToolsetDefinitionLocations.set -> void
-Microsoft.Build.Execution.BuildParameters.Toolsets.get -> System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.Toolset>
-Microsoft.Build.Execution.BuildParameters.UICulture.get -> System.Globalization.CultureInfo
-Microsoft.Build.Execution.BuildParameters.UICulture.set -> void
-Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.get -> bool
-Microsoft.Build.Execution.BuildParameters.UseSynchronousLogging.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsAsErrors.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsAsMessages.set -> void
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.get -> System.Collections.Generic.ISet<string>
-Microsoft.Build.Execution.BuildParameters.WarningsNotAsErrors.set -> void
-Microsoft.Build.Execution.BuildRequestData
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(Microsoft.Build.Execution.ProjectInstance projectInstance, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, System.Collections.Generic.IEnumerable<string> propertiesToTransfer, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Execution.BuildRequestData.BuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string[] targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Execution.RequestedProjectState requestedProjectState) -> void
-Microsoft.Build.Execution.BuildRequestData.ExplicitlySpecifiedToolsVersion.get -> string
-Microsoft.Build.Execution.BuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestData.GlobalProperties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Execution.BuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.BuildRequestData.ProjectFullPath.get -> string
-Microsoft.Build.Execution.BuildRequestData.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildRequestData.PropertiesToTransfer.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Execution.BuildRequestData.RequestedProjectState.get -> Microsoft.Build.Execution.RequestedProjectState
-Microsoft.Build.Execution.BuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ClearCachesAfterBuild = 8 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.FailOnUnresolvedSdk = 128 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState = 4 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports = 64 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.None = 0 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild = 2 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild = 32 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance = 1 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildRequestDataFlags.SkipNonexistentTargets = 16 -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildResult.AddResultsForTarget(string target, Microsoft.Build.Execution.TargetResult result) -> void
-Microsoft.Build.Execution.BuildResult.BuildResult() -> void
-Microsoft.Build.Execution.BuildResult.CircularDependency.get -> bool
-Microsoft.Build.Execution.BuildResult.ConfigurationId.get -> int
-Microsoft.Build.Execution.BuildResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.BuildResult.GlobalRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.HasResultsForTarget(string target) -> bool
-Microsoft.Build.Execution.BuildResult.MergeResults(Microsoft.Build.Execution.BuildResult results) -> void
-Microsoft.Build.Execution.BuildResult.NodeRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResult.ParentGlobalRequestId.get -> int
-Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild.set -> void
-Microsoft.Build.Execution.BuildResult.ResultsByTarget.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult>
-Microsoft.Build.Execution.BuildResult.SubmissionId.get -> int
-Microsoft.Build.Execution.BuildResult.this[string target].get -> Microsoft.Build.Execution.ITargetResult
-Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResultCode.Failure = 1 -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildResultCode.Success = 0 -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Execution.BuildSubmission
-Microsoft.Build.Execution.BuildSubmission.AsyncContext.get -> object
-Microsoft.Build.Execution.BuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Execution.BuildSubmission.BuildResult.get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildSubmission.BuildResult.set -> void
-Microsoft.Build.Execution.BuildSubmission.Execute() -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Execution.BuildSubmission.ExecuteAsync(Microsoft.Build.Execution.BuildSubmissionCompleteCallback callback, object context) -> void
-Microsoft.Build.Execution.BuildSubmission.IsCompleted.get -> bool
-Microsoft.Build.Execution.BuildSubmission.SubmissionId.get -> int
-Microsoft.Build.Execution.BuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
-Microsoft.Build.Execution.BuildSubmissionCompleteCallback
-Microsoft.Build.Execution.HostServices
-Microsoft.Build.Execution.HostServices.GetHostObject(string projectFile, string targetName, string taskName) -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Execution.HostServices.GetNodeAffinity(string projectFile) -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.HostServices.HostServices() -> void
-Microsoft.Build.Execution.HostServices.OnRenameProject(string oldFullPath, string newFullPath) -> void
-Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, Microsoft.Build.Framework.ITaskHost hostObject) -> void
-Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName) -> void
-Microsoft.Build.Execution.HostServices.SetNodeAffinity(string projectFile, Microsoft.Build.Execution.NodeAffinity nodeAffinity) -> void
-Microsoft.Build.Execution.HostServices.UnregisterProject(string projectFullPath) -> void
-Microsoft.Build.Execution.ITargetResult
-Microsoft.Build.Execution.ITargetResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.ITargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Execution.ITargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.Any = 2 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.InProc = 0 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeAffinity.OutOfProc = 1 -> Microsoft.Build.Execution.NodeAffinity
-Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.BuildComplete = 0 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.BuildCompleteReuse = 1 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.ConnectionFailed = 2 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.NodeEngineShutdownReason.Error = 3 -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode
-Microsoft.Build.Execution.OutOfProcNode.OutOfProcNode() -> void
-Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, bool lowPriority, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode.Run(bool enableReuse, out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.OutOfProcNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude) -> Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectInstance.AddItem(string itemType, string evaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) -> Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectInstance.Build() -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string target, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(string[] targets, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, out System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.TargetResult> targetOutputs) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.Build(System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers) -> bool
-Microsoft.Build.Execution.ProjectInstance.DeepCopy() -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.DeepCopy(bool isImmutable) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.DefaultTargets.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.ProjectInstance.Directory.get -> string
-Microsoft.Build.Execution.ProjectInstance.EvaluateCondition(string condition) -> bool
-Microsoft.Build.Execution.ProjectInstance.EvaluatedItemElements.get -> System.Collections.Generic.List<Microsoft.Build.Construction.ProjectItemElement>
-Microsoft.Build.Execution.ProjectInstance.EvaluationId.get -> int
-Microsoft.Build.Execution.ProjectInstance.EvaluationId.set -> void
-Microsoft.Build.Execution.ProjectInstance.ExpandString(string unexpandedValue) -> string
-Microsoft.Build.Execution.ProjectInstance.FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectInstance.FullPath.get -> string
-Microsoft.Build.Execution.ProjectInstance.GetItems(string itemType) -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.GetItemsByItemTypeAndEvaluatedInclude(string itemType, string evaluatedInclude) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.GetProperty(string name) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectInstance.GetPropertyValue(string name) -> string
-Microsoft.Build.Execution.ProjectInstance.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.ProjectInstance.ImportPaths.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Execution.ProjectInstance.ImportPathsIncludingDuplicates.get -> System.Collections.Generic.IReadOnlyList<string>
-Microsoft.Build.Execution.ProjectInstance.InitialTargets.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.ProjectInstance.IsImmutable.get -> bool
-Microsoft.Build.Execution.ProjectInstance.ItemDefinitions.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectItemDefinitionInstance>
-Microsoft.Build.Execution.ProjectInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance>
-Microsoft.Build.Execution.ProjectInstance.ItemTypes.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.ProjectInstance.ProjectFileLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(Microsoft.Build.Evaluation.Project project, Microsoft.Build.Execution.ProjectInstanceSettings settings) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.ProjectInstance(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Execution.ProjectInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyInstance>
-Microsoft.Build.Execution.ProjectInstance.RemoveItem(Microsoft.Build.Execution.ProjectItemInstance item) -> bool
-Microsoft.Build.Execution.ProjectInstance.RemoveProperty(string name) -> bool
-Microsoft.Build.Execution.ProjectInstance.SetProperty(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectInstance.Targets.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance>
-Microsoft.Build.Execution.ProjectInstance.ToolsVersion.get -> string
-Microsoft.Build.Execution.ProjectInstance.ToProjectRootElement() -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.get -> bool
-Microsoft.Build.Execution.ProjectInstance.TranslateEntireState.set -> void
-Microsoft.Build.Execution.ProjectInstance.UpdateStateFrom(Microsoft.Build.Execution.ProjectInstance projectState) -> void
-Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.Immutable = 1 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.ImmutableWithFastItemLookup = 3 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectInstanceSettings.None = 0 -> Microsoft.Build.Execution.ProjectInstanceSettings
-Microsoft.Build.Execution.ProjectItemDefinitionInstance
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectMetadataInstance>
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemDefinitionInstance.MetadataNames.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.Execution.ProjectItemGroupTaskInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Items.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance>
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Exclude.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ExcludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Include.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.IncludeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicates.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepDuplicatesLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.KeepMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptions.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.MatchOnMetadataOptionsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Metadata.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance>
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.Remove.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadata.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance.RemoveMetadataLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance.Value.get -> string
-Microsoft.Build.Execution.ProjectItemInstance
-Microsoft.Build.Execution.ProjectItemInstance.DirectMetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.get -> string
-Microsoft.Build.Execution.ProjectItemInstance.EvaluatedInclude.set -> void
-Microsoft.Build.Execution.ProjectItemInstance.GetMetadata(string name) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemInstance.GetMetadataValue(string name) -> string
-Microsoft.Build.Execution.ProjectItemInstance.HasMetadata(string name) -> bool
-Microsoft.Build.Execution.ProjectItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectItemInstance.Metadata.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Execution.ProjectMetadataInstance>
-Microsoft.Build.Execution.ProjectItemInstance.MetadataCount.get -> int
-Microsoft.Build.Execution.ProjectItemInstance.MetadataNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Execution.ProjectItemInstance.Project.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Execution.ProjectItemInstance.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(string name, string evaluatedValue) -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectItemInstance.SetMetadata(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadataDictionary) -> void
-Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectMetadataInstance.DeepClone() -> Microsoft.Build.Execution.ProjectMetadataInstance
-Microsoft.Build.Execution.ProjectMetadataInstance.EvaluatedValue.get -> string
-Microsoft.Build.Execution.ProjectMetadataInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectOnErrorInstance
-Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargets.get -> string
-Microsoft.Build.Execution.ProjectOnErrorInstance.ExecuteTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance
-Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Properties.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance>
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance.Value.get -> string
-Microsoft.Build.Execution.ProjectPropertyInstance
-Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.get -> string
-Microsoft.Build.Execution.ProjectPropertyInstance.EvaluatedValue.set -> void
-Microsoft.Build.Execution.ProjectPropertyInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance
-Microsoft.Build.Execution.ProjectTargetInstance.AfterTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.AfterTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.BeforeTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Children.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTargetInstanceChild>
-Microsoft.Build.Execution.ProjectTargetInstance.Condition.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargets.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.DependsOnTargetsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.FullPath.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.Inputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.InputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.KeepDuplicateOutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.OnErrorChildren.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectOnErrorInstance>
-Microsoft.Build.Execution.ProjectTargetInstance.Outputs.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.OutputsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Returns.get -> string
-Microsoft.Build.Execution.ProjectTargetInstance.ReturnsLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTargetInstance.Tasks.get -> System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectTaskInstance>
-Microsoft.Build.Execution.ProjectTargetInstanceChild
-Microsoft.Build.Execution.ProjectTargetInstanceChild.FullPath.get -> string
-Microsoft.Build.Execution.ProjectTargetInstanceChild.ProjectTargetInstanceChild() -> void
-Microsoft.Build.Execution.ProjectTaskInstance
-Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnError.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.ContinueOnErrorLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitecture.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildArchitectureLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntime.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.MSBuildRuntimeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskInstance.Name.get -> string
-Microsoft.Build.Execution.ProjectTaskInstance.Outputs.get -> System.Collections.Generic.IList<Microsoft.Build.Execution.ProjectTaskInstanceChild>
-Microsoft.Build.Execution.ProjectTaskInstance.Parameters.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Execution.ProjectTaskInstanceChild
-Microsoft.Build.Execution.ProjectTaskInstanceChild.ProjectTaskInstanceChild() -> void
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemType.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ItemTypeLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameter.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyName.get -> string
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.PropertyNameLocation.get -> Microsoft.Build.Construction.ElementLocation
-Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameter.get -> string
-Microsoft.Build.Execution.RequestedProjectState
-Microsoft.Build.Execution.RequestedProjectState.ItemFilters.get -> System.Collections.Generic.IDictionary<string, System.Collections.Generic.List<string>>
-Microsoft.Build.Execution.RequestedProjectState.ItemFilters.set -> void
-Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Execution.RequestedProjectState.PropertyFilters.set -> void
-Microsoft.Build.Execution.RequestedProjectState.RequestedProjectState() -> void
-Microsoft.Build.Execution.TargetResult
-Microsoft.Build.Execution.TargetResult.Exception.get -> System.Exception
-Microsoft.Build.Execution.TargetResult.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Execution.TargetResult.ResultCode.get -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Failure = 2 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Skipped = 0 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Execution.TargetResultCode.Success = 1 -> Microsoft.Build.Execution.TargetResultCode
-Microsoft.Build.Experimental.ProjectCache.CacheContext
-Microsoft.Build.Experimental.ProjectCache.CacheContext.CacheContext(System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem, Microsoft.Build.Graph.ProjectGraph graph = null, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint> graphEntryPoints = null) -> void
-Microsoft.Build.Experimental.ProjectCache.CacheContext.FileSystem.get -> Microsoft.Build.FileSystem.MSBuildFileSystemBase
-Microsoft.Build.Experimental.ProjectCache.CacheContext.Graph.get -> Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Experimental.ProjectCache.CacheContext.GraphEntryPoints.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Experimental.ProjectCache.CacheContext.MSBuildExePath.get -> string
-Microsoft.Build.Experimental.ProjectCache.CacheContext.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.CacheResult
-Microsoft.Build.Experimental.ProjectCache.CacheResult.BuildResult.get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Experimental.ProjectCache.CacheResult.ProxyTargets.get -> Microsoft.Build.Experimental.ProjectCache.ProxyTargets
-Microsoft.Build.Experimental.ProjectCache.CacheResult.ResultType.get -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheHit = 1 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheMiss = 2 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.CacheNotApplicable = 3 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.CacheResultType.None = 0 -> Microsoft.Build.Experimental.ProjectCache.CacheResultType
-Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase
-Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase.PluginLoggerBase() -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult() -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.PluginTargetResult(string targetName, System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2> taskItems, Microsoft.Build.Execution.BuildResultCode resultCode) -> void
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.ResultCode.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TargetName.get -> string
-Microsoft.Build.Experimental.ProjectCache.PluginTargetResult.TaskItems.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Framework.ITaskItem2>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginAssemblyPath.get -> string
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginInstance.get -> Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.PluginSettings.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.ErrorCode.get -> string
-Microsoft.Build.Experimental.ProjectCache.ProjectCacheException.HasBeenLoggedByProjectCache.get -> bool
-Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase
-Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase.ProjectCachePluginBase() -> void
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargets(System.Collections.Generic.IReadOnlyDictionary<string, string> proxyTargetToRealTargetMap) -> void
-Microsoft.Build.Experimental.ProjectCache.ProxyTargets.ProxyTargetToRealTargetMap.get -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.FileSystem.FindPredicate
-Microsoft.Build.FileSystem.FindTransform<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache
-Microsoft.Build.FileSystem.IDirectoryCache.DirectoryExists(string path) -> bool
-Microsoft.Build.FileSystem.IDirectoryCache.EnumerateDirectories<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache.EnumerateFiles<TResult>(string path, string pattern, Microsoft.Build.FileSystem.FindPredicate predicate, Microsoft.Build.FileSystem.FindTransform<TResult> transform) -> System.Collections.Generic.IEnumerable<TResult>
-Microsoft.Build.FileSystem.IDirectoryCache.FileExists(string path) -> bool
-Microsoft.Build.FileSystem.IDirectoryCacheFactory
-Microsoft.Build.FileSystem.IDirectoryCacheFactory.GetDirectoryCacheForEvaluation(int evaluationId) -> Microsoft.Build.FileSystem.IDirectoryCache
-Microsoft.Build.FileSystem.MSBuildFileSystemBase
-Microsoft.Build.FileSystem.MSBuildFileSystemBase.MSBuildFileSystemBase() -> void
-Microsoft.Build.Globbing.CompositeGlob
-Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(params Microsoft.Build.Globbing.IMSBuildGlob[] globs) -> void
-Microsoft.Build.Globbing.CompositeGlob.CompositeGlob(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> void
-Microsoft.Build.Globbing.CompositeGlob.Globs.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob>
-Microsoft.Build.Globbing.CompositeGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions
-Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.IMSBuildGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlob.FilenamePart.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.FixedDirectoryPart.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.IsLegal.get -> bool
-Microsoft.Build.Globbing.MSBuildGlob.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfo(string stringToMatch) -> Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FilenamePartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.FixedDirectoryPartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.IsMatch.get -> bool
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.MatchInfoResult() -> void
-Microsoft.Build.Globbing.MSBuildGlob.MatchInfoResult.WildcardDirectoryPartMatchGroup.get -> string
-Microsoft.Build.Globbing.MSBuildGlob.WildcardDirectoryPart.get -> string
-Microsoft.Build.Globbing.MSBuildGlobWithGaps
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.Gaps.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.IsMatch(string stringToMatch) -> bool
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MainGlob.get -> Microsoft.Build.Globbing.IMSBuildGlob
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, params Microsoft.Build.Globbing.IMSBuildGlob[] gaps) -> void
-Microsoft.Build.Globbing.MSBuildGlobWithGaps.MSBuildGlobWithGaps(Microsoft.Build.Globbing.IMSBuildGlob mainGlob, System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> gaps) -> void
-Microsoft.Build.Graph.GraphBuildOptions
-Microsoft.Build.Graph.GraphBuildOptions.Build.get -> bool
-Microsoft.Build.Graph.GraphBuildOptions.Build.init -> void
-Microsoft.Build.Graph.GraphBuildRequestData
-Microsoft.Build.Graph.GraphBuildRequestData.Flags.get -> Microsoft.Build.Execution.BuildRequestDataFlags
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildOptions.get -> Microsoft.Build.Graph.GraphBuildOptions
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraph projectGraph, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(Microsoft.Build.Graph.ProjectGraphEntryPoint projectGraphEntryPoint, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(string projectFullPath, System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.GraphBuildRequestData(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> projectGraphEntryPoints, System.Collections.Generic.ICollection<string> targetsToBuild, Microsoft.Build.Execution.HostServices hostServices, Microsoft.Build.Execution.BuildRequestDataFlags flags, Microsoft.Build.Graph.GraphBuildOptions graphBuildOptions) -> void
-Microsoft.Build.Graph.GraphBuildRequestData.HostServices.get -> Microsoft.Build.Execution.HostServices
-Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraph.get -> Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Graph.GraphBuildRequestData.ProjectGraphEntryPoints.get -> System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint>
-Microsoft.Build.Graph.GraphBuildRequestData.TargetNames.get -> System.Collections.Generic.ICollection<string>
-Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildResult.CircularDependency.get -> bool
-Microsoft.Build.Graph.GraphBuildResult.Exception.get -> System.Exception
-Microsoft.Build.Graph.GraphBuildResult.OverallResult.get -> Microsoft.Build.Execution.BuildResultCode
-Microsoft.Build.Graph.GraphBuildResult.ResultsByNode.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, Microsoft.Build.Execution.BuildResult>
-Microsoft.Build.Graph.GraphBuildResult.SubmissionId.get -> int
-Microsoft.Build.Graph.GraphBuildResult.this[Microsoft.Build.Graph.ProjectGraphNode node].get -> Microsoft.Build.Execution.BuildResult
-Microsoft.Build.Graph.GraphBuildSubmission
-Microsoft.Build.Graph.GraphBuildSubmission.AsyncContext.get -> object
-Microsoft.Build.Graph.GraphBuildSubmission.BuildManager.get -> Microsoft.Build.Execution.BuildManager
-Microsoft.Build.Graph.GraphBuildSubmission.BuildResult.get -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildSubmission.Execute() -> Microsoft.Build.Graph.GraphBuildResult
-Microsoft.Build.Graph.GraphBuildSubmission.ExecuteAsync(Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback callback, object context) -> void
-Microsoft.Build.Graph.GraphBuildSubmission.IsCompleted.get -> bool
-Microsoft.Build.Graph.GraphBuildSubmission.SubmissionId.get -> int
-Microsoft.Build.Graph.GraphBuildSubmission.WaitHandle.get -> System.Threading.WaitHandle
-Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback
-Microsoft.Build.Graph.ProjectGraph
-Microsoft.Build.Graph.ProjectGraph.ConstructionMetrics.get -> Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
-Microsoft.Build.Graph.ProjectGraph.EntryPointNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.GetTargetLists(System.Collections.Generic.ICollection<string> entryProjectTargets) -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Graph.ProjectGraphNode, System.Collections.Immutable.ImmutableList<string>>
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.ConstructionTime.get -> System.TimeSpan
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.EdgeCount.get -> int
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics() -> void
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.GraphConstructionMetrics(System.TimeSpan constructionTime, int nodeCount, int edgeCount) -> void
-Microsoft.Build.Graph.ProjectGraph.GraphConstructionMetrics.NodeCount.get -> int
-Microsoft.Build.Graph.ProjectGraph.GraphRoots.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(Microsoft.Build.Graph.ProjectGraphEntryPoint entryPoint, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(string entryProjectFile, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, int degreeOfParallelism, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<Microsoft.Build.Graph.ProjectGraphEntryPoint> entryPoints, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc projectInstanceFactory, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectGraph(System.Collections.Generic.IEnumerable<string> entryProjectFiles, System.Collections.Generic.IDictionary<string, string> globalProperties, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> void
-Microsoft.Build.Graph.ProjectGraph.ProjectInstanceFactoryFunc
-Microsoft.Build.Graph.ProjectGraph.ProjectNodes.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraph.ProjectNodesTopologicallySorted.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraphEntryPoint
-Microsoft.Build.Graph.ProjectGraphEntryPoint.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectFile.get -> string
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint() -> void
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile) -> void
-Microsoft.Build.Graph.ProjectGraphEntryPoint.ProjectGraphEntryPoint(string projectFile, System.Collections.Generic.IDictionary<string, string> globalProperties) -> void
-Microsoft.Build.Graph.ProjectGraphNode
-Microsoft.Build.Graph.ProjectGraphNode.ProjectInstance.get -> Microsoft.Build.Execution.ProjectInstance
-Microsoft.Build.Graph.ProjectGraphNode.ProjectReferences.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Graph.ProjectGraphNode.ReferencingProjects.get -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Graph.ProjectGraphNode>
-Microsoft.Build.Logging.BinaryLogger
-Microsoft.Build.Logging.BinaryLogger.BinaryLogger() -> void
-Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.get -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.CollectProjectImports.set -> void
-Microsoft.Build.Logging.BinaryLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.BinaryLogger.Parameters.get -> string
-Microsoft.Build.Logging.BinaryLogger.Parameters.set -> void
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.Embed = 1 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.None = 0 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode.ZipFile = 2 -> Microsoft.Build.Logging.BinaryLogger.ProjectImportsCollectionMode
-Microsoft.Build.Logging.BinaryLogger.Shutdown() -> void
-Microsoft.Build.Logging.BinaryLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.BinaryLogger.Verbosity.set -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource
-Microsoft.Build.Logging.BinaryLogReplayEventSource.BinaryLogReplayEventSource() -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath) -> void
-Microsoft.Build.Logging.BinaryLogReplayEventSource.Replay(string sourceFilePath, System.Threading.CancellationToken cancellationToken) -> void
-Microsoft.Build.Logging.BuildEventArgsReader
-Microsoft.Build.Logging.BuildEventArgsReader.BuildEventArgsReader(System.IO.BinaryReader binaryReader, int fileFormatVersion) -> void
-Microsoft.Build.Logging.BuildEventArgsReader.Dispose() -> void
-Microsoft.Build.Logging.BuildEventArgsReader.Read() -> Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Logging.ColorResetter
-Microsoft.Build.Logging.ColorSetter
-Microsoft.Build.Logging.ConfigurableForwardingLogger
-Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Logging.ConfigurableForwardingLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.ConfigurableForwardingLogger() -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.get -> int
-Microsoft.Build.Logging.ConfigurableForwardingLogger.NodeId.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.get -> string
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Parameters.set -> void
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ConfigurableForwardingLogger.Verbosity.set -> void
-Microsoft.Build.Logging.ConsoleLogger
-Microsoft.Build.Logging.ConsoleLogger.ApplyParameter(string parameterName, string parameterValue) -> void
-Microsoft.Build.Logging.ConsoleLogger.BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger() -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.Logging.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.Logging.WriteHandler write, Microsoft.Build.Logging.ColorSetter colorSet, Microsoft.Build.Logging.ColorResetter colorReset) -> void
-Microsoft.Build.Logging.ConsoleLogger.CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.Parameters.get -> string
-Microsoft.Build.Logging.ConsoleLogger.Parameters.set -> void
-Microsoft.Build.Logging.ConsoleLogger.ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.ShowSummary.get -> bool
-Microsoft.Build.Logging.ConsoleLogger.ShowSummary.set -> void
-Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.get -> bool
-Microsoft.Build.Logging.ConsoleLogger.SkipProjectStartedText.set -> void
-Microsoft.Build.Logging.ConsoleLogger.TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ConsoleLogger.Verbosity.set -> void
-Microsoft.Build.Logging.ConsoleLogger.WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
-Microsoft.Build.Logging.ConsoleLogger.WriteHandler.get -> Microsoft.Build.Logging.WriteHandler
-Microsoft.Build.Logging.ConsoleLogger.WriteHandler.set -> void
-Microsoft.Build.Logging.DistributedFileLogger
-Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Logging.DistributedFileLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.DistributedFileLogger() -> void
-Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Logging.DistributedFileLogger.NodeId.get -> int
-Microsoft.Build.Logging.DistributedFileLogger.NodeId.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.Parameters.get -> string
-Microsoft.Build.Logging.DistributedFileLogger.Parameters.set -> void
-Microsoft.Build.Logging.DistributedFileLogger.Shutdown() -> void
-Microsoft.Build.Logging.DistributedFileLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.DistributedFileLogger.Verbosity.set -> void
-Microsoft.Build.Logging.EventArgsDispatcher
-Microsoft.Build.Logging.EventArgsDispatcher.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.Dispatch(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
-Microsoft.Build.Logging.EventArgsDispatcher.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.EventArgsDispatcher() -> void
-Microsoft.Build.Logging.EventArgsDispatcher.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Logging.EventArgsDispatcher.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Logging.FileLogger
-Microsoft.Build.Logging.FileLogger.FileLogger() -> void
-Microsoft.Build.Logging.ForwardingLoggerRecord
-Microsoft.Build.Logging.ForwardingLoggerRecord.CentralLogger.get -> Microsoft.Build.Framework.ILogger
-Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerDescription.get -> Microsoft.Build.Logging.LoggerDescription
-Microsoft.Build.Logging.ForwardingLoggerRecord.ForwardingLoggerRecord(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.Logging.LoggerDescription forwardingLoggerDescription) -> void
-Microsoft.Build.Logging.LoggerDescription
-Microsoft.Build.Logging.LoggerDescription.CreateLogger() -> Microsoft.Build.Framework.ILogger
-Microsoft.Build.Logging.LoggerDescription.IsOptional.get -> bool
-Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.Logging.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity, bool isOptional) -> void
-Microsoft.Build.Logging.LoggerDescription.LoggerSwitchParameters.get -> string
-Microsoft.Build.Logging.LoggerDescription.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ProfilerLogger
-Microsoft.Build.Logging.ProfilerLogger.FileToLog.get -> string
-Microsoft.Build.Logging.ProfilerLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Logging.ProfilerLogger.Parameters.get -> string
-Microsoft.Build.Logging.ProfilerLogger.Parameters.set -> void
-Microsoft.Build.Logging.ProfilerLogger.ProfilerLogger(string fileToLog) -> void
-Microsoft.Build.Logging.ProfilerLogger.Shutdown() -> void
-Microsoft.Build.Logging.ProfilerLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Logging.ProfilerLogger.Verbosity.set -> void
-Microsoft.Build.Logging.WriteHandler
-Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider
-Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.ExternalProjectsProvider() -> void
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Collection.get -> Microsoft.Build.Evaluation.ProjectCollection
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.Construction.ProjectImportElement importingElement, Microsoft.Build.Construction.ProjectRootElement importedProject, int versionEvaluated, Microsoft.Build.Framework.SdkResult sdkResult, bool isImported) -> Microsoft.Build.Evaluation.ResolvedImport
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink link) -> Microsoft.Build.Construction.ProjectChooseElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink link) -> Microsoft.Build.Construction.ProjectExtensionsElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink link) -> Microsoft.Build.Construction.ProjectImportElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink link) -> Microsoft.Build.Construction.ProjectImportGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemDefinitionGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectItemDefinition
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink link) -> Microsoft.Build.Construction.ProjectItemElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink link) -> Microsoft.Build.Construction.ProjectItemGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectItemLink link, Microsoft.Build.Evaluation.Project project = null, Microsoft.Build.Construction.ProjectItemElement xml = null) -> Microsoft.Build.Evaluation.ProjectItem
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectLink link) -> Microsoft.Build.Evaluation.Project
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink link) -> Microsoft.Build.Construction.ProjectMetadataElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink link, object parent = null) -> Microsoft.Build.Evaluation.ProjectMetadata
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink link) -> Microsoft.Build.Construction.ProjectOnErrorElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink link) -> Microsoft.Build.Construction.ProjectOtherwiseElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink link) -> Microsoft.Build.Construction.ProjectOutputElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink link) -> Microsoft.Build.Construction.ProjectPropertyElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink link) -> Microsoft.Build.Construction.ProjectPropertyGroupElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink link, Microsoft.Build.Evaluation.Project project = null) -> Microsoft.Build.Evaluation.ProjectProperty
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink link) -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink link) -> Microsoft.Build.Construction.ProjectSdkElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink link) -> Microsoft.Build.Construction.ProjectTargetElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink link) -> Microsoft.Build.Construction.ProjectTaskElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskBodyElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink link) -> Microsoft.Build.Construction.ProjectUsingTaskParameterElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink link) -> Microsoft.Build.Construction.ProjectWhenElement
-Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Create(Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink link) -> Microsoft.Build.Construction.UsingTaskParameterGroupElement
-Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink.ProjectChooseElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink
-Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.ProjectElementContainerLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectElementLink.ProjectElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink.ProjectExtensionsElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink.ProjectImportElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink.ProjectImportGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink.ProjectItemDefinitionElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink.ProjectItemDefinitionGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink.ProjectItemDefinitionLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink.ProjectItemElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink.ProjectItemGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectItemLink
-Microsoft.Build.ObjectModelRemoting.ProjectItemLink.ProjectItemLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectLink
-Microsoft.Build.ObjectModelRemoting.ProjectLink.ProjectLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink.ProjectMetadataElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink
-Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.ProjectMetadataLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink.ProjectOnErrorElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink.ProjectOtherwiseElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink.ProjectOutputElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink.ProjectPropertyElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink.ProjectPropertyGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink
-Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.ProjectPropertyLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink.ProjectRootElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink.ProjectSdkElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink.ProjectTargetElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink.ProjectTaskElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink.ProjectUsingTaskBodyElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink.ProjectUsingTaskElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink.ProjectUsingTaskParameterElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink
-Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink.ProjectWhenElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink
-Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink.UsingTaskParameterGroupElementLink() -> void
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.LocalName.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.NamespaceURI.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.Value.get -> string
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink() -> void
-Microsoft.Build.ObjectModelRemoting.XmlAttributeLink.XmlAttributeLink(string localName, string value, string namespaceUri) -> void
-override Microsoft.Build.Construction.ElementLocation.Equals(object obj) -> bool
-override Microsoft.Build.Construction.ElementLocation.GetHashCode() -> int
-override Microsoft.Build.Construction.ElementLocation.ToString() -> string
-override Microsoft.Build.Construction.ProjectChooseElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectChooseElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectChooseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectExtensionsElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectExtensionsElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectExtensionsElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectItemElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectItemGroupElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectOtherwiseElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectOtherwiseElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectRootElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectRootElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectRootElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectTargetElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectTaskElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectUsingTaskBodyElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.get -> string
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.Condition.set -> void
-override Microsoft.Build.Construction.ProjectUsingTaskParameterElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.get -> string
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.Condition.set -> void
-override Microsoft.Build.Construction.UsingTaskParameterGroupElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Exceptions.BuildAbortedException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InternalLoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InvalidProjectFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Exceptions.InvalidProjectFileException.Message.get -> string
-override Microsoft.Build.Exceptions.InvalidToolsetDefinitionException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectItemGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectItemInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectMetadataInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectOnErrorInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectOnErrorInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectOnErrorInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectPropertyInstance.ToString() -> string
-override Microsoft.Build.Execution.ProjectTaskInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputItemInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Condition.get -> string
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.Location.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance.TaskParameterLocation.get -> Microsoft.Build.Construction.ElementLocation
-override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-override Microsoft.Build.Logging.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-override Microsoft.Build.Logging.FileLogger.Shutdown() -> void
-static Microsoft.Build.Construction.ProjectRootElement.Create() -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions projectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Create(System.Xml.XmlReader xmlReader, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.Open(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.ProjectRootElement.TryOpen(string path, Microsoft.Build.Evaluation.ProjectCollection projectCollection, bool? preserveFormatting) -> Microsoft.Build.Construction.ProjectRootElement
-static Microsoft.Build.Construction.SolutionFile.Parse(string solutionFile) -> Microsoft.Build.Construction.SolutionFile
-static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy) -> Microsoft.Build.Evaluation.Context.EvaluationContext
-static Microsoft.Build.Evaluation.Context.EvaluationContext.Create(Microsoft.Build.Evaluation.Context.EvaluationContext.SharingPolicy policy, Microsoft.Build.FileSystem.MSBuildFileSystemBase fileSystem) -> Microsoft.Build.Evaluation.Context.EvaluationContext
-static Microsoft.Build.Evaluation.Project.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.FromXmlReader(System.Xml.XmlReader reader, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Evaluation.Project
-static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem item) -> string
-static Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem item, string name) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) -> string
-static Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadatum) -> string
-static Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.DisplayVersion.get -> string
-static Microsoft.Build.Evaluation.ProjectCollection.Escape(string unescapedString) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.get -> Microsoft.Build.Evaluation.ProjectCollection
-static Microsoft.Build.Evaluation.ProjectCollection.Unescape(string escapedString) -> string
-static Microsoft.Build.Evaluation.ProjectCollection.Version.get -> System.Version
-static Microsoft.Build.Execution.BuildManager.DefaultBuildManager.get -> Microsoft.Build.Execution.BuildManager
-static Microsoft.Build.Execution.ProjectInstance.FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
-static Microsoft.Build.Execution.ProjectInstance.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) -> Microsoft.Build.Execution.ProjectInstance
-static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item, string name) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectItemInstance item, string name) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetMetadataValueEscaped(Microsoft.Build.Execution.ProjectMetadataInstance metadatum) -> string
-static Microsoft.Build.Execution.ProjectInstance.GetPropertyValueEscaped(Microsoft.Build.Execution.ProjectPropertyInstance property) -> string
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Execution.BuildResult buildResult) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(Microsoft.Build.Experimental.ProjectCache.ProxyTargets proxyTargets) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateCacheHit(System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Experimental.ProjectCache.PluginTargetResult> targetResults) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.CacheResult.IndicateNonCacheHit(Microsoft.Build.Experimental.ProjectCache.CacheResultType resultType) -> Microsoft.Build.Experimental.ProjectCache.CacheResult
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromAssemblyPath(string pluginAssemblyPath, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor.FromInstance(Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase pluginInstance, System.Collections.Generic.IReadOnlyDictionary<string, string> pluginSettings = null) -> Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor
-static Microsoft.Build.Globbing.CompositeGlob.Create(System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.IMSBuildGlob> globs) -> Microsoft.Build.Globbing.IMSBuildGlob
-static Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions.GetParsedGlobs(this Microsoft.Build.Globbing.IMSBuildGlob glob) -> System.Collections.Generic.IEnumerable<Microsoft.Build.Globbing.MSBuildGlob>
-static Microsoft.Build.Globbing.MSBuildGlob.Parse(string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
-static Microsoft.Build.Globbing.MSBuildGlob.Parse(string globRoot, string fileSpec) -> Microsoft.Build.Globbing.MSBuildGlob
-static Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.SetExternalProjectsProvider(Microsoft.Build.Evaluation.ProjectCollection collection, Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider link) -> void
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.Get(Microsoft.Build.Evaluation.ProjectCollection collection) -> Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLink(object obj) -> object
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.GetLocalProjects(Microsoft.Build.Evaluation.ProjectCollection collection, string projectFile = null) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.Evaluation.Project>
-static Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory.IsLocal(object obj) -> bool
-static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.AddInitialChild(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectElement child) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink.DeepClone(Microsoft.Build.Construction.ProjectElementContainer xml, Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) -> Microsoft.Build.Construction.ProjectElementContainer
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.CreateNewInstance(Microsoft.Build.Construction.ProjectElement xml, Microsoft.Build.Construction.ProjectRootElement owner) -> Microsoft.Build.Construction.ProjectElement
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeLocation(Microsoft.Build.Construction.ProjectElement xml, string attributeName) -> Microsoft.Build.Construction.ElementLocation
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributes(Microsoft.Build.Construction.ProjectElement xml) -> System.Collections.Generic.IReadOnlyCollection<Microsoft.Build.ObjectModelRemoting.XmlAttributeLink>
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetAttributeValue(Microsoft.Build.Construction.ProjectElement xml, string attributeName, bool nullIfNotExists) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml) -> bool
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.GetPureText(Microsoft.Build.Construction.ProjectElement xml) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.MarkDirty(Microsoft.Build.Construction.ProjectElement xml, string reason, string param) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetExpressedAsAttribute(Microsoft.Build.Construction.ProjectElement xml, bool value) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectElementLink.SetOrRemoveAttribute(Microsoft.Build.Construction.ProjectElement xml, string name, string value, bool clearAttributeCache, string reason, string param) -> void
-static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> string
-static Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink.GetParent(Microsoft.Build.Evaluation.ProjectMetadata metadata) -> object
-static Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink.GetEvaluatedValueEscaped(Microsoft.Build.Evaluation.ProjectProperty property) -> string
-virtual Microsoft.Build.Construction.ProjectElement.Condition.get -> string
-virtual Microsoft.Build.Construction.ProjectElement.Condition.set -> void
-virtual Microsoft.Build.Construction.ProjectElement.ConditionLocation.get -> Microsoft.Build.Construction.ElementLocation
-virtual Microsoft.Build.Construction.ProjectElement.CopyFrom(Microsoft.Build.Construction.ProjectElement element) -> void
-virtual Microsoft.Build.Construction.ProjectElementContainer.DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer element) -> void
-virtual Microsoft.Build.Evaluation.ProjectCollection.Dispose(bool disposing) -> void
-virtual Microsoft.Build.Execution.ProjectPropertyInstance.IsImmutable.get -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.DirectoryExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateDirectories(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFiles(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.EnumerateFileSystemEntries(string path, string searchPattern = "*", System.IO.SearchOption searchOption = System.IO.SearchOption.TopDirectoryOnly) -> System.Collections.Generic.IEnumerable<string>
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.FileOrDirectoryExists(string path) -> bool
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetAttributes(string path) -> System.IO.FileAttributes
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share) -> System.IO.Stream
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.GetLastWriteTimeUtc(string path) -> System.DateTime
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFile(string path) -> System.IO.TextReader
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllBytes(string path) -> byte[]
-virtual Microsoft.Build.FileSystem.MSBuildFileSystemBase.ReadFileAllText(string path) -> string
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) -> void
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.Logging.ConfigurableForwardingLogger.Shutdown() -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-virtual Microsoft.Build.Logging.ConsoleLogger.Shutdown() -> void
-virtual Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider.Disconnected(Microsoft.Build.Evaluation.ProjectCollection collection) -> void
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
deleted file mode 100644
index 05446d8617c..00000000000
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ /dev/null
@@ -1,24 +0,0 @@
-Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging, bool reuseProjectRootElementCache) -> void
-Microsoft.Build.Experimental.MSBuildClient
-Microsoft.Build.Experimental.MSBuildClient.Execute(System.Threading.CancellationToken cancellationToken) -> Microsoft.Build.Experimental.MSBuildClientExitResult
-Microsoft.Build.Experimental.MSBuildClient.MSBuildClient(string[] commandLine, string msbuildLocation) -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.get -> string
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.set -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitResult() -> void
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.get -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.set -> void
-Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.LaunchError = 3 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.ServerBusy = 1 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.Success = 0 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.UnableToConnect = 2 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.MSBuildClientExitType.Unexpected = 4 -> Microsoft.Build.Experimental.MSBuildClientExitType
-Microsoft.Build.Experimental.OutOfProcServerNode
-Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback
-Microsoft.Build.Experimental.OutOfProcServerNode.OutOfProcServerNode(Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback buildFunction) -> void
-Microsoft.Build.Experimental.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
-static Microsoft.Build.Experimental.MSBuildClient.ShutdownServer(System.Threading.CancellationToken cancellationToken) -> bool
-virtual Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalPropertiesContains(string key) -> bool
-virtual Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalPropertiesCount() -> int
-virtual Microsoft.Build.ObjectModelRemoting.ProjectLink.GlobalPropertiesEnumerable() -> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 6e06bc6e423..7b1b4f411e1 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1271,6 +1271,10 @@
     <value>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</value>
     <comment>{StrBegin="MSB4067: "}</comment>
   </data>
+  <data name="PropertyOutsidePropertyGroupInTarget" xml:space="preserve" Condition="$([MSBuild]::AreFeaturesEnabled('17.6'))">
+    <value>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</value>
+    <comment>{StrBegin="MSB4067: "}</comment>
+  </data>
   <data name="InvalidChildElementDueToDuplication" xml:space="preserve">
     <value>MSB4173: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is invalid because a child element with that name already exists</value>
     <comment>{StrBegin="MSB4173: "}</comment>
@@ -1306,6 +1310,10 @@
   <data name="SDKResolverFailed" xml:space="preserve">
     <value>The SDK resolver "{0}" failed while attempting to resolve the SDK "{1}". Exception: "{2}"</value>
   </data>
+  <data name="FailedToResolveSDK" xml:space="preserve">
+    <value>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</value>
+  </data>
   <data name="CouldNotRunNuGetSdkResolver" xml:space="preserve">
     <value>The NuGet-based SDK resolver failed to run because NuGet assemblies could not be located.  Check your installation of MSBuild or set the environment variable "{0}" to the folder that contains the required NuGet assemblies. {1}</value>
   </data>
@@ -1963,4 +1971,10 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is a file path. {1} is a comma-separated list of target names
     </comment>
   </data>
+   <data name="DefaultSDKResolverError" xml:space="preserve">
+    <value>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</value>
+  </data>
+  <data name="SDKResolverReturnedNull" xml:space="preserve">
+    <value>SDK resolver "{0}" returned null.</value>
+  </data>
 </root>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index fc31029e3e0..0fd2a55f4a1 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Došlo k pokusu o vytvoření více přepsání stejné úlohy: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: Při zápisu do výstupních souborů mezipaměti pro výsledky v cestě {0} byla zjištěna chyba: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Na pozici {1} podmínky {0} je neočekávaná mezera. Nezapomněli jste ji odebrat?</target>
@@ -328,6 +340,11 @@
         <target state="translated">Počáteční hodnota vlastnosti: $({0})={1} Zdroj: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: Zakázání uzlu inproc způsobí snížení výkonu při používání modulů plug-in mezipaměti projektu, které vysílají žádosti o sestavení proxy serveru.</target>
@@ -343,6 +360,11 @@
         <target state="translated">Překladač sady SDK {0} selhal při pokusu o překlad sady SDK {1}. Výjimka: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Projekt {0} přeskočil omezení izolace grafu v odkazovaném projektu {1}.</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpoznán.</target>
+        <target state="needs-review-translation">MSB4067: Element &lt;{0}&gt; pod elementem &lt;{1}&gt; nebyl rozpoznán.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 1bfb8341b04..49aab4ca53c 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Es wurde versucht, mehrere Außerkraftsetzungen derselben Aufgabe zu erstellen: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: Beim Schreiben der Cachedatei für Ausgabeergebnisse im Pfad "{0}" wurde ein Fehler festgestellt: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Unerwartetes Leerzeichen an Position "{1}" der Bedingung "{0}". Haben Sie vergessen, ein Leerzeichen zu entfernen?</target>
@@ -328,6 +340,11 @@
         <target state="translated">Anfangswert der Eigenschaft: $({0})="{1}", Quelle: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: Das Deaktivieren des In-Process-Knotens führt zu Leistungseinbußen bei der Verwendung von Projektcache-Plug-Ins, die Proxybuildanforderungen ausgeben.</target>
@@ -343,6 +360,11 @@
         <target state="translated">Ausfall beim Versuch des SDK-Resolver "{0}", das SDK "{1}" aufzulösen. Ausnahme: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: Das Projekt "{0}" hat Graphisolationseinschränkungen für das referenzierte Projekt "{1}" übersprungen.</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: Das &lt;{0}&gt;-Element unterhalb des &lt;{1}&gt;-Elements ist unbekannt.</target>
+        <target state="needs-review-translation">MSB4067: Das &lt;{0}&gt;-Element unterhalb des &lt;{1}&gt;-Elements ist unbekannt.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 9381108a7e8..3e8d9e420ce 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Se intentaron crear varias invalidaciones de la misma tarea: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: Error al escribir el archivo de caché de resultados de salida en la ruta de acceso "{0}": {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Espacio inesperado en la posición "{1}" de la condición "{0}". ¿Olvidó quitar un espacio?</target>
@@ -328,6 +340,11 @@
         <target state="translated">Valor inicial de la propiedad: $({0})="{1}" Origen: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: Al deshabilitar el nodo InProc, se degrada el rendimiento cuando use los complementos de caché de proyectos que emiten solicitudes de compilación de proxy.</target>
@@ -343,6 +360,11 @@
         <target state="translated">Error en el solucionador del SDK "{0}" al intentar resolver el SDK "{1}". Excepción: "{2}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: El proyecto "{0}" ha omitido las restricciones de aislamiento de gráficos en el proyecto "{1}" al que se hace referencia.</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: No se reconoce el subelemento &lt;{0}&gt; del elemento &lt;{1}&gt;.</target>
+        <target state="needs-review-translation">MSB4067: No se reconoce el subelemento &lt;{0}&gt; del elemento &lt;{1}&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 2b690c854dd..369cad1fc61 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Tentative de création de plusieurs remplacements de la même tâche : {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: L'écriture du fichier cache des résultats de sortie dans le chemin "{0}" a rencontré une erreur : {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: espace inattendu à la position "{1}" de la condition "{0}". Avez-vous oublié de supprimer un espace ?</target>
@@ -328,6 +340,11 @@
         <target state="translated">Valeur initiale de la propriété : $({0})="{1}" Source : {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: la désactivation du nœud inproc entraîne une détérioration des performances lors de l’utilisation de plug-ins de cache de projet qui émettent des requêtes de build proxy.</target>
@@ -343,6 +360,11 @@
         <target state="translated">Échec du programme de résolution SDK «{0}» lors de la tentative de résolution du kit de développement logiciel (SDK) «{1}». Exception : "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: le projet "{0}" a ignoré les contraintes d'isolement de graphe dans le projet référencé "{1}"</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: L'élément "{0}" situé sous l'élément &lt;{1}&gt; n'est pas reconnu.</target>
+        <target state="needs-review-translation">MSB4067: L'élément "{0}" situé sous l'élément &lt;{1}&gt; n'est pas reconnu.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 3c0e4bd0080..16c46738aa3 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: tentativo di creare più sostituzioni della stessa attività: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: durante la scrittura del file della cache dei risultati di output nel percorso "{0}" è stato rilevato un errore: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: spazio imprevisto alla posizione "{1}" della condizione "{0}". Si è dimenticato di rimuovere uno spazio?</target>
@@ -328,6 +340,11 @@
         <target state="translated">Valore iniziale della proprietà: $({0})="{1}". Origine: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: la disabilitazione del nodo InProc porta a una riduzione del livello delle prestazioni quando si usano plug-in della cache del progetto che emettono richieste di compilazione proxy.</target>
@@ -343,6 +360,11 @@
         <target state="translated">Il sistema di risoluzione SDK "{0}" non è riuscito durante il tentativo di risolvere l'SDK "{1}". Eccezione: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: il progetto "{0}" ha ignorato i vincoli di isolamento del grafico nel progetto di riferimento "{1}"</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non riconosciuto.</target>
+        <target state="needs-review-translation">MSB4067: elemento &lt;{0}&gt; sotto l'elemento &lt;{1}&gt; non riconosciuto.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index bedf8d61abf..2767d3b459d 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: 同じタスクの複数のオーバーライドを作成しようとしました: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: パス "{0}" の出力結果キャッシュ ファイルに書き込む処理でエラーが発生しました: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: 条件 "{0}" の位置 "{1}" に予期しないスペースがあります。スペースを削除したか確認してください。</target>
@@ -328,6 +340,11 @@
         <target state="translated">プロパティの初期値: $({0})="{1}" ソース: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: プロキシ・ビルド要求を出すプロジェクト キャッシュ プラグインを使用する場合、InProc ノードを無効にするとパフォーマンスが低下します。</target>
@@ -343,6 +360,11 @@
         <target state="translated">SDK "{1}" を解決しようとしているときに、SDK リゾルバー "{0}" に失敗しました。例外: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: プロジェクト "{0}" は、参照先のプロジェクト "{1}" で、グラフの分離制約をスキップしました</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: 要素 &lt;{1}&gt; の下の要素 &lt;{0}&gt; は認識されていません。</target>
+        <target state="needs-review-translation">MSB4067: 要素 &lt;{1}&gt; の下の要素 &lt;{0}&gt; は認識されていません。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 72b26912e06..a8b9e95d0a2 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: 동일한 작업의 여러 재정의를 만들려고 했습니다. {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: "{0}" 경로에서 출력 결과 캐시 파일을 쓰는 중 오류가 발생했습니다. {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: "{0}" 조건의 "{1}" 위치에 예기치 않은 공백이 있습니다. 공백을 제거했는지 확인하세요.</target>
@@ -328,6 +340,11 @@
         <target state="translated">속성 초기 값: $({0})="{1}" 소스: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: 프록시 빌드 요청을 내보내는 프로젝트 캐시 플러그 인을 사용할 때 inproc 노드를 사용하지 않도록 설정하면 성능이 저하됩니다.</target>
@@ -343,6 +360,11 @@
         <target state="translated">SDK "{1}"을(를) 확인하는 동안 SDK 확인자 "{0}"이(가) 실패했습니다. 예외: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 프로젝트 "{0}"에서 참조된 프로젝트 "{1}"의 그래프 격리 제약 조건을 건너뛰었습니다.</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: &lt;{1}&gt; 요소 아래의 &lt;{0}&gt; 요소를 인식할 수 없습니다.</target>
+        <target state="needs-review-translation">MSB4067: &lt;{1}&gt; 요소 아래의 &lt;{0}&gt; 요소를 인식할 수 없습니다.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index ea709e424e9..dd63fc75115 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Podjęto próbę utworzenia wielu zastąpień tego samego zadania: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: Podczas zapisywania pliku wyjściowej pamięci podręcznej wyników w ścieżce „{0}” wystąpił błąd: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: Nieoczekiwana spacja na pozycji „{1}” warunku „{0}”. Czy zapomniano o usunięciu spacji?</target>
@@ -328,6 +340,11 @@
         <target state="translated">Wartość początkowa właściwości: $({0})=„{1}” Źródło: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: wyłączenie węzła InProc prowadzi do obniżenia wydajności, gdy używane są wtyczki pamięci podręcznej projektu, które emitują żądania kompilowania serwera proxy.</target>
@@ -343,6 +360,11 @@
         <target state="translated">Wystąpił błąd programu do rozpoznawania zestawu SDK „{0}” podczas próby rozpoznania zestawu SDK „{1}”. Wyjątek: „{2}”</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: W przypadku projektu „{0}” pominięto ograniczenia izolacji grafu dla przywoływanego projektu „{1}”</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: Element &lt;{0}&gt; znajdujący się pod elementem &lt;{1}&gt; nie został rozpoznany.</target>
+        <target state="needs-review-translation">MSB4067: Element &lt;{0}&gt; znajdujący się pod elementem &lt;{1}&gt; nie został rozpoznany.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 12559cec995..54b6e04475e 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: tentativa de criar várias substituições da mesma tarefa: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: a gravação do arquivo de cache do resultado de saída no caminho "{0}" encontrou um erro: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: espaço inesperado na posição "{1}" da condição "{0}". Você esqueceu de remover um espaço?</target>
@@ -328,6 +340,11 @@
         <target state="translated">Valor inicial da propriedade: $({0})="{1}" Origem: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: desativar o nó inproc leva à degradação do desempenho ao usar plug-ins de cache de projeto que emitem solicitações de construção de proxy.</target>
@@ -343,6 +360,11 @@
         <target state="translated">O resolvedor do SDK "{0}" falhou ao tentar resolver o SDK "{1}". Exceção: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: o projeto "{0}" ignorou as restrições de isolamento do gráfico no projeto referenciado "{1}"</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; não é reconhecido.</target>
+        <target state="needs-review-translation">MSB4067: O elemento &lt;{0}&gt; abaixo do elemento &lt;{1}&gt; não é reconhecido.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 6ca8431952b..75cd9f7d0c3 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: попытка создать несколько переопределений одной задачи: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: произошла ошибка при записи выходного файла кэша результатов в пути "{0}": {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: неожиданный пробел в позиции "{1}" условия "{0}". Вы забыли удалить пробел?</target>
@@ -328,6 +340,11 @@
         <target state="translated">Начальное значение свойства: $({0})="{1}" Источник: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: Отключение внутрипроцессного узла приводит к замедлению при использовании плагинов кэша проекта, которые создают запросы на сборку прокси-сервера.</target>
@@ -343,6 +360,11 @@
         <target state="translated">Сбой сопоставителя SDK "{0}" при попытке сопоставить пакет SDK "{1}". Исключение: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: проект "{0}" пропустил ограничения изоляции графа в проекте "{1}", на который указывает ссылка.</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: неопознанный элемент &lt;{0}&gt; в элементе &lt;{1}&gt;.</target>
+        <target state="needs-review-translation">MSB4067: неопознанный элемент &lt;{0}&gt; в элементе &lt;{1}&gt;.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 1917bb7e6ce..83a86862dee 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: Aynı {0} görevi için birden çok geçersiz kılma işlemi oluşturulmaya çalışıldı</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: Çıkış sonucu önbellek dosyası "{0}" yoluna yazılırken bir hatayla karşılaşıldı: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: "{0}" koşulunun "{1}" konumunda beklenmeyen boşluk var. Boşluğu kaldırmayı unutmuş olabilirsiniz.</target>
@@ -328,6 +340,11 @@
         <target state="translated">Özellik başlangıç değeri: $({0})="{1}" Kaynak: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: InProc düğümünün devre dışı bırakılması, ara sunucu oluşturma istekleri gönderen proje önbelleği eklentileri kullanılırken performans düşüşüne yol açar.</target>
@@ -343,6 +360,11 @@
         <target state="translated">"{0}" SDK çözümleyicisi, "{1}" SDK'sını çözümlemeye çalışırken başarısız oldu. İstisna: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: "{0}" projesi, başvurulan "{1}" projesindeki graf yalıtımı kısıtlamalarını atladı</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: &lt;{1}&gt; öğesinin altındaki &lt;{0}&gt; öğesi tanınmıyor.</target>
+        <target state="needs-review-translation">MSB4067: &lt;{1}&gt; öğesinin altındaki &lt;{0}&gt; öğesi tanınmıyor.</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index 082781250dd..9be6ea491ba 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: 已尝试创建同一任务的多个重写: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: 从路径“{0}”写入输出结果缓存文件时遇到错误: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: 在条件“{0}”的位置“{1}”处出现意外空格。是否忘记了删除空格?</target>
@@ -328,6 +340,11 @@
         <target state="translated">属性初始值: $({0})=“{1}”，源: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: 使用发出代理构建请求的项目缓存插件时，禁用 inproc 节点会导致性能下降。</target>
@@ -343,6 +360,11 @@
         <target state="translated">尝试解析 SDK "{1}" 时，SDK 解析程序 "{0}" 失败。异常: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 项目“{0}”已跳过所引用的项目“{1}”上的图形隔离约束</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: 无法识别元素 &lt;{1}&gt; 下面的元素 &lt;{0}&gt;。</target>
+        <target state="needs-review-translation">MSB4067: 无法识别元素 &lt;{1}&gt; 下面的元素 &lt;{0}&gt;。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 87e681bf25b..70f6dd3f097 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -92,6 +92,11 @@
         <note>{StrBegin="MSB4006: "}UE: This message is shown when the build engine detects a target referenced in a circular manner -- a project cannot
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
+      <trans-unit id="DefaultSDKResolverError">
+        <source>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</source>
+        <target state="new">MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="DuplicateOverrideUsingTaskElement">
         <source>MSB4275: Attempted to create multiple overrides of the same task: {0}</source>
         <target state="translated">MSB4275: 已嘗試建立相同工作的多個覆寫: {0}</target>
@@ -122,6 +127,13 @@
         <target state="translated">MSB4258: 在路徑 "{0}" 中寫入輸出結果快取檔案發生錯誤: {1}</target>
         <note />
       </trans-unit>
+      <trans-unit id="FailedToResolveSDK">
+        <source>Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</source>
+        <target state="new">Could not resolve SDK "{0}". Exactly one of the probing messages below indicates why we could not resolve the SDK. Investigate and resolve that message to correctly specify the SDK.
+  {1}</target>
+        <note />
+      </trans-unit>
       <trans-unit id="IllFormedPropertySpaceInCondition">
         <source>MSB4259: Unexpected space at position "{1}" of condition "{0}". Did you forget to remove a space?</source>
         <target state="translated">MSB4259: 條件 "{0}" 的位置 "{1}" 出現非預期的空格。忘記移除空格了嗎?</target>
@@ -328,6 +340,11 @@
         <target state="translated">屬性初始值: $({0})="{1}" 來源: {2}</target>
         <note />
       </trans-unit>
+      <trans-unit id="PropertyOutsidePropertyGroupInTarget">
+        <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</source>
+        <target state="new">MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</target>
+        <note>{StrBegin="MSB4067: "}</note>
+      </trans-unit>
       <trans-unit id="ProxyRequestNotScheduledOnInprocNode">
         <source>MSB4274: Disabling the inproc node leads to performance degradation when using project cache plugins that emit proxy build requests.</source>
         <target state="translated">MSB4274: 停用 inproc 節點會在使用可發出 proxy 組建要求的專案快取外掛程式時，導致效能降低。</target>
@@ -343,6 +360,11 @@
         <target state="translated">SDK 解析程式 "{0}" 在嘗試解析 SDK "{1}" 時失敗。例外狀況: "{2}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="SDKResolverReturnedNull">
+        <source>SDK resolver "{0}" returned null.</source>
+        <target state="new">SDK resolver "{0}" returned null.</target>
+        <note />
+      </trans-unit>
       <trans-unit id="SkippedConstraintsOnRequest">
         <source>MSB4260: Project "{0}" skipped graph isolation constraints on referenced project "{1}"</source>
         <target state="translated">MSB4260: 專案 "{0}" 已跳過參考專案 "{1}" 上的圖形隔離條件約束</target>
@@ -1819,7 +1841,7 @@
       </trans-unit>
       <trans-unit id="UnrecognizedChildElement">
         <source>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</source>
-        <target state="translated">MSB4067: 無法辨認項目 &lt;{1}&gt; 下的項目 &lt;{0}&gt;。</target>
+        <target state="needs-review-translation">MSB4067: 無法辨認項目 &lt;{1}&gt; 下的項目 &lt;{0}&gt;。</target>
         <note>{StrBegin="MSB4067: "}</note>
       </trans-unit>
       <trans-unit id="InvalidChildElementDueToDuplication">
diff --git a/src/Build/Utilities/SimpleVersion.cs b/src/Build/Utilities/SimpleVersion.cs
index 052add40c0a..dd665af000e 100644
--- a/src/Build/Utilities/SimpleVersion.cs
+++ b/src/Build/Utilities/SimpleVersion.cs
@@ -22,9 +22,11 @@ namespace Microsoft.Build.Utilities
     ///
     /// Treats unspecified components as 0 (e.g. x == x.0 == x.0.0 == x.0.0.0).
     ///
-    /// Unlike System.Version, does not tolerate whitespace, and '+' is ignored as
-    /// semver metadata as described above, not tolerated as positive sign of integer
-    /// component.
+    /// Ignores leading and trailing whitespace, but does not tolerate whitespace
+    /// between components, unlike System.Version.
+    /// 
+    /// Also unlike System.Version, '+' is ignored as semver metadata as described
+    /// above, not tolerated as positive sign of integer component.
     /// </summary>
     /// <remarks>
     /// Tolerating leading 'v' allows using $(TargetFrameworkVersion) directly.
@@ -127,22 +129,23 @@ public static SimpleVersion Parse(string input)
 
         private static ReadOnlySpan<char> RemoveTrivia(string input)
         {
-            int startIndex = 0;
-            int endIndex = input.Length;
+            // Ignore leading/trailing whitespace in input.
+            ReadOnlySpan<char> span = input.AsSpan().Trim();
 
-            if (input.Length > 0 && (input[0] == 'v' || input[0] == 'V'))
+            // Ignore a leading "v".
+            if (span.Length > 0 && (span[0] == 'v' || span[0] == 'V'))
             {
-                startIndex = 1;
+                span = span.Slice(1);
             }
 
-            int separatorIndex = input.IndexOfAny(s_semverSeparators, startIndex);
-
+            // Ignore semver separator and anything after.
+            int separatorIndex = span.IndexOfAny(s_semverSeparators);
             if (separatorIndex >= 0)
             {
-                endIndex = separatorIndex;
+                span = span.Slice(0, separatorIndex);
             }
 
-            return input.AsSpan().Slice(startIndex, endIndex - startIndex);
+            return span;
         }
 
         private static bool ParseComponent(ref ReadOnlySpan<char> span, out int value)
diff --git a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
index 58ad5723984..0f73cd9c6d9 100644
--- a/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
+++ b/src/Deprecated/Conversion/Microsoft.Build.Conversion.csproj
@@ -9,6 +9,7 @@
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
     <Nullable>disable</Nullable>
+    <EnablePackageValidation>true</EnablePackageValidation>
   </PropertyGroup>
   <ItemGroup>
     <!-- Source Files -->
diff --git a/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Shipped.txt b/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index cc40354b757..00000000000
--- a/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-Microsoft.Build.Conversion.ProjectFileConverter
-Microsoft.Build.Conversion.ProjectFileConverter.ConversionSkippedBecauseProjectAlreadyConverted.get -> bool
-Microsoft.Build.Conversion.ProjectFileConverter.ConversionWarnings.get -> string[]
-Microsoft.Build.Conversion.ProjectFileConverter.Convert() -> void
-Microsoft.Build.Conversion.ProjectFileConverter.Convert(Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
-Microsoft.Build.Conversion.ProjectFileConverter.Convert(string msbuildBinPath) -> void
-Microsoft.Build.Conversion.ProjectFileConverter.ConvertInMemory() -> Microsoft.Build.Construction.ProjectRootElement
-Microsoft.Build.Conversion.ProjectFileConverter.ConvertInMemory(Microsoft.Build.BuildEngine.Engine engine) -> Microsoft.Build.BuildEngine.Project
-Microsoft.Build.Conversion.ProjectFileConverter.ConvertInMemory(Microsoft.Build.BuildEngine.Engine engine, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> Microsoft.Build.BuildEngine.Project
-Microsoft.Build.Conversion.ProjectFileConverter.FSharpSpecificConversions(bool actuallyMakeChanges) -> bool
-Microsoft.Build.Conversion.ProjectFileConverter.IsMinorUpgrade.get -> bool
-Microsoft.Build.Conversion.ProjectFileConverter.IsMinorUpgrade.set -> void
-Microsoft.Build.Conversion.ProjectFileConverter.IsUserFile.get -> bool
-Microsoft.Build.Conversion.ProjectFileConverter.IsUserFile.set -> void
-Microsoft.Build.Conversion.ProjectFileConverter.NewProjectFile.get -> string
-Microsoft.Build.Conversion.ProjectFileConverter.NewProjectFile.set -> void
-Microsoft.Build.Conversion.ProjectFileConverter.OldProjectFile.get -> string
-Microsoft.Build.Conversion.ProjectFileConverter.OldProjectFile.set -> void
-Microsoft.Build.Conversion.ProjectFileConverter.ProjectFileConverter() -> void
-Microsoft.Build.Conversion.ProjectFileConverter.SolutionFile.get -> string
-Microsoft.Build.Conversion.ProjectFileConverter.SolutionFile.set -> void
\ No newline at end of file
diff --git a/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Deprecated/Conversion/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
index 051c7517343..2b627bf1f99 100644
--- a/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
+++ b/src/Deprecated/Engine/Microsoft.Build.Engine.csproj
@@ -14,6 +14,7 @@
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <NoWarn>$(NoWarn);1570;1572;1573;1587</NoWarn>
     <Nullable>disable</Nullable>
+    <EnablePackageValidation>true</EnablePackageValidation>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Shipped.txt b/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index 7abb6ba25e8..00000000000
--- a/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,419 +0,0 @@
-Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.BuildItem.BuildItem(string itemName, Microsoft.Build.Framework.ITaskItem taskItem) -> void
-Microsoft.Build.BuildEngine.BuildItem.BuildItem(string itemName, string itemInclude) -> void
-Microsoft.Build.BuildEngine.BuildItem.Clone() -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.BuildItem.Condition.get -> string
-Microsoft.Build.BuildEngine.BuildItem.Condition.set -> void
-Microsoft.Build.BuildEngine.BuildItem.CopyCustomMetadataTo(Microsoft.Build.BuildEngine.BuildItem destinationItem) -> void
-Microsoft.Build.BuildEngine.BuildItem.CustomMetadataCount.get -> int
-Microsoft.Build.BuildEngine.BuildItem.CustomMetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.BuildEngine.BuildItem.Exclude.get -> string
-Microsoft.Build.BuildEngine.BuildItem.Exclude.set -> void
-Microsoft.Build.BuildEngine.BuildItem.FinalItemSpec.get -> string
-Microsoft.Build.BuildEngine.BuildItem.GetEvaluatedMetadata(string metadataName) -> string
-Microsoft.Build.BuildEngine.BuildItem.GetMetadata(string metadataName) -> string
-Microsoft.Build.BuildEngine.BuildItem.HasMetadata(string metadataName) -> bool
-Microsoft.Build.BuildEngine.BuildItem.Include.get -> string
-Microsoft.Build.BuildEngine.BuildItem.Include.set -> void
-Microsoft.Build.BuildEngine.BuildItem.IsImported.get -> bool
-Microsoft.Build.BuildEngine.BuildItem.MetadataCount.get -> int
-Microsoft.Build.BuildEngine.BuildItem.MetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.BuildEngine.BuildItem.Name.get -> string
-Microsoft.Build.BuildEngine.BuildItem.Name.set -> void
-Microsoft.Build.BuildEngine.BuildItem.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.BuildEngine.BuildItem.SetMetadata(string metadataName, string metadataValue) -> void
-Microsoft.Build.BuildEngine.BuildItem.SetMetadata(string metadataName, string metadataValue, bool treatMetadataValueAsLiteral) -> void
-Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.BuildItemGroup.AddNewItem(string itemName, string itemInclude) -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.BuildItemGroup.AddNewItem(string itemName, string itemInclude, bool treatItemIncludeAsLiteral) -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.BuildItemGroup.BuildItemGroup() -> void
-Microsoft.Build.BuildEngine.BuildItemGroup.Clear() -> void
-Microsoft.Build.BuildEngine.BuildItemGroup.Clone(bool deepClone) -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.BuildItemGroup.Condition.get -> string
-Microsoft.Build.BuildEngine.BuildItemGroup.Condition.set -> void
-Microsoft.Build.BuildEngine.BuildItemGroup.Count.get -> int
-Microsoft.Build.BuildEngine.BuildItemGroup.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.BuildItemGroup.IsImported.get -> bool
-Microsoft.Build.BuildEngine.BuildItemGroup.RemoveItem(Microsoft.Build.BuildEngine.BuildItem itemToRemove) -> void
-Microsoft.Build.BuildEngine.BuildItemGroup.RemoveItemAt(int index) -> void
-Microsoft.Build.BuildEngine.BuildItemGroup.this[int index].get -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.BuildItemGroup.ToArray() -> Microsoft.Build.BuildEngine.BuildItem[]
-Microsoft.Build.BuildEngine.BuildItemGroupCollection
-Microsoft.Build.BuildEngine.BuildItemGroupCollection.CopyTo(System.Array array, int index) -> void
-Microsoft.Build.BuildEngine.BuildItemGroupCollection.Count.get -> int
-Microsoft.Build.BuildEngine.BuildItemGroupCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.BuildItemGroupCollection.IsSynchronized.get -> bool
-Microsoft.Build.BuildEngine.BuildItemGroupCollection.SyncRoot.get -> object
-Microsoft.Build.BuildEngine.BuildProperty
-Microsoft.Build.BuildEngine.BuildProperty.BuildProperty(string propertyName, string propertyValue) -> void
-Microsoft.Build.BuildEngine.BuildProperty.Clone(bool deepClone) -> Microsoft.Build.BuildEngine.BuildProperty
-Microsoft.Build.BuildEngine.BuildProperty.Condition.get -> string
-Microsoft.Build.BuildEngine.BuildProperty.Condition.set -> void
-Microsoft.Build.BuildEngine.BuildProperty.FinalValue.get -> string
-Microsoft.Build.BuildEngine.BuildProperty.IsImported.get -> bool
-Microsoft.Build.BuildEngine.BuildProperty.Name.get -> string
-Microsoft.Build.BuildEngine.BuildProperty.Value.get -> string
-Microsoft.Build.BuildEngine.BuildProperty.Value.set -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.BuildPropertyGroup.AddNewProperty(string propertyName, string propertyValue) -> Microsoft.Build.BuildEngine.BuildProperty
-Microsoft.Build.BuildEngine.BuildPropertyGroup.AddNewProperty(string propertyName, string propertyValue, bool treatPropertyValueAsLiteral) -> Microsoft.Build.BuildEngine.BuildProperty
-Microsoft.Build.BuildEngine.BuildPropertyGroup.BuildPropertyGroup() -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.BuildPropertyGroup(Microsoft.Build.BuildEngine.Project parentProject) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.Clear() -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.Clone(bool deepClone) -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.BuildPropertyGroup.Condition.get -> string
-Microsoft.Build.BuildEngine.BuildPropertyGroup.Condition.set -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.Count.get -> int
-Microsoft.Build.BuildEngine.BuildPropertyGroup.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.BuildPropertyGroup.IsImported.get -> bool
-Microsoft.Build.BuildEngine.BuildPropertyGroup.RemoveProperty(Microsoft.Build.BuildEngine.BuildProperty property) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.RemoveProperty(string propertyName) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.SetImportedPropertyGroupCondition(string condition) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.SetProperty(string propertyName, string propertyValue) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.SetProperty(string propertyName, string propertyValue, bool treatPropertyValueAsLiteral) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroup.this[string propertyName].get -> Microsoft.Build.BuildEngine.BuildProperty
-Microsoft.Build.BuildEngine.BuildPropertyGroup.this[string propertyName].set -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.CopyTo(System.Array array, int index) -> void
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.Count.get -> int
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.IsSynchronized.get -> bool
-Microsoft.Build.BuildEngine.BuildPropertyGroupCollection.SyncRoot.get -> object
-Microsoft.Build.BuildEngine.BuildSettings
-Microsoft.Build.BuildEngine.BuildSettings.DoNotResetPreviouslyBuiltTargets = 1 -> Microsoft.Build.BuildEngine.BuildSettings
-Microsoft.Build.BuildEngine.BuildSettings.None = 0 -> Microsoft.Build.BuildEngine.BuildSettings
-Microsoft.Build.BuildEngine.BuildTask
-Microsoft.Build.BuildEngine.BuildTask.AddOutputItem(string taskParameter, string itemName) -> void
-Microsoft.Build.BuildEngine.BuildTask.AddOutputProperty(string taskParameter, string propertyName) -> void
-Microsoft.Build.BuildEngine.BuildTask.Condition.get -> string
-Microsoft.Build.BuildEngine.BuildTask.Condition.set -> void
-Microsoft.Build.BuildEngine.BuildTask.ContinueOnError.get -> bool
-Microsoft.Build.BuildEngine.BuildTask.ContinueOnError.set -> void
-Microsoft.Build.BuildEngine.BuildTask.Execute() -> bool
-Microsoft.Build.BuildEngine.BuildTask.GetParameterNames() -> string[]
-Microsoft.Build.BuildEngine.BuildTask.GetParameterValue(string attributeName) -> string
-Microsoft.Build.BuildEngine.BuildTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.BuildEngine.BuildTask.HostObject.set -> void
-Microsoft.Build.BuildEngine.BuildTask.Name.get -> string
-Microsoft.Build.BuildEngine.BuildTask.SetParameterValue(string parameterName, string parameterValue) -> void
-Microsoft.Build.BuildEngine.BuildTask.SetParameterValue(string parameterName, string parameterValue, bool treatParameterValueAsLiteral) -> void
-Microsoft.Build.BuildEngine.BuildTask.Type.get -> System.Type
-Microsoft.Build.BuildEngine.ColorResetter
-Microsoft.Build.BuildEngine.ColorSetter
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.BuildEventRedirector.set -> void
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.ConfigurableForwardingLogger() -> void
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.NodeId.get -> int
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.NodeId.set -> void
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Parameters.get -> string
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Parameters.set -> void
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Verbosity.set -> void
-Microsoft.Build.BuildEngine.ConsoleLogger
-Microsoft.Build.BuildEngine.ConsoleLogger.ApplyParameter(string parameterName, string parameterValue) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.BuildFinishedHandler(object sender, Microsoft.Build.Framework.BuildFinishedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.BuildStartedHandler(object sender, Microsoft.Build.Framework.BuildStartedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ConsoleLogger() -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ConsoleLogger(Microsoft.Build.Framework.LoggerVerbosity verbosity, Microsoft.Build.BuildEngine.WriteHandler write, Microsoft.Build.BuildEngine.ColorSetter colorSet, Microsoft.Build.BuildEngine.ColorResetter colorReset) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.CustomEventHandler(object sender, Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ErrorHandler(object sender, Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.MessageHandler(object sender, Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.Parameters.get -> string
-Microsoft.Build.BuildEngine.ConsoleLogger.Parameters.set -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ProjectFinishedHandler(object sender, Microsoft.Build.Framework.ProjectFinishedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ProjectStartedHandler(object sender, Microsoft.Build.Framework.ProjectStartedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.ShowSummary.get -> bool
-Microsoft.Build.BuildEngine.ConsoleLogger.ShowSummary.set -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.SkipProjectStartedText.get -> bool
-Microsoft.Build.BuildEngine.ConsoleLogger.SkipProjectStartedText.set -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.TargetFinishedHandler(object sender, Microsoft.Build.Framework.TargetFinishedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.TargetStartedHandler(object sender, Microsoft.Build.Framework.TargetStartedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.TaskFinishedHandler(object sender, Microsoft.Build.Framework.TaskFinishedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.TaskStartedHandler(object sender, Microsoft.Build.Framework.TaskStartedEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.BuildEngine.ConsoleLogger.Verbosity.set -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.WarningHandler(object sender, Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
-Microsoft.Build.BuildEngine.ConsoleLogger.WriteHandler.get -> Microsoft.Build.BuildEngine.WriteHandler
-Microsoft.Build.BuildEngine.ConsoleLogger.WriteHandler.set -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger
-Microsoft.Build.BuildEngine.DistributedFileLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.BuildEngine.DistributedFileLogger.BuildEventRedirector.set -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.DistributedFileLogger() -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.NodeId.get -> int
-Microsoft.Build.BuildEngine.DistributedFileLogger.NodeId.set -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.Parameters.get -> string
-Microsoft.Build.BuildEngine.DistributedFileLogger.Parameters.set -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.Shutdown() -> void
-Microsoft.Build.BuildEngine.DistributedFileLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.BuildEngine.DistributedFileLogger.Verbosity.set -> void
-Microsoft.Build.BuildEngine.Engine
-Microsoft.Build.BuildEngine.Engine.BinPath.get -> string
-Microsoft.Build.BuildEngine.Engine.BinPath.set -> void
-Microsoft.Build.BuildEngine.Engine.BuildEnabled.get -> bool
-Microsoft.Build.BuildEngine.Engine.BuildEnabled.set -> void
-Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string targetName) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames, System.Collections.IDictionary targetOutputs) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProject(Microsoft.Build.BuildEngine.Project project, string[] targetNames, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string targetName) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFile(string projectFile, string[] targetNames, Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags, string toolsVersion) -> bool
-Microsoft.Build.BuildEngine.Engine.BuildProjectFiles(string[] projectFiles, string[][] targetNamesPerProject, Microsoft.Build.BuildEngine.BuildPropertyGroup[] globalPropertiesPerProject, System.Collections.IDictionary[] targetOutputsPerProject, Microsoft.Build.BuildEngine.BuildSettings buildFlags, string[] toolsVersions) -> bool
-Microsoft.Build.BuildEngine.Engine.CreateNewProject() -> Microsoft.Build.BuildEngine.Project
-Microsoft.Build.BuildEngine.Engine.DefaultToolsVersion.get -> string
-Microsoft.Build.BuildEngine.Engine.DefaultToolsVersion.set -> void
-Microsoft.Build.BuildEngine.Engine.Engine() -> void
-Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties) -> void
-Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations) -> void
-Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.BuildPropertyGroup globalProperties, Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations, int numberOfCpus, string localNodeProviderParameters) -> void
-Microsoft.Build.BuildEngine.Engine.Engine(Microsoft.Build.BuildEngine.ToolsetDefinitionLocations locations) -> void
-Microsoft.Build.BuildEngine.Engine.Engine(string binPath) -> void
-Microsoft.Build.BuildEngine.Engine.GetLoadedProject(string projectFullFileName) -> Microsoft.Build.BuildEngine.Project
-Microsoft.Build.BuildEngine.Engine.GlobalProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.Engine.GlobalProperties.set -> void
-Microsoft.Build.BuildEngine.Engine.IsBuilding.get -> bool
-Microsoft.Build.BuildEngine.Engine.OnlyLogCriticalEvents.get -> bool
-Microsoft.Build.BuildEngine.Engine.OnlyLogCriticalEvents.set -> void
-Microsoft.Build.BuildEngine.Engine.RegisterDistributedLogger(Microsoft.Build.Framework.ILogger centralLogger, Microsoft.Build.BuildEngine.LoggerDescription forwardingLogger) -> void
-Microsoft.Build.BuildEngine.Engine.RegisterLogger(Microsoft.Build.Framework.ILogger logger) -> void
-Microsoft.Build.BuildEngine.Engine.Shutdown() -> void
-Microsoft.Build.BuildEngine.Engine.Toolsets.get -> Microsoft.Build.BuildEngine.ToolsetCollection
-Microsoft.Build.BuildEngine.Engine.UnloadAllProjects() -> void
-Microsoft.Build.BuildEngine.Engine.UnloadProject(Microsoft.Build.BuildEngine.Project project) -> void
-Microsoft.Build.BuildEngine.Engine.UnregisterAllLoggers() -> void
-Microsoft.Build.BuildEngine.FileLogger
-Microsoft.Build.BuildEngine.FileLogger.FileLogger() -> void
-Microsoft.Build.BuildEngine.Import
-Microsoft.Build.BuildEngine.Import.Condition.get -> string
-Microsoft.Build.BuildEngine.Import.Condition.set -> void
-Microsoft.Build.BuildEngine.Import.EvaluatedProjectPath.get -> string
-Microsoft.Build.BuildEngine.Import.IsImported.get -> bool
-Microsoft.Build.BuildEngine.Import.ProjectPath.get -> string
-Microsoft.Build.BuildEngine.Import.ProjectPath.set -> void
-Microsoft.Build.BuildEngine.ImportCollection
-Microsoft.Build.BuildEngine.ImportCollection.AddNewImport(string projectFile, string condition) -> void
-Microsoft.Build.BuildEngine.ImportCollection.CopyTo(Microsoft.Build.BuildEngine.Import[] array, int index) -> void
-Microsoft.Build.BuildEngine.ImportCollection.CopyTo(System.Array array, int index) -> void
-Microsoft.Build.BuildEngine.ImportCollection.Count.get -> int
-Microsoft.Build.BuildEngine.ImportCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.ImportCollection.IsSynchronized.get -> bool
-Microsoft.Build.BuildEngine.ImportCollection.RemoveImport(Microsoft.Build.BuildEngine.Import importToRemove) -> void
-Microsoft.Build.BuildEngine.ImportCollection.SyncRoot.get -> object
-Microsoft.Build.BuildEngine.InternalLoggerException
-Microsoft.Build.BuildEngine.InternalLoggerException.BuildEventArgs.get -> Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.BuildEngine.InternalLoggerException.ErrorCode.get -> string
-Microsoft.Build.BuildEngine.InternalLoggerException.HelpKeyword.get -> string
-Microsoft.Build.BuildEngine.InternalLoggerException.InitializationException.get -> bool
-Microsoft.Build.BuildEngine.InternalLoggerException.InternalLoggerException() -> void
-Microsoft.Build.BuildEngine.InternalLoggerException.InternalLoggerException(string message) -> void
-Microsoft.Build.BuildEngine.InternalLoggerException.InternalLoggerException(string message, System.Exception innerException) -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException
-Microsoft.Build.BuildEngine.InvalidProjectFileException.BaseMessage.get -> string
-Microsoft.Build.BuildEngine.InvalidProjectFileException.ColumnNumber.get -> int
-Microsoft.Build.BuildEngine.InvalidProjectFileException.EndColumnNumber.get -> int
-Microsoft.Build.BuildEngine.InvalidProjectFileException.EndLineNumber.get -> int
-Microsoft.Build.BuildEngine.InvalidProjectFileException.ErrorCode.get -> string
-Microsoft.Build.BuildEngine.InvalidProjectFileException.ErrorSubcategory.get -> string
-Microsoft.Build.BuildEngine.InvalidProjectFileException.HelpKeyword.get -> string
-Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException() -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(string message) -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(string message, System.Exception innerException) -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException.InvalidProjectFileException(System.Xml.XmlNode xmlNode, string message, string errorSubcategory, string errorCode, string helpKeyword) -> void
-Microsoft.Build.BuildEngine.InvalidProjectFileException.LineNumber.get -> int
-Microsoft.Build.BuildEngine.InvalidProjectFileException.ProjectFile.get -> string
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.ErrorCode.get -> string
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException() -> void
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message) -> void
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode) -> void
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, string errorCode, System.Exception innerException) -> void
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(string message, System.Exception innerException) -> void
-Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.InvalidToolsetDefinitionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.BuildEngine.LocalNode
-Microsoft.Build.BuildEngine.LoggerDescription
-Microsoft.Build.BuildEngine.LoggerDescription.LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, Microsoft.Build.Framework.LoggerVerbosity verbosity) -> void
-Microsoft.Build.BuildEngine.LoggerDescription.LoggerSwitchParameters.get -> string
-Microsoft.Build.BuildEngine.LoggerDescription.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.BuildEngine.Project
-Microsoft.Build.BuildEngine.Project.AddNewImport(string projectFile, string condition) -> void
-Microsoft.Build.BuildEngine.Project.AddNewItem(string itemName, string itemInclude) -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.Project.AddNewItem(string itemName, string itemInclude, bool treatItemIncludeAsLiteral) -> Microsoft.Build.BuildEngine.BuildItem
-Microsoft.Build.BuildEngine.Project.AddNewItemGroup() -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.Project.AddNewPropertyGroup(bool insertAtEndOfProject) -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.Project.AddNewUsingTaskFromAssemblyFile(string taskName, string assemblyFile) -> void
-Microsoft.Build.BuildEngine.Project.AddNewUsingTaskFromAssemblyName(string taskName, string assemblyName) -> void
-Microsoft.Build.BuildEngine.Project.Build() -> bool
-Microsoft.Build.BuildEngine.Project.Build(string targetName) -> bool
-Microsoft.Build.BuildEngine.Project.Build(string[] targetNames) -> bool
-Microsoft.Build.BuildEngine.Project.Build(string[] targetNames, System.Collections.IDictionary targetOutputs) -> bool
-Microsoft.Build.BuildEngine.Project.Build(string[] targetNames, System.Collections.IDictionary targetOutputs, Microsoft.Build.BuildEngine.BuildSettings buildFlags) -> bool
-Microsoft.Build.BuildEngine.Project.BuildEnabled.get -> bool
-Microsoft.Build.BuildEngine.Project.BuildEnabled.set -> void
-Microsoft.Build.BuildEngine.Project.DefaultTargets.get -> string
-Microsoft.Build.BuildEngine.Project.DefaultTargets.set -> void
-Microsoft.Build.BuildEngine.Project.DefaultToolsVersion.get -> string
-Microsoft.Build.BuildEngine.Project.DefaultToolsVersion.set -> void
-Microsoft.Build.BuildEngine.Project.Encoding.get -> System.Text.Encoding
-Microsoft.Build.BuildEngine.Project.EvaluatedItems.get -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.Project.EvaluatedItemsIgnoringCondition.get -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.Project.EvaluatedProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.Project.FullFileName.get -> string
-Microsoft.Build.BuildEngine.Project.FullFileName.set -> void
-Microsoft.Build.BuildEngine.Project.GetConditionedPropertyValues(string propertyName) -> string[]
-Microsoft.Build.BuildEngine.Project.GetEvaluatedItemsByName(string itemName) -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.Project.GetEvaluatedItemsByNameIgnoringCondition(string itemName) -> Microsoft.Build.BuildEngine.BuildItemGroup
-Microsoft.Build.BuildEngine.Project.GetEvaluatedProperty(string propertyName) -> string
-Microsoft.Build.BuildEngine.Project.GetProjectExtensions(string id) -> string
-Microsoft.Build.BuildEngine.Project.GlobalProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.Project.GlobalProperties.set -> void
-Microsoft.Build.BuildEngine.Project.HasToolsVersionAttribute.get -> bool
-Microsoft.Build.BuildEngine.Project.Imports.get -> Microsoft.Build.BuildEngine.ImportCollection
-Microsoft.Build.BuildEngine.Project.InitialTargets.get -> string
-Microsoft.Build.BuildEngine.Project.InitialTargets.set -> void
-Microsoft.Build.BuildEngine.Project.IsDirty.get -> bool
-Microsoft.Build.BuildEngine.Project.IsValidated.get -> bool
-Microsoft.Build.BuildEngine.Project.IsValidated.set -> void
-Microsoft.Build.BuildEngine.Project.ItemGroups.get -> Microsoft.Build.BuildEngine.BuildItemGroupCollection
-Microsoft.Build.BuildEngine.Project.Load(string projectFileName) -> void
-Microsoft.Build.BuildEngine.Project.Load(string projectFileName, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
-Microsoft.Build.BuildEngine.Project.Load(System.IO.TextReader textReader) -> void
-Microsoft.Build.BuildEngine.Project.Load(System.IO.TextReader textReader, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
-Microsoft.Build.BuildEngine.Project.LoadXml(string projectXml) -> void
-Microsoft.Build.BuildEngine.Project.LoadXml(string projectXml, Microsoft.Build.BuildEngine.ProjectLoadSettings projectLoadSettings) -> void
-Microsoft.Build.BuildEngine.Project.MarkProjectAsDirty() -> void
-Microsoft.Build.BuildEngine.Project.ParentEngine.get -> Microsoft.Build.BuildEngine.Engine
-Microsoft.Build.BuildEngine.Project.Project() -> void
-Microsoft.Build.BuildEngine.Project.Project(Microsoft.Build.BuildEngine.Engine engine) -> void
-Microsoft.Build.BuildEngine.Project.Project(Microsoft.Build.BuildEngine.Engine engine, string toolsVersion) -> void
-Microsoft.Build.BuildEngine.Project.PropertyGroups.get -> Microsoft.Build.BuildEngine.BuildPropertyGroupCollection
-Microsoft.Build.BuildEngine.Project.RemoveAllItemGroups() -> void
-Microsoft.Build.BuildEngine.Project.RemoveAllPropertyGroups() -> void
-Microsoft.Build.BuildEngine.Project.RemoveImportedPropertyGroup(Microsoft.Build.BuildEngine.BuildPropertyGroup propertyGroupToRemove) -> void
-Microsoft.Build.BuildEngine.Project.RemoveItem(Microsoft.Build.BuildEngine.BuildItem itemToRemove) -> void
-Microsoft.Build.BuildEngine.Project.RemoveItemGroup(Microsoft.Build.BuildEngine.BuildItemGroup itemGroupToRemove) -> void
-Microsoft.Build.BuildEngine.Project.RemoveItemGroupsWithMatchingCondition(string matchCondition) -> void
-Microsoft.Build.BuildEngine.Project.RemoveItemsByName(string itemName) -> void
-Microsoft.Build.BuildEngine.Project.RemovePropertyGroup(Microsoft.Build.BuildEngine.BuildPropertyGroup propertyGroupToRemove) -> void
-Microsoft.Build.BuildEngine.Project.RemovePropertyGroupsWithMatchingCondition(string matchCondition) -> void
-Microsoft.Build.BuildEngine.Project.RemovePropertyGroupsWithMatchingCondition(string matchCondition, bool includeImportedPropertyGroups) -> void
-Microsoft.Build.BuildEngine.Project.ResetBuildStatus() -> void
-Microsoft.Build.BuildEngine.Project.Save(string projectFileName) -> void
-Microsoft.Build.BuildEngine.Project.Save(string projectFileName, System.Text.Encoding encoding) -> void
-Microsoft.Build.BuildEngine.Project.Save(System.IO.TextWriter textWriter) -> void
-Microsoft.Build.BuildEngine.Project.SchemaFile.get -> string
-Microsoft.Build.BuildEngine.Project.SchemaFile.set -> void
-Microsoft.Build.BuildEngine.Project.SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importedProject, Microsoft.Build.BuildEngine.PropertyPosition position) -> void
-Microsoft.Build.BuildEngine.Project.SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importedProject, Microsoft.Build.BuildEngine.PropertyPosition position, bool treatPropertyValueAsLiteral) -> void
-Microsoft.Build.BuildEngine.Project.SetImportedProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.Project importProject) -> void
-Microsoft.Build.BuildEngine.Project.SetProjectExtensions(string id, string content) -> void
-Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue) -> void
-Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue, string condition) -> void
-Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.PropertyPosition position) -> void
-Microsoft.Build.BuildEngine.Project.SetProperty(string propertyName, string propertyValue, string condition, Microsoft.Build.BuildEngine.PropertyPosition position, bool treatPropertyValueAsLiteral) -> void
-Microsoft.Build.BuildEngine.Project.Targets.get -> Microsoft.Build.BuildEngine.TargetCollection
-Microsoft.Build.BuildEngine.Project.TimeOfLastDirty.get -> System.DateTime
-Microsoft.Build.BuildEngine.Project.ToolsVersion.get -> string
-Microsoft.Build.BuildEngine.Project.UsingTasks.get -> Microsoft.Build.BuildEngine.UsingTaskCollection
-Microsoft.Build.BuildEngine.Project.Xml.get -> string
-Microsoft.Build.BuildEngine.ProjectLoadSettings
-Microsoft.Build.BuildEngine.ProjectLoadSettings.IgnoreMissingImports = 1 -> Microsoft.Build.BuildEngine.ProjectLoadSettings
-Microsoft.Build.BuildEngine.ProjectLoadSettings.None = 0 -> Microsoft.Build.BuildEngine.ProjectLoadSettings
-Microsoft.Build.BuildEngine.PropertyPosition
-Microsoft.Build.BuildEngine.PropertyPosition.UseExistingOrCreateAfterLastImport = 1 -> Microsoft.Build.BuildEngine.PropertyPosition
-Microsoft.Build.BuildEngine.PropertyPosition.UseExistingOrCreateAfterLastPropertyGroup = 0 -> Microsoft.Build.BuildEngine.PropertyPosition
-Microsoft.Build.BuildEngine.RemoteErrorException
-Microsoft.Build.BuildEngine.SolutionWrapperProject
-Microsoft.Build.BuildEngine.Target
-Microsoft.Build.BuildEngine.Target.AddNewTask(string taskName) -> Microsoft.Build.BuildEngine.BuildTask
-Microsoft.Build.BuildEngine.Target.Condition.get -> string
-Microsoft.Build.BuildEngine.Target.Condition.set -> void
-Microsoft.Build.BuildEngine.Target.DependsOnTargets.get -> string
-Microsoft.Build.BuildEngine.Target.DependsOnTargets.set -> void
-Microsoft.Build.BuildEngine.Target.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.Target.Inputs.get -> string
-Microsoft.Build.BuildEngine.Target.Inputs.set -> void
-Microsoft.Build.BuildEngine.Target.IsImported.get -> bool
-Microsoft.Build.BuildEngine.Target.Name.get -> string
-Microsoft.Build.BuildEngine.Target.Outputs.get -> string
-Microsoft.Build.BuildEngine.Target.Outputs.set -> void
-Microsoft.Build.BuildEngine.Target.RemoveTask(Microsoft.Build.BuildEngine.BuildTask taskElement) -> void
-Microsoft.Build.BuildEngine.TargetCollection
-Microsoft.Build.BuildEngine.TargetCollection.AddNewTarget(string targetName) -> Microsoft.Build.BuildEngine.Target
-Microsoft.Build.BuildEngine.TargetCollection.CopyTo(System.Array array, int index) -> void
-Microsoft.Build.BuildEngine.TargetCollection.Count.get -> int
-Microsoft.Build.BuildEngine.TargetCollection.Exists(string targetName) -> bool
-Microsoft.Build.BuildEngine.TargetCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.TargetCollection.IsSynchronized.get -> bool
-Microsoft.Build.BuildEngine.TargetCollection.RemoveTarget(Microsoft.Build.BuildEngine.Target targetToRemove) -> void
-Microsoft.Build.BuildEngine.TargetCollection.SyncRoot.get -> object
-Microsoft.Build.BuildEngine.TargetCollection.this[string index].get -> Microsoft.Build.BuildEngine.Target
-Microsoft.Build.BuildEngine.Toolset
-Microsoft.Build.BuildEngine.Toolset.BuildProperties.get -> Microsoft.Build.BuildEngine.BuildPropertyGroup
-Microsoft.Build.BuildEngine.Toolset.Clone() -> Microsoft.Build.BuildEngine.Toolset
-Microsoft.Build.BuildEngine.Toolset.Toolset(string toolsVersion, string toolsPath) -> void
-Microsoft.Build.BuildEngine.Toolset.Toolset(string toolsVersion, string toolsPath, Microsoft.Build.BuildEngine.BuildPropertyGroup buildProperties) -> void
-Microsoft.Build.BuildEngine.Toolset.ToolsPath.get -> string
-Microsoft.Build.BuildEngine.Toolset.ToolsVersion.get -> string
-Microsoft.Build.BuildEngine.ToolsetCollection
-Microsoft.Build.BuildEngine.ToolsetCollection.Add(Microsoft.Build.BuildEngine.Toolset item) -> void
-Microsoft.Build.BuildEngine.ToolsetCollection.Clear() -> void
-Microsoft.Build.BuildEngine.ToolsetCollection.Contains(Microsoft.Build.BuildEngine.Toolset item) -> bool
-Microsoft.Build.BuildEngine.ToolsetCollection.Contains(string toolsVersion) -> bool
-Microsoft.Build.BuildEngine.ToolsetCollection.CopyTo(Microsoft.Build.BuildEngine.Toolset[] array, int arrayIndex) -> void
-Microsoft.Build.BuildEngine.ToolsetCollection.Count.get -> int
-Microsoft.Build.BuildEngine.ToolsetCollection.GetEnumerator() -> System.Collections.Generic.IEnumerator<Microsoft.Build.BuildEngine.Toolset>
-Microsoft.Build.BuildEngine.ToolsetCollection.IsReadOnly.get -> bool
-Microsoft.Build.BuildEngine.ToolsetCollection.Remove(Microsoft.Build.BuildEngine.Toolset item) -> bool
-Microsoft.Build.BuildEngine.ToolsetCollection.this[string toolsVersion].get -> Microsoft.Build.BuildEngine.Toolset
-Microsoft.Build.BuildEngine.ToolsetCollection.ToolsVersions.get -> System.Collections.Generic.IEnumerable<string>
-Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
-Microsoft.Build.BuildEngine.ToolsetDefinitionLocations.ConfigurationFile = 1 -> Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
-Microsoft.Build.BuildEngine.ToolsetDefinitionLocations.None = 0 -> Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
-Microsoft.Build.BuildEngine.ToolsetDefinitionLocations.Registry = 2 -> Microsoft.Build.BuildEngine.ToolsetDefinitionLocations
-Microsoft.Build.BuildEngine.UsingTask
-Microsoft.Build.BuildEngine.UsingTask.AssemblyFile.get -> string
-Microsoft.Build.BuildEngine.UsingTask.AssemblyName.get -> string
-Microsoft.Build.BuildEngine.UsingTask.Condition.get -> string
-Microsoft.Build.BuildEngine.UsingTask.IsImported.get -> bool
-Microsoft.Build.BuildEngine.UsingTask.TaskName.get -> string
-Microsoft.Build.BuildEngine.UsingTaskCollection
-Microsoft.Build.BuildEngine.UsingTaskCollection.CopyTo(Microsoft.Build.BuildEngine.UsingTask[] array, int index) -> void
-Microsoft.Build.BuildEngine.UsingTaskCollection.CopyTo(System.Array array, int index) -> void
-Microsoft.Build.BuildEngine.UsingTaskCollection.Count.get -> int
-Microsoft.Build.BuildEngine.UsingTaskCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.BuildEngine.UsingTaskCollection.IsSynchronized.get -> bool
-Microsoft.Build.BuildEngine.UsingTaskCollection.SyncRoot.get -> object
-Microsoft.Build.BuildEngine.Utilities
-Microsoft.Build.BuildEngine.WriteHandler
-override Microsoft.Build.BuildEngine.BuildProperty.ToString() -> string
-override Microsoft.Build.BuildEngine.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-override Microsoft.Build.BuildEngine.FileLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-override Microsoft.Build.BuildEngine.FileLogger.Shutdown() -> void
-override Microsoft.Build.BuildEngine.InternalLoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.BuildEngine.InvalidProjectFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.BuildEngine.InvalidProjectFileException.Message.get -> string
-override Microsoft.Build.BuildEngine.InvalidToolsetDefinitionException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.BuildEngine.RemoteErrorException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-static Microsoft.Build.BuildEngine.BuildProperty.explicit operator string(Microsoft.Build.BuildEngine.BuildProperty propertyToCast) -> string
-static Microsoft.Build.BuildEngine.Engine.GlobalEngine.get -> Microsoft.Build.BuildEngine.Engine
-static Microsoft.Build.BuildEngine.Engine.Version.get -> System.Version
-static Microsoft.Build.BuildEngine.LocalNode.StartLocalNodeServer(int nodeNumber) -> void
-static Microsoft.Build.BuildEngine.SolutionWrapperProject.Generate(string solutionPath, string toolsVersionOverride, Microsoft.Build.Framework.BuildEventContext projectBuildEventContext) -> string
-static Microsoft.Build.BuildEngine.Utilities.Escape(string unescapedExpression) -> string
-virtual Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.ForwardToCentralLogger(Microsoft.Build.Framework.BuildEventArgs e) -> void
-virtual Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.BuildEngine.ConfigurableForwardingLogger.Shutdown() -> void
-virtual Microsoft.Build.BuildEngine.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-virtual Microsoft.Build.BuildEngine.ConsoleLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-virtual Microsoft.Build.BuildEngine.ConsoleLogger.Shutdown() -> void
\ No newline at end of file
diff --git a/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Deprecated/Engine/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
index edd9b7ee18a..1cac0aa734f 100644
--- a/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
+++ b/src/Deprecated/Engine/Shared/AssemblyNameExtension.cs
@@ -5,7 +5,9 @@
 using System.Text;
 using System.Reflection;
 using System.Globalization;
+#if DEBUG
 using System.Diagnostics;
+#endif
 
 namespace Microsoft.Build.BuildEngine.Shared
 {
diff --git a/src/Deprecated/Engine/Shared/ResourceUtilities.cs b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
index d6443759b87..3be5976f2aa 100644
--- a/src/Deprecated/Engine/Shared/ResourceUtilities.cs
+++ b/src/Deprecated/Engine/Shared/ResourceUtilities.cs
@@ -2,8 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+#if !BUILDINGAPPXTASKS && DEBUG
 using System.Resources;
 using System.Diagnostics;
+#endif
 using System.Globalization;
 using System.Text.RegularExpressions;
 
diff --git a/src/Directory.Build.props b/src/Directory.Build.props
index e3020e9de14..f6809d2e4bf 100644
--- a/src/Directory.Build.props
+++ b/src/Directory.Build.props
@@ -56,6 +56,7 @@
     <GenerateResourceMSBuildArchitecture>CurrentArchitecture</GenerateResourceMSBuildArchitecture>
     <GenerateResourceMSBuildRuntime>CurrentRuntime</GenerateResourceMSBuildRuntime>
 
+    <EnforceCodeStyleInBuild>true</EnforceCodeStyleInBuild>
     <GenerateDocumentationFile>true</GenerateDocumentationFile>
 
     <PackageLicenseUrl Condition="'$(PackageLicenseExpression)' == ''">http://go.microsoft.com/fwlink/?LinkId=329770</PackageLicenseUrl>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index 99fbf81780c..b3f2e35187c 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -91,14 +91,6 @@
     <GenAPIFolderPath>$(RepoRoot)ref\$(GenAPIAssemblyName)\$(GenAPIShortFrameworkIdentifier)\</GenAPIFolderPath>
   </PropertyGroup>
 
-  <ItemGroup Condition="'$(GenerateReferenceAssemblySource)' == 'true'">
-    <!-- Ensure API stability for shipping packages -->
-    <PackageReference Include="Microsoft.CodeAnalysis.PublicApiAnalyzers" PrivateAssets="all" Condition="'$(DotNetBuildFromSource)' != 'true'" />
-
-    <AdditionalFiles Include="PublicAPI/$(PublicApiTfm)/PublicAPI.Shipped.txt" />
-    <AdditionalFiles Include="PublicAPI/$(PublicApiTfm)/PublicAPI.Unshipped.txt" />
-  </ItemGroup>
-
   <ItemGroup Condition="'$(IsUnitTestProject)' == 'true' And '$(TargetFrameworkIdentifier)' != '.NETFramework' ">
     <PackageReference Include="xunit.console" />
   </ItemGroup>
diff --git a/src/Framework/AssemblyUtilities.cs b/src/Framework/AssemblyUtilities.cs
index 32948ee3d39..e625642076d 100644
--- a/src/Framework/AssemblyUtilities.cs
+++ b/src/Framework/AssemblyUtilities.cs
@@ -3,10 +3,13 @@
 
 using System;
 using System.Globalization;
-using System.Linq;
 using System.Reflection;
 
+#if !FEATURE_CULTUREINFO_GETCULTURES
+using System.Linq;
 using Microsoft.Build.Framework;
+#endif
+
 
 // Declare this to get init properties. See https://github.com/dotnet/roslyn/issues/45510#issuecomment-694977239
 #nullable disable
diff --git a/src/Framework/ChangeWaves.cs b/src/Framework/ChangeWaves.cs
index 405747281f1..91acdc9bc59 100644
--- a/src/Framework/ChangeWaves.cs
+++ b/src/Framework/ChangeWaves.cs
@@ -24,11 +24,10 @@ internal enum ChangeWaveConversionState
     /// For dev docs: https://github.com/dotnet/msbuild/blob/master/documentation/wiki/ChangeWaves-Dev.md
     internal class ChangeWaves
     {
-        internal static readonly Version Wave17_0 = new Version(17, 0);
         internal static readonly Version Wave17_2 = new Version(17, 2);
         internal static readonly Version Wave17_4 = new Version(17, 4);
         internal static readonly Version Wave17_6 = new Version(17, 6);
-        internal static readonly Version[] AllWaves = { Wave17_0, Wave17_2, Wave17_4, Wave17_6 };
+        internal static readonly Version[] AllWaves = { Wave17_2, Wave17_4, Wave17_6 };
 
         /// <summary>
         /// Special value indicating that all features behind all Change Waves should be enabled.
diff --git a/src/Framework/CompatibilitySuppressions.xml b/src/Framework/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..993613f410e
--- /dev/null
+++ b/src/Framework/CompatibilitySuppressions.xml
@@ -0,0 +1,56 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
+       This is intentional, because you can only use MSBuild in the context of a .NET SDK
+       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
+       have previously shipped netstandard2.0 packages, and if you want to support both
+       runtime contexts it still makes sense to target that. -->
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETCoreApp,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.1</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.2</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.3</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETStandard,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Tizen,Version=v4.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>UAP,Version=v10.0.15064</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation3,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation4,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStationVita,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.Xbox360,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.XboxOne,Version=v0.0</Target>
+  </Suppression>
+</Suppressions>
diff --git a/src/Framework/ErrorUtilities.cs b/src/Framework/ErrorUtilities.cs
index 20792056fb0..f90c6cc9d82 100644
--- a/src/Framework/ErrorUtilities.cs
+++ b/src/Framework/ErrorUtilities.cs
@@ -2,10 +2,6 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 
 #nullable disable
 
diff --git a/src/Framework/FileClassifier.cs b/src/Framework/FileClassifier.cs
index a214a751443..9ea92f4fccb 100644
--- a/src/Framework/FileClassifier.cs
+++ b/src/Framework/FileClassifier.cs
@@ -4,11 +4,13 @@
 using System;
 using System.Collections.Concurrent;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
-using System.Linq;
 using System.Runtime.InteropServices;
+#if !RUNTIME_TYPE_NETCORE
+using System.Diagnostics;
+using System.Linq;
 using System.Text.RegularExpressions;
+#endif
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index b4c3190f3b4..724e1a38496 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -8,6 +8,7 @@
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which is a common assembly used by other MSBuild assemblies.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <ApplyNgenOptimization Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">full</ApplyNgenOptimization>
+    <EnablePackageValidation>true</EnablePackageValidation>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 6ecf54b1843..cac89847adf 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -10,7 +10,6 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-using System.Threading;
 
 using Microsoft.Build.Shared;
 using Microsoft.Win32;
@@ -200,9 +199,16 @@ internal enum ProcessorArchitectures
         Unknown
     }
 
-#endregion
+    internal enum SymbolicLink
+    {
+        File = 0,
+        Directory = 1,
+        AllowUnprivilegedCreate = 2,
+    }
+
+    #endregion
 
-#region Structs
+    #region Structs
 
     /// <summary>
     /// Structure that contain information about the system on which we are running
@@ -1035,6 +1041,30 @@ internal static MemoryStatus GetMemoryStatus()
         return null;
     }
 
+    internal static bool MakeSymbolicLink(string newFileName, string exitingFileName, ref string errorMessage)
+    {
+        bool symbolicLinkCreated;
+        if (IsWindows)
+        {
+            Version osVersion = Environment.OSVersion.Version;
+            SymbolicLink flags = SymbolicLink.File;
+            if (osVersion.Major >= 11 || (osVersion.Major == 10 && osVersion.Build >= 14972))
+            {
+                flags |= SymbolicLink.AllowUnprivilegedCreate;
+            }
+
+            symbolicLinkCreated = CreateSymbolicLink(newFileName, exitingFileName, flags);
+            errorMessage = symbolicLinkCreated ? null : Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;
+        }
+        else
+        {
+            symbolicLinkCreated = symlink(exitingFileName, newFileName) == 0;
+            errorMessage = symbolicLinkCreated ? null : "The link() library call failed with the following error code: " + Marshal.GetLastWin32Error();
+        }
+
+        return symbolicLinkCreated;
+    }
+
     /// <summary>
     /// Get the last write time of the fullpath to the file.
     /// </summary>
@@ -1048,7 +1078,7 @@ internal static MemoryStatus GetMemoryStatus()
     internal static DateTime GetLastWriteFileUtcTime(string fullPath)
     {
 #if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
-        if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck || !ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+        if (Traits.Instance.EscapeHatches.AlwaysDoImmutableFilesUpToDateCheck)
         {
             return LastWriteFileUtcTime(fullPath);
         }
@@ -1111,6 +1141,23 @@ DateTime LastWriteFileUtcTime(string path)
         }
     }
 
+    /// <summary>
+    /// Get the SafeFileHandle for a file, while skipping reparse points (going directly to target file).
+    /// </summary>
+    /// <param name="fullPath">Full path to the file in the filesystem</param>
+    /// <returns>the SafeFileHandle for a file (target file in case of symlinks)</returns>
+    [SupportedOSPlatform("windows")]
+    private static SafeFileHandle OpenFileThroughSymlinks(string fullPath)
+    {
+        return CreateFile(fullPath,
+            GENERIC_READ,
+            FILE_SHARE_READ,
+            IntPtr.Zero,
+            OPEN_EXISTING,
+            FILE_ATTRIBUTE_NORMAL, /* No FILE_FLAG_OPEN_REPARSE_POINT; read through to content */
+            IntPtr.Zero);
+    }
+
     /// <summary>
     /// Get the last write time of the content pointed to by a file path.
     /// </summary>
@@ -1125,14 +1172,7 @@ private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
     {
         DateTime fileModifiedTime = DateTime.MinValue;
 
-        using (SafeFileHandle handle =
-            CreateFile(fullPath,
-                GENERIC_READ,
-                FILE_SHARE_READ,
-                IntPtr.Zero,
-                OPEN_EXISTING,
-                FILE_ATTRIBUTE_NORMAL, /* No FILE_FLAG_OPEN_REPARSE_POINT; read through to content */
-                IntPtr.Zero))
+        using (SafeFileHandle handle = OpenFileThroughSymlinks(fullPath))
         {
             if (!handle.IsInvalid)
             {
@@ -1635,9 +1675,17 @@ out FILETIME lpLastWriteTime
     [SupportedOSPlatform("windows")]
     internal static extern bool SetThreadErrorMode(int newMode, out int oldMode);
 
-#endregion
+    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    [return: MarshalAs(UnmanagedType.I1)]
+    [SupportedOSPlatform("windows")]
+    internal static extern bool CreateSymbolicLink(string symLinkFileName, string targetFileName, SymbolicLink dwFlags);
+
+    [DllImport("libc", SetLastError = true)]
+    internal static extern int symlink(string oldpath, string newpath);
+
+    #endregion
 
-#region helper methods
+    #region helper methods
 
     internal static bool DirectoryExists(string fullPath)
     {
diff --git a/src/Framework/PublicAPI/net/PublicAPI.Shipped.txt b/src/Framework/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index ec298ae0076..00000000000
--- a/src/Framework/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,919 +0,0 @@
-abstract Microsoft.Build.Framework.SdkLogger.LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-abstract Microsoft.Build.Framework.SdkResolver.Name.get -> string
-abstract Microsoft.Build.Framework.SdkResolver.Priority.get -> int
-abstract Microsoft.Build.Framework.SdkResolver.Resolve(Microsoft.Build.Framework.SdkReference sdkReference, Microsoft.Build.Framework.SdkResolverContext resolverContext, Microsoft.Build.Framework.SdkResultFactory factory) -> Microsoft.Build.Framework.SdkResult
-abstract Microsoft.Build.Framework.SdkResultFactory.IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-abstract Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-const Microsoft.Build.Framework.BuildEventContext.InvalidEvaluationId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidNodeId = -2 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidProjectContextId = -2 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidProjectInstanceId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidSubmissionId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidTargetId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidTaskId = -1 -> int
-const Microsoft.Build.Framework.EngineServices.Version1 = 1 -> int
-const Microsoft.Build.Framework.ProjectStartedEventArgs.InvalidProjectId = -1 -> int
-Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Framework.BuildEngineResult
-Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult() -> void
-Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) -> void
-Microsoft.Build.Framework.BuildEngineResult.Result.get -> bool
-Microsoft.Build.Framework.BuildEngineResult.TargetOutputsPerProject.get -> System.Collections.Generic.IList<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>>
-Microsoft.Build.Framework.BuildErrorEventArgs
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs() -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.HelpLink.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs() -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.set -> void
-Microsoft.Build.Framework.BuildEventArgs.HelpKeyword.get -> string
-Microsoft.Build.Framework.BuildEventArgs.RawMessage.get -> string
-Microsoft.Build.Framework.BuildEventArgs.RawMessage.set -> void
-Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.get -> System.DateTime
-Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.set -> void
-Microsoft.Build.Framework.BuildEventArgs.SenderName.get -> string
-Microsoft.Build.Framework.BuildEventArgs.ThreadId.get -> int
-Microsoft.Build.Framework.BuildEventArgs.Timestamp.get -> System.DateTime
-Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int targetId, int projectContextId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int evaluationId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildRequestId.get -> long
-Microsoft.Build.Framework.BuildEventContext.EvaluationId.get -> int
-Microsoft.Build.Framework.BuildEventContext.NodeId.get -> int
-Microsoft.Build.Framework.BuildEventContext.ProjectContextId.get -> int
-Microsoft.Build.Framework.BuildEventContext.ProjectInstanceId.get -> int
-Microsoft.Build.Framework.BuildEventContext.SubmissionId.get -> int
-Microsoft.Build.Framework.BuildEventContext.TargetId.get -> int
-Microsoft.Build.Framework.BuildEventContext.TaskId.get -> int
-Microsoft.Build.Framework.BuildFinishedEventArgs
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs() -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Framework.BuildMessageEventArgs
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs() -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.Importance.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.BuildMessageEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Framework.BuildStartedEventArgs
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs() -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.Collections.Generic.IDictionary<string, string> environmentOfBuild) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Framework.BuildStatusEventArgs
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs() -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Framework.BuildWarningEventArgs
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs() -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.HelpLink.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs() -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs() -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Framework.EngineServices
-Microsoft.Build.Framework.EngineServices.EngineServices() -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.get -> string
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.set -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs() -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs() -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs() -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames) -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.TargetNames.get -> string
-Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Framework.IBuildEngine.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs) -> bool
-Microsoft.Build.Framework.IBuildEngine.ColumnNumberOfTaskNode.get -> int
-Microsoft.Build.Framework.IBuildEngine.ContinueOnError.get -> bool
-Microsoft.Build.Framework.IBuildEngine.LineNumberOfTaskNode.get -> int
-Microsoft.Build.Framework.IBuildEngine.LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.ProjectFileOfTaskNode.get -> string
-Microsoft.Build.Framework.IBuildEngine10
-Microsoft.Build.Framework.IBuildEngine10.EngineServices.get -> Microsoft.Build.Framework.EngineServices
-Microsoft.Build.Framework.IBuildEngine2
-Microsoft.Build.Framework.IBuildEngine2.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs, string toolsVersion) -> bool
-Microsoft.Build.Framework.IBuildEngine2.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion) -> bool
-Microsoft.Build.Framework.IBuildEngine2.IsRunningMultipleNodes.get -> bool
-Microsoft.Build.Framework.IBuildEngine3
-Microsoft.Build.Framework.IBuildEngine3.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.Generic.IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs) -> Microsoft.Build.Framework.BuildEngineResult
-Microsoft.Build.Framework.IBuildEngine3.Reacquire() -> void
-Microsoft.Build.Framework.IBuildEngine3.Yield() -> void
-Microsoft.Build.Framework.IBuildEngine4
-Microsoft.Build.Framework.IBuildEngine4.GetRegisteredTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
-Microsoft.Build.Framework.IBuildEngine4.RegisterTaskObject(object key, object obj, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection) -> void
-Microsoft.Build.Framework.IBuildEngine4.UnregisterTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
-Microsoft.Build.Framework.IBuildEngine5
-Microsoft.Build.Framework.IBuildEngine5.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
-Microsoft.Build.Framework.IBuildEngine6
-Microsoft.Build.Framework.IBuildEngine6.GetGlobalProperties() -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Framework.IBuildEngine7
-Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.get -> bool
-Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.set -> void
-Microsoft.Build.Framework.IBuildEngine8
-Microsoft.Build.Framework.IBuildEngine8.ShouldTreatWarningAsError(string warningCode) -> bool
-Microsoft.Build.Framework.IBuildEngine9
-Microsoft.Build.Framework.IBuildEngine9.ReleaseCores(int coresToRelease) -> void
-Microsoft.Build.Framework.IBuildEngine9.RequestCores(int requestedCores) -> int
-Microsoft.Build.Framework.ICancelableTask
-Microsoft.Build.Framework.ICancelableTask.Cancel() -> void
-Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Framework.IEventRedirector.ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
-Microsoft.Build.Framework.IEventSource
-Microsoft.Build.Framework.IEventSource.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Framework.IEventSource.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Framework.IEventSource.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Framework.IEventSource.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Framework.IEventSource.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Framework.IEventSource.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Framework.IEventSource.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Framework.IEventSource.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Framework.IEventSource.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Framework.IEventSource.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Framework.IEventSource2
-Microsoft.Build.Framework.IEventSource2.TelemetryLogged -> Microsoft.Build.Framework.TelemetryEventHandler
-Microsoft.Build.Framework.IEventSource3
-Microsoft.Build.Framework.IEventSource3.IncludeEvaluationMetaprojects() -> void
-Microsoft.Build.Framework.IEventSource3.IncludeEvaluationProfiles() -> void
-Microsoft.Build.Framework.IEventSource3.IncludeTaskInputs() -> void
-Microsoft.Build.Framework.IEventSource4
-Microsoft.Build.Framework.IEventSource4.IncludeEvaluationPropertiesAndItems() -> void
-Microsoft.Build.Framework.IForwardingLogger
-Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Framework.IForwardingLogger.NodeId.get -> int
-Microsoft.Build.Framework.IForwardingLogger.NodeId.set -> void
-Microsoft.Build.Framework.IGeneratedTask
-Microsoft.Build.Framework.IGeneratedTask.GetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property) -> object
-Microsoft.Build.Framework.IGeneratedTask.SetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property, object value) -> void
-Microsoft.Build.Framework.ILogger
-Microsoft.Build.Framework.ILogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Framework.ILogger.Parameters.get -> string
-Microsoft.Build.Framework.ILogger.Parameters.set -> void
-Microsoft.Build.Framework.ILogger.Shutdown() -> void
-Microsoft.Build.Framework.ILogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.ILogger.Verbosity.set -> void
-Microsoft.Build.Framework.INodeLogger
-Microsoft.Build.Framework.INodeLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Framework.IProjectElement
-Microsoft.Build.Framework.IProjectElement.ElementName.get -> string
-Microsoft.Build.Framework.IProjectElement.OuterElement.get -> string
-Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Framework.ITask.BuildEngine.set -> void
-Microsoft.Build.Framework.ITask.Execute() -> bool
-Microsoft.Build.Framework.ITask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Framework.ITask.HostObject.set -> void
-Microsoft.Build.Framework.ITaskFactory
-Microsoft.Build.Framework.ITaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Framework.ITaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITaskFactory.FactoryName.get -> string
-Microsoft.Build.Framework.ITaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Framework.ITaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Framework.ITaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Framework.ITaskFactory2
-Microsoft.Build.Framework.ITaskFactory2.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITaskFactory2.Initialize(string taskName, System.Collections.Generic.IDictionary<string, string> factoryIdentityParameters, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Framework.ITaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
-Microsoft.Build.Framework.ITaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
-Microsoft.Build.Framework.ITaskItem.GetMetadata(string metadataName) -> string
-Microsoft.Build.Framework.ITaskItem.ItemSpec.get -> string
-Microsoft.Build.Framework.ITaskItem.ItemSpec.set -> void
-Microsoft.Build.Framework.ITaskItem.MetadataCount.get -> int
-Microsoft.Build.Framework.ITaskItem.MetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.Framework.ITaskItem.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Framework.ITaskItem.SetMetadata(string metadataName, string metadataValue) -> void
-Microsoft.Build.Framework.ITaskItem2
-Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped() -> System.Collections.IDictionary
-Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.get -> string
-Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.set -> void
-Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string metadataName) -> string
-Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs() -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute
-Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute.LoadInSeparateAppDomainAttribute() -> void
-Microsoft.Build.Framework.LoggerException
-Microsoft.Build.Framework.LoggerException.ErrorCode.get -> string
-Microsoft.Build.Framework.LoggerException.HelpKeyword.get -> string
-Microsoft.Build.Framework.LoggerException.LoggerException() -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException, string errorCode, string helpKeyword) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Detailed = 3 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Diagnostic = 4 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Minimal = 1 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Normal = 2 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Quiet = 0 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.High = 0 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.Low = 2 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.Normal = 1 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPath, string message) -> void
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.metaprojectXml -> string
-Microsoft.Build.Framework.OutputAttribute
-Microsoft.Build.Framework.OutputAttribute.OutputAttribute() -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementDescription.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementName.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation() -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long id, long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPass.get -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPassDescription.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.File.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Id.get -> long
-Microsoft.Build.Framework.Profiler.EvaluationLocation.IsEvaluationPass.get -> bool
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Kind.get -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Line.get -> int?
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ParentId.get -> long?
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription = null) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFile(string file) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndCondition(string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndElement(string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithGlob(string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithParentId(long? parentId) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Condition = 1 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Element = 0 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Glob = 2 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.InitialProperties = 2 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.ItemDefinitionGroups = 4 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Items = 5 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.LazyItems = 6 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Properties = 3 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Targets = 8 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.TotalEvaluation = 0 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.TotalGlobbing = 1 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.UsingTasks = 7 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.ProfiledLocation
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ExclusiveTime.get -> System.TimeSpan
-Microsoft.Build.Framework.Profiler.ProfiledLocation.InclusiveTime.get -> System.TimeSpan
-Microsoft.Build.Framework.Profiler.ProfiledLocation.NumberOfHits.get -> int
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation() -> void
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) -> void
-Microsoft.Build.Framework.Profiler.ProfilerResult
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfiledLocations.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation>
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult() -> void
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.get -> Microsoft.Build.Framework.Profiler.ProfilerResult?
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs() -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.set -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs() -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs() -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded) -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Framework.ProjectImportedEventArgs
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.get -> string
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.set -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.get -> bool
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.set -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs() -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs(int lineNumber, int columnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.get -> string
-Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.set -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs
-Microsoft.Build.Framework.ProjectStartedEventArgs.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.ProjectStartedEventArgs.Items.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectStartedEventArgs.ParentProjectBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectId.get -> int
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs() -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.Properties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectStartedEventArgs.TargetNames.get -> string
-Microsoft.Build.Framework.ProjectStartedEventArgs.ToolsVersion.get -> string
-Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs() -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.set -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs() -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime.AppDomain = 1 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime.Build = 0 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RequiredAttribute
-Microsoft.Build.Framework.RequiredAttribute.RequiredAttribute() -> void
-Microsoft.Build.Framework.RequiredRuntimeAttribute
-Microsoft.Build.Framework.RequiredRuntimeAttribute.RequiredRuntimeAttribute(string runtimeVersion) -> void
-Microsoft.Build.Framework.RequiredRuntimeAttribute.RuntimeVersion.get -> string
-Microsoft.Build.Framework.RunInMTAAttribute
-Microsoft.Build.Framework.RunInMTAAttribute.RunInMTAAttribute() -> void
-Microsoft.Build.Framework.RunInSTAAttribute
-Microsoft.Build.Framework.RunInSTAAttribute.RunInSTAAttribute() -> void
-Microsoft.Build.Framework.SdkLogger
-Microsoft.Build.Framework.SdkLogger.SdkLogger() -> void
-Microsoft.Build.Framework.SdkReference
-Microsoft.Build.Framework.SdkReference.Equals(Microsoft.Build.Framework.SdkReference other) -> bool
-Microsoft.Build.Framework.SdkReference.MinimumVersion.get -> string
-Microsoft.Build.Framework.SdkReference.Name.get -> string
-Microsoft.Build.Framework.SdkReference.SdkReference(string name, string version, string minimumVersion) -> void
-Microsoft.Build.Framework.SdkReference.Version.get -> string
-Microsoft.Build.Framework.SdkResolver
-Microsoft.Build.Framework.SdkResolver.SdkResolver() -> void
-Microsoft.Build.Framework.SdkResolverContext
-Microsoft.Build.Framework.SdkResolverContext.SdkResolverContext() -> void
-Microsoft.Build.Framework.SdkResult
-Microsoft.Build.Framework.SdkResult.SdkResult() -> void
-Microsoft.Build.Framework.SdkResultFactory
-Microsoft.Build.Framework.SdkResultFactory.SdkResultFactory() -> void
-Microsoft.Build.Framework.SdkResultItem
-Microsoft.Build.Framework.SdkResultItem.ItemSpec.get -> string
-Microsoft.Build.Framework.SdkResultItem.ItemSpec.set -> void
-Microsoft.Build.Framework.SdkResultItem.Metadata.get -> System.Collections.Generic.Dictionary<string, string>
-Microsoft.Build.Framework.SdkResultItem.SdkResultItem() -> void
-Microsoft.Build.Framework.SdkResultItem.SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) -> void
-Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.AfterTargets = 3 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.BeforeTargets = 1 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.DependsOn = 2 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.None = 0 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetFinishedEventArgs
-Microsoft.Build.Framework.TargetFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs() -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.Collections.IEnumerable targetOutputs) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.DateTime eventTimestamp, System.Collections.IEnumerable targetOutputs) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.set -> void
-Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Framework.TargetSkippedEventArgs
-Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.get -> bool
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.get -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs() -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.ConditionWasFalse = 4 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.None = 0 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.OutputsUpToDate = 3 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltSuccessfully = 1 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltUnsuccessfully = 2 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetStartedEventArgs
-Microsoft.Build.Framework.TargetStartedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetStartedEventArgs.ParentTarget.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs() -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile) -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, Microsoft.Build.Framework.TargetBuiltReason buildReason, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Framework.TaskCommandLineEventArgs
-Microsoft.Build.Framework.TaskCommandLineEventArgs.CommandLine.get -> string
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs() -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs
-Microsoft.Build.Framework.TaskFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFile.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs() -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded) -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Framework.TaskParameterEventArgs
-Microsoft.Build.Framework.TaskParameterEventArgs.Items.get -> System.Collections.IList
-Microsoft.Build.Framework.TaskParameterEventArgs.ItemType.get -> string
-Microsoft.Build.Framework.TaskParameterEventArgs.Kind.get -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterEventArgs.LogItemMetadata.get -> bool
-Microsoft.Build.Framework.TaskParameterEventArgs.TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.AddItem = 2 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.RemoveItem = 3 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetInputs = 4 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetOutputs = 5 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.TaskInput = 0 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.TaskOutput = 1 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskPropertyInfo
-Microsoft.Build.Framework.TaskPropertyInfo.Log.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.Log.set -> void
-Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.set -> void
-Microsoft.Build.Framework.TaskPropertyInfo.Name.get -> string
-Microsoft.Build.Framework.TaskPropertyInfo.Output.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.PropertyType.get -> System.Type
-Microsoft.Build.Framework.TaskPropertyInfo.Required.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) -> void
-Microsoft.Build.Framework.TaskStartedEventArgs
-Microsoft.Build.Framework.TaskStartedEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.TaskStartedEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.TaskStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskFile.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs() -> void
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) -> void
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Framework.TelemetryEventArgs
-Microsoft.Build.Framework.TelemetryEventArgs.EventName.get -> string
-Microsoft.Build.Framework.TelemetryEventArgs.EventName.set -> void
-Microsoft.Build.Framework.TelemetryEventArgs.Properties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.TelemetryEventArgs.Properties.set -> void
-Microsoft.Build.Framework.TelemetryEventArgs.TelemetryEventArgs() -> void
-Microsoft.Build.Framework.TelemetryEventHandler
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs() -> void
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.XamlTypes.Argument
-Microsoft.Build.Framework.XamlTypes.Argument.Argument() -> void
-Microsoft.Build.Framework.XamlTypes.Argument.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.Argument.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.Argument.IsRequired.get -> bool
-Microsoft.Build.Framework.XamlTypes.Argument.IsRequired.set -> void
-Microsoft.Build.Framework.XamlTypes.Argument.Property.get -> string
-Microsoft.Build.Framework.XamlTypes.Argument.Property.set -> void
-Microsoft.Build.Framework.XamlTypes.Argument.Separator.get -> string
-Microsoft.Build.Framework.XamlTypes.Argument.Separator.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Arguments.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Argument>
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Arguments.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.BaseProperty() -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Category.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Category.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.ContainingRule.get -> Microsoft.Build.Framework.XamlTypes.Rule
-Microsoft.Build.Framework.XamlTypes.BaseProperty.DataSource.get -> Microsoft.Build.Framework.XamlTypes.DataSource
-Microsoft.Build.Framework.XamlTypes.BaseProperty.DataSource.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Default.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Default.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Description.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Description.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.F1Keyword.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.F1Keyword.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpContext.get -> int
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpContext.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpFile.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpFile.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpUrl.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.HelpUrl.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.IncludeInCommandLine.get -> bool
-Microsoft.Build.Framework.XamlTypes.BaseProperty.IncludeInCommandLine.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.IsRequired.get -> bool
-Microsoft.Build.Framework.XamlTypes.BaseProperty.IsRequired.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Metadata.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.MultipleValuesAllowed.get -> bool
-Microsoft.Build.Framework.XamlTypes.BaseProperty.MultipleValuesAllowed.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.ReadOnly.get -> bool
-Microsoft.Build.Framework.XamlTypes.BaseProperty.ReadOnly.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Separator.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Separator.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Subcategory.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Subcategory.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Switch.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Switch.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.SwitchPrefix.get -> string
-Microsoft.Build.Framework.XamlTypes.BaseProperty.SwitchPrefix.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.ValueEditors.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.ValueEditor>
-Microsoft.Build.Framework.XamlTypes.BaseProperty.ValueEditors.set -> void
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Visible.get -> bool
-Microsoft.Build.Framework.XamlTypes.BaseProperty.Visible.set -> void
-Microsoft.Build.Framework.XamlTypes.BoolProperty
-Microsoft.Build.Framework.XamlTypes.BoolProperty.BoolProperty() -> void
-Microsoft.Build.Framework.XamlTypes.BoolProperty.ReverseSwitch.get -> string
-Microsoft.Build.Framework.XamlTypes.BoolProperty.ReverseSwitch.set -> void
-Microsoft.Build.Framework.XamlTypes.Category
-Microsoft.Build.Framework.XamlTypes.Category.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.Category.Category() -> void
-Microsoft.Build.Framework.XamlTypes.Category.Description.get -> string
-Microsoft.Build.Framework.XamlTypes.Category.Description.set -> void
-Microsoft.Build.Framework.XamlTypes.Category.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.Category.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.Category.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.Category.HelpString.get -> string
-Microsoft.Build.Framework.XamlTypes.Category.HelpString.set -> void
-Microsoft.Build.Framework.XamlTypes.Category.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.Category.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.Category.Subtype.get -> string
-Microsoft.Build.Framework.XamlTypes.Category.Subtype.set -> void
-Microsoft.Build.Framework.XamlTypes.CategorySchema
-Microsoft.Build.Framework.XamlTypes.CategorySchema.CategorySchema() -> void
-Microsoft.Build.Framework.XamlTypes.ContentType
-Microsoft.Build.Framework.XamlTypes.ContentType.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.ContentType() -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.DefaultContentTypeForItemType.get -> bool
-Microsoft.Build.Framework.XamlTypes.ContentType.DefaultContentTypeForItemType.set -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.ContentType.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.GetMetadata(string metadataName) -> string
-Microsoft.Build.Framework.XamlTypes.ContentType.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.ContentType.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.ContentType.ItemGroupName.get -> string
-Microsoft.Build.Framework.XamlTypes.ContentType.ItemGroupName.set -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.ItemType.get -> string
-Microsoft.Build.Framework.XamlTypes.ContentType.ItemType.set -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
-Microsoft.Build.Framework.XamlTypes.ContentType.Metadata.set -> void
-Microsoft.Build.Framework.XamlTypes.ContentType.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.ContentType.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource
-Microsoft.Build.Framework.XamlTypes.DataSource.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.DataSource() -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.HasConfigurationCondition.get -> bool
-Microsoft.Build.Framework.XamlTypes.DataSource.HasConfigurationCondition.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.ItemType.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.ItemType.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.Label.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.Label.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.MSBuildTarget.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.MSBuildTarget.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.PersistedName.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.PersistedName.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.Persistence.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.Persistence.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.PersistenceStyle.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.PersistenceStyle.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.SourceOfDefaultValue.get -> Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
-Microsoft.Build.Framework.XamlTypes.DataSource.SourceOfDefaultValue.set -> void
-Microsoft.Build.Framework.XamlTypes.DataSource.SourceType.get -> string
-Microsoft.Build.Framework.XamlTypes.DataSource.SourceType.set -> void
-Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
-Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation.AfterContext = 1 -> Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
-Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation.BeforeContext = 0 -> Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.DynamicEnumProperty() -> void
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.EnumProvider.get -> string
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.EnumProvider.set -> void
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.ProviderSettings.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
-Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty.ProviderSettings.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumProperty
-Microsoft.Build.Framework.XamlTypes.EnumProperty.AdmissibleValues.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.EnumValue>
-Microsoft.Build.Framework.XamlTypes.EnumProperty.AdmissibleValues.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumProperty.EnumProperty() -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue
-Microsoft.Build.Framework.XamlTypes.EnumValue.Arguments.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Argument>
-Microsoft.Build.Framework.XamlTypes.EnumValue.Arguments.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.Description.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.Description.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.EnumValue() -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.HelpString.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.HelpString.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.IsDefault.get -> bool
-Microsoft.Build.Framework.XamlTypes.EnumValue.IsDefault.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
-Microsoft.Build.Framework.XamlTypes.EnumValue.Metadata.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.Switch.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.Switch.set -> void
-Microsoft.Build.Framework.XamlTypes.EnumValue.SwitchPrefix.get -> string
-Microsoft.Build.Framework.XamlTypes.EnumValue.SwitchPrefix.set -> void
-Microsoft.Build.Framework.XamlTypes.FileExtension
-Microsoft.Build.Framework.XamlTypes.FileExtension.ContentType.get -> string
-Microsoft.Build.Framework.XamlTypes.FileExtension.ContentType.set -> void
-Microsoft.Build.Framework.XamlTypes.FileExtension.FileExtension() -> void
-Microsoft.Build.Framework.XamlTypes.FileExtension.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.FileExtension.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.FileExtension.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.FileExtension.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.IntProperty
-Microsoft.Build.Framework.XamlTypes.IntProperty.IntProperty() -> void
-Microsoft.Build.Framework.XamlTypes.IntProperty.MaxValue.get -> int?
-Microsoft.Build.Framework.XamlTypes.IntProperty.MaxValue.set -> void
-Microsoft.Build.Framework.XamlTypes.IntProperty.MinValue.get -> int?
-Microsoft.Build.Framework.XamlTypes.IntProperty.MinValue.set -> void
-Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode
-Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.ItemType
-Microsoft.Build.Framework.XamlTypes.ItemType.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.DefaultContentType.get -> string
-Microsoft.Build.Framework.XamlTypes.ItemType.DefaultContentType.set -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.ItemType.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.ItemType.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.ItemType.ItemType() -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.ItemType.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.ItemType.UpToDateCheckInput.get -> bool
-Microsoft.Build.Framework.XamlTypes.ItemType.UpToDateCheckInput.set -> void
-Microsoft.Build.Framework.XamlTypes.NameValuePair
-Microsoft.Build.Framework.XamlTypes.NameValuePair.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.NameValuePair.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.NameValuePair.NameValuePair() -> void
-Microsoft.Build.Framework.XamlTypes.NameValuePair.Value.get -> string
-Microsoft.Build.Framework.XamlTypes.NameValuePair.Value.set -> void
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.Nodes.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode>
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.Nodes.set -> void
-Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions.ProjectSchemaDefinitions() -> void
-Microsoft.Build.Framework.XamlTypes.Rule
-Microsoft.Build.Framework.XamlTypes.Rule.AdditionalInputs.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.AdditionalInputs.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Categories.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Category>
-Microsoft.Build.Framework.XamlTypes.Rule.Categories.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.CommandLine.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.CommandLine.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.DataSource.get -> Microsoft.Build.Framework.XamlTypes.DataSource
-Microsoft.Build.Framework.XamlTypes.Rule.DataSource.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Description.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.Description.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.Rule.EvaluatedCategories.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Category>
-Microsoft.Build.Framework.XamlTypes.Rule.ExecutionDescription.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.ExecutionDescription.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.FileExtension.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.FileExtension.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.GetPropertiesByCategory() -> System.Collections.Specialized.OrderedDictionary
-Microsoft.Build.Framework.XamlTypes.Rule.GetPropertiesInCategory(string categoryName) -> System.Collections.Generic.IList<Microsoft.Build.Framework.XamlTypes.BaseProperty>
-Microsoft.Build.Framework.XamlTypes.Rule.GetProperty(string propertyName) -> Microsoft.Build.Framework.XamlTypes.BaseProperty
-Microsoft.Build.Framework.XamlTypes.Rule.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.Rule.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.Rule.HelpString.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.HelpString.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Metadata.get -> System.Collections.Generic.Dictionary<string, object>
-Microsoft.Build.Framework.XamlTypes.Rule.Metadata.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Name.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.Name.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Order.get -> int
-Microsoft.Build.Framework.XamlTypes.Rule.Order.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Outputs.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.Outputs.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.OverrideMode.get -> Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
-Microsoft.Build.Framework.XamlTypes.Rule.OverrideMode.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.PageTemplate.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.PageTemplate.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Properties.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.BaseProperty>
-Microsoft.Build.Framework.XamlTypes.Rule.Properties.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.PropertyPagesHidden.get -> bool
-Microsoft.Build.Framework.XamlTypes.Rule.PropertyPagesHidden.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Rule() -> void
-Microsoft.Build.Framework.XamlTypes.Rule.Separator.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.Separator.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.ShowOnlyRuleProperties.get -> bool
-Microsoft.Build.Framework.XamlTypes.Rule.ShowOnlyRuleProperties.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.SupportsFileBatching.get -> bool
-Microsoft.Build.Framework.XamlTypes.Rule.SupportsFileBatching.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.SwitchPrefix.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.SwitchPrefix.set -> void
-Microsoft.Build.Framework.XamlTypes.Rule.ToolName.get -> string
-Microsoft.Build.Framework.XamlTypes.Rule.ToolName.set -> void
-Microsoft.Build.Framework.XamlTypes.RuleBag
-Microsoft.Build.Framework.XamlTypes.RuleBag.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.RuleBag.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.RuleBag.GetSchemaObjects(System.Type type) -> System.Collections.Generic.IEnumerable<object>
-Microsoft.Build.Framework.XamlTypes.RuleBag.GetSchemaObjectTypes() -> System.Collections.Generic.IEnumerable<System.Type>
-Microsoft.Build.Framework.XamlTypes.RuleBag.RuleBag() -> void
-Microsoft.Build.Framework.XamlTypes.RuleBag.Rules.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.Rule>
-Microsoft.Build.Framework.XamlTypes.RuleBag.Rules.set -> void
-Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
-Microsoft.Build.Framework.XamlTypes.RuleOverrideMode.Extend = 1 -> Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
-Microsoft.Build.Framework.XamlTypes.RuleOverrideMode.Replace = 0 -> Microsoft.Build.Framework.XamlTypes.RuleOverrideMode
-Microsoft.Build.Framework.XamlTypes.RuleSchema
-Microsoft.Build.Framework.XamlTypes.RuleSchema.RuleSchema() -> void
-Microsoft.Build.Framework.XamlTypes.StringListProperty
-Microsoft.Build.Framework.XamlTypes.StringListProperty.CommandLineValueSeparator.get -> string
-Microsoft.Build.Framework.XamlTypes.StringListProperty.CommandLineValueSeparator.set -> void
-Microsoft.Build.Framework.XamlTypes.StringListProperty.RendererValueSeparator.get -> string
-Microsoft.Build.Framework.XamlTypes.StringListProperty.RendererValueSeparator.set -> void
-Microsoft.Build.Framework.XamlTypes.StringListProperty.StringListProperty() -> void
-Microsoft.Build.Framework.XamlTypes.StringListProperty.Subtype.get -> string
-Microsoft.Build.Framework.XamlTypes.StringListProperty.Subtype.set -> void
-Microsoft.Build.Framework.XamlTypes.StringProperty
-Microsoft.Build.Framework.XamlTypes.StringProperty.StringProperty() -> void
-Microsoft.Build.Framework.XamlTypes.StringProperty.Subtype.get -> string
-Microsoft.Build.Framework.XamlTypes.StringProperty.Subtype.set -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor
-Microsoft.Build.Framework.XamlTypes.ValueEditor.BeginInit() -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor.DisplayName.get -> string
-Microsoft.Build.Framework.XamlTypes.ValueEditor.DisplayName.set -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor.EditorType.get -> string
-Microsoft.Build.Framework.XamlTypes.ValueEditor.EditorType.set -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor.EndInit() -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor.Metadata.get -> System.Collections.Generic.List<Microsoft.Build.Framework.XamlTypes.NameValuePair>
-Microsoft.Build.Framework.XamlTypes.ValueEditor.Metadata.set -> void
-Microsoft.Build.Framework.XamlTypes.ValueEditor.ValueEditor() -> void
-override Microsoft.Build.Framework.BuildEventContext.Equals(object obj) -> bool
-override Microsoft.Build.Framework.BuildEventContext.GetHashCode() -> int
-override Microsoft.Build.Framework.BuildEventContext.ToString() -> string
-override Microsoft.Build.Framework.LazyFormattedBuildEventArgs.Message.get -> string
-override Microsoft.Build.Framework.LoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.GetHashCode() -> int
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.ToString() -> string
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.GetHashCode() -> int
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.ToString() -> string
-override Microsoft.Build.Framework.Profiler.ProfilerResult.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.ProfilerResult.GetHashCode() -> int
-override Microsoft.Build.Framework.ProjectFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.ProjectStartedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.PropertyReassignmentEventArgs.Message.get -> string
-override Microsoft.Build.Framework.SdkReference.Equals(object obj) -> bool
-override Microsoft.Build.Framework.SdkReference.GetHashCode() -> int
-override Microsoft.Build.Framework.SdkReference.ToString() -> string
-override Microsoft.Build.Framework.SdkResultItem.Equals(object obj) -> bool
-override Microsoft.Build.Framework.SdkResultItem.GetHashCode() -> int
-override Microsoft.Build.Framework.TargetFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TargetSkippedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TargetStartedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskParameterEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskStartedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.XamlTypes.EnumProperty.EndInit() -> void
-override Microsoft.Build.Framework.XamlTypes.IntProperty.EndInit() -> void
-static Microsoft.Build.Framework.BuildEventContext.Invalid.get -> Microsoft.Build.Framework.BuildEventContext
-static Microsoft.Build.Framework.BuildEventContext.operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
-static Microsoft.Build.Framework.BuildEventContext.operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForAggregatedGlob() -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForCondition(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForGlob(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForProject(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.EmptyLocation.get -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.SdkReference.TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) -> bool
-virtual Microsoft.Build.Framework.BuildEventArgs.Message.get -> string
-virtual Microsoft.Build.Framework.BuildEventArgs.Message.set -> void
-virtual Microsoft.Build.Framework.EngineServices.IsTaskInputLoggingEnabled.get -> bool
-virtual Microsoft.Build.Framework.EngineServices.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
-virtual Microsoft.Build.Framework.EngineServices.Version.get -> int
-virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.get -> bool
-virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.get -> bool
-virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.Logger.get -> Microsoft.Build.Framework.SdkLogger
-virtual Microsoft.Build.Framework.SdkResolverContext.Logger.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.get -> System.Version
-virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.get -> string
-virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.get -> string
-virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.State.get -> object
-virtual Microsoft.Build.Framework.SdkResolverContext.State.set -> void
-virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.get -> System.Collections.Generic.IList<string>
-virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.set -> void
-virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem>
-virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Path.get -> string
-virtual Microsoft.Build.Framework.SdkResult.Path.set -> void
-virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.get -> System.Collections.Generic.IDictionary<string, string>
-virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.set -> void
-virtual Microsoft.Build.Framework.SdkResult.SdkReference.get -> Microsoft.Build.Framework.SdkReference
-virtual Microsoft.Build.Framework.SdkResult.SdkReference.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Success.get -> bool
-virtual Microsoft.Build.Framework.SdkResult.Success.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Version.get -> string
-virtual Microsoft.Build.Framework.SdkResult.Version.set -> void
-virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd = null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd = null, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-virtual Microsoft.Build.Framework.XamlTypes.BaseProperty.BeginInit() -> void
-virtual Microsoft.Build.Framework.XamlTypes.BaseProperty.EndInit() -> void
\ No newline at end of file
diff --git a/src/Framework/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Framework/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Framework/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Framework/PublicAPI/netstandard/PublicAPI.Shipped.txt
deleted file mode 100644
index fa0dac7c7ef..00000000000
--- a/src/Framework/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,632 +0,0 @@
-abstract Microsoft.Build.Framework.SdkLogger.LogMessage(string message, Microsoft.Build.Framework.MessageImportance messageImportance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-abstract Microsoft.Build.Framework.SdkResolver.Name.get -> string
-abstract Microsoft.Build.Framework.SdkResolver.Priority.get -> int
-abstract Microsoft.Build.Framework.SdkResolver.Resolve(Microsoft.Build.Framework.SdkReference sdkReference, Microsoft.Build.Framework.SdkResolverContext resolverContext, Microsoft.Build.Framework.SdkResultFactory factory) -> Microsoft.Build.Framework.SdkResult
-abstract Microsoft.Build.Framework.SdkResultFactory.IndicateFailure(System.Collections.Generic.IEnumerable<string> errors, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-abstract Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-const Microsoft.Build.Framework.BuildEventContext.InvalidEvaluationId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidNodeId = -2 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidProjectContextId = -2 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidProjectInstanceId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidSubmissionId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidTargetId = -1 -> int
-const Microsoft.Build.Framework.BuildEventContext.InvalidTaskId = -1 -> int
-const Microsoft.Build.Framework.EngineServices.Version1 = 1 -> int
-const Microsoft.Build.Framework.ProjectStartedEventArgs.InvalidProjectId = -1 -> int
-Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Framework.BuildEngineResult
-Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult() -> void
-Microsoft.Build.Framework.BuildEngineResult.BuildEngineResult(bool result, System.Collections.Generic.List<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>> targetOutputsPerProject) -> void
-Microsoft.Build.Framework.BuildEngineResult.Result.get -> bool
-Microsoft.Build.Framework.BuildEngineResult.TargetOutputsPerProject.get -> System.Collections.Generic.IList<System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.ITaskItem[]>>
-Microsoft.Build.Framework.BuildErrorEventArgs
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs() -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.HelpLink.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildErrorEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildErrorEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Framework.BuildEventArgs
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs() -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.BuildEventArgs.BuildEventContext.set -> void
-Microsoft.Build.Framework.BuildEventArgs.HelpKeyword.get -> string
-Microsoft.Build.Framework.BuildEventArgs.RawMessage.get -> string
-Microsoft.Build.Framework.BuildEventArgs.RawMessage.set -> void
-Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.get -> System.DateTime
-Microsoft.Build.Framework.BuildEventArgs.RawTimestamp.set -> void
-Microsoft.Build.Framework.BuildEventArgs.SenderName.get -> string
-Microsoft.Build.Framework.BuildEventArgs.ThreadId.get -> int
-Microsoft.Build.Framework.BuildEventArgs.Timestamp.get -> System.DateTime
-Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int nodeId, int targetId, int projectContextId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int evaluationId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildEventContext(int submissionId, int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId) -> void
-Microsoft.Build.Framework.BuildEventContext.BuildRequestId.get -> long
-Microsoft.Build.Framework.BuildEventContext.EvaluationId.get -> int
-Microsoft.Build.Framework.BuildEventContext.NodeId.get -> int
-Microsoft.Build.Framework.BuildEventContext.ProjectContextId.get -> int
-Microsoft.Build.Framework.BuildEventContext.ProjectInstanceId.get -> int
-Microsoft.Build.Framework.BuildEventContext.SubmissionId.get -> int
-Microsoft.Build.Framework.BuildEventContext.TargetId.get -> int
-Microsoft.Build.Framework.BuildEventContext.TaskId.get -> int
-Microsoft.Build.Framework.BuildFinishedEventArgs
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs() -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Framework.BuildMessageEventArgs
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs() -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.Importance.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.BuildMessageEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildMessageEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildMessageEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Framework.BuildStartedEventArgs
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildEnvironment.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs() -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.Collections.Generic.IDictionary<string, string> environmentOfBuild) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildStartedEventArgs.BuildStartedEventArgs(string message, string helpKeyword, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Framework.BuildStatusEventArgs
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs() -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildStatusEventArgs.BuildStatusEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Framework.BuildWarningEventArgs
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs() -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.Code.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.EndColumnNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.EndLineNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.File.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.HelpLink.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.BuildWarningEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.BuildWarningEventArgs.Subcategory.get -> string
-Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs() -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.CriticalBuildMessageEventArgs.CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs() -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.CustomBuildEventArgs.CustomBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Framework.EngineServices
-Microsoft.Build.Framework.EngineServices.EngineServices() -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.get -> string
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableName.set -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs() -> void
-Microsoft.Build.Framework.EnvironmentVariableReadEventArgs.EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs() -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ExternalProjectFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs() -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames) -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ExternalProjectStartedEventArgs.TargetNames.get -> string
-Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Framework.IBuildEngine.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs) -> bool
-Microsoft.Build.Framework.IBuildEngine.ColumnNumberOfTaskNode.get -> int
-Microsoft.Build.Framework.IBuildEngine.ContinueOnError.get -> bool
-Microsoft.Build.Framework.IBuildEngine.LineNumberOfTaskNode.get -> int
-Microsoft.Build.Framework.IBuildEngine.LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e) -> void
-Microsoft.Build.Framework.IBuildEngine.ProjectFileOfTaskNode.get -> string
-Microsoft.Build.Framework.IBuildEngine10
-Microsoft.Build.Framework.IBuildEngine10.EngineServices.get -> Microsoft.Build.Framework.EngineServices
-Microsoft.Build.Framework.IBuildEngine2
-Microsoft.Build.Framework.IBuildEngine2.BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs, string toolsVersion) -> bool
-Microsoft.Build.Framework.IBuildEngine2.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.IDictionary[] targetOutputsPerProject, string[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion) -> bool
-Microsoft.Build.Framework.IBuildEngine2.IsRunningMultipleNodes.get -> bool
-Microsoft.Build.Framework.IBuildEngine3
-Microsoft.Build.Framework.IBuildEngine3.BuildProjectFilesInParallel(string[] projectFileNames, string[] targetNames, System.Collections.IDictionary[] globalProperties, System.Collections.Generic.IList<string>[] removeGlobalProperties, string[] toolsVersion, bool returnTargetOutputs) -> Microsoft.Build.Framework.BuildEngineResult
-Microsoft.Build.Framework.IBuildEngine3.Reacquire() -> void
-Microsoft.Build.Framework.IBuildEngine3.Yield() -> void
-Microsoft.Build.Framework.IBuildEngine4
-Microsoft.Build.Framework.IBuildEngine4.GetRegisteredTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
-Microsoft.Build.Framework.IBuildEngine4.RegisterTaskObject(object key, object obj, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection) -> void
-Microsoft.Build.Framework.IBuildEngine4.UnregisterTaskObject(object key, Microsoft.Build.Framework.RegisteredTaskObjectLifetime lifetime) -> object
-Microsoft.Build.Framework.IBuildEngine5
-Microsoft.Build.Framework.IBuildEngine5.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
-Microsoft.Build.Framework.IBuildEngine6
-Microsoft.Build.Framework.IBuildEngine6.GetGlobalProperties() -> System.Collections.Generic.IReadOnlyDictionary<string, string>
-Microsoft.Build.Framework.IBuildEngine7
-Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.get -> bool
-Microsoft.Build.Framework.IBuildEngine7.AllowFailureWithoutError.set -> void
-Microsoft.Build.Framework.IBuildEngine8
-Microsoft.Build.Framework.IBuildEngine8.ShouldTreatWarningAsError(string warningCode) -> bool
-Microsoft.Build.Framework.IBuildEngine9
-Microsoft.Build.Framework.IBuildEngine9.ReleaseCores(int coresToRelease) -> void
-Microsoft.Build.Framework.IBuildEngine9.RequestCores(int requestedCores) -> int
-Microsoft.Build.Framework.ICancelableTask
-Microsoft.Build.Framework.ICancelableTask.Cancel() -> void
-Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Framework.IEventRedirector.ForwardEvent(Microsoft.Build.Framework.BuildEventArgs buildEvent) -> void
-Microsoft.Build.Framework.IEventSource
-Microsoft.Build.Framework.IEventSource.AnyEventRaised -> Microsoft.Build.Framework.AnyEventHandler
-Microsoft.Build.Framework.IEventSource.BuildFinished -> Microsoft.Build.Framework.BuildFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.BuildStarted -> Microsoft.Build.Framework.BuildStartedEventHandler
-Microsoft.Build.Framework.IEventSource.CustomEventRaised -> Microsoft.Build.Framework.CustomBuildEventHandler
-Microsoft.Build.Framework.IEventSource.ErrorRaised -> Microsoft.Build.Framework.BuildErrorEventHandler
-Microsoft.Build.Framework.IEventSource.MessageRaised -> Microsoft.Build.Framework.BuildMessageEventHandler
-Microsoft.Build.Framework.IEventSource.ProjectFinished -> Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.ProjectStarted -> Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Framework.IEventSource.StatusEventRaised -> Microsoft.Build.Framework.BuildStatusEventHandler
-Microsoft.Build.Framework.IEventSource.TargetFinished -> Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.TargetStarted -> Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Framework.IEventSource.TaskFinished -> Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Framework.IEventSource.TaskStarted -> Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Framework.IEventSource.WarningRaised -> Microsoft.Build.Framework.BuildWarningEventHandler
-Microsoft.Build.Framework.IEventSource2
-Microsoft.Build.Framework.IEventSource2.TelemetryLogged -> Microsoft.Build.Framework.TelemetryEventHandler
-Microsoft.Build.Framework.IEventSource3
-Microsoft.Build.Framework.IEventSource3.IncludeEvaluationMetaprojects() -> void
-Microsoft.Build.Framework.IEventSource3.IncludeEvaluationProfiles() -> void
-Microsoft.Build.Framework.IEventSource3.IncludeTaskInputs() -> void
-Microsoft.Build.Framework.IEventSource4
-Microsoft.Build.Framework.IEventSource4.IncludeEvaluationPropertiesAndItems() -> void
-Microsoft.Build.Framework.IForwardingLogger
-Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.get -> Microsoft.Build.Framework.IEventRedirector
-Microsoft.Build.Framework.IForwardingLogger.BuildEventRedirector.set -> void
-Microsoft.Build.Framework.IForwardingLogger.NodeId.get -> int
-Microsoft.Build.Framework.IForwardingLogger.NodeId.set -> void
-Microsoft.Build.Framework.IGeneratedTask
-Microsoft.Build.Framework.IGeneratedTask.GetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property) -> object
-Microsoft.Build.Framework.IGeneratedTask.SetPropertyValue(Microsoft.Build.Framework.TaskPropertyInfo property, object value) -> void
-Microsoft.Build.Framework.ILogger
-Microsoft.Build.Framework.ILogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Framework.ILogger.Parameters.get -> string
-Microsoft.Build.Framework.ILogger.Parameters.set -> void
-Microsoft.Build.Framework.ILogger.Shutdown() -> void
-Microsoft.Build.Framework.ILogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.ILogger.Verbosity.set -> void
-Microsoft.Build.Framework.INodeLogger
-Microsoft.Build.Framework.INodeLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int nodeCount) -> void
-Microsoft.Build.Framework.IProjectElement
-Microsoft.Build.Framework.IProjectElement.ElementName.get -> string
-Microsoft.Build.Framework.IProjectElement.OuterElement.get -> string
-Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Framework.ITask.BuildEngine.set -> void
-Microsoft.Build.Framework.ITask.Execute() -> bool
-Microsoft.Build.Framework.ITask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Framework.ITask.HostObject.set -> void
-Microsoft.Build.Framework.ITaskFactory
-Microsoft.Build.Framework.ITaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Framework.ITaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITaskFactory.FactoryName.get -> string
-Microsoft.Build.Framework.ITaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Framework.ITaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Framework.ITaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Framework.ITaskFactory2
-Microsoft.Build.Framework.ITaskFactory2.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost, System.Collections.Generic.IDictionary<string, string> taskIdentityParameters) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Framework.ITaskFactory2.Initialize(string taskName, System.Collections.Generic.IDictionary<string, string> factoryIdentityParameters, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Framework.ITaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
-Microsoft.Build.Framework.ITaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
-Microsoft.Build.Framework.ITaskItem.GetMetadata(string metadataName) -> string
-Microsoft.Build.Framework.ITaskItem.ItemSpec.get -> string
-Microsoft.Build.Framework.ITaskItem.ItemSpec.set -> void
-Microsoft.Build.Framework.ITaskItem.MetadataCount.get -> int
-Microsoft.Build.Framework.ITaskItem.MetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.Framework.ITaskItem.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Framework.ITaskItem.SetMetadata(string metadataName, string metadataValue) -> void
-Microsoft.Build.Framework.ITaskItem2
-Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped() -> System.Collections.IDictionary
-Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.get -> string
-Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped.set -> void
-Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string metadataName) -> string
-Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue) -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs() -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName) -> void
-Microsoft.Build.Framework.LazyFormattedBuildEventArgs.LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName, System.DateTime eventTimestamp, params object[] messageArgs) -> void
-Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute
-Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute.LoadInSeparateAppDomainAttribute() -> void
-Microsoft.Build.Framework.LoggerException
-Microsoft.Build.Framework.LoggerException.ErrorCode.get -> string
-Microsoft.Build.Framework.LoggerException.HelpKeyword.get -> string
-Microsoft.Build.Framework.LoggerException.LoggerException() -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(string message, System.Exception innerException, string errorCode, string helpKeyword) -> void
-Microsoft.Build.Framework.LoggerException.LoggerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Detailed = 3 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Diagnostic = 4 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Minimal = 1 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Normal = 2 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.LoggerVerbosity.Quiet = 0 -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.High = 0 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.Low = 2 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MessageImportance.Normal = 1 -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPath, string message) -> void
-Microsoft.Build.Framework.MetaprojectGeneratedEventArgs.metaprojectXml -> string
-Microsoft.Build.Framework.OutputAttribute
-Microsoft.Build.Framework.OutputAttribute.OutputAttribute() -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementDescription.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ElementName.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation() -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long id, long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationLocation(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationPassDescription, string file, int? line, string elementName, string elementDescription, Microsoft.Build.Framework.Profiler.EvaluationLocationKind kind) -> void
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPass.get -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationLocation.EvaluationPassDescription.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.File.get -> string
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Id.get -> long
-Microsoft.Build.Framework.Profiler.EvaluationLocation.IsEvaluationPass.get -> bool
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Kind.get -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocation.Line.get -> int?
-Microsoft.Build.Framework.Profiler.EvaluationLocation.ParentId.get -> long?
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithEvaluationPass(Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string passDescription = null) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFile(string file) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndCondition(string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithFileLineAndElement(string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithGlob(string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocation.WithParentId(long? parentId) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Condition = 1 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Element = 0 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationLocationKind.Glob = 2 -> Microsoft.Build.Framework.Profiler.EvaluationLocationKind
-Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.InitialProperties = 2 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.ItemDefinitionGroups = 4 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Items = 5 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.LazyItems = 6 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Properties = 3 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.Targets = 8 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.TotalEvaluation = 0 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.TotalGlobbing = 1 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.EvaluationPass.UsingTasks = 7 -> Microsoft.Build.Framework.Profiler.EvaluationPass
-Microsoft.Build.Framework.Profiler.ProfiledLocation
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ExclusiveTime.get -> System.TimeSpan
-Microsoft.Build.Framework.Profiler.ProfiledLocation.InclusiveTime.get -> System.TimeSpan
-Microsoft.Build.Framework.Profiler.ProfiledLocation.NumberOfHits.get -> int
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation() -> void
-Microsoft.Build.Framework.Profiler.ProfiledLocation.ProfiledLocation(System.TimeSpan inclusiveTime, System.TimeSpan exclusiveTime, int numberOfHits) -> void
-Microsoft.Build.Framework.Profiler.ProfilerResult
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfiledLocations.get -> System.Collections.Generic.IReadOnlyDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation>
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult() -> void
-Microsoft.Build.Framework.Profiler.ProfilerResult.ProfilerResult(System.Collections.Generic.IDictionary<Microsoft.Build.Framework.Profiler.EvaluationLocation, Microsoft.Build.Framework.Profiler.ProfiledLocation> profiledLocations) -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.GlobalProperties.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Items.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.get -> Microsoft.Build.Framework.Profiler.ProfilerResult?
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProfilerResult.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs() -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs.Properties.set -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs() -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs.ProjectFile.set -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs() -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded) -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.ProjectFinishedEventHandler
-Microsoft.Build.Framework.ProjectImportedEventArgs
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.get -> string
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportedProjectFile.set -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.get -> bool
-Microsoft.Build.Framework.ProjectImportedEventArgs.ImportIgnored.set -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs() -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.ProjectImportedEventArgs(int lineNumber, int columnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.get -> string
-Microsoft.Build.Framework.ProjectImportedEventArgs.UnexpandedProject.set -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs
-Microsoft.Build.Framework.ProjectStartedEventArgs.GlobalProperties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.ProjectStartedEventArgs.Items.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectStartedEventArgs.ParentProjectBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectId.get -> int
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs() -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.Collections.Generic.IDictionary<string, string> globalProperties, string toolsVersion) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, Microsoft.Build.Framework.BuildEventContext parentBuildEventContext, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, System.Collections.IEnumerable properties, System.Collections.IEnumerable items, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.ProjectStartedEventArgs.Properties.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.ProjectStartedEventArgs.TargetNames.get -> string
-Microsoft.Build.Framework.ProjectStartedEventArgs.ToolsVersion.get -> string
-Microsoft.Build.Framework.ProjectStartedEventHandler
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs() -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertySource.set -> void
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.get -> string
-Microsoft.Build.Framework.PropertyInitialValueSetEventArgs.PropertyValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.Location.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.NewValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PreviousValue.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs() -> void
-Microsoft.Build.Framework.PropertyReassignmentEventArgs.PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime.AppDomain = 1 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RegisteredTaskObjectLifetime.Build = 0 -> Microsoft.Build.Framework.RegisteredTaskObjectLifetime
-Microsoft.Build.Framework.RequiredAttribute
-Microsoft.Build.Framework.RequiredAttribute.RequiredAttribute() -> void
-Microsoft.Build.Framework.RequiredRuntimeAttribute
-Microsoft.Build.Framework.RequiredRuntimeAttribute.RequiredRuntimeAttribute(string runtimeVersion) -> void
-Microsoft.Build.Framework.RequiredRuntimeAttribute.RuntimeVersion.get -> string
-Microsoft.Build.Framework.RunInMTAAttribute
-Microsoft.Build.Framework.RunInMTAAttribute.RunInMTAAttribute() -> void
-Microsoft.Build.Framework.RunInSTAAttribute
-Microsoft.Build.Framework.RunInSTAAttribute.RunInSTAAttribute() -> void
-Microsoft.Build.Framework.SdkLogger
-Microsoft.Build.Framework.SdkLogger.SdkLogger() -> void
-Microsoft.Build.Framework.SdkReference
-Microsoft.Build.Framework.SdkReference.Equals(Microsoft.Build.Framework.SdkReference other) -> bool
-Microsoft.Build.Framework.SdkReference.MinimumVersion.get -> string
-Microsoft.Build.Framework.SdkReference.Name.get -> string
-Microsoft.Build.Framework.SdkReference.SdkReference(string name, string version, string minimumVersion) -> void
-Microsoft.Build.Framework.SdkReference.Version.get -> string
-Microsoft.Build.Framework.SdkResolver
-Microsoft.Build.Framework.SdkResolver.SdkResolver() -> void
-Microsoft.Build.Framework.SdkResolverContext
-Microsoft.Build.Framework.SdkResolverContext.SdkResolverContext() -> void
-Microsoft.Build.Framework.SdkResult
-Microsoft.Build.Framework.SdkResult.SdkResult() -> void
-Microsoft.Build.Framework.SdkResultFactory
-Microsoft.Build.Framework.SdkResultFactory.SdkResultFactory() -> void
-Microsoft.Build.Framework.SdkResultItem
-Microsoft.Build.Framework.SdkResultItem.ItemSpec.get -> string
-Microsoft.Build.Framework.SdkResultItem.ItemSpec.set -> void
-Microsoft.Build.Framework.SdkResultItem.Metadata.get -> System.Collections.Generic.Dictionary<string, string>
-Microsoft.Build.Framework.SdkResultItem.SdkResultItem() -> void
-Microsoft.Build.Framework.SdkResultItem.SdkResultItem(string itemSpec, System.Collections.Generic.Dictionary<string, string> metadata) -> void
-Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.AfterTargets = 3 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.BeforeTargets = 1 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.DependsOn = 2 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetBuiltReason.None = 0 -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetFinishedEventArgs
-Microsoft.Build.Framework.TargetFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs() -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.Collections.IEnumerable targetOutputs) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, System.DateTime eventTimestamp, System.Collections.IEnumerable targetOutputs) -> void
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.get -> System.Collections.IEnumerable
-Microsoft.Build.Framework.TargetFinishedEventArgs.TargetOutputs.set -> void
-Microsoft.Build.Framework.TargetFinishedEventHandler
-Microsoft.Build.Framework.TargetSkippedEventArgs
-Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetSkippedEventArgs.BuildReason.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.Condition.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.EvaluatedCondition.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.get -> Microsoft.Build.Framework.BuildEventContext
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginalBuildEventContext.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.get -> bool
-Microsoft.Build.Framework.TargetSkippedEventArgs.OriginallySucceeded.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.ParentTarget.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.get -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkippedEventArgs.SkipReason.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetFile.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetName.set -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs() -> void
-Microsoft.Build.Framework.TargetSkippedEventArgs.TargetSkippedEventArgs(string message, params object[] messageArgs) -> void
-Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.ConditionWasFalse = 4 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.None = 0 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.OutputsUpToDate = 3 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltSuccessfully = 1 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetSkipReason.PreviouslyBuiltUnsuccessfully = 2 -> Microsoft.Build.Framework.TargetSkipReason
-Microsoft.Build.Framework.TargetStartedEventArgs
-Microsoft.Build.Framework.TargetStartedEventArgs.BuildReason.get -> Microsoft.Build.Framework.TargetBuiltReason
-Microsoft.Build.Framework.TargetStartedEventArgs.ParentTarget.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetFile.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetName.get -> string
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs() -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile) -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, Microsoft.Build.Framework.TargetBuiltReason buildReason, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TargetStartedEventArgs.TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TargetStartedEventHandler
-Microsoft.Build.Framework.TaskCommandLineEventArgs
-Microsoft.Build.Framework.TaskCommandLineEventArgs.CommandLine.get -> string
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs() -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance) -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskCommandLineEventArgs(string commandLine, string taskName, Microsoft.Build.Framework.MessageImportance importance, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskCommandLineEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs
-Microsoft.Build.Framework.TaskFinishedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs.Succeeded.get -> bool
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFile.get -> string
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs() -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded) -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskFinishedEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskFinishedEventHandler
-Microsoft.Build.Framework.TaskParameterEventArgs
-Microsoft.Build.Framework.TaskParameterEventArgs.Items.get -> System.Collections.IList
-Microsoft.Build.Framework.TaskParameterEventArgs.ItemType.get -> string
-Microsoft.Build.Framework.TaskParameterEventArgs.Kind.get -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterEventArgs.LogItemMetadata.get -> bool
-Microsoft.Build.Framework.TaskParameterEventArgs.TaskParameterEventArgs(Microsoft.Build.Framework.TaskParameterMessageKind kind, string itemType, System.Collections.IList items, bool logItemMetadata, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.AddItem = 2 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.RemoveItem = 3 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetInputs = 4 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.SkippedTargetOutputs = 5 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.TaskInput = 0 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskParameterMessageKind.TaskOutput = 1 -> Microsoft.Build.Framework.TaskParameterMessageKind
-Microsoft.Build.Framework.TaskPropertyInfo
-Microsoft.Build.Framework.TaskPropertyInfo.Log.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.Log.set -> void
-Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.LogItemMetadata.set -> void
-Microsoft.Build.Framework.TaskPropertyInfo.Name.get -> string
-Microsoft.Build.Framework.TaskPropertyInfo.Output.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.PropertyType.get -> System.Type
-Microsoft.Build.Framework.TaskPropertyInfo.Required.get -> bool
-Microsoft.Build.Framework.TaskPropertyInfo.TaskPropertyInfo(string name, System.Type typeOfParameter, bool output, bool required) -> void
-Microsoft.Build.Framework.TaskStartedEventArgs
-Microsoft.Build.Framework.TaskStartedEventArgs.ColumnNumber.get -> int
-Microsoft.Build.Framework.TaskStartedEventArgs.LineNumber.get -> int
-Microsoft.Build.Framework.TaskStartedEventArgs.ProjectFile.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskFile.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskName.get -> string
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs() -> void
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName) -> void
-Microsoft.Build.Framework.TaskStartedEventArgs.TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, System.DateTime eventTimestamp) -> void
-Microsoft.Build.Framework.TaskStartedEventHandler
-Microsoft.Build.Framework.TelemetryEventArgs
-Microsoft.Build.Framework.TelemetryEventArgs.EventName.get -> string
-Microsoft.Build.Framework.TelemetryEventArgs.EventName.set -> void
-Microsoft.Build.Framework.TelemetryEventArgs.Properties.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Framework.TelemetryEventArgs.Properties.set -> void
-Microsoft.Build.Framework.TelemetryEventArgs.TelemetryEventArgs() -> void
-Microsoft.Build.Framework.TelemetryEventHandler
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.get -> string
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.PropertyName.set -> void
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs() -> void
-Microsoft.Build.Framework.UninitializedPropertyReadEventArgs.UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword = null, string senderName = null, Microsoft.Build.Framework.MessageImportance importance = Microsoft.Build.Framework.MessageImportance.Low) -> void
-override Microsoft.Build.Framework.BuildEventContext.Equals(object obj) -> bool
-override Microsoft.Build.Framework.BuildEventContext.GetHashCode() -> int
-override Microsoft.Build.Framework.BuildEventContext.ToString() -> string
-override Microsoft.Build.Framework.LazyFormattedBuildEventArgs.Message.get -> string
-override Microsoft.Build.Framework.LoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) -> void
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.GetHashCode() -> int
-override Microsoft.Build.Framework.Profiler.EvaluationLocation.ToString() -> string
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.GetHashCode() -> int
-override Microsoft.Build.Framework.Profiler.ProfiledLocation.ToString() -> string
-override Microsoft.Build.Framework.Profiler.ProfilerResult.Equals(object obj) -> bool
-override Microsoft.Build.Framework.Profiler.ProfilerResult.GetHashCode() -> int
-override Microsoft.Build.Framework.ProjectFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.ProjectStartedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.PropertyReassignmentEventArgs.Message.get -> string
-override Microsoft.Build.Framework.SdkReference.Equals(object obj) -> bool
-override Microsoft.Build.Framework.SdkReference.GetHashCode() -> int
-override Microsoft.Build.Framework.SdkReference.ToString() -> string
-override Microsoft.Build.Framework.SdkResultItem.Equals(object obj) -> bool
-override Microsoft.Build.Framework.SdkResultItem.GetHashCode() -> int
-override Microsoft.Build.Framework.TargetFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TargetSkippedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TargetStartedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskFinishedEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskParameterEventArgs.Message.get -> string
-override Microsoft.Build.Framework.TaskStartedEventArgs.Message.get -> string
-static Microsoft.Build.Framework.BuildEventContext.Invalid.get -> Microsoft.Build.Framework.BuildEventContext
-static Microsoft.Build.Framework.BuildEventContext.operator !=(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
-static Microsoft.Build.Framework.BuildEventContext.operator ==(Microsoft.Build.Framework.BuildEventContext left, Microsoft.Build.Framework.BuildEventContext right) -> bool
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForAggregatedGlob() -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForCondition(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string condition) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForGlob(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, string globDescription) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.CreateLocationForProject(long? parentId, Microsoft.Build.Framework.Profiler.EvaluationPass evaluationPass, string evaluationDescription, string file, int? line, Microsoft.Build.Framework.IProjectElement element) -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.Profiler.EvaluationLocation.EmptyLocation.get -> Microsoft.Build.Framework.Profiler.EvaluationLocation
-static Microsoft.Build.Framework.SdkReference.TryParse(string sdk, out Microsoft.Build.Framework.SdkReference sdkReference) -> bool
-virtual Microsoft.Build.Framework.BuildEventArgs.Message.get -> string
-virtual Microsoft.Build.Framework.BuildEventArgs.Message.set -> void
-virtual Microsoft.Build.Framework.EngineServices.IsTaskInputLoggingEnabled.get -> bool
-virtual Microsoft.Build.Framework.EngineServices.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
-virtual Microsoft.Build.Framework.EngineServices.Version.get -> int
-virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.get -> bool
-virtual Microsoft.Build.Framework.SdkResolverContext.Interactive.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.get -> bool
-virtual Microsoft.Build.Framework.SdkResolverContext.IsRunningInVisualStudio.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.Logger.get -> Microsoft.Build.Framework.SdkLogger
-virtual Microsoft.Build.Framework.SdkResolverContext.Logger.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.get -> System.Version
-virtual Microsoft.Build.Framework.SdkResolverContext.MSBuildVersion.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.get -> string
-virtual Microsoft.Build.Framework.SdkResolverContext.ProjectFilePath.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.get -> string
-virtual Microsoft.Build.Framework.SdkResolverContext.SolutionFilePath.set -> void
-virtual Microsoft.Build.Framework.SdkResolverContext.State.get -> object
-virtual Microsoft.Build.Framework.SdkResolverContext.State.set -> void
-virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.get -> System.Collections.Generic.IList<string>
-virtual Microsoft.Build.Framework.SdkResult.AdditionalPaths.set -> void
-virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.get -> System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem>
-virtual Microsoft.Build.Framework.SdkResult.ItemsToAdd.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Path.get -> string
-virtual Microsoft.Build.Framework.SdkResult.Path.set -> void
-virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.get -> System.Collections.Generic.IDictionary<string, string>
-virtual Microsoft.Build.Framework.SdkResult.PropertiesToAdd.set -> void
-virtual Microsoft.Build.Framework.SdkResult.SdkReference.get -> Microsoft.Build.Framework.SdkReference
-virtual Microsoft.Build.Framework.SdkResult.SdkReference.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Success.get -> bool
-virtual Microsoft.Build.Framework.SdkResult.Success.set -> void
-virtual Microsoft.Build.Framework.SdkResult.Version.get -> string
-virtual Microsoft.Build.Framework.SdkResult.Version.set -> void
-virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(string path, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
-virtual Microsoft.Build.Framework.SdkResultFactory.IndicateSuccess(System.Collections.Generic.IEnumerable<string> paths, string version, System.Collections.Generic.IDictionary<string, string> propertiesToAdd = null, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.SdkResultItem> itemsToAdd = null, System.Collections.Generic.IEnumerable<string> warnings = null) -> Microsoft.Build.Framework.SdkResult
\ No newline at end of file
diff --git a/src/Framework/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Framework/PublicAPI/netstandard/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Framework/ResponseFileUsedEventArgs.cs b/src/Framework/ResponseFileUsedEventArgs.cs
new file mode 100644
index 00000000000..28e4200402f
--- /dev/null
+++ b/src/Framework/ResponseFileUsedEventArgs.cs
@@ -0,0 +1,26 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Arguments for the response file used event
+    /// </summary>
+    [Serializable]
+    public class ResponseFileUsedEventArgs : BuildMessageEventArgs
+    {
+        public ResponseFileUsedEventArgs()
+        {
+        }
+        /// <summary>
+        /// Initialize a new instance of the ResponseFileUsedEventArgs class.
+        /// </summary>
+        public ResponseFileUsedEventArgs(string responseFilePath) : base()
+        {
+            ResponseFilePath = responseFilePath;
+        }
+        public string? ResponseFilePath { set; get; }
+    }
+}
diff --git a/src/Framework/Sdk/SdkResultItem.cs b/src/Framework/Sdk/SdkResultItem.cs
index febbbeffabc..7feba81b7e6 100644
--- a/src/Framework/Sdk/SdkResultItem.cs
+++ b/src/Framework/Sdk/SdkResultItem.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics.CodeAnalysis;
 using System.Linq;
 
 namespace Microsoft.Build.Framework
diff --git a/src/Framework/StringBuilderCache.cs b/src/Framework/StringBuilderCache.cs
index e8b0ebb30cb..5b21061d9ae 100644
--- a/src/Framework/StringBuilderCache.cs
+++ b/src/Framework/StringBuilderCache.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Diagnostics;
 using System.Text;
-#if !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+#if DEBUG && !CLR2COMPATIBILITY && !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
 using Microsoft.Build.Eventing;
 #endif
 
diff --git a/src/Framework/VisualStudioLocationHelper.cs b/src/Framework/VisualStudioLocationHelper.cs
index 4ec70063990..be2ec623f5b 100644
--- a/src/Framework/VisualStudioLocationHelper.cs
+++ b/src/Framework/VisualStudioLocationHelper.cs
@@ -1,7 +1,7 @@
 ﻿using System;
 using System.Collections.Generic;
-using System.Runtime.InteropServices;
 #if FEATURE_VISUALSTUDIOSETUP
+using System.Runtime.InteropServices;
 using Microsoft.VisualStudio.Setup.Configuration;
 #endif
 
diff --git a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
index 0c8de11cf8e..9eedf618d79 100644
--- a/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
+++ b/src/MSBuild.Bootstrap/MSBuild.Bootstrap.csproj
@@ -25,6 +25,10 @@
     <!-- Include NuGet build tasks -->
     <PackageReference Include="NuGet.Build.Tasks" />
     <PackageReference Include="Microsoft.Build.NuGetSdkResolver" />
+
+    <!-- As of 17.5, NuGet.Build.Tasks and Microsoft.Build.NuGetSdkResolver depends on Newtonsoft.Json version 13.0.1,
+         causing it to be downloaded and flagged by component governance -->
+    <PackageReference Include="Newtonsoft.Json" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(MonoBuild)' == 'true'">
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 25ee319e5ee..484875710d0 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -990,7 +990,7 @@ public void InvalidToolsVersionErrors()
                 string filename = null;
                 try
                 {
-                    filename = FileUtilities.GetTemporaryFile();
+                    filename = FileUtilities.GetTemporaryFileName();
                     ProjectRootElement project = ProjectRootElement.Create();
                     project.Save(filename);
                     MSBuildApp.BuildProject(
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
index 44e1b3a9c67..e211fc36115 100644
--- a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -281,6 +281,44 @@ public void ServerShouldNotStartWhenBuildIsInteractive()
             pidOfInitialProcess.ShouldBe(pidOfServerProcess, "We started a server node even when build is interactive.");
         }
 
+        [Fact]
+        public void PropertyMSBuildStartupDirectoryOnServer()
+        {
+            string reportMSBuildStartupDirectoryProperty = @$"
+<Project>
+    <UsingTask TaskName=""ProcessIdTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
+	<Target Name=""DisplayMessages"">
+        <ProcessIdTask>
+            <Output PropertyName=""PID"" TaskParameter=""Pid"" />
+        </ProcessIdTask>
+        <Message Text=""Server ID is $(PID)"" Importance=""High"" />
+		<Message Text="":MSBuildStartupDirectory:$(MSBuildStartupDirectory):"" Importance=""high"" />
+	</Target> 
+</Project>";
+
+            TransientTestFile project = _env.CreateFile("testProject.proj", reportMSBuildStartupDirectoryProperty);
+            _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
+
+            // Start on current working directory
+            string output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, $"/t:DisplayMessages {project.Path}", out bool success, false, _output);
+            success.ShouldBeTrue();
+            int pidOfServerProcess = ParseNumber(output, "Server ID is ");
+            _env.WithTransientProcess(pidOfServerProcess);
+            output.ShouldContain($@":MSBuildStartupDirectory:{Environment.CurrentDirectory}:");
+
+            // Start on transient project directory
+            _env.SetCurrentDirectory(Path.GetDirectoryName(project.Path));
+            output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, $"/t:DisplayMessages {project.Path}", out success, false, _output);
+            int pidOfNewServerProcess = ParseNumber(output, "Server ID is ");
+            if (pidOfServerProcess != pidOfNewServerProcess)
+            {
+                // Register process to clean up (be killed) after tests ends.
+                _env.WithTransientProcess(pidOfNewServerProcess);
+            }
+            pidOfNewServerProcess.ShouldBe(pidOfServerProcess);
+            output.ShouldContain($@":MSBuildStartupDirectory:{Environment.CurrentDirectory}:");
+        }
+
         private int ParseNumber(string searchString, string toFind)
         {
             Regex regex = new(@$"{toFind}(\d+)");
diff --git a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
index 31985adeda6..91839f18a69 100644
--- a/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
+++ b/src/MSBuild.UnitTests/ProjectSchemaValidationHandler_Tests.cs
@@ -80,7 +80,7 @@ public void VerifyInvalidSchemaItself1()
                 Environment.SetEnvironmentVariable("MSBuildOldOM", "");
 
                 // Create schema files in the temp folder
-                invalidSchemaFile = FileUtilities.GetTemporaryFile();
+                invalidSchemaFile = FileUtilities.GetTemporaryFileName();
 
                 File.WriteAllText(invalidSchemaFile, "<this_is_invalid_schema_content/>");
 
@@ -120,7 +120,7 @@ public void VerifyInvalidSchemaItself2()
                 Environment.SetEnvironmentVariable("MSBuildOldOM", "");
 
                 // Create schema files in the temp folder
-                invalidSchemaFile = FileUtilities.GetTemporaryFile();
+                invalidSchemaFile = FileUtilities.GetTemporaryFileName();
 
                 File.WriteAllText(invalidSchemaFile, @"<?xml version=""1.0"" encoding=""UTF-8""?>
 <xs:schema targetNamespace=""http://schemas.microsoft.com/developer/msbuild/2003"" xmlns:msb=""http://schemas.microsoft.com/developer/msbuild/2003"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" elementFormDefault=""qualified"">
@@ -342,7 +342,7 @@ static internal string CreateTempFileOnDisk(string fileContents, params object[]
         /// this project everything that ObjectModelHelpers depends on</remarks>
         static internal string CreateTempFileOnDiskNoFormat(string fileContents)
         {
-            string projectFilePath = FileUtilities.GetTemporaryFile();
+            string projectFilePath = FileUtilities.GetTemporaryFileName();
 
             File.WriteAllText(projectFilePath, CleanupFileContents(fileContents));
 
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index c8bb054cdd1..0c8aba65fc0 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -47,6 +47,7 @@ internal enum ParameterlessSwitch
             FileLogger8,
             FileLogger9,
             DistributedFileLogger,
+            FancyLogger,
 #if DEBUG
             WaitForDebugger,
 #endif
@@ -221,6 +222,7 @@ bool emptyParametersAllowed
             new ParameterlessSwitchInfo(  new string[] { "filelogger8", "fl8" },            ParameterlessSwitch.FileLogger8,           null),
             new ParameterlessSwitchInfo(  new string[] { "filelogger9", "fl9" },            ParameterlessSwitch.FileLogger9,           null),
             new ParameterlessSwitchInfo(  new string[] { "distributedfilelogger", "dfl" },  ParameterlessSwitch.DistributedFileLogger, null),
+            new ParameterlessSwitchInfo(  new string[] { "fancylogger", "flg" },            ParameterlessSwitch.FancyLogger,           null),
 #if DEBUG
             new ParameterlessSwitchInfo(  new string[] { "waitfordebugger", "wfd" },        ParameterlessSwitch.WaitForDebugger,       null),
 #endif
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 2fd51da537c..0ef742fdc22 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -241,8 +241,10 @@
     <ProjectReference Include="..\Tasks\Microsoft.Build.Tasks.csproj" />
   </ItemGroup>
 
+  <!-- Xsds are not TF or arch-specific so copy once them in the outer build -->
   <Target Name="CopyXsds"
-          BeforeTargets="AfterBuild">
+          BeforeTargets="Build"
+          Condition="'$(IsInnerBuild)' != 'true'">
     <Copy SourceFiles="@(XsdsForVS)"
           DestinationFiles="@(XsdsForVS->'$([MSBuild]::NormalizeDirectory('$(ArtifactsDir)', 'xsd'))%(RecursiveDir)%(Filename)%(Extension)')"
           SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 1288ac675c6..4a3d1904bc1 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -38,6 +38,8 @@
 using Microsoft.Build.Experimental;
 using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Internal;
+using Microsoft.Build.Logging.FancyLogger;
+using System.Runtime.InteropServices;
 
 #nullable disable
 
@@ -126,7 +128,7 @@ public enum ExitType
         private static readonly CancellationTokenSource s_buildCancellationSource = new CancellationTokenSource();
 
         private static readonly char[] s_commaSemicolon = { ',', ';' };
-
+ 
         /// <summary>
         /// Static constructor
         /// </summary>
@@ -1085,6 +1087,11 @@ private static void ResetGatheringSwitchesState()
         /// </summary>
         private const string msbuildLogFileName = "msbuild.log";
 
+        /// <summary>
+        /// List of messages to be sent to the logger when it is attached
+        /// </summary>
+        private static List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = new();
+
         /// <summary>
         /// Initializes the build engine, and starts the project building.
         /// </summary>
@@ -1324,11 +1331,12 @@ string[] commandLine
                         }
                     }
 
+                    // List<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = null;
+
                     BuildManager buildManager = BuildManager.DefaultBuildManager;
 
                     BuildResultCode? result = null;
 
-                    IEnumerable<BuildManager.DeferredBuildMessage> messagesToLogInBuildLoggers = null;
                     if (!Traits.Instance.EscapeHatches.DoNotSendDeferredMessagesToBuildManager)
                     {
                         var commandLineString =
@@ -1337,7 +1345,18 @@ string[] commandLine
 #else
                             string.Join(" ", commandLine);
 #endif
-                        messagesToLogInBuildLoggers = GetMessagesToLogInBuildLoggers(commandLineString);
+                        messagesToLogInBuildLoggers.AddRange(GetMessagesToLogInBuildLoggers(commandLineString));
+
+                        // Log a message for every response file and include it in log
+                        foreach (var responseFilePath in s_includedResponseFiles)
+                        {
+                            messagesToLogInBuildLoggers.Add(
+                                new BuildManager.DeferredBuildMessage(
+                                    String.Format("Included response file: {0}", responseFilePath),
+                                    MessageImportance.Normal,
+                                    responseFilePath
+                                ));
+                        }
                     }
 
                     buildManager.BeginBuild(parameters, messagesToLogInBuildLoggers);
@@ -1492,7 +1511,7 @@ private static bool PrintTargets(string projectFile, string toolsVersion, Dictio
             }
         }
 
-        private static IEnumerable<BuildManager.DeferredBuildMessage> GetMessagesToLogInBuildLoggers(string commandLineString)
+        private static List<BuildManager.DeferredBuildMessage> GetMessagesToLogInBuildLoggers(string commandLineString)
         {
             List<BuildManager.DeferredBuildMessage> messages = new()
             {
@@ -2415,6 +2434,7 @@ string commandLine
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],
+                        commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.FancyLogger], 
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
@@ -3199,6 +3219,7 @@ private static ILogger[] ProcessLoggingSwitches
             string[] verbositySwitchParameters,
             bool noConsoleLogger,
             bool distributedFileLogger,
+            bool fancyLoggerCommandLineOptIn, 
             string[] fileLoggerParameters,
             string[] consoleLoggerParameters,
             string[] binaryLoggerParameters,
@@ -3228,7 +3249,15 @@ out bool enableProfiler
             // Add any loggers which have been specified on the commandline
             distributedLoggerRecords = ProcessDistributedLoggerSwitch(distributedLoggerSwitchParameters, verbosity);
 
-            ProcessConsoleLoggerSwitch(noConsoleLogger, consoleLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
+            // Choose default console logger
+            if ((fancyLoggerCommandLineOptIn || Environment.GetEnvironmentVariable("MSBUILDFANCYLOGGER") == "true") && DoesEnvironmentSupportFancyLogger())
+            {
+                ProcessFancyLogger(noConsoleLogger, loggers);
+            }
+            else
+            {
+                ProcessConsoleLoggerSwitch(noConsoleLogger, consoleLoggerParameters, distributedLoggerRecords, verbosity, cpuCount, loggers);
+            }
 
             ProcessDistributedFileLogger(distributedFileLogger, fileLoggerParameters, distributedLoggerRecords, loggers, cpuCount);
 
@@ -3236,6 +3265,9 @@ out bool enableProfiler
 
             ProcessBinaryLogger(binaryLoggerParameters, loggers, ref verbosity);
 
+            // TOOD: Review
+            // ProcessFancyLogger(noConsoleLogger, loggers);
+
             profilerLogger = ProcessProfileEvaluationSwitch(profileEvaluationParameters, loggers, out enableProfiler);
 
             return loggers.ToArray();
@@ -3398,6 +3430,43 @@ List<ILogger> loggers
             }
         }
 
+        private static bool DoesEnvironmentSupportFancyLogger()
+        {
+            // If output is redirected
+            if (Console.IsOutputRedirected)
+            {
+                messagesToLogInBuildLoggers.Add(
+                    new BuildManager.DeferredBuildMessage("FancyLogger was not used because the output is being redirected to a file.", MessageImportance.Low)
+                );
+                return false;
+            }
+            // If terminal is dumb
+            if (
+                (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && Environment.GetEnvironmentVariable("WT_SESSION") == "")
+                || Environment.GetEnvironmentVariable("TERM") == "dumb"
+            )
+            {
+                messagesToLogInBuildLoggers.Add(
+                    new BuildManager.DeferredBuildMessage("FancyLogger was not used because the output is not supported.", MessageImportance.Low)
+                );
+                return false;
+            }
+            return true;
+        }
+
+        private static void ProcessFancyLogger(
+            bool noConsoleLogger,
+            List<ILogger> loggers
+        )
+        {
+            // Check for flags and env variables
+            if (!noConsoleLogger)
+            {
+                FancyLogger l = new FancyLogger();
+                loggers.Add(l);
+            }
+        }
+
         /// <summary>
         /// Returns a DistributedLoggerRecord containing this logger and a ConfigurableForwardingLogger.
         /// Looks at the logger's parameters for any verbosity parameter in order to make sure it is setting up the ConfigurableForwardingLogger
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index ce9f6d2557c..664d8a094c5 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -180,7 +180,8 @@
         <property name="MSBuildFrameworkToolsPathArm64" value="$(SystemRoot)\Microsoft.NET\FrameworkArm64\v$(MSBuildRuntimeVersion)\" />
         <property name="MSBuildFrameworkToolsRoot" value="$(SystemRoot)\Microsoft.NET\Framework\" />
         <property name="SDK35ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.0A\WinSDK-NetFx35Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
-        <property name="SDK40ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
+        <!-- Attempt to use net4.8.1 if possible, falling back to 4.8 when unavailable. -->
+        <property name="SDK40ToolsPath" value="$([MSBuild]::ValueOrDefault($([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32)), $([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))))" />
         <property name="WindowsSDK80Path" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.1', 'InstallationFolder', null, RegistryView.Registry32))" />
         <property name="VsInstallRoot" value="$([MSBuild]::GetVsInstallRoot())" />
         <property name="MSBuildToolsRoot" value="$(VsInstallRoot)\MSBuild" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index f537c444eea..8864b5931da 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -150,7 +150,8 @@
         <property name="MSBuildFrameworkToolsPathArm64" value="$(SystemRoot)\Microsoft.NET\FrameworkArm64\v$(MSBuildRuntimeVersion)\" />
         <property name="MSBuildFrameworkToolsRoot" value="$(SystemRoot)\Microsoft.NET\Framework\" />
         <property name="SDK35ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.0A\WinSDK-NetFx35Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
-        <property name="SDK40ToolsPath" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))" />
+        <!-- Attempt to use net4.8.1 if possible, falling back to 4.8 when unavailable. -->
+        <property name="SDK40ToolsPath" value="$([MSBuild]::ValueOrDefault($([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32)), $([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86', 'InstallationFolder', null, RegistryView.Registry32))))" />
         <property name="WindowsSDK80Path" value="$([MSBuild]::GetRegistryValueFromView('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\Windows\v8.1', 'InstallationFolder', null, RegistryView.Registry32))" />
         <property name="VsInstallRoot" value="$([MSBuild]::GetVsInstallRoot())" />
         <property name="MSBuildToolsRoot" value="$(VsInstallRoot)\MSBuild" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index ec7f04055ae..0628e295bd9 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -62,6 +62,7 @@
       <Link>ITaskItem2.cs</Link>
     </Compile>
     <Compile Include="..\Framework\AssemblyUtilities.cs" />
+    <Compile Include="..\Framework\ResponseFileUsedEventArgs.cs" />
     <Compile Include="..\Shared\BufferedReadStream.cs" />
     <Compile Include="..\Shared\CollectionHelpers.cs" />
     <Compile Include="..\Shared\CopyOnWriteDictionary.cs">
diff --git a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
index f001f9d07ca..9e4f47ac424 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
+++ b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
@@ -6,6 +6,7 @@ package name=Microsoft.Build.Arm64
         vs.package.language=neutral
 
 vs.relatedProcessFiles
+  vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\arm64\Microsoft.Build.dll"
   vs.relatedProcessFile Path="[InstallDir]\MSBuild\Current\Bin\arm64\Microsoft.Build.Tasks.Core.dll"
 
 folder InstallDir:\MSBuild\Current\Bin\arm64
@@ -13,6 +14,7 @@ folder InstallDir:\MSBuild\Current\Bin\arm64
   file source=$(Arm64BinPath)MSBuild.exe.config
 
   file source=$(FrameworkBinPath)x64\Microsoft.Build.Framework.tlb
+  file source=$(Arm64BinPath)Microsoft.Build.dll vs.file.ngenArchitecture=arm64
   file source=$(Arm64BinPath)Microsoft.Build.Tasks.Core.dll vs.file.ngenArchitecture=arm64
   file source=$(Arm64BinPath)Microsoft.Common.CurrentVersion.targets
   file source=$(Arm64BinPath)Microsoft.Common.CrossTargeting.targets
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index 90d1c081d5c..a2a6120ec55 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -10,10 +10,6 @@
 using System.Runtime.Serialization;
 using System.IO;
 using Microsoft.Build.BackEnd;
-#if FEATURE_ASSEMBLYLOADCONTEXT
-using System.Reflection.PortableExecutable;
-using System.Reflection.Metadata;
-#endif
 
 #nullable disable
 
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 86438f1da31..05abbdbab95 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Globalization;
-using System.Reflection;
 
 #nullable disable
 
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index 6d5d9ebfd74..e67cbcbd153 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -10,7 +10,6 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
-using System.Reflection;
 
 #nullable disable
 
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 0aa08501488..e21e214cb78 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -8,7 +8,9 @@
 using System.IO;
 using System.IO.Pipes;
 using System.Runtime.InteropServices;
+#if FEATURE_SECURITY_PRINCIPAL_WINDOWS
 using System.Security.Principal;
+#endif
 using System.Threading;
 
 using Microsoft.Build.Framework;
@@ -680,25 +682,20 @@ internal static void Trace(int nodeId, string format, params object[] args)
             {
                 lock (s_traceLock)
                 {
-                    if (s_debugDumpPath == null)
-                    {
-                        s_debugDumpPath =
+                    s_debugDumpPath ??=
 #if CLR2COMPATIBILITY
                         Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #else
-                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                            ? DebugUtils.DebugPath
-                            : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+                        DebugUtils.DebugPath;
 #endif
 
-                        if (String.IsNullOrEmpty(s_debugDumpPath))
-                        {
-                            s_debugDumpPath = FileUtilities.TempFileDirectory;
-                        }
-                        else
-                        {
-                            Directory.CreateDirectory(s_debugDumpPath);
-                        }
+                    if (String.IsNullOrEmpty(s_debugDumpPath))
+                    {
+                        s_debugDumpPath = FileUtilities.TempFileDirectory;
+                    }
+                    else
+                    {
+                        Directory.CreateDirectory(s_debugDumpPath);
                     }
 
                     try
@@ -711,16 +708,14 @@ internal static void Trace(int nodeId, string format, params object[] args)
 
                         fileName += ".txt";
 
-                        using (StreamWriter file =
-                               FileUtilities.OpenWrite(String.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), Process.GetCurrentProcess().Id, nodeId),
-                                   append: true))
+                        using (StreamWriter file = FileUtilities.OpenWrite(
+                            String.Format(CultureInfo.CurrentCulture, Path.Combine(s_debugDumpPath, fileName), Process.GetCurrentProcess().Id, nodeId), append: true))
                         {
                             string message = String.Format(CultureInfo.CurrentCulture, format, args);
                             long now = DateTime.UtcNow.Ticks;
                             float millisecondsSinceLastLog = (float)(now - s_lastLoggedTicks) / 10000L;
                             s_lastLoggedTicks = now;
-                            file.WriteLine("{0} (TID {1}) {2,15} +{3,10}ms: {4}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, now, millisecondsSinceLastLog,
-                                message);
+                            file.WriteLine("{0} (TID {1}) {2,15} +{3,10}ms: {4}", Thread.CurrentThread.Name, Thread.CurrentThread.ManagedThreadId, now, millisecondsSinceLastLog, message);
                         }
                     }
                     catch (IOException)
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 71af8039f57..74afacbce8a 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -2,7 +2,6 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
-using Microsoft.Build.Utilities;
 using System;
 using System.Collections.Generic;
 using System.Diagnostics;
diff --git a/src/Shared/Debugging/DebugUtils.cs b/src/Shared/Debugging/DebugUtils.cs
index 3ae6cf16891..3ebdad82043 100644
--- a/src/Shared/Debugging/DebugUtils.cs
+++ b/src/Shared/Debugging/DebugUtils.cs
@@ -5,7 +5,6 @@
 using System;
 using System.Diagnostics;
 using System.IO;
-using System.Security;
 using System.Text.RegularExpressions;
 
 #nullable disable
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index 7584322ff2b..62110039952 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -3,11 +3,9 @@
 
 using System;
 using System.Collections.Generic;
-using System.Diagnostics;
 using System.IO;
 using System.Reflection;
 using System.Runtime.CompilerServices;
-using System.Text.RegularExpressions;
 using Microsoft.Build.Framework;
 using CommonWriterType = System.Action<string, string, System.Collections.Generic.IEnumerable<string>>;
 
diff --git a/src/Shared/EscapingUtilities.cs b/src/Shared/EscapingUtilities.cs
index 51a9e9465d2..905e705fcf9 100644
--- a/src/Shared/EscapingUtilities.cs
+++ b/src/Shared/EscapingUtilities.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Collections.Generic;
-using System.Globalization;
 using System.Text;
 
 using Microsoft.Build.Framework;
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index 7c0db803f70..ace6e1e8159 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Globalization;
-using System.Text;
 
 using Microsoft.Build.Framework;
 
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index 3f0b910b267..8752511e6b8 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -47,9 +47,7 @@ private static string GetDebugDumpPath()
 #if CLR2COMPATIBILITY || MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
                         Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
 #else
-                ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
-                    ? DebugUtils.DebugPath
-                    : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+                DebugUtils.DebugPath;
 #endif
 
             return !string.IsNullOrEmpty(debugPath)
diff --git a/src/Shared/FileSystem/ManagedFileSystem.cs b/src/Shared/FileSystem/ManagedFileSystem.cs
index 894249cbd64..c36cc5dee1b 100644
--- a/src/Shared/FileSystem/ManagedFileSystem.cs
+++ b/src/Shared/FileSystem/ManagedFileSystem.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
 using System;
 using System.Collections.Generic;
 using System.IO;
@@ -24,7 +23,7 @@ private static bool ShouldUseMicrosoftIO
             get
             {
 #if !MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
-                return ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0) && NativeMethodsShared.IsWindows;
+                return NativeMethodsShared.IsWindows;
 #else
                 // We need to mock usage of ChangeWaves class,
                 // because Microsoft.Build.Engine.OM.UnitTests should not have access to internals of Microsoft.Build.Framework.
diff --git a/src/Shared/FrameworkLocationHelper.cs b/src/Shared/FrameworkLocationHelper.cs
index 01ff320cf7d..28f8a292848 100644
--- a/src/Shared/FrameworkLocationHelper.cs
+++ b/src/Shared/FrameworkLocationHelper.cs
@@ -7,7 +7,9 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.Versioning;
+#if FEATURE_WIN32_REGISTRY
 using Microsoft.Win32;
+#endif
 
 using Microsoft.Build.Shared.FileSystem;
 
@@ -61,6 +63,7 @@ internal static class FrameworkLocationHelper
         internal static readonly Version dotNetFrameworkVersion471 = new Version(4, 7, 1);
         internal static readonly Version dotNetFrameworkVersion472 = new Version(4, 7, 2);
         internal static readonly Version dotNetFrameworkVersion48 = new Version(4, 8);
+        internal static readonly Version dotNetFrameworkVersion481 = new Version(4, 8, 1);
 
         // visual studio versions.
         internal static readonly Version visualStudioVersion100 = new Version(10, 0);
@@ -217,6 +220,9 @@ internal static class FrameworkLocationHelper
 
             // v4.8
             CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion48, visualStudioVersion150),
+
+            // v4.8.1
+            CreateDotNetFrameworkSpecForV4(dotNetFrameworkVersion481, visualStudioVersion170),
         };
 
         /// <summary>
@@ -327,6 +333,7 @@ internal static class FrameworkLocationHelper
                 dotNetFrameworkVersion471,
                 dotNetFrameworkVersion472,
                 dotNetFrameworkVersion48,
+                dotNetFrameworkVersion481,
             }),
         });
 
@@ -373,6 +380,18 @@ private static readonly (Version, Version)[,] s_explicitFallbackRulesForPathToDo
             { (dotNetFrameworkVersion471, visualStudioVersion160), (dotNetFrameworkVersion47, visualStudioVersion160) },
             { (dotNetFrameworkVersion472, visualStudioVersion160), (dotNetFrameworkVersion471, visualStudioVersion160) },
             { (dotNetFrameworkVersion48, visualStudioVersion160), (dotNetFrameworkVersion472, visualStudioVersion160) },
+
+            // VS 17
+            { (dotNetFrameworkVersion451, visualStudioVersion170), (dotNetFrameworkVersion45, visualStudioVersion170) },
+            { (dotNetFrameworkVersion452, visualStudioVersion170), (dotNetFrameworkVersion451, visualStudioVersion170) },
+            { (dotNetFrameworkVersion46, visualStudioVersion170), (dotNetFrameworkVersion451, visualStudioVersion170) },
+            { (dotNetFrameworkVersion461, visualStudioVersion170), (dotNetFrameworkVersion46, visualStudioVersion170) },
+            { (dotNetFrameworkVersion462, visualStudioVersion170), (dotNetFrameworkVersion461, visualStudioVersion170) },
+            { (dotNetFrameworkVersion47, visualStudioVersion170), (dotNetFrameworkVersion462, visualStudioVersion170) },
+            { (dotNetFrameworkVersion471, visualStudioVersion170), (dotNetFrameworkVersion47, visualStudioVersion170) },
+            { (dotNetFrameworkVersion472, visualStudioVersion170), (dotNetFrameworkVersion471, visualStudioVersion170) },
+            { (dotNetFrameworkVersion48, visualStudioVersion170), (dotNetFrameworkVersion472, visualStudioVersion170) },
+            { (dotNetFrameworkVersion481, visualStudioVersion170), (dotNetFrameworkVersion48, visualStudioVersion170) },
         };
 #endif // FEATURE_WIN32_REGISTRY
 
@@ -1212,7 +1231,11 @@ public string GetDotNetFrameworkSdkRegistryKey(Version dotNetSdkVersion)
             {
                 string sdkVersionFolder = "4.6"; // Default for back-compat
 
-                if (dotNetSdkVersion == dotNetFrameworkVersion48)
+                if (dotNetSdkVersion == dotNetFrameworkVersion481)
+                {
+                    sdkVersionFolder = "4.8.1";
+                }
+                else if (dotNetSdkVersion == dotNetFrameworkVersion48)
                 {
                     sdkVersionFolder = "4.8";
                 }
@@ -1380,10 +1403,14 @@ public virtual string GetPathToDotNetFramework(DotNetFrameworkArchitecture archi
                                     Directory.GetDirectories,
                                     architecture);
 
-                // .net was improperly uninstalled: msbuild.exe isn't there
+                // Assume if either MSBuild.exe or Microsoft.Build.dll are shipped, there is a valid install.
+                // Note: net481 did not ship an ARM64 MSBuild.exe, so checking its dll's is the fallback for a valid install.
+                // Context: https://github.com/dotnet/msbuild/pull/7689
                 if (this._hasMsBuild &&
                     generatedPathToDotNetFramework != null &&
-                    !FileSystems.Default.FileExists(Path.Combine(generatedPathToDotNetFramework, NativeMethodsShared.IsWindows ? "MSBuild.exe" : "mcs.exe")))
+                    (!FileSystems.Default.FileExists(Path.Combine(generatedPathToDotNetFramework, NativeMethodsShared.IsWindows ? "MSBuild.exe" : "mcs.exe")) &&
+                     !FileSystems.Default.FileExists(Path.Combine(generatedPathToDotNetFramework, "Microsoft.Build.dll")))
+                    )
                 {
                     return null;
                 }
diff --git a/src/Shared/InprocTrackingNativeMethods.cs b/src/Shared/InprocTrackingNativeMethods.cs
index cbdd7b59d96..bd0bae9633a 100644
--- a/src/Shared/InprocTrackingNativeMethods.cs
+++ b/src/Shared/InprocTrackingNativeMethods.cs
@@ -11,9 +11,6 @@
 #endif
 using System.Security;
 using Microsoft.Build.Shared.FileSystem;
-#if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
-#endif
 #if FEATURE_RESOURCE_EXPOSURE
 using System.Runtime.Versioning;
 #endif
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index c7181787b69..0b2500390a3 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -2,10 +2,8 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 9f625373ed9..7d518897aa6 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -135,6 +135,11 @@ internal enum LoggingEventType : int
         /// Event is an EnvironmentVariableReadEventArgs
         /// </summary>
         EnvironmentVariableReadEvent = 19,
+
+        /// <summary>
+        /// Event is a ResponseFileUsedEventArgs
+        /// </summary>
+        ResponseFileUsedEvent = 20
     }
     #endregion
 
@@ -517,6 +522,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
                 LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
                 LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
+                LoggingEventType.ResponseFileUsedEvent => new ResponseFileUsedEventArgs(null),
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
                 LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
                 LoggingEventType.ProjectEvaluationStartedEvent => new ProjectEvaluationStartedEventArgs(),
@@ -619,6 +625,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.EnvironmentVariableReadEvent;
             }
+            else if (eventType == typeof(ResponseFileUsedEventArgs))
+            {
+                return LoggingEventType.ResponseFileUsedEvent;
+            }
             else
             {
                 return LoggingEventType.CustomEvent;
@@ -658,6 +668,9 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
                 case LoggingEventType.BuildMessageEvent:
                     WriteBuildMessageEventToStream((BuildMessageEventArgs)buildEvent, translator);
                     break;
+                case LoggingEventType.ResponseFileUsedEvent:
+                    WriteResponseFileUsedEventToStream((ResponseFileUsedEventArgs)buildEvent, translator);
+                    break;
                 case LoggingEventType.TaskCommandLineEvent:
                     WriteTaskCommandLineEventToStream((TaskCommandLineEventArgs)buildEvent, translator);
                     break;
@@ -800,6 +813,15 @@ private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEv
             translator.TranslateEnum(ref importance, (int)importance);
         }
 
+        /// <summary>
+        /// Write a response file used log message into the translator
+        /// </summary>
+        private void WriteResponseFileUsedEventToStream(ResponseFileUsedEventArgs responseFileUsedEventArgs, ITranslator translator)
+        {
+            string filePath = responseFileUsedEventArgs.ResponseFilePath;
+            translator.Translate(ref filePath);
+        }
+
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
         private void WriteProjectEvaluationStartedEventToStream(ProjectEvaluationStartedEventArgs args, ITranslator translator)
         {
@@ -1037,6 +1059,7 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
                 LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),
+                LoggingEventType.ResponseFileUsedEvent => ReadResponseFileUsedEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),
                 LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),
                 _ => null,
@@ -1218,6 +1241,14 @@ private BuildMessageEventArgs ReadBuildMessageEventFromStream(ITranslator transl
             return buildEvent;
         }
 
+        private ResponseFileUsedEventArgs ReadResponseFileUsedEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
+        {
+            string responseFilePath = String.Empty;
+            translator.Translate(ref responseFilePath);
+            ResponseFileUsedEventArgs buildEvent = new ResponseFileUsedEventArgs(responseFilePath);
+            return buildEvent;
+        }
+
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
         private ProjectEvaluationStartedEventArgs ReadProjectEvaluationStartedEventFromStream(ITranslator translator)
         {
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index d8102f69f4e..d3ff339ced3 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -1,9 +1,11 @@
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Utilities;
+#if BUILD_ENGINE
 using Microsoft.Build.BackEnd;
-using Microsoft.Build.Evaluation;
+#else
+using Microsoft.Build.Utilities;
+#endif
 
 namespace Microsoft.Build.Shared
 {
@@ -77,6 +79,13 @@ internal static string GetNearestPlatform(string referencedProjectPlatform, stri
                     // Platform/PlatformTarget when this is the case.
                     log?.LogWarningWithCodeFromResources("GetCompatiblePlatform.NoCompatiblePlatformFound", projectPath);
                 }
+                // If the referenced project has a defined `Platform` that's compatible, it will build that way by default.
+                // If we're about to tell the reference to build using its default platform, don't pass it as a global property.
+                if (!string.IsNullOrEmpty(referencedProjectPlatform) && referencedProjectPlatform.Equals(buildProjectReferenceAs, StringComparison.OrdinalIgnoreCase))
+                {
+                    log?.LogMessageFromResources(MessageImportance.Low, "GetCompatiblePlatform.ReferencedProjectHasDefinitivePlatform", projectPath, referencedProjectPlatform);
+                    buildProjectReferenceAs = string.Empty;
+                }
             return buildProjectReferenceAs;
         }
         internal static Dictionary<string, string>? ExtractLookupTable(string stringTable, TaskLoggingHelper? log = null)
diff --git a/src/Shared/ResourceUtilities.cs b/src/Shared/ResourceUtilities.cs
index 1146f026158..bf7fe3035c8 100644
--- a/src/Shared/ResourceUtilities.cs
+++ b/src/Shared/ResourceUtilities.cs
@@ -2,8 +2,10 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+#if !BUILDINGAPPXTASKS && DEBUG
 using System.Resources;
 using System.Diagnostics;
+#endif
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.ComponentModel;
diff --git a/src/Shared/StrongNameHelpers.cs b/src/Shared/StrongNameHelpers.cs
index d0187a100da..d176b2c40a8 100644
--- a/src/Shared/StrongNameHelpers.cs
+++ b/src/Shared/StrongNameHelpers.cs
@@ -1,14 +1,14 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_STRONG_NAMES
+
 using System;
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 using System.Diagnostics.CodeAnalysis;
 using System.Reflection;
 
-#if FEATURE_STRONG_NAMES
-
 #nullable disable
 
 namespace Microsoft.Runtime.Hosting
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index c7e900625b8..c9dd8991a6a 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -8,7 +8,9 @@
 using System.Globalization;
 using System.Linq;
 using System.Reflection;
+#if FEATURE_APPDOMAIN
 using System.Security;
+#endif
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
diff --git a/src/Shared/TaskParameterTypeVerifier.cs b/src/Shared/TaskParameterTypeVerifier.cs
index 4048d4f736d..7ac8fa58f67 100644
--- a/src/Shared/TaskParameterTypeVerifier.cs
+++ b/src/Shared/TaskParameterTypeVerifier.cs
@@ -2,9 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Reflection;
 using Microsoft.Build.Framework;
+#if NET35
 using Microsoft.Build.Shared;
-using System.Reflection;
+#endif
 
 #nullable disable
 
diff --git a/src/Shared/TempFileUtilities.cs b/src/Shared/TempFileUtilities.cs
index c0583acb483..50c2e6628be 100644
--- a/src/Shared/TempFileUtilities.cs
+++ b/src/Shared/TempFileUtilities.cs
@@ -85,6 +85,18 @@ internal static string GetTemporaryDirectory(bool createDirectory = true, string
             return temporaryDirectory;
         }
 
+        /// <summary>
+        /// Generates a unique temporary file name with a given extension in the temporary folder.
+        /// File is guaranteed to be unique.
+        /// Extension may have an initial period.
+        /// File will NOT be created.
+        /// May throw IOException.
+        /// </summary>
+        internal static string GetTemporaryFileName()
+        {
+            return GetTemporaryFileName(".tmp");
+        }
+
         /// <summary>
         /// Generates a unique temporary file name with a given extension in the temporary folder.
         /// File is guaranteed to be unique.
diff --git a/src/Shared/ToolsetElement.cs b/src/Shared/ToolsetElement.cs
index 3e96ab7c6cb..21c374dea84 100644
--- a/src/Shared/ToolsetElement.cs
+++ b/src/Shared/ToolsetElement.cs
@@ -6,7 +6,6 @@
 using System.Configuration;
 using System.IO;
 using Microsoft.Build.Collections;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -31,32 +30,25 @@ internal static class ToolsetConfigurationReaderHelpers
 
         internal static ToolsetConfigurationSection ReadToolsetConfigurationSection(Configuration configuration)
         {
-            if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+            if (configuration == null)
             {
-                if (configuration == null)
-                {
-                    return null;
-                }
+                return null;
+            }
 
-                lock (s_syncLock)
+            lock (s_syncLock)
+            {
+                // Cache 1st requested configuration section. In unit tests, different Configuration is provided for particular test cases.
+                // During runtime, however, only MSBuild exe configuration file is provided to read toolset configuration from,
+                //   and modifying MSBuild exe configuration during lifetime of msbuild nodes is neither expected nor supported.
+                if (s_toolsetConfigurationSectionCache == null)
                 {
-                    // Cache 1st requested configuration section. In unit tests, different Configuration is provided for particular test cases.
-                    // During runtime, however, only MSBuild exe configuration file is provided to read toolset configuration from,
-                    //   and modifying MSBuild exe configuration during lifetime of msbuild nodes is neither expected nor supported.
-                    if (s_toolsetConfigurationSectionCache == null)
-                    {
-                        s_toolsetConfigurationSectionCache = GetToolsetConfigurationSection(configuration);
-                        s_configurationOfCachedSection = configuration;
-                    }
-
-                    return s_configurationOfCachedSection == configuration ?
-                        s_toolsetConfigurationSectionCache :
-                        GetToolsetConfigurationSection(configuration);
+                    s_toolsetConfigurationSectionCache = GetToolsetConfigurationSection(configuration);
+                    s_configurationOfCachedSection = configuration;
                 }
-            }
-            else
-            {
-                return GetToolsetConfigurationSection(configuration);
+
+                return s_configurationOfCachedSection == configuration ?
+                    s_toolsetConfigurationSectionCache :
+                    GetToolsetConfigurationSection(configuration);
             }
         }
 
diff --git a/src/Shared/Tracing.cs b/src/Shared/Tracing.cs
index 09184fe4666..625006b9718 100644
--- a/src/Shared/Tracing.cs
+++ b/src/Shared/Tracing.cs
@@ -5,7 +5,9 @@
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
+#if DEBUG
 using System.Reflection;
+#endif
 
 #nullable disable
 
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index 825bc0a41d3..40d28f23b29 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -8,9 +8,6 @@
 using System.IO;
 using System.Reflection;
 using System.Runtime.InteropServices;
-#if !NETFRAMEWORK
-using System.Runtime.Loader;
-#endif
 using System.Threading;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Framework;
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index e29d3e3a89c..7f6d55178ac 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -1268,27 +1268,6 @@ public void IllegalPaths()
             ValidateIllegal("http://www.website.com");
         }
 
-        [Fact]
-        [PlatformSpecific(TestPlatforms.Windows)] // Nothing's too long for Unix
-        [SkipOnTargetFramework(TargetFrameworkMonikers.Netcoreapp)]
-        public void IllegalTooLongPathOptOutWave17_0()
-        {
-            using (var env = TestEnvironment.Create())
-            {
-                ChangeWaves.ResetStateForTests();
-                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_0.ToString());
-                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
-
-                string longString = new string('X', 500) + "*"; // need a wildcard to do anything
-                string[] result = FileMatcher.Default.GetFiles(@"c:\", longString).FileList;
-
-                Assert.Equal(longString, result[0]); // Does not throw
-                ChangeWaves.ResetStateForTests();
-            }
-            // Not checking that GetFileSpecMatchInfo returns the illegal-path flag,
-            // not certain that won't break something; this fix is merely to avoid a crash.
-        }
-
         [Fact]
         public void SplitFileSpec()
         {
diff --git a/src/Shared/UnitTests/FileUtilities_Tests.cs b/src/Shared/UnitTests/FileUtilities_Tests.cs
index 7e87e2217af..006a7b607d8 100644
--- a/src/Shared/UnitTests/FileUtilities_Tests.cs
+++ b/src/Shared/UnitTests/FileUtilities_Tests.cs
@@ -901,6 +901,7 @@ public void GenerateTempBatchFileWithBadExtension()
             }
            );
         }
+
         /// <summary>
         /// Directory is invalid
         /// </summary>
diff --git a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
index 825ccaeb1d4..a5652d24cf0 100644
--- a/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
+++ b/src/Shared/UnitTests/NativeMethodsShared_Tests.cs
@@ -77,9 +77,7 @@ public void TestGetProcAddress()
         [Fact]
         public void GetLastWriteFileUtcTimeReturnsMinValueForMissingFile()
         {
-            string nonexistentFile = FileUtilities.GetTemporaryFile();
-            // Make sure that the file does not, in fact, exist.
-            File.Delete(nonexistentFile);
+            string nonexistentFile = FileUtilities.GetTemporaryFileName();
 
             DateTime nonexistentFileTime = NativeMethodsShared.GetLastWriteFileUtcTime(nonexistentFile);
             Assert.Equal(DateTime.MinValue, nonexistentFileTime);
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 1f65afed8cd..a8f02e7d2cc 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1817,7 +1817,11 @@ private static string[] SplitPathIntoFragments(string path)
         /// </summary>
         internal static void DeleteFiles(params string[] paths)
         {
-            foreach (string path in paths)
+            // When we delete the file directory which has the sub folder/file firstly, it will not be deleted since not empty.
+            // So sort paths descendingly by file directory length, it will delete sub folder/file at first.
+            var pathsSortedByDepth = paths.OrderByDescending(x => Path.GetDirectoryName(Path.GetFullPath(x)).Length);
+
+            foreach (string path in pathsSortedByDepth)
             {
                 if (FileSystems.Default.FileExists(path))
                 {
diff --git a/src/Shared/UnitTests/XmakeAttributes_Tests.cs b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
index 1dff7e28c37..3f51a4c8233 100644
--- a/src/Shared/UnitTests/XmakeAttributes_Tests.cs
+++ b/src/Shared/UnitTests/XmakeAttributes_Tests.cs
@@ -132,7 +132,7 @@ public void TestMergeRuntimeValuesCurrentToCore()
         [Fact]
         public void TestArchitectureValuesMatch()
         {
-            string currentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x64 : XMakeAttributes.MSBuildArchitectureValues.x86;
+            string currentArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
             string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
             Assert.True(XMakeAttributes.ArchitectureValuesMatch(XMakeAttributes.MSBuildArchitectureValues.any, XMakeAttributes.MSBuildArchitectureValues.currentArchitecture));
@@ -147,7 +147,7 @@ public void TestArchitectureValuesMatch()
         [Fact]
         public void TestMergeArchitectureValues()
         {
-            string currentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x64 : XMakeAttributes.MSBuildArchitectureValues.x86;
+            string currentArchitecture = XMakeAttributes.GetCurrentMSBuildArchitecture();
             string notCurrentArchitecture = EnvironmentUtilities.Is64BitProcess ? XMakeAttributes.MSBuildArchitectureValues.x86 : XMakeAttributes.MSBuildArchitectureValues.x64;
 
             string mergedArchitecture;
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index 1018c4b79aa..94cd21f7169 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -6,7 +6,6 @@
 #if !CLR2COMPATIBILITY
 using System.Runtime.InteropServices;
 #endif
-using System.Runtime.CompilerServices;
 
 #nullable disable
 
diff --git a/src/StringTools/CompatibilitySuppressions.xml b/src/StringTools/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..b2f2578762f
--- /dev/null
+++ b/src/StringTools/CompatibilitySuppressions.xml
@@ -0,0 +1,8 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <Suppression>
+    <!-- Dropped net35 for 17.5; see https://github.com/dotnet/msbuild/pull/8198 -->
+    <DiagnosticId>PKV006</DiagnosticId>
+    <Target>.NETFramework,Version=v3.5</Target>
+  </Suppression>
+</Suppressions>
diff --git a/src/StringTools/InternableString.Simple.cs b/src/StringTools/InternableString.Simple.cs
index 88126da5c6f..7dd2b72b9ac 100644
--- a/src/StringTools/InternableString.Simple.cs
+++ b/src/StringTools/InternableString.Simple.cs
@@ -2,9 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Linq.Expressions;
 using System.Text;
 
 namespace System
@@ -34,12 +31,12 @@ namespace Microsoft.NET.StringTools
     /// <remarks>
     /// This is a simple and inefficient implementation compatible with .NET Framework 3.5.
     /// </remarks>
-    internal ref struct InternableString
+    internal struct InternableString
     {
         /// <summary>
         /// Enumerator for the top-level struct. Enumerates characters of the string.
         /// </summary>
-        public ref struct Enumerator
+        public struct Enumerator
         {
             /// <summary>
             /// The InternableString being enumerated.
@@ -51,7 +48,7 @@ public ref struct Enumerator
             /// </summary>
             private int _charIndex;
 
-            public Enumerator(ref InternableString spanBuilder)
+            public Enumerator(InternableString spanBuilder)
             {
                 _string = spanBuilder;
                 _charIndex = -1;
@@ -127,7 +124,7 @@ internal InternableString(SpanBasedStringBuilder builder)
         /// <returns>The enumerator.</returns>
         public Enumerator GetEnumerator()
         {
-            return new Enumerator(ref this);
+            return new Enumerator(this);
         }
 
         /// <summary>
diff --git a/src/StringTools/PublicAPI/net/PublicAPI.Shipped.txt b/src/StringTools/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index 9086e5e2c2a..00000000000
--- a/src/StringTools/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,25 +0,0 @@
-Microsoft.NET.StringTools.SpanBasedStringBuilder
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string value) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string value, int startIndex, int count) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(System.ReadOnlyMemory<char> span) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Capacity.get -> int
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Clear() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Dispose() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Current.get -> char
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.MoveNext() -> bool
-Microsoft.NET.StringTools.SpanBasedStringBuilder.GetEnumerator() -> Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Length.get -> int
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(int capacity = 4) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(string str) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Trim() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimEnd() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimStart() -> void
-Microsoft.NET.StringTools.Strings
-override Microsoft.NET.StringTools.SpanBasedStringBuilder.ToString() -> string
-static Microsoft.NET.StringTools.Strings.CreateDiagnosticReport() -> string
-static Microsoft.NET.StringTools.Strings.EnableDiagnostics() -> void
-static Microsoft.NET.StringTools.Strings.GetSpanBasedStringBuilder() -> Microsoft.NET.StringTools.SpanBasedStringBuilder
-static Microsoft.NET.StringTools.Strings.WeakIntern(string str) -> string
-static Microsoft.NET.StringTools.Strings.WeakIntern(System.ReadOnlySpan<char> str) -> string
\ No newline at end of file
diff --git a/src/StringTools/PublicAPI/net/PublicAPI.Unshipped.txt b/src/StringTools/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/StringTools/PublicAPI/net35/PublicAPI.Shipped.txt b/src/StringTools/PublicAPI/net35/PublicAPI.Shipped.txt
deleted file mode 100644
index e2b05b1bd03..00000000000
--- a/src/StringTools/PublicAPI/net35/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,20 +0,0 @@
-Microsoft.NET.StringTools.SpanBasedStringBuilder
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Clear() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Dispose() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Current.get -> char
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator(System.Text.StringBuilder builder) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.MoveNext() -> bool
-Microsoft.NET.StringTools.SpanBasedStringBuilder.GetEnumerator() -> Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Length.get -> int
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(int capacity = 4) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(string str) -> void
-Microsoft.NET.StringTools.Strings
-override Microsoft.NET.StringTools.SpanBasedStringBuilder.ToString() -> string
-static Microsoft.NET.StringTools.Strings.CreateDiagnosticReport() -> string
-static Microsoft.NET.StringTools.Strings.EnableDiagnostics() -> void
-static Microsoft.NET.StringTools.Strings.GetSpanBasedStringBuilder() -> Microsoft.NET.StringTools.SpanBasedStringBuilder
-static Microsoft.NET.StringTools.Strings.WeakIntern(string str) -> string
-static System.MemoryExtensions.AsSpan<T>(this T[] array, int start, int length) -> string
-System.MemoryExtensions
\ No newline at end of file
diff --git a/src/StringTools/PublicAPI/net35/PublicAPI.Unshipped.txt b/src/StringTools/PublicAPI/net35/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/StringTools/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/StringTools/PublicAPI/netstandard/PublicAPI.Shipped.txt
deleted file mode 100644
index 9086e5e2c2a..00000000000
--- a/src/StringTools/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,25 +0,0 @@
-Microsoft.NET.StringTools.SpanBasedStringBuilder
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string value) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(string value, int startIndex, int count) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Append(System.ReadOnlyMemory<char> span) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Capacity.get -> int
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Clear() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Dispose() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Current.get -> char
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.Enumerator() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator.MoveNext() -> bool
-Microsoft.NET.StringTools.SpanBasedStringBuilder.GetEnumerator() -> Microsoft.NET.StringTools.SpanBasedStringBuilder.Enumerator
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Length.get -> int
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(int capacity = 4) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.SpanBasedStringBuilder(string str) -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.Trim() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimEnd() -> void
-Microsoft.NET.StringTools.SpanBasedStringBuilder.TrimStart() -> void
-Microsoft.NET.StringTools.Strings
-override Microsoft.NET.StringTools.SpanBasedStringBuilder.ToString() -> string
-static Microsoft.NET.StringTools.Strings.CreateDiagnosticReport() -> string
-static Microsoft.NET.StringTools.Strings.EnableDiagnostics() -> void
-static Microsoft.NET.StringTools.Strings.GetSpanBasedStringBuilder() -> Microsoft.NET.StringTools.SpanBasedStringBuilder
-static Microsoft.NET.StringTools.Strings.WeakIntern(string str) -> string
-static Microsoft.NET.StringTools.Strings.WeakIntern(System.ReadOnlySpan<char> str) -> string
\ No newline at end of file
diff --git a/src/StringTools/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/StringTools/PublicAPI/netstandard/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index 60f23ad625f..238bd8a4ca1 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -12,8 +12,16 @@
     <AssemblyVersion>1.0.0.0</AssemblyVersion>
     <SemanticVersioningV1>true</SemanticVersioningV1>
 
+    <EnablePackageValidation>true</EnablePackageValidation>
+
     <AssemblyName>Microsoft.NET.StringTools</AssemblyName>
     <PackageDescription>This package contains the $(AssemblyName) assembly which implements common string-related functionality such as weak interning.</PackageDescription>
+    
+    <IncludeBuildOutput Condition="'$(TargetFramework)' == 'net35'">false</IncludeBuildOutput>
+    <!-- Don't publish the reference assembly if the build output isn't included. -->
+    <TargetsForTfmSpecificBuildOutput Condition="'$(IncludeBuildOutput)' == 'false'" />
+    <!-- NU5128: Add lib or ref assemblies for the net35 target framework. -->
+    <NoWarn>$(NoWarn);NU5128</NoWarn>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
@@ -27,7 +35,7 @@
     <AssemblyName>Microsoft.NET.StringTools.net35</AssemblyName>
   </PropertyGroup>
 
-  <ItemGroup Condition="'$(TargetFramework)' != 'net35'">
+  <ItemGroup Condition="'$(TargetFramework)' != 'net35' AND '$(TargetFrameworkIdentifier)' != '.NETCoreApp'">
     <PackageReference Include="System.Memory" />
     <PackageReference Include="System.Runtime.CompilerServices.Unsafe" />
   </ItemGroup>
diff --git a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
index e7f155ac3b0..2f60c7dcd48 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/FilePrimary.cs
@@ -210,8 +210,8 @@ public void ExistsPromotedDependencyInTheBlackList()
                 "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             string appConfigFile = null;
             try
             {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
index 0a520b9f82b..01d46289a95 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/Miscellaneous.cs
@@ -14,6 +14,7 @@
 using SystemProcessorArchitecture = System.Reflection.ProcessorArchitecture;
 using Xunit.Abstractions;
 using Shouldly;
+using Microsoft.Build.UnitTests.Shared;
 
 #nullable disable
 
@@ -94,6 +95,24 @@ public Miscellaneous(ITestOutputHelper output) : base(output)
         {
         }
 
+        [Fact]
+        public void VerifyPrimaryReferenceToBadImageDoesNotThrow()
+        {
+            ITaskItem x = new TaskItem(Path.Combine(s_myComponentsRootPath, "X.dll"));
+            ITaskItem xpdb = new TaskItem(Path.Combine(s_myComponentsRootPath, "X.pdb"));
+            ResolveAssemblyReference t = new()
+            {
+                BuildEngine = new MockEngine(),
+                AllowedRelatedFileExtensions = new string[] { ".pdb" },
+                Assemblies = new ITaskItem[] { xpdb },
+                AssemblyFiles = new ITaskItem[] { x },
+                SearchPaths = new string[] { "{RawFileName}" },
+            };
+
+            bool success = Execute(t);
+            success.ShouldBeTrue();
+        }
+
         /// <summary>
         /// Let us have the following dependency structure
         ///
@@ -2519,7 +2538,7 @@ public void TestDuplicateHandlingForRedistLists()
                   "<File AssemblyName='Microsoft.BuildEngine' Version='3.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='false' />" +
               "</FileList >";
 
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(redistFile, fullRedistListContentsDuplicates);
@@ -2672,7 +2691,7 @@ public void TestDuplicateHandlingDifferentVersion()
         /// </summary>
         private static List<AssemblyEntry> ExpectRedistEntries(string fullRedistListContentsDuplicates, int numberOfExpectedEntries, int numberofExpectedRemapEntries)
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             List<AssemblyEntry> assembliesReadIn = new List<AssemblyEntry>();
             List<AssemblyRemapping> remapEntries = new List<AssemblyRemapping>();
             try
@@ -3373,6 +3392,14 @@ public void ResolveBadImageInPrimary()
 
             // There should have been one warning about the exception.
             Assert.Equal(1, engine.Warnings);
+            engine.AssertLogContains("MSB3246");
+
+            // There should have been no ugly callstack dumped
+            engine.AssertLogDoesntContain("Microsoft.Build.UnitTests");
+
+            // But it should contain the message from the BadImageFormatException, something like
+            //     WARNING MSB3246: Resolved file has a bad image, no metadata, or is otherwise inaccessible. The format of the file 'C:\WINNT\Microsoft.NET\Framework\v2.0.MyVersion\BadImage.dll' is invalid
+            engine.AssertLogContains("'C:\\WINNT\\Microsoft.NET\\Framework\\v2.0.MyVersion\\BadImage.dll'"); // just search for the un-localized part
         }
 
         /// <summary>
@@ -3410,6 +3437,9 @@ public void ResolveBadImageInSecondary()
 
             // There should have been no warning about the exception because it's only a dependency
             Assert.Equal(0, engine.Warnings);
+        
+            // There should have been no ugly callstack dumped
+            engine.AssertLogDoesntContain("Microsoft.Build.UnitTests");
         }
 
         /// <summary>
@@ -5273,10 +5303,9 @@ public void Regress407623_RedistListDoesNotImplyPresenceInFrameworks()
                 @"c:\Regress407623"                    // Assembly is here.
             };
 
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -5359,12 +5388,10 @@ public void Regress435487_FxFileResolvedByHintPathShouldByCopyLocal()
             };
             t.TargetFrameworkDirectories = new string[] { @"r:\WINDOWS\Microsoft.NET\Framework\v2.0.myfx" };
 
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
 
             try
             {
-                File.Delete(redistFile);
-
                 File.WriteAllText
                 (
                     redistFile,
@@ -5392,12 +5419,10 @@ public void Regress435487_FxFileResolvedByHintPathShouldByCopyLocal()
         [Fact]
         public void PartialNameMatchingFromRedist()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
 
             try
             {
-                File.Delete(redistFile);
-
                 File.WriteAllText
                 (
                     redistFile,
@@ -5540,7 +5565,7 @@ public void VerifyFrameworkFileMetadataFiles()
                          "<File AssemblyName='C' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                     "</FileList >";
 
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(redistFile, redistListContents);
 
             bool success = false;
@@ -5607,7 +5632,7 @@ private static string CreateGenericRedistList()
                         "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                     "</FileList >";
 
-            string tempFile = FileUtilities.GetTemporaryFile();
+            string tempFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(tempFile, redistListContents);
             return tempFile;
         }
@@ -5713,7 +5738,7 @@ public void RedistListGenerateBlackListNotFoundSubsetFiles()
         public void RedistListGenerateBlackListGarbageSubsetListFiles()
         {
             string redistFile = CreateGenericRedistList();
-            string garbageSubsetFile = FileUtilities.GetTemporaryFile();
+            string garbageSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText
@@ -5757,7 +5782,7 @@ public void RedistListGenerateBlackListGarbageSubsetListFiles()
         public void RedistListNoSubsetListName()
         {
             string redistFile = CreateGenericRedistList();
-            string subsetFile = FileUtilities.GetTemporaryFile();
+            string subsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 string subsetListContents =
@@ -5802,8 +5827,8 @@ public void RedistListNoSubsetListName()
         [Fact]
         public void RedistListNullkRedistListName()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
-            string subsetFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
+            string subsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 string subsetListContents =
@@ -5855,7 +5880,7 @@ public void RedistListNullkRedistListName()
         public void RedistListDifferentNameToSubSet()
         {
             string redistFile = CreateGenericRedistList();
-            string subsetFile = FileUtilities.GetTemporaryFile();
+            string subsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 string subsetListContents =
@@ -5892,7 +5917,7 @@ public void RedistListDifferentNameToSubSet()
         public void RedistListEmptySubsetMatchingName()
         {
             string redistFile = CreateGenericRedistList();
-            string subsetFile = FileUtilities.GetTemporaryFile();
+            string subsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 string subsetListContents =
@@ -5949,8 +5974,8 @@ public void RedistListNoAssembliesinRedistList()
                 @"{TargetFrameworkDirectory}"
             };
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(subsetListPath, _xmlOnlySubset);
             try
             {
@@ -5983,7 +6008,7 @@ public void RedistListNoAssembliesinRedistList()
         public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
         {
             string redistFile = CreateGenericRedistList();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(goodSubsetFile, _engineOnlySubset);
@@ -6016,7 +6041,7 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSubsetOfRedist()
         public void RedistListGenerateBlackListVerifyBlackListCache()
         {
             string redistFile = CreateGenericRedistList();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(goodSubsetFile, _engineOnlySubset);
@@ -6057,8 +6082,8 @@ public void RedistListGenerateBlackListVerifyBlackListCache()
         public void RedistListGenerateBlackListGoodListsSubsetIsSameAsRedistList()
         {
             string redistFile = CreateGenericRedistList();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
-            string goodSubsetFile2 = FileUtilities.GetTemporaryFile();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
+            string goodSubsetFile2 = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(goodSubsetFile, _engineOnlySubset);
@@ -6094,7 +6119,7 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSameAsRedistList()
         public void RedistListGenerateBlackListGoodListsSubsetIsSuperSet()
         {
             string redistFile = CreateGenericRedistList();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText
@@ -6134,7 +6159,7 @@ public void RedistListGenerateBlackListGoodListsSubsetIsSuperSet()
         public void RedistListGenerateBlackListGoodListsCheckCaseInsensitive()
         {
             string redistFile = CreateGenericRedistList();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(goodSubsetFile, _engineAndXmlSubset.ToUpperInvariant());
@@ -6165,8 +6190,8 @@ public void RedistListGenerateBlackListGoodListsCheckCaseInsensitive()
         [Fact]
         public void RedistListGenerateBlackListGoodListsMultipleIdenticalAssembliesInRedistList()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
-            string goodSubsetFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
+            string goodSubsetFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 // Create a redist list which will contains both of the assemblies to search for
@@ -7952,13 +7977,12 @@ public void ForwardRedistRoot()
                 @"c:\MyRedist"
             };
 
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
 
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
-(
+                (
                     redistFile,
                     "<FileList Redist='Microsoft-Windows-CLRCoreComp' >" +
                         "<File IsRedistRoot='true' AssemblyName='MyRedistRootAssembly' Version='0.0.0.0' PublicKeyToken='null' Culture='Neutral' FileVersion='2.0.40824.0' InGAC='true'/>" +
@@ -8084,10 +8108,9 @@ public void TargetFrameworkFiltering()
         [Fact]
         public void VerifyGetSimpleNamesIsSorted()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8132,10 +8155,9 @@ public void VerifyGetSimpleNamesIsSorted()
         [Fact]
         public void VerifyAssemblyInRedistListNonWindowsRedistName()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8163,10 +8185,9 @@ public void VerifyAssemblyInRedistListNonWindowsRedistName()
         [Fact]
         public void VerifyAssemblyInRedistListWindowsRedistName()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8194,10 +8215,9 @@ public void VerifyAssemblyInRedistListWindowsRedistName()
         [Fact]
         public void VerifyAssemblyInRedistListPartialMatches()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8237,10 +8257,9 @@ public void VerifyAssemblyInRedistListPartialMatches()
         [Fact]
         public void VerifyAssemblyInRedistListDiffVersion()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8269,10 +8288,9 @@ public void VerifyAssemblyInRedistListDiffVersion()
         [Fact]
         public void VerifyAssemblyInRedistListDiffPublicKey()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8301,10 +8319,9 @@ public void VerifyAssemblyInRedistListDiffPublicKey()
         [Fact]
         public void VerifyAssemblyInRedistListDiffCulture()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
@@ -8333,10 +8350,9 @@ public void VerifyAssemblyInRedistListDiffCulture()
         [Fact]
         public void VerifyAssemblyInRedistListDiffSimpleName()
         {
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index 2d572ebf1dc..0ac1240605f 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -546,6 +546,7 @@ internal void StopIOMonitoring()
             Path.Combine(s_myComponentsRootPath, "V.dll"),
             Path.Combine(s_myComponents2RootPath, "W.dll"),
             Path.Combine(s_myComponentsRootPath, "X.dll"),
+            Path.Combine(s_myComponentsRootPath, "X.pdb"),
             Path.Combine(s_myComponentsRootPath, "Y.dll"),
             Path.Combine(s_myComponentsRootPath, "Z.dll"),
 
@@ -1435,6 +1436,12 @@ internal static AssemblyNameExtension GetAssemblyName(string path)
                 return new AssemblyNameExtension("D, Version=1.0.0.0, Culture=Neutral, PublicKeyToken=null");
             }
 
+            if (String.Equals(path, Path.Combine(s_myComponentsRootPath, "X.pdb"), StringComparison.OrdinalIgnoreCase))
+            {
+                // return new AssemblyNameExtension("X, Version=2.0.0.0, Culture=Neutral, PublicKeyToken=null");
+                throw new BadImageFormatException("X.pdb is a PDB file, not a managed assembly");
+            }
+
             if (String.Equals(path, @"C:\Regress714052\X86\a.dll", StringComparison.OrdinalIgnoreCase))
             {
                 return new AssemblyNameExtension("A, Version=2.0.0.0, Culture=neutral, PublicKeyToken=null, ProcessorArchitecture=X86");
@@ -2929,7 +2936,7 @@ protected static string WriteAppConfig(string redirects)
             "    </runtime>\n" +
             "</configuration>";
 
-            string appConfigFile = FileUtilities.GetTemporaryFile();
+            string appConfigFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(appConfigFile, appConfigContents);
             return appConfigFile;
         }
@@ -3143,10 +3150,9 @@ internal void ExecuteRAROnItemsAndRedist(ResolveAssemblyReference t, MockEngine
 
             t.Assemblies = items;
             t.SearchPaths = searchPaths.ToArray();
-            string redistFile = FileUtilities.GetTemporaryFile();
+            string redistFile = FileUtilities.GetTemporaryFileName();
             try
             {
-                File.Delete(redistFile);
                 File.WriteAllText
                 (
                     redistFile,
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
index c4f78439042..3bb0ff19545 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAppConfig.cs
@@ -109,8 +109,8 @@ public void ExistsPromotedDependencyInTheBlackList()
                 "<File AssemblyName='UniFYme' Version='2.0.0.0' Culture='neutral' PublicKeyToken='b77a5c561934e089' InGAC='false' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             string appConfigFile = null;
             try
             {
diff --git a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
index 10694971b29..dc4c11e5ef6 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/StronglyNamedDependencyAutoUnify.cs
@@ -121,8 +121,8 @@ public void ExistsWithPrimaryReferenceOnBlackList()
                 "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(redistListPath, implicitRedistListContents);
@@ -204,8 +204,8 @@ public void ExistsPromotedDependencyInTheBlackList()
                 "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             string appConfigFile = null;
             try
             {
@@ -286,8 +286,8 @@ public void ExistsWithBothDependentReferenceOnBlackList()
                 "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(redistListPath, implicitRedistListContents);
@@ -362,8 +362,8 @@ public void MultipleUnifiedFromNamesMiddlePrimaryOnBlackList()
                 "<File AssemblyName='Microsoft.Build.Engine' Version='2.0.0.0' PublicKeyToken='b03f5f7f11d50a3a' Culture='Neutral' FileVersion='2.0.50727.208' InGAC='true' />" +
                 "</FileList >";
 
-            string redistListPath = FileUtilities.GetTemporaryFile();
-            string subsetListPath = FileUtilities.GetTemporaryFile();
+            string redistListPath = FileUtilities.GetTemporaryFileName();
+            string subsetListPath = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(redistListPath, implicitRedistListContents);
             File.WriteAllText(subsetListPath, engineOnlySubset);
 
diff --git a/src/Tasks.UnitTests/Copy_Tests.cs b/src/Tasks.UnitTests/Copy_Tests.cs
index f02137ec589..17401cfd0d2 100644
--- a/src/Tasks.UnitTests/Copy_Tests.cs
+++ b/src/Tasks.UnitTests/Copy_Tests.cs
@@ -7,7 +7,6 @@
 using System.IO;
 using System.Linq;
 using System.Runtime.InteropServices;
-using System.Security.Principal;
 using System.Threading;
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.AccessControl;
@@ -2208,6 +2207,9 @@ public CopyNotHardLink_Tests(ITestOutputHelper testOutputHelper)
 
     public class CopyHardAndSymbolicLink_Tests
     {
+        /// <summary>
+        /// Verify build sucessfully when UseHardlinksIfPossible and UseSymboliclinksIfPossible are true 
+        /// </summary>
         [Fact]
         public void CopyWithHardAndSymbolicLinks()
         {
@@ -2234,10 +2236,9 @@ public void CopyWithHardAndSymbolicLinks()
 
                 bool success = t.Execute();
 
-                Assert.False(success);
-
+                Assert.True(success);
                 MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
-                me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.ExactlyOneTypeOfLink", "UseHardlinksIfPossible", "UseSymboliclinksIfPossible");
+                me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.HardLinkComment", sourceFile, destFile);
             }
             finally
             {
@@ -2556,77 +2557,63 @@ public CopySymbolicLink_Tests(ITestOutputHelper testOutputHelper)
         [Fact]
         public void CopyToDestinationFolderWithSymbolicLinkCheck()
         {
-            var isPrivileged = true;
-
-            if (NativeMethodsShared.IsWindows)
-            {
-                if (!new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(new SecurityIdentifier(WellKnownSidType.BuiltinAdministratorsSid, null)))
-                {
-                    isPrivileged = false;
-                    Assert.True(true, "It seems that you don't have the permission to create symbolic links. Try to run this test again with higher privileges");
-                }
-            }
-
-            if (isPrivileged)
+            string sourceFile = FileUtilities.GetTemporaryFile();
+            string temp = Path.GetTempPath();
+            string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
+            string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
+            try
             {
-                string sourceFile = FileUtilities.GetTemporaryFile();
-                string temp = Path.GetTempPath();
-                string destFolder = Path.Combine(temp, "2A333ED756AF4dc392E728D0F864A398");
-                string destFile = Path.Combine(destFolder, Path.GetFileName(sourceFile));
-                try
-                {
-                    File.WriteAllText(sourceFile, "This is a source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
-
-                    // Don't create the dest folder, let task do that
+                File.WriteAllText(sourceFile, "This is a source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
 
-                    ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
+                // Don't create the dest folder, let task do that
+                ITaskItem[] sourceFiles = { new TaskItem(sourceFile) };
 
-                    var me = new MockEngine(true);
-                    var t = new Copy
-                    {
-                        RetryDelayMilliseconds = 1,  // speed up tests!
-                        BuildEngine = me,
-                        SourceFiles = sourceFiles,
-                        DestinationFolder = new TaskItem(destFolder),
-                        SkipUnchangedFiles = true,
-                        UseSymboliclinksIfPossible = true
-                    };
+                var me = new MockEngine(true);
+                var t = new Copy
+                {
+                    RetryDelayMilliseconds = 1,  // speed up tests!
+                    BuildEngine = me,
+                    SourceFiles = sourceFiles,
+                    DestinationFolder = new TaskItem(destFolder),
+                    SkipUnchangedFiles = true,
+                    UseSymboliclinksIfPossible = true
+                };
 
-                    bool success = t.Execute();
+                bool success = t.Execute();
 
-                    Assert.True(success); // "success"
-                    Assert.True(File.Exists(destFile)); // "destination exists"
+                Assert.True(success); // "success"
+                Assert.True(File.Exists(destFile)); // "destination exists"
+                Assert.True((File.GetAttributes(destFile) & FileAttributes.ReparsePoint) != 0, "File was copied but is not a symlink");
 
-                    MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
+                MockEngine.GetStringDelegate resourceDelegate = AssemblyResources.GetString;
 
-                    me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.SymbolicLinkComment", sourceFile, destFile);
+                me.AssertLogContainsMessageFromResource(resourceDelegate, "Copy.SymbolicLinkComment", sourceFile, destFile);
 
-                    string destinationFileContents = File.ReadAllText(destFile);
-                    Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination symbolic linked file to contain the contents of source file."
+                string destinationFileContents = File.ReadAllText(destFile);
+                Assert.Equal("This is a source temp file.", destinationFileContents); // "Expected the destination symbolic linked file to contain the contents of source file."
 
-                    Assert.Single(t.DestinationFiles);
-                    Assert.Single(t.CopiedFiles);
-                    Assert.Equal(destFile, t.DestinationFiles[0].ItemSpec);
-                    Assert.Equal(destFile, t.CopiedFiles[0].ItemSpec);
+                Assert.Single(t.DestinationFiles);
+                Assert.Single(t.CopiedFiles);
+                Assert.Equal(destFile, t.DestinationFiles[0].ItemSpec);
+                Assert.Equal(destFile, t.CopiedFiles[0].ItemSpec);
 
-                    // Now we will write new content to the source file
-                    // we'll then check that the destination file automatically
-                    // has the same content (i.e. it's been hard linked)
+                // Now we will write new content to the source file
+                // we'll then check that the destination file automatically
+                // has the same content (i.e. it's been hard linked)
 
-                    File.WriteAllText(sourceFile, "This is another source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
+                File.WriteAllText(sourceFile, "This is another source temp file."); // HIGHCHAR: Test writes in UTF8 without preamble.
 
-                    // Read the destination file (it should have the same modified content as the source)
-                    destinationFileContents = File.ReadAllText(destFile);
-                    Assert.Equal("This is another source temp file.", destinationFileContents); // "Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
+                // Read the destination file (it should have the same modified content as the source)
+                destinationFileContents = File.ReadAllText(destFile);
+                Assert.Equal("This is another source temp file.", destinationFileContents); // "Expected the destination hard linked file to contain the contents of source file. Even after modification of the source"
 
-                    ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3891"); // Didn't do retries
-                }
-                finally
-                {
-                    File.Delete(sourceFile);
-                    File.Delete(destFile);
-                    FileUtilities.DeleteWithoutTrailingBackslash(destFolder, true);
-                }
+                ((MockEngine)t.BuildEngine).AssertLogDoesntContain("MSB3891"); // Didn't do retries
+            }
+            finally
+            {
+                File.Delete(sourceFile);
+                File.Delete(destFile);
+                FileUtilities.DeleteWithoutTrailingBackslash(destFolder, true);
             }
         }
 
diff --git a/src/Tasks.UnitTests/Exec_Tests.cs b/src/Tasks.UnitTests/Exec_Tests.cs
index 3be6e26a45a..c882200d44e 100644
--- a/src/Tasks.UnitTests/Exec_Tests.cs
+++ b/src/Tasks.UnitTests/Exec_Tests.cs
@@ -362,7 +362,7 @@ public void TempPathContainsAmpersand2()
         public void TempPathContainsAmpersand3()
         {
             string directoryWithAmpersand = "nospace& space";
-            string newTmp = Path.Combine(Path.GetTempPath(), directoryWithAmpersand);
+            string newTmp = Path.Combine(FileUtilities.TempFileDirectory, directoryWithAmpersand);
             string oldTmp = Environment.GetEnvironmentVariable("TMP");
 
             try
diff --git a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
index 620cb08680b..d65901d9ccb 100644
--- a/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
+++ b/src/Tasks.UnitTests/GetCompatiblePlatform_Tests.cs
@@ -84,6 +84,28 @@ public void ResolvesViaAnyCPUDefault()
 
             task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe("AnyCPU");
         }
+        
+        [Fact]
+        public void ResolvesViaAnyCPUDefaultWithDefaultPlatformEnabled()
+        {
+            // No valid mapping via the lookup table, should default to AnyCPU when the current project
+            // and ProjectReference platforms don't match.
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "x64;AnyCPU");
+            projectReference.SetMetadata("Platform", "AnyCPU");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "AnyCPU=x64", 
+                AnnotatedProjects = new TaskItem[] { projectReference }
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+        }
 
         [Fact]
         public void ResolvesViaSamePlatform()
@@ -226,5 +248,28 @@ public void PlatformIsChosenAsDefault(string referencedPlatforms, string referen
             task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
             task.Log.HasLoggedErrors.ShouldBeFalse();
         }
+        
+        // When `Platform` is retrieved in "GetTargetFrameworks" and that platform matches what the task has decided the project should be built as
+        // through negotiation. build that project _without_ a global property for Platform.
+        [Fact]
+        public void ChosenPlatformMatchesDefault()
+        {
+            TaskItem projectReference = new TaskItem("foo.bar");
+            projectReference.SetMetadata("Platforms", "AnyCPU;x64");
+            projectReference.SetMetadata("Platform", "AnyCPU");
+
+            GetCompatiblePlatform task = new GetCompatiblePlatform()
+            {
+                BuildEngine = new MockEngine(_output),
+                CurrentProjectPlatform = "x86",
+                PlatformLookupTable = "", // invalid format
+                AnnotatedProjects = new TaskItem[] { projectReference },
+            };
+
+            task.Execute().ShouldBeTrue();
+
+            task.AssignedProjectsWithPlatform[0].GetMetadata("NearestPlatform").ShouldBe(string.Empty);
+            task.Log.HasLoggedErrors.ShouldBeFalse();
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/Move_Tests.cs b/src/Tasks.UnitTests/Move_Tests.cs
index 2ac0ecd66f6..adf456748bc 100644
--- a/src/Tasks.UnitTests/Move_Tests.cs
+++ b/src/Tasks.UnitTests/Move_Tests.cs
@@ -467,7 +467,7 @@ public void MoveLockedFile()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
                 bool result;
                 Move move = null;
 
diff --git a/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs b/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
index e7ba35224bf..29999daefa9 100644
--- a/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
+++ b/src/Tasks.UnitTests/ReadLinesFromFile_Tests.cs
@@ -24,12 +24,10 @@ public sealed class ReadLinesFromFile_Tests
         [Fact]
         public void Basic()
         {
-            var file = FileUtilities.GetTemporaryFile();
+            // Start with a missing file.
+            var file = FileUtilities.GetTemporaryFileName();
             try
             {
-                // Start with a missing file.
-                File.Delete(file);
-
                 // Append one line to the file.
                 var a = new WriteLinesToFile
                 {
@@ -73,12 +71,10 @@ public void Basic()
         [Fact]
         public void Escaping()
         {
-            var file = FileUtilities.GetTemporaryFile();
+            // Start with a missing file.
+            var file = FileUtilities.GetTemporaryFileName();
             try
             {
-                // Start with a missing file.
-                File.Delete(file);
-
                 // Append one line to the file.
                 var a = new WriteLinesToFile
                 {
@@ -120,12 +116,10 @@ public void Escaping()
         [Fact]
         public void ANSINonASCII()
         {
-            var file = FileUtilities.GetTemporaryFile();
+            // Start with a missing file.
+            var file = FileUtilities.GetTemporaryFileName();
             try
             {
-                // Start with a missing file.
-                File.Delete(file);
-
                 // Append one line to the file.
                 var a = new WriteLinesToFile
                 {
@@ -156,8 +150,7 @@ public void ANSINonASCII()
         [Fact]
         public void ReadMissing()
         {
-            var file = FileUtilities.GetTemporaryFile();
-            File.Delete(file);
+            var file = FileUtilities.GetTemporaryFileName();
 
             // Read the line from the file.
             var r = new ReadLinesFromFile
@@ -175,12 +168,10 @@ public void ReadMissing()
         [Fact]
         public void IgnoreBlankLines()
         {
-            var file = FileUtilities.GetTemporaryFile();
+            // Start with a missing file.
+            var file = FileUtilities.GetTemporaryFileName();
             try
             {
-                // Start with a missing file.
-                File.Delete(file);
-
                 // Append one line to the file.
                 var a = new WriteLinesToFile
                 {
@@ -227,12 +218,10 @@ public void ReadNoAccess()
                 return; // "The security API is not the same under Unix"
             }
 
-            var file = FileUtilities.GetTemporaryFile();
+            // Start with a missing file.
+            var file = FileUtilities.GetTemporaryFileName();
             try
             {
-                // Start with a missing file.
-                File.Delete(file);
-
                 // Append one line to the file.
                 var a = new WriteLinesToFile
                 {
diff --git a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
index 64383a4c4b7..aea579d8787 100644
--- a/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/GenerateResource_Tests.cs
@@ -3826,9 +3826,8 @@ public static MethodInfo GetPrivateMethod(object o, string methodName)
         /// </summary>
         public static string GetTempFileName(string extension)
         {
-            string f = FileUtilities.GetTemporaryFile();
+            string f = FileUtilities.GetTemporaryFileName();
             string filename = Path.ChangeExtension(f, extension);
-            File.Delete(f);
             // Make sure that the new file doesn't already exist, since the test is probably
             // expecting it not to
             File.Delete(filename);
diff --git a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
index b4eed6f9a10..1cd7d218fa3 100644
--- a/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
+++ b/src/Tasks.UnitTests/ResourceHandling/ResGenDependencies_Tests.cs
@@ -92,8 +92,7 @@ public void DirtyCleanScenario(bool useMSBuildResXReader)
         /// <returns></returns>
         private string CreateSampleResx()
         {
-            string resx = FileUtilities.GetTemporaryFile();
-            File.Delete(resx);
+            string resx = FileUtilities.GetTemporaryFileName();
             Stream fileToSend = Assembly.GetExecutingAssembly().GetManifestResourceStream("Microsoft.Build.Tasks.UnitTests.SampleResx");
             using (FileStream f = new FileStream(resx, FileMode.CreateNew))
             {
diff --git a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
index 17d45366bca..050975f0c98 100644
--- a/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/XamlTaskFactory_Tests.cs
@@ -338,7 +338,7 @@ public void TestLoadAndParseFromAbsoluteFilePath()
                                        <StringProperty Name=`TargetAssembly` Switch=`/target:&quot;[value]&quot;` />
                                      </Rule>
                                    </ProjectSchemaDefinitions>";
-            string tmpXamlFile = FileUtilities.GetTemporaryFile();
+            string tmpXamlFile = FileUtilities.GetTemporaryFileName();
             try
             {
                 File.WriteAllText(tmpXamlFile, xmlContents.Replace("`", "\""));
diff --git a/src/Tasks.UnitTests/XmlPoke_Tests.cs b/src/Tasks.UnitTests/XmlPoke_Tests.cs
index 05e3f05860c..88caa456fad 100644
--- a/src/Tasks.UnitTests/XmlPoke_Tests.cs
+++ b/src/Tasks.UnitTests/XmlPoke_Tests.cs
@@ -142,7 +142,7 @@ public void PokeMissingParams()
             string xmlInputPath;
             Prepare(_xmlFileNoNs, out xmlInputPath);
 
-            for (int i = 0; i < 8; i++)
+            for (int i = 0; i < 4; i++)
             {
                 XmlPoke p = new XmlPoke();
                 p.BuildEngine = engine;
@@ -157,13 +157,8 @@ public void PokeMissingParams()
                     p.Query = "//variable/@Name";
                 }
 
-                if ((i & 4) == 4)
-                {
-                    p.Value = new TaskItem("Mert");
-                }
-
-                // "Expecting argumentnullexception for the first 7 tests"
-                if (i < 7)
+                // "Expecting argumentnullexception for the first 3 tests"
+                if (i < 3)
                 {
                     Should.Throw<ArgumentNullException>(() => p.Execute());
                 }
@@ -174,6 +169,33 @@ public void PokeMissingParams()
             }
         }
 
+        [Fact]
+        // https://github.com/dotnet/msbuild/issues/5814
+        public void XmlPokeWithEmptyValue()
+        {
+            string xmlInputPath;
+            string query = "//class/variable/@Name";
+            Prepare(_xmlFileNoNs, out xmlInputPath);
+            string projectContents = $"""
+                <Project ToolsVersion='msbuilddefaulttoolsversion'>
+                <Target Name='Poke'>
+                    <XmlPoke Value='' Query='{query}' XmlInputPath='{xmlInputPath}'/>
+                </Target>
+                </Project>
+                """;
+
+            ObjectModelHelpers.BuildProjectExpectSuccess(projectContents);
+
+            string result = File.ReadAllText(xmlInputPath);
+            XmlDocument xmlDocument = new XmlDocument();
+            xmlDocument.LoadXml(result);
+            List<XmlAttribute> nodes = xmlDocument.SelectNodes(query)?.Cast<XmlAttribute>().ToList();
+            foreach (var node in nodes)
+            {
+                node.Value.ShouldBe(string.Empty);
+            }
+        }
+
         [Fact]
         public void ErrorInNamespaceDecl()
         {
diff --git a/src/Tasks/AssemblyDependency/BadImageReferenceException.cs b/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
index a93ae6fb390..ded433fe021 100644
--- a/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
+++ b/src/Tasks/AssemblyDependency/BadImageReferenceException.cs
@@ -29,5 +29,10 @@ private BadImageReferenceException(SerializationInfo info, StreamingContext cont
             : base(info, context)
         {
         }
+
+        /// <summary>
+        /// Gets a message that describes the exception.
+        /// </summary>
+        public override string Message => (InnerException == null) ? base.Message : $"{base.Message} {InnerException.Message}";
     }
 }
diff --git a/src/Tasks/AssemblyDependency/CopyLocalState.cs b/src/Tasks/AssemblyDependency/CopyLocalState.cs
index e6f506668e7..e1768f2bd0d 100644
--- a/src/Tasks/AssemblyDependency/CopyLocalState.cs
+++ b/src/Tasks/AssemblyDependency/CopyLocalState.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 
 #nullable disable
 
@@ -72,6 +71,11 @@ internal enum CopyLocalState
         /// The property copyLocalDependenciesWhenParentReferenceInGac is set to false and all the parent source items were found in the GAC.
         /// </summary>
         NoBecauseParentReferencesFoundInGAC,
+
+        /// <summary>
+        /// The "assembly" should not be copied because it is a bad image—possibly not managed, possibly not an assembly at all.
+        /// </summary>
+        NoBecauseBadImage,
     }
 
     /// <remarks>
@@ -98,6 +102,7 @@ internal static bool IsCopyLocal(CopyLocalState state)
                 case CopyLocalState.NoBecauseReferenceFoundInGAC:
                 case CopyLocalState.NoBecauseEmbedded:
                 case CopyLocalState.NoBecauseParentReferencesFoundInGAC:
+                case CopyLocalState.NoBecauseBadImage:
                     return false;
                 default:
                     throw new InternalErrorException("Unexpected CopyLocal flag.");
diff --git a/src/Tasks/AssemblyDependency/Reference.cs b/src/Tasks/AssemblyDependency/Reference.cs
index db5d30bda9d..9ad4a1f1bdb 100644
--- a/src/Tasks/AssemblyDependency/Reference.cs
+++ b/src/Tasks/AssemblyDependency/Reference.cs
@@ -969,6 +969,12 @@ internal void SetFinalCopyLocalState
             ReferenceTable referenceTable
         )
         {
+            if (IsBadImage)
+            {
+                CopyLocal = CopyLocalState.NoBecauseBadImage;
+                return;
+            }
+
             // If this item was unresolvable, then copy-local is false.
             if (IsUnresolvable)
             {
diff --git a/src/Tasks/AssemblyDependency/ReferenceTable.cs b/src/Tasks/AssemblyDependency/ReferenceTable.cs
index 4cb1e0d2a63..8408c19de17 100644
--- a/src/Tasks/AssemblyDependency/ReferenceTable.cs
+++ b/src/Tasks/AssemblyDependency/ReferenceTable.cs
@@ -409,7 +409,7 @@ internal void AddReference(AssemblyNameExtension assemblyName, Reference referen
                 }
             }
 
-            if (reference.FullPath.Length > 0 && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
+            if (reference.FullPath.Length > 0)
             {
                 // Saves effort and makes deduplication possible downstream
                 reference.NormalizeFullPath();
@@ -1340,16 +1340,7 @@ out userRequestedSpecificFile
             // If the path was resolved, then specify the full path on the reference.
             if (resolvedPath != null)
             {
-                if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0))
-                {
-                    resolvedPath = FileUtilities.NormalizePath(resolvedPath);
-                }
-                else if (!Path.IsPathRooted(resolvedPath))
-                {
-                    resolvedPath = Path.GetFullPath(resolvedPath);
-                }
-
-                reference.FullPath = resolvedPath;
+                reference.FullPath = FileUtilities.NormalizePath(resolvedPath);
                 reference.ResolvedSearchPath = resolvedSearchPath;
                 reference.UserRequestedSpecificFile = userRequestedSpecificFile;
             }
@@ -2628,49 +2619,51 @@ out ITaskItem[] copyLocalFiles
                 AssemblyNameExtension assemblyName = kvp.Key;
                 Reference reference = kvp.Value;
 
+                reference.SetFinalCopyLocalState
+                (
+                    assemblyName,
+                    _frameworkPaths,
+                    _targetProcessorArchitecture,
+                    _getRuntimeVersion,
+                    _targetedRuntimeVersion,
+                    _fileExists,
+                    _getAssemblyPathInGac,
+                    _copyLocalDependenciesWhenParentReferenceInGac,
+                    _doNotCopyLocalIfInGac,
+                    this
+                );
+
                 // Conflict victims and badimages are filtered out.
-                if (!reference.IsBadImage)
+                if (reference.IsBadImage)
                 {
-                    reference.SetFinalCopyLocalState
-                    (
-                        assemblyName,
-                        _frameworkPaths,
-                        _targetProcessorArchitecture,
-                        _getRuntimeVersion,
-                        _targetedRuntimeVersion,
-                        _fileExists,
-                        _getAssemblyPathInGac,
-                        _copyLocalDependenciesWhenParentReferenceInGac,
-                        _doNotCopyLocalIfInGac,
-                        this
-                    );
+                    continue;
+                }
 
-                    // If mscorlib was found as a dependency and not a primary reference we will assume that mscorlib on the target machine will be ok to use.
-                    // If mscorlib was a primary reference then we may have resolved one which is a differnt version that is on the target
-                    // machine and we should gather it along with the other references.
-                    if (!reference.IsPrimary && IsPseudoAssembly(assemblyName.Name))
-                    {
-                        continue;
-                    }
+                // If mscorlib was found as a dependency and not a primary reference we will assume that mscorlib on the target machine will be ok to use.
+                // If mscorlib was a primary reference then we may have resolved one which is a differnt version that is on the target
+                // machine and we should gather it along with the other references.
+                if (!reference.IsPrimary && IsPseudoAssembly(assemblyName.Name))
+                {
+                    continue;
+                }
 
-                    if (reference.IsResolved)
-                    {
-                        ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, assemblyName.FullName, reference, assemblyName);
+                if (reference.IsResolved)
+                {
+                    ITaskItem referenceItem = SetItemMetadata(relatedItems, satelliteItems, serializationAssemblyItems, scatterItems, assemblyName.FullName, reference, assemblyName);
 
-                        if (reference.IsPrimary)
-                        {
-                            if (!reference.IsBadImage)
-                            {
-                                // Add a primary item.
-                                primaryItems.Add(referenceItem);
-                            }
-                        }
-                        else
+                    if (reference.IsPrimary)
+                    {
+                        if (!reference.IsBadImage)
                         {
-                            // Add the reference item.
-                            dependencyItems.Add(referenceItem);
+                            // Add a primary item.
+                            primaryItems.Add(referenceItem);
                         }
                     }
+                    else
+                    {
+                        // Add the reference item.
+                        dependencyItems.Add(referenceItem);
+                    }
                 }
             }
 
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index f4039034b9a..402221401a2 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -83,6 +83,7 @@ private static class Strings
             public static string LogAttributeFormat;
             public static string LogTaskPropertyFormat;
             public static string NoBecauseParentReferencesFoundInGac;
+            public static string NoBecauseBadImage;
             public static string NotCopyLocalBecauseConflictVictim;
             public static string NotCopyLocalBecauseEmbedded;
             public static string NotCopyLocalBecauseFrameworksFiles;
@@ -132,6 +133,7 @@ internal static void Initialize(TaskLoggingHelper log)
                 IsAWinMdFile = GetResourceFourSpaces("ResolveAssemblyReference.IsAWinMdFile");
                 LogAttributeFormat = GetResourceEightSpaces("ResolveAssemblyReference.LogAttributeFormat");
                 LogTaskPropertyFormat = GetResource("ResolveAssemblyReference.LogTaskPropertyFormat");
+                NoBecauseBadImage = GetResourceFourSpaces("ResolveAssemblyReference.NoBecauseBadImage");
                 NoBecauseParentReferencesFoundInGac = GetResourceFourSpaces("ResolveAssemblyReference.NoBecauseParentReferencesFoundInGac");
                 NotCopyLocalBecauseConflictVictim = GetResourceFourSpaces("ResolveAssemblyReference.NotCopyLocalBecauseConflictVictim");
                 NotCopyLocalBecauseEmbedded = GetResourceFourSpaces("ResolveAssemblyReference.NotCopyLocalBecauseEmbedded");
@@ -1693,7 +1695,7 @@ private void LogReferenceErrors(Reference reference, MessageImportance importanc
                 }
                 else if (itemError is BadImageReferenceException)
                 {
-                    message = Log.FormatResourceString("ResolveAssemblyReference.FailedWithException", itemError.InnerException?.ToString() ?? itemError.ToString());
+                    message = Log.FormatResourceString("ResolveAssemblyReference.FailedWithException", itemError.Message);
                     helpKeyword = "MSBuild.ResolveAssemblyReference.FailedWithException";
                     dependencyProblem = false;
                 }
@@ -1944,6 +1946,10 @@ private void LogCopyLocalState(Reference reference, MessageImportance importance
                         Log.LogMessage(importance, Strings.NoBecauseParentReferencesFoundInGac);
                         break;
 
+                    case CopyLocalState.NoBecauseBadImage:
+                        Log.LogMessage(importance, Strings.NoBecauseBadImage);
+                        break;
+
                     default:
                         Debug.Assert(false, "Should have handled this case.");
                         break;
@@ -3002,23 +3008,16 @@ private AssemblyTableInfo[] GetInstalledAssemblyTableInfo(bool ignoreInstalledAs
                 // Whidbey behavior was to accept a single TargetFrameworkDirectory, and multiple
                 // InstalledAssemblyTables, under the assumption that all of the InstalledAssemblyTables
                 // were related to the single TargetFrameworkDirectory.  If inputs look like the Whidbey
-                // case, let's make sure we behave the same way.
-
+                // case, let's make sure we behave the same way. Otherwise, use non-empty metadata.
                 if (String.IsNullOrEmpty(frameworkDirectory))
                 {
                     if (TargetFrameworkDirectories?.Length == 1)
                     {
                         // Exactly one TargetFrameworkDirectory, so assume it's related to this
                         // InstalledAssemblyTable.
-
                         frameworkDirectory = TargetFrameworkDirectories[0];
                     }
                 }
-                else
-                {
-                    // The metadata on the item was non-empty, so use it.
-                    frameworkDirectory = FileUtilities.EnsureTrailingSlash(frameworkDirectory);
-                }
 
                 tableMap[installedAssemblyTable.ItemSpec] = new AssemblyTableInfo(installedAssemblyTable.ItemSpec, frameworkDirectory);
             }
diff --git a/src/Tasks/AssemblyFolder.cs b/src/Tasks/AssemblyFolder.cs
index 6f5da7d008f..d8cafc0a6d6 100644
--- a/src/Tasks/AssemblyFolder.cs
+++ b/src/Tasks/AssemblyFolder.cs
@@ -3,7 +3,6 @@
 #if FEATURE_WIN32_REGISTRY
 
 using System;
-using System.IO;
 using System.Collections.Generic;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
diff --git a/src/Tasks/AssignCulture.cs b/src/Tasks/AssignCulture.cs
index bf29ead3d01..f7c09a4c3d4 100644
--- a/src/Tasks/AssignCulture.cs
+++ b/src/Tasks/AssignCulture.cs
@@ -3,7 +3,9 @@
 
 using System;
 using System.Collections.Generic;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index e3fd34e9fc6..c47cd7f6f9a 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -5,7 +5,6 @@
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
 
 #nullable disable
@@ -23,6 +22,7 @@ namespace Microsoft.Build.Tasks
     using System.Reflection;
     using System.Text;
     using System.Xml;
+    using Microsoft.Build.Shared.FileSystem;
 
     /// <summary>
     /// A task factory which can take code dom supported languages and create a task out of it
diff --git a/src/Tasks/ComReference.cs b/src/Tasks/ComReference.cs
index eaf732c4ec4..f1aa4c82c3f 100644
--- a/src/Tasks/ComReference.cs
+++ b/src/Tasks/ComReference.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Runtime.InteropServices.ComTypes;
-using System.Text;
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks/CompatibilitySuppressions.xml b/src/Tasks/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..1314aae19e3
--- /dev/null
+++ b/src/Tasks/CompatibilitySuppressions.xml
@@ -0,0 +1,67 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <Suppression>
+    <!-- For ease of logging the "not supported on Core" message, this task is a
+         TaskExtension on netstandard/netcore. Since the type is sealed there,
+         that shouldn't cause any implementation problems since no one can derive
+         from it and try to call TaskExtension.Log. -->
+    <DiagnosticId>CP0007</DiagnosticId>
+    <Target>T:Microsoft.Build.Tasks.ResolveComReference</Target>
+    <Left>ref/netstandard2.0/Microsoft.Build.Tasks.Core.dll</Left>
+    <Right>ref/net472/Microsoft.Build.Tasks.Core.dll</Right>
+  </Suppression>
+
+  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
+       This is intentional, because you can only use MSBuild in the context of a .NET SDK
+       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
+       have previously shipped netstandard2.0 packages, and if you want to support both
+       runtime contexts it still makes sense to target that. -->
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETCoreApp,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.1</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.2</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.3</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETStandard,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Tizen,Version=v4.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>UAP,Version=v10.0.15064</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation3,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation4,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStationVita,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.Xbox360,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.XboxOne,Version=v0.0</Target>
+  </Suppression>
+</Suppressions>
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index 81e5fd48fcf..d5247d3d933 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -58,6 +58,7 @@ public Copy()
                 FileComment = Log.GetResourceMessage("Copy.FileComment");
                 HardLinkComment = Log.GetResourceMessage("Copy.HardLinkComment");
                 RetryingAsFileCopy = Log.GetResourceMessage("Copy.RetryingAsFileCopy");
+                RetryingAsSymbolicLink = Log.GetResourceMessage("Copy.RetryingAsSymbolicLink");
                 RemovingReadOnlyAttribute = Log.GetResourceMessage("Copy.RemovingReadOnlyAttribute");
                 SymbolicLinkComment = Log.GetResourceMessage("Copy.SymbolicLinkComment");
             }
@@ -68,6 +69,7 @@ public Copy()
         private static string FileComment;
         private static string HardLinkComment;
         private static string RetryingAsFileCopy;
+        private static string RetryingAsSymbolicLink;
         private static string RemovingReadOnlyAttribute;
         private static string SymbolicLinkComment;
 
@@ -294,20 +296,39 @@ FileState destinationFileState  // The destination file
                 destinationFileExists = destinationFileState.FileExists;
             }
 
-            bool linkCreated = false;
+            bool symbolicLinkCreated = false;
+            bool hardLinkCreated = false;
             string errorMessage = string.Empty;
 
-            // If we want to create hard or symbolic links, then try that first
+            // Create hard links if UseHardlinksIfPossible is true
             if (UseHardlinksIfPossible)
             {
-                TryCopyViaLink(HardLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out linkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage));
+                TryCopyViaLink(HardLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out hardLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeHardLink(destination, source, ref errorMessage));
+                if(!hardLinkCreated)
+                {
+                    if(UseSymboliclinksIfPossible)
+                    {
+                        // This is a message for fallback to SymbolicLinks if HardLinks fail when UseHardlinksIfPossible and UseSymboliclinksIfPossible are true
+                        Log.LogMessage(MessageImportance.Normal, RetryingAsSymbolicLink, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                    }
+                    else
+                    {
+                        Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                    }
+                }
             }
-            else if (UseSymboliclinksIfPossible)
+
+            // Create symbolic link if UseSymboliclinksIfPossible is true and hard link is not created
+            if (!hardLinkCreated && UseSymboliclinksIfPossible)
             {
-                TryCopyViaLink(SymbolicLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out linkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethods.MakeSymbolicLink(destination, source, ref errorMessage));
+                TryCopyViaLink(SymbolicLinkComment, MessageImportance.Normal, sourceFileState, destinationFileState, ref destinationFileExists, out symbolicLinkCreated, ref errorMessage, (source, destination, errMessage) => NativeMethodsShared.MakeSymbolicLink(destination, source, ref errorMessage));
+                if(!symbolicLinkCreated)
+                {
+                    Log.LogMessage(MessageImportance.Normal, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
+                }
             }
 
-            if (ErrorIfLinkFails && !linkCreated)
+            if (ErrorIfLinkFails && !hardLinkCreated && !symbolicLinkCreated)
             {
                 Log.LogErrorWithCodeFromResources("Copy.LinkFailed", sourceFileState.Name, destinationFileState.Name);
                 return false;
@@ -315,7 +336,7 @@ FileState destinationFileState  // The destination file
 
             // If the link was not created (either because the user didn't want one, or because it couldn't be created)
             // then let's copy the file
-            if (!linkCreated)
+            if (!hardLinkCreated && !symbolicLinkCreated)
             {
                 // Do not log a fake command line as well, as it's superfluous, and also potentially expensive
                 string sourceFilePath = FileUtilities.GetFullPathNoThrow(sourceFileState.Name);
@@ -359,12 +380,6 @@ private void TryCopyViaLink(string linkComment, MessageImportance messageImporta
             }
 
             linkCreated = createLink(sourceFileState.Name, destinationFileState.Name, errorMessage);
-
-            if (!linkCreated)
-            {
-                // This is only a message since we don't want warnings when copying to network shares etc.
-                Log.LogMessage(messageImportance, RetryingAsFileCopy, sourceFileState.Name, destinationFileState.Name, errorMessage);
-            }
         }
 
         /// <summary>
@@ -673,12 +688,6 @@ private bool ValidateInputs()
                 return false;
             }
 
-            // First check if create hard or symbolic link option is selected. If both then return an error
-            if (UseHardlinksIfPossible & UseSymboliclinksIfPossible)
-            {
-                Log.LogErrorWithCodeFromResources("Copy.ExactlyOneTypeOfLink", "UseHardlinksIfPossible", "UseSymboliclinksIfPossible");
-                return false;
-            }
 
             if (ErrorIfLinkFails && !UseHardlinksIfPossible && !UseSymboliclinksIfPossible)
             {
diff --git a/src/Tasks/CreateVisualBasicManifestResourceName.cs b/src/Tasks/CreateVisualBasicManifestResourceName.cs
index 6b0a1f18a25..27c60d89d2a 100644
--- a/src/Tasks/CreateVisualBasicManifestResourceName.cs
+++ b/src/Tasks/CreateVisualBasicManifestResourceName.cs
@@ -4,7 +4,6 @@
 using System;
 using System.IO;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 
 #nullable disable
diff --git a/src/Tasks/CultureInfoCache.cs b/src/Tasks/CultureInfoCache.cs
index 1a4786a6477..0c2a3672ad0 100644
--- a/src/Tasks/CultureInfoCache.cs
+++ b/src/Tasks/CultureInfoCache.cs
@@ -4,8 +4,10 @@
 using System;
 using System.Collections.Generic;
 using System.Globalization;
+#if NET5_0_OR_GREATER
 using System.Linq;
 using Microsoft.Build.Framework;
+#endif
 using Microsoft.Build.Shared;
 
 #nullable disable
diff --git a/src/Tasks/Exec.cs b/src/Tasks/Exec.cs
index c05a3afb682..9e6eca86c59 100644
--- a/src/Tasks/Exec.cs
+++ b/src/Tasks/Exec.cs
@@ -196,7 +196,7 @@ private void CreateTemporaryBatchFile()
             var encoding = EncodingUtilities.BatchFileEncoding(Command + WorkingDirectory, UseUtf8Encoding);
 
             // Temporary file with the extension .Exec.bat
-            _batchFile = FileUtilities.GetTemporaryFile(".exec.cmd");
+            _batchFile = FileUtilities.GetTemporaryFileName(".exec.cmd");
 
             // UNICODE Batch files are not allowed as of WinXP. We can't use normal ANSI code pages either,
             // since console-related apps use OEM code pages "for historical reasons". Sigh.
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 97fc039caf3..8671210a76b 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -23,9 +23,9 @@
 using System.Runtime.InteropServices;
 #if FEATURE_APPDOMAIN
 using System.Runtime.Remoting;
+using System.Runtime.Serialization.Formatters.Binary;
 #endif
 using System.Runtime.Serialization;
-using System.Runtime.Serialization.Formatters.Binary;
 #if !FEATURE_ASSEMBLYLOADCONTEXT
 using System.Runtime.Versioning;
 using System.Security;
@@ -40,7 +40,9 @@
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Tasks.ResourceHandling;
 using Microsoft.Build.Utilities;
+#if FEATURE_RESXREADER_LIVEDESERIALIZATION
 using Microsoft.Win32;
+#endif
 
 #nullable disable
 
@@ -913,24 +915,29 @@ public override bool Execute()
             return !Log.HasLoggedErrors && outOfProcExecutionSucceeded;
         }
 
+#if FEATURE_RESXREADER_LIVEDESERIALIZATION
         private static readonly bool AllowMOTW = !NativeMethodsShared.IsWindows || (Registry.GetValue(@"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\SDK", "AllowProcessOfUntrustedResourceFiles", null) is string allowUntrustedFiles && allowUntrustedFiles.Equals("true", StringComparison.OrdinalIgnoreCase));
 
         private const string CLSID_InternetSecurityManager = "7b8a2d94-0ac9-11d1-896c-00c04fb6bfc4";
         private const uint ZoneInternet = 3;
         private static IInternetSecurityManager internetSecurityManager = null;
+#endif
 
         // Resources can have arbitrarily serialized objects in them which can execute arbitrary code
         // so check to see if we should trust them before analyzing them
         private bool IsDangerous(String filename)
         {
+#if !FEATURE_RESXREADER_LIVEDESERIALIZATION
+            return false;
+        }
+#else
             // If they are opted out, there's no work to do
-            if (AllowMOTW || !NativeMethodsShared.IsWindows)
+            if (AllowMOTW)
             {
                 return false;
             }
 
             // First check the zone, if they are not an untrusted zone, they aren't dangerous
-
             if (internetSecurityManager == null)
             {
                 Type iismType = Type.GetTypeFromCLSID(new Guid(CLSID_InternetSecurityManager));
@@ -997,7 +1004,6 @@ private bool IsDangerous(String filename)
             return dangerous;
         }
 
-#if FEATURE_APPDOMAIN
         /// <summary>
         /// For setting OutputResources and ensuring it can be read after the second AppDomain has been unloaded.
         /// </summary>
@@ -1982,7 +1988,6 @@ private bool NeedSeparateAppDomainBasedOnSerializedType(XmlReader reader)
             // Return true to err on the side of caution. Error will appear later.
             return true;
         }
-#endif
 
         /// <summary>
         /// Deserializes a base64 block from a resx in order to figure out if its type is in the GAC.
@@ -2003,6 +2008,7 @@ private bool DetermineWhetherSerializedObjectLoads(string data)
                 return result != null;
             }
         }
+#endif
 
         /// <summary>
         /// Chars that should be ignored in the nicely justified block of base64
diff --git a/src/Tasks/GetCompatiblePlatform.cs b/src/Tasks/GetCompatiblePlatform.cs
index 9787b51e366..c68f60f13f9 100644
--- a/src/Tasks/GetCompatiblePlatform.cs
+++ b/src/Tasks/GetCompatiblePlatform.cs
@@ -5,7 +5,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
 using System;
-using System.Collections.Generic;
 
 namespace Microsoft.Build.Tasks
 {
diff --git a/src/Tasks/LockCheck.cs b/src/Tasks/LockCheck.cs
index fd499d4bc93..237a138dd64 100644
--- a/src/Tasks/LockCheck.cs
+++ b/src/Tasks/LockCheck.cs
@@ -7,7 +7,6 @@
 using System.Linq;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-using System.Text;
 
 #nullable disable
 
diff --git a/src/Tasks/ManifestUtil/ManifestWriter.cs b/src/Tasks/ManifestUtil/ManifestWriter.cs
index 1c85fae10f0..cc076b2a08a 100644
--- a/src/Tasks/ManifestUtil/ManifestWriter.cs
+++ b/src/Tasks/ManifestUtil/ManifestWriter.cs
@@ -123,7 +123,7 @@ private static void WriteManifest(Manifest manifest, Stream output, string targe
                 else
                 {
                     // May throw IO-related exceptions
-                    string temp = FileUtilities.GetTemporaryFile();
+                    string temp = FileUtilities.GetTemporaryFileName();
 
                     am.TrustInfo.Write(temp);
                     if (Util.logging)
diff --git a/src/Tasks/ManifestUtil/MetadataReader.cs b/src/Tasks/ManifestUtil/MetadataReader.cs
index dc7fc6529d4..1b2dbef040f 100644
--- a/src/Tasks/ManifestUtil/MetadataReader.cs
+++ b/src/Tasks/ManifestUtil/MetadataReader.cs
@@ -2,8 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Diagnostics.CodeAnalysis;
-using System.Runtime.InteropServices;
 using System.Collections.Specialized;
 #if RUNTIME_TYPE_NETCORE
 using System.Collections.Generic;
@@ -11,6 +9,9 @@
 using System.Reflection;
 using System.Reflection.Metadata;
 using System.Reflection.PortableExecutable;
+#else
+using System.Diagnostics.CodeAnalysis;
+using System.Runtime.InteropServices;
 #endif
 
 #nullable disable
diff --git a/src/Tasks/ManifestUtil/SecurityUtil.cs b/src/Tasks/ManifestUtil/SecurityUtil.cs
index 986370caf84..8e16ee1a599 100644
--- a/src/Tasks/ManifestUtil/SecurityUtil.cs
+++ b/src/Tasks/ManifestUtil/SecurityUtil.cs
@@ -1,11 +1,11 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.Framework;
 using Microsoft.Build.Utilities;
 using Microsoft.Win32;
 using System;
 #if !RUNTIME_TYPE_NETCORE
+using Microsoft.Build.Framework;
 using System.Collections.Generic;
 #endif
 using System.ComponentModel;
diff --git a/src/Tasks/ManifestUtil/TrustInfo.cs b/src/Tasks/ManifestUtil/TrustInfo.cs
index ce5a2b4843e..dc7880cd52a 100644
--- a/src/Tasks/ManifestUtil/TrustInfo.cs
+++ b/src/Tasks/ManifestUtil/TrustInfo.cs
@@ -8,8 +8,10 @@
 using System.Globalization;
 using System.IO;
 using System.Runtime.InteropServices;
+#if !RUNTIME_TYPE_NETCORE
 using System.Security;
 using System.Security.Permissions;
+#endif
 using System.Xml;
 using Microsoft.Build.Shared.FileSystem;
 
diff --git a/src/Tasks/ManifestUtil/Util.cs b/src/Tasks/ManifestUtil/Util.cs
index 85434a45d44..fd197c183f5 100644
--- a/src/Tasks/ManifestUtil/Util.cs
+++ b/src/Tasks/ManifestUtil/Util.cs
@@ -510,7 +510,7 @@ public static void WriteLogFile(string filename, System.Xml.XmlElement element)
         public static string WriteTempFile(Stream s)
         {
             // May throw IO-related exceptions
-            string path = FileUtilities.GetTemporaryFile();
+            string path = FileUtilities.GetTemporaryFileName();
 
             WriteFile(path, s);
             return path;
@@ -519,7 +519,7 @@ public static string WriteTempFile(Stream s)
         public static string WriteTempFile(string s)
         {
             // May throw IO-related exceptions
-            string path = FileUtilities.GetTemporaryFile();
+            string path = FileUtilities.GetTemporaryFileName();
 
             WriteFile(path, s);
             return path;
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 6421d98c638..972776ac9e0 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -16,6 +16,7 @@
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which implements the commonly used tasks of MSBuild.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <ApplyNgenOptimization Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">full</ApplyNgenOptimization>
+    <EnablePackageValidation>true</EnablePackageValidation>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 73e8d25dbb4..1db9e025afa 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -5713,7 +5713,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
     <RemoveDir
         Directories="$(ClickOncePublishDir)"
-        Condition="Exists('$(ClickOncePublishDir)')"/>
+        Condition="'$(ClickOncePublishDir)'=='$(OutputPath)app.publish\' and Exists('$(ClickOncePublishDir)')"/>
 
   </Target>
 
diff --git a/src/Tasks/NativeMethods.cs b/src/Tasks/NativeMethods.cs
index 7ea9782cedb..b7f212ebe43 100644
--- a/src/Tasks/NativeMethods.cs
+++ b/src/Tasks/NativeMethods.cs
@@ -13,7 +13,9 @@
 using System.Collections;
 using System.Globalization;
 using System.Linq;
+#if FEATURE_HANDLEPROCESSCORRUPTEDSTATEEXCEPTIONS
 using System.Runtime.ExceptionServices;
+#endif
 using System.Text.RegularExpressions;
 using System.Runtime.Versioning;
 
@@ -514,12 +516,6 @@ internal struct PROCESS_INFORMATION
         public int dwThreadId;
     }
 
-    internal enum SymbolicLink
-    {
-        File = 0,
-        Directory = 1
-    }
-
     /// <summary>
     /// Interop methods.
     /// </summary>
@@ -818,33 +814,6 @@ internal static bool MakeHardLink(string newFileName, string exitingFileName, re
             return hardLinkCreated;
         }
 
-        //------------------------------------------------------------------------------
-        // CreateSymbolicLink
-        //------------------------------------------------------------------------------
-        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
-        [return: MarshalAs(UnmanagedType.I1)]
-        internal static extern bool CreateSymbolicLink(string symLinkFileName, string targetFileName, SymbolicLink dwFlags);
-
-        [DllImport("libc", SetLastError = true)]
-        internal static extern int symlink(string oldpath, string newpath);
-
-        internal static bool MakeSymbolicLink(string newFileName, string exitingFileName, ref string errorMessage)
-        {
-            bool symbolicLinkCreated;
-            if (NativeMethodsShared.IsWindows)
-            {
-                symbolicLinkCreated = CreateSymbolicLink(newFileName, exitingFileName, SymbolicLink.File);
-                errorMessage = symbolicLinkCreated ? null : Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()).Message;
-            }
-            else
-            {
-                symbolicLinkCreated = symlink(exitingFileName, newFileName) == 0;
-                errorMessage = symbolicLinkCreated ? null : "The link() library call failed with the following error code: " + Marshal.GetLastWin32Error();
-            }
-
-            return symbolicLinkCreated;
-        }
-
         //------------------------------------------------------------------------------
         // MoveFileEx
         //------------------------------------------------------------------------------
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index 1cc4f59b5e8..00000000000
--- a/src/Tasks/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,2429 +0,0 @@
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.IsSourceFile(string fileName) -> bool
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.SourceFileExtension.get -> string
-abstract Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SortName.get -> string
-abstract Microsoft.Build.Tasks.GenerateManifestBase.GetObjectType() -> System.Type
-abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
-abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
-Microsoft.Build.Tasks.AL
-Microsoft.Build.Tasks.AL.AL() -> void
-Microsoft.Build.Tasks.AL.AlgorithmId.get -> string
-Microsoft.Build.Tasks.AL.AlgorithmId.set -> void
-Microsoft.Build.Tasks.AL.BaseAddress.get -> string
-Microsoft.Build.Tasks.AL.BaseAddress.set -> void
-Microsoft.Build.Tasks.AL.CompanyName.get -> string
-Microsoft.Build.Tasks.AL.CompanyName.set -> void
-Microsoft.Build.Tasks.AL.Configuration.get -> string
-Microsoft.Build.Tasks.AL.Configuration.set -> void
-Microsoft.Build.Tasks.AL.Copyright.get -> string
-Microsoft.Build.Tasks.AL.Copyright.set -> void
-Microsoft.Build.Tasks.AL.Culture.get -> string
-Microsoft.Build.Tasks.AL.Culture.set -> void
-Microsoft.Build.Tasks.AL.DelaySign.get -> bool
-Microsoft.Build.Tasks.AL.DelaySign.set -> void
-Microsoft.Build.Tasks.AL.Description.get -> string
-Microsoft.Build.Tasks.AL.Description.set -> void
-Microsoft.Build.Tasks.AL.EmbedResources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AL.EmbedResources.set -> void
-Microsoft.Build.Tasks.AL.EvidenceFile.get -> string
-Microsoft.Build.Tasks.AL.EvidenceFile.set -> void
-Microsoft.Build.Tasks.AL.FileVersion.get -> string
-Microsoft.Build.Tasks.AL.FileVersion.set -> void
-Microsoft.Build.Tasks.AL.Flags.get -> string
-Microsoft.Build.Tasks.AL.Flags.set -> void
-Microsoft.Build.Tasks.AL.GenerateFullPaths.get -> bool
-Microsoft.Build.Tasks.AL.GenerateFullPaths.set -> void
-Microsoft.Build.Tasks.AL.KeyContainer.get -> string
-Microsoft.Build.Tasks.AL.KeyContainer.set -> void
-Microsoft.Build.Tasks.AL.KeyFile.get -> string
-Microsoft.Build.Tasks.AL.KeyFile.set -> void
-Microsoft.Build.Tasks.AL.LinkResources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AL.LinkResources.set -> void
-Microsoft.Build.Tasks.AL.MainEntryPoint.get -> string
-Microsoft.Build.Tasks.AL.MainEntryPoint.set -> void
-Microsoft.Build.Tasks.AL.OutputAssembly.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.AL.OutputAssembly.set -> void
-Microsoft.Build.Tasks.AL.Platform.get -> string
-Microsoft.Build.Tasks.AL.Platform.set -> void
-Microsoft.Build.Tasks.AL.Prefer32Bit.get -> bool
-Microsoft.Build.Tasks.AL.Prefer32Bit.set -> void
-Microsoft.Build.Tasks.AL.ProductName.get -> string
-Microsoft.Build.Tasks.AL.ProductName.set -> void
-Microsoft.Build.Tasks.AL.ProductVersion.get -> string
-Microsoft.Build.Tasks.AL.ProductVersion.set -> void
-Microsoft.Build.Tasks.AL.ResponseFiles.get -> string[]
-Microsoft.Build.Tasks.AL.ResponseFiles.set -> void
-Microsoft.Build.Tasks.AL.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.AL.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.AL.SourceModules.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AL.SourceModules.set -> void
-Microsoft.Build.Tasks.AL.TargetType.get -> string
-Microsoft.Build.Tasks.AL.TargetType.set -> void
-Microsoft.Build.Tasks.AL.TemplateFile.get -> string
-Microsoft.Build.Tasks.AL.TemplateFile.set -> void
-Microsoft.Build.Tasks.AL.Title.get -> string
-Microsoft.Build.Tasks.AL.Title.set -> void
-Microsoft.Build.Tasks.AL.Trademark.get -> string
-Microsoft.Build.Tasks.AL.Trademark.set -> void
-Microsoft.Build.Tasks.AL.Version.get -> string
-Microsoft.Build.Tasks.AL.Version.set -> void
-Microsoft.Build.Tasks.AL.Win32Icon.get -> string
-Microsoft.Build.Tasks.AL.Win32Icon.set -> void
-Microsoft.Build.Tasks.AL.Win32Resource.get -> string
-Microsoft.Build.Tasks.AL.Win32Resource.set -> void
-Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension
-Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Tasks.AspNetCompiler
-Microsoft.Build.Tasks.AspNetCompiler.AllowPartiallyTrustedCallers.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.AllowPartiallyTrustedCallers.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.AspNetCompiler() -> void
-Microsoft.Build.Tasks.AspNetCompiler.Clean.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.Clean.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.Debug.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.Debug.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.DelaySign.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.DelaySign.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.FixedNames.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.FixedNames.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.Force.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.Force.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.KeyContainer.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.KeyContainer.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.KeyFile.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.KeyFile.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.MetabasePath.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.MetabasePath.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.PhysicalPath.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.PhysicalPath.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.TargetPath.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.TargetPath.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.Updateable.get -> bool
-Microsoft.Build.Tasks.AspNetCompiler.Updateable.set -> void
-Microsoft.Build.Tasks.AspNetCompiler.VirtualPath.get -> string
-Microsoft.Build.Tasks.AspNetCompiler.VirtualPath.set -> void
-Microsoft.Build.Tasks.AssignCulture
-Microsoft.Build.Tasks.AssignCulture.AssignCulture() -> void
-Microsoft.Build.Tasks.AssignCulture.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithCulture.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithNoCulture.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.CultureNeutralAssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.Files.set -> void
-Microsoft.Build.Tasks.AssignLinkMetadata
-Microsoft.Build.Tasks.AssignLinkMetadata.AssignLinkMetadata() -> void
-Microsoft.Build.Tasks.AssignLinkMetadata.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignLinkMetadata.Items.set -> void
-Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration
-Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignProjectConfiguration() -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.set -> void
-Microsoft.Build.Tasks.AssignTargetPath
-Microsoft.Build.Tasks.AssignTargetPath.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignTargetPath.AssignTargetPath() -> void
-Microsoft.Build.Tasks.AssignTargetPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignTargetPath.Files.set -> void
-Microsoft.Build.Tasks.AssignTargetPath.RootFolder.get -> string
-Microsoft.Build.Tasks.AssignTargetPath.RootFolder.set -> void
-Microsoft.Build.Tasks.CallTarget
-Microsoft.Build.Tasks.CallTarget.CallTarget() -> void
-Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.get -> bool
-Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.set -> void
-Microsoft.Build.Tasks.CallTarget.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CallTarget.Targets.get -> string[]
-Microsoft.Build.Tasks.CallTarget.Targets.set -> void
-Microsoft.Build.Tasks.CallTarget.UseResultsCache.get -> bool
-Microsoft.Build.Tasks.CallTarget.UseResultsCache.set -> void
-Microsoft.Build.Tasks.CodeTaskFactory
-Microsoft.Build.Tasks.CodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.CodeTaskFactory.CodeTaskFactory() -> void
-Microsoft.Build.Tasks.CodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine loggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.CodeTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.CodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.CodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> taskParameters, string taskElementContents, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.CodeTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.CombinePath
-Microsoft.Build.Tasks.CombinePath.BasePath.get -> string
-Microsoft.Build.Tasks.CombinePath.BasePath.set -> void
-Microsoft.Build.Tasks.CombinePath.CombinedPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombinePath.CombinedPaths.set -> void
-Microsoft.Build.Tasks.CombinePath.CombinePath() -> void
-Microsoft.Build.Tasks.CombinePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombinePath.Paths.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.CombineTargetFrameworkInfoProperties() -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.get -> string
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.get -> string
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.get -> bool
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.set -> void
-Microsoft.Build.Tasks.CombineXmlElements
-Microsoft.Build.Tasks.CombineXmlElements.CombineXmlElements() -> void
-Microsoft.Build.Tasks.CombineXmlElements.Result.get -> string
-Microsoft.Build.Tasks.CombineXmlElements.Result.set -> void
-Microsoft.Build.Tasks.CombineXmlElements.RootElementName.get -> string
-Microsoft.Build.Tasks.CombineXmlElements.RootElementName.set -> void
-Microsoft.Build.Tasks.CombineXmlElements.XmlElements.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombineXmlElements.XmlElements.set -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension
-Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension() -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension.GetQuotedText(string unquotedText) -> string
-Microsoft.Build.Tasks.ConvertToAbsolutePath
-Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.set -> void
-Microsoft.Build.Tasks.ConvertToAbsolutePath.ConvertToAbsolutePath() -> void
-Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.set -> void
-Microsoft.Build.Tasks.Copy
-Microsoft.Build.Tasks.Copy.Cancel() -> void
-Microsoft.Build.Tasks.Copy.CopiedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.Copy() -> void
-Microsoft.Build.Tasks.Copy.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.DestinationFiles.set -> void
-Microsoft.Build.Tasks.Copy.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Copy.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.get -> bool
-Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.set -> void
-Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Copy.Retries.get -> int
-Microsoft.Build.Tasks.Copy.Retries.set -> void
-Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.get -> int
-Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.set -> void
-Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.Copy.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.SourceFiles.set -> void
-Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.get -> bool
-Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.set -> void
-Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.get -> bool
-Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.set -> void
-Microsoft.Build.Tasks.Copy.WroteAtLeastOneFile.get -> bool
-Microsoft.Build.Tasks.CreateCSharpManifestResourceName
-Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateCSharpManifestResourceName() -> void
-Microsoft.Build.Tasks.CreateItem
-Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.get -> string[]
-Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.set -> void
-Microsoft.Build.Tasks.CreateItem.CreateItem() -> void
-Microsoft.Build.Tasks.CreateItem.Exclude.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateItem.Exclude.set -> void
-Microsoft.Build.Tasks.CreateItem.Include.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateItem.Include.set -> void
-Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.get -> bool
-Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName
-Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestResourceName() -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.itemSpecToTaskitem -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Framework.ITaskItem>
-Microsoft.Build.Tasks.CreateManifestResourceName.ManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.get -> bool
-Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.get -> string
-Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.get -> bool
-Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.set -> void
-Microsoft.Build.Tasks.CreateProperty
-Microsoft.Build.Tasks.CreateProperty.CreateProperty() -> void
-Microsoft.Build.Tasks.CreateProperty.Value.get -> string[]
-Microsoft.Build.Tasks.CreateProperty.Value.set -> void
-Microsoft.Build.Tasks.CreateProperty.ValueSetByTask.get -> string[]
-Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName
-Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateVisualBasicManifestResourceName() -> void
-Microsoft.Build.Tasks.Delete
-Microsoft.Build.Tasks.Delete.Cancel() -> void
-Microsoft.Build.Tasks.Delete.Delete() -> void
-Microsoft.Build.Tasks.Delete.DeletedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Delete.DeletedFiles.set -> void
-Microsoft.Build.Tasks.Delete.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Delete.Files.set -> void
-Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.get -> bool
-Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder(string visualStudioVersion) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation componentsLocation) -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpId.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Message.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Error = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Info = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Warning = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.ComponentFiles.get -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.KeyFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Succeeded.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.BuildSettings() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Absolute = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.HomeSite = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Relative = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpId.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Message.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.ComponentFiles.get -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.KeyFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Succeeded.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Name.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductCode.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Name.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Product() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductCode.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity deployManifestIdentity, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity applicationManifestIdentity) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest(string targetFrameworkVersion) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.FileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.All = Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture | Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Default = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.GetFullName(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags flags) -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsFrameworkAssembly.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsInFramework(string frameworkIdentifier, string frameworkVersion) -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsNeutralPlatform.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsStrongName.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.AssemblyManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.ExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assembly) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(string name) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assemblyReference) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ClickOnceManifest = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ManagedAssembly = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.NativeAssembly = 3 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.Unspecified = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.get -> long
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ClsId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ComClass() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ThreadingModel.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.CompatibleFramework() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework compatibleFramework) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest(string targetFrameworkMoniker) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.FileAssociation() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation fileAssociation) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.TypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.Build(string filename, string outputPath) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherBuilder(string launcherPath) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.FileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.get -> System.IO.Stream
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Manifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.OutputMessages.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles(string[] searchPaths) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo(string targetFrameworkVersion) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ValidatePlatform() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.GetArguments() -> string[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Text.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Type.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.ErrorCount.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.WarningCount.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Error = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Info = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Warning = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.BaseInterface.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.IID.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.NumMethods.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.ProxyStub() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.HasUnmanagedCodePermission.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.IsFullTrust.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.IsFullTrust.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PermissionSet.get -> System.Security.PermissionSet
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PermissionSet.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(System.IO.Stream input) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(System.IO.Stream input) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.TrustInfo() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream input, System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Flags.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.HelpDirectory.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.ResourceId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TypeLib() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Background = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Foreground = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Days = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Hours = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Weeks = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Versioned.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass(string name, bool versioned) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.set -> void
-Microsoft.Build.Tasks.DownloadFile
-Microsoft.Build.Tasks.DownloadFile.Cancel() -> void
-Microsoft.Build.Tasks.DownloadFile.DestinationFileName.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DestinationFileName.set -> void
-Microsoft.Build.Tasks.DownloadFile.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DestinationFolder.set -> void
-Microsoft.Build.Tasks.DownloadFile.DownloadedFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DownloadedFile.set -> void
-Microsoft.Build.Tasks.DownloadFile.DownloadFile() -> void
-Microsoft.Build.Tasks.DownloadFile.Retries.get -> int
-Microsoft.Build.Tasks.DownloadFile.Retries.set -> void
-Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.get -> int
-Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.set -> void
-Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.DownloadFile.SourceUrl.get -> string
-Microsoft.Build.Tasks.DownloadFile.SourceUrl.set -> void
-Microsoft.Build.Tasks.DownloadFile.Timeout.get -> int
-Microsoft.Build.Tasks.DownloadFile.Timeout.set -> void
-Microsoft.Build.Tasks.Error
-Microsoft.Build.Tasks.Error.Code.get -> string
-Microsoft.Build.Tasks.Error.Code.set -> void
-Microsoft.Build.Tasks.Error.Error() -> void
-Microsoft.Build.Tasks.Error.File.get -> string
-Microsoft.Build.Tasks.Error.File.set -> void
-Microsoft.Build.Tasks.Error.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Error.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Error.HelpLink.get -> string
-Microsoft.Build.Tasks.Error.HelpLink.set -> void
-Microsoft.Build.Tasks.Error.Text.get -> string
-Microsoft.Build.Tasks.Error.Text.set -> void
-Microsoft.Build.Tasks.ErrorFromResources
-Microsoft.Build.Tasks.ErrorFromResources.Arguments.get -> string[]
-Microsoft.Build.Tasks.ErrorFromResources.Arguments.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.Code.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.Code.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.ErrorFromResources() -> void
-Microsoft.Build.Tasks.ErrorFromResources.File.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.File.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.Resource.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.Resource.set -> void
-Microsoft.Build.Tasks.Exec
-Microsoft.Build.Tasks.Exec.Command.get -> string
-Microsoft.Build.Tasks.Exec.Command.set -> void
-Microsoft.Build.Tasks.Exec.ConsoleOutput.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.get -> bool
-Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.set -> void
-Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.get -> string
-Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.set -> void
-Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.get -> string
-Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.set -> void
-Microsoft.Build.Tasks.Exec.Exec() -> void
-Microsoft.Build.Tasks.Exec.IgnoreExitCode.get -> bool
-Microsoft.Build.Tasks.Exec.IgnoreExitCode.set -> void
-Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.get -> bool
-Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.set -> void
-Microsoft.Build.Tasks.Exec.Outputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Exec.Outputs.set -> void
-Microsoft.Build.Tasks.Exec.StdErrEncoding.get -> string
-Microsoft.Build.Tasks.Exec.StdErrEncoding.set -> void
-Microsoft.Build.Tasks.Exec.StdOutEncoding.get -> string
-Microsoft.Build.Tasks.Exec.StdOutEncoding.set -> void
-Microsoft.Build.Tasks.Exec.WorkingDirectory.get -> string
-Microsoft.Build.Tasks.Exec.WorkingDirectory.set -> void
-Microsoft.Build.Tasks.ExtractedClassName
-Microsoft.Build.Tasks.ExtractedClassName.ExtractedClassName() -> void
-Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.get -> bool
-Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.set -> void
-Microsoft.Build.Tasks.ExtractedClassName.Name.get -> string
-Microsoft.Build.Tasks.ExtractedClassName.Name.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile
-Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.FindAppConfigFile() -> void
-Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.get -> string
-Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.set -> void
-Microsoft.Build.Tasks.FindInList
-Microsoft.Build.Tasks.FindInList.CaseSensitive.get -> bool
-Microsoft.Build.Tasks.FindInList.CaseSensitive.set -> void
-Microsoft.Build.Tasks.FindInList.FindInList() -> void
-Microsoft.Build.Tasks.FindInList.FindLastMatch.get -> bool
-Microsoft.Build.Tasks.FindInList.FindLastMatch.set -> void
-Microsoft.Build.Tasks.FindInList.ItemFound.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindInList.ItemFound.set -> void
-Microsoft.Build.Tasks.FindInList.ItemSpecToFind.get -> string
-Microsoft.Build.Tasks.FindInList.ItemSpecToFind.set -> void
-Microsoft.Build.Tasks.FindInList.List.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInList.List.set -> void
-Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.get -> bool
-Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences
-Microsoft.Build.Tasks.FindInvalidProjectReferences.FindInvalidProjectReferences() -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.InvalidReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.FindUnderPath
-Microsoft.Build.Tasks.FindUnderPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.Files.set -> void
-Microsoft.Build.Tasks.FindUnderPath.FindUnderPath() -> void
-Microsoft.Build.Tasks.FindUnderPath.InPath.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.InPath.set -> void
-Microsoft.Build.Tasks.FindUnderPath.OutOfPath.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.OutOfPath.set -> void
-Microsoft.Build.Tasks.FindUnderPath.Path.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindUnderPath.Path.set -> void
-Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.get -> bool
-Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.set -> void
-Microsoft.Build.Tasks.FormatUrl
-Microsoft.Build.Tasks.FormatUrl.FormatUrl() -> void
-Microsoft.Build.Tasks.FormatUrl.InputUrl.get -> string
-Microsoft.Build.Tasks.FormatUrl.InputUrl.set -> void
-Microsoft.Build.Tasks.FormatUrl.OutputUrl.get -> string
-Microsoft.Build.Tasks.FormatUrl.OutputUrl.set -> void
-Microsoft.Build.Tasks.FormatVersion
-Microsoft.Build.Tasks.FormatVersion.FormatType.get -> string
-Microsoft.Build.Tasks.FormatVersion.FormatType.set -> void
-Microsoft.Build.Tasks.FormatVersion.FormatVersion() -> void
-Microsoft.Build.Tasks.FormatVersion.OutputVersion.get -> string
-Microsoft.Build.Tasks.FormatVersion.OutputVersion.set -> void
-Microsoft.Build.Tasks.FormatVersion.Revision.get -> int
-Microsoft.Build.Tasks.FormatVersion.Revision.set -> void
-Microsoft.Build.Tasks.FormatVersion.Version.get -> string
-Microsoft.Build.Tasks.FormatVersion.Version.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest
-Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.Files.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.GenerateApplicationManifest() -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Product.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.Product.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects
-Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.GenerateBindingRedirects() -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.get -> string
-Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationFile.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationFile.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationName.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationName.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationRequiresElevation.get -> bool
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationRequiresElevation.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationUrl.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.ApplicationUrl.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperComponentFiles.get -> string[]
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperComponentFiles.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperItems.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperItems.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperKeyFile.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.BootstrapperKeyFile.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsLocation.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsLocation.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsUrl.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.ComponentsUrl.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.CopyComponents.get -> bool
-Microsoft.Build.Tasks.GenerateBootstrapper.CopyComponents.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.Culture.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.Culture.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.FallbackCulture.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.FallbackCulture.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.GenerateBootstrapper() -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.OutputPath.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.OutputPath.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.Path.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.Path.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.SupportUrl.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.SupportUrl.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.Validate.get -> bool
-Microsoft.Build.Tasks.GenerateBootstrapper.Validate.set -> void
-Microsoft.Build.Tasks.GenerateBootstrapper.VisualStudioVersion.get -> string
-Microsoft.Build.Tasks.GenerateBootstrapper.VisualStudioVersion.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest
-Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.GenerateDeploymentManifest() -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.get -> int
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.set -> void
-Microsoft.Build.Tasks.GenerateLauncher
-Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.GenerateLauncher() -> void
-Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.OutputPath.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.OutputPath.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase
-Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyNameFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddEntryPointFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.Description.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.Description.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.FindFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.GenerateManifestBase.GenerateManifestBase() -> void
-Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.get -> int
-Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.Platform.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.Platform.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.GenerateResource
-Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.set -> void
-Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.get -> string[]
-Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.get -> bool
-Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.get -> bool
-Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.set -> void
-Microsoft.Build.Tasks.GenerateResource.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.GenerateResource() -> void
-Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.get -> bool
-Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.set -> void
-Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.get -> bool
-Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.set -> void
-Microsoft.Build.Tasks.GenerateResource.OutputDirectory.get -> string
-Microsoft.Build.Tasks.GenerateResource.OutputDirectory.set -> void
-Microsoft.Build.Tasks.GenerateResource.OutputResources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.OutputResources.set -> void
-Microsoft.Build.Tasks.GenerateResource.PublicClass.get -> bool
-Microsoft.Build.Tasks.GenerateResource.PublicClass.set -> void
-Microsoft.Build.Tasks.GenerateResource.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.References.set -> void
-Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.Sources.set -> void
-Microsoft.Build.Tasks.GenerateResource.StateFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateResource.StateFile.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.set -> void
-Microsoft.Build.Tasks.GenerateResource.TLogReadFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.TLogWriteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.get -> string
-Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.get -> bool
-Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.set -> void
-Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.get -> bool
-Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.set -> void
-Microsoft.Build.Tasks.GenerateResource.UseSourcePath.get -> bool
-Microsoft.Build.Tasks.GenerateResource.UseSourcePath.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo
-Microsoft.Build.Tasks.GenerateTrustInfo.ApplicationDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateTrustInfo.ApplicationDependencies.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.BaseManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateTrustInfo.BaseManifest.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.ExcludedPermissions.get -> string
-Microsoft.Build.Tasks.GenerateTrustInfo.ExcludedPermissions.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.GenerateTrustInfo() -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.GenerateTrustInfo.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.TargetZone.get -> string
-Microsoft.Build.Tasks.GenerateTrustInfo.TargetZone.set -> void
-Microsoft.Build.Tasks.GenerateTrustInfo.TrustInfoFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateTrustInfo.TrustInfoFile.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity
-Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity.GetAssemblyIdentity() -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform
-Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.get -> string
-Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.GetCompatiblePlatform() -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.get -> string
-Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.set -> void
-Microsoft.Build.Tasks.GetFileHash
-Microsoft.Build.Tasks.GetFileHash.Algorithm.get -> string
-Microsoft.Build.Tasks.GetFileHash.Algorithm.set -> void
-Microsoft.Build.Tasks.GetFileHash.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetFileHash.Files.set -> void
-Microsoft.Build.Tasks.GetFileHash.GetFileHash() -> void
-Microsoft.Build.Tasks.GetFileHash.Hash.get -> string
-Microsoft.Build.Tasks.GetFileHash.Hash.set -> void
-Microsoft.Build.Tasks.GetFileHash.HashEncoding.get -> string
-Microsoft.Build.Tasks.GetFileHash.HashEncoding.set -> void
-Microsoft.Build.Tasks.GetFileHash.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetFileHash.Items.set -> void
-Microsoft.Build.Tasks.GetFileHash.MetadataName.get -> string
-Microsoft.Build.Tasks.GetFileHash.MetadataName.set -> void
-Microsoft.Build.Tasks.GetFrameworkPath
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion11Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion20Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion30Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion35Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion40Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion451Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion452Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion45Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion461Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion462Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion46Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion471Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion472Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion47Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion48Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.GetFrameworkPath() -> void
-Microsoft.Build.Tasks.GetFrameworkPath.Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion20Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion35Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion40Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion451Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion45Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion461Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.FrameworkSdkVersion46Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.GetFrameworkSdkPath() -> void
-Microsoft.Build.Tasks.GetFrameworkSdkPath.Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkSdkPath.Path.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations
-Microsoft.Build.Tasks.GetInstalledSDKLocations.GetInstalledSDKLocations() -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.get -> string[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.get -> string[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.get -> bool
-Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.get -> bool
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.FullFrameworkReferenceAssemblyPaths.get -> string[]
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.GetReferenceAssemblyPaths() -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.ReferenceAssemblyPaths.get -> string[]
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.get -> bool
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.GetSDKReferenceFiles() -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.RedistFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.get -> string[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.set -> void
-Microsoft.Build.Tasks.Hash
-Microsoft.Build.Tasks.Hash.Hash() -> void
-Microsoft.Build.Tasks.Hash.HashResult.get -> string
-Microsoft.Build.Tasks.Hash.HashResult.set -> void
-Microsoft.Build.Tasks.Hash.IgnoreCase.get -> bool
-Microsoft.Build.Tasks.Hash.IgnoreCase.set -> void
-Microsoft.Build.Tasks.Hash.ItemsToHash.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Hash.ItemsToHash.set -> void
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAdditionalFiles(Microsoft.Build.Framework.ITaskItem[] additionalFiles) -> bool
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAnalyzers(Microsoft.Build.Framework.ITaskItem[] analyzers) -> bool
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetRuleSet(string ruleSetFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject
-Microsoft.Build.Tasks.Hosting.ICscHostObject.BeginInitialization() -> void
-Microsoft.Build.Tasks.Hosting.ICscHostObject.Compile() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.EndInitialization(out string errorMessage, out int errorCode) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.IsDesignTime() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.IsUpToDate() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAddModules(string[] addModules) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAllowUnsafeBlocks(bool allowUnsafeBlocks) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetBaseAddress(string baseAddress) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCheckForOverflowUnderflow(bool checkForOverflowUnderflow) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCodePage(int codePage) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDebugType(string debugType) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDefineConstants(string defineConstants) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDelaySign(bool delaySignExplicitlySet, bool delaySign) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDocumentationFile(string documentationFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetEmitDebugInformation(bool emitDebugInformation) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetErrorReport(string errorReport) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetFileAlignment(int fileAlignment) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetGenerateFullPaths(bool generateFullPaths) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyContainer(string keyContainer) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyFile(string keyFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLangVersion(string langVersion) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetMainEntryPoint(string targetType, string mainEntryPoint) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetModuleAssemblyName(string moduleAssemblyName) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoConfig(bool noConfig) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoStandardLib(bool noStandardLib) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOptimize(bool optimize) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOutputAssembly(string outputAssembly) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPdbFile(string pdbFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPlatform(string platform) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTargetType(string targetType) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningLevel(int warningLevel) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Icon(string win32Icon) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Resource(string win32Resource) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject2
-Microsoft.Build.Tasks.Hosting.ICscHostObject2.SetWin32Manifest(string win32Manifest) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject3
-Microsoft.Build.Tasks.Hosting.ICscHostObject3.SetApplicationConfiguration(string applicationConfiguration) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetHighEntropyVA(bool highEntropyVA) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetSubsystemVersion(string subsystemVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.BeginInitialization() -> void
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.Compile() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.EndInitialization() -> void
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsDesignTime() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsUpToDate() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAddModules(string[] addModules) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetBaseAddress(string targetType, string baseAddress) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetCodePage(int codePage) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDebugType(bool emitDebugInformation, string debugType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDefineConstants(string defineConstants) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDelaySign(bool delaySign) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDocumentationFile(string documentationFile) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetErrorReport(string errorReport) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetFileAlignment(int fileAlignment) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetGenerateDocumentation(bool generateDocumentation) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetImports(Microsoft.Build.Framework.ITaskItem[] importsList) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyContainer(string keyContainer) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyFile(string keyFile) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetMainEntryPoint(string mainEntryPoint) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoConfig(bool noConfig) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoStandardLib(bool noStandardLib) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoWarnings(bool noWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptimize(bool optimize) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionCompare(string optionCompare) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionExplicit(bool optionExplicit) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrict(bool optionStrict) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrictType(string optionStrictType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOutputAssembly(string outputAssembly) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetPlatform(string platform) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRemoveIntegerChecks(bool removeIntegerChecks) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRootNamespace(string rootNamespace) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSdkPath(string sdkPath) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetCompactFramework(bool targetCompactFramework) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetType(string targetType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Icon(string win32Icon) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Resource(string win32Resource) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetModuleAssemblyName(string moduleAssemblyName) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetOptionInfer(bool optionInfer) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetWin32Manifest(string win32Manifest) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject3
-Microsoft.Build.Tasks.Hosting.IVbcHostObject3.SetLanguageVersion(string languageVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject4
-Microsoft.Build.Tasks.Hosting.IVbcHostObject4.SetVBRuntime(string VBRuntime) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.CompileAsync(out System.IntPtr buildSucceededEvent, out System.IntPtr buildFailedEvent) -> int
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.EndCompile(bool buildSuccess) -> int
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.GetFreeThreadedHostObject() -> Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetHighEntropyVA(bool highEntropyVA) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetSubsystemVersion(string subsystemVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
-Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded.Compile() -> bool
-Microsoft.Build.Tasks.IFixedTypeInfo
-Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(object pUnkOuter, ref System.Guid riid, out object ppvObj) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(out System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, out int pIndex) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, System.IntPtr pBstrDllName, System.IntPtr pBstrName, System.IntPtr pwOrdinal) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(int index, out System.IntPtr ppFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(int index, out System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(int memid, out string pBstrMops) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out Microsoft.Build.Tasks.IFixedTypeInfo ppTI) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeOfImplType(int index, out System.IntPtr href) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeAttr(out System.IntPtr ppTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeComp(out System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetVarDesc(int index, out System.IntPtr ppVarDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, System.IntPtr pVarResult, System.IntPtr pExcepInfo, out int puArgErr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr pFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr pTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr pVarDesc) -> void
-Microsoft.Build.Tasks.LC
-Microsoft.Build.Tasks.LC.LC() -> void
-Microsoft.Build.Tasks.LC.LicenseTarget.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.LC.LicenseTarget.set -> void
-Microsoft.Build.Tasks.LC.NoLogo.get -> bool
-Microsoft.Build.Tasks.LC.NoLogo.set -> void
-Microsoft.Build.Tasks.LC.OutputDirectory.get -> string
-Microsoft.Build.Tasks.LC.OutputDirectory.set -> void
-Microsoft.Build.Tasks.LC.OutputLicense.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.LC.OutputLicense.set -> void
-Microsoft.Build.Tasks.LC.ReferencedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.LC.ReferencedAssemblies.set -> void
-Microsoft.Build.Tasks.LC.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.LC.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.LC.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.LC.Sources.set -> void
-Microsoft.Build.Tasks.LC.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.LC.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.MakeDir
-Microsoft.Build.Tasks.MakeDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MakeDir.Directories.set -> void
-Microsoft.Build.Tasks.MakeDir.DirectoriesCreated.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MakeDir.MakeDir() -> void
-Microsoft.Build.Tasks.Message
-Microsoft.Build.Tasks.Message.Code.get -> string
-Microsoft.Build.Tasks.Message.Code.set -> void
-Microsoft.Build.Tasks.Message.File.get -> string
-Microsoft.Build.Tasks.Message.File.set -> void
-Microsoft.Build.Tasks.Message.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Message.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Message.Importance.get -> string
-Microsoft.Build.Tasks.Message.Importance.set -> void
-Microsoft.Build.Tasks.Message.IsCritical.get -> bool
-Microsoft.Build.Tasks.Message.IsCritical.set -> void
-Microsoft.Build.Tasks.Message.Message() -> void
-Microsoft.Build.Tasks.Message.Text.get -> string
-Microsoft.Build.Tasks.Message.Text.set -> void
-Microsoft.Build.Tasks.Move
-Microsoft.Build.Tasks.Move.Cancel() -> void
-Microsoft.Build.Tasks.Move.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.DestinationFiles.set -> void
-Microsoft.Build.Tasks.Move.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Move.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Move.Move() -> void
-Microsoft.Build.Tasks.Move.MovedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Move.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.SourceFiles.set -> void
-Microsoft.Build.Tasks.MSBuild
-Microsoft.Build.Tasks.MSBuild.BuildInParallel.get -> bool
-Microsoft.Build.Tasks.MSBuild.BuildInParallel.set -> void
-Microsoft.Build.Tasks.MSBuild.MSBuild() -> void
-Microsoft.Build.Tasks.MSBuild.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MSBuild.Projects.set -> void
-Microsoft.Build.Tasks.MSBuild.Properties.get -> string[]
-Microsoft.Build.Tasks.MSBuild.Properties.set -> void
-Microsoft.Build.Tasks.MSBuild.RebaseOutputs.get -> bool
-Microsoft.Build.Tasks.MSBuild.RebaseOutputs.set -> void
-Microsoft.Build.Tasks.MSBuild.RemoveProperties.get -> string
-Microsoft.Build.Tasks.MSBuild.RemoveProperties.set -> void
-Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.get -> bool
-Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.set -> void
-Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.get -> string
-Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.set -> void
-Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.get -> bool
-Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.set -> void
-Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.get -> string[]
-Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.set -> void
-Microsoft.Build.Tasks.MSBuild.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MSBuild.Targets.get -> string[]
-Microsoft.Build.Tasks.MSBuild.Targets.set -> void
-Microsoft.Build.Tasks.MSBuild.ToolsVersion.get -> string
-Microsoft.Build.Tasks.MSBuild.ToolsVersion.set -> void
-Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.get -> bool
-Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.set -> void
-Microsoft.Build.Tasks.MSBuild.UseResultsCache.get -> bool
-Microsoft.Build.Tasks.MSBuild.UseResultsCache.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile
-Microsoft.Build.Tasks.ReadLinesFromFile.File.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ReadLinesFromFile.File.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ReadLinesFromFile.Lines.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile.ReadLinesFromFile() -> void
-Microsoft.Build.Tasks.RegisterAssembly
-Microsoft.Build.Tasks.RegisterAssembly.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RegisterAssembly.Assemblies.set -> void
-Microsoft.Build.Tasks.RegisterAssembly.AssemblyListFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.RegisterAssembly.AssemblyListFile.set -> void
-Microsoft.Build.Tasks.RegisterAssembly.CreateCodeBase.get -> bool
-Microsoft.Build.Tasks.RegisterAssembly.CreateCodeBase.set -> void
-Microsoft.Build.Tasks.RegisterAssembly.RegisterAssembly() -> void
-Microsoft.Build.Tasks.RegisterAssembly.ReportEvent(System.Runtime.InteropServices.ExporterEventKind kind, int code, string msg) -> void
-Microsoft.Build.Tasks.RegisterAssembly.ResolveRef(System.Reflection.Assembly assemblyToResolve) -> object
-Microsoft.Build.Tasks.RegisterAssembly.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RegisterAssembly.TypeLibFiles.set -> void
-Microsoft.Build.Tasks.RemoveDir
-Microsoft.Build.Tasks.RemoveDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDir.Directories.set -> void
-Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.set -> void
-Microsoft.Build.Tasks.RemoveDir.RemoveDir() -> void
-Microsoft.Build.Tasks.RemoveDuplicates
-Microsoft.Build.Tasks.RemoveDuplicates.Filtered.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDuplicates.Filtered.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.get -> bool
-Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.Inputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDuplicates.Inputs.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.RemoveDuplicates() -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Assemblies.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.CreateDesktopShortcut.get -> bool
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.CreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.DeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.DeploymentManifestEntryPoint.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.EntryPoint.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Files.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ReferencedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.ReferencedAssemblies.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.RequiresFramework35SP1Assembly() -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.RequiresMinimumFramework35SP1.get -> bool
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.RequiresMinimumFramework35SP1.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SigningManifests.get -> bool
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SigningManifests.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SuiteName.get -> string
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.SuiteName.set -> void
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnNETStandard.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnSystemRuntime.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.RelatedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolveAssemblyReference() -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedDependencyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SatelliteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ScatterFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SerializationAssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolvedAssemblyConflicts.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.get -> string
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.get -> string
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolveCodeAnalysisRuleSet() -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolvedCodeAnalysisRuleSet.get -> string
-Microsoft.Build.Tasks.ResolveComReference
-Microsoft.Build.Tasks.ResolveComReference.DelaySign.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.DelaySign.set -> void
-Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.get -> string[]
-Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.set -> void
-Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.set -> void
-Microsoft.Build.Tasks.ResolveComReference.KeyContainer.get -> string
-Microsoft.Build.Tasks.ResolveComReference.KeyContainer.set -> void
-Microsoft.Build.Tasks.ResolveComReference.KeyFile.get -> string
-Microsoft.Build.Tasks.ResolveComReference.KeyFile.set -> void
-Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolveComReference() -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.set -> void
-Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.ResolveComReference.Silent.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.Silent.set -> void
-Microsoft.Build.Tasks.ResolveComReference.StateFile.get -> string
-Microsoft.Build.Tasks.ResolveComReference.StateFile.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.set -> void
-Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.get -> string
-Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.set -> void
-Microsoft.Build.Tasks.ResolveKeySource
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.get -> int
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.get -> int
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.KeyFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.KeyFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolveKeySource() -> void
-Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.get -> bool
-Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.get -> bool
-Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles
-Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.Files.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ResolveManifestFiles() -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference
-Microsoft.Build.Tasks.ResolveNativeReference.AdditionalSearchPaths.get -> string[]
-Microsoft.Build.Tasks.ResolveNativeReference.AdditionalSearchPaths.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedComComponents.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedComComponents.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseEtcFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseEtcFiles.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseTlbFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedLooseTlbFiles.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedPrerequisiteAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedPrerequisiteAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedTypeLibraries.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainedTypeLibraries.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ContainingReferenceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.ContainingReferenceFiles.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.NativeReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNativeReference.NativeReferences.set -> void
-Microsoft.Build.Tasks.ResolveNativeReference.ResolveNativeReference() -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.get -> string
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.set -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.set -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolveNonMSBuildProjectOutput() -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.set -> void
-Microsoft.Build.Tasks.ResolveProjectBase
-Microsoft.Build.Tasks.ResolveProjectBase.AddSyntheticProjectReferences(string currentProjectAbsolutePath) -> void
-Microsoft.Build.Tasks.ResolveProjectBase.GetProjectElement(Microsoft.Build.Framework.ITaskItem projectRef) -> System.Xml.XmlElement
-Microsoft.Build.Tasks.ResolveProjectBase.GetProjectItem(Microsoft.Build.Framework.ITaskItem projectRef) -> string
-Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.set -> void
-Microsoft.Build.Tasks.ResolveProjectBase.ResolveProjectBase() -> void
-Microsoft.Build.Tasks.ResolveSDKReference
-Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.References.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.ResolveSDKReference() -> void
-Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.set -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.RoslynCodeTaskFactory() -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.SGen
-Microsoft.Build.Tasks.SGen.BuildAssemblyName.get -> string
-Microsoft.Build.Tasks.SGen.BuildAssemblyName.set -> void
-Microsoft.Build.Tasks.SGen.BuildAssemblyPath.get -> string
-Microsoft.Build.Tasks.SGen.BuildAssemblyPath.set -> void
-Microsoft.Build.Tasks.SGen.DelaySign.get -> bool
-Microsoft.Build.Tasks.SGen.DelaySign.set -> void
-Microsoft.Build.Tasks.SGen.KeyContainer.get -> string
-Microsoft.Build.Tasks.SGen.KeyContainer.set -> void
-Microsoft.Build.Tasks.SGen.KeyFile.get -> string
-Microsoft.Build.Tasks.SGen.KeyFile.set -> void
-Microsoft.Build.Tasks.SGen.Platform.get -> string
-Microsoft.Build.Tasks.SGen.Platform.set -> void
-Microsoft.Build.Tasks.SGen.References.get -> string[]
-Microsoft.Build.Tasks.SGen.References.set -> void
-Microsoft.Build.Tasks.SGen.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.SGen.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.SGen.SerializationAssembly.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SGen.SerializationAssembly.set -> void
-Microsoft.Build.Tasks.SGen.SerializationAssemblyName.get -> string
-Microsoft.Build.Tasks.SGen.SGen() -> void
-Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.get -> bool
-Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.set -> void
-Microsoft.Build.Tasks.SGen.Types.get -> string[]
-Microsoft.Build.Tasks.SGen.Types.set -> void
-Microsoft.Build.Tasks.SGen.UseKeep.get -> bool
-Microsoft.Build.Tasks.SGen.UseKeep.set -> void
-Microsoft.Build.Tasks.SGen.UseProxyTypes.get -> bool
-Microsoft.Build.Tasks.SGen.UseProxyTypes.set -> void
-Microsoft.Build.Tasks.SignFile
-Microsoft.Build.Tasks.SignFile.CertificateThumbprint.get -> string
-Microsoft.Build.Tasks.SignFile.CertificateThumbprint.set -> void
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
-Microsoft.Build.Tasks.SignFile.SignFile() -> void
-Microsoft.Build.Tasks.SignFile.SigningTarget.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.SignFile.SigningTarget.set -> void
-Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.get -> string
-Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.set -> void
-Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.SignFile.TimestampUrl.get -> string
-Microsoft.Build.Tasks.SignFile.TimestampUrl.set -> void
-Microsoft.Build.Tasks.TaskExtension
-Microsoft.Build.Tasks.TaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Tasks.TaskLoggingHelperExtension
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskLoggingHelperExtension(Microsoft.Build.Framework.ITask taskInstance, System.Resources.ResourceManager primaryResources, System.Resources.ResourceManager sharedResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.set -> void
-Microsoft.Build.Tasks.Telemetry
-Microsoft.Build.Tasks.Telemetry.EventData.get -> string
-Microsoft.Build.Tasks.Telemetry.EventData.set -> void
-Microsoft.Build.Tasks.Telemetry.EventName.get -> string
-Microsoft.Build.Tasks.Telemetry.EventName.set -> void
-Microsoft.Build.Tasks.Telemetry.Telemetry() -> void
-Microsoft.Build.Tasks.ToolTaskExtension
-Microsoft.Build.Tasks.ToolTaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Tasks.Touch
-Microsoft.Build.Tasks.Touch.AlwaysCreate.get -> bool
-Microsoft.Build.Tasks.Touch.AlwaysCreate.set -> void
-Microsoft.Build.Tasks.Touch.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Touch.Files.set -> void
-Microsoft.Build.Tasks.Touch.ForceTouch.get -> bool
-Microsoft.Build.Tasks.Touch.ForceTouch.set -> void
-Microsoft.Build.Tasks.Touch.Time.get -> string
-Microsoft.Build.Tasks.Touch.Time.set -> void
-Microsoft.Build.Tasks.Touch.Touch() -> void
-Microsoft.Build.Tasks.Touch.TouchedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Touch.TouchedFiles.set -> void
-Microsoft.Build.Tasks.UnregisterAssembly
-Microsoft.Build.Tasks.UnregisterAssembly.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.UnregisterAssembly.Assemblies.set -> void
-Microsoft.Build.Tasks.UnregisterAssembly.AssemblyListFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.UnregisterAssembly.AssemblyListFile.set -> void
-Microsoft.Build.Tasks.UnregisterAssembly.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.UnregisterAssembly.TypeLibFiles.set -> void
-Microsoft.Build.Tasks.UnregisterAssembly.UnregisterAssembly() -> void
-Microsoft.Build.Tasks.Unzip
-Microsoft.Build.Tasks.Unzip.Cancel() -> void
-Microsoft.Build.Tasks.Unzip.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Unzip.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Unzip.Exclude.get -> string
-Microsoft.Build.Tasks.Unzip.Exclude.set -> void
-Microsoft.Build.Tasks.Unzip.Include.get -> string
-Microsoft.Build.Tasks.Unzip.Include.set -> void
-Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.Unzip.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Unzip.SourceFiles.set -> void
-Microsoft.Build.Tasks.Unzip.Unzip() -> void
-Microsoft.Build.Tasks.UpdateManifest
-Microsoft.Build.Tasks.UpdateManifest.ApplicationManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.UpdateManifest.ApplicationManifest.set -> void
-Microsoft.Build.Tasks.UpdateManifest.ApplicationPath.get -> string
-Microsoft.Build.Tasks.UpdateManifest.ApplicationPath.set -> void
-Microsoft.Build.Tasks.UpdateManifest.InputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.UpdateManifest.InputManifest.set -> void
-Microsoft.Build.Tasks.UpdateManifest.OutputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.UpdateManifest.OutputManifest.set -> void
-Microsoft.Build.Tasks.UpdateManifest.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.UpdateManifest.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.UpdateManifest.UpdateManifest() -> void
-Microsoft.Build.Tasks.VerifyFileHash
-Microsoft.Build.Tasks.VerifyFileHash.Algorithm.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.Algorithm.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.File.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.File.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.Hash.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.Hash.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.VerifyFileHash() -> void
-Microsoft.Build.Tasks.Warning
-Microsoft.Build.Tasks.Warning.Code.get -> string
-Microsoft.Build.Tasks.Warning.Code.set -> void
-Microsoft.Build.Tasks.Warning.File.get -> string
-Microsoft.Build.Tasks.Warning.File.set -> void
-Microsoft.Build.Tasks.Warning.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Warning.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Warning.HelpLink.get -> string
-Microsoft.Build.Tasks.Warning.HelpLink.set -> void
-Microsoft.Build.Tasks.Warning.Text.get -> string
-Microsoft.Build.Tasks.Warning.Text.set -> void
-Microsoft.Build.Tasks.Warning.Warning() -> void
-Microsoft.Build.Tasks.WinMDExp
-Microsoft.Build.Tasks.WinMDExp.AssemblyUnificationPolicy.get -> string
-Microsoft.Build.Tasks.WinMDExp.AssemblyUnificationPolicy.set -> void
-Microsoft.Build.Tasks.WinMDExp.DisabledWarnings.get -> string
-Microsoft.Build.Tasks.WinMDExp.DisabledWarnings.set -> void
-Microsoft.Build.Tasks.WinMDExp.InputDocumentationFile.get -> string
-Microsoft.Build.Tasks.WinMDExp.InputDocumentationFile.set -> void
-Microsoft.Build.Tasks.WinMDExp.InputPDBFile.get -> string
-Microsoft.Build.Tasks.WinMDExp.InputPDBFile.set -> void
-Microsoft.Build.Tasks.WinMDExp.OutputDocumentationFile.get -> string
-Microsoft.Build.Tasks.WinMDExp.OutputDocumentationFile.set -> void
-Microsoft.Build.Tasks.WinMDExp.OutputPDBFile.get -> string
-Microsoft.Build.Tasks.WinMDExp.OutputPDBFile.set -> void
-Microsoft.Build.Tasks.WinMDExp.OutputWindowsMetadataFile.get -> string
-Microsoft.Build.Tasks.WinMDExp.OutputWindowsMetadataFile.set -> void
-Microsoft.Build.Tasks.WinMDExp.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.WinMDExp.References.set -> void
-Microsoft.Build.Tasks.WinMDExp.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.WinMDExp.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.WinMDExp.TreatWarningsAsErrors.get -> bool
-Microsoft.Build.Tasks.WinMDExp.TreatWarningsAsErrors.set -> void
-Microsoft.Build.Tasks.WinMDExp.UTF8Output.get -> bool
-Microsoft.Build.Tasks.WinMDExp.UTF8Output.set -> void
-Microsoft.Build.Tasks.WinMDExp.WinMDExp() -> void
-Microsoft.Build.Tasks.WinMDExp.WinMDModule.get -> string
-Microsoft.Build.Tasks.WinMDExp.WinMDModule.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment
-Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.Language.get -> string
-Microsoft.Build.Tasks.WriteCodeFragment.Language.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.WriteCodeFragment() -> void
-Microsoft.Build.Tasks.WriteLinesToFile
-Microsoft.Build.Tasks.WriteLinesToFile.Encoding.get -> string
-Microsoft.Build.Tasks.WriteLinesToFile.Encoding.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.File.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteLinesToFile.File.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.WriteLinesToFile.Lines.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.get -> bool
-Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.WriteLinesToFile() -> void
-Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.get -> bool
-Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation
-Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation.CommandLineArgumentRelation(string argument, string value, bool required, string separator) -> void
-Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation.Separator.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation.Separator.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AdditionalOptions.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AdditionalOptions.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AlwaysAppend.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.AlwaysAppend.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.CommandLineGenerator(Microsoft.Build.Framework.XamlTypes.Rule rule, System.Collections.Generic.Dictionary<string, object> parameterValues) -> void
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.CommandLineTemplate.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.CommandLineTemplate.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineGenerator.GenerateCommandLine() -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.AllowMultipleValues.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.AllowMultipleValues.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ArgumentRequired.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ArgumentRequired.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Arguments.get -> System.Collections.Generic.ICollection<System.Tuple<string, bool>>
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Arguments.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.BooleanValue.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.BooleanValue.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.CommandLineToolSwitch() -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.CommandLineToolSwitch(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType toolType) -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Description.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Description.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.DisplayName.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.DisplayName.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FallbackArgumentParameter.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FallbackArgumentParameter.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FalseSuffix.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.FalseSuffix.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IncludeInCommandLine.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IncludeInCommandLine.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IsValid.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.IsValid.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Name.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Name.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Number.get -> int
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Number.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Overrides.get -> System.Collections.Generic.LinkedList<System.Collections.Generic.KeyValuePair<string, string>>
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Parents.get -> System.Collections.Generic.LinkedList<string>
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Required.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Required.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ReverseSwitchValue.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.ReverseSwitchValue.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Reversible.get -> bool
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Reversible.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Separator.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Separator.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.StringList.get -> string[]
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.StringList.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.SwitchValue.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.SwitchValue.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TaskItemArray.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TaskItemArray.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TrueSuffix.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.TrueSuffix.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Type.get -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Type.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Value.get -> string
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch.Value.set -> void
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.Boolean = 0 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.Integer = 1 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.ITaskItemArray = 4 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.String = 2 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType.StringArray = 3 -> Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType
-Microsoft.Build.Tasks.Xaml.PropertyRelation
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Argument.get -> string
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Argument.set -> void
-Microsoft.Build.Tasks.Xaml.PropertyRelation.PropertyRelation() -> void
-Microsoft.Build.Tasks.Xaml.PropertyRelation.PropertyRelation(string argument, string value, bool required) -> void
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Required.get -> bool
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Required.set -> void
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Value.get -> string
-Microsoft.Build.Tasks.Xaml.PropertyRelation.Value.set -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ActiveToolSwitches.get -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch>
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ActiveToolSwitchesValues.get -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch>
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ActiveToolSwitchesValues.set -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AddActiveSwitchToolValue(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch switchToAdd) -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AdditionalOptions.get -> string
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AdditionalOptions.set -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CommandLineTemplate.get -> string
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CommandLineTemplate.set -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.CreateSwitchValue(string propertyName, string baseSwitch, string separator, System.Tuple<string, bool>[] arguments) -> string
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.IsPropertySet(string propertyName) -> bool
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReadSwitchMap(string propertyName, string[][] switchMap, string value) -> string
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReadSwitchMap2(string propertyName, System.Tuple<string, string, System.Tuple<string, bool>[]>[] switchMap, string value) -> int
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ReplaceToolSwitch(Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch switchToAdd) -> void
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ValidateInteger(string switchName, int min, int max, int value) -> bool
-Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.XamlDataDrivenToolTask(string[] switchOrderList, System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Tasks.XamlTaskFactory
-Microsoft.Build.Tasks.XamlTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.XamlTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.XamlTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.XamlTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.XamlTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> taskParameters, string taskElementContents, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.XamlTaskFactory.TaskElementContents.get -> string
-Microsoft.Build.Tasks.XamlTaskFactory.TaskName.get -> string
-Microsoft.Build.Tasks.XamlTaskFactory.TaskNamespace.get -> string
-Microsoft.Build.Tasks.XamlTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.XamlTaskFactory.XamlTaskFactory() -> void
-Microsoft.Build.Tasks.XmlPeek
-Microsoft.Build.Tasks.XmlPeek.Namespaces.get -> string
-Microsoft.Build.Tasks.XmlPeek.Namespaces.set -> void
-Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.get -> bool
-Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.set -> void
-Microsoft.Build.Tasks.XmlPeek.Query.get -> string
-Microsoft.Build.Tasks.XmlPeek.Query.set -> void
-Microsoft.Build.Tasks.XmlPeek.Result.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XmlPeek.XmlContent.get -> string
-Microsoft.Build.Tasks.XmlPeek.XmlContent.set -> void
-Microsoft.Build.Tasks.XmlPeek.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPeek.XmlInputPath.set -> void
-Microsoft.Build.Tasks.XmlPeek.XmlPeek() -> void
-Microsoft.Build.Tasks.XmlPoke
-Microsoft.Build.Tasks.XmlPoke.Namespaces.get -> string
-Microsoft.Build.Tasks.XmlPoke.Namespaces.set -> void
-Microsoft.Build.Tasks.XmlPoke.Query.get -> string
-Microsoft.Build.Tasks.XmlPoke.Query.set -> void
-Microsoft.Build.Tasks.XmlPoke.Value.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPoke.Value.set -> void
-Microsoft.Build.Tasks.XmlPoke.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPoke.XmlInputPath.set -> void
-Microsoft.Build.Tasks.XmlPoke.XmlPoke() -> void
-Microsoft.Build.Tasks.XslTransformation
-Microsoft.Build.Tasks.XslTransformation.OutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XslTransformation.OutputPaths.set -> void
-Microsoft.Build.Tasks.XslTransformation.Parameters.get -> string
-Microsoft.Build.Tasks.XslTransformation.Parameters.set -> void
-Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.get -> bool
-Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.set -> void
-Microsoft.Build.Tasks.XslTransformation.XmlContent.get -> string
-Microsoft.Build.Tasks.XslTransformation.XmlContent.set -> void
-Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslContent.get -> string
-Microsoft.Build.Tasks.XslTransformation.XslContent.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XslTransformation.XslInputPath.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslTransformation() -> void
-Microsoft.Build.Tasks.ZipDirectory
-Microsoft.Build.Tasks.ZipDirectory.DestinationFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ZipDirectory.DestinationFile.set -> void
-Microsoft.Build.Tasks.ZipDirectory.Overwrite.get -> bool
-Microsoft.Build.Tasks.ZipDirectory.Overwrite.set -> void
-Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.set -> void
-Microsoft.Build.Tasks.ZipDirectory.ZipDirectory() -> void
-override Microsoft.Build.Tasks.AL.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.AL.Execute() -> bool
-override Microsoft.Build.Tasks.AL.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.AL.ToolName.get -> string
-override Microsoft.Build.Tasks.AspNetCompiler.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.AspNetCompiler.Execute() -> bool
-override Microsoft.Build.Tasks.AspNetCompiler.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.AspNetCompiler.ToolName.get -> string
-override Microsoft.Build.Tasks.AspNetCompiler.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.AssignCulture.Execute() -> bool
-override Microsoft.Build.Tasks.AssignLinkMetadata.Execute() -> bool
-override Microsoft.Build.Tasks.AssignProjectConfiguration.Execute() -> bool
-override Microsoft.Build.Tasks.AssignTargetPath.Execute() -> bool
-override Microsoft.Build.Tasks.CallTarget.Execute() -> bool
-override Microsoft.Build.Tasks.CombinePath.Execute() -> bool
-override Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Execute() -> bool
-override Microsoft.Build.Tasks.CombineXmlElements.Execute() -> bool
-override Microsoft.Build.Tasks.ConvertToAbsolutePath.Execute() -> bool
-override Microsoft.Build.Tasks.Copy.Execute() -> bool
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.IsSourceFile(string fileName) -> bool
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.SourceFileExtension.get -> string
-override Microsoft.Build.Tasks.CreateItem.Execute() -> bool
-override Microsoft.Build.Tasks.CreateManifestResourceName.Execute() -> bool
-override Microsoft.Build.Tasks.CreateProperty.Execute() -> bool
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.IsSourceFile(string fileName) -> bool
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.SourceFileExtension.get -> string
-override Microsoft.Build.Tasks.Delete.Execute() -> bool
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.set -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Validate() -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.set -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Validate() -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ToString() -> string
-override Microsoft.Build.Tasks.DownloadFile.Execute() -> bool
-override Microsoft.Build.Tasks.Error.Execute() -> bool
-override Microsoft.Build.Tasks.ErrorFromResources.Execute() -> bool
-override Microsoft.Build.Tasks.Exec.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.Exec.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
-override Microsoft.Build.Tasks.Exec.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.Exec.GetWorkingDirectory() -> string
-override Microsoft.Build.Tasks.Exec.HandleTaskExecutionErrors() -> bool
-override Microsoft.Build.Tasks.Exec.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
-override Microsoft.Build.Tasks.Exec.LogPathToTool(string toolName, string pathToTool) -> void
-override Microsoft.Build.Tasks.Exec.LogToolCommand(string message) -> void
-override Microsoft.Build.Tasks.Exec.StandardErrorEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.Exec.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-override Microsoft.Build.Tasks.Exec.StandardOutputEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.Exec.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-override Microsoft.Build.Tasks.Exec.ToolName.get -> string
-override Microsoft.Build.Tasks.Exec.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.FindAppConfigFile.Execute() -> bool
-override Microsoft.Build.Tasks.FindInList.Execute() -> bool
-override Microsoft.Build.Tasks.FindInvalidProjectReferences.Execute() -> bool
-override Microsoft.Build.Tasks.FindUnderPath.Execute() -> bool
-override Microsoft.Build.Tasks.FormatUrl.Execute() -> bool
-override Microsoft.Build.Tasks.FormatVersion.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateBindingRedirects.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateBootstrapper.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateLauncher.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateManifestBase.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateResource.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateTrustInfo.Execute() -> bool
-override Microsoft.Build.Tasks.GetAssemblyIdentity.Execute() -> bool
-override Microsoft.Build.Tasks.GetCompatiblePlatform.Execute() -> bool
-override Microsoft.Build.Tasks.GetFileHash.Execute() -> bool
-override Microsoft.Build.Tasks.GetFrameworkPath.Execute() -> bool
-override Microsoft.Build.Tasks.GetFrameworkSdkPath.Execute() -> bool
-override Microsoft.Build.Tasks.GetInstalledSDKLocations.Execute() -> bool
-override Microsoft.Build.Tasks.GetReferenceAssemblyPaths.Execute() -> bool
-override Microsoft.Build.Tasks.GetSDKReferenceFiles.Execute() -> bool
-override Microsoft.Build.Tasks.Hash.Execute() -> bool
-override Microsoft.Build.Tasks.LC.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.LC.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.LC.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.LC.ToolName.get -> string
-override Microsoft.Build.Tasks.LC.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.MakeDir.Execute() -> bool
-override Microsoft.Build.Tasks.Message.Execute() -> bool
-override Microsoft.Build.Tasks.Move.Execute() -> bool
-override Microsoft.Build.Tasks.MSBuild.Execute() -> bool
-override Microsoft.Build.Tasks.ReadLinesFromFile.Execute() -> bool
-override Microsoft.Build.Tasks.RegisterAssembly.Execute() -> bool
-override Microsoft.Build.Tasks.RemoveDir.Execute() -> bool
-override Microsoft.Build.Tasks.RemoveDuplicates.Execute() -> bool
-override Microsoft.Build.Tasks.RequiresFramework35SP1Assembly.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveAssemblyReference.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveComReference.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveKeySource.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveManifestFiles.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveNativeReference.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveSDKReference.Execute() -> bool
-override Microsoft.Build.Tasks.SGen.GenerateCommandLineCommands() -> string
-override Microsoft.Build.Tasks.SGen.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.SGen.SkipTaskExecution() -> bool
-override Microsoft.Build.Tasks.SGen.ToolName.get -> string
-override Microsoft.Build.Tasks.SGen.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.SignFile.Execute() -> bool
-override Microsoft.Build.Tasks.TaskLoggingHelperExtension.FormatResourceString(string resourceName, params object[] args) -> string
-override Microsoft.Build.Tasks.Telemetry.Execute() -> bool
-override Microsoft.Build.Tasks.Touch.Execute() -> bool
-override Microsoft.Build.Tasks.UnregisterAssembly.Execute() -> bool
-override Microsoft.Build.Tasks.Unzip.Execute() -> bool
-override Microsoft.Build.Tasks.UpdateManifest.Execute() -> bool
-override Microsoft.Build.Tasks.VerifyFileHash.Execute() -> bool
-override Microsoft.Build.Tasks.Warning.Execute() -> bool
-override Microsoft.Build.Tasks.WinMDExp.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.WinMDExp.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.WinMDExp.SkipTaskExecution() -> bool
-override Microsoft.Build.Tasks.WinMDExp.StandardErrorEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.WinMDExp.StandardOutputEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.WinMDExp.ToolName.get -> string
-override Microsoft.Build.Tasks.WinMDExp.UseNewLineSeparatorInResponseFile.get -> bool
-override Microsoft.Build.Tasks.WinMDExp.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.WriteCodeFragment.Execute() -> bool
-override Microsoft.Build.Tasks.WriteLinesToFile.Execute() -> bool
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.Execute() -> bool
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateCommandLineCommands() -> string
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.GenerateResponseFileCommands() -> string
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.HandleTaskExecutionErrors() -> bool
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ResponseFileEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.XmlPeek.Execute() -> bool
-override Microsoft.Build.Tasks.XmlPoke.Execute() -> bool
-override Microsoft.Build.Tasks.XslTransformation.Execute() -> bool
-override Microsoft.Build.Tasks.ZipDirectory.Execute() -> bool
-override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureDeformatter
-override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureFormatter
-static Microsoft.Build.Tasks.CreateManifestResourceName.MakeValidEverettIdentifier(string name) -> string
-static Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.XmlToConfigurationFile(System.Xml.XmlNode input) -> string
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromAssemblyName(string assemblyName) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromFile(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManagedAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManifest(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromNativeAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path, string targetframeWorkVersion) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, System.IO.Stream output) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.ComputeZonePermissionSet(string targetZone, System.Security.PermissionSet includedPermissionSet, string[] excludedPermissions) -> System.Security.PermissionSet
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.IdentityListToPermissionSet(string[] ids) -> System.Security.PermissionSet
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.PermissionSetToIdentityList(System.Security.PermissionSet permissionSet) -> string[]
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.XmlToPermissionSet(System.Xml.XmlElement element) -> System.Security.PermissionSet
-System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription
-System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.RSAPKCS1SHA256SignatureDescription() -> void
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.set -> void
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Validate() -> void
-virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateInputs() -> bool
-virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateOutput() -> bool
-virtual Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AcceptableNonZeroExitCodes.get -> string[]
-virtual Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask.AcceptableNonZeroExitCodes.set -> void
\ No newline at end of file
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e2378ba70a3..00000000000
--- a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.set -> void
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.SetRidAgnosticValueForProjects() -> void
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.set -> void
-override Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Execute() -> bool
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.get -> bool
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
deleted file mode 100644
index 942972d067e..00000000000
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,2032 +0,0 @@
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.IsSourceFile(string fileName) -> bool
-abstract Microsoft.Build.Tasks.CreateManifestResourceName.SourceFileExtension.get -> string
-abstract Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SortName.get -> string
-abstract Microsoft.Build.Tasks.GenerateManifestBase.GetObjectType() -> System.Type
-abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestLoaded(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
-abstract Microsoft.Build.Tasks.GenerateManifestBase.OnManifestResolved(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> bool
-Microsoft.Build.Tasks.AssignCulture
-Microsoft.Build.Tasks.AssignCulture.AssignCulture() -> void
-Microsoft.Build.Tasks.AssignCulture.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithCulture.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.AssignedFilesWithNoCulture.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.CultureNeutralAssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignCulture.Files.set -> void
-Microsoft.Build.Tasks.AssignLinkMetadata
-Microsoft.Build.Tasks.AssignLinkMetadata.AssignLinkMetadata() -> void
-Microsoft.Build.Tasks.AssignLinkMetadata.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignLinkMetadata.Items.set -> void
-Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignLinkMetadata.OutputItems.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration
-Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.AddSyntheticProjectReferencesForSolutionDependencies.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignedProjects.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.AssignProjectConfiguration() -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProject.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectConfiguration.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.CurrentProjectPlatform.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.DefaultToVcxPlatformMapping.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.OutputType.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.ResolveConfigurationPlatformUsingMappings.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.get -> bool
-Microsoft.Build.Tasks.AssignProjectConfiguration.ShouldUnsetParentConfigurationAndPlatform.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.SolutionConfigurationContents.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignProjectConfiguration.UnassignedProjects.set -> void
-Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.get -> string
-Microsoft.Build.Tasks.AssignProjectConfiguration.VcxToDefaultPlatformMapping.set -> void
-Microsoft.Build.Tasks.AssignTargetPath
-Microsoft.Build.Tasks.AssignTargetPath.AssignedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignTargetPath.AssignTargetPath() -> void
-Microsoft.Build.Tasks.AssignTargetPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.AssignTargetPath.Files.set -> void
-Microsoft.Build.Tasks.AssignTargetPath.RootFolder.get -> string
-Microsoft.Build.Tasks.AssignTargetPath.RootFolder.set -> void
-Microsoft.Build.Tasks.CallTarget
-Microsoft.Build.Tasks.CallTarget.CallTarget() -> void
-Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.get -> bool
-Microsoft.Build.Tasks.CallTarget.RunEachTargetSeparately.set -> void
-Microsoft.Build.Tasks.CallTarget.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CallTarget.Targets.get -> string[]
-Microsoft.Build.Tasks.CallTarget.Targets.set -> void
-Microsoft.Build.Tasks.CallTarget.UseResultsCache.get -> bool
-Microsoft.Build.Tasks.CallTarget.UseResultsCache.set -> void
-Microsoft.Build.Tasks.CodeTaskFactory
-Microsoft.Build.Tasks.CodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.CodeTaskFactory.CodeTaskFactory() -> void
-Microsoft.Build.Tasks.CodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.CodeTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.CodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.CodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.CodeTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.CombinePath
-Microsoft.Build.Tasks.CombinePath.BasePath.get -> string
-Microsoft.Build.Tasks.CombinePath.BasePath.set -> void
-Microsoft.Build.Tasks.CombinePath.CombinedPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombinePath.CombinedPaths.set -> void
-Microsoft.Build.Tasks.CombinePath.CombinePath() -> void
-Microsoft.Build.Tasks.CombinePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombinePath.Paths.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.CombineTargetFrameworkInfoProperties() -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.PropertiesAndValues.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.get -> string
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Result.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.get -> string
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.RootElementName.set -> void
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.get -> bool
-Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.UseAttributeForTargetFrameworkInfoPropertyNames.set -> void
-Microsoft.Build.Tasks.CombineXmlElements
-Microsoft.Build.Tasks.CombineXmlElements.CombineXmlElements() -> void
-Microsoft.Build.Tasks.CombineXmlElements.Result.get -> string
-Microsoft.Build.Tasks.CombineXmlElements.Result.set -> void
-Microsoft.Build.Tasks.CombineXmlElements.RootElementName.get -> string
-Microsoft.Build.Tasks.CombineXmlElements.RootElementName.set -> void
-Microsoft.Build.Tasks.CombineXmlElements.XmlElements.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CombineXmlElements.XmlElements.set -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension
-Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension() -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension.CommandLineBuilderExtension(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
-Microsoft.Build.Tasks.CommandLineBuilderExtension.GetQuotedText(string unquotedText) -> string
-Microsoft.Build.Tasks.ConvertToAbsolutePath
-Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ConvertToAbsolutePath.AbsolutePaths.set -> void
-Microsoft.Build.Tasks.ConvertToAbsolutePath.ConvertToAbsolutePath() -> void
-Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ConvertToAbsolutePath.Paths.set -> void
-Microsoft.Build.Tasks.Copy
-Microsoft.Build.Tasks.Copy.Cancel() -> void
-Microsoft.Build.Tasks.Copy.CopiedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.Copy() -> void
-Microsoft.Build.Tasks.Copy.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.DestinationFiles.set -> void
-Microsoft.Build.Tasks.Copy.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Copy.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.get -> bool
-Microsoft.Build.Tasks.Copy.ErrorIfLinkFails.set -> void
-Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Copy.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Copy.Retries.get -> int
-Microsoft.Build.Tasks.Copy.Retries.set -> void
-Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.get -> int
-Microsoft.Build.Tasks.Copy.RetryDelayMilliseconds.set -> void
-Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.Copy.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.Copy.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Copy.SourceFiles.set -> void
-Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.get -> bool
-Microsoft.Build.Tasks.Copy.UseHardlinksIfPossible.set -> void
-Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.get -> bool
-Microsoft.Build.Tasks.Copy.UseSymboliclinksIfPossible.set -> void
-Microsoft.Build.Tasks.Copy.WroteAtLeastOneFile.get -> bool
-Microsoft.Build.Tasks.CreateCSharpManifestResourceName
-Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateCSharpManifestResourceName() -> void
-Microsoft.Build.Tasks.CreateItem
-Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.get -> string[]
-Microsoft.Build.Tasks.CreateItem.AdditionalMetadata.set -> void
-Microsoft.Build.Tasks.CreateItem.CreateItem() -> void
-Microsoft.Build.Tasks.CreateItem.Exclude.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateItem.Exclude.set -> void
-Microsoft.Build.Tasks.CreateItem.Include.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateItem.Include.set -> void
-Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.get -> bool
-Microsoft.Build.Tasks.CreateItem.PreserveExistingMetadata.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName
-Microsoft.Build.Tasks.CreateManifestResourceName.CreateManifestResourceName() -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.itemSpecToTaskitem -> System.Collections.Generic.Dictionary<string, Microsoft.Build.Framework.ITaskItem>
-Microsoft.Build.Tasks.CreateManifestResourceName.ManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.get -> bool
-Microsoft.Build.Tasks.CreateManifestResourceName.PrependCultureAsDirectory.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFiles.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.CreateManifestResourceName.ResourceFilesWithManifestResourceNames.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.get -> string
-Microsoft.Build.Tasks.CreateManifestResourceName.RootNamespace.set -> void
-Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.get -> bool
-Microsoft.Build.Tasks.CreateManifestResourceName.UseDependentUponConvention.set -> void
-Microsoft.Build.Tasks.CreateProperty
-Microsoft.Build.Tasks.CreateProperty.CreateProperty() -> void
-Microsoft.Build.Tasks.CreateProperty.Value.get -> string[]
-Microsoft.Build.Tasks.CreateProperty.Value.set -> void
-Microsoft.Build.Tasks.CreateProperty.ValueSetByTask.get -> string[]
-Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName
-Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateVisualBasicManifestResourceName() -> void
-Microsoft.Build.Tasks.Delete
-Microsoft.Build.Tasks.Delete.Cancel() -> void
-Microsoft.Build.Tasks.Delete.Delete() -> void
-Microsoft.Build.Tasks.Delete.DeletedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Delete.DeletedFiles.set -> void
-Microsoft.Build.Tasks.Delete.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Delete.Files.set -> void
-Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.get -> bool
-Microsoft.Build.Tasks.Delete.TreatErrorsAsWarnings.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.BootstrapperBuilder(string visualStudioVersion) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.GetOutputFolders(string[] productCodes, string culture, string fallbackCulture, Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation componentsLocation) -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Path.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpId.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Message.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Error = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Info = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity.Warning = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.ComponentFiles.get -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.KeyFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults.Succeeded.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationFile.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationName.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationRequiresElevation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ApplicationUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.BuildSettings() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsLocation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ComponentsUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.CopyComponents.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.FallbackLCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.LCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.OutputPath.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings.Validate.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Absolute = 2 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.HomeSite = 0 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation.Relative = 1 -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Build(Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings settings) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Path.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder.Products.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpId.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Message.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage.Severity.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.ComponentFiles.get -> string[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.KeyFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Messages.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage[]
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults.Succeeded.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationFile.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationName.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationRequiresElevation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ApplicationUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsLocation.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ComponentsUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.CopyComponents.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.FallbackLCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.LCID.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.OutputPath.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.ProductBuilders.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.get -> bool
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings.Validate.set -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.Name.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct.ProductCode.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Includes.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Name.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.Product() -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductBuilder.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.Product.ProductCode.get -> string
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder.Product.get -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.Add(Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder builder) -> void
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Item(int index) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection.Product(string productCode) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.Product
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity deployManifestIdentity, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity applicationManifestIdentity) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ApplicationManifest(string targetFrameworkVersion) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ConfigFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.FileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.HostInBrowser.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IconFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.IsClickOnceManifest.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.MaxTargetPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.OSVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Product.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Publisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.TrustInfo.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.UseApplicationTrust.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlConfigFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlEntryPointPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlFileAssociations.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlHostInBrowser.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIconFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlIsClickOnceManifest.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSBuild.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMajor.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSMinor.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSRevision.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlOSSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlProduct.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlPublisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.XmlUseApplicationTrust.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Culture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.All = Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture | Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Default = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.ProcessorArchitecture = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags.Type = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.GetFullName(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FullNameFlags flags) -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsFrameworkAssembly.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsInFramework(string frameworkIdentifier, string frameworkVersion) -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsNeutralPlatform.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.IsStrongName.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Name.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.PublicKeyToken.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Type.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.Version.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlCulture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlPublicKeyToken.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.AssemblyManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.ExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest.XmlExternalProxyStubs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.AssemblyReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.IsPrerequisite.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ReferenceType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlAssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsNative.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.XmlIsPrerequisite.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assembly) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity identity) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Find(string name) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference assemblyReference) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ClickOnceManifest = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.ManagedAssembly = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.NativeAssembly = 3 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType.Unspecified = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.BaseReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Group.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Hash.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.IsOptional.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ResolvedPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.get -> long
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.Size.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.SourcePath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.TargetPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlGroup.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHash.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlHashAlgorithm.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlIsOptional.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.XmlSize.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ClsId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ComClass() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.ThreadingModel.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlClsId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlThreadingModel.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.CompatibleFramework() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Profile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.SupportedRuntime.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.Version.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlProfile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlSupportedRuntime.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework compatibleFramework) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.CreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeployManifest(string targetFrameworkMoniker) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DeploymentUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.DisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Install.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MapFileExtensions.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.MinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Product.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Publisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.TrustUrlParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateEnabled.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateInterval.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateMode.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.UpdateUnit.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCompatibleFrameworks.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlCreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDeploymentUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlDisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlErrorReportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlInstall.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMapFileExtensions.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlMinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlProduct.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlPublisher.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSuiteName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlSupportUrl.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlTrustUrlParameters.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateEnabled.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateInterval.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateMode.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.XmlUpdateUnit.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.DefaultIcon.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Description.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.Extension.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.FileAssociation() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.ProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDefaultIcon.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlExtension.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation.XmlProgId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation fileAssociation) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.FileReference(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.IsDataFile.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.ProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.TypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlComClasses.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlProxyStubs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlTypeLibs.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference.XmlWriteableType.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Add(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Count.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.FindTargetPath(string targetPath) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.Remove(Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference file) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.Build(string filename, string outputPath) -> Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherBuilder(string launcherPath) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder.LauncherPath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.AssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Description.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.FileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.get -> System.IO.Stream
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.InputStream.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Manifest() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.OutputMessages.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ReadOnly.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ResolveFiles(string[] searchPaths) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.SourcePath.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.UpdateFileInfo(string targetFrameworkVersion) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ValidatePlatform() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyIdentity.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlAssemblyReferences.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlDescription.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlFileReferences.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.XmlSchema.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.GetArguments() -> string[]
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Text.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage.Type.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.ErrorCount.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.GetEnumerator() -> System.Collections.IEnumerator
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.this[int index].get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection.WarningCount.get -> int
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Error = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Info = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType.Warning = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.BaseInterface.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.IID.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.NumMethods.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.ProxyStub() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlBaseInterface.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlIID.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlNumMethods.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Clear() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.HasUnmanagedCodePermission.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.IsFullTrust.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.PreserveFullTrustPermissionSet.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Read(System.IO.Stream input) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ReadManifest(System.IO.Stream input) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.SameSiteAccess.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.TrustInfo() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.Write(System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(string path) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream input, System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.WriteManifest(System.IO.Stream output) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Flags.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.HelpDirectory.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.ResourceId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.TypeLib() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.Version.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlFlags.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlHelpDirectory.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlResourceId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlTlbId.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib.XmlVersion.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Background = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode.Foreground = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Days = 1 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Hours = 0 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit.Weeks = 2 -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Name.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.Versioned.get -> bool
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass() -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.WindowClass(string name, bool versioned) -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlName.set -> void
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.get -> string
-Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass.XmlVersioned.set -> void
-Microsoft.Build.Tasks.DownloadFile
-Microsoft.Build.Tasks.DownloadFile.Cancel() -> void
-Microsoft.Build.Tasks.DownloadFile.DestinationFileName.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DestinationFileName.set -> void
-Microsoft.Build.Tasks.DownloadFile.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DestinationFolder.set -> void
-Microsoft.Build.Tasks.DownloadFile.DownloadedFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.DownloadFile.DownloadedFile.set -> void
-Microsoft.Build.Tasks.DownloadFile.DownloadFile() -> void
-Microsoft.Build.Tasks.DownloadFile.Retries.get -> int
-Microsoft.Build.Tasks.DownloadFile.Retries.set -> void
-Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.get -> int
-Microsoft.Build.Tasks.DownloadFile.RetryDelayMilliseconds.set -> void
-Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.DownloadFile.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.DownloadFile.SourceUrl.get -> string
-Microsoft.Build.Tasks.DownloadFile.SourceUrl.set -> void
-Microsoft.Build.Tasks.DownloadFile.Timeout.get -> int
-Microsoft.Build.Tasks.DownloadFile.Timeout.set -> void
-Microsoft.Build.Tasks.Error
-Microsoft.Build.Tasks.Error.Code.get -> string
-Microsoft.Build.Tasks.Error.Code.set -> void
-Microsoft.Build.Tasks.Error.Error() -> void
-Microsoft.Build.Tasks.Error.File.get -> string
-Microsoft.Build.Tasks.Error.File.set -> void
-Microsoft.Build.Tasks.Error.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Error.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Error.HelpLink.get -> string
-Microsoft.Build.Tasks.Error.HelpLink.set -> void
-Microsoft.Build.Tasks.Error.Text.get -> string
-Microsoft.Build.Tasks.Error.Text.set -> void
-Microsoft.Build.Tasks.ErrorFromResources
-Microsoft.Build.Tasks.ErrorFromResources.Arguments.get -> string[]
-Microsoft.Build.Tasks.ErrorFromResources.Arguments.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.Code.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.Code.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.ErrorFromResources() -> void
-Microsoft.Build.Tasks.ErrorFromResources.File.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.File.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.HelpKeyword.set -> void
-Microsoft.Build.Tasks.ErrorFromResources.Resource.get -> string
-Microsoft.Build.Tasks.ErrorFromResources.Resource.set -> void
-Microsoft.Build.Tasks.Exec
-Microsoft.Build.Tasks.Exec.Command.get -> string
-Microsoft.Build.Tasks.Exec.Command.set -> void
-Microsoft.Build.Tasks.Exec.ConsoleOutput.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.get -> bool
-Microsoft.Build.Tasks.Exec.ConsoleToMSBuild.set -> void
-Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.get -> string
-Microsoft.Build.Tasks.Exec.CustomErrorRegularExpression.set -> void
-Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.get -> string
-Microsoft.Build.Tasks.Exec.CustomWarningRegularExpression.set -> void
-Microsoft.Build.Tasks.Exec.Exec() -> void
-Microsoft.Build.Tasks.Exec.IgnoreExitCode.get -> bool
-Microsoft.Build.Tasks.Exec.IgnoreExitCode.set -> void
-Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.get -> bool
-Microsoft.Build.Tasks.Exec.IgnoreStandardErrorWarningFormat.set -> void
-Microsoft.Build.Tasks.Exec.Outputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Exec.Outputs.set -> void
-Microsoft.Build.Tasks.Exec.StdErrEncoding.get -> string
-Microsoft.Build.Tasks.Exec.StdErrEncoding.set -> void
-Microsoft.Build.Tasks.Exec.StdOutEncoding.get -> string
-Microsoft.Build.Tasks.Exec.StdOutEncoding.set -> void
-Microsoft.Build.Tasks.Exec.WorkingDirectory.get -> string
-Microsoft.Build.Tasks.Exec.WorkingDirectory.set -> void
-Microsoft.Build.Tasks.ExtractedClassName
-Microsoft.Build.Tasks.ExtractedClassName.ExtractedClassName() -> void
-Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.get -> bool
-Microsoft.Build.Tasks.ExtractedClassName.IsInsideConditionalBlock.set -> void
-Microsoft.Build.Tasks.ExtractedClassName.Name.get -> string
-Microsoft.Build.Tasks.ExtractedClassName.Name.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile
-Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindAppConfigFile.AppConfigFile.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.FindAppConfigFile() -> void
-Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindAppConfigFile.PrimaryList.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindAppConfigFile.SecondaryList.set -> void
-Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.get -> string
-Microsoft.Build.Tasks.FindAppConfigFile.TargetPath.set -> void
-Microsoft.Build.Tasks.FindInList
-Microsoft.Build.Tasks.FindInList.CaseSensitive.get -> bool
-Microsoft.Build.Tasks.FindInList.CaseSensitive.set -> void
-Microsoft.Build.Tasks.FindInList.FindInList() -> void
-Microsoft.Build.Tasks.FindInList.FindLastMatch.get -> bool
-Microsoft.Build.Tasks.FindInList.FindLastMatch.set -> void
-Microsoft.Build.Tasks.FindInList.ItemFound.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindInList.ItemFound.set -> void
-Microsoft.Build.Tasks.FindInList.ItemSpecToFind.get -> string
-Microsoft.Build.Tasks.FindInList.ItemSpecToFind.set -> void
-Microsoft.Build.Tasks.FindInList.List.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInList.List.set -> void
-Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.get -> bool
-Microsoft.Build.Tasks.FindInList.MatchFileNameOnly.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences
-Microsoft.Build.Tasks.FindInvalidProjectReferences.FindInvalidProjectReferences() -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.InvalidReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindInvalidProjectReferences.ProjectReferences.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.FindInvalidProjectReferences.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.FindUnderPath
-Microsoft.Build.Tasks.FindUnderPath.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.Files.set -> void
-Microsoft.Build.Tasks.FindUnderPath.FindUnderPath() -> void
-Microsoft.Build.Tasks.FindUnderPath.InPath.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.InPath.set -> void
-Microsoft.Build.Tasks.FindUnderPath.OutOfPath.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.FindUnderPath.OutOfPath.set -> void
-Microsoft.Build.Tasks.FindUnderPath.Path.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.FindUnderPath.Path.set -> void
-Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.get -> bool
-Microsoft.Build.Tasks.FindUnderPath.UpdateToAbsolutePaths.set -> void
-Microsoft.Build.Tasks.FormatUrl
-Microsoft.Build.Tasks.FormatUrl.FormatUrl() -> void
-Microsoft.Build.Tasks.FormatUrl.InputUrl.get -> string
-Microsoft.Build.Tasks.FormatUrl.InputUrl.set -> void
-Microsoft.Build.Tasks.FormatUrl.OutputUrl.get -> string
-Microsoft.Build.Tasks.FormatUrl.OutputUrl.set -> void
-Microsoft.Build.Tasks.FormatVersion
-Microsoft.Build.Tasks.FormatVersion.FormatType.get -> string
-Microsoft.Build.Tasks.FormatVersion.FormatType.set -> void
-Microsoft.Build.Tasks.FormatVersion.FormatVersion() -> void
-Microsoft.Build.Tasks.FormatVersion.OutputVersion.get -> string
-Microsoft.Build.Tasks.FormatVersion.OutputVersion.set -> void
-Microsoft.Build.Tasks.FormatVersion.Revision.get -> int
-Microsoft.Build.Tasks.FormatVersion.Revision.set -> void
-Microsoft.Build.Tasks.FormatVersion.Version.get -> string
-Microsoft.Build.Tasks.FormatVersion.Version.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest
-Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ClrVersion.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.ConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.Dependencies.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.FileAssociations.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.Files.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.GenerateApplicationManifest() -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.HostInBrowser.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.IconFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateApplicationManifest.IsolatedComReferences.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.ManifestType.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.OSVersion.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Product.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.Product.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.Publisher.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.RequiresMinimumFramework35SP1.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkProfile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.get -> string
-Microsoft.Build.Tasks.GenerateApplicationManifest.TargetFrameworkSubset.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateApplicationManifest.TrustInfoFile.set -> void
-Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.get -> bool
-Microsoft.Build.Tasks.GenerateApplicationManifest.UseApplicationTrust.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects
-Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateBindingRedirects.AppConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.GenerateBindingRedirects() -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateBindingRedirects.OutputAppConfigFile.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateBindingRedirects.SuggestedRedirects.set -> void
-Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.get -> string
-Microsoft.Build.Tasks.GenerateBindingRedirects.TargetName.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest
-Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.CreateDesktopShortcut.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DeploymentUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.DisallowUrlActivation.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.ErrorReportUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.GenerateDeploymentManifest() -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Install.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MapFileExtensions.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.MinimumRequiredVersion.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Product.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.Publisher.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SuiteName.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.SupportUrl.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.TrustUrlParameters.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.get -> bool
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateEnabled.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.get -> int
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateInterval.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateMode.set -> void
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.get -> string
-Microsoft.Build.Tasks.GenerateDeploymentManifest.UpdateUnit.set -> void
-Microsoft.Build.Tasks.GenerateLauncher
-Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.AssemblyName.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateLauncher.EntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.GenerateLauncher() -> void
-Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.LauncherPath.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateLauncher.OutputEntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.OutputPath.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.OutputPath.set -> void
-Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.get -> string
-Microsoft.Build.Tasks.GenerateLauncher.VisualStudioVersion.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase
-Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddAssemblyNameFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddEntryPointFromItem(Microsoft.Build.Framework.ITaskItem item, Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType referenceType) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-Microsoft.Build.Tasks.GenerateManifestBase.AddFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyName.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.AssemblyVersion.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.Description.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.Description.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.EntryPoint.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.FindFileFromItem(Microsoft.Build.Framework.ITaskItem item) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference
-Microsoft.Build.Tasks.GenerateManifestBase.GenerateManifestBase() -> void
-Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.InputManifest.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.GenerateManifestBase.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.get -> int
-Microsoft.Build.Tasks.GenerateManifestBase.MaxTargetPath.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateManifestBase.OutputManifest.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.Platform.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.Platform.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetCulture.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.GenerateManifestBase.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.GenerateResource
-Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.AdditionalInputs.set -> void
-Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.get -> string[]
-Microsoft.Build.Tasks.GenerateResource.EnvironmentVariables.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.ExcludedInputPaths.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.get -> bool
-Microsoft.Build.Tasks.GenerateResource.ExecuteAsTool.set -> void
-Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.get -> bool
-Microsoft.Build.Tasks.GenerateResource.ExtractResWFiles.set -> void
-Microsoft.Build.Tasks.GenerateResource.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.GenerateResource() -> void
-Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.get -> bool
-Microsoft.Build.Tasks.GenerateResource.MinimalRebuildFromTracking.set -> void
-Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.get -> bool
-Microsoft.Build.Tasks.GenerateResource.NeverLockTypeAssemblies.set -> void
-Microsoft.Build.Tasks.GenerateResource.OutputDirectory.get -> string
-Microsoft.Build.Tasks.GenerateResource.OutputDirectory.set -> void
-Microsoft.Build.Tasks.GenerateResource.OutputResources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.OutputResources.set -> void
-Microsoft.Build.Tasks.GenerateResource.PublicClass.get -> bool
-Microsoft.Build.Tasks.GenerateResource.PublicClass.set -> void
-Microsoft.Build.Tasks.GenerateResource.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.References.set -> void
-Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.Sources.set -> void
-Microsoft.Build.Tasks.GenerateResource.StateFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.GenerateResource.StateFile.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedClassName.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedFileName.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedLanguage.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedManifestPrefix.set -> void
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.get -> string
-Microsoft.Build.Tasks.GenerateResource.StronglyTypedNamespace.set -> void
-Microsoft.Build.Tasks.GenerateResource.TLogReadFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.TLogWriteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.get -> string
-Microsoft.Build.Tasks.GenerateResource.ToolArchitecture.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerFrameworkPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerLogDirectory.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.get -> string
-Microsoft.Build.Tasks.GenerateResource.TrackerSdkPath.set -> void
-Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.get -> bool
-Microsoft.Build.Tasks.GenerateResource.TrackFileAccess.set -> void
-Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.get -> bool
-Microsoft.Build.Tasks.GenerateResource.UsePreserializedResources.set -> void
-Microsoft.Build.Tasks.GenerateResource.UseSourcePath.get -> bool
-Microsoft.Build.Tasks.GenerateResource.UseSourcePath.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity
-Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetAssemblyIdentity.Assemblies.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetAssemblyIdentity.AssemblyFiles.set -> void
-Microsoft.Build.Tasks.GetAssemblyIdentity.GetAssemblyIdentity() -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform
-Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetCompatiblePlatform.AnnotatedProjects.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetCompatiblePlatform.AssignedProjectsWithPlatform.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.get -> string
-Microsoft.Build.Tasks.GetCompatiblePlatform.CurrentProjectPlatform.set -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.GetCompatiblePlatform() -> void
-Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.get -> string
-Microsoft.Build.Tasks.GetCompatiblePlatform.PlatformLookupTable.set -> void
-Microsoft.Build.Tasks.GetFileHash
-Microsoft.Build.Tasks.GetFileHash.Algorithm.get -> string
-Microsoft.Build.Tasks.GetFileHash.Algorithm.set -> void
-Microsoft.Build.Tasks.GetFileHash.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetFileHash.Files.set -> void
-Microsoft.Build.Tasks.GetFileHash.GetFileHash() -> void
-Microsoft.Build.Tasks.GetFileHash.Hash.get -> string
-Microsoft.Build.Tasks.GetFileHash.Hash.set -> void
-Microsoft.Build.Tasks.GetFileHash.HashEncoding.get -> string
-Microsoft.Build.Tasks.GetFileHash.HashEncoding.set -> void
-Microsoft.Build.Tasks.GetFileHash.Items.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetFileHash.Items.set -> void
-Microsoft.Build.Tasks.GetFileHash.MetadataName.get -> string
-Microsoft.Build.Tasks.GetFileHash.MetadataName.set -> void
-Microsoft.Build.Tasks.GetFrameworkPath
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion11Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion20Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion30Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion35Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion40Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion451Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion452Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion45Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion461Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion462Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion46Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion471Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion472Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion47Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion48Path.get -> string
-Microsoft.Build.Tasks.GetFrameworkPath.GetFrameworkPath() -> void
-Microsoft.Build.Tasks.GetFrameworkPath.Path.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations
-Microsoft.Build.Tasks.GetInstalledSDKLocations.GetInstalledSDKLocations() -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.get -> string[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.get -> string[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.get -> bool
-Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.get -> bool
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.FullFrameworkReferenceAssemblyPaths.get -> string[]
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.GetReferenceAssemblyPaths() -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.ReferenceAssemblyPaths.get -> string[]
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.RootPath.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.get -> bool
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.SuppressNotFoundError.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkFallbackSearchPaths.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.get -> string
-Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.GetSDKReferenceFiles() -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.RedistFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.get -> string[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.set -> void
-Microsoft.Build.Tasks.Hash
-Microsoft.Build.Tasks.Hash.Hash() -> void
-Microsoft.Build.Tasks.Hash.HashResult.get -> string
-Microsoft.Build.Tasks.Hash.HashResult.set -> void
-Microsoft.Build.Tasks.Hash.IgnoreCase.get -> bool
-Microsoft.Build.Tasks.Hash.IgnoreCase.set -> void
-Microsoft.Build.Tasks.Hash.ItemsToHash.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Hash.ItemsToHash.set -> void
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAdditionalFiles(Microsoft.Build.Framework.ITaskItem[] additionalFiles) -> bool
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetAnalyzers(Microsoft.Build.Framework.ITaskItem[] analyzers) -> bool
-Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject.SetRuleSet(string ruleSetFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject
-Microsoft.Build.Tasks.Hosting.ICscHostObject.BeginInitialization() -> void
-Microsoft.Build.Tasks.Hosting.ICscHostObject.Compile() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.EndInitialization(out string errorMessage, out int errorCode) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.IsDesignTime() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.IsUpToDate() -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAddModules(string[] addModules) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetAllowUnsafeBlocks(bool allowUnsafeBlocks) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetBaseAddress(string baseAddress) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCheckForOverflowUnderflow(bool checkForOverflowUnderflow) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetCodePage(int codePage) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDebugType(string debugType) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDefineConstants(string defineConstants) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDelaySign(bool delaySignExplicitlySet, bool delaySign) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetDocumentationFile(string documentationFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetEmitDebugInformation(bool emitDebugInformation) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetErrorReport(string errorReport) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetFileAlignment(int fileAlignment) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetGenerateFullPaths(bool generateFullPaths) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyContainer(string keyContainer) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetKeyFile(string keyFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLangVersion(string langVersion) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetMainEntryPoint(string targetType, string mainEntryPoint) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetModuleAssemblyName(string moduleAssemblyName) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoConfig(bool noConfig) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetNoStandardLib(bool noStandardLib) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOptimize(bool optimize) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetOutputAssembly(string outputAssembly) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPdbFile(string pdbFile) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetPlatform(string platform) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTargetType(string targetType) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningLevel(int warningLevel) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Icon(string win32Icon) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject.SetWin32Resource(string win32Resource) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject2
-Microsoft.Build.Tasks.Hosting.ICscHostObject2.SetWin32Manifest(string win32Manifest) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject3
-Microsoft.Build.Tasks.Hosting.ICscHostObject3.SetApplicationConfiguration(string applicationConfiguration) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetHighEntropyVA(bool highEntropyVA) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
-Microsoft.Build.Tasks.Hosting.ICscHostObject4.SetSubsystemVersion(string subsystemVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.BeginInitialization() -> void
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.Compile() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.EndInitialization() -> void
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsDesignTime() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.IsUpToDate() -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAdditionalLibPaths(string[] additionalLibPaths) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetAddModules(string[] addModules) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetBaseAddress(string targetType, string baseAddress) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetCodePage(int codePage) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDebugType(bool emitDebugInformation, string debugType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDefineConstants(string defineConstants) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDelaySign(bool delaySign) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDisabledWarnings(string disabledWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetDocumentationFile(string documentationFile) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetErrorReport(string errorReport) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetFileAlignment(int fileAlignment) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetGenerateDocumentation(bool generateDocumentation) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetImports(Microsoft.Build.Framework.ITaskItem[] importsList) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyContainer(string keyContainer) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetKeyFile(string keyFile) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetLinkResources(Microsoft.Build.Framework.ITaskItem[] linkResources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetMainEntryPoint(string mainEntryPoint) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoConfig(bool noConfig) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoStandardLib(bool noStandardLib) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetNoWarnings(bool noWarnings) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptimize(bool optimize) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionCompare(string optionCompare) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionExplicit(bool optionExplicit) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrict(bool optionStrict) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOptionStrictType(string optionStrictType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetOutputAssembly(string outputAssembly) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetPlatform(string platform) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetReferences(Microsoft.Build.Framework.ITaskItem[] references) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRemoveIntegerChecks(bool removeIntegerChecks) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResources(Microsoft.Build.Framework.ITaskItem[] resources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetResponseFiles(Microsoft.Build.Framework.ITaskItem[] responseFiles) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetRootNamespace(string rootNamespace) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSdkPath(string sdkPath) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetSources(Microsoft.Build.Framework.ITaskItem[] sources) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetCompactFramework(bool targetCompactFramework) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTargetType(string targetType) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetTreatWarningsAsErrors(bool treatWarningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsAsErrors(string warningsAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWarningsNotAsErrors(string warningsNotAsErrors) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Icon(string win32Icon) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject.SetWin32Resource(string win32Resource) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetModuleAssemblyName(string moduleAssemblyName) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetOptionInfer(bool optionInfer) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject2.SetWin32Manifest(string win32Manifest) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject3
-Microsoft.Build.Tasks.Hosting.IVbcHostObject3.SetLanguageVersion(string languageVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject4
-Microsoft.Build.Tasks.Hosting.IVbcHostObject4.SetVBRuntime(string VBRuntime) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.CompileAsync(out System.IntPtr buildSucceededEvent, out System.IntPtr buildFailedEvent) -> int
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.EndCompile(bool buildSuccess) -> int
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.GetFreeThreadedHostObject() -> Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetHighEntropyVA(bool highEntropyVA) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetPlatformWith32BitPreference(string platformWith32BitPreference) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetSubsystemVersion(string subsystemVersion) -> bool
-Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
-Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded.Compile() -> bool
-Microsoft.Build.Tasks.IFixedTypeInfo
-Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(object pUnkOuter, ref System.Guid riid, out object ppvObj) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(out System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, out int pIndex) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, System.IntPtr pBstrDllName, System.IntPtr pBstrName, System.IntPtr pwOrdinal) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(int index, out System.IntPtr ppFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(int index, out System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(int memid, out string pBstrMops) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out Microsoft.Build.Tasks.IFixedTypeInfo ppTI) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeOfImplType(int index, out System.IntPtr href) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeAttr(out System.IntPtr ppTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeComp(out System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetVarDesc(int index, out System.IntPtr ppVarDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, System.IntPtr pVarResult, System.IntPtr pExcepInfo, out int puArgErr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr pFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr pTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr pVarDesc) -> void
-Microsoft.Build.Tasks.LC
-Microsoft.Build.Tasks.LC.LC() -> void
-Microsoft.Build.Tasks.LC.LicenseTarget.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.LC.LicenseTarget.set -> void
-Microsoft.Build.Tasks.LC.NoLogo.get -> bool
-Microsoft.Build.Tasks.LC.NoLogo.set -> void
-Microsoft.Build.Tasks.LC.OutputDirectory.get -> string
-Microsoft.Build.Tasks.LC.OutputDirectory.set -> void
-Microsoft.Build.Tasks.LC.OutputLicense.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.LC.OutputLicense.set -> void
-Microsoft.Build.Tasks.LC.ReferencedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.LC.ReferencedAssemblies.set -> void
-Microsoft.Build.Tasks.LC.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.LC.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.LC.Sources.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.LC.Sources.set -> void
-Microsoft.Build.Tasks.LC.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.LC.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.MakeDir
-Microsoft.Build.Tasks.MakeDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MakeDir.Directories.set -> void
-Microsoft.Build.Tasks.MakeDir.DirectoriesCreated.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MakeDir.MakeDir() -> void
-Microsoft.Build.Tasks.Message
-Microsoft.Build.Tasks.Message.Code.get -> string
-Microsoft.Build.Tasks.Message.Code.set -> void
-Microsoft.Build.Tasks.Message.File.get -> string
-Microsoft.Build.Tasks.Message.File.set -> void
-Microsoft.Build.Tasks.Message.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Message.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Message.Importance.get -> string
-Microsoft.Build.Tasks.Message.Importance.set -> void
-Microsoft.Build.Tasks.Message.IsCritical.get -> bool
-Microsoft.Build.Tasks.Message.IsCritical.set -> void
-Microsoft.Build.Tasks.Message.Message() -> void
-Microsoft.Build.Tasks.Message.Text.get -> string
-Microsoft.Build.Tasks.Message.Text.set -> void
-Microsoft.Build.Tasks.Move
-Microsoft.Build.Tasks.Move.Cancel() -> void
-Microsoft.Build.Tasks.Move.DestinationFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.DestinationFiles.set -> void
-Microsoft.Build.Tasks.Move.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Move.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Move.Move() -> void
-Microsoft.Build.Tasks.Move.MovedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Move.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Move.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Move.SourceFiles.set -> void
-Microsoft.Build.Tasks.MSBuild
-Microsoft.Build.Tasks.MSBuild.BuildInParallel.get -> bool
-Microsoft.Build.Tasks.MSBuild.BuildInParallel.set -> void
-Microsoft.Build.Tasks.MSBuild.MSBuild() -> void
-Microsoft.Build.Tasks.MSBuild.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MSBuild.Projects.set -> void
-Microsoft.Build.Tasks.MSBuild.Properties.get -> string[]
-Microsoft.Build.Tasks.MSBuild.Properties.set -> void
-Microsoft.Build.Tasks.MSBuild.RebaseOutputs.get -> bool
-Microsoft.Build.Tasks.MSBuild.RebaseOutputs.set -> void
-Microsoft.Build.Tasks.MSBuild.RemoveProperties.get -> string
-Microsoft.Build.Tasks.MSBuild.RemoveProperties.set -> void
-Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.get -> bool
-Microsoft.Build.Tasks.MSBuild.RunEachTargetSeparately.set -> void
-Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.get -> string
-Microsoft.Build.Tasks.MSBuild.SkipNonexistentProjects.set -> void
-Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.get -> bool
-Microsoft.Build.Tasks.MSBuild.StopOnFirstFailure.set -> void
-Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.get -> string[]
-Microsoft.Build.Tasks.MSBuild.TargetAndPropertyListSeparators.set -> void
-Microsoft.Build.Tasks.MSBuild.TargetOutputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.MSBuild.Targets.get -> string[]
-Microsoft.Build.Tasks.MSBuild.Targets.set -> void
-Microsoft.Build.Tasks.MSBuild.ToolsVersion.get -> string
-Microsoft.Build.Tasks.MSBuild.ToolsVersion.set -> void
-Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.get -> bool
-Microsoft.Build.Tasks.MSBuild.UnloadProjectsOnCompletion.set -> void
-Microsoft.Build.Tasks.MSBuild.UseResultsCache.get -> bool
-Microsoft.Build.Tasks.MSBuild.UseResultsCache.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile
-Microsoft.Build.Tasks.ReadLinesFromFile.File.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ReadLinesFromFile.File.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ReadLinesFromFile.Lines.set -> void
-Microsoft.Build.Tasks.ReadLinesFromFile.ReadLinesFromFile() -> void
-Microsoft.Build.Tasks.RemoveDir
-Microsoft.Build.Tasks.RemoveDir.Directories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDir.Directories.set -> void
-Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDir.RemovedDirectories.set -> void
-Microsoft.Build.Tasks.RemoveDir.RemoveDir() -> void
-Microsoft.Build.Tasks.RemoveDuplicates
-Microsoft.Build.Tasks.RemoveDuplicates.Filtered.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDuplicates.Filtered.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.get -> bool
-Microsoft.Build.Tasks.RemoveDuplicates.HadAnyDuplicates.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.Inputs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.RemoveDuplicates.Inputs.set -> void
-Microsoft.Build.Tasks.RemoveDuplicates.RemoveDuplicates() -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedAssemblyExtensions.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AllowedRelatedFileExtensions.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.AppConfigFile.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.Assemblies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCacheOutputPath.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.AssemblyInformationCachePaths.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.AutoUnify.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.CandidateAssemblyFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalDependenciesWhenParentReferenceInGac.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnNETStandard.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.DependsOnSystemRuntime.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.DoNotCopyLocalIfInGac.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FilesWritten.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependencies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindDependenciesOfExternallyResolvedReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindRelatedFiles.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSatellites.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.FindSerializationAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullFrameworkFolders.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.FullTargetFrameworkSubsetNames.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblySubsetTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreDefaultInstalledAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreTargetFrameworkAttributeVersionMismatch.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.IgnoreVersionForFrameworkReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblySubsetTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.InstalledAssemblyTables.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.LatestTargetFrameworkDirectories.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.OutputUnresolvedAssemblyConflicts.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.ProfileName.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.RelatedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolveAssemblyReference() -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedDependencyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ResolvedSDKReferences.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SatelliteFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.ScatterFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SearchPaths.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SerializationAssemblyFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.Silent.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.StateFile.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.SuggestedRedirects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.SupportsBindingRedirectGeneration.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetedRuntimeVersion.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkDirectories.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMoniker.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkMonikerDisplayName.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.get -> string[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkSubsets.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.TargetProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolvedAssemblyConflicts.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.get -> bool
-Microsoft.Build.Tasks.ResolveAssemblyReference.UnresolveFrameworkAssembliesFromHigherFrameworks.set -> void
-Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.get -> string
-Microsoft.Build.Tasks.ResolveAssemblyReference.WarnOrErrorOnTargetArchitectureMismatch.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.get -> string
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSet.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.get -> string[]
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.CodeAnalysisRuleSetDirectories.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.get -> string
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.MSBuildProjectDirectory.set -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolveCodeAnalysisRuleSet() -> void
-Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.ResolvedCodeAnalysisRuleSet.get -> string
-Microsoft.Build.Tasks.ResolveComReference
-Microsoft.Build.Tasks.ResolveComReference.DelaySign.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.DelaySign.set -> void
-Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.get -> string[]
-Microsoft.Build.Tasks.ResolveComReference.EnvironmentVariables.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.ExecuteAsTool.set -> void
-Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.IncludeVersionInInteropName.set -> void
-Microsoft.Build.Tasks.ResolveComReference.KeyContainer.get -> string
-Microsoft.Build.Tasks.ResolveComReference.KeyContainer.set -> void
-Microsoft.Build.Tasks.ResolveComReference.KeyFile.get -> string
-Microsoft.Build.Tasks.ResolveComReference.KeyFile.set -> void
-Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.NoClassMembers.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolveComReference() -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedAssemblyReferences.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedFiles.set -> void
-Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.ResolvedModules.set -> void
-Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.ResolveComReference.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.ResolveComReference.Silent.get -> bool
-Microsoft.Build.Tasks.ResolveComReference.Silent.set -> void
-Microsoft.Build.Tasks.ResolveComReference.StateFile.get -> string
-Microsoft.Build.Tasks.ResolveComReference.StateFile.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveComReference.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveComReference.TargetProcessorArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.TypeLibFiles.set -> void
-Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveComReference.TypeLibNames.set -> void
-Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.get -> string
-Microsoft.Build.Tasks.ResolveComReference.WrapperOutputDirectory.set -> void
-Microsoft.Build.Tasks.ResolveKeySource
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.get -> int
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptShow.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.get -> int
-Microsoft.Build.Tasks.ResolveKeySource.AutoClosePasswordPromptTimeout.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.CertificateFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.CertificateThumbprint.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.KeyFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.KeyFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyContainer.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedKeyFile.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.get -> string
-Microsoft.Build.Tasks.ResolveKeySource.ResolvedThumbprint.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.ResolveKeySource() -> void
-Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.get -> bool
-Microsoft.Build.Tasks.ResolveKeySource.ShowImportDialogDespitePreviousFailures.set -> void
-Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.get -> bool
-Microsoft.Build.Tasks.ResolveKeySource.SuppressAutoClosePasswordPrompt.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles
-Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.AssemblyName.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.DeploymentManifestEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.EntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.ExtraFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.Files.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSelfContainedPublish.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.IsSingleFilePublish.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.LauncherBasedDeployment.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.ManagedAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.NativeAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputDeploymentManifestEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputEntryPoint.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.OutputFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.PublishFiles.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.ResolveManifestFiles() -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.RuntimePackAssets.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveManifestFiles.SatelliteAssemblies.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.get -> bool
-Microsoft.Build.Tasks.ResolveManifestFiles.SigningManifests.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetCulture.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkIdentifier.set -> void
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.ResolveManifestFiles.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.get -> string
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.PreresolvedProjectOutputs.set -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolvedOutputPaths.set -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.ResolveNonMSBuildProjectOutput() -> void
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.UnresolvedProjectReferences.set -> void
-Microsoft.Build.Tasks.ResolveProjectBase
-Microsoft.Build.Tasks.ResolveProjectBase.AddSyntheticProjectReferences(string currentProjectAbsolutePath) -> void
-Microsoft.Build.Tasks.ResolveProjectBase.GetProjectElement(Microsoft.Build.Framework.ITaskItem projectRef) -> System.Xml.XmlElement
-Microsoft.Build.Tasks.ResolveProjectBase.GetProjectItem(Microsoft.Build.Framework.ITaskItem projectRef) -> string
-Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.set -> void
-Microsoft.Build.Tasks.ResolveProjectBase.ResolveProjectBase() -> void
-Microsoft.Build.Tasks.ResolveSDKReference
-Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.References.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.ResolveSDKReference() -> void
-Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.set -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.RoslynCodeTaskFactory() -> void
-Microsoft.Build.Tasks.RoslynCodeTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.SGen
-Microsoft.Build.Tasks.SGen.BuildAssemblyName.get -> string
-Microsoft.Build.Tasks.SGen.BuildAssemblyName.set -> void
-Microsoft.Build.Tasks.SGen.BuildAssemblyPath.get -> string
-Microsoft.Build.Tasks.SGen.BuildAssemblyPath.set -> void
-Microsoft.Build.Tasks.SGen.DelaySign.get -> bool
-Microsoft.Build.Tasks.SGen.DelaySign.set -> void
-Microsoft.Build.Tasks.SGen.KeyContainer.get -> string
-Microsoft.Build.Tasks.SGen.KeyContainer.set -> void
-Microsoft.Build.Tasks.SGen.KeyFile.get -> string
-Microsoft.Build.Tasks.SGen.KeyFile.set -> void
-Microsoft.Build.Tasks.SGen.Platform.get -> string
-Microsoft.Build.Tasks.SGen.Platform.set -> void
-Microsoft.Build.Tasks.SGen.References.get -> string[]
-Microsoft.Build.Tasks.SGen.References.set -> void
-Microsoft.Build.Tasks.SGen.SdkToolsPath.get -> string
-Microsoft.Build.Tasks.SGen.SdkToolsPath.set -> void
-Microsoft.Build.Tasks.SGen.SerializationAssembly.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SGen.SerializationAssembly.set -> void
-Microsoft.Build.Tasks.SGen.SerializationAssemblyName.get -> string
-Microsoft.Build.Tasks.SGen.SGen() -> void
-Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.get -> bool
-Microsoft.Build.Tasks.SGen.ShouldGenerateSerializer.set -> void
-Microsoft.Build.Tasks.SGen.Types.get -> string[]
-Microsoft.Build.Tasks.SGen.Types.set -> void
-Microsoft.Build.Tasks.SGen.UseKeep.get -> bool
-Microsoft.Build.Tasks.SGen.UseKeep.set -> void
-Microsoft.Build.Tasks.SGen.UseProxyTypes.get -> bool
-Microsoft.Build.Tasks.SGen.UseProxyTypes.set -> void
-Microsoft.Build.Tasks.SignFile
-Microsoft.Build.Tasks.SignFile.CertificateThumbprint.get -> string
-Microsoft.Build.Tasks.SignFile.CertificateThumbprint.set -> void
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.get -> bool
-Microsoft.Build.Tasks.SignFile.DisallowMansignTimestampFallback.set -> void
-Microsoft.Build.Tasks.SignFile.SignFile() -> void
-Microsoft.Build.Tasks.SignFile.SigningTarget.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.SignFile.SigningTarget.set -> void
-Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.get -> string
-Microsoft.Build.Tasks.SignFile.TargetFrameworkIdentifier.set -> void
-Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.get -> string
-Microsoft.Build.Tasks.SignFile.TargetFrameworkVersion.set -> void
-Microsoft.Build.Tasks.SignFile.TimestampUrl.get -> string
-Microsoft.Build.Tasks.SignFile.TimestampUrl.set -> void
-Microsoft.Build.Tasks.TaskExtension
-Microsoft.Build.Tasks.TaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Tasks.TaskLoggingHelperExtension
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskLoggingHelperExtension(Microsoft.Build.Framework.ITask taskInstance, System.Resources.ResourceManager primaryResources, System.Resources.ResourceManager sharedResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Tasks.TaskLoggingHelperExtension.TaskSharedResources.set -> void
-Microsoft.Build.Tasks.Telemetry
-Microsoft.Build.Tasks.Telemetry.EventData.get -> string
-Microsoft.Build.Tasks.Telemetry.EventData.set -> void
-Microsoft.Build.Tasks.Telemetry.EventName.get -> string
-Microsoft.Build.Tasks.Telemetry.EventName.set -> void
-Microsoft.Build.Tasks.Telemetry.Telemetry() -> void
-Microsoft.Build.Tasks.ToolTaskExtension
-Microsoft.Build.Tasks.ToolTaskExtension.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Tasks.Touch
-Microsoft.Build.Tasks.Touch.AlwaysCreate.get -> bool
-Microsoft.Build.Tasks.Touch.AlwaysCreate.set -> void
-Microsoft.Build.Tasks.Touch.Files.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Touch.Files.set -> void
-Microsoft.Build.Tasks.Touch.ForceTouch.get -> bool
-Microsoft.Build.Tasks.Touch.ForceTouch.set -> void
-Microsoft.Build.Tasks.Touch.Time.get -> string
-Microsoft.Build.Tasks.Touch.Time.set -> void
-Microsoft.Build.Tasks.Touch.Touch() -> void
-Microsoft.Build.Tasks.Touch.TouchedFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Touch.TouchedFiles.set -> void
-Microsoft.Build.Tasks.Unzip
-Microsoft.Build.Tasks.Unzip.Cancel() -> void
-Microsoft.Build.Tasks.Unzip.DestinationFolder.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.Unzip.DestinationFolder.set -> void
-Microsoft.Build.Tasks.Unzip.Exclude.get -> string
-Microsoft.Build.Tasks.Unzip.Exclude.set -> void
-Microsoft.Build.Tasks.Unzip.Include.get -> string
-Microsoft.Build.Tasks.Unzip.Include.set -> void
-Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.get -> bool
-Microsoft.Build.Tasks.Unzip.OverwriteReadOnlyFiles.set -> void
-Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.get -> bool
-Microsoft.Build.Tasks.Unzip.SkipUnchangedFiles.set -> void
-Microsoft.Build.Tasks.Unzip.SourceFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.Unzip.SourceFiles.set -> void
-Microsoft.Build.Tasks.Unzip.Unzip() -> void
-Microsoft.Build.Tasks.VerifyFileHash
-Microsoft.Build.Tasks.VerifyFileHash.Algorithm.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.Algorithm.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.File.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.File.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.Hash.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.Hash.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.get -> string
-Microsoft.Build.Tasks.VerifyFileHash.HashEncoding.set -> void
-Microsoft.Build.Tasks.VerifyFileHash.VerifyFileHash() -> void
-Microsoft.Build.Tasks.Warning
-Microsoft.Build.Tasks.Warning.Code.get -> string
-Microsoft.Build.Tasks.Warning.Code.set -> void
-Microsoft.Build.Tasks.Warning.File.get -> string
-Microsoft.Build.Tasks.Warning.File.set -> void
-Microsoft.Build.Tasks.Warning.HelpKeyword.get -> string
-Microsoft.Build.Tasks.Warning.HelpKeyword.set -> void
-Microsoft.Build.Tasks.Warning.HelpLink.get -> string
-Microsoft.Build.Tasks.Warning.HelpLink.set -> void
-Microsoft.Build.Tasks.Warning.Text.get -> string
-Microsoft.Build.Tasks.Warning.Text.set -> void
-Microsoft.Build.Tasks.Warning.Warning() -> void
-Microsoft.Build.Tasks.WriteCodeFragment
-Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.WriteCodeFragment.AssemblyAttributes.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.Language.get -> string
-Microsoft.Build.Tasks.WriteCodeFragment.Language.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteCodeFragment.OutputDirectory.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteCodeFragment.OutputFile.set -> void
-Microsoft.Build.Tasks.WriteCodeFragment.WriteCodeFragment() -> void
-Microsoft.Build.Tasks.WriteLinesToFile
-Microsoft.Build.Tasks.WriteLinesToFile.Encoding.get -> string
-Microsoft.Build.Tasks.WriteLinesToFile.Encoding.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.File.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.WriteLinesToFile.File.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.Lines.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.WriteLinesToFile.Lines.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.get -> bool
-Microsoft.Build.Tasks.WriteLinesToFile.Overwrite.set -> void
-Microsoft.Build.Tasks.WriteLinesToFile.WriteLinesToFile() -> void
-Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.get -> bool
-Microsoft.Build.Tasks.WriteLinesToFile.WriteOnlyWhenDifferent.set -> void
-Microsoft.Build.Tasks.XamlTaskFactory
-Microsoft.Build.Tasks.XamlTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
-Microsoft.Build.Tasks.XamlTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
-Microsoft.Build.Tasks.XamlTaskFactory.FactoryName.get -> string
-Microsoft.Build.Tasks.XamlTaskFactory.GetTaskParameters() -> Microsoft.Build.Framework.TaskPropertyInfo[]
-Microsoft.Build.Tasks.XamlTaskFactory.Initialize(string taskName, System.Collections.Generic.IDictionary<string, Microsoft.Build.Framework.TaskPropertyInfo> parameterGroup, string taskBody, Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> bool
-Microsoft.Build.Tasks.XamlTaskFactory.TaskType.get -> System.Type
-Microsoft.Build.Tasks.XamlTaskFactory.XamlTaskFactory() -> void
-Microsoft.Build.Tasks.XmlPeek
-Microsoft.Build.Tasks.XmlPeek.Namespaces.get -> string
-Microsoft.Build.Tasks.XmlPeek.Namespaces.set -> void
-Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.get -> bool
-Microsoft.Build.Tasks.XmlPeek.ProhibitDtd.set -> void
-Microsoft.Build.Tasks.XmlPeek.Query.get -> string
-Microsoft.Build.Tasks.XmlPeek.Query.set -> void
-Microsoft.Build.Tasks.XmlPeek.Result.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XmlPeek.XmlContent.get -> string
-Microsoft.Build.Tasks.XmlPeek.XmlContent.set -> void
-Microsoft.Build.Tasks.XmlPeek.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPeek.XmlInputPath.set -> void
-Microsoft.Build.Tasks.XmlPeek.XmlPeek() -> void
-Microsoft.Build.Tasks.XmlPoke
-Microsoft.Build.Tasks.XmlPoke.Namespaces.get -> string
-Microsoft.Build.Tasks.XmlPoke.Namespaces.set -> void
-Microsoft.Build.Tasks.XmlPoke.Query.get -> string
-Microsoft.Build.Tasks.XmlPoke.Query.set -> void
-Microsoft.Build.Tasks.XmlPoke.Value.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPoke.Value.set -> void
-Microsoft.Build.Tasks.XmlPoke.XmlInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XmlPoke.XmlInputPath.set -> void
-Microsoft.Build.Tasks.XmlPoke.XmlPoke() -> void
-Microsoft.Build.Tasks.XslTransformation
-Microsoft.Build.Tasks.XslTransformation.OutputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XslTransformation.OutputPaths.set -> void
-Microsoft.Build.Tasks.XslTransformation.Parameters.get -> string
-Microsoft.Build.Tasks.XslTransformation.Parameters.set -> void
-Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.get -> bool
-Microsoft.Build.Tasks.XslTransformation.UseTrustedSettings.set -> void
-Microsoft.Build.Tasks.XslTransformation.XmlContent.get -> string
-Microsoft.Build.Tasks.XslTransformation.XmlContent.set -> void
-Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.XslTransformation.XmlInputPaths.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XslTransformation.XslCompiledDllPath.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslContent.get -> string
-Microsoft.Build.Tasks.XslTransformation.XslContent.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslInputPath.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.XslTransformation.XslInputPath.set -> void
-Microsoft.Build.Tasks.XslTransformation.XslTransformation() -> void
-Microsoft.Build.Tasks.ZipDirectory
-Microsoft.Build.Tasks.ZipDirectory.DestinationFile.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ZipDirectory.DestinationFile.set -> void
-Microsoft.Build.Tasks.ZipDirectory.Overwrite.get -> bool
-Microsoft.Build.Tasks.ZipDirectory.Overwrite.set -> void
-Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.get -> Microsoft.Build.Framework.ITaskItem
-Microsoft.Build.Tasks.ZipDirectory.SourceDirectory.set -> void
-Microsoft.Build.Tasks.ZipDirectory.ZipDirectory() -> void
-override Microsoft.Build.Tasks.AssignCulture.Execute() -> bool
-override Microsoft.Build.Tasks.AssignLinkMetadata.Execute() -> bool
-override Microsoft.Build.Tasks.AssignProjectConfiguration.Execute() -> bool
-override Microsoft.Build.Tasks.AssignTargetPath.Execute() -> bool
-override Microsoft.Build.Tasks.CallTarget.Execute() -> bool
-override Microsoft.Build.Tasks.CombinePath.Execute() -> bool
-override Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties.Execute() -> bool
-override Microsoft.Build.Tasks.CombineXmlElements.Execute() -> bool
-override Microsoft.Build.Tasks.ConvertToAbsolutePath.Execute() -> bool
-override Microsoft.Build.Tasks.Copy.Execute() -> bool
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.IsSourceFile(string fileName) -> bool
-override Microsoft.Build.Tasks.CreateCSharpManifestResourceName.SourceFileExtension.get -> string
-override Microsoft.Build.Tasks.CreateItem.Execute() -> bool
-override Microsoft.Build.Tasks.CreateManifestResourceName.Execute() -> bool
-override Microsoft.Build.Tasks.CreateProperty.Execute() -> bool
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, System.IO.Stream binaryStream) -> string
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.IsSourceFile(string fileName) -> bool
-override Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName.SourceFileExtension.get -> string
-override Microsoft.Build.Tasks.Delete.Execute() -> bool
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.EntryPoint.set -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest.Validate() -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.EntryPoint.set -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest.Validate() -> void
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.ToString() -> string
-override Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo.ToString() -> string
-override Microsoft.Build.Tasks.DownloadFile.Execute() -> bool
-override Microsoft.Build.Tasks.Error.Execute() -> bool
-override Microsoft.Build.Tasks.ErrorFromResources.Execute() -> bool
-override Microsoft.Build.Tasks.Exec.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.Exec.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
-override Microsoft.Build.Tasks.Exec.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.Exec.GetWorkingDirectory() -> string
-override Microsoft.Build.Tasks.Exec.HandleTaskExecutionErrors() -> bool
-override Microsoft.Build.Tasks.Exec.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
-override Microsoft.Build.Tasks.Exec.LogPathToTool(string toolName, string pathToTool) -> void
-override Microsoft.Build.Tasks.Exec.LogToolCommand(string message) -> void
-override Microsoft.Build.Tasks.Exec.StandardErrorEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.Exec.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-override Microsoft.Build.Tasks.Exec.StandardOutputEncoding.get -> System.Text.Encoding
-override Microsoft.Build.Tasks.Exec.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-override Microsoft.Build.Tasks.Exec.ToolName.get -> string
-override Microsoft.Build.Tasks.Exec.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.FindAppConfigFile.Execute() -> bool
-override Microsoft.Build.Tasks.FindInList.Execute() -> bool
-override Microsoft.Build.Tasks.FindInvalidProjectReferences.Execute() -> bool
-override Microsoft.Build.Tasks.FindUnderPath.Execute() -> bool
-override Microsoft.Build.Tasks.FormatUrl.Execute() -> bool
-override Microsoft.Build.Tasks.FormatVersion.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateApplicationManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateBindingRedirects.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateDeploymentManifest.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateLauncher.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateManifestBase.Execute() -> bool
-override Microsoft.Build.Tasks.GenerateResource.Execute() -> bool
-override Microsoft.Build.Tasks.GetAssemblyIdentity.Execute() -> bool
-override Microsoft.Build.Tasks.GetCompatiblePlatform.Execute() -> bool
-override Microsoft.Build.Tasks.GetFileHash.Execute() -> bool
-override Microsoft.Build.Tasks.GetFrameworkPath.Execute() -> bool
-override Microsoft.Build.Tasks.GetInstalledSDKLocations.Execute() -> bool
-override Microsoft.Build.Tasks.GetReferenceAssemblyPaths.Execute() -> bool
-override Microsoft.Build.Tasks.GetSDKReferenceFiles.Execute() -> bool
-override Microsoft.Build.Tasks.Hash.Execute() -> bool
-override Microsoft.Build.Tasks.LC.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.LC.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
-override Microsoft.Build.Tasks.LC.Execute() -> bool
-override Microsoft.Build.Tasks.LC.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.LC.ToolName.get -> string
-override Microsoft.Build.Tasks.LC.ValidateParameters() -> bool
-override Microsoft.Build.Tasks.MakeDir.Execute() -> bool
-override Microsoft.Build.Tasks.Message.Execute() -> bool
-override Microsoft.Build.Tasks.Move.Execute() -> bool
-override Microsoft.Build.Tasks.MSBuild.Execute() -> bool
-override Microsoft.Build.Tasks.ReadLinesFromFile.Execute() -> bool
-override Microsoft.Build.Tasks.RemoveDir.Execute() -> bool
-override Microsoft.Build.Tasks.RemoveDuplicates.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveAssemblyReference.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveComReference.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveKeySource.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveManifestFiles.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveSDKReference.Execute() -> bool
-override Microsoft.Build.Tasks.SGen.Execute() -> bool
-override Microsoft.Build.Tasks.SGen.GenerateFullPathToTool() -> string
-override Microsoft.Build.Tasks.SGen.ToolName.get -> string
-override Microsoft.Build.Tasks.SignFile.Execute() -> bool
-override Microsoft.Build.Tasks.TaskLoggingHelperExtension.FormatResourceString(string resourceName, params object[] args) -> string
-override Microsoft.Build.Tasks.Telemetry.Execute() -> bool
-override Microsoft.Build.Tasks.Touch.Execute() -> bool
-override Microsoft.Build.Tasks.Unzip.Execute() -> bool
-override Microsoft.Build.Tasks.VerifyFileHash.Execute() -> bool
-override Microsoft.Build.Tasks.Warning.Execute() -> bool
-override Microsoft.Build.Tasks.WriteCodeFragment.Execute() -> bool
-override Microsoft.Build.Tasks.WriteLinesToFile.Execute() -> bool
-override Microsoft.Build.Tasks.XmlPeek.Execute() -> bool
-override Microsoft.Build.Tasks.XmlPoke.Execute() -> bool
-override Microsoft.Build.Tasks.XslTransformation.Execute() -> bool
-override Microsoft.Build.Tasks.ZipDirectory.Execute() -> bool
-override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureDeformatter
-override System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key) -> System.Security.Cryptography.AsymmetricSignatureFormatter
-static Microsoft.Build.Tasks.CreateManifestResourceName.MakeValidEverettIdentifier(string name) -> string
-static Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder.XmlToConfigurationFile(System.Xml.XmlNode input) -> string
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromAssemblyName(string assemblyName) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromFile(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManagedAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromManifest(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity.FromNativeAssembly(string path) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string manifestType, System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(string path, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader.ReadManifest(System.IO.Stream input, bool preserveStream) -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, string path, string targetframeWorkVersion) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter.WriteManifest(Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest manifest, System.IO.Stream output) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certPath, System.Security.SecureString certPassword, System.Uri timestampUrl, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(string certThumbprint, System.Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback) -> void
-static Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities.SignFile(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Uri timestampUrl, string path) -> void
-System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription
-System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription.RSAPKCS1SHA256SignatureDescription() -> void
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.get -> Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.EntryPoint.set -> void
-virtual Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest.Validate() -> void
-virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateInputs() -> bool
-virtual Microsoft.Build.Tasks.GenerateManifestBase.ValidateOutput() -> bool
\ No newline at end of file
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
deleted file mode 100644
index 176cca35d60..00000000000
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Projects.set -> void
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.SetRidAgnosticValueForProjects() -> void
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.UpdatedProjects.set -> void
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.get -> bool
-Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
-override Microsoft.Build.Tasks.SetRidAgnosticValueForProjects.Execute() -> bool
diff --git a/src/Tasks/RedistList.cs b/src/Tasks/RedistList.cs
index 6d2862fac49..2fdd200203a 100644
--- a/src/Tasks/RedistList.cs
+++ b/src/Tasks/RedistList.cs
@@ -918,8 +918,8 @@ internal class AssemblyTableInfo : IComparable
 
         internal AssemblyTableInfo(string path, string frameworkDirectory)
         {
-            Path = path;
-            FrameworkDirectory = frameworkDirectory;
+            Path = FileUtilities.NormalizeForPathComparison(path);
+            FrameworkDirectory = FileUtilities.NormalizeForPathComparison(frameworkDirectory);
         }
 
         internal string Path { get; }
diff --git a/src/Tasks/ResGenDependencies.cs b/src/Tasks/ResGenDependencies.cs
index 143d69af4c5..530982c0f32 100644
--- a/src/Tasks/ResGenDependencies.cs
+++ b/src/Tasks/ResGenDependencies.cs
@@ -2,11 +2,13 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.IO;
+#if FEATURE_RESXREADER_LIVEDESERIALIZATION
+using System.Collections;
 using System.Resources;
+#endif
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/ResolveComReference.cs b/src/Tasks/ResolveComReference.cs
index c39a2eb609b..bdca81a2457 100644
--- a/src/Tasks/ResolveComReference.cs
+++ b/src/Tasks/ResolveComReference.cs
@@ -2,21 +2,25 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+#if !RUNTIME_TYPE_NETCORE
 using System.Collections.Generic;
+#endif
+#if !NET7_0_OR_GREATER
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
 using System.Linq;
 using System.Reflection;
 using System.Runtime.InteropServices;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 // TYPELIBATTR clashes with the one in InteropServices.
 using TYPELIBATTR = System.Runtime.InteropServices.ComTypes.TYPELIBATTR;
 using UtilitiesProcessorArchitecture = Microsoft.Build.Utilities.ProcessorArchitecture;
+#endif
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 
 #nullable disable
 
diff --git a/src/Tasks/ResolveKeySource.cs b/src/Tasks/ResolveKeySource.cs
index 95e3a2ecf68..9960105ee1d 100644
--- a/src/Tasks/ResolveKeySource.cs
+++ b/src/Tasks/ResolveKeySource.cs
@@ -2,16 +2,16 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using System.Globalization;
 using System.IO;
-using System.Security.Cryptography;
 using System.Security.Cryptography.X509Certificates;
 
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
 #if FEATURE_PFX_SIGNING
+using System.Globalization;
+using System.Security.Cryptography;
 using Microsoft.Runtime.Hosting;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 #endif
 
 #nullable disable
diff --git a/src/Tasks/ResolveManifestFiles.cs b/src/Tasks/ResolveManifestFiles.cs
index 6695d3196f9..80e55c6aaca 100644
--- a/src/Tasks/ResolveManifestFiles.cs
+++ b/src/Tasks/ResolveManifestFiles.cs
@@ -24,7 +24,7 @@ namespace Microsoft.Build.Tasks
     /// <comment>
     /// This task executes following steps:
     ///   (1) Filter out Framework assemblies
-    ///   (2) Filter out non-existant files
+    ///   (2) Filter out non-existent files
     ///   (3) Build list of Dependencies from built items with CopyLocal=True
     ///   (4) Build list of Prerequisites from built items with CopyLocal=False
     ///   (5) Build list of Satellites from built items based on TargetCulture
diff --git a/src/Tasks/ResolveNativeReference.cs b/src/Tasks/ResolveNativeReference.cs
index 0f2b3752dbe..a765f4a4d7a 100644
--- a/src/Tasks/ResolveNativeReference.cs
+++ b/src/Tasks/ResolveNativeReference.cs
@@ -5,7 +5,9 @@
 using System.IO;
 using System.Collections;
 using System.Collections.Generic;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using System.Linq;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/Resources/Strings.resx b/src/Tasks/Resources/Strings.resx
index 3dce8da62b4..e5535f6399e 100644
--- a/src/Tasks/Resources/Strings.resx
+++ b/src/Tasks/Resources/Strings.resx
@@ -251,6 +251,10 @@
     <value>Could not use a link to copy "{0}" to "{1}". Copying the file instead. {2}</value>
     <comment>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</comment>
   </data>
+  <data name="Copy.RetryingAsSymbolicLink">
+    <value>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</value>
+    <comment>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</comment>
+  </data>
   <data name="Copy.NeedsDestination" xml:space="preserve">
     <value>MSB3023: No destination specified for Copy. Please supply either "{0}" or "{1}".</value>
     <comment>{StrBegin="MSB3023: "}</comment>
@@ -1477,6 +1481,12 @@
         LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name. "CopyLocalDependenciesWhenParentReferenceInGac" is a property name.
    </comment>
   </data>
+  <data name="ResolveAssemblyReference.NoBecauseBadImage">
+    <value>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</value>
+    <comment>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </comment>
+  </data>
   <data name="ResolveAssemblyReference.NotCopyLocalBecauseEmbedded" xml:space="preserve">
     <value>This reference is not "CopyLocal" because its types will be embedded into the target assembly.</value>
     <comment>
@@ -2430,9 +2440,11 @@
     <value>MSB3871: Shared projects cannot be built on their own.  Please either build a project that references this project, or build the entire solution.</value>
     <comment>{StrBegin="MSB3871: "}</comment>
   </data>
-  <data name="Copy.ExactlyOneTypeOfLink" xml:space="preserve">
-    <value>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</value>
-  </data>
+
+  <!--
+        MSB3891 - MSB3900   Targets: Copy Overflow
+        If this bucket overflows, pls. contact 'vsppbdev'.
+  -->
   <data name="Copy.ErrorIfLinkFailsSetWithoutLinkOption" xml:space="preserve">
     <value>MSB3892: ErrorIfLinkFails requires UseHardlinksIfPossible or UseSymbolicLinksIfPossible to be set.</value>
     <comment>{StrBegin="MSB3892: "} LOCALIZATION: Do not localize "ErrorIfLinkFails", "UseHardLinksIfPossible", or "UseSymbolicLinksIfPossible".</comment>
@@ -2515,7 +2527,10 @@
   <data name="Unzip.DidNotUnzipBecauseOfFilter" xml:space="preserve">
     <value>Did not unzip file "{0}" because it didn't match the include filter or because it matched the exclude filter.</value>
   </data>
-  <data name="Unzip.FileComment" xml:space="preserve">
+  <data name="Unzip.ZipSlipExploit">
+    <value>Entry is outside the target directory: "{0}"</value>
+  </data>
+  <data name="Unzip.FileComment">
     <value>Unzipping file "{0}" to "{1}".</value>
   </data>
   <data name="ZipDirectory.ErrorDirectoryDoesNotExist" xml:space="preserve">
diff --git a/src/Tasks/Resources/xlf/Strings.cs.xlf b/src/Tasks/Resources/xlf/Strings.cs.xlf
index 4d10d6bdef6..f871ba48031 100644
--- a/src/Tasks/Resources/xlf/Strings.cs.xlf
+++ b/src/Tasks/Resources/xlf/Strings.cs.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Probíhá odebírání atributu pouze pro čtení z položky {0}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Zdrojový soubor {0} je ve skutečnosti adresář.  Úloha kopírování nepodporuje kopírování adresářů.</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">Umístění AssemblyFoldersEx: {0}</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Byla uvažována umístění AssemblyFoldersEx.</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">Soubor {0} se rozzipovává do {1}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: {1} je neplatná hodnota parametru {0}.  Platné hodnoty jsou : {2}.</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">Konfigurační soubor AssemblyFolder ({0}) zadaný v Microsoft.Common.CurrentVersion.targets byl neplatný. Chyba: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: V souboru projektu jste zadali jak položku {0}, tak i {1}. Zvolte buď jednu, nebo druhou.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: Nešlo přečíst existující soubor {0}, aby se zjistilo, jestli je jeho obsah aktuální. Přepíše se.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.de.xlf b/src/Tasks/Resources/xlf/Strings.de.xlf
index 1f43d892a1d..33fe01b3cca 100644
--- a/src/Tasks/Resources/xlf/Strings.de.xlf
+++ b/src/Tasks/Resources/xlf/Strings.de.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Das schreibgeschützte Attribut wird aus "{0}" entfernt.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Die Quelldatei "{0}" ist keine Datei, sondern ein Verzeichnis.  Mit der Copy-Aufgabe können keine Verzeichnisse kopiert werden.</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">Speicherort von AssemblyFoldersEx: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Berücksichtigte Speicherorte von AssemblyFoldersEx.</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">Die Datei "{0}" wird in "{1}" entzippt.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" ist ein ungültiger Wert für den Parameter "{0}". Gültige Werte sind: {2}</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">Die in Microsoft.Common.CurrentVersion.targets festgelegte AssemblyFolder-Konfigurationsdatei ({0}) ist ungültig. Fehler: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: "{0}" und "{1}" wurden in der Projektdatei angegeben. Verwenden Sie nur einen dieser Werte.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: Die vorhandene Datei "{0}" konnte nicht gelesen werden, um zu bestimmen, ob ihr Inhalt aktuell ist. Die Datei wird überschrieben.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.es.xlf b/src/Tasks/Resources/xlf/Strings.es.xlf
index 0a9c4e53de5..95bf54d0a65 100644
--- a/src/Tasks/Resources/xlf/Strings.es.xlf
+++ b/src/Tasks/Resources/xlf/Strings.es.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Se quitará el atributo de solo lectura de "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: El archivo de origen "{0}" es un directorio.  La tarea "Copy" no permite copiar directorios.</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">Ubicación de AssemblyFoldersEx: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Ubicaciones de AssemblyFoldersEx consideradas.</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">Descomprimiendo el archivo "{0}" en "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" no es un valor válido para el parámetro "{0}".  Los valores válidos son: {2}</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">El archivo de configuración ('{0}') de AssemblyFolder especificado en Microsoft.Common.CurrentVersion.targets no es válido. Error: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: Se especificó "{0}" y "{1}" en el archivo de proyecto. Elija solo uno de los dos.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: No se pudo leer el archivo existente "{0}"para determinar si su contenido está actualizado. Sobrescribiéndolo.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.fr.xlf b/src/Tasks/Resources/xlf/Strings.fr.xlf
index 1fb6fb17bfd..2d7ce88789f 100644
--- a/src/Tasks/Resources/xlf/Strings.fr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.fr.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Suppression de l'attribut de lecture seule de "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Le fichier source "{0}" est en fait un répertoire.  La tâche "Copy" ne prend pas en charge la copie des répertoires.</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">Emplacement d'AssemblyFoldersEx : "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Emplacements d'AssemblyFoldersEx envisagés.</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">Décompression du fichier "{0}" dans "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" n'est pas une valeur valide pour le paramètre "{0}". Les valeurs valides sont : {2}</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">Le fichier config AssemblyFolder ('{0}') spécifié dans Microsoft.Common.CurrentVersion.targets est non valide. Erreur : {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: "{0}" et "{1}" ont été spécifiés dans le fichier projet. Choisissez l'un ou l'autre.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: Impossible de lire le fichier existant "{0}" pour déterminer si son contenu est à jour. Remplacement du fichier.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 932a415363a..a015575fa68 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Rimozione dell'attributo di sola lettura da "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: il file di origine "{0}" è in realtà una directory. L'attività "Copia" non supporta la copia di directory.</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">Percorso AssemblyFoldersEx: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Percorsi AssemblyFoldersEx considerati.</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">Decompressione del file "{0}" in "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" è un valore non valido per il parametro "{0}". I valori validi sono: {2}</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">Il file config AssemblyFolder ('{0}') specificato in Microsoft.Common.CurrentVersion.targets non è valido. Errore: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: nel file di progetto sono stati specificati sia "{0}" che "{1}". Sceglierne uno.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: non è stato possibile leggere il file esistente "{0}" per determinare se il relativo contenuto è aggiornato. Verrà sovrascritto.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ja.xlf b/src/Tasks/Resources/xlf/Strings.ja.xlf
index fb8a72a98ee..642593ca671 100644
--- a/src/Tasks/Resources/xlf/Strings.ja.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ja.xlf
@@ -201,6 +201,11 @@
         <target state="translated">"{0}" から読み取り専用属性を削除しています。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: ソース ファイル "{0}" はディレクトリです。"Copy" タスクはディレクトリのコピーをサポートしません。</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">AssemblyFoldersEx の場所:"{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">AssemblyFoldersEx の場所が考慮されました。</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">ファイル "{0}" を "{1}" に解凍しています。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" は "{0}" パラメーターに対して無効な値です。有効な値は {2} です。</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">Microsoft.Common.CurrentVersion.targets に指定されている AssemblyFolder 構成ファイル ('{0}') が無効です。エラー: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: "{0}" と "{1}" の両方がプロジェクト ファイルで指定されました。いずれか 1 つを選択してください。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: ファイル "{0}" のコンテンツが最新であるかを判断するため、そのファイルを読み取ることができませんでした。ファイルは上書きされます。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ko.xlf b/src/Tasks/Resources/xlf/Strings.ko.xlf
index ba4e35e2243..f773deb19da 100644
--- a/src/Tasks/Resources/xlf/Strings.ko.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ko.xlf
@@ -201,6 +201,11 @@
         <target state="translated">"{0}"에서 읽기 전용 특성을 제거하고 있습니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 소스 파일 "{0}"은(는) 실제로 디렉터리입니다.  "Copy" 작업으로는 디렉터리를 복사할 수 없습니다.</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">AssemblyFoldersEx 위치: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">AssemblyFoldersEx 위치로 간주했습니다.</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">파일 "{0}"의 압축을 "{1}"에 푸는 중입니다.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}"은(는) "{0}" 매개 변수에 사용할 수 없는 값입니다.  유효한 값은 {2}입니다.</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">Microsoft.Common.CurrentVersion.targets에 지정된 AssemblyFolder 구성 파일('{0}')이 잘못되었습니다. 오류: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: 프로젝트 파일에서 "{0}" 및 "{1}"을(를) 모두 지정했습니다. 둘 중 하나만 선택하세요.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: 기존 파일 "{0}"을(를) 읽을 수 없어 콘텐츠가 최신 상태인지 확인할 수 없습니다. 덮어씁니다.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pl.xlf b/src/Tasks/Resources/xlf/Strings.pl.xlf
index 490afb76bf9..50075f7c0d9 100644
--- a/src/Tasks/Resources/xlf/Strings.pl.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pl.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Usuwanie atrybutu tylko do odczytu z elementu „{0}”.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: Plik źródłowy „{0}” jest w rzeczywistości katalogiem.  Zadanie „Copy” nie obsługuje kopiowania katalogów.</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">Lokalizacja klucza rejestru AssemblyFoldersEx: „{0}”</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Wybrano lokalizacje klucza rejestru AssemblyFoldersEx.</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">Rozpakowywanie pliku „{0}” do pliku „{1}”.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: „{1}” jest nieprawidłową wartością parametru „{0}”.  Prawidłowe wartości: {2}</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">Plik konfiguracji AssemblyFolder („{0}”) określony w elemencie Microsoft.Common.CurrentVersion.targets był nieprawidłowy. Błąd: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: W pliku projektu określono elementy „{0}” i „{1}”. Wybierz jeden z nich.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: nie można odczytać istniejącego pliku „{0}” w celu sprawdzenia, czy jego zawartość jest aktualna. Zostanie on zastąpiony.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
index 8b565c5ceaa..e1cfea4ac57 100644
--- a/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Tasks/Resources/xlf/Strings.pt-BR.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Removendo o atributo somente leitura de "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: O arquivo de origem "{0}" é, na verdade, um diretório.  A tarefa "Copy" não dá suporte à cópia de diretórios.</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">Localização de AssemblyFoldersEx: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Localizações de AssemblyFoldersEx consideradas.</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">Descompactando o arquivo "{0}" em "{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" é um nome inválido para o parâmetro "{0}".  Os valores válidos são: {2}</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">O arquivo de configuração AssemblyFolder ('{0}') especificado em Microsoft.Common.CurrentVersion.targets era inválido. O erro era: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: "{0}" e "{1}" foram especificados no arquivo do projeto. Escolha um ou outro.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: não foi possível ler o arquivo existente "{0}" para determinar se seus conteúdos estão atualizados. Substituindo-o.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.ru.xlf b/src/Tasks/Resources/xlf/Strings.ru.xlf
index 9b42b353fbf..8dd90592200 100644
--- a/src/Tasks/Resources/xlf/Strings.ru.xlf
+++ b/src/Tasks/Resources/xlf/Strings.ru.xlf
@@ -201,6 +201,11 @@
         <target state="translated">Удаление доступного только для чтения атрибута из "{0}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: исходный файл "{0}" в действительности является каталогом.  Задача Copy не поддерживает копирование каталогов.</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">Расположение AssemblyFoldersEx: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">Рассмотрены расположения AssemblyFoldersEx.</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">Распаковка файла "{0}" в"{1}".</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" — недопустимое значение для параметра "{0}".  Допустимые значения: {2}</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">Файл конфигурации AssemblyFolder ("{0}"), указанный в Microsoft.Common.CurrentVersion.targets, недопустим. Ошибка: {1}.</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: в файле проекта указан как "{0}", так и "{1}". Укажите только один из них.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: не удалось считать данные из существующего файла ("{0}") и определить, актуально ли его содержимое. Файл перезаписывается.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.tr.xlf b/src/Tasks/Resources/xlf/Strings.tr.xlf
index 076da5e497c..d1dc8d88f8f 100644
--- a/src/Tasks/Resources/xlf/Strings.tr.xlf
+++ b/src/Tasks/Resources/xlf/Strings.tr.xlf
@@ -201,6 +201,11 @@
         <target state="translated">"{0}" öğesinin salt okunur özniteliği kaldırılıyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: "{0}" kaynak dosyası aslında bir dizindir.  "Kopyala" görevi, dizinleri kopyalamayı desteklemez.</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">AssemblyFoldersEx konumu: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">AssemblyFoldersEx konumları dikkate alındı.</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">"{0}" dosyasının sıkıştırması "{1}" hedefine açılıyor.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" değeri, "{0}" parametresi için geçersiz.  Geçerli değerler şunlardır: {2}</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">Microsoft.Common.CurrentVersion.targets içinde belirtilen AssemblyFolder yapılandırma dosyası ('{0}') geçersiz. Hata: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: Proje dosyasında hem "{0}" hem de "{1}" belirtilmiş. Lütfen yalnızca birini seçin.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: İçeriğinin güncel olup olmadığını belirlemek üzere "{0}" adlı mevcut dosya okunamadı. Dosyanın üzerine yazılıyor.</target>
diff --git a/src/Tasks/Resources/xlf/Strings.xlf b/src/Tasks/Resources/xlf/Strings.xlf
index 0fb97061f54..c4900cd99f9 100644
--- a/src/Tasks/Resources/xlf/Strings.xlf
+++ b/src/Tasks/Resources/xlf/Strings.xlf
@@ -2387,10 +2387,6 @@
         <source>The AssemblyFolder config file ('{0}') specified in Microsoft.Common.CurrentVersion.targets was invalid. The error was: {1}</source>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <note>{StrBegin="MSB3491: "}</note>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
index dd8ffd61187..19dd5bcb70a 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hans.xlf
@@ -201,6 +201,11 @@
         <target state="translated">正在从“{0}”中移除只读特性。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 源文件“{0}”实际上是一个目录。“Copy”任务不支持复制目录。</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">AssemblyFoldersEx 位置:“{0}”</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">已考虑 AssemblyFoldersEx 位置。</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">将文件“{0}”解压缩到“{1}”。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: “{1}”是无效的“{0}”参数值。有效值为: {2}</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">Microsoft.Common.CurrentVersion.targets 中指定的 AssemblyFolder 配置文件(“{0}”)无效。错误为: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: 项目文件中同时指定了“{0}”和“{1}”。请任选其一。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: 无法读取现有文件“{0}”以确定其内容是否是最新的。覆盖此文件。</target>
diff --git a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
index cfbf7c36952..e8c0ff70311 100644
--- a/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Tasks/Resources/xlf/Strings.zh-Hant.xlf
@@ -201,6 +201,11 @@
         <target state="translated">正在從 "{0}" 移除唯讀屬性。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Copy.RetryingAsSymbolicLink">
+        <source>Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</source>
+        <target state="new">Could not use a hard link to copy "{0}" to "{1}". Copying the file with symbolic link instead. {2}</target>
+        <note>LOCALIZATION: {0} and {1} are paths. {2} is an optional localized message.</note>
+      </trans-unit>
       <trans-unit id="Copy.SourceIsDirectory">
         <source>MSB3025: The source file "{0}" is actually a directory.  The "Copy" task does not support copying directories.</source>
         <target state="translated">MSB3025: 來源檔案 "{0}" 其實是目錄。"Copy" 工作不支援複製目錄。</target>
@@ -1622,6 +1627,13 @@
         <target state="translated">AssemblyFoldersEx 位置: "{0}"</target>
         <note />
       </trans-unit>
+      <trans-unit id="ResolveAssemblyReference.NoBecauseBadImage">
+        <source>This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</source>
+        <target state="new">This reference is not "CopyLocal" because it is a bad image. It may be a native binary, or it may not be an assembly at all.</target>
+        <note>
+      LOCALIZATION: Please don't localize "CopyLocal" this is an item meta-data name.
+    </note>
+      </trans-unit>
       <trans-unit id="ResolveAssemblyReference.SearchedAssemblyFoldersEx">
         <source>Considered AssemblyFoldersEx locations.</source>
         <target state="translated">已考慮 AssemblyFoldersEx 位置。</target>
@@ -2605,6 +2617,11 @@
         <target state="translated">正在將檔案 "{0}" 解壓縮到 "{1}"。</target>
         <note />
       </trans-unit>
+      <trans-unit id="Unzip.ZipSlipExploit">
+        <source>Entry is outside the target directory: "{0}"</source>
+        <target state="new">Entry is outside the target directory: "{0}"</target>
+        <note />
+      </trans-unit>
       <trans-unit id="Vbc.EnumParameterHasInvalidValue">
         <source>MSB3401: "{1}" is an invalid value for the "{0}" parameter.  The valid values are: {2}</source>
         <target state="translated">MSB3401: "{1}" 是 "{0}" 參數的無效值。有效值為: {2}</target>
@@ -3290,11 +3307,6 @@
         <target state="translated">Microsoft.Common.CurrentVersion.targets 中所指定的 AssemblyFolder 組態檔 ('{0}') 無效。錯誤為: {1}</target>
         <note />
       </trans-unit>
-      <trans-unit id="Copy.ExactlyOneTypeOfLink">
-        <source>MSB3891: Both "{0}" and "{1}" were specified in the project file. Please choose one or the other.</source>
-        <target state="translated">MSB3891: 專案檔中已同時指定 "{0}" 和 "{1}"。請選擇使用其中一個。</target>
-        <note />
-      </trans-unit>
       <trans-unit id="WriteLinesToFile.ErrorReadingFile">
         <source>MSB3492: Could not read existing file "{0}" to determine whether its contents are up to date. Overwriting it.</source>
         <target state="translated">MSB3492: 無法讀取現有的檔案 "{0}"，所以無法判斷其是否包含最新的內容。將予覆寫。</target>
diff --git a/src/Tasks/SetRidAgnosticValueForProjects.cs b/src/Tasks/SetRidAgnosticValueForProjects.cs
index 7e45e76f163..689a4eb9711 100644
--- a/src/Tasks/SetRidAgnosticValueForProjects.cs
+++ b/src/Tasks/SetRidAgnosticValueForProjects.cs
@@ -3,10 +3,7 @@
 //
 
 using System;
-using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Utilities;
diff --git a/src/Tasks/UnregisterAssembly.cs b/src/Tasks/UnregisterAssembly.cs
index 2ee63116123..88e0ed11611 100644
--- a/src/Tasks/UnregisterAssembly.cs
+++ b/src/Tasks/UnregisterAssembly.cs
@@ -4,7 +4,9 @@
 #if FEATURE_APPDOMAIN
 
 using System;
+#if DEBUG
 using System.Diagnostics;
+#endif
 using System.IO;
 using System.Reflection;
 using System.Runtime.InteropServices;
diff --git a/src/Tasks/Unzip.cs b/src/Tasks/Unzip.cs
index d758c8099b8..718e06555db 100644
--- a/src/Tasks/Unzip.cs
+++ b/src/Tasks/Unzip.cs
@@ -160,6 +160,8 @@ public override bool Execute()
         /// <param name="destinationDirectory">The <see cref="DirectoryInfo"/> to extract files to.</param>
         private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory)
         {
+            string fullDestinationDirectoryPath = Path.GetFullPath(FileUtilities.EnsureTrailingSlash(destinationDirectory.FullName));
+
             foreach (ZipArchiveEntry zipArchiveEntry in sourceArchive.Entries.TakeWhile(i => !_cancellationToken.IsCancellationRequested))
             {
                 if (ShouldSkipEntry(zipArchiveEntry))
@@ -168,7 +170,10 @@ private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirector
                     continue;
                 }
 
-                FileInfo destinationPath = new FileInfo(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));
+                string fullDestinationPath = Path.GetFullPath(Path.Combine(destinationDirectory.FullName, zipArchiveEntry.FullName));
+                ErrorUtilities.VerifyThrowInvalidOperation(fullDestinationPath.StartsWith(fullDestinationDirectoryPath, FileUtilities.PathComparison), "Unzip.ZipSlipExploit", fullDestinationPath);
+
+                FileInfo destinationPath = new(fullDestinationPath);
 
                 // Zip archives can have directory entries listed explicitly.
                 // If this entry is a directory we should create it and move to the next entry.
diff --git a/src/Tasks/WriteCodeFragment.cs b/src/Tasks/WriteCodeFragment.cs
index 5088a0ff87e..a781f20b2c3 100644
--- a/src/Tasks/WriteCodeFragment.cs
+++ b/src/Tasks/WriteCodeFragment.cs
@@ -6,12 +6,14 @@
 using System.CodeDom.Compiler;
 using System.Collections;
 using System.Collections.Generic;
-using System.Configuration;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
 using System.IO;
 using System.Linq;
+#if FEATURE_SYSTEM_CONFIGURATION
+using System.Configuration;
 using System.Security;
+#endif
 using System.Text;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
diff --git a/src/Tasks/XamlTaskFactory/TaskParser.cs b/src/Tasks/XamlTaskFactory/TaskParser.cs
index b0eab96849c..73fc516867b 100644
--- a/src/Tasks/XamlTaskFactory/TaskParser.cs
+++ b/src/Tasks/XamlTaskFactory/TaskParser.cs
@@ -158,7 +158,7 @@ private bool ParseAsContentOrFile(string contentOrFile, string desiredRule)
             //  - or xml content with the current dir prepended (like "/foo/bar/<abc .. />"),
             //    but not on Windows
             //
-            // On Windows, this means that @contentOrFile is really a non-existant file name
+            // On Windows, this means that @contentOrFile is really a non-existent file name
             if (NativeMethodsShared.IsWindows)
                 throw new ArgumentException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("Xaml.RuleFileNotFound", maybeFullPath));
             else // On !Windows, try parsing as XML
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index 7378f094c43..eec457b6a96 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -20,7 +20,6 @@ namespace Microsoft.Build.Tasks
     using System.Reflection;
     using System.Text;
     using System.Threading;
-    using System.Xml;
 
     /// <summary>
     /// The task factory provider for XAML tasks.
diff --git a/src/Tasks/XmlPoke.cs b/src/Tasks/XmlPoke.cs
index b64579109fd..78f0fa6c50c 100644
--- a/src/Tasks/XmlPoke.cs
+++ b/src/Tasks/XmlPoke.cs
@@ -8,6 +8,7 @@
 
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 #nullable disable
 
@@ -30,11 +31,6 @@ public class XmlPoke : TaskExtension
         /// </summary>
         private string _query;
 
-        /// <summary>
-        /// The property that this task will set.
-        /// </summary>
-        private ITaskItem _value;
-
         #endregion
 
         #region Properties
@@ -68,18 +64,8 @@ public string Query
 
         /// <summary>
         /// The value to be inserted into the specified location.
-        /// </summary>
-        [Required]
-        public ITaskItem Value
-        {
-            get
-            {
-                ErrorUtilities.VerifyThrowArgumentNull(_value, nameof(Value));
-                return _value;
-            }
-
-            set => _value = value;
-        }
+        /// </summary>        
+        public ITaskItem Value { get; set; }
 
         /// <summary>
         /// The namespaces for XPath query's prefixes.
@@ -95,8 +81,12 @@ public ITaskItem Value
         public override bool Execute()
         {
             ErrorUtilities.VerifyThrowArgumentNull(_query, "Query");
-            ErrorUtilities.VerifyThrowArgumentNull(_value, "Value");
             ErrorUtilities.VerifyThrowArgumentNull(_xmlInputPath, "XmlInputPath");
+            if (Value == null)
+            {
+                // When Value is null, it means Value is not set or empty. Here we treat them all as empty.
+                Value = new TaskItem(String.Empty);
+            }
 
             // Load the XPath Document
             XmlDocument xmlDoc = new XmlDocument();
@@ -164,12 +154,12 @@ public override bool Execute()
                 try
                 {
                     count++;
-                    iter.Current.InnerXml = _value.ItemSpec;
-                    Log.LogMessageFromResources(MessageImportance.Low, "XmlPoke.Replaced", iter.Current.Name, _value.ItemSpec);
+                    iter.Current.InnerXml = Value.ItemSpec;
+                    Log.LogMessageFromResources(MessageImportance.Low, "XmlPoke.Replaced", iter.Current.Name, Value.ItemSpec);
                 }
                 catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
                 {
-                    Log.LogErrorWithCodeFromResources("XmlPoke.PokeError", _value.ItemSpec, e.Message);
+                    Log.LogErrorWithCodeFromResources("XmlPoke.PokeError", Value.ItemSpec, e.Message);
                     return false;
                 }
             }
diff --git a/src/Tasks/system.design/stronglytypedresourcebuilder.cs b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
index 0facabc1b83..2a0ecc35e16 100644
--- a/src/Tasks/system.design/stronglytypedresourcebuilder.cs
+++ b/src/Tasks/system.design/stronglytypedresourcebuilder.cs
@@ -23,7 +23,9 @@
 
 using System;
 using System.IO;
+#if FEATURE_RESXREADER_LIVEDESERIALIZATION
 using System.Collections;
+#endif
 using System.Collections.Generic;
 using System.Resources;
 using System.CodeDom;
diff --git a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
index 36670c64bc3..b37dbed11db 100644
--- a/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
+++ b/src/Utilities.UnitTests/TaskLoggingHelper_Tests.cs
@@ -171,7 +171,7 @@ public void CheckLogMessageFromFile()
 
             try
             {
-                file = FileUtilities.GetTemporaryFile();
+                file = FileUtilities.GetTemporaryFileName();
 
                 string contents = @"a message here
                     error abcd12345: hey jude.
diff --git a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
index 7a1f034a25c..ad43b36401b 100644
--- a/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
+++ b/src/Utilities.UnitTests/ToolLocationHelper_Tests.cs
@@ -796,6 +796,7 @@ public void TestGetDotNetFrameworkSdkRootRegistryKey()
             string fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK471 = @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.1\WinSDK-NetFx40Tools-x86";
             string fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK472 = @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.7.2\WinSDK-NetFx40Tools-x86";
             string fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK48 = @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8\WinSDK-NetFx40Tools-x86";
+            string fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK481 = @"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Microsoft SDKs\NETFXSDK\4.8.1\WinSDK-NetFx40Tools-x86";
 
             // v4.0
             ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version40, VisualStudioVersion.Version100).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK70A);
@@ -863,9 +864,20 @@ public void TestGetDotNetFrameworkSdkRootRegistryKey()
             Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version48, VisualStudioVersion.Version120));
             Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version48, VisualStudioVersion.Version140));
             ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version48, VisualStudioVersion.Version150).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK48);
+            ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version48, VisualStudioVersion.Version160).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK48);
+            ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version48, VisualStudioVersion.Version170).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK48);
+
+            // v4.8.1
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version100));
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version110));
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version120));
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version140));
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version150));
+            Should.Throw<ArgumentException>(() => ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version160));
+            ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Version481, VisualStudioVersion.Version170).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK481);
 
             // Latest
-            ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Latest, VisualStudioVersion.Version150).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK48);
+            ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(TargetDotNetFrameworkVersion.Latest, VisualStudioVersion.Version170).ShouldBe(fullDotNetFrameworkSdkRegistryPathForV4ToolsOnManagedToolsSDK481);
         }
 
         [Fact]
diff --git a/src/Utilities.UnitTests/ToolTask_Tests.cs b/src/Utilities.UnitTests/ToolTask_Tests.cs
index b5df279597a..d6004dc55d6 100644
--- a/src/Utilities.UnitTests/ToolTask_Tests.cs
+++ b/src/Utilities.UnitTests/ToolTask_Tests.cs
@@ -416,7 +416,7 @@ public void TaskFoundOnPath()
         [Fact]
         public void OverrideStdOutImportanceToLow()
         {
-            string tempFile = FileUtilities.GetTemporaryFile();
+            string tempFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(tempFile, @"hello world");
 
             using (MyTool t = new MyTool())
@@ -444,7 +444,7 @@ public void OverrideStdOutImportanceToLow()
         [Fact]
         public void OverrideStdOutImportanceToHigh()
         {
-            string tempFile = FileUtilities.GetTemporaryFile();
+            string tempFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(tempFile, @"hello world");
 
             using (MyTool t = new MyTool())
@@ -475,7 +475,7 @@ public void OverrideStdOutImportanceToHigh()
         [Fact]
         public void ToolTaskCanChangeCanonicalErrorFormat()
         {
-            string tempFile = FileUtilities.GetTemporaryFile();
+            string tempFile = FileUtilities.GetTemporaryFileName();
             File.WriteAllText(tempFile, @"
                 Main.cs(17,20): warning CS0168: The variable 'foo' is declared but never used.
                 BADTHINGHAPPENED: This is my custom error format that's not in canonical error format.
diff --git a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
index c5dd50492ca..14cd1e7820f 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/FileTrackerTests.cs
@@ -314,7 +314,7 @@ static void Main(string[] args)
 
             try
             {
-                codeFile = FileUtilities.GetTemporaryFile();
+                codeFile = FileUtilities.GetTemporaryFileName();
                 File.WriteAllText(codeFile, codeContent);
                 Csc csc = new Csc();
                 csc.BuildEngine = new MockEngine();
@@ -418,7 +418,7 @@ public void FileTrackerFindStrInIncludeDuplicates()
             try
             {
                 string inputPath = Path.GetFullPath("test.in");
-                codeFile = FileUtilities.GetTemporaryFile();
+                codeFile = FileUtilities.GetTemporaryFileName();
                 string codeContent = @"using System.IO; class X { static void Main() { File.ReadAllText(@""" + inputPath + @"""); File.ReadAllText(@""" + inputPath + @"""); }}";
                 File.WriteAllText(codeFile, codeContent);
                 Csc csc = new Csc();
diff --git a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
index 67cb313a50e..dc79f6c8cc1 100644
--- a/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
+++ b/src/Utilities.UnitTests/TrackedDependencies/TrackedDependenciesTests.cs
@@ -1,6 +1,10 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#pragma warning disable 0219
+
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.IO;
@@ -12,10 +16,6 @@
 using Microsoft.Build.Utilities;
 using Xunit;
 
-#pragma warning disable 0219
-
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.UnitTests.TrackedDependencies
diff --git a/src/Utilities/CompatibilitySuppressions.xml b/src/Utilities/CompatibilitySuppressions.xml
new file mode 100644
index 00000000000..993613f410e
--- /dev/null
+++ b/src/Utilities/CompatibilitySuppressions.xml
@@ -0,0 +1,56 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+  <!-- PKV004 for netstandard2.0-supporting TFs that we do not have runtime assemblies for.
+       This is intentional, because you can only use MSBuild in the context of a .NET SDK
+       (on net7.0, as of MSBuild 17.4) or in the context of Visual Studio (net472), but we
+       have previously shipped netstandard2.0 packages, and if you want to support both
+       runtime contexts it still makes sense to target that. -->
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETCoreApp,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.1</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.2</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETFramework,Version=v4.6.3</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>.NETStandard,Version=v2.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Tizen,Version=v4.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>UAP,Version=v10.0.15064</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation3,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStation4,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.PlayStationVita,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.Xbox360,Version=v0.0</Target>
+  </Suppression>
+  <Suppression>
+    <DiagnosticId>PKV004</DiagnosticId>
+    <Target>Xamarin.XboxOne,Version=v0.0</Target>
+  </Suppression>
+</Suppressions>
diff --git a/src/Utilities/Microsoft.Build.Utilities.csproj b/src/Utilities/Microsoft.Build.Utilities.csproj
index b5e520f25a3..64fa68b16e5 100644
--- a/src/Utilities/Microsoft.Build.Utilities.csproj
+++ b/src/Utilities/Microsoft.Build.Utilities.csproj
@@ -15,6 +15,7 @@
     <PackageDescription>This package contains the $(MSBuildProjectName) assembly which is used to implement custom MSBuild tasks.</PackageDescription>
     <IncludeSatelliteOutputInPack>false</IncludeSatelliteOutputInPack>
     <ApplyNgenOptimization Condition="'$(TargetFramework)' == '$(FullFrameworkTFM)'">full</ApplyNgenOptimization>
+    <EnablePackageValidation>true</EnablePackageValidation>
   </PropertyGroup>
 
   <ItemGroup>
diff --git a/src/Utilities/ProcessorArchitecture.cs b/src/Utilities/ProcessorArchitecture.cs
index 6c846b7f094..188b0c6b2ef 100644
--- a/src/Utilities/ProcessorArchitecture.cs
+++ b/src/Utilities/ProcessorArchitecture.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Diagnostics.CodeAnalysis;
-using Microsoft.Build.Shared;
 
 #nullable disable
 
diff --git a/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt b/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
deleted file mode 100644
index 0c8ceeed580..00000000000
--- a/src/Utilities/PublicAPI/net/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,583 +0,0 @@
-abstract Microsoft.Build.Utilities.AppDomainIsolatedTask.Execute() -> bool
-abstract Microsoft.Build.Utilities.Logger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-abstract Microsoft.Build.Utilities.Task.Execute() -> bool
-abstract Microsoft.Build.Utilities.ToolTask.GenerateFullPathToTool() -> string
-abstract Microsoft.Build.Utilities.ToolTask.ToolName.get -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.AMD64 = "AMD64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.ARM = "ARM" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.ARM64 = "ARM64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.IA64 = "IA64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.MSIL = "MSIL" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.X86 = "x86" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.APPX = "APPX" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.AppxLocation = "AppxLocation" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyLocalExpandedReferenceAssemblies = "CopyLocalExpandedReferenceAssemblies" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedist = "CopyRedist" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedistToSubDirectory = "CopyRedistToSubDirectory" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.DependsOnSDK = "DependsOn" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.DisplayName = "DisplayName" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.ExpandReferenceAssemblies = "ExpandReferenceAssemblies" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.FrameworkIdentity = "FrameworkIdentity" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxOSVersionTested = "MaxOSVersionTested" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxPlatformVersion = "MaxPlatformVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MinOSVersion = "MinOSVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MinVSVersion = "MinVSVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MoreInfo = "MoreInfo" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.PlatformIdentity = "PlatformIdentity" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.ProductFamilyName = "ProductFamilyName" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SDKType = "SDKType" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportedArchitectures = "SupportedArchitectures" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportPrefer32Bit = "SupportPrefer32Bit" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportsMultipleVersions = "SupportsMultipleVersions" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDK = "TargetedSDKArchitecture" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDKConfiguration = "TargetedSDKConfiguration" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatform = "TargetPlatform" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformMinVersion = "TargetPlatformMinVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformVersion = "TargetPlatformVersion" -> string
-Microsoft.Build.Utilities.AppDomainIsolatedTask
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask() -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.set -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.AssemblyFoldersExInfo(Microsoft.Win32.RegistryHive hive, Microsoft.Win32.RegistryView view, string registryKey, string directoryPath, System.Version targetFrameworkVersion) -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.DirectoryPath.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Hive.get -> Microsoft.Win32.RegistryHive
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Key.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.TargetFrameworkVersion.get -> System.Version
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.View.get -> Microsoft.Win32.RegistryView
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.AssemblyFoldersFromConfigInfo(string directoryPath, System.Version targetFrameworkVersion) -> void
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.DirectoryPath.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.TargetFrameworkVersion.get -> System.Version
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem sourceFile, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Framework.ITaskItem[] outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Framework.ITaskItem[] excludedInputPaths, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.CanonicalTrackedInputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] sourceFiles, Microsoft.Build.Utilities.CanonicalTrackedOutputFiles outputs, bool useMinimalRebuildOptimization, bool maintainCompositeRootingMarkers) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.ComputeSourcesNeedingCompilation() -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.ComputeSourcesNeedingCompilation(bool searchForSubRootsInCompositeRootingMarkers) -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.DependencyTable.get -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, string>>
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.FileIsExcludedFromDependencyCheck(string fileName) -> bool
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.RemoveEntryForSourceRoot(string rootingMarker) -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.SaveTlog() -> void
-Microsoft.Build.Utilities.CanonicalTrackedInputFiles.SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.AddComputedOutputForSourceRoot(string sourceKey, string computedOutput) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.AddComputedOutputsForSourceRoot(string sourceKey, Microsoft.Build.Framework.ITaskItem[] computedOutputs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.AddComputedOutputsForSourceRoot(string sourceKey, string[] computedOutputs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool constructOutputsFromTLogs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.CanonicalTrackedOutputFiles(Microsoft.Build.Framework.ITaskItem[] tlogFiles) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.DependencyTable.get -> System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, System.DateTime>>
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.OutputsForNonCompositeSource(params Microsoft.Build.Framework.ITaskItem[] sources) -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.OutputsForSource(Microsoft.Build.Framework.ITaskItem[] sources, bool searchForSubRootsInCompositeRootingMarkers) -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.OutputsForSource(params Microsoft.Build.Framework.ITaskItem[] sources) -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependenciesFromEntryIfMissing(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveDependencyFromEntry(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem dependencyToRemove) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem correspondingOutput) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveEntriesForSource(Microsoft.Build.Framework.ITaskItem[] source, Microsoft.Build.Framework.ITaskItem[] correspondingOutputs) -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveOutputForSourceRoot(string sourceRoot, string outputPathToRemove) -> bool
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.RemoveRootsWithSharedOutputs(Microsoft.Build.Framework.ITaskItem[] sources) -> string[]
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.SaveTlog() -> void
-Microsoft.Build.Utilities.CanonicalTrackedOutputFiles.SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) -> void
-Microsoft.Build.Utilities.CommandLineBuilder
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(Microsoft.Build.Framework.ITaskItem fileItem) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(string fileName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(Microsoft.Build.Framework.ITaskItem[] fileItems, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(string[] fileNames, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameWithQuoting(string fileName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendQuotedTextToBuffer(System.Text.StringBuilder buffer, string unquotedTextToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSpaceIfNotEmpty() -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitch(string switchName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendTextUnquoted(string textToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendTextWithQuoting(string textToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLine.get -> System.Text.StringBuilder
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder() -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.Length.get -> int
-Microsoft.Build.Utilities.DependencyFilter
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness32 = 1 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness64 = 2 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Current = 0 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.Managed32Bit = 3 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.Managed64Bit = 4 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.ManagedARM64 = 7 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.ManagedIL = 2 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.Native32Bit = 0 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.Native64Bit = 1 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.NativeARM64 = 6 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.ExecutableType.SameAsCurrentProcess = 5 -> Microsoft.Build.Utilities.ExecutableType
-Microsoft.Build.Utilities.FileTracker
-Microsoft.Build.Utilities.FlatTrackingData
-Microsoft.Build.Utilities.FlatTrackingData.FileIsExcludedFromDependencyCheck(string fileName) -> bool
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool skipMissingFiles) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITask ownerTask, Microsoft.Build.Framework.ITaskItem[] tlogFiles, System.DateTime missingFileTimeUtc) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, bool skipMissingFiles) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc, string[] excludedInputPaths, System.Collections.Generic.IDictionary<string, System.DateTime> sharedLastWriteTimeUtcCache) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, Microsoft.Build.Framework.ITaskItem[] tlogFilesToIgnore, System.DateTime missingFileTimeUtc, string[] excludedInputPaths, System.Collections.Generic.IDictionary<string, System.DateTime> sharedLastWriteTimeUtcCache, bool treatRootMarkersAsEntries) -> void
-Microsoft.Build.Utilities.FlatTrackingData.FlatTrackingData(Microsoft.Build.Framework.ITaskItem[] tlogFiles, System.DateTime missingFileTimeUtc) -> void
-Microsoft.Build.Utilities.FlatTrackingData.GetLastWriteTimeUtc(string file) -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.MissingFiles.get -> System.Collections.Generic.List<string>
-Microsoft.Build.Utilities.FlatTrackingData.MissingFiles.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileName.get -> string
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileName.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileTime.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileTime.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileTimeUtc.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.NewestFileTimeUtc.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogFileName.get -> string
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogFileName.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTime.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTime.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTimeUtc.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.NewestTLogTimeUtc.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileName.get -> string
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileName.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileTime.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileTime.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileTimeUtc.get -> System.DateTime
-Microsoft.Build.Utilities.FlatTrackingData.OldestFileTimeUtc.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.SaveTlog() -> void
-Microsoft.Build.Utilities.FlatTrackingData.SaveTlog(Microsoft.Build.Utilities.DependencyFilter includeInTLog) -> void
-Microsoft.Build.Utilities.FlatTrackingData.SkipMissingFiles.get -> bool
-Microsoft.Build.Utilities.FlatTrackingData.SkipMissingFiles.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.TlogFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Utilities.FlatTrackingData.TlogFiles.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.TlogsAvailable.get -> bool
-Microsoft.Build.Utilities.FlatTrackingData.TlogsAvailable.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.TreatRootMarkersAsEntries.get -> bool
-Microsoft.Build.Utilities.FlatTrackingData.TreatRootMarkersAsEntries.set -> void
-Microsoft.Build.Utilities.FlatTrackingData.UpdateFileEntryDetails() -> void
-Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnFailure = 3 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnSuccess = 2 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.UseAlternateToolToExecute = 1 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.UseHostObjectToExecute = 0 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.Logger
-Microsoft.Build.Utilities.Logger.IsVerbosityAtLeast(Microsoft.Build.Framework.LoggerVerbosity checkVerbosity) -> bool
-Microsoft.Build.Utilities.Logger.Logger() -> void
-Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Allow = 0 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Error = 2 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Warning = 1 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MuxLogger
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.set -> void
-Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int maxNodeCount) -> void
-Microsoft.Build.Utilities.MuxLogger.MuxLogger() -> void
-Microsoft.Build.Utilities.MuxLogger.Parameters.get -> string
-Microsoft.Build.Utilities.MuxLogger.Parameters.set -> void
-Microsoft.Build.Utilities.MuxLogger.RegisterLogger(int submissionId, Microsoft.Build.Framework.ILogger logger) -> void
-Microsoft.Build.Utilities.MuxLogger.Shutdown() -> void
-Microsoft.Build.Utilities.MuxLogger.UnregisterLoggers(int submissionId) -> bool
-Microsoft.Build.Utilities.MuxLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Utilities.MuxLogger.Verbosity.set -> void
-Microsoft.Build.Utilities.ProcessorArchitecture
-Microsoft.Build.Utilities.SDKManifest
-Microsoft.Build.Utilities.SDKManifest.AppxLocations.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Utilities.SDKManifest.Attributes
-Microsoft.Build.Utilities.SDKManifest.CopyRedistToSubDirectory.get -> string
-Microsoft.Build.Utilities.SDKManifest.DependsOnSDK.get -> string
-Microsoft.Build.Utilities.SDKManifest.DisplayName.get -> string
-Microsoft.Build.Utilities.SDKManifest.FrameworkIdentities.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Utilities.SDKManifest.FrameworkIdentity.get -> string
-Microsoft.Build.Utilities.SDKManifest.MaxOSVersionTested.get -> string
-Microsoft.Build.Utilities.SDKManifest.MaxPlatformVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MinOSVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MinVSVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MoreInfo.get -> string
-Microsoft.Build.Utilities.SDKManifest.PlatformIdentity.get -> string
-Microsoft.Build.Utilities.SDKManifest.ProductFamilyName.get -> string
-Microsoft.Build.Utilities.SDKManifest.ReadError.get -> bool
-Microsoft.Build.Utilities.SDKManifest.ReadErrorMessage.get -> string
-Microsoft.Build.Utilities.SDKManifest.SDKManifest(string pathToSdk) -> void
-Microsoft.Build.Utilities.SDKManifest.SDKType.get -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKManifest.SupportedArchitectures.get -> string
-Microsoft.Build.Utilities.SDKManifest.SupportPrefer32Bit.get -> string
-Microsoft.Build.Utilities.SDKManifest.SupportsMultipleVersions.get -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.SDKManifest.TargetPlatform.get -> string
-Microsoft.Build.Utilities.SDKManifest.TargetPlatformMinVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.TargetPlatformVersion.get -> string
-Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.External = 1 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Framework = 3 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Platform = 2 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Unspecified = 0 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Latest = 9999 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version11 = 0 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version20 = 1 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version30 = 2 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version35 = 3 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version40 = 4 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version45 = 5 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version451 = 6 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version452 = 9 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version46 = 7 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version461 = 8 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version462 = 10 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version47 = 11 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version471 = 12 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version472 = 13 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version48 = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.VersionLatest = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetPlatformSDK
-Microsoft.Build.Utilities.TargetPlatformSDK.ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion) -> bool
-Microsoft.Build.Utilities.TargetPlatformSDK.DisplayName.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.Equals(Microsoft.Build.Utilities.TargetPlatformSDK other) -> bool
-Microsoft.Build.Utilities.TargetPlatformSDK.MinOSVersion.get -> System.Version
-Microsoft.Build.Utilities.TargetPlatformSDK.MinVSVersion.get -> System.Version
-Microsoft.Build.Utilities.TargetPlatformSDK.Path.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.Path.set -> void
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformSDK(string targetPlatformIdentifier, System.Version targetPlatformVersion, string path) -> void
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformVersion.get -> System.Version
-Microsoft.Build.Utilities.Task
-Microsoft.Build.Utilities.Task.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.Task.BuildEngine.set -> void
-Microsoft.Build.Utilities.Task.BuildEngine2.get -> Microsoft.Build.Framework.IBuildEngine2
-Microsoft.Build.Utilities.Task.BuildEngine3.get -> Microsoft.Build.Framework.IBuildEngine3
-Microsoft.Build.Utilities.Task.BuildEngine4.get -> Microsoft.Build.Framework.IBuildEngine4
-Microsoft.Build.Utilities.Task.BuildEngine5.get -> Microsoft.Build.Framework.IBuildEngine5
-Microsoft.Build.Utilities.Task.BuildEngine6.get -> Microsoft.Build.Framework.IBuildEngine6
-Microsoft.Build.Utilities.Task.BuildEngine7.get -> Microsoft.Build.Framework.IBuildEngine7
-Microsoft.Build.Utilities.Task.BuildEngine8.get -> Microsoft.Build.Framework.IBuildEngine8
-Microsoft.Build.Utilities.Task.BuildEngine9.get -> Microsoft.Build.Framework.IBuildEngine9
-Microsoft.Build.Utilities.Task.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.Task.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.Task.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Utilities.Task.HostObject.set -> void
-Microsoft.Build.Utilities.Task.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.Task.Task() -> void
-Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.Task.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.Task.TaskResources.set -> void
-Microsoft.Build.Utilities.TaskItem
-Microsoft.Build.Utilities.TaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
-Microsoft.Build.Utilities.TaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
-Microsoft.Build.Utilities.TaskItem.GetMetadata(string metadataName) -> string
-Microsoft.Build.Utilities.TaskItem.ItemSpec.get -> string
-Microsoft.Build.Utilities.TaskItem.ItemSpec.set -> void
-Microsoft.Build.Utilities.TaskItem.MetadataCount.get -> int
-Microsoft.Build.Utilities.TaskItem.MetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.Utilities.TaskItem.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Utilities.TaskItem.SetMetadata(string metadataName, string metadataValue) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem() -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(Microsoft.Build.Framework.ITaskItem sourceItem) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec, System.Collections.IDictionary itemMetadata) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.TaskLoggingHelper.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.TaskLoggingHelper.ExtractMessageCode(string message, out string messageWithoutCodePrefix) -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.HasLoggedErrors.get -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.IsTaskInputLoggingEnabled.get -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(Microsoft.Build.Framework.MessageImportance importance, string commandLine) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(string commandLine) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace, bool showDetail, string file) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(Microsoft.Build.Framework.MessageImportance importance, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromText(string lineOfText, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception, bool showStackTrace) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.MarkAsInactive() -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.IBuildEngine buildEngine, string taskName) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskName.get -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.set -> void
-Microsoft.Build.Utilities.ToolLocationHelper
-Microsoft.Build.Utilities.ToolTask
-Microsoft.Build.Utilities.ToolTask.DeleteTempFile(string fileName) -> void
-Microsoft.Build.Utilities.ToolTask.EchoOff.get -> bool
-Microsoft.Build.Utilities.ToolTask.EchoOff.set -> void
-Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.get -> string[]
-Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.set -> void
-Microsoft.Build.Utilities.ToolTask.ExitCode.get -> int
-Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.get -> bool
-Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.get -> string
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.get -> string
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.get -> int
-Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.set -> void
-Microsoft.Build.Utilities.ToolTask.ToolCanceled.get -> System.Threading.ManualResetEvent
-Microsoft.Build.Utilities.ToolTask.ToolPath.get -> string
-Microsoft.Build.Utilities.ToolTask.ToolPath.set -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask() -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.get -> bool
-Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.set -> void
-Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.get -> string
-Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.set -> void
-Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.get -> bool
-Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.set -> void
-Microsoft.Build.Utilities.TrackedDependencies
-Microsoft.Build.Utilities.UpToDateCheckType
-Microsoft.Build.Utilities.UpToDateCheckType.InputNewerThanOutput = 0 -> Microsoft.Build.Utilities.UpToDateCheckType
-Microsoft.Build.Utilities.UpToDateCheckType.InputNewerThanTracking = 2 -> Microsoft.Build.Utilities.UpToDateCheckType
-Microsoft.Build.Utilities.UpToDateCheckType.InputOrOutputNewerThanTracking = 1 -> Microsoft.Build.Utilities.UpToDateCheckType
-Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version100 = 0 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version110 = 1 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version120 = 2 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version140 = 3 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version150 = 4 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version160 = 5 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version170 = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.VersionLatest = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
-override Microsoft.Build.Utilities.AppDomainIsolatedTask.InitializeLifetimeService() -> object
-override Microsoft.Build.Utilities.CommandLineBuilder.ToString() -> string
-override Microsoft.Build.Utilities.TargetPlatformSDK.Equals(object obj) -> bool
-override Microsoft.Build.Utilities.TargetPlatformSDK.GetHashCode() -> int
-override Microsoft.Build.Utilities.TaskItem.InitializeLifetimeService() -> object
-override Microsoft.Build.Utilities.TaskItem.ToString() -> string
-override Microsoft.Build.Utilities.TaskLoggingHelper.InitializeLifetimeService() -> object
-override Microsoft.Build.Utilities.ToolTask.Execute() -> bool
-static Microsoft.Build.Utilities.FileTracker.CreateRootingMarkerResponseFile(Microsoft.Build.Framework.ITaskItem[] sources) -> string
-static Microsoft.Build.Utilities.FileTracker.CreateRootingMarkerResponseFile(string rootMarker) -> string
-static Microsoft.Build.Utilities.FileTracker.EndTrackingContext() -> void
-static Microsoft.Build.Utilities.FileTracker.EnsureFileTrackerOnPath() -> string
-static Microsoft.Build.Utilities.FileTracker.EnsureFileTrackerOnPath(string rootPath) -> string
-static Microsoft.Build.Utilities.FileTracker.FileIsExcludedFromDependencies(string fileName) -> bool
-static Microsoft.Build.Utilities.FileTracker.FileIsUnderPath(string fileName, string path) -> bool
-static Microsoft.Build.Utilities.FileTracker.FindTrackerOnPath() -> string
-static Microsoft.Build.Utilities.FileTracker.ForceOutOfProcTracking(Microsoft.Build.Utilities.ExecutableType toolType) -> bool
-static Microsoft.Build.Utilities.FileTracker.ForceOutOfProcTracking(Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string cancelEventName) -> bool
-static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem source) -> string
-static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem source, Microsoft.Build.Framework.ITaskItem output) -> string
-static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem[] sources) -> string
-static Microsoft.Build.Utilities.FileTracker.FormatRootingMarker(Microsoft.Build.Framework.ITaskItem[] sources, Microsoft.Build.Framework.ITaskItem[] outputs) -> string
-static Microsoft.Build.Utilities.FileTracker.GetFileTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType) -> string
-static Microsoft.Build.Utilities.FileTracker.GetFileTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType, string rootPath) -> string
-static Microsoft.Build.Utilities.FileTracker.GetTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType) -> string
-static Microsoft.Build.Utilities.FileTracker.GetTrackerPath(Microsoft.Build.Utilities.ExecutableType toolType, string rootPath) -> string
-static Microsoft.Build.Utilities.FileTracker.ResumeTracking() -> void
-static Microsoft.Build.Utilities.FileTracker.SetThreadCount(int threadCount) -> void
-static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType) -> System.Diagnostics.Process
-static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles) -> System.Diagnostics.Process
-static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) -> System.Diagnostics.Process
-static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string intermediateDirectory, string rootFiles) -> System.Diagnostics.Process
-static Microsoft.Build.Utilities.FileTracker.StartProcess(string command, string arguments, Microsoft.Build.Utilities.ExecutableType toolType, string rootFiles) -> System.Diagnostics.Process
-static Microsoft.Build.Utilities.FileTracker.StartTrackingContext(string intermediateDirectory, string taskName) -> void
-static Microsoft.Build.Utilities.FileTracker.StartTrackingContextWithRoot(string intermediateDirectory, string taskName, string rootMarkerResponseFile) -> void
-static Microsoft.Build.Utilities.FileTracker.StopTrackingAndCleanup() -> void
-static Microsoft.Build.Utilities.FileTracker.SuspendTracking() -> void
-static Microsoft.Build.Utilities.FileTracker.TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles) -> string
-static Microsoft.Build.Utilities.FileTracker.TrackerArguments(string command, string arguments, string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) -> string
-static Microsoft.Build.Utilities.FileTracker.TrackerCommandArguments(string command, string arguments) -> string
-static Microsoft.Build.Utilities.FileTracker.TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles) -> string
-static Microsoft.Build.Utilities.FileTracker.TrackerResponseFileArguments(string dllName, string intermediateDirectory, string rootFiles, string cancelEventName) -> string
-static Microsoft.Build.Utilities.FileTracker.WriteAllTLogs(string intermediateDirectory, string taskName) -> void
-static Microsoft.Build.Utilities.FileTracker.WriteContextTLogs(string intermediateDirectory, string taskName) -> void
-static Microsoft.Build.Utilities.FlatTrackingData.FinalizeTLogs(bool trackedOperationsSucceeded, Microsoft.Build.Framework.ITaskItem[] readTLogNames, Microsoft.Build.Framework.ITaskItem[] writeTLogNames, Microsoft.Build.Framework.ITaskItem[] trackedFilesToRemoveFromTLogs) -> void
-static Microsoft.Build.Utilities.FlatTrackingData.IsUpToDate(Microsoft.Build.Utilities.Task hostTask, Microsoft.Build.Utilities.UpToDateCheckType upToDateCheckType, Microsoft.Build.Framework.ITaskItem[] readTLogNames, Microsoft.Build.Framework.ITaskItem[] writeTLogNames) -> bool
-static Microsoft.Build.Utilities.FlatTrackingData.IsUpToDate(Microsoft.Build.Utilities.TaskLoggingHelper Log, Microsoft.Build.Utilities.UpToDateCheckType upToDateCheckType, Microsoft.Build.Utilities.FlatTrackingData inputs, Microsoft.Build.Utilities.FlatTrackingData outputs) -> bool
-static Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture.get -> string
-static Microsoft.Build.Utilities.TaskItem.explicit operator string(Microsoft.Build.Utilities.TaskItem taskItemToCast) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.ClearSDKStaticCache() -> void
-static Microsoft.Build.Utilities.ToolLocationHelper.CurrentToolsVersion.get -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.FilterPlatformExtensionSDKs(System.Version targetPlatformVersion, System.Collections.Generic.IDictionary<string, string> extensionSdks) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.FilterTargetPlatformSdks(System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> targetPlatformSdkList, System.Version osVersion, System.Version vsVersion) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.FindRootFolderWhereAllFilesExist(string possibleRoots, string relativeFilePaths) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersExInfo>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, System.Runtime.Versioning.FrameworkName frameworkName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkVersionFolderPrefix(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstalls(System.Version minVersion = null, System.Version maxVersion = null, string subFolder = null) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstallsAsString(string minVersionString = null, string maxVersionString = null, string subFolder = null) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, string[] sdkRoots) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk() -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToSystemFile(string fileName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string[] extensionDiskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string[] multiPlatformDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, string targetPlatformVersion) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion, string[] diskRoots, string registryRoot) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetProgramFilesReferenceAssemblyRoot() -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot = null) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSupportedTargetFrameworks() -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks() -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks(string[] diskRoots, string registryRoot) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier) -> System.Runtime.Versioning.FrameworkName
-static Microsoft.Build.Utilities.ToolLocationHelper.PathToSystem.get -> string
-static Microsoft.Build.Utilities.TrackedDependencies.ExpandWildcards(Microsoft.Build.Framework.ITaskItem[] expand) -> Microsoft.Build.Framework.ITaskItem[]
-virtual Microsoft.Build.Utilities.CommandLineBuilder.IsQuotingRequired(string parameter) -> bool
-virtual Microsoft.Build.Utilities.CommandLineBuilder.VerifyThrowNoEmbeddedDoubleQuotes(string switchName, string parameter) -> void
-virtual Microsoft.Build.Utilities.Logger.FormatErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs args) -> string
-virtual Microsoft.Build.Utilities.Logger.FormatWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs args) -> string
-virtual Microsoft.Build.Utilities.Logger.Parameters.get -> string
-virtual Microsoft.Build.Utilities.Logger.Parameters.set -> void
-virtual Microsoft.Build.Utilities.Logger.Shutdown() -> void
-virtual Microsoft.Build.Utilities.Logger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-virtual Microsoft.Build.Utilities.Logger.Verbosity.set -> void
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatResourceString(string resourceName, params object[] args) -> string
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatString(string unformatted, params object[] args) -> string
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.GetResourceMessage(string resourceName) -> string
-virtual Microsoft.Build.Utilities.ToolTask.AdjustCommandsForOperatingSystem(string input) -> string
-virtual Microsoft.Build.Utilities.ToolTask.CallHostObjectToExecute() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.Cancel() -> void
-virtual Microsoft.Build.Utilities.ToolTask.EnvironmentOverride.get -> System.Collections.Generic.Dictionary<string, string>
-virtual Microsoft.Build.Utilities.ToolTask.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
-virtual Microsoft.Build.Utilities.ToolTask.GenerateCommandLineCommands() -> string
-virtual Microsoft.Build.Utilities.ToolTask.GenerateResponseFileCommands() -> string
-virtual Microsoft.Build.Utilities.ToolTask.GetProcessStartInfo(string pathToTool, string commandLineCommands, string responseFileSwitch) -> System.Diagnostics.ProcessStartInfo
-virtual Microsoft.Build.Utilities.ToolTask.GetResponseFileSwitch(string responseFilePath) -> string
-virtual Microsoft.Build.Utilities.ToolTask.GetWorkingDirectory() -> string
-virtual Microsoft.Build.Utilities.ToolTask.HandleTaskExecutionErrors() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.HasLoggedErrors.get -> bool
-virtual Microsoft.Build.Utilities.ToolTask.InitializeHostObject() -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-virtual Microsoft.Build.Utilities.ToolTask.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
-virtual Microsoft.Build.Utilities.ToolTask.LogPathToTool(string toolName, string pathToTool) -> void
-virtual Microsoft.Build.Utilities.ToolTask.LogToolCommand(string message) -> void
-virtual Microsoft.Build.Utilities.ToolTask.ProcessStarted() -> void
-virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEscape(string responseString) -> string
-virtual Microsoft.Build.Utilities.ToolTask.SkipTaskExecution() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.StandardErrorEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-virtual Microsoft.Build.Utilities.ToolTask.StandardOutputEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-virtual Microsoft.Build.Utilities.ToolTask.Timeout.get -> int
-virtual Microsoft.Build.Utilities.ToolTask.Timeout.set -> void
-virtual Microsoft.Build.Utilities.ToolTask.ToolExe.get -> string
-virtual Microsoft.Build.Utilities.ToolTask.ToolExe.set -> void
-virtual Microsoft.Build.Utilities.ToolTask.ValidateParameters() -> bool
\ No newline at end of file
diff --git a/src/Utilities/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Utilities/PublicAPI/net/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
deleted file mode 100644
index 9efcc6b3e9d..00000000000
--- a/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ /dev/null
@@ -1,439 +0,0 @@
-abstract Microsoft.Build.Utilities.AppDomainIsolatedTask.Execute() -> bool
-abstract Microsoft.Build.Utilities.Logger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-abstract Microsoft.Build.Utilities.Task.Execute() -> bool
-abstract Microsoft.Build.Utilities.ToolTask.GenerateFullPathToTool() -> string
-abstract Microsoft.Build.Utilities.ToolTask.ToolName.get -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.AMD64 = "AMD64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.ARM = "ARM" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.ARM64 = "ARM64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.IA64 = "IA64" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.MSIL = "MSIL" -> string
-const Microsoft.Build.Utilities.ProcessorArchitecture.X86 = "x86" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.APPX = "APPX" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.AppxLocation = "AppxLocation" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyLocalExpandedReferenceAssemblies = "CopyLocalExpandedReferenceAssemblies" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedist = "CopyRedist" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.CopyRedistToSubDirectory = "CopyRedistToSubDirectory" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.DependsOnSDK = "DependsOn" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.DisplayName = "DisplayName" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.ExpandReferenceAssemblies = "ExpandReferenceAssemblies" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.FrameworkIdentity = "FrameworkIdentity" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxOSVersionTested = "MaxOSVersionTested" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MaxPlatformVersion = "MaxPlatformVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MinOSVersion = "MinOSVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MinVSVersion = "MinVSVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.MoreInfo = "MoreInfo" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.PlatformIdentity = "PlatformIdentity" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.ProductFamilyName = "ProductFamilyName" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SDKType = "SDKType" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportedArchitectures = "SupportedArchitectures" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportPrefer32Bit = "SupportPrefer32Bit" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.SupportsMultipleVersions = "SupportsMultipleVersions" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDK = "TargetedSDKArchitecture" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDKConfiguration = "TargetedSDKConfiguration" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatform = "TargetPlatform" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformMinVersion = "TargetPlatformMinVersion" -> string
-const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformVersion = "TargetPlatformVersion" -> string
-Microsoft.Build.Utilities.AppDomainIsolatedTask
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask() -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.set -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.AssemblyFoldersExInfo(Microsoft.Win32.RegistryHive hive, Microsoft.Win32.RegistryView view, string registryKey, string directoryPath, System.Version targetFrameworkVersion) -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.DirectoryPath.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Hive.get -> Microsoft.Win32.RegistryHive
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Key.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.TargetFrameworkVersion.get -> System.Version
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.View.get -> Microsoft.Win32.RegistryView
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.AssemblyFoldersFromConfigInfo(string directoryPath, System.Version targetFrameworkVersion) -> void
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.DirectoryPath.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.TargetFrameworkVersion.get -> System.Version
-Microsoft.Build.Utilities.CommandLineBuilder
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(Microsoft.Build.Framework.ITaskItem fileItem) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameIfNotNull(string fileName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(Microsoft.Build.Framework.ITaskItem[] fileItems, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNamesIfNotNull(string[] fileNames, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendFileNameWithQuoting(string fileName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendQuotedTextToBuffer(System.Text.StringBuilder buffer, string unquotedTextToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSpaceIfNotEmpty() -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitch(string switchName) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchIfNotNull(string switchName, string[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, Microsoft.Build.Framework.ITaskItem[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string parameter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendSwitchUnquotedIfNotNull(string switchName, string[] parameters, string delimiter) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendTextUnquoted(string textToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.AppendTextWithQuoting(string textToAppend) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLine.get -> System.Text.StringBuilder
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder() -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.CommandLineBuilder(bool quoteHyphensOnCommandLine, bool useNewLineSeparator) -> void
-Microsoft.Build.Utilities.CommandLineBuilder.Length.get -> int
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness32 = 1 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Bitness64 = 2 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.DotNetFrameworkArchitecture.Current = 0 -> Microsoft.Build.Utilities.DotNetFrameworkArchitecture
-Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnFailure = 3 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.NoActionReturnSuccess = 2 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.UseAlternateToolToExecute = 1 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.HostObjectInitializationStatus.UseHostObjectToExecute = 0 -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-Microsoft.Build.Utilities.Logger
-Microsoft.Build.Utilities.Logger.IsVerbosityAtLeast(Microsoft.Build.Framework.LoggerVerbosity checkVerbosity) -> bool
-Microsoft.Build.Utilities.Logger.Logger() -> void
-Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Allow = 0 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Error = 2 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MultipleVersionSupport.Warning = 1 -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.MuxLogger
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationMetaprojects.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationProfiles.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeEvaluationPropertiesAndItems.set -> void
-Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.get -> bool
-Microsoft.Build.Utilities.MuxLogger.IncludeTaskInputs.set -> void
-Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
-Microsoft.Build.Utilities.MuxLogger.Initialize(Microsoft.Build.Framework.IEventSource eventSource, int maxNodeCount) -> void
-Microsoft.Build.Utilities.MuxLogger.MuxLogger() -> void
-Microsoft.Build.Utilities.MuxLogger.Parameters.get -> string
-Microsoft.Build.Utilities.MuxLogger.Parameters.set -> void
-Microsoft.Build.Utilities.MuxLogger.RegisterLogger(int submissionId, Microsoft.Build.Framework.ILogger logger) -> void
-Microsoft.Build.Utilities.MuxLogger.Shutdown() -> void
-Microsoft.Build.Utilities.MuxLogger.UnregisterLoggers(int submissionId) -> bool
-Microsoft.Build.Utilities.MuxLogger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-Microsoft.Build.Utilities.MuxLogger.Verbosity.set -> void
-Microsoft.Build.Utilities.ProcessorArchitecture
-Microsoft.Build.Utilities.SDKManifest
-Microsoft.Build.Utilities.SDKManifest.AppxLocations.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Utilities.SDKManifest.Attributes
-Microsoft.Build.Utilities.SDKManifest.CopyRedistToSubDirectory.get -> string
-Microsoft.Build.Utilities.SDKManifest.DependsOnSDK.get -> string
-Microsoft.Build.Utilities.SDKManifest.DisplayName.get -> string
-Microsoft.Build.Utilities.SDKManifest.FrameworkIdentities.get -> System.Collections.Generic.IDictionary<string, string>
-Microsoft.Build.Utilities.SDKManifest.FrameworkIdentity.get -> string
-Microsoft.Build.Utilities.SDKManifest.MaxOSVersionTested.get -> string
-Microsoft.Build.Utilities.SDKManifest.MaxPlatformVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MinOSVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MinVSVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.MoreInfo.get -> string
-Microsoft.Build.Utilities.SDKManifest.PlatformIdentity.get -> string
-Microsoft.Build.Utilities.SDKManifest.ProductFamilyName.get -> string
-Microsoft.Build.Utilities.SDKManifest.ReadError.get -> bool
-Microsoft.Build.Utilities.SDKManifest.ReadErrorMessage.get -> string
-Microsoft.Build.Utilities.SDKManifest.SDKManifest(string pathToSdk) -> void
-Microsoft.Build.Utilities.SDKManifest.SDKType.get -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKManifest.SupportedArchitectures.get -> string
-Microsoft.Build.Utilities.SDKManifest.SupportPrefer32Bit.get -> string
-Microsoft.Build.Utilities.SDKManifest.SupportsMultipleVersions.get -> Microsoft.Build.Utilities.MultipleVersionSupport
-Microsoft.Build.Utilities.SDKManifest.TargetPlatform.get -> string
-Microsoft.Build.Utilities.SDKManifest.TargetPlatformMinVersion.get -> string
-Microsoft.Build.Utilities.SDKManifest.TargetPlatformVersion.get -> string
-Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.External = 1 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Framework = 3 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Platform = 2 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.SDKType.Unspecified = 0 -> Microsoft.Build.Utilities.SDKType
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Latest = 9999 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version11 = 0 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version20 = 1 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version30 = 2 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version35 = 3 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version40 = 4 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version45 = 5 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version451 = 6 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version452 = 9 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version46 = 7 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version461 = 8 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version462 = 10 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version47 = 11 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version471 = 12 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version472 = 13 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.Version48 = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.VersionLatest = 14 -> Microsoft.Build.Utilities.TargetDotNetFrameworkVersion
-Microsoft.Build.Utilities.TargetPlatformSDK
-Microsoft.Build.Utilities.TargetPlatformSDK.ContainsPlatform(string targetPlatformIdentifier, string targetPlatformVersion) -> bool
-Microsoft.Build.Utilities.TargetPlatformSDK.DisplayName.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.Equals(Microsoft.Build.Utilities.TargetPlatformSDK other) -> bool
-Microsoft.Build.Utilities.TargetPlatformSDK.MinOSVersion.get -> System.Version
-Microsoft.Build.Utilities.TargetPlatformSDK.MinVSVersion.get -> System.Version
-Microsoft.Build.Utilities.TargetPlatformSDK.Path.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.Path.set -> void
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformSDK(string targetPlatformIdentifier, System.Version targetPlatformVersion, string path) -> void
-Microsoft.Build.Utilities.TargetPlatformSDK.TargetPlatformVersion.get -> System.Version
-Microsoft.Build.Utilities.Task
-Microsoft.Build.Utilities.Task.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.Task.BuildEngine.set -> void
-Microsoft.Build.Utilities.Task.BuildEngine2.get -> Microsoft.Build.Framework.IBuildEngine2
-Microsoft.Build.Utilities.Task.BuildEngine3.get -> Microsoft.Build.Framework.IBuildEngine3
-Microsoft.Build.Utilities.Task.BuildEngine4.get -> Microsoft.Build.Framework.IBuildEngine4
-Microsoft.Build.Utilities.Task.BuildEngine5.get -> Microsoft.Build.Framework.IBuildEngine5
-Microsoft.Build.Utilities.Task.BuildEngine6.get -> Microsoft.Build.Framework.IBuildEngine6
-Microsoft.Build.Utilities.Task.BuildEngine7.get -> Microsoft.Build.Framework.IBuildEngine7
-Microsoft.Build.Utilities.Task.BuildEngine8.get -> Microsoft.Build.Framework.IBuildEngine8
-Microsoft.Build.Utilities.Task.BuildEngine9.get -> Microsoft.Build.Framework.IBuildEngine9
-Microsoft.Build.Utilities.Task.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.Task.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.Task.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Utilities.Task.HostObject.set -> void
-Microsoft.Build.Utilities.Task.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.Task.Task() -> void
-Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.Task.Task(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.Task.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.Task.TaskResources.set -> void
-Microsoft.Build.Utilities.TaskItem
-Microsoft.Build.Utilities.TaskItem.CloneCustomMetadata() -> System.Collections.IDictionary
-Microsoft.Build.Utilities.TaskItem.CopyMetadataTo(Microsoft.Build.Framework.ITaskItem destinationItem) -> void
-Microsoft.Build.Utilities.TaskItem.GetMetadata(string metadataName) -> string
-Microsoft.Build.Utilities.TaskItem.ItemSpec.get -> string
-Microsoft.Build.Utilities.TaskItem.ItemSpec.set -> void
-Microsoft.Build.Utilities.TaskItem.MetadataCount.get -> int
-Microsoft.Build.Utilities.TaskItem.MetadataNames.get -> System.Collections.ICollection
-Microsoft.Build.Utilities.TaskItem.RemoveMetadata(string metadataName) -> void
-Microsoft.Build.Utilities.TaskItem.SetMetadata(string metadataName, string metadataValue) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem() -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(Microsoft.Build.Framework.ITaskItem sourceItem) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec) -> void
-Microsoft.Build.Utilities.TaskItem.TaskItem(string itemSpec, System.Collections.IDictionary itemMetadata) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.TaskLoggingHelper.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.TaskLoggingHelper.ExtractMessageCode(string message, out string messageWithoutCodePrefix) -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.HasLoggedErrors.get -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.IsTaskInputLoggingEnabled.get -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(Microsoft.Build.Framework.MessageImportance importance, string commandLine) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCommandLine(string commandLine) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromException(System.Exception exception, bool showStackTrace, bool showDetail, string file) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, Microsoft.Build.Framework.MessageImportance importance, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(Microsoft.Build.Framework.MessageImportance importance, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessageFromText(string lineOfText, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromFile(string fileName, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogMessagesFromStream(System.IO.TextReader stream, Microsoft.Build.Framework.MessageImportance messageImportance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogsMessagesOfImportance(Microsoft.Build.Framework.MessageImportance importance) -> bool
-Microsoft.Build.Utilities.TaskLoggingHelper.LogTelemetry(string eventName, System.Collections.Generic.IDictionary<string, string> properties) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromException(System.Exception exception, bool showStackTrace) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, params object[] messageArgs) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.IBuildEngine buildEngine, string taskName) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskLoggingHelper(Microsoft.Build.Framework.ITask taskInstance) -> void
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskName.get -> string
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.TaskLoggingHelper.TaskResources.set -> void
-Microsoft.Build.Utilities.ToolLocationHelper
-Microsoft.Build.Utilities.ToolTask
-Microsoft.Build.Utilities.ToolTask.DeleteTempFile(string fileName) -> void
-Microsoft.Build.Utilities.ToolTask.EchoOff.get -> bool
-Microsoft.Build.Utilities.ToolTask.EchoOff.set -> void
-Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.get -> string[]
-Microsoft.Build.Utilities.ToolTask.EnvironmentVariables.set -> void
-Microsoft.Build.Utilities.ToolTask.ExitCode.get -> int
-Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.get -> bool
-Microsoft.Build.Utilities.ToolTask.LogStandardErrorAsError.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.get -> string
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportance.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardErrorImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.get -> string
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportance.set -> void
-Microsoft.Build.Utilities.ToolTask.StandardOutputImportanceToUse.get -> Microsoft.Build.Framework.MessageImportance
-Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.get -> int
-Microsoft.Build.Utilities.ToolTask.TaskProcessTerminationTimeout.set -> void
-Microsoft.Build.Utilities.ToolTask.ToolCanceled.get -> System.Threading.ManualResetEvent
-Microsoft.Build.Utilities.ToolTask.ToolPath.get -> string
-Microsoft.Build.Utilities.ToolTask.ToolPath.set -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask() -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.ToolTask.ToolTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.get -> bool
-Microsoft.Build.Utilities.ToolTask.UseCommandProcessor.set -> void
-Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.get -> string
-Microsoft.Build.Utilities.ToolTask.UseUtf8Encoding.set -> void
-Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.get -> bool
-Microsoft.Build.Utilities.ToolTask.YieldDuringToolExecution.set -> void
-Microsoft.Build.Utilities.TrackedDependencies
-Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version100 = 0 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version110 = 1 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version120 = 2 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version140 = 3 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version150 = 4 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version160 = 5 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.Version170 = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
-Microsoft.Build.Utilities.VisualStudioVersion.VersionLatest = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
-override Microsoft.Build.Utilities.AppDomainIsolatedTask.InitializeLifetimeService() -> object
-override Microsoft.Build.Utilities.CommandLineBuilder.ToString() -> string
-override Microsoft.Build.Utilities.TargetPlatformSDK.Equals(object obj) -> bool
-override Microsoft.Build.Utilities.TargetPlatformSDK.GetHashCode() -> int
-override Microsoft.Build.Utilities.TaskItem.ToString() -> string
-override Microsoft.Build.Utilities.ToolTask.Execute() -> bool
-static Microsoft.Build.Utilities.ProcessorArchitecture.CurrentProcessArchitecture.get -> string
-static Microsoft.Build.Utilities.TaskItem.explicit operator string(Microsoft.Build.Utilities.TaskItem taskItemToCast) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.ClearSDKStaticCache() -> void
-static Microsoft.Build.Utilities.ToolLocationHelper.CurrentToolsVersion.get -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.FilterPlatformExtensionSDKs(System.Version targetPlatformVersion, System.Collections.Generic.IDictionary<string, string> extensionSdks) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.FilterTargetPlatformSdks(System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> targetPlatformSdkList, System.Version osVersion, System.Version vsVersion) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.FindRootFolderWhereAllFilesExist(string possibleRoots, string relativeFilePaths) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersExInfo>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, System.Runtime.Versioning.FrameworkName frameworkName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkInstallKeyValue(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkSdkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkVersionFolderPrefix(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstalls(System.Version minVersion = null, System.Version maxVersion = null, string subFolder = null) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetFoldersInVSInstallsAsString(string minVersionString = null, string maxVersionString = null, string subFolder = null) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetLatestSDKTargetPlatformVersion(string sdkIdentifier, string sdkVersion, string[] sdkRoots) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildTools(string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToBuildToolsFile(string fileName, string toolsVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFramework(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkReferenceAssemblies(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk() -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToDotNetFrameworkSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(string targetFrameworkRootPath, System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToReferenceAssemblies(System.Runtime.Versioning.FrameworkName frameworkName) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToStandardLibraries(string targetFrameworkIdentifier, string targetFrameworkVersion, string targetFrameworkProfile, string platformTarget, string targetFrameworkRootPath, string targetFrameworkFallbackSearchPaths) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToSystemFile(string fileName) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdk(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPathToWindowsSdkFile(string fileName, Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version, Microsoft.Build.Utilities.VisualStudioVersion visualStudioVersion, Microsoft.Build.Utilities.DotNetFrameworkArchitecture architecture) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocation(string sdkMoniker, string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string[] extensionDiskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocations(string[] diskRoots, string[] extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformExtensionSDKLocationsAndVersions(string[] diskRoots, string[] multiPlatformDiskRoots, string registryRoot, string targetPlatformIdentifier, System.Version targetPlatformVersion) -> System.Collections.Generic.IDictionary<string, System.Tuple<string, string>>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformOrFrameworkExtensionSdkReferences(string extensionSdkMoniker, string targetSdkIdentifier, string targetSdkVersion, string diskRoots, string extensionDiskRoots, string registryRoot, string targetPlatformIdentifier, string targetPlatformVersion) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKDisplayName(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKLocation(string targetPlatformIdentifier, System.Version targetPlatformVersion, string[] diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformSDKPropsFileLocation(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetPlatformsForSDK(string sdkIdentifier, System.Version sdkVersion, string[] diskRoots, string registryRoot) -> System.Collections.Generic.IEnumerable<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetProgramFilesReferenceAssemblyRoot() -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKContentFolderPath(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string folderName, string diskRoot = null) -> string
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKDesignTimeFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKRedistFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSDKReferenceFolders(string sdkRoot, string targetConfiguration, string targetArchitecture) -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetSupportedTargetFrameworks() -> System.Collections.Generic.IList<string>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformReferences(string sdkIdentifier, string sdkVersion, string targetPlatformIdentifier, string targetPlatformMinVersion, string targetPlatformVersion, string diskRoots, string registryRoot) -> string[]
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks() -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.GetTargetPlatformSdks(string[] diskRoots, string registryRoot) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
-static Microsoft.Build.Utilities.ToolLocationHelper.HighestVersionOfTargetFrameworkIdentifier(string targetFrameworkRootDirectory, string frameworkIdentifier) -> System.Runtime.Versioning.FrameworkName
-static Microsoft.Build.Utilities.ToolLocationHelper.PathToSystem.get -> string
-static Microsoft.Build.Utilities.TrackedDependencies.ExpandWildcards(Microsoft.Build.Framework.ITaskItem[] expand) -> Microsoft.Build.Framework.ITaskItem[]
-virtual Microsoft.Build.Utilities.CommandLineBuilder.IsQuotingRequired(string parameter) -> bool
-virtual Microsoft.Build.Utilities.CommandLineBuilder.VerifyThrowNoEmbeddedDoubleQuotes(string switchName, string parameter) -> void
-virtual Microsoft.Build.Utilities.Logger.FormatErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs args) -> string
-virtual Microsoft.Build.Utilities.Logger.FormatWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs args) -> string
-virtual Microsoft.Build.Utilities.Logger.Parameters.get -> string
-virtual Microsoft.Build.Utilities.Logger.Parameters.set -> void
-virtual Microsoft.Build.Utilities.Logger.Shutdown() -> void
-virtual Microsoft.Build.Utilities.Logger.Verbosity.get -> Microsoft.Build.Framework.LoggerVerbosity
-virtual Microsoft.Build.Utilities.Logger.Verbosity.set -> void
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatResourceString(string resourceName, params object[] args) -> string
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.FormatString(string unformatted, params object[] args) -> string
-virtual Microsoft.Build.Utilities.TaskLoggingHelper.GetResourceMessage(string resourceName) -> string
-virtual Microsoft.Build.Utilities.ToolTask.AdjustCommandsForOperatingSystem(string input) -> string
-virtual Microsoft.Build.Utilities.ToolTask.CallHostObjectToExecute() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.Cancel() -> void
-virtual Microsoft.Build.Utilities.ToolTask.EnvironmentOverride.get -> System.Collections.Generic.Dictionary<string, string>
-virtual Microsoft.Build.Utilities.ToolTask.ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands) -> int
-virtual Microsoft.Build.Utilities.ToolTask.GenerateCommandLineCommands() -> string
-virtual Microsoft.Build.Utilities.ToolTask.GenerateResponseFileCommands() -> string
-virtual Microsoft.Build.Utilities.ToolTask.GetProcessStartInfo(string pathToTool, string commandLineCommands, string responseFileSwitch) -> System.Diagnostics.ProcessStartInfo
-virtual Microsoft.Build.Utilities.ToolTask.GetResponseFileSwitch(string responseFilePath) -> string
-virtual Microsoft.Build.Utilities.ToolTask.GetWorkingDirectory() -> string
-virtual Microsoft.Build.Utilities.ToolTask.HandleTaskExecutionErrors() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.HasLoggedErrors.get -> bool
-virtual Microsoft.Build.Utilities.ToolTask.InitializeHostObject() -> Microsoft.Build.Utilities.HostObjectInitializationStatus
-virtual Microsoft.Build.Utilities.ToolTask.LogEventsFromTextOutput(string singleLine, Microsoft.Build.Framework.MessageImportance messageImportance) -> void
-virtual Microsoft.Build.Utilities.ToolTask.LogPathToTool(string toolName, string pathToTool) -> void
-virtual Microsoft.Build.Utilities.ToolTask.LogToolCommand(string message) -> void
-virtual Microsoft.Build.Utilities.ToolTask.ProcessStarted() -> void
-virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.ResponseFileEscape(string responseString) -> string
-virtual Microsoft.Build.Utilities.ToolTask.SkipTaskExecution() -> bool
-virtual Microsoft.Build.Utilities.ToolTask.StandardErrorEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.StandardErrorLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-virtual Microsoft.Build.Utilities.ToolTask.StandardOutputEncoding.get -> System.Text.Encoding
-virtual Microsoft.Build.Utilities.ToolTask.StandardOutputLoggingImportance.get -> Microsoft.Build.Framework.MessageImportance
-virtual Microsoft.Build.Utilities.ToolTask.Timeout.get -> int
-virtual Microsoft.Build.Utilities.ToolTask.Timeout.set -> void
-virtual Microsoft.Build.Utilities.ToolTask.ToolExe.get -> string
-virtual Microsoft.Build.Utilities.ToolTask.ToolExe.set -> void
-virtual Microsoft.Build.Utilities.ToolTask.ValidateParameters() -> bool
\ No newline at end of file
diff --git a/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
deleted file mode 100644
index e69de29bb2d..00000000000
diff --git a/src/Utilities/TaskItem.cs b/src/Utilities/TaskItem.cs
index 53f3d588300..edba3b1af42 100644
--- a/src/Utilities/TaskItem.cs
+++ b/src/Utilities/TaskItem.cs
@@ -5,9 +5,8 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
-using System.Security;
 #if FEATURE_SECURITY_PERMISSIONS
-using System.Security.Permissions;
+using System.Security;
 #endif
 
 using Microsoft.Build.Framework;
diff --git a/src/Utilities/ToolLocationHelper.cs b/src/Utilities/ToolLocationHelper.cs
index 8028af19a93..2d20b9f110b 100644
--- a/src/Utilities/ToolLocationHelper.cs
+++ b/src/Utilities/ToolLocationHelper.cs
@@ -105,6 +105,11 @@ public enum TargetDotNetFrameworkVersion
         /// </summary>
         Version48 = 14,
 
+        /// <summary>
+        /// version 4.8.1
+        /// </summary>
+        Version481 = 15,
+
         /// <summary>
         /// The latest version available at the time of major release. This
         /// value should not be updated in minor releases as it could be a
@@ -2047,10 +2052,14 @@ private static Version TargetDotNetFrameworkVersionToSystemVersion(TargetDotNetF
 
                 case TargetDotNetFrameworkVersion.Version472:
                     return FrameworkLocationHelper.dotNetFrameworkVersion472;
+
                 case TargetDotNetFrameworkVersion.Version48:
-                case TargetDotNetFrameworkVersion.Latest: // Latest is a special value to indicate the highest version we know about.
                     return FrameworkLocationHelper.dotNetFrameworkVersion48;
 
+                case TargetDotNetFrameworkVersion.Version481:
+                case TargetDotNetFrameworkVersion.Latest: // Latest is a special value to indicate the highest version we know about.
+                    return FrameworkLocationHelper.dotNetFrameworkVersion481;
+
                 default:
                     ErrorUtilities.ThrowArgument("ToolLocationHelper.UnsupportedFrameworkVersion", version);
                     return null;
diff --git a/src/Utilities/ToolTask.cs b/src/Utilities/ToolTask.cs
index 491fe8d5875..9ed38f4d2d8 100644
--- a/src/Utilities/ToolTask.cs
+++ b/src/Utilities/ToolTask.cs
@@ -551,7 +551,7 @@ private string GetTemporaryResponseFile(string responseFileCommands, out string
                 // have to worry about how long the command-line is going to be
 
                 // May throw IO-related exceptions
-                responseFile = FileUtilities.GetTemporaryFile(".rsp");
+                responseFile = FileUtilities.GetTemporaryFileName(".rsp");
 
                 // Use the encoding specified by the overridable ResponseFileEncoding property
                 using (StreamWriter responseFileStream = FileUtilities.OpenWrite(responseFile, false, ResponseFileEncoding))
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
index 1d59803aa05..2343b93060f 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedFilesHelper.cs
@@ -1,13 +1,13 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 99c1745f803..46495392855 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.Collections.Concurrent;
@@ -11,8 +13,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 2ccbbce8f3b..550f3bc8d35 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
@@ -9,8 +11,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/DependencyTableCache.cs b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
index ac4d674e0a8..d87e3ea9507 100644
--- a/src/Utilities/TrackedDependencies/DependencyTableCache.cs
+++ b/src/Utilities/TrackedDependencies/DependencyTableCache.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections;
 using System.Collections.Generic;
@@ -9,8 +11,6 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/src/Utilities/TrackedDependencies/FileTracker.cs b/src/Utilities/TrackedDependencies/FileTracker.cs
index a6fa201acc7..e2812d295ca 100644
--- a/src/Utilities/TrackedDependencies/FileTracker.cs
+++ b/src/Utilities/TrackedDependencies/FileTracker.cs
@@ -343,7 +343,7 @@ public static string FormatRootingMarker(ITaskItem[] sources, ITaskItem[] output
         /// <returns>The response file path.</returns>
         public static string CreateRootingMarkerResponseFile(string rootMarker)
         {
-            string trackerResponseFile = FileUtilities.GetTemporaryFile(".rsp");
+            string trackerResponseFile = FileUtilities.GetTemporaryFileName(".rsp");
             File.WriteAllText(trackerResponseFile, "/r \"" + rootMarker + "\"", Encoding.Unicode);
 
             return trackerResponseFile;
diff --git a/src/Utilities/TrackedDependencies/FlatTrackingData.cs b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
index 1c6529ac55d..3a3b9d71130 100644
--- a/src/Utilities/TrackedDependencies/FlatTrackingData.cs
+++ b/src/Utilities/TrackedDependencies/FlatTrackingData.cs
@@ -1,6 +1,8 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
+#if FEATURE_FILE_TRACKER
+
 using System;
 using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
@@ -12,8 +14,6 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
-#if FEATURE_FILE_TRACKER
-
 #nullable disable
 
 namespace Microsoft.Build.Utilities
diff --git a/testenvironments.json b/testenvironments.json
new file mode 100644
index 00000000000..86278391870
--- /dev/null
+++ b/testenvironments.json
@@ -0,0 +1,15 @@
+{
+    "version": "1",
+    "environments": [
+      {
+        "name": "WSL-Ubuntu",
+        "type": "wsl",
+        "wslDistribution": "Ubuntu"
+      },
+      {
+        "name": "docker dotnet 7.0",
+        "type": "docker",
+        "dockerImage": "mcr.microsoft.com/dotnet/sdk:7.0"
+      }
+    ]
+}
