diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 11f068342c4..3f53fc8b1e7 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2020,12 +2020,6 @@ private void PerformSchedulingActions(IEnumerable<ScheduleResponse> responses)
 
         internal bool CreateRarNode()
         {
-            // If the _buildParametrs is not set, we are in OutOfProc mode, so continue
-            // Else check if users specified that he want to use multiple nodes, if so use RARaaS
-            if (_buildParameters?.MaxNodeCount == 1)
-                return false;
-
-
             string nodeLocation = _buildParameters?.NodeExeLocation ?? BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
             if (string.IsNullOrEmpty(nodeLocation))
             {
diff --git a/src/Build/BackEnd/Node/RarNode.cs b/src/Build/BackEnd/Node/RarNode.cs
index 2de3b71ee86..2079ee91b8f 100644
--- a/src/Build/BackEnd/Node/RarNode.cs
+++ b/src/Build/BackEnd/Node/RarNode.cs
@@ -42,6 +42,7 @@ public NodeEngineShutdownReason Run(bool nodeReuse, bool lowPriority, out Except
             Handshake handshake = NodeProviderOutOfProc.GetHandshake(enableNodeReuse: nodeReuse,
                                                                      enableLowPriority: lowPriority, specialNode: true);
 
+            Console.WriteLine(pipeName);
             IRarController controller = GetController(pipeName, handshake);
 
             Task<int> rarTask = controller.StartAsync(cts.Token);
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs
index 028bb58ae25..4f3c80cd508 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceAsAService_Tests.cs
@@ -1,5 +1,4 @@
 ï»¿using MessagePack;
-using MessagePack.Resolvers;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Client;
@@ -12,15 +11,10 @@
 using Nerdbank.Streams;
 using Shouldly;
 using System;
-using System.Collections.Generic;
 using System.IO;
-using System.IO.Pipelines;
-using System.IO.Pipes;
 using System.Linq;
 using System.Reflection;
-using System.Text;
 using System.Threading;
-using System.Threading.Tasks;
 using Xunit;
 using Xunit.Abstractions;
 using Task = System.Threading.Tasks.Task;
@@ -37,8 +31,8 @@ public ResolveAssemblyReferenceAsAService_Tests(ITestOutputHelper output) : base
         public void EnsureInputPropertiesMatch()
         {
             string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
-                .Where(p => !p.GetCustomAttributes(typeof(OutputAttribute), inherit: true).Any()).Select(p => $"{p.PropertyType.FullName}.{p.Name}").ToArray();
-            string[] inputProperties = typeof(ResolveAssemblyReferenceTaskInput).GetProperties().Select(p => $"{p.PropertyType.FullName}.{p.Name}").ToArray();
+                .Where(p => !p.GetCustomAttributes(typeof(OutputAttribute), inherit: true).Any()).Select(p => p.Name).ToArray();
+            string[] inputProperties = typeof(ResolveAssemblyReferenceRequest).GetProperties().Select(p => p.Name).ToArray();
 
             foreach (var item in rarInputProperties)
             {
@@ -50,37 +44,38 @@ public void EnsureInputPropertiesMatch()
         public void EnsureOutputPropertiesMatch()
         {
             string[] rarInputProperties = typeof(ResolveAssemblyReference).GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
-                .Where(p => p.GetCustomAttributes(typeof(OutputAttribute), true).Any()).Select(p => $"{p.PropertyType.FullName}.{p.Name}").ToArray();
-            string[] inputProperties = typeof(ResolveAssemblyReferenceTaskOutput).GetProperties().Select(p => $"{p.PropertyType.FullName}.{p.Name}").ToArray();
+                .Where(p => p.GetCustomAttributes(typeof(OutputAttribute), true).Any()).Select(p => p.Name).ToArray();
+            string[] inputProperties = typeof(ResolveAssemblyReferenceResponse).GetProperties().Select(p => p.Name).ToArray();
 
             foreach (var item in rarInputProperties)
             {
                 inputProperties.ShouldContain(item);
             }
         }
+
         [Fact]
         public void TransferredRequestEquals()
         {
-            ITaskItem[] assemblyNames = new TaskItem[]
-            {
-                new TaskItem("DependsOnEverettSystem, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=feedbeadbadcadbe")
-            };
-
-            ResolveAssemblyReference rar = new ResolveAssemblyReference
-            {
-                Assemblies = assemblyNames
-            };
-
             MessagePackSerializerOptions options = MessagePackSerializerOptions.Standard.WithResolver(ResolveAssemblyReferneceResolver.Instance);
+            ResolveAssemblyReferenceRequest request = GetPopulatedObject<ResolveAssemblyReferenceRequest>("test", new[] { "testArr" }, true, new[] { new ReadOnlyTaskItem("test") });
 
-            ResolveAssemblyReferenceRequest request = new ResolveAssemblyReferenceRequest(rar.ResolveAssemblyReferenceInput);
             byte[] data = MessagePackSerializer.Serialize(request, options);
-
             ResolveAssemblyReferenceRequest requestDes = MessagePackSerializer.Deserialize<ResolveAssemblyReferenceRequest>(data, options);
 
             ResolveAssemblyReferenceComparer.CompareInput(request, requestDes).ShouldBeTrue();
         }
 
+        [Fact]
+        public void TransferredResponseEquals()
+        {
+            MessagePackSerializerOptions options = MessagePackSerializerOptions.Standard.WithResolver(ResolveAssemblyReferneceResolver.Instance);
+            ResolveAssemblyReferenceResponse response = GetPopulatedObject<ResolveAssemblyReferenceResponse>("test", new[] { "testArr" }, true, new[] { new ReadOnlyTaskItem("test") });
+
+            byte[] data = MessagePackSerializer.Serialize(response, options);
+            ResolveAssemblyReferenceResponse responseDes = MessagePackSerializer.Deserialize<ResolveAssemblyReferenceResponse>(data, options);
+
+            ResolveAssemblyReferenceComparer.CompareOutput(response, responseDes).ShouldBeTrue();
+        }
 
         [Fact]
         public void TransmitDataTest()
@@ -105,9 +100,8 @@ public void TransmitDataTest()
                 Assemblies = assemblyNames
             };
 
-            ResolveAssemblyReferenceRequest request = new ResolveAssemblyReferenceRequest(rar.ResolveAssemblyReferenceInput);
             ResolveAssemblyReferenceHandler handler = new ResolveAssemblyReferenceHandler();
-            ResolveAssemblyReferenceResult expectedResult = handler.Execute(request);
+            ResolveAssemblyReferenceResult expectedResult = handler.Execute(rar.ResolveAssemblyReferenceInput);
 
             client.Connect();
             ResolveAssemblyReferenceResult result = client.Execute(rar.ResolveAssemblyReferenceInput);
@@ -118,5 +112,49 @@ public void TransmitDataTest()
             serverStream.Dispose();
             clientStream.Dispose();
         }
+
+        private T GetPopulatedObject<T>(string str, string[] strArray, bool boolVal, ReadOnlyTaskItem[] taskItems) where T : new()
+        {
+            int count = 0;
+            T request = new T();
+            Type t = typeof(T);
+            t.GetConstructor(Type.EmptyTypes).Invoke(null);
+            foreach (var prop in t.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
+            {
+                var propType = prop.PropertyType;
+                if (propType == typeof(string))
+                {
+                    prop.SetValue(request, str + count++);
+                }
+                else if (propType == typeof(string[]))
+                {
+                    if (strArray?.Length > 0)
+                    {
+                        strArray[0] += count++;
+                    }
+
+                    prop.SetValue(request, strArray);
+                }
+                else if (propType == typeof(bool))
+                {
+                    prop.SetValue(request, boolVal);
+                }
+                else if (propType == typeof(ReadOnlyTaskItem[]))
+                {
+                    if (taskItems?.Length > 0 && taskItems[0] != null)
+                    {
+                        taskItems[0].ItemSpec += count++;
+                    }
+
+                    prop.SetValue(request, taskItems);
+                }
+                else
+                {
+                    // Fix by adding new if with this type
+                    throw new NotImplementedException($"Invalid type: {propType.FullName}");
+                }
+            }
+            return request;
+        }
     }
 }
diff --git a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
index d1fe413dfbb..39e28a18d59 100644
--- a/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
+++ b/src/Tasks.UnitTests/AssemblyDependency/ResolveAssemblyReferenceTestFixture.cs
@@ -2993,14 +2993,13 @@ public Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenc
 
             internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceRequest input)
             {
-                ResolveAssemblyReferenceTaskInput taskInput = new ResolveAssemblyReferenceTaskInput(input);
                 ResolveAssemblyReferenceBuildEngine buildEngine = new ResolveAssemblyReferenceBuildEngine();
                 ResolveAssemblyReference task = new ResolveAssemblyReference
                 {
                     BuildEngine = buildEngine
                 };
 
-                task.ResolveAssemblyReferenceInput = taskInput;
+                task.ResolveAssemblyReferenceInput = input;
                 bool taskResult = ExecuteRarTask(task);
                 ResolveAssemblyReferenceResult result = new ResolveAssemblyReferenceResult(taskResult, task.ResolveAssemblyReferenceOutput)
                 {
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 4b5954d3d51..5017c54c68a 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -921,15 +921,15 @@ public String DependsOnNETStandard
             private set;
         }
 
-        internal ResolveAssemblyReferenceTaskInput ResolveAssemblyReferenceInput
+        internal ResolveAssemblyReferenceRequest ResolveAssemblyReferenceInput
         {
-            get => new ResolveAssemblyReferenceTaskInput
+            get => new ResolveAssemblyReferenceRequest  
             {
                 AllowedAssemblyExtensions = AllowedAssemblyExtensions,
                 AllowedRelatedFileExtensions = AllowedRelatedFileExtensions,
                 AppConfigFile = AppConfigFile,
-                Assemblies = Assemblies,
-                AssemblyFiles = AssemblyFiles,
+                Assemblies = ReadOnlyTaskItem.ToReadOnlyItems(Assemblies),
+                AssemblyFiles = ReadOnlyTaskItem.ToReadOnlyItems(AssemblyFiles),
                 AutoUnify = AutoUnify,
                 CandidateAssemblyFiles = CandidateAssemblyFiles,
                 CopyLocalDependenciesWhenParentReferenceInGac = CopyLocalDependenciesWhenParentReferenceInGac,
@@ -939,18 +939,18 @@ internal ResolveAssemblyReferenceTaskInput ResolveAssemblyReferenceInput
                 FindRelatedFiles = FindRelatedFiles,
                 FindSatellites = FindSatellites,
                 FindSerializationAssemblies = FindSerializationAssemblies,
-                FullFrameworkAssemblyTables = FullFrameworkAssemblyTables,
+                FullFrameworkAssemblyTables = ReadOnlyTaskItem.ToReadOnlyItems(FullFrameworkAssemblyTables),
                 FullFrameworkFolders = FullFrameworkFolders,
                 FullTargetFrameworkSubsetNames = FullTargetFrameworkSubsetNames,
                 IgnoreDefaultInstalledAssemblySubsetTables = IgnoreDefaultInstalledAssemblySubsetTables,
                 IgnoreDefaultInstalledAssemblyTables = IgnoreDefaultInstalledAssemblyTables,
                 IgnoreTargetFrameworkAttributeVersionMismatch = IgnoreTargetFrameworkAttributeVersionMismatch,
                 IgnoreVersionForFrameworkReferences = IgnoreVersionForFrameworkReferences,
-                InstalledAssemblySubsetTables = InstalledAssemblySubsetTables,
-                InstalledAssemblyTables = InstalledAssemblyTables,
+                InstalledAssemblySubsetTables = ReadOnlyTaskItem.ToReadOnlyItems(InstalledAssemblySubsetTables),
+                InstalledAssemblyTables = ReadOnlyTaskItem.ToReadOnlyItems(InstalledAssemblyTables),
                 LatestTargetFrameworkDirectories = LatestTargetFrameworkDirectories,
                 ProfileName = ProfileName,
-                ResolvedSDKReferences = ResolvedSDKReferences,
+                ResolvedSDKReferences = ReadOnlyTaskItem.ToReadOnlyItems(ResolvedSDKReferences),
                 SearchPaths = SearchPaths,
                 Silent = Silent,
                 StateFile = StateFile,
@@ -965,6 +965,8 @@ internal ResolveAssemblyReferenceTaskInput ResolveAssemblyReferenceInput
                 UnresolveFrameworkAssembliesFromHigherFrameworks = UnresolveFrameworkAssembliesFromHigherFrameworks,
                 UseResolveAssemblyReferenceService = UseResolveAssemblyReferenceService,
                 WarnOrErrorOnTargetArchitectureMismatch = WarnOrErrorOnTargetArchitectureMismatch,
+                AssemblyInformationCacheOutputPath = AssemblyInformationCacheOutputPath,
+                AssemblyInformationCachePaths = ReadOnlyTaskItem.ToReadOnlyItems(AssemblyInformationCachePaths),
                 CurrentPath = Directory.GetCurrentDirectory()
             };
             set
@@ -972,8 +974,8 @@ internal ResolveAssemblyReferenceTaskInput ResolveAssemblyReferenceInput
                 AllowedAssemblyExtensions = value.AllowedAssemblyExtensions;
                 AllowedRelatedFileExtensions = value.AllowedRelatedFileExtensions;
                 AppConfigFile = value.AppConfigFile;
-                Assemblies = value.Assemblies;
-                AssemblyFiles = value.AssemblyFiles;
+                Assemblies = ReadOnlyTaskItem.ToTaskItems(value.Assemblies);
+                AssemblyFiles = ReadOnlyTaskItem.ToTaskItems(value.AssemblyFiles);
                 AutoUnify = value.AutoUnify;
                 CandidateAssemblyFiles = value.CandidateAssemblyFiles;
                 CopyLocalDependenciesWhenParentReferenceInGac = value.CopyLocalDependenciesWhenParentReferenceInGac;
@@ -983,18 +985,18 @@ internal ResolveAssemblyReferenceTaskInput ResolveAssemblyReferenceInput
                 FindRelatedFiles = value.FindRelatedFiles;
                 FindSatellites = value.FindSatellites;
                 FindSerializationAssemblies = value.FindSerializationAssemblies;
-                FullFrameworkAssemblyTables = value.FullFrameworkAssemblyTables;
+                FullFrameworkAssemblyTables = ReadOnlyTaskItem.ToTaskItems(value.FullFrameworkAssemblyTables);
                 FullFrameworkFolders = value.FullFrameworkFolders;
                 FullTargetFrameworkSubsetNames = value.FullTargetFrameworkSubsetNames;
                 IgnoreDefaultInstalledAssemblySubsetTables = value.IgnoreDefaultInstalledAssemblySubsetTables;
                 IgnoreDefaultInstalledAssemblyTables = value.IgnoreDefaultInstalledAssemblyTables;
                 IgnoreTargetFrameworkAttributeVersionMismatch = value.IgnoreTargetFrameworkAttributeVersionMismatch;
                 IgnoreVersionForFrameworkReferences = value.IgnoreVersionForFrameworkReferences;
-                InstalledAssemblySubsetTables = value.InstalledAssemblySubsetTables;
-                InstalledAssemblyTables = value.InstalledAssemblyTables;
+                InstalledAssemblySubsetTables = ReadOnlyTaskItem.ToTaskItems(value.InstalledAssemblySubsetTables);
+                InstalledAssemblyTables = ReadOnlyTaskItem.ToTaskItems(value.InstalledAssemblyTables);
                 LatestTargetFrameworkDirectories = value.LatestTargetFrameworkDirectories;
                 ProfileName = value.ProfileName;
-                ResolvedSDKReferences = value.ResolvedSDKReferences;
+                ResolvedSDKReferences = ReadOnlyTaskItem.ToTaskItems(value.ResolvedSDKReferences);
                 SearchPaths = value.SearchPaths;
                 Silent = value.Silent;
                 StateFile = value.StateFile;
@@ -1009,38 +1011,40 @@ internal ResolveAssemblyReferenceTaskInput ResolveAssemblyReferenceInput
                 UnresolveFrameworkAssembliesFromHigherFrameworks = value.UnresolveFrameworkAssembliesFromHigherFrameworks;
                 UseResolveAssemblyReferenceService = value.UseResolveAssemblyReferenceService;
                 WarnOrErrorOnTargetArchitectureMismatch = value.WarnOrErrorOnTargetArchitectureMismatch;
+                AssemblyInformationCacheOutputPath = value.AssemblyInformationCacheOutputPath;
+                AssemblyInformationCachePaths = ReadOnlyTaskItem.ToTaskItems(value.AssemblyInformationCachePaths);
             }
         }
 
-        internal ResolveAssemblyReferenceTaskOutput ResolveAssemblyReferenceOutput
+        internal ResolveAssemblyReferenceResponse ResolveAssemblyReferenceOutput
         {
-            get => new ResolveAssemblyReferenceTaskOutput
+            get => new ResolveAssemblyReferenceResponse
             {
-                CopyLocalFiles = CopyLocalFiles,
+                CopyLocalFiles = ReadOnlyTaskItem.ToReadOnlyItems(CopyLocalFiles),
                 DependsOnNETStandard = DependsOnNETStandard,
                 DependsOnSystemRuntime = DependsOnSystemRuntime,
-                FilesWritten = FilesWritten,
-                RelatedFiles = RelatedFiles,
-                ResolvedDependencyFiles = ResolvedDependencyFiles,
-                ResolvedFiles = ResolvedFiles,
-                SatelliteFiles = SatelliteFiles,
-                ScatterFiles = ScatterFiles,
-                SerializationAssemblyFiles = SerializationAssemblyFiles,
-                SuggestedRedirects = SuggestedRedirects,
+                FilesWritten = ReadOnlyTaskItem.ToReadOnlyItems(FilesWritten),
+                RelatedFiles = ReadOnlyTaskItem.ToReadOnlyItems(RelatedFiles),
+                ResolvedDependencyFiles = ReadOnlyTaskItem.ToReadOnlyItems(ResolvedDependencyFiles),
+                ResolvedFiles = ReadOnlyTaskItem.ToReadOnlyItems(ResolvedFiles),
+                SatelliteFiles = ReadOnlyTaskItem.ToReadOnlyItems(SatelliteFiles),
+                ScatterFiles = ReadOnlyTaskItem.ToReadOnlyItems(ScatterFiles),
+                SerializationAssemblyFiles = ReadOnlyTaskItem.ToReadOnlyItems(SerializationAssemblyFiles),
+                SuggestedRedirects = ReadOnlyTaskItem.ToReadOnlyItems(SuggestedRedirects),
             };
             set
             {
-                _copyLocalFiles = value.CopyLocalFiles;
+                _copyLocalFiles = ReadOnlyTaskItem.ToTaskItems(value.CopyLocalFiles);
                 DependsOnNETStandard = value.DependsOnNETStandard;
                 DependsOnSystemRuntime = value.DependsOnSystemRuntime;
-                _filesWritten = new List<ITaskItem>(value.FilesWritten);
-                _relatedFiles = value.RelatedFiles;
-                _resolvedDependencyFiles = value.ResolvedDependencyFiles;
-                _resolvedFiles = value.ResolvedFiles;
-                _satelliteFiles = value.SatelliteFiles;
-                _scatterFiles = value.ScatterFiles;
-                _serializationAssemblyFiles = value.SerializationAssemblyFiles;
-                _suggestedRedirects = value.SuggestedRedirects;
+                _filesWritten = new List<ITaskItem>(ReadOnlyTaskItem.ToTaskItems(value.FilesWritten));
+                _relatedFiles = ReadOnlyTaskItem.ToTaskItems(value.RelatedFiles);
+                _resolvedDependencyFiles =  ReadOnlyTaskItem.ToTaskItems(value.ResolvedDependencyFiles);
+                _resolvedFiles =  ReadOnlyTaskItem.ToTaskItems(value.ResolvedFiles);
+                _satelliteFiles =  ReadOnlyTaskItem.ToTaskItems(value.SatelliteFiles);
+                _scatterFiles =  ReadOnlyTaskItem.ToTaskItems(value.ScatterFiles);
+                _serializationAssemblyFiles =  ReadOnlyTaskItem.ToTaskItems(value.SerializationAssemblyFiles);
+                _suggestedRedirects =  ReadOnlyTaskItem.ToTaskItems(value.SuggestedRedirects);
             }
         }
 
@@ -3152,10 +3156,14 @@ public override bool Execute()
                     MSBuildEventSource.Log.ResolveAssemblyReferenceServiceRequestStart();
                     ResolveAssemblyReferenceResult result = client.Execute(ResolveAssemblyReferenceInput);
                     MSBuildEventSource.Log.ResolveAssemblyReferenceServiceRequestStop();
-                    ResolveAssemblyReferenceOutput = result.Output;
+                    ResolveAssemblyReferenceOutput = result.Response;
                     LogEvents(result.BuildEvents);
                     return result.TaskResult;
                 }
+                else
+                {
+                    ErrorUtilities.ThrowInternalError(UseResolveAssemblyReferenceService.ToString());
+                }
             }
 
             return Execute
@@ -3215,7 +3223,7 @@ private void LogEvents(IEnumerable<BuildEventArgs> buildEventArgs)
         /// </summary>
         /// <param name="input">Required input to the task</param>
         /// <returns>If task was executed successfully</returns>
-        internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceTaskInput input)
+        internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceRequest input)
         {
             ErrorUtilities.VerifyThrowArgumentNull(input, nameof(input));
 
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index 9bf2b418821..b7a615a4bd5 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -354,13 +354,11 @@
     <Compile Include="ResolveAssemblyReferences\Contract\ReadOnlyTaskItem.cs" />
     <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceRequest.cs" />
     <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceResponse.cs" />
-    <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceTaskInput.cs" />
-    <Compile Include="ResolveAssemblyReferences\Contract\ResolveAssemblyReferenceTaskOutput.cs" />
     <Compile Include="ResolveAssemblyReferences\Formatters\BuildEventArgsFormatter.cs" />
     <Compile Include="ResolveAssemblyReferences\Formatters\ReadOnlyTaskItemFormatter.cs" />
-    <Compile Include="ResolveAssemblyReferences\Formatters\ResolveAssemblyReferenceRequestFormatter.cs" />
-    <Compile Include="ResolveAssemblyReferences\Formatters\ResolveAssemblyReferenceResponseFormatter.cs" />
-    <Compile Include="ResolveAssemblyReferences\Formatters\ResolveAssemblyReferenceResultFormatter.cs" />
+    <Compile Include="ResolveAssemblyReferences\Formatters\RequestFormatter.cs" />
+    <Compile Include="ResolveAssemblyReferences\Formatters\ResponseFormatter.cs" />
+    <Compile Include="ResolveAssemblyReferences\Formatters\ResultFormatter.cs" />
     <Compile Include="ResolveAssemblyReferences\ResolveAssemblyReferneceResolver.cs" />
     <Compile Include="ResolveAssemblyReferences\RpcUtils.cs" />
     <Compile Include="ResolveAssemblyReferences\Server\RarController.cs" />
@@ -368,7 +366,6 @@
     <Compile Include="ResolveAssemblyReferences\Services\ResolveAssemblyReferenceComparer.cs" />
     <Compile Include="ResolveAssemblyReferences\Server\ServerMutex.cs" />
     <Compile Include="ResolveAssemblyReferences\Services\ResolveAssemblyReferenceHandler.cs" />
-    <Compile Include="ResolveAssemblyReferences\Services\ResolveAssemblyReferenceCacheHandler.cs" />
     <Compile Include="ResolveComReference.cs" />
     <Compile Include="BuildCacheDisposeWrapper.cs" />
     <Compile Include="DownloadFile.cs" />
diff --git a/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs b/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs
index 4d86fe23397..a9d7ec70fb0 100644
--- a/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Client/RarClient.cs
@@ -33,7 +33,7 @@ internal bool Connect(int timeout)
                 return true;
 
             string pipeName = _rarBuildEngine.GetRarPipeName();
-
+              
             MSBuildEventSource.Log.ResolveAssemblyReferenceNodeConnectStart();
             Stream stream = _rarBuildEngine.GetRarClientStream(pipeName, timeout);
             MSBuildEventSource.Log.ResolveAssemblyReferenceNodeConnectStop();
@@ -50,10 +50,8 @@ internal bool CreateNode()
             return _rarBuildEngine.CreateRarNode();
         }
 
-        internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceTaskInput input)
+        internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceRequest request)
         {
-            ResolveAssemblyReferenceRequest request = new ResolveAssemblyReferenceRequest(input);
-
             var client = GetRpcClient();
             client.StartListening();
             // TODO: Find out if there is any possibility of awaiting it.
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs
index d75d5642964..77481920f82 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ReadOnlyTaskItem.cs
@@ -23,10 +23,34 @@ public ReadOnlyTaskItem(string itemSpec)
         public ReadOnlyTaskItem(string itemSpec, IDictionary metadata)
         {
             ItemSpec = itemSpec;
-            MetadataNameToValue = new Dictionary<string, string>((IDictionary<string, string>)metadata);
+
+            if (metadata is Dictionary<string, string> metadataNameToValue)
+            {
+                MetadataNameToValue = metadataNameToValue;
+            }
+            else if (metadata is IDictionary<string, string> metadataByInterface)
+            {
+                MetadataNameToValue = new Dictionary<string, string>(metadataByInterface);
+            }
+            else
+            {
+                if (metadata.Count > 0)
+                {
+                    MetadataNameToValue = new Dictionary<string, string>();
+
+                    foreach (DictionaryEntry singleMetadata in metadata)
+                    {
+                        string key = (string)singleMetadata.Key;
+                        if (key != null)
+                        {
+                            MetadataNameToValue[key] = (string)singleMetadata.Value ?? string.Empty;
+                        }
+                    }
+                }
+            }
         }
 
-        internal static ReadOnlyTaskItem[] CreateArray(ITaskItem[] items)
+        internal static ReadOnlyTaskItem[] ToReadOnlyItems(ITaskItem[] items)
         {
             if (items == null)
                 return null;
@@ -44,7 +68,7 @@ internal static ReadOnlyTaskItem[] CreateArray(ITaskItem[] items)
             return readOnlyTaskItems;
         }
 
-        internal static ITaskItem[] ToTaskItem(ReadOnlyTaskItem[] readOnlyTaskItems)
+        internal static ITaskItem[] ToTaskItems(ReadOnlyTaskItem[] readOnlyTaskItems)
         {
             if (readOnlyTaskItems == null)
                 return null;
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
index e82ec64fb9d..148218cf76c 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceRequest.cs
@@ -1,58 +1,12 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System.IO;
-
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
 {
     internal sealed class ResolveAssemblyReferenceRequest
     {
         public ResolveAssemblyReferenceRequest() { }
-        internal ResolveAssemblyReferenceRequest(ResolveAssemblyReferenceTaskInput input)
-        {
-            AllowedAssemblyExtensions = input.AllowedAssemblyExtensions;
-            AllowedRelatedFileExtensions = input.AllowedRelatedFileExtensions;
-            AppConfigFile = input.AppConfigFile;
-            Assemblies = ReadOnlyTaskItem.CreateArray(input.Assemblies);
-            AssemblyFiles = ReadOnlyTaskItem.CreateArray(input.AssemblyFiles);
-            AutoUnify = input.AutoUnify;
-            CandidateAssemblyFiles = input.CandidateAssemblyFiles;
-            CopyLocalDependenciesWhenParentReferenceInGac = input.CopyLocalDependenciesWhenParentReferenceInGac;
-            DoNotCopyLocalIfInGac = input.DoNotCopyLocalIfInGac;
-            FindDependencies = input.FindDependencies;
-            FindDependenciesOfExternallyResolvedReferences = input.FindDependenciesOfExternallyResolvedReferences;
-            FindRelatedFiles = input.FindRelatedFiles;
-            FindSatellites = input.FindSatellites;
-            FindSerializationAssemblies = input.FindSerializationAssemblies;
-            FullFrameworkAssemblyTables = ReadOnlyTaskItem.CreateArray(input.FullFrameworkAssemblyTables);
-            FullFrameworkFolders = input.FullFrameworkFolders;
-            FullTargetFrameworkSubsetNames = input.FullTargetFrameworkSubsetNames;
-            IgnoreDefaultInstalledAssemblySubsetTables = input.IgnoreDefaultInstalledAssemblySubsetTables;
-            IgnoreDefaultInstalledAssemblyTables = input.IgnoreDefaultInstalledAssemblyTables;
-            IgnoreTargetFrameworkAttributeVersionMismatch = input.IgnoreTargetFrameworkAttributeVersionMismatch;
-            IgnoreVersionForFrameworkReferences = input.IgnoreVersionForFrameworkReferences;
-            InstalledAssemblySubsetTables = ReadOnlyTaskItem.CreateArray(input.InstalledAssemblySubsetTables);
-            InstalledAssemblyTables = ReadOnlyTaskItem.CreateArray(input.InstalledAssemblyTables);
-            LatestTargetFrameworkDirectories = input.LatestTargetFrameworkDirectories;
-            ProfileName = input.ProfileName;
-            ResolvedSDKReferences = ReadOnlyTaskItem.CreateArray(input.ResolvedSDKReferences);
-            SearchPaths = input.SearchPaths;
-            Silent = input.Silent;
-            StateFile = input.StateFile == null ? input.StateFile : Path.GetFullPath(input.StateFile);
-            SupportsBindingRedirectGeneration = input.SupportsBindingRedirectGeneration;
-            TargetedRuntimeVersion = input.TargetedRuntimeVersion;
-            TargetFrameworkDirectories = input.TargetFrameworkDirectories;
-            TargetFrameworkMoniker = input.TargetFrameworkMoniker;
-            TargetFrameworkMonikerDisplayName = input.TargetFrameworkMonikerDisplayName;
-            TargetFrameworkSubsets = input.TargetFrameworkSubsets;
-            TargetFrameworkVersion = input.TargetFrameworkVersion;
-            TargetProcessorArchitecture = input.TargetProcessorArchitecture;
-            UnresolveFrameworkAssembliesFromHigherFrameworks = input.UnresolveFrameworkAssembliesFromHigherFrameworks;
-            UseResolveAssemblyReferenceService = input.UseResolveAssemblyReferenceService;
-            WarnOrErrorOnTargetArchitectureMismatch = input.WarnOrErrorOnTargetArchitectureMismatch;
-            CurrentPath = input.CurrentPath;
-        }
-
+        
         public string[] AllowedAssemblyExtensions { get; set; }
 
         public string[] AllowedRelatedFileExtensions { get; set; }
@@ -134,5 +88,9 @@ internal ResolveAssemblyReferenceRequest(ResolveAssemblyReferenceTaskInput input
         public string WarnOrErrorOnTargetArchitectureMismatch { get; set; }
 
         public string CurrentPath { get; set; }
+
+        public string AssemblyInformationCacheOutputPath { get; set; }
+
+        public ReadOnlyTaskItem[] AssemblyInformationCachePaths { get; set; }
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
index ddf90a648ea..64f369864b0 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResponse.cs
@@ -9,21 +9,6 @@ public ResolveAssemblyReferenceResponse()
         {
         }
 
-        internal ResolveAssemblyReferenceResponse(ResolveAssemblyReferenceTaskOutput output)
-        {
-            CopyLocalFiles = ReadOnlyTaskItem.CreateArray(output.CopyLocalFiles);
-            DependsOnNETStandard = output.DependsOnNETStandard;
-            DependsOnSystemRuntime = output.DependsOnSystemRuntime;
-            FilesWritten = ReadOnlyTaskItem.CreateArray(output.FilesWritten);
-            RelatedFiles = ReadOnlyTaskItem.CreateArray(output.RelatedFiles);
-            ResolvedDependencyFiles = ReadOnlyTaskItem.CreateArray(output.ResolvedDependencyFiles);
-            ResolvedFiles = ReadOnlyTaskItem.CreateArray(output.ResolvedFiles);
-            SatelliteFiles = ReadOnlyTaskItem.CreateArray(output.SatelliteFiles);
-            ScatterFiles = ReadOnlyTaskItem.CreateArray(output.ScatterFiles);
-            SerializationAssemblyFiles = ReadOnlyTaskItem.CreateArray(output.SerializationAssemblyFiles);
-            SuggestedRedirects = ReadOnlyTaskItem.CreateArray(output.SuggestedRedirects);
-        }
-
         public ReadOnlyTaskItem[] CopyLocalFiles { get; set; }
 
         public string DependsOnNETStandard { get; set; }
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs
index 565f4f83dd7..5a5c62c0ca8 100644
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceResult.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections.Generic;
-using MessagePack;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
@@ -13,10 +12,10 @@ public ResolveAssemblyReferenceResult()
         {
         }
 
-        internal ResolveAssemblyReferenceResult(bool taskResult, ResolveAssemblyReferenceTaskOutput output)
+        internal ResolveAssemblyReferenceResult(bool taskResult, ResolveAssemblyReferenceResponse response)
         {
             TaskResult = taskResult;
-            Response = new ResolveAssemblyReferenceResponse(output);
+            Response = response;
         }
 
         public bool TaskResult { get; set; }
@@ -24,7 +23,5 @@ internal ResolveAssemblyReferenceResult(bool taskResult, ResolveAssemblyReferenc
         public ResolveAssemblyReferenceResponse Response { get; set; }
 
         public List<BuildEventArgs> BuildEvents { get; set; }
-
-        internal ResolveAssemblyReferenceTaskOutput Output => new ResolveAssemblyReferenceTaskOutput(Response);
     }
 }
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskInput.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskInput.cs
deleted file mode 100644
index 4c89b42a5b3..00000000000
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskInput.cs
+++ /dev/null
@@ -1,140 +0,0 @@
-ï»¿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
-{
-    internal class ResolveAssemblyReferenceTaskInput
-    {
-        public ResolveAssemblyReferenceTaskInput()
-        {
-        }
-
-        public ResolveAssemblyReferenceTaskInput(ResolveAssemblyReferenceRequest request)
-        {
-            AllowedAssemblyExtensions = request.AllowedAssemblyExtensions;
-            AllowedRelatedFileExtensions = request.AllowedRelatedFileExtensions;
-            AppConfigFile = request.AppConfigFile;
-            Assemblies = ReadOnlyTaskItem.ToTaskItem(request.Assemblies);
-            AssemblyFiles = ReadOnlyTaskItem.ToTaskItem(request.AssemblyFiles);
-            AutoUnify = request.AutoUnify;
-            CandidateAssemblyFiles = request.CandidateAssemblyFiles;
-            CopyLocalDependenciesWhenParentReferenceInGac = request.CopyLocalDependenciesWhenParentReferenceInGac;
-            DoNotCopyLocalIfInGac = request.DoNotCopyLocalIfInGac;
-            FindDependencies = request.FindDependencies;
-            FindDependenciesOfExternallyResolvedReferences = request.FindDependenciesOfExternallyResolvedReferences;
-            FindRelatedFiles = request.FindRelatedFiles;
-            FindSatellites = request.FindSatellites;
-            FindSerializationAssemblies = request.FindSerializationAssemblies;
-            FullFrameworkAssemblyTables = ReadOnlyTaskItem.ToTaskItem(request.FullFrameworkAssemblyTables);
-            FullFrameworkFolders = request.FullFrameworkFolders;
-            FullTargetFrameworkSubsetNames = request.FullTargetFrameworkSubsetNames;
-            IgnoreDefaultInstalledAssemblySubsetTables = request.IgnoreDefaultInstalledAssemblySubsetTables;
-            IgnoreDefaultInstalledAssemblyTables = request.IgnoreDefaultInstalledAssemblyTables;
-            IgnoreTargetFrameworkAttributeVersionMismatch = request.IgnoreTargetFrameworkAttributeVersionMismatch;
-            IgnoreVersionForFrameworkReferences = request.IgnoreVersionForFrameworkReferences;
-            InstalledAssemblySubsetTables = ReadOnlyTaskItem.ToTaskItem(request.InstalledAssemblySubsetTables);
-            InstalledAssemblyTables = ReadOnlyTaskItem.ToTaskItem(request.InstalledAssemblyTables);
-            LatestTargetFrameworkDirectories = request.LatestTargetFrameworkDirectories;
-            ProfileName = request.ProfileName;
-            ResolvedSDKReferences = ReadOnlyTaskItem.ToTaskItem(request.ResolvedSDKReferences);
-            SearchPaths = request.SearchPaths;
-            Silent = request.Silent;
-            StateFile = request.StateFile;
-            SupportsBindingRedirectGeneration = request.SupportsBindingRedirectGeneration;
-            TargetedRuntimeVersion = request.TargetedRuntimeVersion;
-            TargetFrameworkDirectories = request.TargetFrameworkDirectories;
-            TargetFrameworkMoniker = request.TargetFrameworkMoniker;
-            TargetFrameworkMonikerDisplayName = request.TargetFrameworkMonikerDisplayName;
-            TargetFrameworkSubsets = request.TargetFrameworkSubsets;
-            TargetFrameworkVersion = request.TargetFrameworkVersion;
-            TargetProcessorArchitecture = request.TargetProcessorArchitecture;
-            UnresolveFrameworkAssembliesFromHigherFrameworks = request.UnresolveFrameworkAssembliesFromHigherFrameworks;
-            UseResolveAssemblyReferenceService = request.UseResolveAssemblyReferenceService;
-            WarnOrErrorOnTargetArchitectureMismatch = request.WarnOrErrorOnTargetArchitectureMismatch;
-            CurrentPath = request.CurrentPath;
-        }
-
-        public string[] AllowedAssemblyExtensions { get; set; }
-
-        public string[] AllowedRelatedFileExtensions { get; set; }
-
-        public string AppConfigFile { get; set; }
-
-        public ITaskItem[] Assemblies { get; set; }
-
-        public ITaskItem[] AssemblyFiles { get; set; }
-
-        public bool AutoUnify { get; set; }
-
-        public string[] CandidateAssemblyFiles { get; set; }
-
-        public bool CopyLocalDependenciesWhenParentReferenceInGac { get; set; }
-
-        public bool DoNotCopyLocalIfInGac { get; set; }
-
-        public bool FindDependencies { get; set; }
-
-        public bool FindDependenciesOfExternallyResolvedReferences { get; set; }
-
-        public bool FindRelatedFiles { get; set; }
-
-        public bool FindSatellites { get; set; }
-
-        public bool FindSerializationAssemblies { get; set; }
-
-        public ITaskItem[] FullFrameworkAssemblyTables { get; set; }
-
-        public string[] FullFrameworkFolders { get; set; }
-
-        public string[] FullTargetFrameworkSubsetNames { get; set; }
-
-        public bool IgnoreDefaultInstalledAssemblySubsetTables { get; set; }
-
-        public bool IgnoreDefaultInstalledAssemblyTables { get; set; }
-
-        public bool IgnoreTargetFrameworkAttributeVersionMismatch { get; set; }
-
-        public bool IgnoreVersionForFrameworkReferences { get; set; }
-
-        public ITaskItem[] InstalledAssemblySubsetTables { get; set; }
-
-        public ITaskItem[] InstalledAssemblyTables { get; set; }
-
-        public string[] LatestTargetFrameworkDirectories { get; set; }
-
-        public string ProfileName { get; set; }
-
-        public ITaskItem[] ResolvedSDKReferences { get; set; }
-
-        public string[] SearchPaths { get; set; }
-
-        public bool Silent { get; set; }
-
-        public string StateFile { get; set; }
-
-        public bool SupportsBindingRedirectGeneration { get; set; }
-
-        public string TargetedRuntimeVersion { get; set; }
-
-        public string[] TargetFrameworkDirectories { get; set; }
-
-        public string TargetFrameworkMoniker { get; set; }
-
-        public string TargetFrameworkMonikerDisplayName { get; set; }
-
-        public string[] TargetFrameworkSubsets { get; set; }
-
-        public string TargetFrameworkVersion { get; set; }
-
-        public string TargetProcessorArchitecture { get; set; }
-
-        public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get; set; }
-
-        public bool UseResolveAssemblyReferenceService { get; set; }
-
-        public string WarnOrErrorOnTargetArchitectureMismatch { get; set; }
-        public string CurrentPath { get; set; }
-    }
-}
diff --git a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskOutput.cs b/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskOutput.cs
deleted file mode 100644
index 95267d464c3..00000000000
--- a/src/Tasks/ResolveAssemblyReferences/Contract/ResolveAssemblyReferenceTaskOutput.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-ï»¿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using Microsoft.Build.Framework;
-
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract
-{
-    internal sealed class ResolveAssemblyReferenceTaskOutput
-    {
-        public ResolveAssemblyReferenceTaskOutput()
-        {
-        }
-
-        public ResolveAssemblyReferenceTaskOutput(ResolveAssemblyReferenceResponse response)
-        {
-            CopyLocalFiles = ReadOnlyTaskItem.ToTaskItem(response.CopyLocalFiles);
-            DependsOnNETStandard = response.DependsOnNETStandard;
-            DependsOnSystemRuntime = response.DependsOnSystemRuntime;
-            FilesWritten = ReadOnlyTaskItem.ToTaskItem(response.FilesWritten);
-            RelatedFiles = ReadOnlyTaskItem.ToTaskItem(response.RelatedFiles);
-            ResolvedDependencyFiles = ReadOnlyTaskItem.ToTaskItem(response.ResolvedDependencyFiles);
-            ResolvedFiles = ReadOnlyTaskItem.ToTaskItem(response.ResolvedFiles);
-            SatelliteFiles = ReadOnlyTaskItem.ToTaskItem(response.SatelliteFiles);
-            ScatterFiles = ReadOnlyTaskItem.ToTaskItem(response.ScatterFiles);
-            SerializationAssemblyFiles = ReadOnlyTaskItem.ToTaskItem(response.SerializationAssemblyFiles);
-            SuggestedRedirects = ReadOnlyTaskItem.ToTaskItem(response.SuggestedRedirects);
-        }
-
-        public ITaskItem[] CopyLocalFiles { get; set; }
-
-        public string DependsOnNETStandard { get; set; }
-
-        public string DependsOnSystemRuntime { get; set; }
-
-        public ITaskItem[] FilesWritten { get; set; }
-
-        public ITaskItem[] RelatedFiles { get; set; }
-
-        public ITaskItem[] ResolvedDependencyFiles { get; set; }
-
-        public ITaskItem[] ResolvedFiles { get; set; }
-
-        public ITaskItem[] SatelliteFiles { get; set; }
-
-        public ITaskItem[] ScatterFiles { get; set; }
-
-        public ITaskItem[] SerializationAssemblyFiles { get; set; }
-
-        public ITaskItem[] SuggestedRedirects { get; set; }
-    }
-}
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs
index 60af623b2dd..049208e0619 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ReadOnlyTaskItemFormatter.cs
@@ -57,7 +57,6 @@ public ReadOnlyTaskItem Deserialize(ref MessagePackReader reader, MessagePackSer
 
             ReadOnlyTaskItem result = new ReadOnlyTaskItem(itemSpec)
             {
-                ItemSpec = itemSpec,
                 MetadataNameToValue = metadataNameToValue
             };
             reader.Depth--;
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/RequestFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/RequestFormatter.cs
new file mode 100644
index 00000000000..d25304f64cc
--- /dev/null
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/RequestFormatter.cs
@@ -0,0 +1,224 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using MessagePack;
+using MessagePack.Formatters;
+using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
+
+namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
+{
+    internal sealed class RequestFormatter : IMessagePackFormatter<ResolveAssemblyReferenceRequest>
+    {
+        public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceRequest value, MessagePackSerializerOptions options)
+        {
+            if (value == null)
+            {
+                writer.WriteNil();
+                return;
+            }
+
+            IFormatterResolver formatterResolver = options.Resolver;
+            writer.WriteArrayHeader(43);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.AllowedAssemblyExtensions, options);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.AllowedRelatedFileExtensions, options);
+            writer.Write(value.AppConfigFile);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.Assemblies, options);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.AssemblyFiles, options);
+            writer.Write(value.AutoUnify);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.CandidateAssemblyFiles, options);
+            writer.Write(value.CopyLocalDependenciesWhenParentReferenceInGac);
+            writer.Write(value.DoNotCopyLocalIfInGac);
+            writer.Write(value.FindDependencies);
+            writer.Write(value.FindDependenciesOfExternallyResolvedReferences);
+            writer.Write(value.FindRelatedFiles);
+            writer.Write(value.FindSatellites);
+            writer.Write(value.FindSerializationAssemblies);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.FullFrameworkAssemblyTables, options);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.FullFrameworkFolders, options);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.FullTargetFrameworkSubsetNames, options);
+            writer.Write(value.IgnoreDefaultInstalledAssemblySubsetTables);
+            writer.Write(value.IgnoreDefaultInstalledAssemblyTables);
+            writer.Write(value.IgnoreTargetFrameworkAttributeVersionMismatch);
+            writer.Write(value.IgnoreVersionForFrameworkReferences);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.InstalledAssemblySubsetTables, options);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.InstalledAssemblyTables, options);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.LatestTargetFrameworkDirectories, options);
+            writer.Write(value.ProfileName);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.ResolvedSDKReferences, options);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.SearchPaths, options);
+            writer.Write(value.Silent);
+            writer.Write(value.StateFile);
+            writer.Write(value.SupportsBindingRedirectGeneration);
+            writer.Write(value.TargetedRuntimeVersion);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.TargetFrameworkDirectories, options);
+            writer.Write(value.TargetFrameworkMoniker);
+            writer.Write(value.TargetFrameworkMonikerDisplayName);
+            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.TargetFrameworkSubsets, options);
+            writer.Write(value.TargetFrameworkVersion);
+            writer.Write(value.TargetProcessorArchitecture);
+            writer.Write(value.UnresolveFrameworkAssembliesFromHigherFrameworks);
+            writer.Write(value.UseResolveAssemblyReferenceService);
+            writer.Write(value.WarnOrErrorOnTargetArchitectureMismatch);
+            writer.Write(value.CurrentPath);
+            writer.Write(value.AssemblyInformationCacheOutputPath);
+            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.AssemblyInformationCachePaths, options);
+        }
+
+        public ResolveAssemblyReferenceRequest Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
+        {
+            if (reader.TryReadNil())
+            {
+                return null;
+            }
+
+            options.Security.DepthStep(ref reader);
+            IFormatterResolver formatterResolver = options.Resolver;
+            int length = reader.ReadArrayHeader();
+            ResolveAssemblyReferenceRequest result = new ResolveAssemblyReferenceRequest();
+
+            for (int i = 0; i < length; i++)
+            {
+                int key = i;
+
+                switch (key)
+                {
+                    case 0:
+                        result.AllowedAssemblyExtensions = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 1:
+                        result.AllowedRelatedFileExtensions = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 2:
+                        result.AppConfigFile = reader.ReadString();
+                        break;
+                    case 3:
+                        result.Assemblies = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 4:
+                        result.AssemblyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 5:
+                        result.AutoUnify = reader.ReadBoolean();
+                        break;
+                    case 6:
+                        result.CandidateAssemblyFiles = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 7:
+                        result.CopyLocalDependenciesWhenParentReferenceInGac = reader.ReadBoolean();
+                        break;
+                    case 8:
+                        result.DoNotCopyLocalIfInGac = reader.ReadBoolean();
+                        break;
+                    case 9:
+                        result.FindDependencies = reader.ReadBoolean();
+                        break;
+                    case 10:
+                        result.FindDependenciesOfExternallyResolvedReferences = reader.ReadBoolean();
+                        break;
+                    case 11:
+                        result.FindRelatedFiles = reader.ReadBoolean();
+                        break;
+                    case 12:
+                        result.FindSatellites = reader.ReadBoolean();
+                        break;
+                    case 13:
+                        result.FindSerializationAssemblies = reader.ReadBoolean();
+                        break;
+                    case 14:
+                        result.FullFrameworkAssemblyTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 15:
+                        result.FullFrameworkFolders = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 16:
+                        result.FullTargetFrameworkSubsetNames = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 17:
+                        result.IgnoreDefaultInstalledAssemblySubsetTables = reader.ReadBoolean();
+                        break;
+                    case 18:
+                        result.IgnoreDefaultInstalledAssemblyTables = reader.ReadBoolean();
+                        break;
+                    case 19:
+                        result.IgnoreTargetFrameworkAttributeVersionMismatch = reader.ReadBoolean();
+                        break;
+                    case 20:
+                        result.IgnoreVersionForFrameworkReferences = reader.ReadBoolean();
+                        break;
+                    case 21:
+                        result.InstalledAssemblySubsetTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 22:
+                        result.InstalledAssemblyTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 23:
+                        result.LatestTargetFrameworkDirectories = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 24:
+                        result.ProfileName = reader.ReadString();
+                        break;
+                    case 25:
+                        result.ResolvedSDKReferences = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    case 26:
+                        result.SearchPaths = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 27:
+                        result.Silent = reader.ReadBoolean();
+                        break;
+                    case 28:
+                        result.StateFile = reader.ReadString();
+                        break;
+                    case 29:
+                        result.SupportsBindingRedirectGeneration = reader.ReadBoolean();
+                        break;
+                    case 30:
+                        result.TargetedRuntimeVersion = reader.ReadString();
+                        break;
+                    case 31:
+                        result.TargetFrameworkDirectories = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 32:
+                        result.TargetFrameworkMoniker = reader.ReadString();
+                        break;
+                    case 33:
+                        result.TargetFrameworkMonikerDisplayName = reader.ReadString();
+                        break;
+                    case 34:
+                        result.TargetFrameworkSubsets = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
+                        break;
+                    case 35:
+                        result.TargetFrameworkVersion = reader.ReadString();
+                        break;
+                    case 36:
+                        result.TargetProcessorArchitecture = reader.ReadString();
+                        break;
+                    case 37:
+                        result.UnresolveFrameworkAssembliesFromHigherFrameworks = reader.ReadBoolean();
+                        break;
+                    case 38:
+                        result.UseResolveAssemblyReferenceService = reader.ReadBoolean();
+                        break;
+                    case 39:
+                        result.WarnOrErrorOnTargetArchitectureMismatch = reader.ReadString();
+                        break;
+                    case 40:
+                        result.CurrentPath = reader.ReadString();
+                        break;
+                    case 41:
+                        result.AssemblyInformationCacheOutputPath = reader.ReadString();
+                        break;
+                    case 42:
+                        result.AssemblyInformationCachePaths = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        break;
+                    default:
+                        reader.Skip();
+                        break;
+                }
+            }
+
+            reader.Depth--;
+            return result;
+        }
+    }
+}
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceRequestFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceRequestFormatter.cs
deleted file mode 100644
index d2b02825252..00000000000
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceRequestFormatter.cs
+++ /dev/null
@@ -1,300 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using MessagePack;
-using MessagePack.Formatters;
-using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
-
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
-{
-    internal sealed class ResolveAssemblyReferenceRequestFormatter : IMessagePackFormatter<ResolveAssemblyReferenceRequest>
-    {
-        public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceRequest value, MessagePackSerializerOptions options)
-        {
-            if (value == null)
-            {
-                writer.WriteNil();
-                return;
-            }
-
-            IFormatterResolver formatterResolver = options.Resolver;
-            writer.WriteArrayHeader(41);
-            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.AllowedAssemblyExtensions, options);
-            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.AllowedRelatedFileExtensions, options);
-            writer.Write(value.AppConfigFile);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.Assemblies, options);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.AssemblyFiles, options);
-            writer.Write(value.AutoUnify);
-            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.CandidateAssemblyFiles, options);
-            writer.Write(value.CopyLocalDependenciesWhenParentReferenceInGac);
-            writer.Write(value.DoNotCopyLocalIfInGac);
-            writer.Write(value.FindDependencies);
-            writer.Write(value.FindDependenciesOfExternallyResolvedReferences);
-            writer.Write(value.FindRelatedFiles);
-            writer.Write(value.FindSatellites);
-            writer.Write(value.FindSerializationAssemblies);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.FullFrameworkAssemblyTables, options);
-            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.FullFrameworkFolders, options);
-            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.FullTargetFrameworkSubsetNames, options);
-            writer.Write(value.IgnoreDefaultInstalledAssemblySubsetTables);
-            writer.Write(value.IgnoreDefaultInstalledAssemblyTables);
-            writer.Write(value.IgnoreTargetFrameworkAttributeVersionMismatch);
-            writer.Write(value.IgnoreVersionForFrameworkReferences);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.InstalledAssemblySubsetTables, options);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.InstalledAssemblyTables, options);
-            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.LatestTargetFrameworkDirectories, options);
-            writer.Write(value.ProfileName);
-            formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Serialize(ref writer, value.ResolvedSDKReferences, options);
-            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.SearchPaths, options);
-            writer.Write(value.Silent);
-            writer.Write(value.StateFile);
-            writer.Write(value.SupportsBindingRedirectGeneration);
-            writer.Write(value.TargetedRuntimeVersion);
-            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.TargetFrameworkDirectories, options);
-            writer.Write(value.TargetFrameworkMoniker);
-            writer.Write(value.TargetFrameworkMonikerDisplayName);
-            formatterResolver.GetFormatter<string[]>().Serialize(ref writer, value.TargetFrameworkSubsets, options);
-            writer.Write(value.TargetFrameworkVersion);
-            writer.Write(value.TargetProcessorArchitecture);
-            writer.Write(value.UnresolveFrameworkAssembliesFromHigherFrameworks);
-            writer.Write(value.UseResolveAssemblyReferenceService);
-            writer.Write(value.WarnOrErrorOnTargetArchitectureMismatch);
-            writer.Write(value.CurrentPath);
-        }
-
-        public ResolveAssemblyReferenceRequest Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
-        {
-            if (reader.TryReadNil())
-            {
-                return null;
-            }
-
-            options.Security.DepthStep(ref reader);
-            IFormatterResolver formatterResolver = options.Resolver;
-            int length = reader.ReadArrayHeader();
-            string[] allowedAssemblyExtensions = default;
-            string[] allowedRelatedFileExtensions = default;
-            string appConfigFile = default;
-            ReadOnlyTaskItem[] assemblies = default;
-            ReadOnlyTaskItem[] assemblyFiles = default;
-            bool autoUnify = default;
-            string[] candidateAssemblyFiles = default;
-            bool copyLocalDependenciesWhenParentReferenceInGac = default;
-            bool doNotCopyLocalIfInGac = default;
-            bool findDependencies = default;
-            bool findDependenciesOfExternallyResolvedReferences = default;
-            bool findRelatedFiles = default;
-            bool findSatellites = default;
-            bool findSerializationAssemblies = default;
-            ReadOnlyTaskItem[] fullFrameworkAssemblyTables = default;
-            string[] fullFrameworkFolders = default;
-            string[] fullTargetFrameworkSubsetNames = default;
-            bool ignoreDefaultInstalledAssemblySubsetTables = default;
-            bool ignoreDefaultInstalledAssemblyTables = default;
-            bool ignoreTargetFrameworkAttributeVersionMismatch = default;
-            bool ignoreVersionForFrameworkReferences = default;
-            ReadOnlyTaskItem[] installedAssemblySubsetTables = default;
-            ReadOnlyTaskItem[] installedAssemblyTables = default;
-            string[] latestTargetFrameworkDirectories = default;
-            string profileName = default;
-            ReadOnlyTaskItem[] resolvedSDKReferences = default;
-            string[] searchPaths = default;
-            bool silent = default;
-            string stateFile = default;
-            bool supportsBindingRedirectGeneration = default;
-            string targetedRuntimeVersion = default;
-            string[] targetFrameworkDirectories = default;
-            string targetFrameworkMoniker = default;
-            string targetFrameworkMonikerDisplayName = default;
-            string[] targetFrameworkSubsets = default;
-            string targetFrameworkVersion = default;
-            string targetProcessorArchitecture = default;
-            bool unresolveFrameworkAssembliesFromHigherFrameworks = default;
-            bool useResolveAssemblyReferenceService = default;
-            string warnOrErrorOnTargetArchitectureMismatch = default;
-            string currentPath = default;
-
-            for (int i = 0; i < length; i++)
-            {
-                int key = i;
-
-                switch (key)
-                {
-                    case 0:
-                        allowedAssemblyExtensions = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 1:
-                        allowedRelatedFileExtensions = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 2:
-                        appConfigFile = reader.ReadString();
-                        break;
-                    case 3:
-                        assemblies = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 4:
-                        assemblyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 5:
-                        autoUnify = reader.ReadBoolean();
-                        break;
-                    case 6:
-                        candidateAssemblyFiles = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 7:
-                        copyLocalDependenciesWhenParentReferenceInGac = reader.ReadBoolean();
-                        break;
-                    case 8:
-                        doNotCopyLocalIfInGac = reader.ReadBoolean();
-                        break;
-                    case 9:
-                        findDependencies = reader.ReadBoolean();
-                        break;
-                    case 10:
-                        findDependenciesOfExternallyResolvedReferences = reader.ReadBoolean();
-                        break;
-                    case 11:
-                        findRelatedFiles = reader.ReadBoolean();
-                        break;
-                    case 12:
-                        findSatellites = reader.ReadBoolean();
-                        break;
-                    case 13:
-                        findSerializationAssemblies = reader.ReadBoolean();
-                        break;
-                    case 14:
-                        fullFrameworkAssemblyTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 15:
-                        fullFrameworkFolders = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 16:
-                        fullTargetFrameworkSubsetNames = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 17:
-                        ignoreDefaultInstalledAssemblySubsetTables = reader.ReadBoolean();
-                        break;
-                    case 18:
-                        ignoreDefaultInstalledAssemblyTables = reader.ReadBoolean();
-                        break;
-                    case 19:
-                        ignoreTargetFrameworkAttributeVersionMismatch = reader.ReadBoolean();
-                        break;
-                    case 20:
-                        ignoreVersionForFrameworkReferences = reader.ReadBoolean();
-                        break;
-                    case 21:
-                        installedAssemblySubsetTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 22:
-                        installedAssemblyTables = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 23:
-                        latestTargetFrameworkDirectories = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 24:
-                        profileName = reader.ReadString();
-                        break;
-                    case 25:
-                        resolvedSDKReferences = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
-                        break;
-                    case 26:
-                        searchPaths = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 27:
-                        silent = reader.ReadBoolean();
-                        break;
-                    case 28:
-                        stateFile = reader.ReadString();
-                        break;
-                    case 29:
-                        supportsBindingRedirectGeneration = reader.ReadBoolean();
-                        break;
-                    case 30:
-                        targetedRuntimeVersion = reader.ReadString();
-                        break;
-                    case 31:
-                        targetFrameworkDirectories = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 32:
-                        targetFrameworkMoniker = reader.ReadString();
-                        break;
-                    case 33:
-                        targetFrameworkMonikerDisplayName = reader.ReadString();
-                        break;
-                    case 34:
-                        targetFrameworkSubsets = formatterResolver.GetFormatter<string[]>().Deserialize(ref reader, options);
-                        break;
-                    case 35:
-                        targetFrameworkVersion = reader.ReadString();
-                        break;
-                    case 36:
-                        targetProcessorArchitecture = reader.ReadString();
-                        break;
-                    case 37:
-                        unresolveFrameworkAssembliesFromHigherFrameworks = reader.ReadBoolean();
-                        break;
-                    case 38:
-                        useResolveAssemblyReferenceService = reader.ReadBoolean();
-                        break;
-                    case 39:
-                        warnOrErrorOnTargetArchitectureMismatch = reader.ReadString();
-                        break;
-                    case 40:
-                        currentPath = reader.ReadString();
-                        break;
-                    default:
-                        reader.Skip();
-                        break;
-                }
-            }
-
-            ResolveAssemblyReferenceRequest result = new ResolveAssemblyReferenceRequest
-            {
-                AllowedAssemblyExtensions = allowedAssemblyExtensions,
-                AllowedRelatedFileExtensions = allowedRelatedFileExtensions,
-                AppConfigFile = appConfigFile,
-                Assemblies = assemblies,
-                AssemblyFiles = assemblyFiles,
-                AutoUnify = autoUnify,
-                CandidateAssemblyFiles = candidateAssemblyFiles,
-                CopyLocalDependenciesWhenParentReferenceInGac = copyLocalDependenciesWhenParentReferenceInGac,
-                DoNotCopyLocalIfInGac = doNotCopyLocalIfInGac,
-                FindDependencies = findDependencies,
-                FindDependenciesOfExternallyResolvedReferences = findDependenciesOfExternallyResolvedReferences,
-                FindRelatedFiles = findRelatedFiles,
-                FindSatellites = findSatellites,
-                FindSerializationAssemblies = findSerializationAssemblies,
-                FullFrameworkAssemblyTables = fullFrameworkAssemblyTables,
-                FullFrameworkFolders = fullFrameworkFolders,
-                FullTargetFrameworkSubsetNames = fullTargetFrameworkSubsetNames,
-                IgnoreDefaultInstalledAssemblySubsetTables = ignoreDefaultInstalledAssemblySubsetTables,
-                IgnoreDefaultInstalledAssemblyTables = ignoreDefaultInstalledAssemblyTables,
-                IgnoreTargetFrameworkAttributeVersionMismatch = ignoreTargetFrameworkAttributeVersionMismatch,
-                IgnoreVersionForFrameworkReferences = ignoreVersionForFrameworkReferences,
-                InstalledAssemblySubsetTables = installedAssemblySubsetTables,
-                InstalledAssemblyTables = installedAssemblyTables,
-                LatestTargetFrameworkDirectories = latestTargetFrameworkDirectories,
-                ProfileName = profileName,
-                ResolvedSDKReferences = resolvedSDKReferences,
-                SearchPaths = searchPaths,
-                Silent = silent,
-                StateFile = stateFile,
-                SupportsBindingRedirectGeneration = supportsBindingRedirectGeneration,
-                TargetedRuntimeVersion = targetedRuntimeVersion,
-                TargetFrameworkDirectories = targetFrameworkDirectories,
-                TargetFrameworkMoniker = targetFrameworkMoniker,
-                TargetFrameworkMonikerDisplayName = targetFrameworkMonikerDisplayName,
-                TargetFrameworkSubsets = targetFrameworkSubsets,
-                TargetFrameworkVersion = targetFrameworkVersion,
-                TargetProcessorArchitecture = targetProcessorArchitecture,
-                UnresolveFrameworkAssembliesFromHigherFrameworks = unresolveFrameworkAssembliesFromHigherFrameworks,
-                UseResolveAssemblyReferenceService = useResolveAssemblyReferenceService,
-                WarnOrErrorOnTargetArchitectureMismatch = warnOrErrorOnTargetArchitectureMismatch,
-                CurrentPath = currentPath
-            };
-            reader.Depth--;
-            return result;
-        }
-    }
-}
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResponseFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ResponseFormatter.cs
similarity index 54%
rename from src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResponseFormatter.cs
rename to src/Tasks/ResolveAssemblyReferences/Formatters/ResponseFormatter.cs
index db22bbb5861..7914ded3560 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResponseFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ResponseFormatter.cs
@@ -6,7 +6,7 @@
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
 {
-    internal sealed class ResolveAssemblyReferenceResponseFormatter : MessagePack.Formatters.IMessagePackFormatter<ResolveAssemblyReferenceResponse>
+    internal sealed class ResponseFormatter : MessagePack.Formatters.IMessagePackFormatter<ResolveAssemblyReferenceResponse>
     {
         public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceResponse value, MessagePackSerializerOptions options)
         {
@@ -41,56 +41,44 @@ public ResolveAssemblyReferenceResponse Deserialize(ref MessagePackReader reader
             options.Security.DepthStep(ref reader);
             IFormatterResolver formatterResolver = options.Resolver;
             int length = reader.ReadArrayHeader();
-            ReadOnlyTaskItem[] copyLocalFiles = default;
-            string dependsOnNETStandard = default;
-            string dependsOnSystemRuntime = default;
-            ReadOnlyTaskItem[] filesWritten = default;
-            ReadOnlyTaskItem[] relatedFiles = default;
-            ReadOnlyTaskItem[] resolvedDependencyFiles = default;
-            ReadOnlyTaskItem[] resolvedFiles = default;
-            ReadOnlyTaskItem[] satelliteFiles = default;
-            ReadOnlyTaskItem[] scatterFiles = default;
-            ReadOnlyTaskItem[] serializationAssemblyFiles = default;
-            ReadOnlyTaskItem[] suggestedRedirects = default;
+            ResolveAssemblyReferenceResponse result = new ResolveAssemblyReferenceResponse();
 
             for (int i = 0; i < length; i++)
             {
-                int key = i;
-
-                switch (key)
+                switch (i)
                 {
                     case 0:
-                        copyLocalFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        result.CopyLocalFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
                         break;
                     case 1:
-                        dependsOnNETStandard = reader.ReadString();
+                        result.DependsOnNETStandard = reader.ReadString();
                         break;
                     case 2:
-                        dependsOnSystemRuntime = reader.ReadString();
+                        result.DependsOnSystemRuntime = reader.ReadString();
                         break;
                     case 3:
-                        filesWritten = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        result.FilesWritten = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
                         break;
                     case 4:
-                        relatedFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        result.RelatedFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
                         break;
                     case 5:
-                        resolvedDependencyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        result.ResolvedDependencyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
                         break;
                     case 6:
-                        resolvedFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        result.ResolvedFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
                         break;
                     case 7:
-                        satelliteFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        result.SatelliteFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
                         break;
                     case 8:
-                        scatterFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        result.ScatterFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
                         break;
                     case 9:
-                        serializationAssemblyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        result.SerializationAssemblyFiles = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
                         break;
                     case 10:
-                        suggestedRedirects = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
+                        result.SuggestedRedirects = formatterResolver.GetFormatter<ReadOnlyTaskItem[]>().Deserialize(ref reader, options);
                         break;
                     default:
                         reader.Skip();
@@ -98,20 +86,6 @@ public ResolveAssemblyReferenceResponse Deserialize(ref MessagePackReader reader
                 }
             }
 
-            ResolveAssemblyReferenceResponse result = new ResolveAssemblyReferenceResponse
-            {
-                CopyLocalFiles = copyLocalFiles,
-                DependsOnNETStandard = dependsOnNETStandard,
-                DependsOnSystemRuntime = dependsOnSystemRuntime,
-                FilesWritten = filesWritten,
-                RelatedFiles = relatedFiles,
-                ResolvedDependencyFiles = resolvedDependencyFiles,
-                ResolvedFiles = resolvedFiles,
-                SatelliteFiles = satelliteFiles,
-                ScatterFiles = scatterFiles,
-                SerializationAssemblyFiles = serializationAssemblyFiles,
-                SuggestedRedirects = suggestedRedirects,
-            };
             reader.Depth--;
             return result;
         }
diff --git a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResultFormatter.cs b/src/Tasks/ResolveAssemblyReferences/Formatters/ResultFormatter.cs
similarity index 70%
rename from src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResultFormatter.cs
rename to src/Tasks/ResolveAssemblyReferences/Formatters/ResultFormatter.cs
index 1093f33c70f..4ae77645385 100644
--- a/src/Tasks/ResolveAssemblyReferences/Formatters/ResolveAssemblyReferenceResultFormatter.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Formatters/ResultFormatter.cs
@@ -9,7 +9,7 @@
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Formatters
 {
-    internal sealed class ResolveAssemblyReferenceResultFormatter : IMessagePackFormatter<ResolveAssemblyReferenceResult>
+    internal sealed class ResultFormatter : IMessagePackFormatter<ResolveAssemblyReferenceResult>
     {
         public void Serialize(ref MessagePackWriter writer, ResolveAssemblyReferenceResult value, MessagePackSerializerOptions options)
         {
@@ -36,24 +36,21 @@ public ResolveAssemblyReferenceResult Deserialize(ref MessagePackReader reader,
             options.Security.DepthStep(ref reader);
             IFormatterResolver formatterResolver = options.Resolver;
             int length = reader.ReadArrayHeader();
-            List<BuildEventArgs> buildEvents = default;
-            ResolveAssemblyReferenceResponse response = default;
-            bool taskResult = default;
+
+            ResolveAssemblyReferenceResult result = new ResolveAssemblyReferenceResult();
 
             for (int i = 0; i < length; i++)
             {
-                int key = i;
-
-                switch (key)
+                switch (i)
                 {
                     case 2:
-                        taskResult = reader.ReadBoolean();
+                        result.TaskResult = reader.ReadBoolean();
                         break;
                     case 1:
-                        response = formatterResolver.GetFormatter<ResolveAssemblyReferenceResponse>().Deserialize(ref reader, options);
+                        result.Response = formatterResolver.GetFormatter<ResolveAssemblyReferenceResponse>().Deserialize(ref reader, options);
                         break;
                     case 0:
-                        buildEvents = formatterResolver.GetFormatter<List<BuildEventArgs>>().Deserialize(ref reader, options);
+                        result.BuildEvents = formatterResolver.GetFormatter<List<BuildEventArgs>>().Deserialize(ref reader, options);
                         break;
                     default:
                         reader.Skip();
@@ -61,12 +58,6 @@ public ResolveAssemblyReferenceResult Deserialize(ref MessagePackReader reader,
                 }
             }
 
-            ResolveAssemblyReferenceResult result = new ResolveAssemblyReferenceResult
-            {
-                TaskResult = taskResult,
-                Response = response,
-                BuildEvents = buildEvents
-            };
             reader.Depth--;
             return result;
         }
diff --git a/src/Tasks/ResolveAssemblyReferences/ResolveAssemblyReferneceResolver.cs b/src/Tasks/ResolveAssemblyReferences/ResolveAssemblyReferneceResolver.cs
index 397d22724dc..b4947d3aa6b 100644
--- a/src/Tasks/ResolveAssemblyReferences/ResolveAssemblyReferneceResolver.cs
+++ b/src/Tasks/ResolveAssemblyReferences/ResolveAssemblyReferneceResolver.cs
@@ -74,9 +74,9 @@ internal static object GetFormatter(Type t)
                 1 => new DictionaryFormatter<string, string>(),
                 2 => new ListFormatter<BuildEventArgs>(),
                 3 => new ReadOnlyTaskItemFormatter(),
-                4 => new ResolveAssemblyReferenceRequestFormatter(),
-                5 => new ResolveAssemblyReferenceResponseFormatter(),
-                6 => new ResolveAssemblyReferenceResultFormatter(),
+                4 => new RequestFormatter(),
+                5 => new ResponseFormatter(),
+                6 => new ResultFormatter(),
                 7 => NullableStringArrayFormatter.Instance,
                 8 => NullableStringFormatter.Instance,
                 _ => null,
diff --git a/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs b/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs
index a2136b55e3e..27ab33cab9f 100644
--- a/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs
+++ b/src/Tasks/ResolveAssemblyReferences/RpcUtils.cs
@@ -1,15 +1,8 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using System;
 using System.IO;
-using System.IO.Pipes;
-using System.Threading.Tasks;
 using MessagePack;
-using MessagePack.Formatters;
-using MessagePack.Resolvers;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
 using Nerdbank.Streams;
 using StreamJsonRpc;
 
diff --git a/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs b/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
index 77a5108b8d9..b135f24bccd 100644
--- a/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Server/RarController.cs
@@ -75,8 +75,7 @@ public RarController(
                   validateHandshakeCallback,
                   timeout: timeout,
                   resolveAssemblyReferenceTaskHandler:
-                      new ResolveAssemblyReferenceCacheHandler(
-                      new ResolveAssemblyReferenceHandler()))
+                      new ResolveAssemblyReferenceHandler())
         {
         }
 
@@ -142,6 +141,7 @@ public async Task<int> StartAsync(CancellationToken cancellationToken = default)
             {
                 return pipeServerStream;
             }
+            Console.WriteLine("ERROR: Didn't validate handshake");
 
             // We couldn't validate connection, so don't use this connection at all.
             pipeServerStream.Dispose();
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceCacheHandler.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceCacheHandler.cs
deleted file mode 100644
index 3a44a1c6162..00000000000
--- a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceCacheHandler.cs
+++ /dev/null
@@ -1,76 +0,0 @@
-ï»¿// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-
-using System;
-using System.Collections.Generic;
-using System.Threading;
-using System.Threading.Tasks;
-using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
-
-namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
-{
-    internal sealed class ResolveAssemblyReferenceCacheHandler : IResolveAssemblyReferenceTaskHandler
-    {
-        private readonly struct CacheEntry
-        {
-            public CacheEntry(ResolveAssemblyReferenceRequest request, ResolveAssemblyReferenceResult result)
-            {
-                Request = request;
-                Result = result;
-            }
-
-            public ResolveAssemblyReferenceRequest Request { get; }
-            public ResolveAssemblyReferenceResult Result { get; }
-        }
-
-        private readonly object _lock = new object();
-
-        private readonly Dictionary<string, CacheEntry> _cache;
-
-        private readonly IResolveAssemblyReferenceTaskHandler _handler;
-
-        public ResolveAssemblyReferenceCacheHandler(IResolveAssemblyReferenceTaskHandler handler)
-        {
-            _handler = handler;
-            _cache = new Dictionary<string, CacheEntry>(StringComparer.OrdinalIgnoreCase);
-        }
-
-        public async Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenceRequest input, CancellationToken cancellationToken = default)
-        {
-            string projectId = input.StateFile;
-
-            lock (_lock)
-            {
-                if (projectId != null && _cache.ContainsKey(projectId))
-                {
-                    Console.WriteLine($"Found entry for project: '{projectId}'");
-                    CacheEntry entry = _cache[projectId];
-
-                    if (ResolveAssemblyReferenceComparer.CompareInput(input, entry.Request))
-                    {
-                        return entry.Result;
-                    }
-
-                    // Not matching, remove it from cache
-                    _cache.Remove(projectId);
-                }
-            }
-
-            ResolveAssemblyReferenceResult result = await _handler.ExecuteAsync(input, cancellationToken);
-
-            lock (_lock)
-            {
-                Console.WriteLine("Adding new entry to cache");
-                if (projectId != null)
-                    _cache[projectId] = new CacheEntry(input, result);
-            }
-
-            return result;
-        }
-
-        public void Dispose()
-        {
-            _handler.Dispose();
-        }
-    }
-}
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs
index 9ea99c6fe54..92e2bf35916 100644
--- a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceComparer.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System.Collections.Generic;
+using System.Linq;
 using Microsoft.Build.Tasks.ResolveAssemblyReferences.Contract;
 
 namespace Microsoft.Build.Tasks.ResolveAssemblyReferences.Services
@@ -20,8 +21,7 @@ internal static bool CompareInput(ResolveAssemblyReferenceRequest x, ResolveAsse
                 return false;
             }
 
-            bool fieldsEqual = y != null &&
-                   x.AppConfigFile == y.AppConfigFile &&
+            bool fieldsEqual = x.AppConfigFile == y.AppConfigFile &&
                    x.AutoUnify == y.AutoUnify &&
                    x.CopyLocalDependenciesWhenParentReferenceInGac == y.CopyLocalDependenciesWhenParentReferenceInGac &&
                    x.DoNotCopyLocalIfInGac == y.DoNotCopyLocalIfInGac &&
@@ -46,6 +46,7 @@ internal static bool CompareInput(ResolveAssemblyReferenceRequest x, ResolveAsse
                    x.UnresolveFrameworkAssembliesFromHigherFrameworks == y.UnresolveFrameworkAssembliesFromHigherFrameworks &&
                    x.UseResolveAssemblyReferenceService == y.UseResolveAssemblyReferenceService &&
                    x.WarnOrErrorOnTargetArchitectureMismatch == y.WarnOrErrorOnTargetArchitectureMismatch &&
+                   x.AssemblyInformationCacheOutputPath == y.AssemblyInformationCacheOutputPath &&
                    x.CurrentPath == y.CurrentPath;
 
             return fieldsEqual &&
@@ -63,6 +64,7 @@ internal static bool CompareInput(ResolveAssemblyReferenceRequest x, ResolveAsse
                    AreTaskItemListsEqual(x.ResolvedSDKReferences, y.ResolvedSDKReferences) &&
                    AreStringListsEqual(x.SearchPaths, y.SearchPaths) &&
                    AreStringListsEqual(x.TargetFrameworkDirectories, y.TargetFrameworkDirectories) &&
+                   AreTaskItemListsEqual(x.AssemblyInformationCachePaths, y.AssemblyInformationCachePaths) &&
                    AreStringListsEqual(x.TargetFrameworkSubsets, y.TargetFrameworkSubsets);
         }
 
@@ -89,9 +91,6 @@ internal static bool CompareOutput(ResolveAssemblyReferenceResponse x, ResolveAs
                    AreTaskItemListsEqual(x.ScatterFiles, y.ScatterFiles) &&
                    AreTaskItemListsEqual(x.SerializationAssemblyFiles, y.SerializationAssemblyFiles) &&
                    AreTaskItemListsEqual(x.SuggestedRedirects, y.SuggestedRedirects); 
-            //&&
-            //       AreTaskItemListsEqual(x.Assemblies, y.Assemblies) &&
-            //       AreTaskItemListsEqual(x.AssemblyFiles, y.AssemblyFiles);
         }
 
         private static bool AreStringListsEqual(string[] x, string[] y)
diff --git a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceHandler.cs b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceHandler.cs
index e2b1101d535..6ee7f850717 100644
--- a/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceHandler.cs
+++ b/src/Tasks/ResolveAssemblyReferences/Services/ResolveAssemblyReferenceHandler.cs
@@ -16,14 +16,13 @@ public Task<ResolveAssemblyReferenceResult> ExecuteAsync(ResolveAssemblyReferenc
 
         internal ResolveAssemblyReferenceResult Execute(ResolveAssemblyReferenceRequest input)
         {
-            ResolveAssemblyReferenceTaskInput taskInput = new ResolveAssemblyReferenceTaskInput(input);
             ResolveAssemblyReferenceBuildEngine buildEngine = new ResolveAssemblyReferenceBuildEngine();
             ResolveAssemblyReference task = new ResolveAssemblyReference
             {
                 BuildEngine = buildEngine
             };
 
-            ResolveAssemblyReferenceResult result = task.Execute(taskInput);
+            ResolveAssemblyReferenceResult result = task.Execute(input);
             result.BuildEvents = buildEngine.BuildEvents;
 
             return result;
