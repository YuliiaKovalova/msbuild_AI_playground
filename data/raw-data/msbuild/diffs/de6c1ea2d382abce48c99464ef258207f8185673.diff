diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 1f86224d271..92bf0ff1e27 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -137,9 +137,9 @@
       <Uri>https://github.com/dotnet/arcade</Uri>
       <Sha>5ba9ca776c1d0bb72b2791591e54cf51fc52dfee</Sha>
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.14.0-preview.1.66">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.14.0-preview.1.89">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>181b65dad9f440c7a31fe673abc59c258f224ada</Sha>
+      <Sha>13550619f90e73a1f8b4b5159c6d7f268c9756d0</Sha>
     </Dependency>
     <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.14.0-3.25171.27">
       <Uri>https://github.com/dotnet/roslyn</Uri>
diff --git a/eng/Versions.props b/eng/Versions.props
index 3093e9241f6..ce75c963a5a 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -85,7 +85,7 @@
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
     <MicrosoftDotNetXUnitExtensionsVersion>9.0.0-beta.25164.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftNetCompilersToolsetVersion>4.14.0-3.25171.27</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.14.0-preview.1.66</NuGetBuildTasksVersion>
+    <NuGetBuildTasksVersion>6.14.0-preview.1.89</NuGetBuildTasksVersion>
   </PropertyGroup>
   <PropertyGroup Condition="!$(TargetFramework.StartsWith('net4'))">
     <BootstrapSdkVersion>9.0.200-preview.0.24603.3</BootstrapSdkVersion>
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 74963e26794..8ca50416de7 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 using Xunit;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
diff --git a/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs b/src/Build.UnitTests/Telemetry/OpenTelemetryActivities_Tests.cs
similarity index 98%
rename from src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs
rename to src/Build.UnitTests/Telemetry/OpenTelemetryActivities_Tests.cs
index cd041632de2..5616f614530 100644
--- a/src/Build.UnitTests/BackEnd/OpenTelemetryActivities_Tests.cs
+++ b/src/Build.UnitTests/Telemetry/OpenTelemetryActivities_Tests.cs
@@ -8,8 +8,9 @@
 using System.Text;
 using Xunit;
 using Shouldly;
+using Microsoft.Build.Framework.Telemetry;
 
-namespace Microsoft.Build.Framework.Telemetry.Tests
+namespace Microsoft.Build.Engine.UnitTests.Telemetry
 {
     public class ActivityExtensionsTests
     {
diff --git a/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs b/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
similarity index 64%
rename from src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs
rename to src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
index a2ec5161797..58dbfa240ca 100644
--- a/src/Build.UnitTests/BackEnd/OpenTelemetryManager_Tests.cs
+++ b/src/Build.UnitTests/Telemetry/OpenTelemetryManager_Tests.cs
@@ -8,12 +8,11 @@
 using Xunit.Abstractions;
 using Microsoft.Build.UnitTests.Shared;
 using Microsoft.Build.UnitTests;
+using Microsoft.Build.Framework.Telemetry;
 
-namespace Microsoft.Build.Framework.Telemetry.Tests
+namespace Microsoft.Build.Engine.UnitTests.Telemetry
 {
-    /// <summary>
-    /// Ensures tests run serially so environment variables and the singleton do not interfere with parallel test runs.
-    /// </summary>
+    // Putting the tests to a collection ensures tests run serially by default, that's needed to isolate the manager singleton state and env vars in some telemetry tests.
     [Collection("OpenTelemetryManagerTests")]
     public class OpenTelemetryManagerTests : IDisposable
     {
@@ -23,46 +22,13 @@ public class OpenTelemetryManagerTests : IDisposable
         private const string TelemetrySampleRateOverrideEnvVarName = "MSBUILD_TELEMETRY_SAMPLE_RATE";
         private const string VS1714TelemetryOptInEnvVarName = "MSBUILD_TELEMETRY_OPTIN";
 
-        private string? preTestFxOptout;
-        private string? preTestDotnetOptout;
-        private string? preTestSampleRate;
-        private string? preTestVS1714TelemetryOptIn;
-
         public OpenTelemetryManagerTests()
         {
-            // control environment state before each test
-            SaveEnvVars();
             ResetManagerState();
-            ResetEnvVars();
-        }
-
-        private void SaveEnvVars()
-        {
-            preTestFxOptout = Environment.GetEnvironmentVariable(TelemetryFxOptoutEnvVarName);
-            preTestDotnetOptout = Environment.GetEnvironmentVariable(DotnetOptOut);
-            preTestSampleRate = Environment.GetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName);
-            preTestVS1714TelemetryOptIn = Environment.GetEnvironmentVariable(VS1714TelemetryOptInEnvVarName);
-        }
-
-        private void RestoreEnvVars()
-        {
-            Environment.SetEnvironmentVariable(TelemetryFxOptoutEnvVarName, preTestFxOptout);
-            Environment.SetEnvironmentVariable(DotnetOptOut, preTestDotnetOptout);
-            Environment.SetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName, preTestSampleRate);
-            Environment.SetEnvironmentVariable(VS1714TelemetryOptInEnvVarName, preTestVS1714TelemetryOptIn);
-        }
-
-        private void ResetEnvVars()
-        {
-            Environment.SetEnvironmentVariable(DotnetOptOut, null);
-            Environment.SetEnvironmentVariable(TelemetryFxOptoutEnvVarName, null);
-            Environment.SetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName, null);
-            Environment.SetEnvironmentVariable(VS1714TelemetryOptInEnvVarName, null);
         }
 
         public void Dispose()
         {
-            RestoreEnvVars();
         }
 
         [Theory]
@@ -73,7 +39,8 @@ public void Dispose()
         public void Initialize_ShouldSetStateToOptOut_WhenOptOutEnvVarIsTrue(string optoutVar, string value)
         {
             // Arrange
-            Environment.SetEnvironmentVariable(optoutVar, value);
+            using TestEnvironment environment = TestEnvironment.Create();
+            environment.SetEnvironmentVariable(optoutVar, value);
 
             // Act
             OpenTelemetryManager.Instance.Initialize(isStandalone: false);
@@ -82,11 +49,13 @@ public void Initialize_ShouldSetStateToOptOut_WhenOptOutEnvVarIsTrue(string opto
             OpenTelemetryManager.Instance.IsActive().ShouldBeFalse();
         }
 
-#if NET
+#if NETCOREAPP
         [Fact]
         public void Initialize_ShouldSetStateToUnsampled_WhenNoOverrideOnNetCore()
         {
-            Environment.SetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName, null);
+            using TestEnvironment environment = TestEnvironment.Create();
+            environment.SetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName, null);
+            environment.SetEnvironmentVariable(DotnetOptOut, null);
 
             OpenTelemetryManager.Instance.Initialize(isStandalone: false);
 
@@ -101,8 +70,10 @@ public void Initialize_ShouldSetStateToUnsampled_WhenNoOverrideOnNetCore()
         public void Initialize_ShouldSetSampleRateOverride_AndCreateActivitySource_WhenRandomBelowOverride(bool standalone)
         {
             // Arrange
-            Environment.SetEnvironmentVariable(VS1714TelemetryOptInEnvVarName, "1");
-            Environment.SetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName, "1.0");
+            using TestEnvironment environment = TestEnvironment.Create();
+            environment.SetEnvironmentVariable(VS1714TelemetryOptInEnvVarName, "1");
+            environment.SetEnvironmentVariable(TelemetrySampleRateOverrideEnvVarName, "1.0");
+            environment.SetEnvironmentVariable(DotnetOptOut, null);
 
             // Act
             OpenTelemetryManager.Instance.Initialize(isStandalone: standalone);
@@ -115,11 +86,12 @@ public void Initialize_ShouldSetSampleRateOverride_AndCreateActivitySource_WhenR
         [Fact]
         public void Initialize_ShouldNoOp_WhenCalledMultipleTimes()
         {
-            Environment.SetEnvironmentVariable(DotnetOptOut, "true");
+            using TestEnvironment environment = TestEnvironment.Create();
+            environment.SetEnvironmentVariable(DotnetOptOut, "true");
             OpenTelemetryManager.Instance.Initialize(isStandalone: true);
             var state1 = OpenTelemetryManager.Instance.IsActive();
 
-            Environment.SetEnvironmentVariable(DotnetOptOut, null);
+            environment.SetEnvironmentVariable(DotnetOptOut, null);
             OpenTelemetryManager.Instance.Initialize(isStandalone: true);
             var state2 = OpenTelemetryManager.Instance.IsActive();
 
diff --git a/src/Build.UnitTests/TelemetryTests.cs b/src/Build.UnitTests/Telemetry/Telemetry_Tests.cs
similarity index 55%
rename from src/Build.UnitTests/TelemetryTests.cs
rename to src/Build.UnitTests/Telemetry/Telemetry_Tests.cs
index d04353d7321..6939eda86e5 100644
--- a/src/Build.UnitTests/TelemetryTests.cs
+++ b/src/Build.UnitTests/Telemetry/Telemetry_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Linq;
 using System.Text.Json;
 using Microsoft.Build.Execution;
@@ -16,11 +17,12 @@
 
 namespace Microsoft.Build.Engine.UnitTests
 {
-    public class TelemetryTests
+    [Collection("OpenTelemetryManagerTests")]
+    public class Telemetry_Tests
     {
         private readonly ITestOutputHelper _output;
 
-        public TelemetryTests(ITestOutputHelper output)
+        public Telemetry_Tests(ITestOutputHelper output)
         {
             _output = output;
         }
@@ -82,7 +84,7 @@ public void WorkerNodeTelemetryCollection_BasicTarget()
             ((int)workerNodeTelemetryData.TasksExecutionData[(TaskOrTargetTelemetryKey)"Microsoft.Build.Tasks.CreateItem"].ExecutionsCount).ShouldBe(1);
             workerNodeTelemetryData.TasksExecutionData[(TaskOrTargetTelemetryKey)"Microsoft.Build.Tasks.CreateItem"].CumulativeExecutionTime.ShouldBeGreaterThan(TimeSpan.Zero);
 
-            workerNodeTelemetryData.TasksExecutionData.Keys.ShouldAllBe(k => !k.IsCustom && !k.IsFromNugetCache);
+            workerNodeTelemetryData.TasksExecutionData.Keys.ShouldAllBe(k => !k.IsCustom && !k.IsNuget);
             workerNodeTelemetryData.TasksExecutionData.Values
                 .Count(v => v.CumulativeExecutionTime > TimeSpan.Zero || v.ExecutionsCount > 0).ShouldBe(2);
         }
@@ -106,7 +108,7 @@ public void WorkerNodeTelemetryCollection_CustomTargetsAndTasks()
                                             </Code>
                                           </Task>
                                        </UsingTask>
-                                       
+
                                        <UsingTask
                                          TaskName="Task02"
                                          TaskFactory="RoslynCodeTaskFactory"
@@ -118,7 +120,7 @@ public void WorkerNodeTelemetryCollection_CustomTargetsAndTasks()
                                            </Code>
                                          </Task>
                                       </UsingTask>
-                                      
+
                                           <Target Name="Build" DependsOnTargets="BeforeBuild">
                                               <Message Text="Hello World"/>
                                               <CreateItem Include="foo.bar">
@@ -127,12 +129,12 @@ public void WorkerNodeTelemetryCollection_CustomTargetsAndTasks()
                                               <Task01 />
                                               <Message Text="Bye World"/>
                                           </Target>
-                                          
+
                                           <Target Name="BeforeBuild">
                                               <Message Text="Hello World"/>
                                               <Task01 />
                                           </Target>
-                                          
+
                                           <Target Name="NotExecuted">
                                               <Message Text="Hello World"/>
                                           </Target>
@@ -166,32 +168,151 @@ public void WorkerNodeTelemetryCollection_CustomTargetsAndTasks()
             workerNodeTelemetryData.TasksExecutionData.Values
                 .Count(v => v.CumulativeExecutionTime > TimeSpan.Zero || v.ExecutionsCount > 0).ShouldBe(3);
 
-            workerNodeTelemetryData.TasksExecutionData.Keys.ShouldAllBe(k => !k.IsFromNugetCache);
+            workerNodeTelemetryData.TasksExecutionData.Keys.ShouldAllBe(k => !k.IsNuget);
         }
 
+#if NET
+        // test in .net core with opentelemetry opted in to avoid sending it but enable listening to it
         [Fact]
-        public void Foo()
+        public void NodeTelemetryE2E()
         {
-            WorkerNodeTelemetryData wd = new WorkerNodeTelemetryData(
-                new Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>()
-                {
-                    {
-                        new TaskOrTargetTelemetryKey("TaskA", false, true),
-                        new TaskExecutionStats(TimeSpan.FromSeconds(2.1554548), 5, 545)
-                    },
-                    {
-                        new TaskOrTargetTelemetryKey("TaskA", true, false),
-                        new TaskExecutionStats(TimeSpan.FromSeconds(254548), 6, 54545451)
-                    },
-                },
-                new Dictionary<TaskOrTargetTelemetryKey, bool>()
-                {
-                    { new TaskOrTargetTelemetryKey("TargetA", false, true, false), false },
-                    { new TaskOrTargetTelemetryKey("TargetA", true, true, false), false },
-                    { new TaskOrTargetTelemetryKey("TargetB", false, false, true), false }
-                });
-
-            var holder = TelemetryDataUtils.AsActivityDataHolder(wd, true, true);
+            using TestEnvironment env = TestEnvironment.Create();
+            env.SetEnvironmentVariable("MSBUILD_TELEMETRY_OPTIN", "1");
+            env.SetEnvironmentVariable("MSBUILD_TELEMETRY_SAMPLE_RATE", "1.0");
+            env.SetEnvironmentVariable("MSBUILD_TELEMETRY_OPTOUT", null);
+            env.SetEnvironmentVariable("DOTNET_CLI_TELEMETRY_OPTOUT", null);
+
+            // Reset the OpenTelemetryManager state to ensure clean test
+            var instance = OpenTelemetryManager.Instance;
+            typeof(OpenTelemetryManager)
+                .GetField("_telemetryState", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
+                ?.SetValue(instance, OpenTelemetryManager.TelemetryState.Uninitialized);
+
+            typeof(OpenTelemetryManager)
+                .GetProperty("DefaultActivitySource",
+                    System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
+                ?.SetValue(instance, null);
+
+            // track activities through an ActivityListener
+            var capturedActivities = new List<Activity>();
+            using var listener = new ActivityListener
+            {
+                ShouldListenTo = source => source.Name.StartsWith(TelemetryConstants.DefaultActivitySourceNamespace),
+                Sample = (ref ActivityCreationOptions<ActivityContext> _) => ActivitySamplingResult.AllData,
+                ActivityStarted = capturedActivities.Add,
+                ActivityStopped = _ => { }
+            };
+            ActivitySource.AddActivityListener(listener);
+
+            var testProject = @"
+            <Project>
+                <Target Name='Build'>
+                    <Message Text='Start'/>
+                    <CreateItem Include='test.txt'>
+                        <Output TaskParameter='Include' ItemName='TestItem' />
+                    </CreateItem>
+                    <Message Text='End'/>
+                </Target>
+                <Target Name='Clean'>
+                    <Message Text='Cleaning...'/>
+                </Target>
+            </Project>";
+
+            using var testEnv = TestEnvironment.Create(_output);
+            var projectFile = testEnv.CreateFile("test.proj", testProject).Path;
+
+            // Set up loggers
+            var projectFinishedLogger = new ProjectFinishedCapturingLogger();
+            var buildParameters = new BuildParameters
+            {
+                Loggers = new ILogger[] { projectFinishedLogger },
+                IsTelemetryEnabled = true
+            };
+
+            // Act
+            using (var buildManager = new BuildManager())
+            {
+                // Phase 1: Begin Build - This initializes telemetry infrastructure
+                buildManager.BeginBuild(buildParameters);
+
+                // Phase 2: Execute build requests
+                var buildRequestData1 = new BuildRequestData(
+                    projectFile,
+                    new Dictionary<string, string?>(),
+                    null,
+                    new[] { "Build" },
+                    null);
+
+                buildManager.BuildRequest(buildRequestData1);
+
+                var buildRequestData2 = new BuildRequestData(
+                    projectFile,
+                    new Dictionary<string, string?>(),
+                    null,
+                    new[] { "Clean" },
+                    null);
+
+                buildManager.BuildRequest(buildRequestData2);
+
+                // Phase 3: End Build - This puts telemetry to an system.diagnostics activity
+                buildManager.EndBuild();
+
+                // Verify build activity were captured by the listener and contain task and target info
+                capturedActivities.ShouldNotBeEmpty();
+                var activity = capturedActivities.FindLast(a => a.DisplayName == "VS/MSBuild/Build").ShouldNotBeNull();
+                var tags = activity.Tags.ToDictionary(t => t.Key, t => t.Value);
+                tags.ShouldNotBeNull();
+
+                tags.ShouldContainKey("VS.MSBuild.BuildTarget");
+                tags["VS.MSBuild.BuildTarget"].ShouldNotBeNullOrEmpty();
+
+                // Verify task data
+                tags.ShouldContainKey("VS.MSBuild.Tasks");
+                var tasksJson = tags["VS.MSBuild.Tasks"];
+                tasksJson.ShouldNotBeNullOrEmpty();
+                tasksJson.ShouldContain("Microsoft.Build.Tasks.Message");
+                tasksJson.ShouldContain("Microsoft.Build.Tasks.CreateItem");
+
+                // Parse tasks data for detailed assertions
+                var tasksData = JsonSerializer.Deserialize<JsonElement>(tasksJson);
+
+                // Verify Message task execution metrics - updated for object structure
+                tasksData.TryGetProperty("Microsoft.Build.Tasks.Message", out var messageTask).ShouldBe(true);
+                messageTask.GetProperty("ExecutionsCount").GetInt32().ShouldBe(3);
+                messageTask.GetProperty("TotalMilliseconds").GetDouble().ShouldBeGreaterThan(0);
+                messageTask.GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThan(0);
+                messageTask.GetProperty(nameof(TaskOrTargetTelemetryKey.IsCustom)).GetBoolean().ShouldBe(false);
+                messageTask.GetProperty(nameof(TaskOrTargetTelemetryKey.IsCustom)).GetBoolean().ShouldBe(false);
+
+                // Verify CreateItem task execution metrics - updated for object structure
+                tasksData.TryGetProperty("Microsoft.Build.Tasks.CreateItem", out var createItemTask).ShouldBe(true);
+                createItemTask.GetProperty("ExecutionsCount").GetInt32().ShouldBe(1);
+                createItemTask.GetProperty("TotalMilliseconds").GetDouble().ShouldBeGreaterThan(0);
+                createItemTask.GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThan(0);
+
+                // Verify Targets summary information
+                tags.ShouldContainKey("VS.MSBuild.TargetsSummary");
+                var targetsSummaryJson = tags["VS.MSBuild.TargetsSummary"];
+                targetsSummaryJson.ShouldNotBeNullOrEmpty();
+                var targetsSummary = JsonSerializer.Deserialize<JsonElement>(targetsSummaryJson);
+
+                // Verify loaded and executed targets counts - match structure in TargetsSummaryConverter.Write
+                targetsSummary.GetProperty("Loaded").GetProperty("Total").GetInt32().ShouldBe(2);
+                targetsSummary.GetProperty("Executed").GetProperty("Total").GetInt32().ShouldBe(2);
+
+                // Verify Tasks summary information
+                tags.ShouldContainKey("VS.MSBuild.TasksSummary");
+                var tasksSummaryJson = tags["VS.MSBuild.TasksSummary"];
+                tasksSummaryJson.ShouldNotBeNullOrEmpty();
+                var tasksSummary = JsonSerializer.Deserialize<JsonElement>(tasksSummaryJson);
+
+                // Verify task execution summary metrics based on TasksSummaryConverter.Write structure
+                tasksSummary.GetProperty("Microsoft").GetProperty("Total").GetProperty("ExecutionsCount").GetInt32().ShouldBe(4);
+                tasksSummary.GetProperty("Microsoft").GetProperty("Total").GetProperty("TotalMilliseconds").GetDouble().ShouldBeGreaterThan(0);
+                tasksSummary.GetProperty("Microsoft").GetProperty("Total").GetProperty("TotalMemoryBytes").GetInt64().ShouldBeGreaterThan(0);
+            }
         }
+
+#endif
     }
 }
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 78f96a187df..a60bd4ed0d8 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -2989,8 +2989,8 @@ private ILoggingService CreateLoggingService(
                 // We do want to dictate our own forwarding logger (otherwise CentralForwardingLogger with minimum transferred importance MessageImportance.Low is used)
                 // In the future we might optimize for single, in-node build scenario - where forwarding logger is not needed (but it's just quick pass-through)
                 LoggerDescription forwardingLoggerDescription = new LoggerDescription(
-                    loggerClassName: typeof(InternalTelemeteryForwardingLogger).FullName,
-                    loggerAssemblyName: typeof(InternalTelemeteryForwardingLogger).GetTypeInfo().Assembly.GetName().FullName,
+                    loggerClassName: typeof(InternalTelemetryForwardingLogger).FullName,
+                    loggerAssemblyName: typeof(InternalTelemetryForwardingLogger).GetTypeInfo().Assembly.GetName().FullName,
                     loggerAssemblyFile: null,
                     loggerSwitchParameters: null,
                     verbosity: LoggerVerbosity.Quiet);
diff --git a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
index e61db2b91b2..995370003eb 100644
--- a/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
+++ b/src/Build/BackEnd/Components/Logging/EventSourceSink.cs
@@ -5,6 +5,7 @@
 using Microsoft.Build.Experimental.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
diff --git a/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs b/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs
index 24cd5b9ed0e..8d4832cd374 100644
--- a/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs
+++ b/src/Build/TelemetryInfra/InternalTelemetryConsumingLogger.cs
@@ -14,7 +14,7 @@ internal sealed class InternalTelemetryConsumingLogger : ILogger
 {
     public LoggerVerbosity Verbosity { get; set; }
     public string? Parameters { get; set; }
-    internal static event Action<WorkerNodeTelemetryData>? TestOnly_InternalTelemetryAggregted; 
+    internal static event Action<WorkerNodeTelemetryData>? TestOnly_InternalTelemetryAggregted;
 
     public void Initialize(IEventSource eventSource)
     {
@@ -38,12 +38,11 @@ private void EventSourceOnBuildFinished(object sender, BuildFinishedEventArgs e)
     {
         TestOnly_InternalTelemetryAggregted?.Invoke(_workerNodeTelemetryData);
         FlushDataIntoConsoleIfRequested();
-        FlushDataIntoJsonFileIfRequested();
     }
 
     private void FlushDataIntoConsoleIfRequested()
     {
-        if (!Traits.IsEnvVarOneOrTrue("MSBUILDOUTPUTNODESTELEMETRY"))
+        if (!Traits.Instance.FlushNodesTelemetryIntoConsole)
         {
             return;
         }
@@ -63,15 +62,15 @@ private void FlushDataIntoConsoleIfRequested()
         }
         Console.WriteLine("==========================================");
         Console.WriteLine("Tasks by time:");
-        foreach (var task in _workerNodeTelemetryData.TasksExecutionData.OrderByDescending(t => t.Value.CumulativeExecutionTime).Take(20))
+        foreach (var task in _workerNodeTelemetryData.TasksExecutionData.OrderByDescending(t => t.Value.CumulativeExecutionTime))
         {
             Console.WriteLine($"{task.Key} - {task.Value.CumulativeExecutionTime}");
         }
         Console.WriteLine("==========================================");
         Console.WriteLine("Tasks by memory consumption:");
-        foreach (var task in _workerNodeTelemetryData.TasksExecutionData.OrderByDescending(t => t.Value.TotalMemoryConsumption).Take(20))
+        foreach (var task in _workerNodeTelemetryData.TasksExecutionData.OrderByDescending(t => t.Value.TotalMemoryBytes))
         {
-            Console.WriteLine($"{task.Key} - {task.Value.TotalMemoryConsumption / 1024.0:0.00}kB");
+            Console.WriteLine($"{task.Key} - {task.Value.TotalMemoryBytes / 1024.0:0.00}kB");
         }
         Console.WriteLine("==========================================");
         Console.WriteLine("Tasks by Executions count:");
@@ -82,22 +81,6 @@ private void FlushDataIntoConsoleIfRequested()
         Console.WriteLine("==========================================");
     }
 
-    private void FlushDataIntoJsonFileIfRequested()
-    {
-        const string jsonFileNameVariable = "MSBUILDNODETELEMETRYFILENAME";
-        var jsonFilePath = Environment.GetEnvironmentVariable(jsonFileNameVariable);
-        if (string.IsNullOrEmpty(jsonFilePath))
-        {
-            return;
-        }
-
-        var telemetryTags = _workerNodeTelemetryData.AsActivityDataHolder(true, true)?.GetActivityProperties();
-
-        using var stream = File.OpenWrite(jsonFilePath);
-        stream.SetLength(0);
-        JsonSerializer.Serialize(stream, telemetryTags, new JsonSerializerOptions() { WriteIndented = true });
-    }
-
     public void Shutdown()
     { }
 }
diff --git a/src/Build/TelemetryInfra/TelemetryDataUtils.cs b/src/Build/TelemetryInfra/TelemetryDataUtils.cs
index ed91dcdbaa9..e2759bec030 100644
--- a/src/Build/TelemetryInfra/TelemetryDataUtils.cs
+++ b/src/Build/TelemetryInfra/TelemetryDataUtils.cs
@@ -5,10 +5,18 @@
 using System.Collections.Generic;
 using System.Text.Json;
 using System.Text.Json.Serialization;
+
 namespace Microsoft.Build.Framework.Telemetry
 {
     internal static class TelemetryDataUtils
     {
+        /// <summary>
+        /// Transforms collected telemetry data to format recognized by the telemetry infrastructure.
+        /// </summary>
+        /// <param name="telemetryData">Data about tasks and target forwarded from nodes.</param>
+        /// <param name="includeTasksDetails">Controls whether Task details should attached to the telemetry.</param>
+        /// <param name="includeTargetDetails">Controls whether Target details should be attached to the telemetry.</param>
+        /// <returns>Node Telemetry data wrapped in <see cref="IActivityTelemetryDataHolder"/> a list of properties that can be attached as tags to a <see cref="System.Diagnostics.Activity"/>.</returns>
         public static IActivityTelemetryDataHolder? AsActivityDataHolder(this IWorkerNodeTelemetryData? telemetryData, bool includeTasksDetails, bool includeTargetDetails)
         {
             if (telemetryData == null)
@@ -20,24 +28,24 @@ internal static class TelemetryDataUtils
 
             if (includeTasksDetails)
             {
-                telemetryItems.Add(new TelemetryItem("Tasks",
+                telemetryItems.Add(new TelemetryItem(NodeTelemetryTags.Tasks,
                     JsonSerializer.Serialize(telemetryData.TasksExecutionData, _serializerOptions), false));
             }
 
             if (includeTargetDetails)
             {
-                telemetryItems.Add(new TelemetryItem("Targets",
+                telemetryItems.Add(new TelemetryItem(NodeTelemetryTags.Targets,
                     JsonSerializer.Serialize(telemetryData.TargetsExecutionData, _serializerOptions), false));
             }
 
-            TargetsSummary targetsSummary = new();
-            targetsSummary.Initialize(telemetryData.TargetsExecutionData);
-            telemetryItems.Add(new TelemetryItem("TargetsSummary",
+            TargetsSummaryConverter targetsSummary = new();
+            targetsSummary.Process(telemetryData.TargetsExecutionData);
+            telemetryItems.Add(new TelemetryItem(NodeTelemetryTags.TargetsSummary,
                 JsonSerializer.Serialize(targetsSummary, _serializerOptions), false));
 
-            TasksSummary tasksSummary = new();
-            tasksSummary.Initialize(telemetryData.TasksExecutionData);
-            telemetryItems.Add(new TelemetryItem("TasksSummary",
+            TasksSummaryConverter tasksSummary = new();
+            tasksSummary.Process(telemetryData.TasksExecutionData);
+            telemetryItems.Add(new TelemetryItem(NodeTelemetryTags.TasksSummary,
                 JsonSerializer.Serialize(tasksSummary, _serializerOptions), false));
 
             return new NodeTelemetry(telemetryItems);
@@ -49,21 +57,19 @@ private static JsonSerializerOptions CreateSerializerOptions()
         {
             var opt = new JsonSerializerOptions
             {
-                // Add following if user-friendly indentation would be needed
-                // WriteIndented = true,
                 Converters =
                 {
-                    new TargetDataConverter(),
-                    new TaskDataConverter(),
-                    new TargetsSummary(),
-                    new TasksSummary(),
+                    new TargetsDetailsConverter(),
+                    new TasksDetailsConverter(),
+                    new TargetsSummaryConverter(),
+                    new TasksSummaryConverter(),
                 },
             };
 
             return opt;
         }
 
-        private class TargetDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, bool>?>
+        private class TargetsDetailsConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, bool>?>
         {
             public override Dictionary<TaskOrTargetTelemetryKey, bool>? Read(
                 ref Utf8JsonReader reader,
@@ -83,24 +89,29 @@ public override void Write(
                 }
 
                 // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types
-
-                writer.WriteStartArray();
+                writer.WriteStartObject();
 
                 foreach (KeyValuePair<TaskOrTargetTelemetryKey, bool> valuePair in value)
                 {
-                    writer.WriteStartObject(valuePair.Key.IsCustom || valuePair.Key.IsFromMetaProject ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);
+                    string keyName = ShouldHashKey(valuePair.Key) ?
+                        ActivityExtensions.GetHashed(valuePair.Key.Name) :
+                        valuePair.Key.Name;
+
+                    writer.WriteStartObject(keyName);
                     writer.WriteBoolean("WasExecuted", valuePair.Value);
-                    writer.WriteBoolean("IsCustom", valuePair.Key.IsCustom);
-                    writer.WriteBoolean("IsFromNuget", valuePair.Key.IsFromNugetCache);
-                    writer.WriteBoolean("IsMetaproj", valuePair.Key.IsFromMetaProject);
+                    writer.WriteBoolean(nameof(valuePair.Key.IsCustom), valuePair.Key.IsCustom);
+                    writer.WriteBoolean(nameof(valuePair.Key.IsNuget), valuePair.Key.IsNuget);
+                    writer.WriteBoolean(nameof(valuePair.Key.IsMetaProj), valuePair.Key.IsMetaProj);
                     writer.WriteEndObject();
                 }
 
-                writer.WriteEndArray();
+                writer.WriteEndObject();
             }
+
+            private bool ShouldHashKey(TaskOrTargetTelemetryKey key) => key.IsCustom || key.IsMetaProj;
         }
 
-        private class TaskDataConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>?>
+        private class TasksDetailsConverter : JsonConverter<Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>?>
         {
             public override Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats>? Read(
                 ref Utf8JsonReader reader,
@@ -120,58 +131,67 @@ public override void Write(
                 }
 
                 // Following needed - as System.Text.Json doesn't support indexing dictionary by composite types
-
-                writer.WriteStartArray();
+                writer.WriteStartObject();
 
                 foreach (KeyValuePair<TaskOrTargetTelemetryKey, TaskExecutionStats> valuePair in value)
                 {
-                    writer.WriteStartObject(valuePair.Key.IsCustom ? ActivityExtensions.GetHashed(valuePair.Key.Name) : valuePair.Key.Name);
-                    // We do not want decimals
-                    writer.WriteNumber("ExecTimeMs", valuePair.Value.CumulativeExecutionTime.TotalMilliseconds / 1);
-                    writer.WriteNumber("ExecCnt", valuePair.Value.ExecutionsCount);
-                    // We do not want decimals
-                    writer.WriteNumber("MemKBs", valuePair.Value.TotalMemoryConsumption / 1024);
-                    writer.WriteBoolean("IsCustom", valuePair.Key.IsCustom);
-                    writer.WriteBoolean("IsFromNuget", valuePair.Key.IsFromNugetCache);
+                    string keyName = valuePair.Key.IsCustom ?
+                        ActivityExtensions.GetHashed(valuePair.Key.Name) :
+                        valuePair.Key.Name;
+                    writer.WriteStartObject(keyName);
+                    writer.WriteNumber(nameof(valuePair.Value.CumulativeExecutionTime.TotalMilliseconds), valuePair.Value.CumulativeExecutionTime.TotalMilliseconds);
+                    writer.WriteNumber(nameof(valuePair.Value.ExecutionsCount), valuePair.Value.ExecutionsCount);
+                    writer.WriteNumber(nameof(valuePair.Value.TotalMemoryBytes), valuePair.Value.TotalMemoryBytes);
+                    writer.WriteBoolean(nameof(valuePair.Key.IsCustom), valuePair.Key.IsCustom);
+                    writer.WriteBoolean(nameof(valuePair.Key.IsNuget), valuePair.Key.IsNuget);
                     writer.WriteEndObject();
                 }
 
-                writer.WriteEndArray();
+                writer.WriteEndObject();
             }
         }
 
-        private class TargetsSummary : JsonConverter<TargetsSummary>
+        private class TargetsSummaryConverter : JsonConverter<TargetsSummaryConverter>
         {
-            public void Initialize(Dictionary<TaskOrTargetTelemetryKey, bool> targetsExecutionData)
+            /// <summary>
+            /// Processes target execution data to compile summary statistics for both built-in and custom targets.
+            /// </summary>
+            /// <param name="targetsExecutionData">Dictionary containing target execution data keyed by task identifiers.</param>
+            public void Process(Dictionary<TaskOrTargetTelemetryKey, bool> targetsExecutionData)
             {
-                foreach (var targetInfo in targetsExecutionData)
+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, bool> targetPair in targetsExecutionData)
                 {
-                    UpdateStatistics(LoadedBuiltinTargetInfo, LoadedCustomTargetInfo, targetInfo.Key);
-                    if (targetInfo.Value)
+                    TaskOrTargetTelemetryKey key = targetPair.Key;
+                    bool wasExecuted = targetPair.Value;
+
+                    // Update loaded targets statistics (all targets are loaded)
+                    UpdateTargetStatistics(key, isExecuted: false);
+
+                    // Update executed targets statistics (only targets that were actually executed)
+                    if (wasExecuted)
                     {
-                        UpdateStatistics(ExecutedBuiltinTargetInfo, ExecutedCustomTargetInfo, targetInfo.Key);
+                        UpdateTargetStatistics(key, isExecuted: true);
                     }
                 }
+            }
 
-                void UpdateStatistics(
-                    TargetInfo builtinTargetInfo,
-                    TargetInfo customTargetInfo,
-                    TaskOrTargetTelemetryKey key)
-                {
-                    UpdateSingleStatistics(key.IsCustom ? customTargetInfo : builtinTargetInfo, key);
+            private void UpdateTargetStatistics(TaskOrTargetTelemetryKey key, bool isExecuted)
+            {
+                // Select the appropriate target info collections based on execution state
+                TargetInfo builtinTargetInfo = isExecuted ? ExecutedBuiltinTargetInfo : LoadedBuiltinTargetInfo;
+                TargetInfo customTargetInfo = isExecuted ? ExecutedCustomTargetInfo : LoadedCustomTargetInfo;
 
-                    void UpdateSingleStatistics(TargetInfo targetInfo, TaskOrTargetTelemetryKey kkey)
-                    {
-                        targetInfo.Total++;
-                        if (kkey.IsFromNugetCache)
-                        {
-                            targetInfo.FromNuget++;
-                        }
-                        if (kkey.IsFromMetaProject)
-                        {
-                            targetInfo.FromMetaproj++;
-                        }
-                    }
+                // Update either custom or builtin target info based on target type
+                TargetInfo targetInfo = key.IsCustom ? customTargetInfo : builtinTargetInfo;
+
+                targetInfo.Total++;
+                if (key.IsNuget)
+                {
+                    targetInfo.FromNuget++;
+                }
+                if (key.IsMetaProj)
+                {
+                    targetInfo.FromMetaproj++;
                 }
             }
 
@@ -187,7 +207,7 @@ private class TargetInfo
                 public int FromMetaproj { get; internal set; }
             }
 
-            public override TargetsSummary? Read(
+            public override TargetsSummaryConverter? Read(
                 ref Utf8JsonReader reader,
                 Type typeToConvert,
                 JsonSerializerOptions options) =>
@@ -195,7 +215,7 @@ private class TargetInfo
 
             public override void Write(
                 Utf8JsonWriter writer,
-                TargetsSummary value,
+                TargetsSummaryConverter value,
                 JsonSerializerOptions options)
             {
                 writer.WriteStartObject();
@@ -207,10 +227,9 @@ public override void Write(
                 writer.WriteEndObject();
                 writer.WriteEndObject();
 
-
-                void WriteStat(Utf8JsonWriter writer, TargetInfo customTargetsInfo, TargetInfo builtinTargetsInfo)
+                void WriteStat(Utf8JsonWriter writer, TargetInfo builtinTargetsInfo, TargetInfo customTargetsInfo)
                 {
-                    writer.WriteNumber("Total", builtinTargetsInfo.Total + customTargetsInfo.Total);
+                    writer.WriteNumber(nameof(builtinTargetsInfo.Total), builtinTargetsInfo.Total + customTargetsInfo.Total);
                     WriteSingleStat(writer, builtinTargetsInfo, "Microsoft");
                     WriteSingleStat(writer, customTargetsInfo, "Custom");
                 }
@@ -220,54 +239,56 @@ void WriteSingleStat(Utf8JsonWriter writer, TargetInfo targetInfo, string name)
                     if (targetInfo.Total > 0)
                     {
                         writer.WriteStartObject(name);
-                        writer.WriteNumber("Total", targetInfo.Total);
-                        writer.WriteNumber("FromNuget", targetInfo.FromNuget);
-                        writer.WriteNumber("FromMetaproj", targetInfo.FromMetaproj);
+                        writer.WriteNumber(nameof(targetInfo.Total), targetInfo.Total);
+                        writer.WriteNumber(nameof(targetInfo.FromNuget), targetInfo.FromNuget);
+                        writer.WriteNumber(nameof(targetInfo.FromMetaproj), targetInfo.FromMetaproj);
                         writer.WriteEndObject();
                     }
                 }
             }
         }
 
-
-        private class TasksSummary : JsonConverter<TasksSummary>
+        private class TasksSummaryConverter : JsonConverter<TasksSummaryConverter>
         {
-            public void Initialize(Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats> tasksExecutionData)
+            /// <summary>
+            /// Processes task execution data to compile summary statistics for both built-in and custom tasks.
+            /// </summary>
+            /// <param name="tasksExecutionData">Dictionary containing task execution data keyed by task identifiers.</param>
+            public void Process(Dictionary<TaskOrTargetTelemetryKey, TaskExecutionStats> tasksExecutionData)
             {
-                foreach (var taskInfo in tasksExecutionData)
+                foreach (KeyValuePair<TaskOrTargetTelemetryKey, TaskExecutionStats> taskInfo in tasksExecutionData)
                 {
-                    UpdateStatistics(BuiltinTasksInfo, CustomTasksInfo, taskInfo.Key, taskInfo.Value);
+                    UpdateTaskStatistics(BuiltinTasksInfo, CustomTasksInfo, taskInfo.Key, taskInfo.Value);
                 }
+            }
 
-                void UpdateStatistics(
-                    TasksInfo builtinTaskInfo,
-                    TasksInfo customTaskInfo,
-                    TaskOrTargetTelemetryKey key,
-                    TaskExecutionStats taskExecutionStats)
-                {
-                    UpdateSingleStatistics(key.IsCustom ? customTaskInfo : builtinTaskInfo, taskExecutionStats, key);
+            private void UpdateTaskStatistics(
+                TasksInfo builtinTaskInfo,
+                TasksInfo customTaskInfo,
+                TaskOrTargetTelemetryKey key,
+                TaskExecutionStats taskExecutionStats)
+            {
+                TasksInfo taskInfo = key.IsCustom ? customTaskInfo : builtinTaskInfo;
+                taskInfo.Total.Accumulate(taskExecutionStats);
 
-                    void UpdateSingleStatistics(TasksInfo summarizedTaskInfo, TaskExecutionStats infoToAdd, TaskOrTargetTelemetryKey kkey)
-                    {
-                        summarizedTaskInfo.Total.AddAnother(infoToAdd);
-                        if (kkey.IsFromNugetCache)
-                        {
-                            summarizedTaskInfo.FromNuget.AddAnother(infoToAdd);
-                        }
-                    }
+                if (key.IsNuget)
+                {
+                    taskInfo.FromNuget.Accumulate(taskExecutionStats);
                 }
             }
 
             private TasksInfo BuiltinTasksInfo { get; } = new TasksInfo();
+
             private TasksInfo CustomTasksInfo { get; } = new TasksInfo();
 
             private class TasksInfo
             {
                 public TaskExecutionStats Total { get; } = TaskExecutionStats.CreateEmpty();
+
                 public TaskExecutionStats FromNuget { get; } = TaskExecutionStats.CreateEmpty();
             }
 
-            public override TasksSummary? Read(
+            public override TasksSummaryConverter? Read(
                 ref Utf8JsonReader reader,
                 Type typeToConvert,
                 JsonSerializerOptions options) =>
@@ -275,7 +296,7 @@ private class TasksInfo
 
             public override void Write(
                 Utf8JsonWriter writer,
-                TasksSummary value,
+                TasksSummaryConverter value,
                 JsonSerializerOptions options)
             {
                 writer.WriteStartObject();
@@ -286,21 +307,19 @@ public override void Write(
                 void WriteStat(Utf8JsonWriter writer, TasksInfo tasksInfo, string name)
                 {
                     writer.WriteStartObject(name);
-                    WriteSingleStat(writer, tasksInfo.Total, "Total", true);
-                    WriteSingleStat(writer, tasksInfo.FromNuget, "FromNuget", false);
+                    WriteSingleStat(writer, tasksInfo.Total, nameof(tasksInfo.Total));
+                    WriteSingleStat(writer, tasksInfo.FromNuget, nameof(tasksInfo.FromNuget));
                     writer.WriteEndObject();
                 }
 
-                void WriteSingleStat(Utf8JsonWriter writer, TaskExecutionStats stats, string name, bool writeIfEmpty)
+                void WriteSingleStat(Utf8JsonWriter writer, TaskExecutionStats stats, string name)
                 {
                     if (stats.ExecutionsCount > 0)
                     {
                         writer.WriteStartObject(name);
-                        writer.WriteNumber("TotalExecutionsCount", stats.ExecutionsCount);
-                        // We do not want decimals
-                        writer.WriteNumber("CumulativeExecutionTimeMs", (long)stats.CumulativeExecutionTime.TotalMilliseconds);
-                        // We do not want decimals
-                        writer.WriteNumber("CumulativeConsumedMemoryKB", stats.TotalMemoryConsumption / 1024);
+                        writer.WriteNumber(nameof(stats.ExecutionsCount), stats.ExecutionsCount);
+                        writer.WriteNumber(nameof(stats.CumulativeExecutionTime.TotalMilliseconds), stats.CumulativeExecutionTime.TotalMilliseconds);
+                        writer.WriteNumber(nameof(stats.TotalMemoryBytes), stats.TotalMemoryBytes);
                         writer.WriteEndObject();
                     }
                 }
diff --git a/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs b/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs
index b3522dbf64a..58ea242088b 100644
--- a/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs
+++ b/src/Build/TelemetryInfra/TelemetryForwarderProvider.cs
@@ -5,6 +5,7 @@
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.TelemetryInfra;
diff --git a/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs b/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs
index 57d822d7194..bf5303e2c09 100644
--- a/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/WorkerNodeTelemetryEventArgs_Tests.cs
@@ -9,6 +9,7 @@
 using System.Threading.Tasks;
 using Shouldly;
 using Xunit;
+using Microsoft.Build.Framework.Telemetry;
 
 namespace Microsoft.Build.Framework.UnitTests
 {
diff --git a/src/Framework/IEventSource5.cs b/src/Framework/IEventSource5.cs
index 6ce4f300c30..cd56c63fb40 100644
--- a/src/Framework/IEventSource5.cs
+++ b/src/Framework/IEventSource5.cs
@@ -1,5 +1,6 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
+using Microsoft.Build.Framework.Telemetry;
 
 namespace Microsoft.Build.Framework
 {
diff --git a/src/Framework/Telemetry/IWorkerNodeTelemetryData.cs b/src/Framework/Telemetry/IWorkerNodeTelemetryData.cs
index 7f439252482..a0303e4a4e2 100644
--- a/src/Framework/Telemetry/IWorkerNodeTelemetryData.cs
+++ b/src/Framework/Telemetry/IWorkerNodeTelemetryData.cs
@@ -3,7 +3,7 @@
 
 using System.Collections.Generic;
 
-namespace Microsoft.Build.Framework;
+namespace Microsoft.Build.Framework.Telemetry;
 
 internal interface IWorkerNodeTelemetryData
 {
diff --git a/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs b/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs
index 95e38567587..2208f4f2f5b 100644
--- a/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs
+++ b/src/Framework/Telemetry/InternalTelemetryForwardingLogger.cs
@@ -1,12 +1,12 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-namespace Microsoft.Build.Framework;
+namespace Microsoft.Build.Framework.Telemetry;
 
 /// <remarks>
 /// Ensure that events filtering is in sync with InternalTelemetryConsumingLogger.
 /// </remarks>
-internal class InternalTelemeteryForwardingLogger : IForwardingLogger
+internal class InternalTelemetryForwardingLogger : IForwardingLogger
 {
     public IEventRedirector? BuildEventRedirector { get; set; }
 
diff --git a/src/Framework/Telemetry/TaskExecutionStats.cs b/src/Framework/Telemetry/TaskExecutionStats.cs
index b3f1564d615..533599734fd 100644
--- a/src/Framework/Telemetry/TaskExecutionStats.cs
+++ b/src/Framework/Telemetry/TaskExecutionStats.cs
@@ -3,14 +3,21 @@
 
 using System;
 
-namespace Microsoft.Build.Framework;
+namespace Microsoft.Build.Framework.Telemetry;
 
+/// <summary>
+/// Represents the execution statistics of tasks executed on a node.
+/// </summary>
 internal class TaskExecutionStats(TimeSpan cumulativeExecutionTime, int executionsCount, long totalMemoryConsumption)
 {
     private TaskExecutionStats()
         : this(TimeSpan.Zero, 0, 0)
     { }
 
+    /// <summary>
+    /// Creates an instance of <see cref="TaskExecutionStats"/> initialized to zero values.
+    /// </summary>
+    /// <returns>Empty task execution statistics.</returns>
     internal static TaskExecutionStats CreateEmpty()
         => new();
 
@@ -22,21 +29,25 @@ internal static TaskExecutionStats CreateEmpty()
     /// <summary>
     /// Total memory consumption (across all executions) in bytes.
     /// </summary>
-    public long TotalMemoryConsumption { get; set; } = totalMemoryConsumption;
+    public long TotalMemoryBytes { get; set; } = totalMemoryConsumption;
 
     /// <summary>
-    /// Total number of execution of the tasks in all nodes for all projects.
+    /// Total number of executions of the task.
     /// </summary>
     public int ExecutionsCount { get; set; } = executionsCount;
 
-    internal void AddAnother(TaskExecutionStats another)
+    /// <summary>
+    /// Accumulates statistics from another instance into this one.
+    /// </summary>
+    /// <param name="other">Statistics to add to this instance.</param>
+    internal void Accumulate(TaskExecutionStats other)
     {
-        this.CumulativeExecutionTime += another.CumulativeExecutionTime;
-        this.TotalMemoryConsumption += another.TotalMemoryConsumption;
-        this.ExecutionsCount += another.ExecutionsCount;
+        this.CumulativeExecutionTime += other.CumulativeExecutionTime;
+        this.TotalMemoryBytes += other.TotalMemoryBytes;
+        this.ExecutionsCount += other.ExecutionsCount;
     }
 
-    // We need custom Equals for easier assertations in tests
+    // We need custom Equals for easier assertions in tests
     public override bool Equals(object? obj)
     {
         if (obj is TaskExecutionStats other)
@@ -48,7 +59,7 @@ public override bool Equals(object? obj)
 
     protected bool Equals(TaskExecutionStats other)
         => CumulativeExecutionTime.Equals(other.CumulativeExecutionTime) &&
-           TotalMemoryConsumption == other.TotalMemoryConsumption &&
+           TotalMemoryBytes == other.TotalMemoryBytes &&
            ExecutionsCount == other.ExecutionsCount;
 
     // Needed since we override Equals
@@ -57,7 +68,7 @@ public override int GetHashCode()
         unchecked
         {
             var hashCode = CumulativeExecutionTime.GetHashCode();
-            hashCode = (hashCode * 397) ^ TotalMemoryConsumption.GetHashCode();
+            hashCode = (hashCode * 397) ^ TotalMemoryBytes.GetHashCode();
             hashCode = (hashCode * 397) ^ ExecutionsCount.GetHashCode();
             return hashCode;
         }
diff --git a/src/Framework/Telemetry/TaskOrTargetTelemetryKey.cs b/src/Framework/Telemetry/TaskOrTargetTelemetryKey.cs
index 864ce31e7a9..5647f2fdadd 100644
--- a/src/Framework/Telemetry/TaskOrTargetTelemetryKey.cs
+++ b/src/Framework/Telemetry/TaskOrTargetTelemetryKey.cs
@@ -3,36 +3,83 @@
 
 using System;
 
-namespace Microsoft.Build.Framework;
+namespace Microsoft.Build.Framework.Telemetry;
 
+/// <summary>
+/// Represents a unique key for task or target telemetry data.
+/// </summary>
+/// <remarks>
+/// Used as a dictionary key for tracking execution metrics of tasks and targets.
+/// </remarks>
 internal struct TaskOrTargetTelemetryKey : IEquatable<TaskOrTargetTelemetryKey>
 {
+    /// <summary>
+    /// Initializes a new instance of the <see cref="TaskOrTargetTelemetryKey"/> struct with all properties.
+    /// </summary>
+    /// <param name="name">The name of the task or target.</param>
+    /// <param name="isCustom">Indicates whether the task/target is custom.</param>
+    /// <param name="isFromNugetCache">Indicates whether the task/target is from NuGet cache.</param>
+    /// <param name="isFromMetaProject">Indicates whether the task/target is from a meta project.</param>
     public TaskOrTargetTelemetryKey(string name, bool isCustom, bool isFromNugetCache, bool isFromMetaProject)
     {
         Name = name;
         IsCustom = isCustom;
-        IsFromNugetCache = isFromNugetCache;
-        IsFromMetaProject = isFromMetaProject;
+        IsNuget = isFromNugetCache;
+        IsMetaProj = isFromMetaProject;
     }
 
+    /// <summary>
+    /// Initializes a new instance of the <see cref="TaskOrTargetTelemetryKey"/> struct without meta project flag.
+    /// </summary>
+    /// <param name="name">The name of the task or target.</param>
+    /// <param name="isCustom">Indicates whether the task/target is custom.</param>
+    /// <param name="isFromNugetCache">Indicates whether the task/target is from NuGet cache.</param>
     public TaskOrTargetTelemetryKey(string name, bool isCustom, bool isFromNugetCache)
     {
         Name = name;
         IsCustom = isCustom;
-        IsFromNugetCache = isFromNugetCache;
+        IsNuget = isFromNugetCache;
+        IsMetaProj = false;
     }
 
-    public TaskOrTargetTelemetryKey(string name) => Name = name;
+    /// <summary>
+    /// Initializes a new instance of the <see cref="TaskOrTargetTelemetryKey"/> struct with name only.
+    /// </summary>
+    /// <param name="name">The name of the task or target.</param>
+    public TaskOrTargetTelemetryKey(string name) : this(name, false, false, false) { }
 
+    /// <summary>
+    /// Enables explicit casting from string to <see cref="TaskOrTargetTelemetryKey"/>.
+    /// </summary>
+    /// <param name="key">The string name to convert to a telemetry key.</param>
+    /// <returns>A telemetry key with the given name.</returns>
     public static explicit operator TaskOrTargetTelemetryKey(string key) => new(key);
 
+    /// <summary>
+    /// Gets the name of the task or target.
+    /// </summary>
+    /// <remarks>
+    /// This name is used as the primary key in serialized JSON data.
+    /// It is hashed when the task/target is custom or from a meta project.
+    /// </remarks>
     public string Name { get; }
-    // Indicate custom targets/task - those must be hashed.
+
+    /// <summary>
+    /// Indicates whether the task/target is custom.
+    /// </summary>
     public bool IsCustom { get; }
-    // Indicate targets/tasks sourced from nuget cache - those can be custom or MSFT provided ones.
-    public bool IsFromNugetCache { get; }
-    // Indicate targets/tasks generated during build - those must be hashed (as they contain paths).
-    public bool IsFromMetaProject { get; }
+
+    /// <summary>
+    /// Indicates whether the task/target is from NuGet cache.
+    /// </summary>
+    /// <remarks>Those can be custom or MSFT provided ones.</remarks>
+    public bool IsNuget { get; }
+
+    /// <summary>
+    /// Indicates whether the task/target is generated during build from a metaproject.
+    /// </summary>
+    /// <remarks>Those must be hashed (as they contain paths).</remarks>
+    public bool IsMetaProj { get; }
 
     public override bool Equals(object? obj)
     {
@@ -46,8 +93,8 @@ public override bool Equals(object? obj)
     public bool Equals(TaskOrTargetTelemetryKey other)
         => string.Equals(Name, other.Name, StringComparison.OrdinalIgnoreCase) &&
            IsCustom == other.IsCustom &&
-           IsFromNugetCache == other.IsFromNugetCache &&
-           IsFromMetaProject == other.IsFromMetaProject;
+           IsNuget == other.IsNuget &&
+           IsMetaProj == other.IsMetaProj;
 
     // We need hash code and equals - so that we can stuff data into dictionaries
     public override int GetHashCode()
@@ -56,11 +103,11 @@ public override int GetHashCode()
         {
             var hashCode = Name.GetHashCode();
             hashCode = (hashCode * 397) ^ IsCustom.GetHashCode();
-            hashCode = (hashCode * 397) ^ IsFromNugetCache.GetHashCode();
-            hashCode = (hashCode * 397) ^ IsFromMetaProject.GetHashCode();
+            hashCode = (hashCode * 397) ^ IsNuget.GetHashCode();
+            hashCode = (hashCode * 397) ^ IsMetaProj.GetHashCode();
             return hashCode;
         }
     }
 
-    public override string ToString() => $"{Name},Custom:{IsCustom},IsFromNugetCache:{IsFromNugetCache},IsFromMetaProject:{IsFromMetaProject}";
+    public override string ToString() => $"{Name},Custom:{IsCustom},IsFromNugetCache:{IsNuget},IsFromMetaProject:{IsMetaProj}";
 }
diff --git a/src/Framework/Telemetry/TelemetryConstants.cs b/src/Framework/Telemetry/TelemetryConstants.cs
index 87df7c68e1c..f373760de7c 100644
--- a/src/Framework/Telemetry/TelemetryConstants.cs
+++ b/src/Framework/Telemetry/TelemetryConstants.cs
@@ -48,3 +48,12 @@ internal static class TelemetryConstants
     /// </summary>
     public const string InnerBuildDurationPropertyName = "InnerBuildDurationInMilliseconds";
 }
+
+internal static class NodeTelemetryTags
+{
+    // These properties can't use nameof since they're not tied to a specific class property
+    public const string Tasks = "Tasks";
+    public const string Targets = "Targets";
+    public const string TargetsSummary = "TargetsSummary";
+    public const string TasksSummary = "TasksSummary";
+}
diff --git a/src/Framework/Telemetry/WorkerNodeTelemetryData.cs b/src/Framework/Telemetry/WorkerNodeTelemetryData.cs
index 4b5afad229f..d643045ffe6 100644
--- a/src/Framework/Telemetry/WorkerNodeTelemetryData.cs
+++ b/src/Framework/Telemetry/WorkerNodeTelemetryData.cs
@@ -4,7 +4,7 @@
 using System;
 using System.Collections.Generic;
 
-namespace Microsoft.Build.Framework;
+namespace Microsoft.Build.Framework.Telemetry;
 
 internal class WorkerNodeTelemetryData : IWorkerNodeTelemetryData
 {
@@ -18,7 +18,7 @@ public void Add(IWorkerNodeTelemetryData other)
     {
         foreach (var task in other.TasksExecutionData)
         {
-            AddTask(task.Key, task.Value.CumulativeExecutionTime, task.Value.ExecutionsCount, task.Value.TotalMemoryConsumption);
+            AddTask(task.Key, task.Value.CumulativeExecutionTime, task.Value.ExecutionsCount, task.Value.TotalMemoryBytes);
         }
 
         foreach (var target in other.TargetsExecutionData)
@@ -39,7 +39,7 @@ public void AddTask(TaskOrTargetTelemetryKey task, TimeSpan cumulativeExectionTi
         {
             taskExecutionStats.CumulativeExecutionTime += cumulativeExectionTime;
             taskExecutionStats.ExecutionsCount += executionsCount;
-            taskExecutionStats.TotalMemoryConsumption += totalMemoryConsumption;
+            taskExecutionStats.TotalMemoryBytes += totalMemoryConsumption;
         }
     }
 
diff --git a/src/Framework/Telemetry/WorkerNodeTelemetryEventArgs.cs b/src/Framework/Telemetry/WorkerNodeTelemetryEventArgs.cs
index a416f4245ad..a2a11f16e82 100644
--- a/src/Framework/Telemetry/WorkerNodeTelemetryEventArgs.cs
+++ b/src/Framework/Telemetry/WorkerNodeTelemetryEventArgs.cs
@@ -6,7 +6,7 @@
 using System.IO;
 using Microsoft.Build.Shared;
 
-namespace Microsoft.Build.Framework;
+namespace Microsoft.Build.Framework.Telemetry;
 
 internal sealed class WorkerNodeTelemetryEventArgs(IWorkerNodeTelemetryData workerNodeTelemetryData) : BuildEventArgs
 {
@@ -24,7 +24,7 @@ internal override void WriteToStream(BinaryWriter writer)
             WriteToStream(writer, entry.Key);
             writer.Write(entry.Value.CumulativeExecutionTime.Ticks);
             writer.Write(entry.Value.ExecutionsCount);
-            writer.Write(entry.Value.TotalMemoryConsumption);
+            writer.Write(entry.Value.TotalMemoryBytes);
         }
 
         writer.Write7BitEncodedInt(WorkerNodeTelemetryData.TargetsExecutionData.Count);
@@ -62,8 +62,8 @@ private static void WriteToStream(BinaryWriter writer, TaskOrTargetTelemetryKey
     {
         writer.Write(key.Name);
         writer.Write(key.IsCustom);
-        writer.Write(key.IsFromNugetCache);
-        writer.Write(key.IsFromMetaProject);
+        writer.Write(key.IsNuget);
+        writer.Write(key.IsMetaProj);
     }
 
     private static TaskOrTargetTelemetryKey ReadFromStream(BinaryReader reader)
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index bcdc4ac195c..f2447e47031 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -142,6 +142,7 @@ public Traits()
         public bool FrameworkTelemetryOptOut = IsEnvVarOneOrTrue("MSBUILD_TELEMETRY_OPTOUT");
         public double? TelemetrySampleRateOverride = ParseDoubleFromEnvironmentVariable("MSBUILD_TELEMETRY_SAMPLE_RATE");
         public bool ExcludeTasksDetailsFromTelemetry = IsEnvVarOneOrTrue("MSBUILDTELEMETRYEXCLUDETASKSDETAILS");
+        public bool FlushNodesTelemetryIntoConsole = IsEnvVarOneOrTrue("MSBUILDFLUSHNODESTELEMETRYINTOCONSOLE");
 
         // for VS17.14
         public readonly bool TelemetryOptIn = IsEnvVarOneOrTrue("MSBUILD_TELEMETRY_OPTIN");
@@ -163,9 +164,15 @@ private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVa
                 : defaultValue;
         }
 
+        /// <summary>
+        /// Parse a double from an environment variable with invariant culture.
+        /// </summary>
         private static double? ParseDoubleFromEnvironmentVariable(string environmentVariable)
         {
-            return double.TryParse(Environment.GetEnvironmentVariable(environmentVariable), out double result)
+            return double.TryParse(Environment.GetEnvironmentVariable(environmentVariable),
+                                  NumberStyles.Float,
+                                  CultureInfo.InvariantCulture,
+                                  out double result)
                 ? result
                 : null;
         }
diff --git a/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj b/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj
index 6282c3a2134..0d02925d4e9 100644
--- a/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj
+++ b/src/Package/Microsoft.Build.UnGAC/Microsoft.Build.UnGAC.csproj
@@ -24,6 +24,6 @@
     <SwrProperty Include="Version=$(VsixVersion)" />
 
     <!-- our swr file must be picked up, this is how we set that. -->
-    <SwrFile Include="exe.swr" Condition=" '$(MSBuildRuntimeType)' == 'Full' " />
+    <SwrFile Include="exe.swr" />
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 3c617c54014..65283a2591b 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Framework;
 
 #if !TASKHOST
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Experimental.BuildCheck;
 #endif
 
diff --git a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
index b63fa1e4e9e..d45c242ed70 100644
--- a/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
+++ b/src/StringTools.UnitTests/StringTools.UnitTests.net35.csproj
@@ -1,9 +1,5 @@
 <Project Sdk="Microsoft.NET.Sdk">
 
-  <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
-       a .props file that prevents building the project from doing much of anything. -->
-  <Import Project="$(RepoRoot)eng\ProducesNoOutput.Settings.props" Condition="'$(MSBuildRuntimeType)' == 'Core'" />
-
   <PropertyGroup>
     <TargetFrameworks>$(FullFrameworkTFM)</TargetFrameworks>
     <PlatformTarget>$(RuntimeOutputPlatformTarget)</PlatformTarget>
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index 4809373c67c..5015904acba 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -1,7 +1,6 @@
 <Project Sdk="Microsoft.NET.Sdk">
   <PropertyGroup>
-    <TargetFrameworks>$(LibraryTargetFrameworks)</TargetFrameworks>
-    <TargetFrameworks Condition="'$(MSBuildRuntimeType)' != 'Core'">$(LibraryTargetFrameworks);net35</TargetFrameworks>
+    <TargetFrameworks>$(LibraryTargetFrameworks);net35</TargetFrameworks>
     <PlatformTarget>AnyCPU</PlatformTarget>
     <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
     <IsPackable>true</IsPackable>
diff --git a/src/Tasks/Resources/xlf/Strings.it.xlf b/src/Tasks/Resources/xlf/Strings.it.xlf
index 82941a83d6b..5614177333f 100644
--- a/src/Tasks/Resources/xlf/Strings.it.xlf
+++ b/src/Tasks/Resources/xlf/Strings.it.xlf
@@ -2839,7 +2839,7 @@
       </trans-unit>
       <trans-unit id="WriteCodeFragment.CouldNotInferParameterType">
         <source>Could not infer the type of parameter "{0}" because the attribute type is unknown. The value will be treated as a string.</source>
-        <target state="translated">Non è stato possibile inferire il tipo di parametro "{0}" perché il tipo di attributo è sconosciuto. Il valore sarà trattto come una stringa.</target>
+        <target state="translated">Non è stato possibile inferire il tipo di parametro "{0}" perché il tipo di attributo è sconosciuto. Il valore sarà tratto come una stringa.</target>
         <note />
       </trans-unit>
       <trans-unit id="WriteCodeFragment.MultipleConstructorsFound">
