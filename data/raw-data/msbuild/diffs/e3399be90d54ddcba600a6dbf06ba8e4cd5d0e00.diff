diff --git a/.github/issue_template.md b/.github/issue_template.md
index 32b10a00408..7aedcdf41d2 100644
--- a/.github/issue_template.md
+++ b/.github/issue_template.md
@@ -32,7 +32,7 @@ Command line
 ```
 msbuild /bl
 ```
-### Expected  behavior
+### Expected behavior
 
 
 ### Actual behavior
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 77a587a3b3b..c816e8f283d 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -147,6 +147,13 @@ stages:
         ArtifactName: logs
       condition: succeededOrFailed()
 
+    - task: PublishBuildArtifacts@1
+      displayName: 'Publish Artifact: symbols'
+      inputs:
+        PathtoPublish: 'artifacts\bin'
+        ArtifactName: symbols
+      condition: succeededOrFailed()
+
     # Publishes setup VSIXes to a drop.
     # Note: The insertion tool looks for the display name of this task in the logs.
     - task: ms-vseng.MicroBuildTasks.4305a8de-ba66-4d8b-b2d1-0dc4ecbbf5e8.MicroBuildUploadVstsDropFolder@1
diff --git a/README.md b/README.md
index 90316ac0a6e..ec95e8f97d6 100644
--- a/README.md
+++ b/README.md
@@ -6,11 +6,15 @@ For more information on MSBuild, see the [MSBuild documentation](https://docs.mi
 
 ### Build Status
 
-The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.5 and a corresponding version of the .NET Core SDK.
+The current development branch is `master`. Changes in `master` will go into a future update of MSBuild, which will release with Visual Studio 16.6 and a corresponding version of the .NET Core SDK.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=master)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=master)
 
-We have forked for MSBuild 16.4 in the branch [`vs16.4`](https://github.com/Microsoft/msbuild/tree/vs16.4). Changes to that branch need special approval.
+We have forked for MSBuild 16.5 in the branch [`vs16.5`](https://github.com/Microsoft/msbuild/tree/vs16.5). Changes to that branch need special approval.
+
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.5)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.5)
+
+MSBuild 16.4 builds from the branch [`vs16.4`](https://github.com/Microsoft/msbuild/tree/vs16.4). Only high-priority bugfixes will be considered for servicing 16.4.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs16.4)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=86&branchName=vs16.4)
 
diff --git a/documentation/specs/task-isolation-and-dependencies.md b/documentation/specs/task-isolation-and-dependencies.md
index db4ca2af03d..f130c37e8a4 100644
--- a/documentation/specs/task-isolation-and-dependencies.md
+++ b/documentation/specs/task-isolation-and-dependencies.md
@@ -3,12 +3,13 @@
 Tasks in MSBuild are dynamically loaded assemblies with potentially separate and colliding dependency trees. Currently MSBuild on .NET Core has no isolation between tasks and as such only one version of any given assembly can be loaded. Prime example of this is Newtonsoft.Json which has multiple versions, but all the tasks must agree on it to work.
 This problem is also described in #1754.
 
-## Possible solution
+## Solution
 Use [`AssemblyLoadContext`](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.loader.assemblyloadcontext?view=netcore-2.2) (ALC) to provide binding isolation for task assemblies. Each task assembly would be loaded into its own ALC instance.
 * The ALC would resolve all dependencies of the task assemblies (see dependency resolution below)
 * ALC would fallback to the Default for dependencies which the assembly doesn't carry with itself (frameworks and so on)
 * ALC would probably have to forcefully fallback for MSBuild assemblies since it's possible that tasks will carry these, but the system requires for the MSBuild assemblies to be shared.
-We would probably also want to load groups of tasks which belong together into the same ALC (for example based on their location on disk) to improve performance. This will need some care as there's no guarantee that two random tasks have compatible dependency trees.
+
+We also want to load groups of tasks which belong together into the same ALC (for example based on their location on disk) to improve performance. This will need some care as there's no guarantee that two random tasks have compatible dependency trees. As implemented, each task assembly is loaded into its own ALC.
 
 ## Potential risks
 * Has some small probability of causing breaks. Currently all assemblies from all tasks are loaded into the default context and thus are "visible" to everybody. Tasks with following properties might not work:
@@ -20,13 +21,11 @@ We would probably also want to load groups of tasks which belong together into t
 * None of these changes would have any effect on MSBuild on .NET Framework
 * Task isolation alone could be achieved on existing MSBuild
 
-
-
 # Task dependency resolution
 ## Problem definition
 Tasks with complex and specifically platform specific dependencies don't work out of the box. For example if a task uses [`LibGit2Sharp`](https://www.nuget.org/packages/LibGit2Sharp) package it will not work as is. `LibGit2Sharp` has native dependencies which are platform specific. While the package carries all of them, there's no built in support for the task to load the right ones. For example [source link](https://github.com/dotnet/sourcelink/blob/master/src/Microsoft.Build.Tasks.Git/GitLoaderContext.cs) runs into this problem.
 
-## Possible solution
+## Solution
 .NET Core uses `.deps.json` files to describe dependencies of components. It would be natural to treat task assemblies as components and use associated .deps.json file to determine their dependencies. This would make the system work nicely end to end with the .NET Core CLI/SDK and VS integration.
 In .NET Core 3 there's a new type [`AssemblyDependencyResolver`](https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/src/System/Runtime/Loader/AssemblyDependencyResolver.cs) which implements parsing and processing of a `.deps.json` for a component (or assembly). The usage is to create an instance of the resolver pointing to the assembly (in MSBuild case the task assembly). The resolver parses the `.deps.json` and stores the information. It exposes two methods to resolve managed and native dependencies.
 It was designed to be used as the underlying piece to implement custom ALC. So it would work nicely with task isolation above.
@@ -36,3 +35,5 @@ It was designed to be used as the underlying piece to implement custom ALC. So i
 
 ## Additional consideration
 * Task dependency resolution requires APIs which are only available in .NET Core 3.0 (no plan to backport), as such MSBuild will have to target netcoreapp3.0 to use these APIs.
+
+We decided not to implement `AssemblyDependencyResolver` in the .NET Core 3.x timeframe because of the uncertain impact of the change. We should reconsider in the .NET 5 timeframe.
diff --git a/eng/Packages.props b/eng/Packages.props
index 80e14eb1d86..7496689a0f5 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -39,6 +39,7 @@
     <PackageReference Update="System.Runtime.Serialization.Primitives" Version="4.1.1" />
     <PackageReference Update="System.Security.Principal.Windows" Version="4.3.0" />
     <PackageReference Update="System.Text.Encoding.CodePages" Version="4.0.1" />
+    <PackageReference Update="System.Text.Json" Version="4.6.0" />
     <PackageReference Update="System.Threading.Tasks.Dataflow" Version="4.9.0" />
     <PackageReference Update="System.Threading.Thread" Version="4.0.0" />
     <PackageReference Update="System.Xml.XPath" Version="4.3.0" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 5626cbf8188..4ee2e210efd 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.19616.5">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="1.0.0-beta.20077.3">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>d4a1ce6278134f5dc25843e228d0498203031e61</Sha>
+      <Sha>69a67461460d99125742d5c2dd94dad83add84a3</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index f4113b3848d..4d68046b631 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -15,7 +15,7 @@
     <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
   </PropertyGroup>
   <PropertyGroup>
-    <VersionPrefix>16.5.0</VersionPrefix>
+    <VersionPrefix>16.6.0</VersionPrefix>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
diff --git a/eng/cibuild_bootstrapped_msbuild.ps1 b/eng/cibuild_bootstrapped_msbuild.ps1
index 60fba4bc47e..ca978944bd6 100644
--- a/eng/cibuild_bootstrapped_msbuild.ps1
+++ b/eng/cibuild_bootstrapped_msbuild.ps1
@@ -106,6 +106,11 @@ try {
 
   if ($buildStage1)
   {
+    if (Test-Path $Stage1Dir)
+    {
+      Remove-Item -Force -Recurse $Stage1Dir
+    }
+
     Move-Item -Path $ArtifactsDir -Destination $Stage1Dir -Force
   }
 
@@ -137,4 +142,4 @@ finally {
   if ($prepareMachine) {
     Stop-Processes
   }
-}
\ No newline at end of file
+}
diff --git a/eng/common/darc-init.ps1 b/eng/common/darc-init.ps1
index 46d175fdfdc..b94c2f4e411 100644
--- a/eng/common/darc-init.ps1
+++ b/eng/common/darc-init.ps1
@@ -27,7 +27,7 @@ function InstallDarcCli ($darcVersion) {
 
   Write-Host "Installing Darc CLI version $darcVersion..."
   Write-Host "You may need to restart your command window if this is the first dotnet tool you have installed."
-  & "$dotnet" tool install $darcCliPackageName --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g
+  & "$dotnet" tool install $darcCliPackageName --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g --framework netcoreapp2.1
 }
 
 InstallDarcCli $darcVersion
diff --git a/global.json b/global.json
index d000e2fd755..ec1e5d920bf 100644
--- a/global.json
+++ b/global.json
@@ -12,6 +12,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.19616.5"
+    "Microsoft.DotNet.Arcade.Sdk": "1.0.0-beta.20077.3"
   }
 }
diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 89f0b331489..4efc2c2a9d4 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -1102,6 +1102,8 @@ public ProjectInstance(string projectFile, System.Collections.Generic.IDictionar
         public int EvaluationId { get { throw null; } set { } }
         public string FullPath { get { throw null; } }
         public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyList<string> ImportPaths { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyList<string> ImportPathsIncludingDuplicates { get { throw null; } }
         public System.Collections.Generic.List<string> InitialTargets { get { throw null; } }
         public bool IsImmutable { get { throw null; } }
         public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectItemDefinitionInstance> ItemDefinitions { get { throw null; } }
@@ -1128,6 +1130,8 @@ public ProjectInstance(string projectFile, System.Collections.Generic.IDictionar
         public bool EvaluateCondition(string condition) { throw null; }
         public string ExpandString(string unexpandedValue) { throw null; }
         public Microsoft.Build.Execution.ProjectInstance FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) { throw null; }
+        public static Microsoft.Build.Execution.ProjectInstance FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
+        public static Microsoft.Build.Execution.ProjectInstance FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) { throw null; }
         public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance> GetItems(string itemType) { throw null; }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 4c99d69334e..287be1139eb 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -1096,6 +1096,8 @@ public ProjectInstance(string projectFile, System.Collections.Generic.IDictionar
         public int EvaluationId { get { throw null; } set { } }
         public string FullPath { get { throw null; } }
         public System.Collections.Generic.IDictionary<string, string> GlobalProperties { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyList<string> ImportPaths { get { throw null; } }
+        public System.Collections.Generic.IReadOnlyList<string> ImportPathsIncludingDuplicates { get { throw null; } }
         public System.Collections.Generic.List<string> InitialTargets { get { throw null; } }
         public bool IsImmutable { get { throw null; } }
         public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectItemDefinitionInstance> ItemDefinitions { get { throw null; } }
@@ -1122,6 +1124,8 @@ public ProjectInstance(string projectFile, System.Collections.Generic.IDictionar
         public bool EvaluateCondition(string condition) { throw null; }
         public string ExpandString(string unexpandedValue) { throw null; }
         public Microsoft.Build.Execution.ProjectInstance FilteredCopy(Microsoft.Build.Execution.RequestedProjectState filter) { throw null; }
+        public static Microsoft.Build.Execution.ProjectInstance FromFile(string file, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
+        public static Microsoft.Build.Execution.ProjectInstance FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemDefinitionInstance item) { throw null; }
         public static string GetEvaluatedItemIncludeEscaped(Microsoft.Build.Execution.ProjectItemInstance item) { throw null; }
         public System.Collections.Generic.ICollection<Microsoft.Build.Execution.ProjectItemInstance> GetItems(string itemType) { throw null; }
diff --git a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
index a1c01d9bd6c..a4e0c79e34e 100644
--- a/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.OM.UnitTests/Construction/SolutionFile_Tests.cs
@@ -7,6 +7,7 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Exceptions;
+using Shouldly;
 using Xunit;
 
 namespace Microsoft.Build.UnitTests.Construction
@@ -16,6 +17,72 @@ namespace Microsoft.Build.UnitTests.Construction
     /// </summary>
     public class SolutionFile_Tests
     {
+        [Theory]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects2"": [
+                      ""src\\Build\\Microsoft.Build.csproj"",
+                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
+                      ""src\\MSBuild\\MSBuild.csproj"",
+                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                [{
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      ""src\\Build\\Microsoft.Build.csproj"",
+                      ""src\\Framework\\Microsoft.Build.Framework.csproj"",
+                      ""src\\MSBuild\\MSBuild.csproj"",
+                      ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""
+                    ]
+                    }
+                }]
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
+                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
+                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
+                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterJsonParsingError")]
+        [InlineData(@"
+                {
+                  ""solution"": {
+                    ""path"": ""C:\\notAPath2\\MSBuild.Dev.sln"",
+                    ""projects"": [
+                      {""path"": ""src\\Build\\Microsoft.Build.csproj""},
+                      {""path"": ""src\\Framework\\Microsoft.Build.Framework.csproj""},
+                      {""path"": ""src\\MSBuild\\MSBuild.csproj""},
+                      {""path"": ""src\\Tasks.UnitTests\\Microsoft.Build.Tasks.UnitTests.csproj""}
+                    ]
+                    }
+                }
+                ", "MSBuild.SolutionFilterMissingSolutionError")]
+        public void InvalidSolutionFilters(string slnfValue, string exceptionReason)
+        {
+            Assert.False(File.Exists("C:\\notAPath2\\MSBuild.Dev.sln"));
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "Dev.sln");
+                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf", slnfValue.Replace(@"C:\\notAPath\\MSBuild.Dev.sln", sln.Path.Replace("\\", "\\\\")));
+                InvalidProjectFileException e = Should.Throw<InvalidProjectFileException>(() => SolutionFile.Parse(slnf.Path));
+                e.HelpKeyword.ShouldBe(exceptionReason);
+            }
+        }
+
         /// <summary>
         /// Test that a project with the C++ project guid and an extension of vcproj is seen as invalid.
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index 6b9360ee0ea..f2c4d85b94f 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1157,7 +1157,7 @@ private void InitializeHost(bool throwOnExecute)
             ProjectInstance project = CreateTestProject();
 
             TypeLoader typeLoader = new TypeLoader(IsTaskFactoryClass);
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             AssemblyLoadInfo loadInfo = AssemblyLoadInfo.Create(Assembly.GetAssembly(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory)).FullName, null);
 #else
             AssemblyLoadInfo loadInfo = AssemblyLoadInfo.Create(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).GetTypeInfo().FullName, null);
diff --git a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
index 716b94050f0..e13787dfe95 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
@@ -114,7 +114,7 @@ public void ConstructorWithNullLocation()
            );
         }
 
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// Test that an exception is thrown when the path to the task assembly is empty
         /// </summary>
@@ -267,7 +267,7 @@ public void TestTranslationWithNullDictionary()
             TaskHostConfiguration deserializedConfig = packet as TaskHostConfiguration;
 
             Assert.Equal(config.TaskName, deserializedConfig.TaskName);
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             Assert.Equal(config.TaskLocation, deserializedConfig.TaskLocation);
 #endif
             Assert.Null(deserializedConfig.TaskParameters);
@@ -305,7 +305,7 @@ public void TestTranslationWithEmptyDictionary()
             TaskHostConfiguration deserializedConfig = packet as TaskHostConfiguration;
 
             Assert.Equal(config.TaskName, deserializedConfig.TaskName);
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             Assert.Equal(config.TaskLocation, deserializedConfig.TaskLocation);
 #endif
             Assert.NotNull(deserializedConfig.TaskParameters);
@@ -348,7 +348,7 @@ public void TestTranslationWithValueTypesInDictionary()
             TaskHostConfiguration deserializedConfig = packet as TaskHostConfiguration;
 
             Assert.Equal(config.TaskName, deserializedConfig.TaskName);
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             Assert.Equal(config.TaskLocation, deserializedConfig.TaskLocation);
 #endif
             Assert.NotNull(deserializedConfig.TaskParameters);
@@ -389,7 +389,7 @@ public void TestTranslationWithITaskItemInDictionary()
             TaskHostConfiguration deserializedConfig = packet as TaskHostConfiguration;
 
             Assert.Equal(config.TaskName, deserializedConfig.TaskName);
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             Assert.Equal(config.TaskLocation, deserializedConfig.TaskLocation);
 #endif
             Assert.NotNull(deserializedConfig.TaskParameters);
@@ -429,7 +429,7 @@ public void TestTranslationWithITaskItemArrayInDictionary()
             TaskHostConfiguration deserializedConfig = packet as TaskHostConfiguration;
 
             Assert.Equal(config.TaskName, deserializedConfig.TaskName);
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             Assert.Equal(config.TaskLocation, deserializedConfig.TaskLocation);
 #endif
             Assert.NotNull(deserializedConfig.TaskParameters);
diff --git a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
index 0783ab0eaff..a6c6c5a59d9 100644
--- a/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionFile_Tests.cs
@@ -17,6 +17,64 @@ namespace Microsoft.Build.UnitTests.Construction
 {
     public class SolutionFile_Tests
     {
+        /// <summary>
+        /// Test that a solution filter file is parsed correctly, and it can accurately respond as to whether a project should be filtered out.
+        /// </summary>
+        [Fact]
+        public void ParseSolutionFilter()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder src = testEnvironment.CreateFolder(Path.Combine(folder.Path, "src"), createFolder: true);
+                TransientTestFile microsoftBuild = testEnvironment.CreateFile(src, "Microsoft.Build.csproj");
+                TransientTestFile msbuild = testEnvironment.CreateFile(src, "MSBuild.csproj");
+                TransientTestFile commandLineUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.CommandLine.UnitTests.csproj");
+                TransientTestFile tasksUnitTests = testEnvironment.CreateFile(src, "Microsoft.Build.Tasks.UnitTests.csproj");
+                // The important part of this .sln is that it has references to each of the four projects we just created.
+                TransientTestFile sln = testEnvironment.CreateFile(folder, "Microsoft.Build.Dev.sln",
+                    @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio 15
+                    VisualStudioVersion = 15.0.27004.2009
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build"", """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)) + @""", ""{69BE05E2-CBDA-4D27-9733-44E12B0F5627}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""MSBuild"", """ + Path.Combine("src", Path.GetFileName(msbuild.Path)) + @""", ""{6F92CA55-1D15-4F34-B1FE-56C0B7EB455E}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.CommandLine.UnitTests"", """ + Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path)) + @""", ""{0ADDBC02-0076-4159-B351-2BF33FAA46B2}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""Microsoft.Build.Tasks.UnitTests"", """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)) + @""", ""{CF999BDE-02B3-431B-95E6-E88D621D9CBF}""
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                        EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                    EndGlobalSection
+                    GlobalSection(SolutionProperties) = preSolution
+                        HideSolutionNode = FALSE
+                    EndGlobalSection
+                    GlobalSection(ExtensibilityGlobals) = postSolution
+                    EndGlobalSection
+                    EndGlobal
+                    ");
+                TransientTestFile slnf = testEnvironment.CreateFile(folder, "Dev.slnf",
+                    @"
+                    {
+                      ""solution"": {
+                        ""path"": """ + sln.Path.Replace("\\", "\\\\") + @""",
+                        ""projects"": [
+                          """ + Path.Combine("src", Path.GetFileName(microsoftBuild.Path)).Replace("\\", "\\\\") + @""",
+                          """ + Path.Combine("src", Path.GetFileName(tasksUnitTests.Path)).Replace("\\", "\\\\") + @"""
+                        ]
+                        }
+                    }");
+                SolutionFile sp = SolutionFile.Parse(slnf.Path);
+                Assert.True(sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(microsoftBuild.Path))) && sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(tasksUnitTests.Path))));
+                Assert.False(sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(commandLineUnitTests.Path))) || sp.ProjectShouldBuild(Path.Combine("src", Path.GetFileName(msbuild.Path))) || sp.ProjectShouldBuild(Path.Combine("src", "notAProject.csproj")));
+            }
+        }
+
         /// <summary>
         /// Test just the most basic, plain vanilla first project line.
         /// </summary>
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 655a4ad71c3..d2393c9798d 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -60,6 +60,95 @@ public void Dispose()
             ProjectCollection.GlobalProjectCollection.UnloadAllProjects();
         }
 
+        /// <summary>
+        /// Test that a solution filter file excludes projects not covered by its list of projects or their dependencies.
+        /// </summary>
+        [Fact]
+        public void SolutionFilterFiltersProjects()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);              
+                TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "ClassLibrary"), createFolder: true);
+                TransientTestFolder classLibSubFolder = testEnvironment.CreateFolder(Path.Combine(classLibFolder.Path, "ClassLibrary"), createFolder: true);
+                TransientTestFile classLibrary = testEnvironment.CreateFile(classLibSubFolder, "ClassLibrary.csproj",
+                    @"<Project>
+                  <Target Name=""ClassLibraryTarget"">
+                      <Message Text=""ClassLibraryBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "SimpleProject"), createFolder: true);
+                TransientTestFolder simpleProjectSubFolder = testEnvironment.CreateFolder(Path.Combine(simpleProjectFolder.Path, "SimpleProject"), createFolder: true);
+                TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectSubFolder, "SimpleProject.csproj",
+                    @"<Project DefaultTargets=""SimpleProjectTarget"">
+                  <Target Name=""SimpleProjectTarget"">
+                      <Message Text=""SimpleProjectBuilt""/>
+                  </Target>
+                  </Project>
+                    ");
+                TransientTestFile solutionFile = testEnvironment.CreateFile(simpleProjectFolder, "SimpleProject.sln",
+                    @"
+                    Microsoft Visual Studio Solution File, Format Version 12.00
+                    # Visual Studio Version 16
+                    VisualStudioVersion = 16.0.29326.124
+                    MinimumVisualStudioVersion = 10.0.40219.1
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""SimpleProject"", """ + Path.Combine("SimpleProject", "SimpleProject.csproj") + @""", ""{79B5EBA6-5D27-4976-BC31-14422245A59A}""
+                    EndProject
+                    Project(""{9A19103F-16F7-4668-BE54-9A1E7A4F7556}"") = ""ClassLibrary"", """ + Path.Combine("..", "ClassLibrary", "ClassLibrary", "ClassLibrary.csproj") + @""", ""{8EFCCA22-9D51-4268-90F7-A595E11FCB2D}""
+                    EndProject
+                    Global
+                        GlobalSection(SolutionConfigurationPlatforms) = preSolution
+                            Debug|Any CPU = Debug|Any CPU
+                            Release|Any CPU = Release|Any CPU
+                            EndGlobalSection
+                        GlobalSection(ProjectConfigurationPlatforms) = postSolution
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {79B5EBA6-5D27-4976-BC31-14422245A59A}.Release|Any CPU.Build.0 = Release|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {8EFCCA22-9D51-4268-90F7-A595E11FCB2D}.Release|Any CPU.Build.0 = Release|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Debug|Any CPU.Build.0 = Debug|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.ActiveCfg = Release|Any CPU
+                            {06A4DD1B-5027-41EF-B72F-F586A5A83EA5}.Release|Any CPU.Build.0 = Release|Any CPU
+                        EndGlobalSection
+                        GlobalSection(SolutionProperties) = preSolution
+                            HideSolutionNode = FALSE
+                        EndGlobalSection
+                        GlobalSection(ExtensibilityGlobals) = postSolution
+                            SolutionGuid = {DE7234EC-0C4D-4070-B66A-DCF1B4F0CFEF}
+                        EndGlobalSection
+                    EndGlobal
+                ");
+                TransientTestFile filterFile = testEnvironment.CreateFile(folder, "solutionFilter.slnf",
+                    @"
+                {
+                  ""solution"": {
+                    ""path"": """ + solutionFile.Path.Replace("\\", "\\\\") + @""",
+                    ""projects"": [
+                      """ + Path.Combine("SimpleProject", "SimpleProject.csproj").Replace("\\", "\\\\") + @"""
+                    ]
+                    }
+                }
+                ");
+                SolutionFile solution = SolutionFile.Parse(filterFile.Path);
+                ILoggingService mockLogger = CreateMockLoggingService();
+                ProjectInstance[] instances = SolutionProjectGenerator.Generate(solution, null, null, _buildEventContext, mockLogger);
+                instances.ShouldHaveSingleItem();
+
+                // Check that dependencies are built, and non-dependencies in the .sln are not.
+                MockLogger logger = new MockLogger(output);
+                instances[0].Build(targets: null, new List<ILogger> { logger }).ShouldBeTrue();
+                logger.AssertLogContains(new string[] { "SimpleProjectBuilt" });
+                logger.AssertLogDoesntContain("ClassLibraryBuilt");
+            }
+        }
+
         /// <summary>
         /// Verify the AddNewErrorWarningMessageElement method
         /// </summary>
diff --git a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
index c40fabd96a9..9271584b5ff 100644
--- a/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
+++ b/src/Build.UnitTests/Definition/ProjectEvaluationContext_Tests.cs
@@ -7,11 +7,12 @@
 using System.Linq;
 using System.Xml;
 using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Construction;
 using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Evaluation.Context;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
 using Microsoft.Build.Unittest;
 using Shouldly;
 using Xunit;
@@ -121,6 +122,45 @@ public void ReevaluationShouldNotReuseInitialContext(EvaluationContext.SharingPo
             }
         }
 
+        [Theory]
+        [InlineData(EvaluationContext.SharingPolicy.Shared)]
+        [InlineData(EvaluationContext.SharingPolicy.Isolated)]
+        public void ProjectInstanceShouldRespectSharingPolicy(EvaluationContext.SharingPolicy policy)
+        {
+            try
+            {
+                var seenContexts = new HashSet<EvaluationContext>();
+
+                EvaluationContext.TestOnlyHookOnCreate = c => seenContexts.Add(c);
+
+                var collection = _env.CreateProjectCollection().Collection;
+
+                var context = EvaluationContext.Create(policy);
+
+                const int numIterations = 10;
+                for (int i = 0; i < numIterations; i++)
+                {
+                    ProjectInstance.FromProjectRootElement(
+                        ProjectRootElement.Create(),
+                        new ProjectOptions
+                        {
+                            ProjectCollection = collection,
+                            EvaluationContext = context,
+                            LoadSettings = ProjectLoadSettings.IgnoreMissingImports
+                        });
+                }
+
+                int expectedNumContexts = policy == EvaluationContext.SharingPolicy.Shared ? 1 : numIterations;
+
+                seenContexts.Count.ShouldBe(expectedNumContexts);
+                seenContexts.ShouldAllBe(c => c.Policy == policy);
+            }
+            finally
+            {
+                EvaluationContext.TestOnlyHookOnCreate = null;
+            }
+        }
+
         private static string[] _sdkResolutionProjects =
         {
             "<Project Sdk=\"foo\"></Project>",
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index 9a506e4e8c1..3dfc11a9f97 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -3882,6 +3882,12 @@ public void PropertyFunctionStringPadLeft2()
             TestPropertyFunction("$(prop.PadLeft(2, '0'))", "prop", "x", "0x");
         }
 
+        [Fact]
+        public void PropertyFunctionStringPadLeftComplex()
+        {
+            TestPropertyFunction("$(prop.PadLeft($([MSBuild]::Multiply(1, 2)), '0'))", "prop", "x", "0x");
+        }
+
         [Fact]
         public void PropertyFunctionStringPadRight1()
         {
@@ -3946,6 +3952,12 @@ public void PropertyFunctionMSBuildAdd()
             TestPropertyFunction("$([MSBuild]::Add($(X), 5))", "X", "7", "12");
         }
 
+        [Fact]
+        public void PropertyFunctionMSBuildAddComplex()
+        {
+            TestPropertyFunction("$([MSBuild]::Add($(X), $([MSBuild]::Add(2, 3))))", "X", "7", "12");
+        }
+
         [Fact]
         public void PropertyFunctionMSBuildSubtract()
         {
@@ -3958,6 +3970,12 @@ public void PropertyFunctionMSBuildMultiply()
             TestPropertyFunction("$([MSBuild]::Multiply($(X), 8800))", "X", "2", "17600");
         }
 
+        [Fact]
+        public void PropertyFunctionMSBuildMultiplyComplex()
+        {
+            TestPropertyFunction("$([MSBuild]::Multiply($(X), $([MSBuild]::Multiply(1, 8800))))", "X", "2", "17600");
+        }
+
         [Fact]
         public void PropertyFunctionMSBuildDivide()
         {
diff --git a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
index 994efb0f61f..6743baf1a8d 100644
--- a/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
+++ b/src/Build.UnitTests/Instance/ProjectInstance_Internal_Tests.cs
@@ -8,6 +8,7 @@
 using System.Xml;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
@@ -691,12 +692,18 @@ public void ProjectInstanceCanSerializeEntireStateViaTranslator(string projectCo
 
         public static IEnumerable<object[]> ProjectInstanceHasEvaluationIdTestData()
         {
-            // from file
+            // from file (new)
             yield return new ProjectInstanceFactory[]
             {
                 (f, xml, c) => new ProjectInstance(f, null, null, c)
             };
 
+            // from file (factory method)
+            yield return new ProjectInstanceFactory[]
+            {
+                (f, xml, c) => ProjectInstance.FromFile(f, new ProjectOptions { ProjectCollection = c })
+            };
+
             // from Project
             yield return new ProjectInstanceFactory[]
             {
@@ -709,10 +716,16 @@ public static IEnumerable<object[]> ProjectInstanceHasEvaluationIdTestData()
                 (f, xml, c) => new ProjectInstance(f, null, null, c).DeepCopy()
             };
 
-            // from ProjectRootElement
+            // from ProjectRootElement (new)
             yield return new ProjectInstanceFactory[]
             {
-                (f, xml, c) => new ProjectInstance(xml, null, null, c).DeepCopy()
+                (f, xml, c) => new ProjectInstance(xml, null, null, c)
+            };
+
+            // from ProjectRootElement (factory method)
+            yield return new ProjectInstanceFactory[]
+            {
+                (f, xml, c) => ProjectInstance.FromProjectRootElement(xml, new ProjectOptions { ProjectCollection = c })
             };
 
             // from translated project instance
@@ -797,6 +810,62 @@ public void AddTargetThrowsWithExistingTarget()
             Assert.Throws<InternalErrorException>(() => projectInstance.AddTarget("a", "1==1", "inputs", "outputs", "returns", "keepDuplicateOutputs", "dependsOnTargets", "beforeTargets", "afterTargets", true));
         }
 
+        [Theory]
+        [InlineData(false, ProjectLoadSettings.Default)]
+        [InlineData(false, ProjectLoadSettings.RecordDuplicateButNotCircularImports)]
+        [InlineData(true, ProjectLoadSettings.Default)]
+        [InlineData(true, ProjectLoadSettings.RecordDuplicateButNotCircularImports)]
+        public void GetImportPathsAndImportPathsIncludingDuplicates(bool useDirectConstruction, ProjectLoadSettings projectLoadSettings)
+        {
+            try
+            {
+                string projectFileContent = @"
+                    <Project>
+                        <Import Project='{0}'/>
+                        <Import Project='{1}'/>
+                        <Import Project='{0}'/>
+                    </Project>";
+
+                string import1Content = @"
+                    <Project>
+                        <Import Project='{0}'/>
+                        <Import Project='{1}'/>
+                    </Project>";
+
+                string import2Content = @"<Project />";
+                string import3Content = @"<Project />";
+
+                string import2Path = ObjectModelHelpers.CreateFileInTempProjectDirectory("import2.targets", import2Content);
+                string import3Path = ObjectModelHelpers.CreateFileInTempProjectDirectory("import3.targets", import3Content);
+
+                import1Content = string.Format(import1Content, import2Path, import3Path);
+                string import1Path = ObjectModelHelpers.CreateFileInTempProjectDirectory("import1.targets", import1Content);
+
+                projectFileContent = string.Format(projectFileContent, import1Path, import2Path);
+
+                ProjectCollection projectCollection = new ProjectCollection();
+                BuildParameters buildParameters = new BuildParameters(projectCollection) { ProjectLoadSettings = projectLoadSettings };
+                BuildEventContext buildEventContext = new BuildEventContext(0, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
+
+                ProjectRootElement rootElement = ProjectRootElement.Create(XmlReader.Create(new StringReader(projectFileContent)));
+                ProjectInstance projectInstance = useDirectConstruction
+                    ? new ProjectInstance(rootElement, globalProperties: null, toolsVersion: null, buildParameters, projectCollection.LoggingService, buildEventContext, sdkResolverService: null, 0)
+                    : new Project(rootElement, globalProperties: null, toolsVersion: null, projectCollection, projectLoadSettings).CreateProjectInstance();
+
+                string[] expectedImportPaths = new string[] { import1Path, import2Path, import3Path };
+                string[] expectedImportPathsIncludingDuplicates = projectLoadSettings.HasFlag(ProjectLoadSettings.RecordDuplicateButNotCircularImports)
+                    ? new string[] { import1Path, import2Path, import3Path, import2Path, import1Path }
+                    : expectedImportPaths;
+
+                Helpers.AssertListsValueEqual(expectedImportPaths, projectInstance.ImportPaths.ToList());
+                Helpers.AssertListsValueEqual(expectedImportPathsIncludingDuplicates, projectInstance.ImportPathsIncludingDuplicates.ToList());
+            }
+            finally
+            {
+                ObjectModelHelpers.DeleteTempProjectDirectory();
+            }
+        }
+
         /// <summary>
         /// Create a ProjectInstance from provided project content
         /// </summary>
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 3c1aa0491c5..a5837079443 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -1826,7 +1826,9 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF
             var errorMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
                 "CacheMissesNotAllowedInIsolatedGraphBuilds",
                 parentConfig.ProjectFullPath,
+                ConcatenateGlobalProperties(parentConfig),
                 requestConfig.ProjectFullPath,
+                ConcatenateGlobalProperties(requestConfig),
                 request.Targets.Count == 0
                     ? "default"
                     : string.Join(";", request.Targets));
@@ -1834,8 +1836,6 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF
             // Issue a failed build result to have the msbuild task marked as failed and thus stop the build
             BuildResult result = new BuildResult(request);
             result.SetOverallResult(false);
-
-            // Log an error to have something useful displayed to the user and to avoid having a failed build with 0 errors
             result.SchedulerInducedError = errorMessage;
 
             var response = GetResponseForResult(nodeForResults, request, result);
@@ -1870,6 +1870,11 @@ BuildEventContext NewBuildEventContext()
                 var parentConfiguration = configCache[parentRequest.BuildRequest.ConfigurationId];
                 return (buildRequestConfiguration, parentConfiguration);
             }
+
+            string ConcatenateGlobalProperties(BuildRequestConfiguration configuration)
+            {
+                return string.Join("; ", configuration.GlobalProperties.Select<ProjectPropertyInstance, string>(p => $"{p.Name}={p.EvaluatedValue}"));
+            }
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
index 612fd2ea1a1..c3a86600cde 100644
--- a/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
+++ b/src/Build/BackEnd/Components/SdkResolution/SdkResolverLoader.cs
@@ -16,7 +16,7 @@ namespace Microsoft.Build.BackEnd.SdkResolution
 {
     internal class SdkResolverLoader
     {
-#if !FEATURE_ASSEMBLY_LOADFROM
+#if FEATURE_ASSEMBLYLOADCONTEXT
         private readonly CoreClrAssemblyLoader _loader = new CoreClrAssemblyLoader();
 #endif
 
@@ -135,10 +135,9 @@ protected virtual IEnumerable<Type> GetResolverTypes(Assembly assembly)
 
         protected virtual Assembly LoadResolverAssembly(string resolverPath, LoggingContext loggingContext, ElementLocation location)
         {
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             return Assembly.LoadFrom(resolverPath);
 #else
-            _loader.AddDependencyLocation(Path.GetDirectoryName(resolverPath));
             return _loader.LoadFromPath(resolverPath);
 #endif
         }
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 8ac4e03d847..e8c02f80020 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -5,22 +5,23 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Text;
-using System.Threading;
-using System.Threading.Tasks;
-using Microsoft.Build.Framework;
-using Microsoft.Build.Shared;
-
-using Microsoft.Build.Execution;
-using Microsoft.Build.Exceptions;
-using Microsoft.Build.Evaluation;
-using Microsoft.Build.Construction;
-using Microsoft.Build.BackEnd.Logging;
 using System.Globalization;
 using System.Reflection;
 #if FEATURE_APPDOMAIN
 using System.Runtime.Remoting;
 #endif
+using System.Text;
+using System.Threading;
+using System.Threading.Tasks;
+
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Evaluation;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
@@ -145,7 +146,7 @@ internal TaskExecutionHost(IBuildComponentHost host)
             // If this is false, check the environment variable to see if it's there:
             if (!LogTaskInputs)
             {
-                LogTaskInputs = (Environment.GetEnvironmentVariable("MSBUILDLOGTASKINPUTS") == "1");
+                LogTaskInputs = Traits.Instance.EscapeHatches.LogTaskInputs;
             }
         }
 
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 99f7b8d5769..3ca66711e41 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -8,6 +8,7 @@
 using System.Text;
 using System.Globalization;
 using System.Security;
+using System.Text.Json;
 using System.Text.RegularExpressions;
 
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
@@ -18,6 +19,7 @@
 using ExceptionUtilities = Microsoft.Build.Shared.ExceptionHandling;
 using System.Collections.ObjectModel;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Construction
 {
@@ -85,6 +87,7 @@ public sealed class SolutionFile
         #endregion
         #region Member data
         private string _solutionFile;                 // Could be absolute or relative path to the .SLN file.
+        private HashSet<string> _solutionFilter;     // The project files to include in loading the solution.
         private bool _parsingForConversionOnly;      // Are we parsing this solution to get project reference data during
                                                      // conversion, or in preparation for actually building the solution?
 
@@ -195,7 +198,48 @@ internal string FullPath
             {
                 // Should already be canonicalized to a full path
                 ErrorUtilities.VerifyThrowInternalRooted(value);
-                _solutionFile = value;
+                if (FileUtilities.IsSolutionFilterFilename(value))
+                {
+                    try
+                    {
+                        using JsonDocument text = JsonDocument.Parse(File.ReadAllText(value));
+                        JsonElement solution = text.RootElement.GetProperty("solution");
+                        _solutionFile = Path.GetFullPath(solution.GetProperty("path").GetString());
+                        if (!FileSystems.Default.FileExists(_solutionFile))
+                        {
+                            ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                            (
+                                "SubCategoryForSolutionParsingErrors",
+                                new BuildEventFileInfo(_solutionFile),
+                                "SolutionFilterMissingSolutionError",
+                                value,
+                                _solutionFile
+                            );
+                        }
+                        _solutionFilter = new HashSet<string>(NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
+                        foreach (JsonElement project in solution.GetProperty("projects").EnumerateArray())
+                        {
+                            _solutionFilter.Add(project.GetString());
+                        }
+                    }
+                    catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
+                    {
+                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                        (
+                            false, /* Just throw the exception */
+                            "SubCategoryForSolutionParsingErrors",
+                            new BuildEventFileInfo(value),
+                            e,
+                            "SolutionFilterJsonParsingError",
+                            value
+                        );
+                    }
+                }
+                else
+                {
+                    _solutionFile = value;
+                    _solutionFilter = null;
+                }
             }
         }
 
@@ -218,6 +262,11 @@ internal string FullPath
 
         #region Methods
 
+        internal bool ProjectShouldBuild(string projectFile)
+        {
+            return _solutionFilter == null || _solutionFilter.Contains(projectFile);
+        }
+
         /// <summary>
         /// This method takes a path to a solution file, parses the projects and project dependencies
         /// in the solution file, and creates internal data structures representing the projects within
@@ -288,7 +337,6 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
                         {
                             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
                                 (
-                                    false /* just throw the exception */,
                                     "SubCategoryForSolutionParsingErrors",
                                     new BuildEventFileInfo(solutionFile),
                                     "SolutionParseVersionMismatchError",
@@ -336,7 +384,6 @@ internal static void GetSolutionFileAndVisualStudioMajorVersions(string solution
             // Didn't find the header in lines 1-4, so the solution file is invalid.
             ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
                 (
-                    false /* just throw the exception */,
                     "SubCategoryForSolutionParsingErrors",
                     new BuildEventFileInfo(solutionFile),
                     "SolutionParseNoHeaderError"
@@ -461,6 +508,30 @@ internal void ParseSolution()
                 }
             }
 
+            if (_solutionFilter != null)
+            {
+                HashSet<string> projectPaths = new HashSet<string>(_projectsInOrder.Count, NativeMethodsShared.OSUsesCaseSensitivePaths ? StringComparer.Ordinal : StringComparer.OrdinalIgnoreCase);
+                foreach (ProjectInSolution project in _projectsInOrder)
+                {
+                    projectPaths.Add(project.RelativePath);
+                }
+                foreach (string project in _solutionFilter)
+                {
+                    if (!projectPaths.Contains(project))
+                    {
+                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                        (
+                            "SubCategoryForSolutionParsingErrors",
+                            new BuildEventFileInfo(project),
+                            "SolutionFilterFilterContainsProjectNotInSolution",
+                            _solutionFilter,
+                            project,
+                            _solutionFile
+                        );
+                    }
+                }
+            }
+
             if (rawProjectConfigurationsEntries != null)
             {
                 ProcessProjectConfigurationSection(rawProjectConfigurationsEntries);
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index 0c937c6d71d..5000095577c 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -637,6 +637,12 @@ private static string DetermineLikelyActiveSolutionConfiguration(SolutionFile so
         /// </summary>
         private static bool WouldProjectBuild(SolutionFile solutionFile, string selectedSolutionConfiguration, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration)
         {
+            // If the solution filter does not contain this project, do not build it.
+            if (!solutionFile.ProjectShouldBuild(project.RelativePath))
+            {
+                return false;
+            }
+
             if (projectConfiguration == null)
             {
                 if (project.ProjectType == SolutionProjectType.WebProject)
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index c3964994753..1f904f39007 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -924,7 +924,7 @@ public List<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluatio
         /// <A Include="a.cs;*.cs"/> // Occurrences:2; Operation: Include; Provenance: StringLiteral | Glob
         /// <B Include="*.cs" Exclude="a.cs"/> // Occurrences: 1; Operation: Exclude; Provenance: StringLiteral
         /// <C Include="b.cs"/> // NA
-        /// <D Include="@(A)"/> // Occurrences: 2; Operation: Include; Provenance: Inconclusive (it is an indirect occurence from a referenced item)
+        /// <D Include="@(A)"/> // Occurrences: 2; Operation: Include; Provenance: Inconclusive (it is an indirect occurrence from a referenced item)
         /// <E Include="$(P)"/> // Occurrences: 4; Operation: Include; Provenance: FromLiteral (direct reference in $P) | Glob (direct reference in $P) | Inconclusive (it is an indirect occurrence from referenced properties and items)
         /// <PropertyGroup>
         ///     <P>a.cs;*.cs;@(A)</P>
@@ -4655,7 +4655,7 @@ public class ProvenanceResult
         public Provenance Provenance { get; }
 
         /// <summary>
-        /// Gets the number of occurences of the item.
+        /// Gets the number of occurrences of the item.
         /// </summary>
         public int Occurrences { get; }
 
diff --git a/src/Build/Errors/InternalLoggerException.cs b/src/Build/Errors/InternalLoggerException.cs
index 7b50e2ed51c..ca0a8f26a77 100644
--- a/src/Build/Errors/InternalLoggerException.cs
+++ b/src/Build/Errors/InternalLoggerException.cs
@@ -241,7 +241,7 @@ params string[] messageArgs
         // the F1-help keyword for the host IDE
         private string helpKeyword;
 
-        // This flag is set to indicate that the exception occured during logger initialization
+        // This flag is set to indicate that the exception occurred during logger initialization
         [OptionalField(VersionAdded = 2)]
         private bool initializationException;
     }
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index db90237b35e..f242a066e03 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -4170,6 +4170,9 @@ private static bool TryConvertToInt(object value, out int arg0)
             {
                 switch (value)
                 {
+                    case double d:
+                        arg0 = Convert.ToInt32(d);
+                        return arg0 == d;
                     case int i:
                         arg0 = i;
                         return true;
@@ -4181,6 +4184,22 @@ private static bool TryConvertToInt(object value, out int arg0)
                 return false;
             }
 
+            private static bool TryConvertToDouble(object value, out double arg)
+            {
+                if (value is double unboxed)
+                {
+                    arg = unboxed;
+                    return true;
+                }
+                else if (value is string str && double.TryParse(str, out arg))
+                {
+                    return true;
+                }
+
+                arg = 0;
+                return false;
+            }
+
             private static bool TryGetArg(object[] args, out string arg0)
             {
                 if (args.Length != 1)
@@ -4217,15 +4236,8 @@ private static bool TryGetArgs(object[] args, out double arg0, out double arg1)
                     return false;
                 }
 
-                if (args[0] is string value0 &&
-                    args[1] is string value1 &&
-                    double.TryParse(value0, out arg0) &&
-                    double.TryParse(value1, out arg1))
-                {
-                    return true;
-                }
-
-                return false;
+                return TryConvertToDouble(args[0], out arg0) &&
+                       TryConvertToDouble(args[1], out arg1);
             }
 
             private static bool TryGetArgs(object[] args, out int arg0, out string arg1)
@@ -4238,11 +4250,9 @@ private static bool TryGetArgs(object[] args, out int arg0, out string arg1)
                     return false;
                 }
 
-                var value0 = args[0] as string;
                 arg1 = args[1] as string;
-                if (value0 != null &&
-                    arg1 != null &&
-                    int.TryParse(value0, out arg0))
+                if (TryConvertToInt(args[0], out arg0) &&
+                    arg1 != null)
                 {
                     return true;
                 }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index b916615c280..1ca74004420 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -2,32 +2,32 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections;
 using System.Collections.Generic;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
+using System.IO;
+using System.Linq;
+using System.Runtime.CompilerServices;
+using System.Text.Json;
+using System.Xml;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.BackEnd.SdkResolution;
 using Microsoft.Build.Collections;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Definition;
 using Microsoft.Build.Evaluation;
-using Evaluation = Microsoft.Build.Evaluation;
-using ObjectModel = System.Collections.ObjectModel;
+using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Framework;
-using Microsoft.Build.BackEnd;
-using Microsoft.Build.Construction;
-using Microsoft.Build.Shared;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Internal;
-
-using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
-using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
-using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
-using System.Xml;
-using System.IO;
-using System.Collections;
-using System.Runtime.CompilerServices;
-using System.Linq;
-using Microsoft.Build.BackEnd.SdkResolution;
+using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
+using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
+using ObjectModel = System.Collections.ObjectModel;
+using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
 using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 
 namespace Microsoft.Build.Execution
@@ -89,6 +89,10 @@ public class ProjectInstance : IPropertyProvider<ProjectPropertyInstance>, IItem
 
         private List<string> _initialTargets;
 
+        private List<string> _importPaths;
+
+        private List<string> _importPathsIncludingDuplicates;
+
         /// <summary>
         /// The global properties evaluation occurred with.
         /// Needed by the build as they traverse between projects.
@@ -238,6 +242,26 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
+            : this(projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null)
+        {
+        }
+
+        /// <summary>
+        /// Creates a ProjectInstance directly.
+        /// No intermediate Project object is created.
+        /// This is ideal if the project is simply going to be built, and not displayed or edited.
+        /// Global properties may be null.
+        /// Tools version may be null.
+        /// Evaluation context may be null.
+        /// </summary>
+        /// <param name="projectFile">The name of the project file.</param>
+        /// <param name="globalProperties">The global properties to use.</param>
+        /// <param name="toolsVersion">The tools version.</param>
+        /// <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
+        /// <param name="projectCollection">Project collection</param>
+        /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <returns>A new project instance</returns>
+        private ProjectInstance(string projectFile, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
         {
             ErrorUtilities.VerifyThrowArgumentLength(projectFile, "projectFile");
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(toolsVersion, "toolsVersion");
@@ -251,7 +275,7 @@ public ProjectInstance(string projectFile, IDictionary<string, string> globalPro
             BuildEventContext buildEventContext = new BuildEventContext(buildParameters.NodeId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
             ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile, globalProperties, toolsVersion, buildParameters.ProjectRootElementCache, true /*Explicitly Loaded*/);
 
-            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version provided */, buildParameters, projectCollection.LoggingService, buildEventContext);
+            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version provided */, buildParameters, projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
         }
 
         /// <summary>
@@ -299,9 +323,29 @@ public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globa
         /// <param name="projectCollection">Project collection</param>
         /// <returns>A new project instance</returns>
         public ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection)
+            : this(xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, projectLoadSettings: null, evaluationContext: null)
+        {
+        }
+
+        /// <summary>
+        /// Creates a ProjectInstance directly.
+        /// No intermediate Project object is created.
+        /// This is ideal if the project is simply going to be built, and not displayed or edited.
+        /// Global properties may be null.
+        /// Tools version may be null.
+        /// Sub-toolset version may be null, but if specified will override all other methods of determining the sub-toolset.
+        /// </summary>
+        /// <param name="xml">The project root element</param>
+        /// <param name="globalProperties">The global properties to use.</param>
+        /// <param name="toolsVersion">The tools version.</param>
+        /// <param name="subToolsetVersion">The sub-toolset version, used in tandem with the ToolsVersion to determine the set of toolset properties.</param>
+        /// <param name="projectCollection">Project collection</param>
+        /// <param name="evaluationContext">The context to use for evaluation.</param>
+        /// <returns>A new project instance</returns>
+        private ProjectInstance(ProjectRootElement xml, IDictionary<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings? projectLoadSettings, EvaluationContext evaluationContext)
         {
             BuildEventContext buildEventContext = new BuildEventContext(0, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTaskId);
-            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, new BuildParameters(projectCollection), projectCollection.LoggingService, buildEventContext);
+            Initialize(xml, globalProperties, toolsVersion, subToolsetVersion, 0 /* no solution version specified */, new BuildParameters(projectCollection), projectCollection.LoggingService, buildEventContext, projectLoadSettings: projectLoadSettings, evaluationContext: evaluationContext);
         }
 
         /// <summary>
@@ -331,6 +375,10 @@ internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFro
             this.DefaultTargets.Add("Build");
             this.TaskRegistry = projectToInheritFrom.TaskRegistry;
             _isImmutable = projectToInheritFrom._isImmutable;
+            _importPaths = projectToInheritFrom._importPaths;
+            ImportPaths = _importPaths.AsReadOnly();
+            _importPathsIncludingDuplicates = projectToInheritFrom._importPathsIncludingDuplicates;
+            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
 
             this.EvaluatedItemElements = new List<ProjectItemElement>();
 
@@ -424,6 +472,7 @@ internal ProjectInstance(Evaluation.Project.Data data, string directory, string
             this.CreateGlobalPropertiesSnapshot(data);
             this.CreateEnvironmentVariablePropertiesSnapshot(environmentVariableProperties);
             this.CreateTargetsSnapshot(data);
+            this.CreateImportsSnapshot(data);
 
             this.Toolset = data.Toolset; // UNDONE: This isn't immutable, should be cloned or made immutable; it currently has a pointer to project collection
             this.SubToolsetVersion = data.SubToolsetVersion;
@@ -515,6 +564,10 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
                 _targets = that._targets;
                 _itemDefinitions = that._itemDefinitions;
                 _explicitToolsVersionSpecified = that._explicitToolsVersionSpecified;
+                _importPaths = that._importPaths;
+                ImportPaths = _importPaths.AsReadOnly();
+                _importPathsIncludingDuplicates = that._importPathsIncludingDuplicates;
+                ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
 
                 this.EvaluatedItemElements = that.EvaluatedItemElements;
 
@@ -607,6 +660,41 @@ private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProject
             }
         }
 
+        /// <summary>
+        /// Create a file based ProjectInstance.
+        /// </summary>
+        /// <param name="file">The file to evaluate the ProjectInstance from.</param>
+        /// <param name="options">The <see cref="ProjectOptions"/> to use.</param>
+        /// <returns></returns>
+        public static ProjectInstance FromFile(string file, ProjectOptions options)
+        {
+            return new ProjectInstance(
+                file,
+                options.GlobalProperties,
+                options.ToolsVersion,
+                options.SubToolsetVersion,
+                options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
+                options.LoadSettings,
+                options.EvaluationContext);
+        }
+
+        /// <summary>
+        /// Create a <see cref="ProjectRootElement"/> based ProjectInstance.
+        /// </summary>
+        /// <param name="rootElement">The <see cref="ProjectRootElement"/> to evaluate the ProjectInstance from.</param>
+        /// <param name="options">The <see cref="ProjectOptions"/> to use.</param>
+        public static ProjectInstance FromProjectRootElement(ProjectRootElement rootElement, ProjectOptions options)
+        {
+            return new ProjectInstance(
+                rootElement,
+                options.GlobalProperties,
+                options.ToolsVersion,
+                options.SubToolsetVersion,
+                options.ProjectCollection ?? ProjectCollection.GlobalProjectCollection,
+                options.LoadSettings,
+                options.EvaluationContext);
+        }
+
         /// <summary>
         /// Global properties this project was evaluated with, if any.
         /// Read only collection.
@@ -773,6 +861,18 @@ public IDictionary<string, ProjectItemDefinitionInstance> ItemDefinitions
             { return _itemDefinitions; }
         }
 
+        /// <summary>
+        /// The full file paths of all the files that during evaluation contributed to this project instance.
+        /// This does not include projects that were never imported because a condition on an Import element was false.
+        /// The outer ProjectRootElement that maps to this project instance itself is not included.
+        /// </summary>
+        public IReadOnlyList<string> ImportPaths { get; private set; }
+
+        /// <summary>
+        /// This list will contain duplicate imports if an import is imported multiple times. However, only the first import was used in evaluation.
+        /// </summary>
+        public IReadOnlyList<string> ImportPathsIncludingDuplicates { get; private set; }
+
         /// <summary>
         /// DefaultTargets specified in the project, or
         /// the logically first target if no DefaultTargets is
@@ -1358,7 +1458,6 @@ void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadat
 
         /// <summary>
         /// Record an import opened during evaluation.
-        /// Does nothing: not needed for project instances.
         /// </summary>
         void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.RecordImport(
             ProjectImportElement importElement,
@@ -1366,14 +1465,16 @@ void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadat
             int versionEvaluated,
             SdkResult sdkResult)
         {
+            _importPaths.Add(import.FullPath);
+            ((IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>)this).RecordImportWithDuplicates(importElement, import, versionEvaluated);
         }
 
         /// <summary>
         /// Record an import opened during evaluation. Include duplicates
-        /// Does nothing: not needed for project instances.
         /// </summary>
         void IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.RecordImportWithDuplicates(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated)
         {
+            _importPathsIncludingDuplicates.Add(import.FullPath);
         }
 
         /// <summary>
@@ -1897,6 +1998,9 @@ private void TranslateAllState(ITranslator translator)
                 ref _itemDefinitions,
                 ProjectItemDefinitionInstance.FactoryForDeserialization,
                 capacity => new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(capacity, MSBuildNameIgnoreCaseComparer.Default));
+
+            // ignore _importPaths/ImportPaths. Only used by public API users, not nodes
+            // ignore _importPathsIncludingDuplicates/ImportPathsIncludingDuplicates. Only used by public API users, not nodes
         }
 
         private void TranslateToolsetSpecificState(ITranslator translator)
@@ -2034,9 +2138,29 @@ internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, Prope
             // we should be generating a 4.0+ or a 3.5-style wrapper project based on the version of the solution. 
             else
             {
-                int solutionVersion;
-                int visualStudioVersion;
-                SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(projectFile, out solutionVersion, out visualStudioVersion);
+                string solutionFile = projectFile;
+                if (FileUtilities.IsSolutionFilterFilename(projectFile))
+                {
+                    try
+                    {
+                        using JsonDocument text = JsonDocument.Parse(File.ReadAllText(projectFile));
+                        JsonElement solution = text.RootElement.GetProperty("solution");
+                        solutionFile = Path.GetFullPath(solution.GetProperty("path").GetString());
+                    }
+                    catch (Exception e) when (e is JsonException || e is KeyNotFoundException || e is InvalidOperationException)
+                    {
+                        ProjectFileErrorUtilities.VerifyThrowInvalidProjectFile
+                        (
+                            false, /* Just throw the exception */
+                            "SubCategoryForSolutionParsingErrors",
+                            new BuildEventFileInfo(projectFile),
+                            e,
+                            "SolutionFilterJsonParsingError",
+                            projectFile
+                        );
+                    }
+                }
+                SolutionFile.GetSolutionFileAndVisualStudioMajorVersions(solutionFile, out int solutionVersion, out int visualStudioVersion);
 
                 // If we get to this point, it's because it's a valid version.  Map the solution version 
                 // to the equivalent MSBuild ToolsVersion, and unless it's Dev10 or newer, spawn the old 
@@ -2064,7 +2188,7 @@ internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, Prope
 
                     string toolsVersionToUse = Utilities.GenerateToolsVersionToUse(
                         explicitToolsVersion: null,
-                        toolsVersionFromProject: toolsVersion,
+                        toolsVersionFromProject: FileUtilities.IsSolutionFilterFilename(projectFile) ? MSBuildConstants.CurrentToolsVersion : toolsVersion,
                         getToolset: buildParameters.GetToolset,
                         defaultToolsVersion: Constants.defaultSolutionWrapperProjectToolsVersion,
                         usingDifferentToolsVersionFromProjectFile: out _);
@@ -2471,7 +2595,19 @@ private static IDictionary<string, TValue> CreateCloneDictionary<TValue>(IDictio
         /// Tools version may be null.
         /// Does not set mutability.
         /// </summary>
-        private void Initialize(ProjectRootElement xml, IDictionary<string, string> globalProperties, string explicitToolsVersion, string explicitSubToolsetVersion, int visualStudioVersionFromSolution, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService = null, int submissionId = BuildEventContext.InvalidSubmissionId, ProjectLoadSettings? projectLoadSettings = null)
+        private void Initialize(
+            ProjectRootElement xml,
+            IDictionary<string, string> globalProperties,
+            string explicitToolsVersion,
+            string explicitSubToolsetVersion,
+            int visualStudioVersionFromSolution,
+            BuildParameters buildParameters,
+            ILoggingService loggingService,
+            BuildEventContext buildEventContext,
+            ISdkResolverService sdkResolverService = null,
+            int submissionId = BuildEventContext.InvalidSubmissionId,
+            ProjectLoadSettings? projectLoadSettings = null,
+            EvaluationContext evaluationContext = null)
         {
             ErrorUtilities.VerifyThrowArgumentNull(xml, "xml");
             ErrorUtilities.VerifyThrowArgumentLengthIfNotNull(explicitToolsVersion, "toolsVersion");
@@ -2483,6 +2619,10 @@ private void Initialize(ProjectRootElement xml, IDictionary<string, string> glob
             _items = new ItemDictionary<ProjectItemInstance>();
             _actualTargets = new RetrievableEntryHashSet<ProjectTargetInstance>(StringComparer.OrdinalIgnoreCase);
             _targets = new ObjectModel.ReadOnlyDictionary<string, ProjectTargetInstance>(_actualTargets);
+            _importPaths = new List<string>();
+            ImportPaths = _importPaths.AsReadOnly();
+            _importPathsIncludingDuplicates = new List<string>();
+            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
             _globalProperties = new PropertyDictionary<ProjectPropertyInstance>((globalProperties == null) ? 0 : globalProperties.Count);
             _environmentVariableProperties = buildParameters.EnvironmentPropertiesInternal;
             _itemDefinitions = new RetrievableEntryHashSet<ProjectItemDefinitionInstance>(MSBuildNameIgnoreCaseComparer.Default);
@@ -2556,6 +2696,8 @@ out var usingDifferentToolsVersionFromProjectFile
 
             ErrorUtilities.VerifyThrow(EvaluationId == BuildEventContext.InvalidEvaluationId, "Evaluation ID is invalid prior to evaluation");
 
+            evaluationContext = evaluationContext?.ContextForNewProject() ?? EvaluationContext.Create(EvaluationContext.SharingPolicy.Isolated);
+
             Evaluator<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.Evaluate(
                 this,
                 xml,
@@ -2567,8 +2709,9 @@ out var usingDifferentToolsVersionFromProjectFile
                 buildParameters.ToolsetProvider,
                 ProjectRootElementCache,
                 buildEventContext,
-                sdkResolverService ?? SdkResolverService.Instance,
+                sdkResolverService ?? evaluationContext.SdkResolverService, /* Use override ISdkResolverService if specified */
                 submissionId,
+                evaluationContext,
                 interactive: buildParameters.Interactive);
 
             ErrorUtilities.VerifyThrow(EvaluationId != BuildEventContext.InvalidEvaluationId, "Evaluation should produce an evaluation ID");
@@ -2597,6 +2740,36 @@ private void CreateTargetsSnapshot(Evaluation.Project.Data data)
             _targets = CreateCloneDictionary(data.Targets);
         }
 
+        /// <summary>
+        /// Create various imports snapshots
+        /// </summary>
+        private void CreateImportsSnapshot(Evaluation.Project.Data data)
+        {
+            _importPaths = new List<string>(data.ImportClosure.Count - 1 /* outer project */);
+            foreach (var resolvedImport in data.ImportClosure)
+            {
+                // Exclude outer project itself
+                if (resolvedImport.ImportingElement != null)
+                {
+                    _importPaths.Add(resolvedImport.ImportedProject.FullPath);
+                }
+            }
+
+            ImportPaths = _importPaths.AsReadOnly();
+
+            _importPathsIncludingDuplicates = new List<string>(data.ImportClosureWithDuplicates.Count - 1 /* outer project */);
+            foreach (var resolvedImport in data.ImportClosureWithDuplicates)
+            {
+                // Exclude outer project itself
+                if (resolvedImport.ImportingElement != null)
+                {
+                    _importPathsIncludingDuplicates.Add(resolvedImport.ImportedProject.FullPath);
+                }
+            }
+
+            ImportPathsIncludingDuplicates = _importPathsIncludingDuplicates.AsReadOnly();
+        }
+
         /// <summary>
         /// Create environment variable properties snapshot
         /// </summary>
diff --git a/src/Build/Logging/LoggerDescription.cs b/src/Build/Logging/LoggerDescription.cs
index 76032eca78f..918314c8891 100644
--- a/src/Build/Logging/LoggerDescription.cs
+++ b/src/Build/Logging/LoggerDescription.cs
@@ -249,7 +249,7 @@ private ILogger CreateLogger(bool forwardingLogger)
                 if (innerException is LoggerException)
                 {
                     // Logger failed politely during construction. In order to preserve
-                    // the stack trace at which the error occured we wrap the original
+                    // the stack trace at which the error occurred we wrap the original
                     // exception instead of throwing.
                     LoggerException l = ((LoggerException)innerException);
                     throw new LoggerException(l.Message, innerException, l.ErrorCode, l.HelpKeyword);
diff --git a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index 3445daea46e..af005dfbe68 100644
--- a/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -213,7 +213,7 @@ internal TargetStartedEventMinimumFields GetTargetStartedEvent(BuildEventContext
         internal void RemoveProjectStartedEvent(BuildEventContext e)
         {
             ProjectStartedEventMinimumFields startedEvent = GetProjectStartedEvent(e);
-            // Only remove the project from the event list if it is in the list, and no errors have occured in the project
+            // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
             if (startedEvent != null && !startedEvent.ErrorInProject)
             {
                 _projectStartedEvents.Remove(e);
@@ -226,7 +226,7 @@ internal void RemoveProjectStartedEvent(BuildEventContext e)
         internal void RemoveTargetStartedEvent(BuildEventContext e)
         {
             TargetStartedEventMinimumFields startedEvent = GetTargetStartedEvent(e);
-            // Only remove the project from the event list if it is in the list, and no errors have occured in the project
+            // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
             if (startedEvent != null && !startedEvent.ErrorInTarget)
             {
                 _targetStartedEvents.Remove(e);
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index f9abac04503..7ef4ae0bb1a 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -34,6 +34,7 @@
     <PackageReference Include="System.Collections.Immutable" />
     <PackageReference Include="System.Threading.Tasks.Dataflow" />
     <PackageReference Include="System.Memory" />
+    <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
   </ItemGroup>
@@ -756,6 +757,9 @@
     <Compile Include="..\Shared\TypeLoader.cs">
       <Link>SharedUtilities\TypeLoader.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\MSBuildLoadContext.cs" Condition="'$(TargetFrameworkIdentifier)'!='.NETFramework'">
+      <Link>SharedUtilities\MSBuildLoadContext.cs</Link>
+    </Compile>
     <Compile Include="..\Shared\VisualStudioConstants.cs">
       <Link>VisualStudioConstants.cs</Link>
     </Compile>
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index a931f0f57a6..ded6b1fcf9a 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1718,14 +1718,18 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     </comment>
   </data>
   <data name="CacheMissesNotAllowedInIsolatedGraphBuilds" UESanitized="false" Visibility="Public">
-    <value>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+    <value>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </value>
     <comment>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </comment>
   </data>
   <data name="NullReferenceFromProjectInstanceFactory" UESanitized="false" Visibility="Public">
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 1f76059199b..cf2198d6eed 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252: Projekt {0} m odkaz na {1} (poet cl: {2}), ale vsledky sestaven pro tento odkaz v mezipamti modulu chyb. V izolovanch buildech by to mohlo znamenat nsledujc:
-    - Odkaz nebyl explicitn zadn jako poloka ProjectReference v: {0}.
-    - Odkaz nebyl zahrnut do poskytnutch vstupnch mezipamt.
-    - Odkaz byl voln s clem, kter nen zadn v poloce ProjectReferenceTargets v: {0}.
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 4ad4a4e0a8e..590b4eccf11 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252: Das Projekt "{0}" enthlt einen Verweis auf "{1}" ({2} Ziel(e)), aber das Buildergebnis fr den Verweis befindet sich nicht im Enginecache. In isolierten Builds kann dies eine der folgenden Ursachen haben:
-     Der Verweis wurde nicht explizit als ProjectReference-Element in "{0}" angegeben.
-     Der Verweis wurde nicht in die angegebenen Eingabecaches aufgenommen.
-     Der Verweis wurde mit einem Ziel aufgerufen, das nicht im ProjectReferenceTargets-Element in "{0}" angegeben ist.
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.en.xlf b/src/Build/Resources/xlf/Strings.en.xlf
index dbc30a8eaea..efe19856060 100644
--- a/src/Build/Resources/xlf/Strings.en.xlf
+++ b/src/Build/Resources/xlf/Strings.en.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="new">MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 31f67968df5..ccc65afc673 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252: El proyecto "{0}" tiene una referencia a "{1}" ({2} destinos(s)), pero el resultado de la compilacin para la referencia no est en la memoria cach del motor. En compilaciones aisladas, esto puede indicar uno de los siguientes casos:
-    - La referencia no se especific de forma explcita como un elemento ProjectReference en "{0}"
-    - La referencia no se incluy en las memorias cach de entrada proporcionadas.
-    - Se llam a la referencia con un destino que no est especificado en el elemento ProjectReferenceTargets en "{0}".
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index dd61954a11e..439b3e3cfca 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252: Le projet "{0}" a une rfrence  "{1}" ({2} cible(s)) mais le rsultat de la build pour la rfrence ne se trouve pas dans le cache du moteur. Dans les builds isoles, cela peut avoir l'une des significations suivantes:
-    - la rfrence n'a pas t explicitement spcifie en tant qu'lment ProjectReference dans "{0}"
-    - la rfrence n'a pas t incluse dans les caches d'entre fournis
-    - la rfrence a t appele avec une cible qui n'est pas spcifie dans l'lment ProjectReferenceTargets dans "{0}"
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index 7808aa8b5ee..8003caadb29 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252: il progetto "{0}" contiene un riferimento a "{1}" ({2} destinazione/i), ma il risultato della compilazione per il riferimento non  incluso nella cache del motore. Nelle compilazioni isolate questa condizione indica che:
-    - il riferimento non  stato specificato in modo esplicito come ProjectReference in "{0}"
-    - il riferimento non  stato incluso nelle cache di input specificate
-    - il riferimento  stato chiamato con una destinazione che non  specificata nell'elemento ProjectReferenceTargets in "{0}"
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 673894455b3..cfc1bc37222 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252:  "{0}"  "{1}" ({2} )  
-    -  "{0}"  ProjectReference 
-    - 
-    - "{0}"  ProjectReferenceTargets 
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 57b4828c811..820bf445661 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252: "{0}"  "{1}"( {2})          .        .
-    -  "{0}" ProjectReference    
-    -      
-    -  "{0}" ProjectReferenceTargets     
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 76b02d08693..0462cfbf7e6 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252: Projekt {0} zawiera odwoanie do elementu {1} (elementy docelowe: {2}), ale wynik kompilacji dla tego odwoania nie wystpuje w pamici podrcznej aparatu. W przypadku kompilacji izolowanych moe to oznacza jeden z nastpujcych przypadkw:
-    - odwoanie nie zostao jawnie okrelone jako element ProjectReference w elemencie {0}
-    - odwoanie nie zostao uwzgldnione w podanych wejciowych pamiciach podrcznych
-    - odwoanie zostao wywoane z elementem docelowym, ktry nie jest okrelony w elemencie ProjectReferenceTargets w elemencie {0}
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 55b0b401668..d96ab64cf04 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -32,18 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252: o projeto "{0}" tem uma referncia a "{1}" ({2} destinos, mas o resultado do build da referncia no est no cache do mecanismo. Em builds isolados, isso poderia significar uma das opes a seguir:
-     a referncia no foi especificada explicitamente como um item ProjectReference em "{0}"
-     a referncia no foi includa nos caches de entrada fornecidos
-     a referncia foi chamada com um destino que no est especificado no item ProjectReferenceTargets em "{0}"</target>
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
+    </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 73906c7e1b9..35c5d5e5e28 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252:   "{0}"    "{1}" ( : {2}),          .       :
-            ProjectReference  "{0}";
-             ;
-          ,      ProjectReferenceTargets  "{0}".
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 7cacf937cdf..3db882d5d87 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252: "{0}" projesinde "{1}" ({2} hedef) bavurusu var, ancak bavurunun derleme sonucu altyap nbelleinde deil. Yaltlm derlemelerde bunun anlam aadakilerden biri olabilir:
-    - "{0}" iinde bavuru aka bir ProjectReference esi olarak belirtilmemi
-    - Bavuru, salanan giri nbelleklerine eklenmemi
-    - Bavuru, "{0}" iindeki ProjectReferenceTargets esinde belirtilmeyen bir hedefle arlm
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index eef1a928b22..7c7d6f29a71 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252: {0}{1} ({2} target(s)):
-    - {0} ProjectReference 
-    - 
-    - {0} ProjectReferenceTargets 
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 730ba0bca10..9fa55769437 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -32,19 +32,27 @@
         <note />
       </trans-unit>
       <trans-unit id="CacheMissesNotAllowedInIsolatedGraphBuilds">
-        <source>MSB4252: Project "{0}" has a reference to "{1}" ({2} target(s)) but the build result for the reference is not in the engine cache. In isolated builds this could mean one of the following:
-    - the reference was not explicitly specified as a ProjectReference item in "{0}"
-    - the reference was not included in the provided input caches
-    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in "{0}"
+        <source>MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </source>
-        <target state="translated">MSB4252:  "{0}"  "{1}"  ({2} )
-    -  "{0}"  ProjectReference 
-    - 
-    -  "{0}"  ProjectReferenceTargets 
+        <target state="new">MSB4252: Project "{0}" with global properties
+    ({1})
+    is building project "{2}" with global properties
+    ({3})
+    with the ({4}) target(s) but the build result for the built project is not in the engine cache. In isolated builds this could mean one of the following:
+    - the reference was called with a target which is not specified in the ProjectReferenceTargets item in project "{0}"
+    - the reference was called with global properties that do not match the static graph inferred nodes
+    - the reference was not explicitly specified as a ProjectReference item in project "{0}"
     </target>
         <note>
       {StrBegin="MSB4252:"}
-      LOCALIZATION: Do not localize the following words: ProjectReference.
+      LOCALIZATION: Do not localize the following words: ProjectReference, ProjectReferenceTargets
     </note>
       </trans-unit>
       <trans-unit id="CannotExpandItemMetadata">
diff --git a/src/Deprecated/Conversion/AdditionalOptionsParser.cs b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
index 4b98de0d2ed..b99929a450e 100644
--- a/src/Deprecated/Conversion/AdditionalOptionsParser.cs
+++ b/src/Deprecated/Conversion/AdditionalOptionsParser.cs
@@ -43,7 +43,7 @@ internal enum SwitchValueType
         /// <summary>
         /// This switch can occur multiple times and the 
         /// final value is the ';' delimeted concat of all the
-        /// individual occurences
+        /// individual occurrences
         /// </summary>
         SVT_MultiString,
     }
diff --git a/src/Deprecated/Engine/Engine/Engine.cs b/src/Deprecated/Engine/Engine/Engine.cs
index 4cdc00de9bc..e9b5b85cf45 100644
--- a/src/Deprecated/Engine/Engine/Engine.cs
+++ b/src/Deprecated/Engine/Engine/Engine.cs
@@ -233,10 +233,10 @@ public class Engine
         // Counter of node Ids
         private int nextNodeId = 1;
 
-        // Context of the event in which the fatal error terminating the execution occured
+        // Context of the event in which the fatal error terminating the execution occurred
         private BuildEventContext fatalErrorContext;
 
-        // File name of the project in which fatal error occured (cached in order to avoid complexity in the
+        // File name of the project in which fatal error occurred (cached in order to avoid complexity in the
         // finally clause)
         private string fatalErrorProjectName;
 
diff --git a/src/Deprecated/Engine/Engine/EngineCommand.cs b/src/Deprecated/Engine/Engine/EngineCommand.cs
index ee649433ee5..47df3d53ec9 100644
--- a/src/Deprecated/Engine/Engine/EngineCommand.cs
+++ b/src/Deprecated/Engine/Engine/EngineCommand.cs
@@ -82,7 +82,7 @@ internal ReportExceptionEngineCommand(Exception e)
 
         internal override void Execute(Engine parentEngine)
         {
-            // Figure out if the exception occured on a parent or child engine
+            // Figure out if the exception occurred on a parent or child engine
             // On the parent rethrow nicely and make sure the finallies run
             // On the child try to communicate with the parent - if success, exit
             // if failure rethrow and hope Watson will pick the exception up
diff --git a/src/Deprecated/Engine/Engine/Node.cs b/src/Deprecated/Engine/Engine/Node.cs
index 8b4392267b7..a16f21d38e1 100644
--- a/src/Deprecated/Engine/Engine/Node.cs
+++ b/src/Deprecated/Engine/Engine/Node.cs
@@ -441,7 +441,7 @@ internal void ReportUnhandledError(Exception originalException)
                 }
                 catch (Exception ex)
                 {
-                    // If an error occured while trying to send the orginal exception to the parent 
+                    // If an error occurred while trying to send the original exception to the parent 
                     // rethrow the original exception
                     string message = ResourceUtilities.FormatResourceString("FatalErrorOnChildNode", nodeId, ex.Message);
 
diff --git a/src/Deprecated/Engine/Engine/ProjectBuildState.cs b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
index 4acdc3f5fec..f21598c28a5 100644
--- a/src/Deprecated/Engine/Engine/ProjectBuildState.cs
+++ b/src/Deprecated/Engine/Engine/ProjectBuildState.cs
@@ -306,7 +306,7 @@ internal enum BuildContextState
             /// </summary>
             ExceptionThrown,
             /// <summary>
-            /// All needed target have been completed or an error terminating the request has occured
+            /// All needed target have been completed or an error terminating the request has occurred
             /// </summary>
             BuildComplete,
             /// <summary>
diff --git a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
index 372a3432f61..d9456bffd51 100644
--- a/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
+++ b/src/Deprecated/Engine/Engine/TargetExecutionWrapper.cs
@@ -822,7 +822,7 @@ private void ProcessTaskOutputs(TaskExecutionContext executionContext)
                         }
                         else
                         {
-                            // The error occured outside of the user code (it may still be caused
+                            // The error occurred outside of the user code (it may still be caused
                             // by bad user input), the build should be terminated. The exception
                             // will be logged as a fatal build error in engine. The exceptions caused
                             // by user code are converted into LogFatalTaskError messages by the TaskEngine
@@ -1001,7 +1001,7 @@ internal void NotifyWaitingTargets(ProjectBuildState errorContext)
                 ProjectBuildState buildContext = waitingTargets[0];
                 waitingTargets.RemoveAt(0);
 
-                //Don't report any messages within the context in which the error occured. That context
+                //Don't report any messages within the context in which the error occurred. That context
                 //is addressed as the base of the stack 
                 if (buildContext == errorContext ||
                     buildContext.CurrentBuildContextState == ProjectBuildState.BuildContextState.RequestFilled)
diff --git a/src/Deprecated/Engine/Engine/TaskExecutionContext.cs b/src/Deprecated/Engine/Engine/TaskExecutionContext.cs
index aa95867a557..4962df3ab57 100644
--- a/src/Deprecated/Engine/Engine/TaskExecutionContext.cs
+++ b/src/Deprecated/Engine/Engine/TaskExecutionContext.cs
@@ -59,7 +59,7 @@ internal bool TaskExecutedSuccessfully
 
         /// <summary>
         /// Returns the exception thrown during the task execution. The exception will either be
-        /// InvalidProjectException or some unexpected exception that occured in the engine code,
+        /// InvalidProjectException or some unexpected exception that occurred in the engine code,
         /// because unexpected task exceptions are converted to logged errors.
         /// </summary>
         internal Exception ThrownException
diff --git a/src/Deprecated/Engine/Errors/InternalLoggerException.cs b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
index 0ea8c28a87b..54447515463 100644
--- a/src/Deprecated/Engine/Errors/InternalLoggerException.cs
+++ b/src/Deprecated/Engine/Errors/InternalLoggerException.cs
@@ -199,7 +199,7 @@ public string HelpKeyword
         }
 
         /// <summary>
-        /// True if the exception occured during logger initialization
+        /// True if the exception occurred during logger initialization
         /// </summary>
         public bool InitializationException
         {
@@ -243,7 +243,7 @@ params string[] messageArgs
         // the F1-help keyword for the host IDE
         private string helpKeyword;
 
-        // This flag is set to indicate that the exception occured during logger initialization
+        // This flag is set to indicate that the exception occurred during logger initialization
         [OptionalField(VersionAdded = 2)]
         private bool initializationException;
     }
diff --git a/src/Deprecated/Engine/Errors/RemoteErrorException.cs b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
index 03ff01eb7eb..1e040579d39 100644
--- a/src/Deprecated/Engine/Errors/RemoteErrorException.cs
+++ b/src/Deprecated/Engine/Errors/RemoteErrorException.cs
@@ -57,7 +57,7 @@ override public void GetObjectData(SerializationInfo info, StreamingContext cont
 
         #region Properties
         /// <summary>
-        /// Gets the event context in which the remote exception occured
+        /// Gets the event context in which the remote exception occurred
         /// </summary>
         internal BuildEventContext BuildEventContext
         {
diff --git a/src/Deprecated/Engine/Introspector/NodeStatus.cs b/src/Deprecated/Engine/Introspector/NodeStatus.cs
index 850ed6c9ba4..054fd1a125f 100644
--- a/src/Deprecated/Engine/Introspector/NodeStatus.cs
+++ b/src/Deprecated/Engine/Introspector/NodeStatus.cs
@@ -207,7 +207,7 @@ internal bool IsLaunchInProgress
         }
 
         /// <summary>
-        /// Returns the exception that occured on the node
+        /// Returns the exception that occurred on the node
         /// </summary>
         internal Exception UnhandledException
         {
diff --git a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
index 332d8c94b6a..eb841f4102b 100644
--- a/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
+++ b/src/Deprecated/Engine/Logging/BaseConsoleLogger.cs
@@ -1097,24 +1097,24 @@ internal virtual bool ApplyParameter(string parameterName, string parameterValue
         #region Per-build Members
         internal int numberOfProcessors = 1;
         /// <summary>
-        /// Number of errors enountered in this build
+        /// Number of errors encountered in this build
         /// </summary>
         /// <owner>t-jeffv, sumedhk</owner>
         internal int errorCount = 0;
 
         /// <summary>
-        /// Number of warnings enountered in this build
+        /// Number of warnings encountered in this build
         /// </summary>
         /// <owner>t-jeffv, sumedhk</owner>
         internal int warningCount = 0;
 
         /// <summary>
-        /// A list of the errors that have occured during this build.
+        /// A list of the errors that have occurred during this build.
         /// </summary>
         internal ArrayList errorList;
 
         /// <summary>
-        /// A list of the warnings that have occured during this build.
+        /// A list of the warnings that have occurred during this build.
         /// </summary>
         internal ArrayList warningList;
 
diff --git a/src/Deprecated/Engine/Logging/LoggerDescription.cs b/src/Deprecated/Engine/Logging/LoggerDescription.cs
index 50e30d8718e..b505e646692 100644
--- a/src/Deprecated/Engine/Logging/LoggerDescription.cs
+++ b/src/Deprecated/Engine/Logging/LoggerDescription.cs
@@ -175,7 +175,7 @@ private ILogger CreateLogger(bool forwardingLogger)
                 if (innerException is LoggerException)
                 {
                     // Logger failed politely during construction. In order to preserve
-                    // the stack trace at which the error occured we wrap the original
+                    // the stack trace at which the error occurred we wrap the original
                     // exception instead of throwing.
                     LoggerException l = ((LoggerException)innerException);
                     throw new LoggerException(l.Message, innerException, l.ErrorCode, l.HelpKeyword);
diff --git a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
index aeb6d4772a2..d8fa15e6395 100644
--- a/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
+++ b/src/Deprecated/Engine/Logging/ParallelLogger/ParallelLoggerHelpers.cs
@@ -213,7 +213,7 @@ internal TargetStartedEventMinimumFields GetTargetStartedEvent(BuildEventContext
         internal void RemoveProjectStartedEvent(BuildEventContext e)
         {
             ProjectStartedEventMinimumFields startedEvent = GetProjectStartedEvent(e);
-            // Only remove the project from the event list if it is in the list, and no errors have occured in the project
+            // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
             if (startedEvent != null && !startedEvent.ErrorInProject)
             {
                 projectStartedEvents.Remove(e);
@@ -226,7 +226,7 @@ internal void RemoveProjectStartedEvent(BuildEventContext e)
         internal void RemoveTargetStartedEvent(BuildEventContext e)
         {
             TargetStartedEventMinimumFields startedEvent = GetTargetStartedEvent(e);
-            // Only remove the project from the event list if it is in the list, and no errors have occured in the project
+            // Only remove the project from the event list if it is in the list, and no errors have occurred in the project
             if (startedEvent != null && !startedEvent.ErrorInTarget)
             {
                 targetStartedEvents.Remove(e);
diff --git a/src/Deprecated/Engine/Shared/SolutionParser.cs b/src/Deprecated/Engine/Shared/SolutionParser.cs
index 2eccbff2343..0bb83616e54 100644
--- a/src/Deprecated/Engine/Shared/SolutionParser.cs
+++ b/src/Deprecated/Engine/Shared/SolutionParser.cs
@@ -85,10 +85,10 @@ internal class SolutionParser
         // cached default platform name for GetDefaultPlatformName
         private string defaultPlatformName;
 
-        //List of warnings that occured while parsing solution
+        //List of warnings that occurred while parsing solution
         private ArrayList solutionParserWarnings = null;
 
-        //List of comments that occured while parsing solution
+        //List of comments that occurred while parsing solution
         private ArrayList solutionParserComments = null;
 
         // unit-testing only
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index e0317fa9eda..4d85540d8d9 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -24,7 +24,6 @@
     <FeatureAppDomain>true</FeatureAppDomain>
     <DefineConstants>$(DefineConstants);FEATURE_APPDOMAIN_UNHANDLED_EXCEPTION</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_ASPNET_COMPILER</DefineConstants>
-    <DefineConstants>$(DefineConstants);FEATURE_ASSEMBLY_LOADFROM</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_ASSEMBLY_LOCATION</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_ASSEMBLY_GETENTRYASSEMBLY</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_ASSEMBLYNAME_CLONE</DefineConstants>
@@ -120,6 +119,7 @@
 
   <PropertyGroup Condition="'$(NetCoreBuild)'=='true'">
     <CompilerToolsDir>$([System.IO.Path]::Combine($(ToolPackagesDir)Microsoft.Net.Compilers, $(CompilerToolsVersion), "tools"))$([System.IO.Path]::DirectorySeparatorChar)</CompilerToolsDir>
+    <DefineConstants>$(DefineConstants);FEATURE_ASSEMBLYLOADCONTEXT</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_PROCESSSTARTINFO_ENVIRONMENT</DefineConstants>
     <DefineConstants>$(DefineConstants);FEATURE_RUNTIMEINFORMATION</DefineConstants>
     <DefineConstants>$(DefineConstants);USE_MSBUILD_DLL_EXTN</DefineConstants>
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 29931444d46..4996cd7cc45 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -31,9 +31,9 @@ public void BogusSwitchIdentificationTests()
             CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
             string duplicateSwitchErrorMessage;
 
-            Assert.False(CommandLineSwitches.IsParameterlessSwitch("bogus", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Invalid, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
+            CommandLineSwitches.IsParameterlessSwitch("bogus", out parameterlessSwitch, out duplicateSwitchErrorMessage).ShouldBeFalse();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterlessSwitch.Invalid);
+            duplicateSwitchErrorMessage.ShouldBeNull();
 
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             bool multipleParametersAllowed;
@@ -41,213 +41,122 @@ public void BogusSwitchIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.False(CommandLineSwitches.IsParameterizedSwitch("bogus", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Invalid, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.False(unquoteParameters);
+            CommandLineSwitches.IsParameterizedSwitch("bogus", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeFalse();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.Invalid);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldBeNull();
+            unquoteParameters.ShouldBeFalse();
         }
 
-        [Fact]
-        public void HelpSwitchIdentificationTests()
+        [Theory]
+        [InlineData("help")]
+        [InlineData("HELP")]
+        [InlineData("Help")]
+        [InlineData("h")]
+        [InlineData("H")]
+        [InlineData("?")]
+        public void HelpSwitchIdentificationTests(string help)
         {
-            CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
-            string duplicateSwitchErrorMessage;
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("help", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Help, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("HELP", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Help, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("Help", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Help, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("h", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Help, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("H", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Help, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("?", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Help, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
+            CommandLineSwitches.IsParameterlessSwitch(help, out CommandLineSwitches.ParameterlessSwitch parameterlessSwitch, out string duplicateSwitchErrorMessage).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterlessSwitch.Help);
+            duplicateSwitchErrorMessage.ShouldBeNull();
         }
 
-        [Fact]
-        public void VersionSwitchIdentificationTests()
+        [Theory]
+        [InlineData("version")]
+        [InlineData("Version")]
+        [InlineData("VERSION")]
+        [InlineData("ver")]
+        [InlineData("VER")]
+        [InlineData("Ver")]
+        public void VersionSwitchIdentificationTests(string version)
         {
-            CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
-            string duplicateSwitchErrorMessage;
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("version", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Version, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("Version", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Version, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("VERSION", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Version, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("ver", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Version, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("VER", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Version, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("Ver", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.Version, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
+            CommandLineSwitches.IsParameterlessSwitch(version, out CommandLineSwitches.ParameterlessSwitch parameterlessSwitch, out string duplicateSwitchErrorMessage).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterlessSwitch.Version);
+            duplicateSwitchErrorMessage.ShouldBeNull();
         }
 
-        [Fact]
-        public void NoLogoSwitchIdentificationTests()
+        [Theory]
+        [InlineData("nologo")]
+        [InlineData("NOLOGO")]
+        [InlineData("NoLogo")]
+        public void NoLogoSwitchIdentificationTests(string nologo)
         {
-            CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
-            string duplicateSwitchErrorMessage;
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("nologo", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoLogo, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("NOLOGO", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoLogo, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("NoLogo", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoLogo, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
+            CommandLineSwitches.IsParameterlessSwitch(nologo, out CommandLineSwitches.ParameterlessSwitch parameterlessSwitch, out string duplicateSwitchErrorMessage).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterlessSwitch.NoLogo);
+            duplicateSwitchErrorMessage.ShouldBeNull();
         }
 
-        [Fact]
-        public void NoAutoResponseSwitchIdentificationTests()
+        [Theory]
+        [InlineData("noautoresponse")]
+        [InlineData("NOAUTORESPONSE")]
+        [InlineData("NoAutoResponse")]
+        [InlineData("noautorsp")]
+        [InlineData("NOAUTORSP")]
+        [InlineData("NoAutoRsp")]
+        public void NoAutoResponseSwitchIdentificationTests(string noautoresponse)
         {
-            CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
-            string duplicateSwitchErrorMessage;
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("noautoresponse", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoAutoResponse, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("NOAUTORESPONSE", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoAutoResponse, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("NoAutoResponse", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoAutoResponse, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("noautorsp", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoAutoResponse, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("NOAUTORSP", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoAutoResponse, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("NoAutoRsp", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoAutoResponse, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
+            CommandLineSwitches.IsParameterlessSwitch(noautoresponse, out CommandLineSwitches.ParameterlessSwitch parameterlessSwitch, out string duplicateSwitchErrorMessage).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterlessSwitch.NoAutoResponse);
+            duplicateSwitchErrorMessage.ShouldBeNull();
         }
 
-        [Fact]
-        public void NoConsoleLoggerSwitchIdentificationTests()
+        [Theory]
+        [InlineData("noconsolelogger")]
+        [InlineData("NOCONSOLELOGGER")]
+        [InlineData("NoConsoleLogger")]
+        [InlineData("noconlog")]
+        [InlineData("NOCONLOG")]
+        [InlineData("NoConLog")]
+        public void NoConsoleLoggerSwitchIdentificationTests(string noconsolelogger)
         {
             CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
             string duplicateSwitchErrorMessage;
 
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("noconsolelogger", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("NOCONSOLELOGGER", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("NoConsoleLogger", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("noconlog", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("NOCONLOG", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("NoConLog", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
+            CommandLineSwitches.IsParameterlessSwitch(noconsolelogger, out parameterlessSwitch, out duplicateSwitchErrorMessage).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger);
+            duplicateSwitchErrorMessage.ShouldBeNull();
         }
 
-        [Fact]
-        public void FileLoggerSwitchIdentificationTests()
+        [Theory]
+        [InlineData("fileLogger")]
+        [InlineData("FILELOGGER")]
+        [InlineData("FileLogger")]
+        [InlineData("fl")]
+        [InlineData("FL")]
+        public void FileLoggerSwitchIdentificationTests(string filelogger)
         {
             CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
             string duplicateSwitchErrorMessage;
 
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("fileLogger", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.FileLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("FILELOGGER", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.FileLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("FileLogger", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.FileLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("fl", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.FileLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("FL", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.FileLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
+            CommandLineSwitches.IsParameterlessSwitch(filelogger, out parameterlessSwitch, out duplicateSwitchErrorMessage).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterlessSwitch.FileLogger);
+            duplicateSwitchErrorMessage.ShouldBeNull();
         }
 
-        [Fact]
-        public void DistributedFileLoggerSwitchIdentificationTests()
+        [Theory]
+        [InlineData("distributedfilelogger")]
+        [InlineData("DISTRIBUTEDFILELOGGER")]
+        [InlineData("DistributedFileLogger")]
+        [InlineData("dfl")]
+        [InlineData("DFL")]
+        public void DistributedFileLoggerSwitchIdentificationTests(string distributedfilelogger)
         {
             CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
             string duplicateSwitchErrorMessage;
 
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("distributedfilelogger", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("DISTRIBUTEDFILELOGGER", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("DistributedFileLogger", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("dfl", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("DFL", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
+            CommandLineSwitches.IsParameterlessSwitch(distributedfilelogger, out parameterlessSwitch, out duplicateSwitchErrorMessage).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger);
+            duplicateSwitchErrorMessage.ShouldBeNull();
         }
 
-        [Fact]
-        public void FileLoggerParametersIdentificationTests()
+        [Theory]
+        [InlineData("flp")]
+        [InlineData("FLP")]
+        [InlineData("fileLoggerParameters")]
+        [InlineData("FILELOGGERPARAMETERS")]
+        public void FileLoggerParametersIdentificationTests(string fileloggerparameters)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -256,38 +165,21 @@ public void FileLoggerParametersIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("flp", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("FLP", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("fileLoggerParameters", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("FILELOGGERPARAMETERS", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
+            CommandLineSwitches.IsParameterizedSwitch(fileloggerparameters, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldNotBeNull();
+            unquoteParameters.ShouldBeTrue();
         }
 
 #if FEATURE_NODE_REUSE
-        [Fact]
-        public void NodeReuseParametersIdentificationTests()
+        [Theory]
+        [InlineData("nr")]
+        [InlineData("NR")]
+        [InlineData("nodereuse")]
+        [InlineData("NodeReuse")]
+        public void NodeReuseParametersIdentificationTests(string nodereuse)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -296,33 +188,12 @@ public void NodeReuseParametersIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("nr", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.NodeReuse, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("NR", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.NodeReuse, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("nodereuse", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.NodeReuse, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("NodeReuse", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.NodeReuse, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
+            CommandLineSwitches.IsParameterizedSwitch(nodereuse, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.NodeReuse);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldNotBeNull();
+            unquoteParameters.ShouldBeTrue();
         }
 #endif
 
@@ -352,8 +223,13 @@ public void ProjectSwitchIdentificationTests()
             Assert.False(unquoteParameters);
         }
 
-        [Fact]
-        public void IgnoreProjectExtensionsSwitchIdentificationTests()
+        [Theory]
+        [InlineData("ignoreprojectextensions")]
+        [InlineData("IgnoreProjectExtensions")]
+        [InlineData("IGNOREPROJECTEXTENSIONS")]
+        [InlineData("ignore")]
+        [InlineData("IGNORE")]
+        public void IgnoreProjectExtensionsSwitchIdentificationTests(string ignoreprojectextensions)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -362,44 +238,21 @@ public void IgnoreProjectExtensionsSwitchIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("ignoreprojectextensions", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.IgnoreProjectExtensions, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("IgnoreProjectExtensions", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.IgnoreProjectExtensions, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("IGNOREPROJECTEXTENSIONS", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.IgnoreProjectExtensions, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("ignore", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.IgnoreProjectExtensions, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("IGNORE", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.IgnoreProjectExtensions, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
+            CommandLineSwitches.IsParameterizedSwitch(ignoreprojectextensions, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.IgnoreProjectExtensions);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNull();
+            unquoteParameters.ShouldBeTrue();
         }
 
-        [Fact]
-        public void TargetSwitchIdentificationTests()
+        [Theory]
+        [InlineData("target")]
+        [InlineData("TARGET")]
+        [InlineData("Target")]
+        [InlineData("t")]
+        [InlineData("T")]
+        public void TargetSwitchIdentificationTests(string target)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -408,44 +261,21 @@ public void TargetSwitchIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("target", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Target, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("TARGET", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Target, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("Target", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Target, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("t", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Target, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("T", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Target, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
+            CommandLineSwitches.IsParameterizedSwitch(target, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.Target);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNull();
+            unquoteParameters.ShouldBeTrue();
         }
 
-        [Fact]
-        public void PropertySwitchIdentificationTests()
+        [Theory]
+        [InlineData("property")]
+        [InlineData("PROPERTY")]
+        [InlineData("Property")]
+        [InlineData("p")]
+        [InlineData("P")]
+        public void PropertySwitchIdentificationTests(string property)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -454,44 +284,21 @@ public void PropertySwitchIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("property", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Property, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("PROPERTY", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Property, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("Property", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Property, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("p", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Property, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("P", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Property, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.True(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
+            CommandLineSwitches.IsParameterizedSwitch(property, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.Property);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeTrue();
+            missingParametersErrorMessage.ShouldNotBeNull();
+            unquoteParameters.ShouldBeTrue();
         }
 
-        [Fact]
-        public void LoggerSwitchIdentificationTests()
+        [Theory]
+        [InlineData("logger")]
+        [InlineData("LOGGER")]
+        [InlineData("Logger")]
+        [InlineData("l")]
+        [InlineData("L")]
+        public void LoggerSwitchIdentificationTests(string logger)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -500,44 +307,21 @@ public void LoggerSwitchIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("logger", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Logger, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.False(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("LOGGER", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Logger, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.False(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("Logger", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Logger, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.False(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("l", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Logger, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.False(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("L", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Logger, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.False(unquoteParameters);
+            CommandLineSwitches.IsParameterizedSwitch(logger, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.Logger);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldNotBeNull();
+            unquoteParameters.ShouldBeFalse();
         }
 
-        [Fact]
-        public void VerbositySwitchIdentificationTests()
+        [Theory]
+        [InlineData("verbosity")]
+        [InlineData("VERBOSITY")]
+        [InlineData("Verbosity")]
+        [InlineData("v")]
+        [InlineData("V")]
+        public void VerbositySwitchIdentificationTests(string verbosity)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -546,74 +330,36 @@ public void VerbositySwitchIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("verbosity", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Verbosity, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("VERBOSITY", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Verbosity, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("Verbosity", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Verbosity, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("v", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Verbosity, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("V", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Verbosity, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
+            CommandLineSwitches.IsParameterizedSwitch(verbosity, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.Verbosity);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldNotBeNull();
+            unquoteParameters.ShouldBeTrue();
         }
 
-        [Fact]
-        public void DetailedSummarySwitchIndentificationTests()
+        [Theory]
+        [InlineData("ds")]
+        [InlineData("DS")]
+        [InlineData("Ds")]
+        [InlineData("detailedsummary")]
+        [InlineData("DETAILEDSUMMARY")]
+        [InlineData("DetailedSummary")]
+        public void DetailedSummarySwitchIndentificationTests(string detailedsummary)
         {
             CommandLineSwitches.ParameterlessSwitch parameterlessSwitch;
             string duplicateSwitchErrorMessage;
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("ds", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.DetailedSummary, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("DS", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.DetailedSummary, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("Ds", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.DetailedSummary, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("detailedsummary", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.DetailedSummary, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("DETAILEDSUMMARY", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.DetailedSummary, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-
-            Assert.True(CommandLineSwitches.IsParameterlessSwitch("DetailedSummary", out parameterlessSwitch, out duplicateSwitchErrorMessage));
-            Assert.Equal(CommandLineSwitches.ParameterlessSwitch.DetailedSummary, parameterlessSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
+            CommandLineSwitches.IsParameterlessSwitch(detailedsummary, out parameterlessSwitch, out duplicateSwitchErrorMessage).ShouldBeTrue();
+            parameterlessSwitch.ShouldBe(CommandLineSwitches.ParameterlessSwitch.DetailedSummary);
+            duplicateSwitchErrorMessage.ShouldBeNull();
         }
 
-        [Fact]
-        public void MaxCPUCountSwitchIdentificationTests()
+        [Theory]
+        [InlineData("m")]
+        [InlineData("M")]
+        [InlineData("maxcpucount")]
+        [InlineData("MAXCPUCOUNT")]
+        public void MaxCPUCountSwitchIdentificationTests(string maxcpucount)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -622,38 +368,23 @@ public void MaxCPUCountSwitchIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("m", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.MaxCPUCount, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("M", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.MaxCPUCount, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("maxcpucount", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.MaxCPUCount, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("MAXCPUCOUNT", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.MaxCPUCount, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.NotNull(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
+            CommandLineSwitches.IsParameterizedSwitch(maxcpucount, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.MaxCPUCount);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldNotBeNull();
+            unquoteParameters.ShouldBeTrue();
         }
 
 #if FEATURE_XML_SCHEMA_VALIDATION
-        [Fact]
-        public void ValidateSwitchIdentificationTests()
+        [Theory]
+        [InlineData("validate")]
+        [InlineData("VALIDATE")]
+        [InlineData("Validate")]
+        [InlineData("val")]
+        [InlineData("VAL")]
+        [InlineData("Val")]
+        public void ValidateSwitchIdentificationTests(string validate)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -662,52 +393,19 @@ public void ValidateSwitchIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("validate", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Validate, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("VALIDATE", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Validate, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("Validate", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Validate, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("val", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Validate, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("VAL", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Validate, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("Val", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Validate, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
+            CommandLineSwitches.IsParameterizedSwitch(validate, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.Validate);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldBeNull();
+            unquoteParameters.ShouldBeTrue();
         }
 #endif
 
-        [Fact]
-        public void PreprocessSwitchIdentificationTests()
+        [Theory]
+        [InlineData("preprocess")]
+        [InlineData("pp")]
+        public void PreprocessSwitchIdentificationTests(string preprocess)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -716,23 +414,20 @@ public void PreprocessSwitchIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("preprocess", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Preprocess, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("pp", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.Preprocess, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
+            CommandLineSwitches.IsParameterizedSwitch(preprocess, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.Preprocess);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldBeNull();
+            unquoteParameters.ShouldBeTrue();
         }
 
-        [Fact]
-        public void IsolateProjectsSwitchIdentificationTests()
+        [Theory]
+        [InlineData("isolate")]
+        [InlineData("ISOLATE")]
+        [InlineData("isolateprojects")]
+        [InlineData("isolateProjects")]
+        public void IsolateProjectsSwitchIdentificationTests(string isolateprojects)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -741,41 +436,21 @@ public void IsolateProjectsSwitchIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("isolate", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.IsolateProjects, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-            Assert.False(emptyParametersAllowed);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("ISOLATE", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.IsolateProjects, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-            Assert.False(emptyParametersAllowed);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("isolateprojects", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.IsolateProjects, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-            Assert.False(emptyParametersAllowed);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("isolateProjects", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.IsolateProjects, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-            Assert.False(emptyParametersAllowed);
+            CommandLineSwitches.IsParameterizedSwitch(isolateprojects, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.IsolateProjects);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldBeNull();
+            unquoteParameters.ShouldBeTrue();
+            emptyParametersAllowed.ShouldBeFalse();
         }
 
-        [Fact]
-        public void GraphBuildSwitchIdentificationTests()
+        [Theory]
+        [InlineData("graph")]
+        [InlineData("GRAPH")]
+        [InlineData("graphbuild")]
+        [InlineData("graphBuild")]
+        public void GraphBuildSwitchIdentificationTests(string graph)
         {
             CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
             string duplicateSwitchErrorMessage;
@@ -784,37 +459,13 @@ public void GraphBuildSwitchIdentificationTests()
             bool unquoteParameters;
             bool emptyParametersAllowed;
 
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("graph", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.GraphBuild, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-            Assert.False(emptyParametersAllowed);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("GRAPH", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.GraphBuild, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-            Assert.False(emptyParametersAllowed);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("graphbuild", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.GraphBuild, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-            Assert.False(emptyParametersAllowed);
-
-            Assert.True(CommandLineSwitches.IsParameterizedSwitch("graphBuild", out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed));
-            Assert.Equal(CommandLineSwitches.ParameterizedSwitch.GraphBuild, parameterizedSwitch);
-            Assert.Null(duplicateSwitchErrorMessage);
-            Assert.False(multipleParametersAllowed);
-            Assert.Null(missingParametersErrorMessage);
-            Assert.True(unquoteParameters);
-            Assert.False(emptyParametersAllowed);
+            CommandLineSwitches.IsParameterizedSwitch(graph, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.GraphBuild);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldBeNull();
+            unquoteParameters.ShouldBeTrue();
+            emptyParametersAllowed.ShouldBeFalse();
         }
 
         [Fact]
diff --git a/src/MSBuild.UnitTests/ValidateAssemblyLoadContext.cs b/src/MSBuild.UnitTests/ValidateAssemblyLoadContext.cs
new file mode 100644
index 00000000000..4cdcab25b0d
--- /dev/null
+++ b/src/MSBuild.UnitTests/ValidateAssemblyLoadContext.cs
@@ -0,0 +1,46 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#if FEATURE_ASSEMBLYLOADCONTEXT
+
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
+using System.Runtime.Loader;
+
+namespace Microsoft.Build.UnitTests
+{
+    public class ValidateAssemblyLoadContext : Task
+    {
+        public override bool Execute()
+        {
+            var thisLoadContext = AssemblyLoadContext.GetLoadContext(typeof(ValidateAssemblyLoadContext).Assembly);
+
+            // The straightforward implementation of this check:
+            //   if (thisLoadContext is MSBuildLoadContext context)
+            // fails here because MSBuildLoadContext (in this test assembly) is from MSBuild.exe via
+            // IVT, but the one that actually gets used for task isolation is in Microsoft.Build.dll.
+            // This probably doesn't need to be how it is forever: https://github.com/microsoft/msbuild/issues/5041
+            if (thisLoadContext.GetType().FullName == typeof(MSBuildLoadContext).FullName)
+            {
+#if NETCOREAPP && !NETCOREAPP2_1 // TODO: enable this functionality when targeting .NET Core 3.0+
+                if (!thisLoadContext.Name.EndsWith(typeof(ValidateAssemblyLoadContext).Assembly.GetName().Name + ".dll"))
+                {
+                    Log.LogError($"Unexpected AssemblyLoadContext name: \"{thisLoadContext.Name}\", but the current executing assembly was {typeof(ValidateAssemblyLoadContext).Assembly.GetName().Name}");
+                }
+                else
+                {
+                    Log.LogMessage(MessageImportance.High, $"Task {nameof(ValidateAssemblyLoadContext)} loaded in AssemblyLoadContext named {thisLoadContext.Name}");
+                }
+#endif
+            }
+            else
+            {
+                Log.LogError($"Load context was a {thisLoadContext.GetType().AssemblyQualifiedName} instead of an {typeof(MSBuildLoadContext).AssemblyQualifiedName}");
+            }
+
+            return !Log.HasLoggedErrors;
+        }
+    }
+}
+#endif
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index 652fe6593ce..9e448504a9c 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -18,6 +18,7 @@
 using Xunit.Abstractions;
 using Shouldly;
 using System.IO.Compression;
+using System.Reflection;
 
 namespace Microsoft.Build.UnitTests
 {
@@ -2119,6 +2120,34 @@ public void BinaryLogContainsImportedFiles()
             }
         }
 
+#if FEATURE_ASSEMBLYLOADCONTEXT
+        /// <summary>
+        /// Ensure that tasks get loaded into their own <see cref="System.Runtime.Loader.AssemblyLoadContext"/>.
+        /// </summary>
+        /// <remarks>
+        /// When loading a task from a test assembly in a test within that assembly, the assembly is already loaded
+        /// into the default context. So put the test here and isolate the task into an MSBuild that runs in its
+        /// own process, causing it to newly load the task (test) assembly in a new ALC.
+        /// </remarks>
+        [Fact]
+        public void TasksGetAssemblyLoadContexts()
+        {
+            string customTaskPath = Assembly.GetExecutingAssembly().Location;
+
+            string projectContents = $@"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+  <UsingTask TaskName=`ValidateAssemblyLoadContext` AssemblyFile=`{customTaskPath}` />
+
+  <Target Name=`Build`>
+    <ValidateAssemblyLoadContext />
+  </Target>
+</Project>";
+
+            ExecuteMSBuildExeExpectSuccess(projectContents);
+        }
+
+#endif
+
+
         private string CopyMSBuild()
         {
             string dest = null;
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 67af1aa070c..6ffb8fd6f9d 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -135,6 +135,7 @@
     <Compile Include="..\Shared\OutOfProcTaskHostTaskResult.cs" />
     <Compile Include="..\Shared\TaskHostTaskCancelled.cs" />
     <Compile Include="..\Shared\TaskLoader.cs" />
+    <Compile Include="..\Shared\MSBuildLoadContext.cs" Condition="'$(TargetFrameworkIdentifier)'!='.NETFramework'" />
     <Compile Include="..\Shared\TypeLoader.cs" />
     <Compile Include="..\Shared\LoadedType.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index dea55cd58d4..1680296dd96 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -3563,13 +3563,14 @@ private static void ReplayBinaryLog
 
             foreach (var distributedLoggerRecord in distributedLoggerRecords)
             {
-                if (distributedLoggerRecord.CentralLogger is INodeLogger nodeLogger)
+                ILogger centralLogger = distributedLoggerRecord.CentralLogger;
+                if (centralLogger is INodeLogger nodeLogger)
                 {
                     nodeLogger.Initialize(replayEventSource, cpuCount);
                 }
-                else
+                else if (centralLogger != null)
                 {
-                    distributedLoggerRecord.CentralLogger.Initialize(replayEventSource);
+                    centralLogger.Initialize(replayEventSource);
                 }
             }
 
@@ -3602,7 +3603,7 @@ private static void ReplayBinaryLog
 
             foreach (var distributedLoggerRecord in distributedLoggerRecords)
             {
-                distributedLoggerRecord.CentralLogger.Shutdown();
+                distributedLoggerRecord.CentralLogger?.Shutdown();
             }
         }
 
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index b467ede1ed0..d175b224579 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -48,8 +48,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.CPPTasks.Common" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="16.0.0.0-16.5.0.0" newVersion="16.5.0.0" />
-          <codeBase version="16.5.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
+          <bindingRedirect oldVersion="16.0.0.0-16.6.0.0" newVersion="16.6.0.0" />
+          <codeBase version="16.6.0.0" href="..\..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
         <!-- Redirects for components dropped by Visual Studio -->
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index 215bbed847c..15228cfffa0 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -54,8 +54,8 @@
         </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="Microsoft.Build.CPPTasks.Common" culture="neutral" publicKeyToken="b03f5f7f11d50a3a" />
-          <bindingRedirect oldVersion="16.0.0.0-16.5.0.0" newVersion="16.5.0.0" />
-          <codeBase version="16.5.0.0" href="..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
+          <bindingRedirect oldVersion="16.0.0.0-16.6.0.0" newVersion="16.6.0.0" />
+          <codeBase version="16.6.0.0" href="..\..\Microsoft\VC\v160\Microsoft.Build.CPPTasks.Common.dll" />
         </dependentAssembly>
 
         <!-- Workaround for crash in C++ CodeAnalysis scenarios due to https://github.com/Microsoft/msbuild/issues/1675 -->
diff --git a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
index faa791b0c73..3d2c3a79701 100644
--- a/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
+++ b/src/Package/MSBuild.Engine.Corext/MsBuild.Engine.Corext.nuspec
@@ -30,6 +30,12 @@
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/Microsoft.Bcl.AsyncInterfaces.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Buffers.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Text.Encodings.Web.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.Threading.Tasks.Extensions.dll" target="v15.0/bin" />
+    <file src="$X86BinPath$/System.ValueTuple.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Numerics.Vectors.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin" />
@@ -76,6 +82,12 @@
     <file src="$X86BinPath$/Microsoft.Build.Utilities.Core.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Collections.Immutable.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Memory.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Text.Json.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/Microsoft.Bcl.AsyncInterfaces.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Buffers.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Text.Encodings.Web.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.Threading.Tasks.Extensions.dll" target="v15.0/bin/amd64" />
+    <file src="$X86BinPath$/System.ValueTuple.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Numerics.Vectors.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Resources.Extensions.dll" target="v15.0/bin/amd64" />
     <file src="$X86BinPath$/System.Runtime.CompilerServices.Unsafe.dll" target="v15.0/bin/amd64" />
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 17f17010bf3..117a5582398 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -28,6 +28,11 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.ValueTuple.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
@@ -169,6 +174,11 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Threading.Tasks.Extensions.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.ValueTuple.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Numerics.Vectors.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Resources.Extensions.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Runtime.CompilerServices.Unsafe.dll vs.file.ngenArchitecture=all
diff --git a/src/Shared/AssemblyNameExtension.cs b/src/Shared/AssemblyNameExtension.cs
index a4b0e0e2e00..78b09cdefbf 100644
--- a/src/Shared/AssemblyNameExtension.cs
+++ b/src/Shared/AssemblyNameExtension.cs
@@ -11,7 +11,7 @@
 using System.Configuration.Assemblies;
 using System.Runtime.Serialization;
 using System.IO;
-#if !FEATURE_ASSEMBLY_LOADFROM
+#if FEATURE_ASSEMBLYLOADCONTEXT
 using System.Reflection.PortableExecutable;
 using System.Reflection.Metadata;
 #endif
@@ -183,7 +183,7 @@ private AssemblyNameExtension(SerializationInfo info, StreamingContext context)
         internal static AssemblyNameExtension GetAssemblyNameEx(string path)
         {
             AssemblyName assemblyName = null;
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             try
             {
                 assemblyName = AssemblyName.GetAssemblyName(path);
diff --git a/src/Shared/CoreCLRAssemblyLoader.cs b/src/Shared/CoreCLRAssemblyLoader.cs
index 8a3cdb023a8..25b5f21ee6e 100644
--- a/src/Shared/CoreCLRAssemblyLoader.cs
+++ b/src/Shared/CoreCLRAssemblyLoader.cs
@@ -5,8 +5,6 @@
 using System.Diagnostics;
 using System.IO;
 using System.Reflection;
-using System.Runtime.Loader;
-using Microsoft.Build.Shared.FileSystem;
 
 namespace Microsoft.Build.Shared
 {
@@ -16,35 +14,8 @@ namespace Microsoft.Build.Shared
     internal sealed class CoreClrAssemblyLoader
     {
         private readonly Dictionary<string, Assembly> _pathsToAssemblies = new Dictionary<string, Assembly>(StringComparer.OrdinalIgnoreCase);
-        private readonly Dictionary<string, Assembly> _namesToAssemblies = new Dictionary<string, Assembly>();
-        private readonly HashSet<string> _dependencyPaths = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
         private readonly object _guard = new object();
 
-        private bool _resolvingHandlerHookedUp = false;
-
-        private static readonly string[] _extensions = new[] { "ni.dll", "ni.exe", "dll", "exe" };
-        private static readonly Version _currentAssemblyVersion = new Version(Microsoft.Build.Shared.MSBuildConstants.CurrentAssemblyVersion);
-        private static readonly HashSet<string> _wellKnownAssemblyNames = new HashSet<string>(
-            new[]
-            {
-                "Microsoft.Build",
-                "Microsoft.Build.Framework",
-                "Microsoft.Build.Tasks.Core",
-                "Microsoft.Build.Utilities.Core"
-            });
-
-        public void AddDependencyLocation(string fullPath)
-        {
-            if (fullPath == null)
-            {
-                throw new ArgumentNullException(nameof(fullPath));
-            }
-
-            lock (_guard)
-            {
-                _dependencyPaths.Add(fullPath);
-            }
-        }
 
         public Assembly LoadFromPath(string fullPath)
         {
@@ -57,113 +28,23 @@ public Assembly LoadFromPath(string fullPath)
 
             lock (_guard)
             {
-                if (!_resolvingHandlerHookedUp)
-                {
-                    AssemblyLoadContext.Default.Resolving += TryResolveAssembly;
-                    _resolvingHandlerHookedUp = true;
-                }
-
                 Assembly assembly;
                 if (_pathsToAssemblies.TryGetValue(fullPath, out assembly))
                 {
                     return assembly;
                 }
 
-                return LoadAndCache(AssemblyLoadContext.Default, fullPath);
-            }
-        }
+                var contextForAssemblyPath = new MSBuildLoadContext(fullPath);
 
-        private Assembly TryGetWellKnownAssembly(AssemblyLoadContext context, AssemblyName assemblyName)
-        {
-            if (!_wellKnownAssemblyNames.Contains(assemblyName.Name))
-            {
-                return null;
-            }
-
-            // Ensure we are attempting to load a matching version
-            // of the Microsoft.Build.* assembly.
-            assemblyName.Version = _currentAssemblyVersion;
-
-            var searchPaths = new[] { Assembly.GetExecutingAssembly().Location };
-            return TryResolveAssemblyFromPaths(context, assemblyName, searchPaths);
-        }
-
-        private Assembly TryResolveAssembly(AssemblyLoadContext context, AssemblyName assemblyName)
-        {
-            lock (_guard)
-            {
-                Assembly assembly = TryGetWellKnownAssembly(context, assemblyName);
+                assembly = contextForAssemblyPath.LoadFromAssemblyPath(fullPath);
 
                 if (assembly != null)
                 {
-                    return assembly;
-                }
-
-                if (_namesToAssemblies.TryGetValue(assemblyName.FullName, out assembly))
-                {
-                    return assembly;
+                    _pathsToAssemblies[fullPath] = assembly;
                 }
 
-                return TryResolveAssemblyFromPaths(context, assemblyName, _dependencyPaths);
-            }
-        }
-
-        private Assembly TryResolveAssemblyFromPaths(AssemblyLoadContext context, AssemblyName assemblyName, IEnumerable<string> searchPaths)
-        {
-            foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
-                // If no culture is specified, attempt to load directly from
-                // the known dependency paths.
-                ? new[] { string.Empty }
-                // Search for satellite assemblies in culture subdirectories
-                // of the assembly search directories, but fall back to the
-                // bare search directory if that fails.
-                : new[] { assemblyName.CultureName, string.Empty })
-            {
-                foreach (var searchPath in searchPaths)
-                {
-                    foreach (var extension in _extensions)
-                    {
-                        var candidatePath = Path.Combine(searchPath,
-                            cultureSubfolder,
-                            $"{assemblyName.Name}.{extension}");
-
-                        if (IsAssemblyAlreadyLoaded(candidatePath) ||
-                            !FileSystems.Default.FileExists(candidatePath))
-                        {
-                            continue;
-                        }
-
-                        AssemblyName candidateAssemblyName = AssemblyLoadContext.GetAssemblyName(candidatePath);
-                        if (candidateAssemblyName.Version != assemblyName.Version)
-                        {
-                            continue;
-                        }
-
-                        return LoadAndCache(context, candidatePath);
-                    }
-                }
+                return assembly;
             }
-
-            return null;
-        }
-
-        /// <remarks>
-        /// Assumes we have a lock on _guard
-        /// </remarks>
-        private Assembly LoadAndCache(AssemblyLoadContext context, string fullPath)
-        {
-            var assembly = context.LoadFromAssemblyPath(fullPath);
-            var name = assembly.FullName;
-
-            _pathsToAssemblies[fullPath] = assembly;
-            _namesToAssemblies[name] = assembly;
-
-            return assembly;
-        }
-
-        private bool IsAssemblyAlreadyLoaded(string path)
-        {
-            return _pathsToAssemblies.ContainsKey(path);
         }
     }
 }
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 14b6c56b35f..09950a60c49 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -1222,7 +1222,7 @@ private static void AppendRegularExpressionFromFixedDirectory(ReuseableStringBui
         ///
         /// (1) The leading **\ if existing
         ///
-        /// (2) Each occurence of recursive wildcard \**\
+        /// (2) Each occurrence of recursive wildcard \**\
         /// 
         /// (3) Common filespec characters
         /// </summary>
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 92c330b45e3..99661543b4b 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -954,12 +954,21 @@ internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem f
         }
 
         /// <summary>
-        /// This method returns true if the specified filename is a solution file (.sln), otherwise
-        /// it returns false.
+        /// This method returns true if the specified filename is a solution file (.sln) or
+        /// solution filter file (.slnf); otherwise, it returns false.
         /// </summary>
+        /// <remarks>
+        /// Solution filters are included because they are a thin veneer over solutions, just
+        /// with a more limited set of projects to build, and should be treated the same way.
+        /// </remarks>
         internal static bool IsSolutionFilename(string filename)
         {
-            return HasExtension(filename, ".sln");
+            return HasExtension(filename, ".sln") || HasExtension(filename, ".slnf");
+        }
+
+        internal static bool IsSolutionFilterFilename(string filename)
+        {
+            return HasExtension(filename, ".slnf");
         }
 
         /// <summary>
diff --git a/src/Shared/MSBuildLoadContext.cs b/src/Shared/MSBuildLoadContext.cs
new file mode 100644
index 00000000000..1e5d15d03de
--- /dev/null
+++ b/src/Shared/MSBuildLoadContext.cs
@@ -0,0 +1,97 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+
+using Microsoft.Build.Shared.FileSystem;
+using System;
+using System.Collections.Immutable;
+using System.IO;
+using System.Reflection;
+using System.Runtime.Loader;
+
+#nullable enable
+namespace Microsoft.Build.Shared
+{
+    /// <summary>
+    /// This class is used to isolate the types used by an MSBuild plugin
+    /// (SDK resolver, logger, or task).
+    /// </summary>
+    internal class MSBuildLoadContext : AssemblyLoadContext
+    {
+        private readonly string _directory;
+        private readonly object _guard = new object();
+
+        private static readonly ImmutableHashSet<string> _wellKnownAssemblyNames =
+            new[]
+            {
+                "MSBuild",
+                "Microsoft.Build",
+                "Microsoft.Build.Framework",
+                "Microsoft.Build.Tasks.Core",
+                "Microsoft.Build.Utilities.Core",
+            }.ToImmutableHashSet();
+
+        private static readonly string[] _extensions = new[] { "ni.dll", "ni.exe", "dll", "exe" };
+
+
+        public MSBuildLoadContext(string assemblyPath)
+        {
+            _directory = Directory.GetParent(assemblyPath).FullName;
+        }
+
+        protected override Assembly? Load(AssemblyName assemblyName)
+        {
+            if (_wellKnownAssemblyNames.Contains(assemblyName.Name!))
+            {
+                // Force MSBuild assemblies to be loaded in the default ALC
+                // and unify to the current version.
+                return null;
+            }
+
+            foreach (var cultureSubfolder in string.IsNullOrEmpty(assemblyName.CultureName)
+                // If no culture is specified, attempt to load directly from
+                // the known dependency paths.
+                ? new[] { string.Empty }
+                // Search for satellite assemblies in culture subdirectories
+                // of the assembly search directories, but fall back to the
+                // bare search directory if that fails.
+                : new[] { assemblyName.CultureName, string.Empty })
+            {
+                foreach (var extension in _extensions)
+                {
+                    var candidatePath = Path.Combine(_directory,
+                        cultureSubfolder,
+                        $"{assemblyName.Name}.{extension}");
+
+                    if (!FileSystems.Default.FileExists(candidatePath))
+                    {
+                        continue;
+                    }
+
+                    AssemblyName candidateAssemblyName = AssemblyLoadContext.GetAssemblyName(candidatePath);
+                    if (candidateAssemblyName.Version != assemblyName.Version)
+                    {
+                        continue;
+                    }
+
+                    return LoadFromAssemblyPath(candidatePath);
+                }
+            }
+
+            // If the Assembly is provided via a file path, the following rules are used to load the assembly:
+            // - the assembly from the user specified path is loaded, if it exists, into the custom ALC, or
+            // - if the simple name of the assembly exists in the same folder as msbuild.exe, then that assembly gets loaded
+            //   into the default ALC (so it's shared with other uses).
+
+            var assemblyNameInExecutableDirectory = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
+                assemblyName.Name);
+
+            if (FileSystems.Default.FileExists(assemblyNameInExecutableDirectory))
+            {
+                return AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyNameInExecutableDirectory);
+            }
+
+            return null;
+        }
+    }
+}
diff --git a/src/Shared/NativeMethodsShared.cs b/src/Shared/NativeMethodsShared.cs
index 4b81c06e13c..15751561086 100644
--- a/src/Shared/NativeMethodsShared.cs
+++ b/src/Shared/NativeMethodsShared.cs
@@ -670,6 +670,11 @@ internal static string GetOSNameForExtensionsPath()
             return IsOSX ? "osx" : IsUnixLike ? "unix" : "windows";
         }
 
+        internal static bool OSUsesCaseSensitivePaths
+        {
+            get { return IsLinux; }
+        }
+
         /// <summary>
         /// The base directory for all framework paths in Mono
         /// </summary>
diff --git a/src/Shared/ProjectFileErrorUtilities.cs b/src/Shared/ProjectFileErrorUtilities.cs
index 9e49658e8b4..b69f4998adc 100644
--- a/src/Shared/ProjectFileErrorUtilities.cs
+++ b/src/Shared/ProjectFileErrorUtilities.cs
@@ -77,6 +77,29 @@ params object[] args
             VerifyThrowInvalidProjectFile(condition, null, projectFile, resourceName, args);
         }
 
+        /// <summary>
+        /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
+        /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
+        /// 
+        /// PERF WARNING: calling a method that takes a variable number of arguments is expensive, because memory is allocated for
+        /// the array of arguments -- do not call this method repeatedly in performance-critical scenarios
+        /// </summary>
+        /// <param name="condition">The condition to check.</param>
+        /// <param name="errorSubCategoryResourceName">The resource string for the error sub-category (can be null).</param>
+        /// <param name="projectFile">The invalid project file.</param>
+        /// <param name="resourceName">The resource string for the error message.</param>
+        /// <param name="args">Extra arguments for formatting the error message.</param>
+        internal static void VerifyThrowInvalidProjectFile
+        (
+            string errorSubCategoryResourceName,
+            BuildEventFileInfo projectFile,
+            string resourceName,
+            params object[] args
+        )
+        {
+            VerifyThrowInvalidProjectFile(false, errorSubCategoryResourceName, projectFile, null, resourceName, args);
+        }
+
         /// <summary>
         /// This method is used to flag errors in the project file being processed. Do NOT use this method in place of
         /// ErrorUtilities.VerifyThrow(), because ErrorUtilities.VerifyThrow() is used to flag internal/programming errors.
diff --git a/src/Shared/Resources/Strings.shared.resx b/src/Shared/Resources/Strings.shared.resx
index 2b6a5b23284..fd568252430 100644
--- a/src/Shared/Resources/Strings.shared.resx
+++ b/src/Shared/Resources/Strings.shared.resx
@@ -48,107 +48,107 @@
   <resheader name="writer">
     <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
   </resheader>
-  <data name="BuildAborted" UESanitized="false" Visibility="Public">
+  <data name="BuildAborted" Visibility="Public">
     <value>MSB4188: Build was canceled.</value>
     <comment>{StrBegin="MSB4188: "} Error when the build stops suddenly for some reason. For example, because a child node died.</comment>
   </data>
-  <data name="BuildEngineCallbacksInTaskHostUnsupported" UESanitized="false" Visibility="Public">
+  <data name="BuildEngineCallbacksInTaskHostUnsupported" Visibility="Public">
     <value>MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</value>
     <comment>{StrBegin="MSB5022: "} "Runtime", "Architecture", "MSBuildRuntime", and "MSBuildArchitecture" are all attributes in the project file, and thus should not be localized.</comment>
   </data>
   <data name="BuildStarted" UESanitized="false" Visibility="Public">
     <value>Build started.</value>
   </data>
-  <data name="ConflictingTaskAssembly" UESanitized="false" Visibility="Public">
+  <data name="ConflictingTaskAssembly" Visibility="Public">
     <value>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</value>
     <comment>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</comment>
   </data>
-  <data name="ExpectedEventToBeSerializable" UESanitized="false" Visibility="Public">
+  <data name="ExpectedEventToBeSerializable" Visibility="Public">
     <value>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</value>
   </data>
-  <data name="FileLocation" UESanitized="false" Visibility="Public">
+  <data name="FileLocation" Visibility="Public">
     <value>{0} ({1},{2})</value>
     <comment>A file location to be embedded in a string.</comment>
   </data>
-  <data name="ModifyingTaskHostEnvironmentHeader" UESanitized="false" Visibility="Public">
+  <data name="ModifyingTaskHostEnvironmentHeader" Visibility="Public">
     <value>Making the following modifications to the environment received from the parent node before applying it to the task host:</value>
     <comment>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</comment>
   </data>
-  <data name="ModifyingTaskHostEnvironmentVariable" UESanitized="false" Visibility="Public">
+  <data name="ModifyingTaskHostEnvironmentVariable" Visibility="Public">
     <value>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</value>
     <comment>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</comment>
   </data>
-  <data name="InvalidProjectFile" UESanitized="false" Visibility="Public">
+  <data name="InvalidProjectFile" Visibility="Public">
     <value>MSB4025: The project file could not be loaded. {0}</value>
     <comment>{StrBegin="MSB4025: "}UE: This message is shown when the project file given to the engine cannot be loaded because the filename/path is
     invalid, or due to lack of permissions, or incorrect XML. The project filename is not part of the message because it is
     provided separately to loggers.
     LOCALIZATION: {0} is a localized message from the CLR/FX explaining why the project is invalid.</comment>
   </data>
-  <data name="InvalidVerbosity" UESanitized="false" Visibility="Public">
+  <data name="InvalidVerbosity" Visibility="Public">
     <value>MSB4103: "{0}" is not a valid logger verbosity level.</value>
     <comment>{StrBegin="MSB4103: "}</comment>
   </data>
-  <data name="InvalidLogFileFormat" UESanitized="false" Visibility="Public">
+  <data name="InvalidLogFileFormat" Visibility="Public">
     <value>MSB4233: There was an exception while reading the log file: {0}</value>
     <comment>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</comment>
   </data>
-  <data name="MissingProject" UESanitized="false" Visibility="Private_OM">
+  <data name="MissingProject" Visibility="Private_OM">
     <value>MSBuild is expecting a valid "{0}" object.</value>
   </data>
-  <data name="UnrecognizedToolsVersion" UESanitized="false" Visibility="Public">
+  <data name="UnrecognizedToolsVersion" Visibility="Public">
     <value>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</value>
     <comment>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</comment>
   </data>
-  <data name="NameInvalid" UESanitized="false" Visibility="Public">
+  <data name="NameInvalid" Visibility="Public">
     <value>MSB5016: The name "{0}" contains an invalid character "{1}".</value>
     <comment>{StrBegin="MSB5016: "}</comment>
   </data>
-  <data name="Shared.CannotChangeItemSpecModifiers" UESanitized="false" Visibility="Private_OM">
+  <data name="Shared.CannotChangeItemSpecModifiers" Visibility="Private_OM">
     <value>"{0}" is a reserved item metadata, and cannot be modified or deleted.</value>
     <comment>UE: Tasks and OM users are not allowed to remove or change the value of the built-in metadata on items e.g. the meta-data "FullPath", "RelativeDir", etc. are reserved.</comment>
   </data>
-  <data name="Shared.CannotConvertStringToBool" UESanitized="false" Visibility="Public">
+  <data name="Shared.CannotConvertStringToBool" Visibility="Public">
     <value>The string "{0}" cannot be converted to a boolean (true/false) value.</value>
   </data>
-  <data name="Shared.FailedCreatingTempFile" UESanitized="false" Visibility="Public">
+  <data name="Shared.FailedCreatingTempFile" Visibility="Public">
     <value>MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</value>
     <comment>{StrBegin="MSB5003: "}</comment>
   </data>
-  <data name="Shared.FailedDeletingTempFile" UESanitized="false" Visibility="Public">
+  <data name="Shared.FailedDeletingTempFile" Visibility="Public">
     <value>MSB5018: Failed to delete the temporary file "{0}". {1}</value>
     <comment>{StrBegin="MSB5018: "}</comment>
   </data>
-  <data name="Shared.InvalidFilespecForTransform" UESanitized="false" Visibility="Public">
+  <data name="Shared.InvalidFilespecForTransform" Visibility="Public">
     <value>The item metadata "%({0})" cannot be applied to the path "{1}". {2}</value>
     <comment>UE: This message is shown when the user tries to perform path manipulations using one of the built-in item metadata e.g. %(RootDir), on an item-spec that's not a valid path. LOCALIZATION: "{2}" is a localized message from a CLR/FX exception.</comment>
   </data>
-  <data name="TaskNotMarshalByRef" UESanitized="false" Visibility="Public">
+  <data name="TaskNotMarshalByRef" Visibility="Public">
     <value>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</value>
     <comment>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</comment>
   </data>
-  <data name="FrameworkLocationHelper.UnsupportedFrameworkVersion" UESanitized="false" Visibility="Private_OM">
+  <data name="FrameworkLocationHelper.UnsupportedFrameworkVersion" Visibility="Private_OM">
     <value>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</value>
   </data>
-  <data name="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk" UESanitized="false" Visibility="Private_OM">
+  <data name="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk" Visibility="Private_OM">
     <value>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</value>
   </data>
-  <data name="FrameworkLocationHelper.UnsupportedVisualStudioVersion" UESanitized="false" Visibility="Private_OM">
+  <data name="FrameworkLocationHelper.UnsupportedVisualStudioVersion" Visibility="Private_OM">
     <value>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</value>
   </data>
   <data name="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
     <value>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</value>
     <comment>No Error code because this resource will be used in an exception. The error code is discarded if it is included</comment>
   </data>
-  <data name="DirectoryNotFound" UESanitized="false" Visibility="Public">
+  <data name="DirectoryNotFound" Visibility="Public">
     <value>Could not find directory path: {0}</value>
     <comment>Directory must exist</comment>
   </data>
-  <data name="UnauthorizedAccess" UESanitized="false" Visibility="Public">
+  <data name="UnauthorizedAccess" Visibility="Public">
     <value>You do not have access to: {0}</value>
     <comment>Directory must have access</comment>
   </data>
-  <data name="SubCategoryForSchemaValidationErrors" UESanitized="false" Visibility="Public">
+  <data name="SubCategoryForSchemaValidationErrors" Visibility="Public">
     <value>Schema validation</value>
     <comment>
       UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
@@ -161,92 +161,92 @@
     <value>MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</value>
     <comment>{StrBegin="MSB5002: "}</comment>
   </data>
-  <data name="Shared.ParameterCannotBeNull" UESanitized="false" Visibility="Public">
+  <data name="Shared.ParameterCannotBeNull" Visibility="Public">
     <value>Parameter "{0}" cannot be null.</value>
   </data>
-  <data name="Shared.ParameterCannotHaveInvalidPathChars" UESanitized="false" Visibility="Public">
+  <data name="Shared.ParameterCannotHaveInvalidPathChars" Visibility="Public">
     <value>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</value>
   </data>
-  <data name="Shared.ParameterCannotHaveZeroLength" UESanitized="false" Visibility="Public">
+  <data name="Shared.ParameterCannotHaveZeroLength" Visibility="Public">
     <value>Parameter "{0}" cannot have zero length.</value>
   </data>
-  <data name="Shared.ParametersMustHaveTheSameLength" UESanitized="false" Visibility="Public">
+  <data name="Shared.ParametersMustHaveTheSameLength" Visibility="Public">
     <value>Parameters "{0}" and "{1}" must have the same number of elements.</value>
   </data>
-  <data name="Shared.TaskResourceNotFound" UESanitized="false" Visibility="Private_OM">
+  <data name="Shared.TaskResourceNotFound" Visibility="Private_OM">
     <value>The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</value>
   </data>
-  <data name="Shared.TaskResourcesNotRegistered" UESanitized="false" Visibility="Private_OM">
+  <data name="Shared.TaskResourcesNotRegistered" Visibility="Private_OM">
     <value>The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</value>
     <comment>LOCALIZATION: "TaskLoggingHelper.FormatResourceString()" and "TaskResources" should not be localized.</comment>
   </data>
-  <data name="SolutionParseDuplicateProject" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseDuplicateProject" Visibility="Public">
     <value>MSB5004: The solution file has two projects named "{0}".</value>
     <comment>{StrBegin="MSB5004: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseInvalidProjectFileNameCharacters" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseInvalidProjectFileNameCharacters" Visibility="Public">
     <value>MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</value>
     <comment>{StrBegin="MSB5005: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseInvalidProjectFileNameEmpty" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseInvalidProjectFileNameEmpty" Visibility="Public">
     <value>MSB5006: Error parsing project section for project "{0}". The project file name is empty.</value>
     <comment>{StrBegin="MSB5006: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseInvalidProjectSolutionConfigurationEntry" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseInvalidProjectSolutionConfigurationEntry" Visibility="Public">
     <value>MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</value>
     <comment>{StrBegin="MSB5007: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseInvalidSolutionConfigurationEntry" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseInvalidSolutionConfigurationEntry" Visibility="Public">
     <value>MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</value>
     <comment>{StrBegin="MSB5008: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseNestedProjectError" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseNestedProjectError" Visibility="Public">
     <value>MSB5009: Error parsing the nested project section in solution file.</value>
     <comment>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseNestedProjectUndefinedError" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseNestedProjectUndefinedError" Visibility="Public">
     <value>MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</value>
     <comment>{StrBegin="MSB5023: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseNoHeaderError" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseNoHeaderError" Visibility="Public">
     <value>MSB5010: No file format header found.</value>
     <comment>{StrBegin="MSB5010: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseProjectDepGuidError" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseProjectDepGuidError" Visibility="Public">
     <value>MSB5011: Parent project GUID not found in "{0}" project dependency section.</value>
     <comment>{StrBegin="MSB5011: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseProjectEofError" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseProjectEofError" Visibility="Public">
     <value>MSB5012: Unexpected end-of-file reached inside "{0}" project section.</value>
     <comment>{StrBegin="MSB5012: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseProjectError" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseProjectError" Visibility="Public">
     <value>MSB5013: Error parsing a project section.</value>
     <comment>{StrBegin="MSB5013: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseVersionMismatchError" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseVersionMismatchError" Visibility="Public">
     <value>MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</value>
     <comment>{StrBegin="MSB5014: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="SolutionParseWebProjectPropertiesError" UESanitized="false" Visibility="Public">
+  <data name="SolutionParseWebProjectPropertiesError" Visibility="Public">
     <value>MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</value>
     <comment>{StrBegin="MSB5015: "}UE: The solution filename is provided separately to loggers.</comment>
   </data>
-  <data name="UnrecognizedSolutionComment" UESanitized="false" Visibility="Public">
+  <data name="UnrecognizedSolutionComment" Visibility="Public">
     <value>Unrecognized solution version "{0}", attempting to continue.</value>
   </data>
-  <data name="SubCategoryForSolutionParsingErrors" UESanitized="false" Visibility="Public">
+  <data name="SubCategoryForSolutionParsingErrors" Visibility="Public">
     <value>Solution file</value>
     <comment>UE: this fragment is used to describe errors found while parsing solution files. For example, if a normal error is
       displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from solution parsing would look like this:
       "MSBUILD : Solution file error MSB0000: This is an error."
       LOCALIZATION: This fragment needs to be localized.</comment>
   </data>
-  <data name="Shared.InvalidProjectFile" UESanitized="false" Visibility="Public">
+  <data name="Shared.InvalidProjectFile" Visibility="Public">
     <value>MSB5019: The project file is malformed: "{0}". {1}</value>
     <comment>{StrBegin="MSB5019: "}</comment>
   </data>
-  <data name="Shared.ProjectFileCouldNotBeLoaded" UESanitized="false" Visibility="Public">
+  <data name="Shared.ProjectFileCouldNotBeLoaded" Visibility="Public">
     <value>MSB5020: Could not load the project file: "{0}". {1}</value>
     <comment>{StrBegin="MSB5020: "}</comment>
   </data>
@@ -262,10 +262,22 @@
     <value>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</value>
     <comment></comment>
   </data>
+  <data name="SolutionFilterJsonParsingError" Visibility="Public">
+    <value>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</value>
+    <comment>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</comment>
+  </data>
+  <data name="SolutionFilterMissingSolutionError" Visibility="Public">
+    <value>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</value>
+    <comment>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</comment>
+  </data>
+  <data name="SolutionFilterFilterContainsProjectNotInSolution" Visibility="Public">
+    <value>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</value>
+    <comment>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</comment>
+  </data>
   <!--
         The shared message bucket is: MSB5001 - MSB5999
 
-        Next message code should be MSB5025
+        Next message code should be MSB5029
 
         Some unused codes which can also be reused (because their messages were deleted, and UE hasn't indexed the codes yet):
             <none>
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index 5d65ee0a93b..00a783fd1db 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Cesta: {0} pekrauje maximln limit pro cestu k OS. Pln kvalifikovan nzev souboru mus bt krat ne {1} znak.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Verze nstroj {0} je neznm. Dostupn verze nstroj jsou {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index 0a0fce1dbb9..e3bd8284ae0 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Der Pfad "{0}" berschreitet das maximale Pfadlimit des Betriebssystems. Der vollqualifizierte Dateiname muss weniger als {1} Zeichen umfassen.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Die Toolsversion "{0}" ist unbekannt. Verfgbare Toolversionen sind {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.en.xlf b/src/Shared/Resources/xlf/Strings.shared.en.xlf
index 89e1330b798..cf10e5c095a 100644
--- a/src/Shared/Resources/xlf/Strings.shared.en.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.en.xlf
@@ -70,6 +70,21 @@
         <target state="new">Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="new">MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 62c0b3ef027..0860cf5f017 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -65,6 +65,21 @@
         <target state="translated">La ruta de acceso {0} supera el lmite mximo para la ruta de acceso del sistema operativo. El nombre de archivo completo debe ser inferior a {1} caracteres.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: No se reconoce la versin de herramientas "{0}". Las versiones de herramientas disponibles son {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 09edfc73b93..b0ee0eaf271 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Le chemin {0} dpasse la limite maximale de chemin du systme d'exploitation. Le nom du fichier qualifi complet doit contenir moins de {1} caractres.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: La version des outils "{0}" n'est pas reconnue. Les versions disponibles sont {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index 33fb3b72d80..fa13a591797 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Il percorso {0} supera il limite massimo dei percorsi del sistema operativo. Il nome completo del file deve essere composto da meno di {1}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: versione degli strumenti "{0}" non riconosciuta. Le versioni disponibili sono {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index d38f7aba8ed..d4c5be36d60 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -4,47 +4,67 @@
     <body>
       <trans-unit id="BuildAborted">
         <source>MSB4188: Build was canceled.</source>
-        <target state="translated">MSB4188: </target>
+        <target state="new">MSB4188: Build was canceled.</target>
         <note>{StrBegin="MSB4188: "} Error when the build stops suddenly for some reason. For example, because a child node died.</note>
       </trans-unit>
       <trans-unit id="BuildEngineCallbacksInTaskHostUnsupported">
         <source>MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</source>
-        <target state="translated">MSB5022: MSBuild  IBuildEngine  MSBuild UsingTask  "Runtime"  "Architecture"  "MSBuildRuntime"  "MSBuildArchitecture"  MSBuild  </target>
+        <target state="new">MSB5022: The MSBuild task host does not support running tasks that perform IBuildEngine callbacks. If you wish to perform these operations, please run your task in the core MSBuild process instead.  A task will automatically execute in the task host if the UsingTask has been attributed with a "Runtime" or "Architecture" value, or the task invocation has been attributed with an "MSBuildRuntime" or "MSBuildArchitecture" value, that does not match the current runtime or architecture of MSBuild.</target>
         <note>{StrBegin="MSB5022: "} "Runtime", "Architecture", "MSBuildRuntime", and "MSBuildArchitecture" are all attributes in the project file, and thus should not be localized.</note>
       </trans-unit>
       <trans-unit id="BuildStarted">
         <source>Build started.</source>
-        <target state="translated"></target>
+        <target state="new">Build started.</target>
         <note />
       </trans-unit>
       <trans-unit id="ConflictingTaskAssembly">
         <source>MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</source>
-        <target state="translated">MSB4008:   "{0}"  "{1}" </target>
+        <target state="new">MSB4008: A conflicting assembly for the task assembly "{0}" has been found at "{1}".</target>
         <note>{StrBegin="MSB4008: "}UE: This message is shown when the type/class of a task cannot be resolved uniquely from a single assembly.</note>
       </trans-unit>
+      <trans-unit id="DirectoryNotFound">
+        <source>Could not find directory path: {0}</source>
+        <target state="new">Could not find directory path: {0}</target>
+        <note>Directory must exist</note>
+      </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
         <source>Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</source>
-        <target state="translated"> "{0}"  .NET </target>
+        <target state="new">Event type "{0}" was expected to be serializable using the .NET serializer. The event was not serializable and has been ignored.</target>
         <note />
       </trans-unit>
       <trans-unit id="FileLocation">
         <source>{0} ({1},{2})</source>
-        <target state="translated">{0} ({1},{2})</target>
+        <target state="new">{0} ({1},{2})</target>
         <note>A file location to be embedded in a string.</note>
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
-        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
-        <target state="translated"> :</target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
+        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
+        <target state="new">When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</target>
+        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
       </trans-unit>
-      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
-        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
-        <target state="translated">  '{0}'  '{2}'  '{1}' </target>
-        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
+        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
+        <target state="new">.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
+        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
+        <target state="new">.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
+        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
+        <target state="new">Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="InvalidLogFileFormat">
+        <source>MSB4233: There was an exception while reading the log file: {0}</source>
+        <target state="new">MSB4233: There was an exception while reading the log file: {0}</target>
+        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
       </trans-unit>
       <trans-unit id="InvalidProjectFile">
         <source>MSB4025: The project file could not be loaded. {0}</source>
-        <target state="translated">MSB4025:  {0}</target>
+        <target state="new">MSB4025: The project file could not be loaded. {0}</target>
         <note>{StrBegin="MSB4025: "}UE: This message is shown when the project file given to the engine cannot be loaded because the filename/path is
     invalid, or due to lack of permissions, or incorrect XML. The project filename is not part of the message because it is
     provided separately to loggers.
@@ -52,241 +72,236 @@
       </trans-unit>
       <trans-unit id="InvalidVerbosity">
         <source>MSB4103: "{0}" is not a valid logger verbosity level.</source>
-        <target state="translated">MSB4103: "{0}" </target>
+        <target state="new">MSB4103: "{0}" is not a valid logger verbosity level.</target>
         <note>{StrBegin="MSB4103: "}</note>
       </trans-unit>
       <trans-unit id="MissingProject">
         <source>MSBuild is expecting a valid "{0}" object.</source>
-        <target state="translated">MSBuild  "{0}" </target>
+        <target state="new">MSBuild is expecting a valid "{0}" object.</target>
         <note />
       </trans-unit>
-      <trans-unit id="Shared.PathTooLong">
-        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
-        <target state="translated">: {0}  OS  {1} </target>
-        <note />
+      <trans-unit id="ModifyingTaskHostEnvironmentHeader">
+        <source>Making the following modifications to the environment received from the parent node before applying it to the task host:</source>
+        <target state="new">Making the following modifications to the environment received from the parent node before applying it to the task host:</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
-      <trans-unit id="UnrecognizedToolsVersion">
-        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
-        <target state="translated">MSB4132:   "{0}"   {1} </target>
-        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
+      <trans-unit id="ModifyingTaskHostEnvironmentVariable">
+        <source>  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</source>
+        <target state="new">  Setting '{0}' to '{1}' rather than the parent environment's value, '{2}'.</target>
+        <note>Only ever used when MSBuild is run under a "secret" environment variable switch, MSBuildTaskHostUpdateEnvironmentAndLog=1</note>
       </trans-unit>
       <trans-unit id="NameInvalid">
         <source>MSB5016: The name "{0}" contains an invalid character "{1}".</source>
-        <target state="translated">MSB5016:  "{0}"  "{1}" </target>
+        <target state="new">MSB5016: The name "{0}" contains an invalid character "{1}".</target>
         <note>{StrBegin="MSB5016: "}</note>
       </trans-unit>
+      <trans-unit id="OM_NotSupportedReadOnlyCollection">
+        <source>This collection is read-only.</source>
+        <target state="new">This collection is read-only.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
+        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
+        <target state="new">MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</target>
+        <note>{StrBegin="MSB5024: "}</note>
+      </trans-unit>
       <trans-unit id="Shared.CannotChangeItemSpecModifiers">
         <source>"{0}" is a reserved item metadata, and cannot be modified or deleted.</source>
-        <target state="translated">"{0}" </target>
+        <target state="new">"{0}" is a reserved item metadata, and cannot be modified or deleted.</target>
         <note>UE: Tasks and OM users are not allowed to remove or change the value of the built-in metadata on items e.g. the meta-data "FullPath", "RelativeDir", etc. are reserved.</note>
       </trans-unit>
       <trans-unit id="Shared.CannotConvertStringToBool">
         <source>The string "{0}" cannot be converted to a boolean (true/false) value.</source>
-        <target state="translated"> "{0}"  (true/false) </target>
+        <target state="new">The string "{0}" cannot be converted to a boolean (true/false) value.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.FailedCreatingTempFile">
         <source>MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</source>
-        <target state="translated">MSB5003:  {0}</target>
+        <target state="new">MSB5003: Failed to create a temporary file. Temporary files folder is full or its path is incorrect. {0}</target>
         <note>{StrBegin="MSB5003: "}</note>
       </trans-unit>
       <trans-unit id="Shared.FailedDeletingTempFile">
         <source>MSB5018: Failed to delete the temporary file "{0}". {1}</source>
-        <target state="translated">MSB5018:  "{0}" {1}</target>
+        <target state="new">MSB5018: Failed to delete the temporary file "{0}". {1}</target>
         <note>{StrBegin="MSB5018: "}</note>
       </trans-unit>
       <trans-unit id="Shared.InvalidFilespecForTransform">
         <source>The item metadata "%({0})" cannot be applied to the path "{1}". {2}</source>
-        <target state="translated"> "%({0})"  "{1}" {2}</target>
+        <target state="new">The item metadata "%({0})" cannot be applied to the path "{1}". {2}</target>
         <note>UE: This message is shown when the user tries to perform path manipulations using one of the built-in item metadata e.g. %(RootDir), on an item-spec that's not a valid path. LOCALIZATION: "{2}" is a localized message from a CLR/FX exception.</note>
       </trans-unit>
-      <trans-unit id="TaskNotMarshalByRef">
-        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
-        <target state="translated">MSB4077: "{0}"  LoadInSeparateAppDomain MarshalByRefObject  MarshalByRefObject  AppDomainIsolatedTask </target>
-        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersion">
-        <source>.NET Framework version "{0}" is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion.</source>
-        <target state="translated">.NET Framework  "{0}"  Microsoft.Build.Utilities.TargetDotNetFrameworkVersion </target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedFrameworkVersionForWindowsSdk">
-        <source>.NET Framework version "{0}" is not supported when explicitly targeting the Windows SDK, which is only supported on .NET 4.5 and later.  Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion that is Version45 or above.</source>
-        <target state="translated">Windows SDK .NET Framework  "{0}" Windows SDK .NET 4.5  Microsoft.Build.Utilities.TargetDotNetFrameworkVersion  Version45 </target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.UnsupportedVisualStudioVersion">
-        <source>Visual Studio version "{0}" is not supported.  Please specify a value from the enumeration Microsoft.Build.Utilities.VisualStudioVersion.</source>
-        <target state="translated">Visual Studio  "{0}"  Microsoft.Build.Utilities.VisualStudioVersion </target>
-        <note />
-      </trans-unit>
-      <trans-unit id="FrameworkLocationHelper.CouldNotGenerateReferenceAssemblyDirectory">
-        <source>When attempting to generate a reference assembly path from the path "{0}" and the framework moniker "{1}" there was an error. {2}</source>
-        <target state="translated">  "{0}"   "{1}" {2}</target>
-        <note>No Error code because this resource will be used in an exception. The error code is discarded if it is included</note>
-      </trans-unit>
-      <trans-unit id="DirectoryNotFound">
-        <source>Could not find directory path: {0}</source>
-        <target state="translated"> : {0}</target>
-        <note>Directory must exist</note>
-      </trans-unit>
-      <trans-unit id="UnauthorizedAccess">
-        <source>You do not have access to: {0}</source>
-        <target state="translated">{0} </target>
-        <note>Directory must have access</note>
-      </trans-unit>
-      <trans-unit id="SubCategoryForSchemaValidationErrors">
-        <source>Schema validation</source>
-        <target state="translated"></target>
-        <note>
-      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
-      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
-      "MSBUILD : Schema validation error MSB0000: This is an error."
-      LOCALIZATION: This fragment needs to be localized.
-    </note>
+      <trans-unit id="Shared.InvalidProjectFile">
+        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
+        <target state="new">MSB5019: The project file is malformed: "{0}". {1}</target>
+        <note>{StrBegin="MSB5019: "}</note>
       </trans-unit>
       <trans-unit id="Shared.KillingProcess">
         <source>MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</source>
-        <target state="translated">MSB5002:  "{0}"  ({1} ) </target>
+        <target state="new">MSB5002: Terminating the task executable "{0}" because it did not finish within the specified limit of {1} milliseconds.</target>
         <note>{StrBegin="MSB5002: "}</note>
       </trans-unit>
+      <trans-unit id="Shared.KillingProcessByCancellation">
+        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
+        <target state="new">MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</target>
+        <note>{StrBegin="MSB5021: "}</note>
+      </trans-unit>
       <trans-unit id="Shared.ParameterCannotBeNull">
         <source>Parameter "{0}" cannot be null.</source>
-        <target state="translated"> "{0}"  null </target>
+        <target state="new">Parameter "{0}" cannot be null.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
+        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
+        <target state="new">Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParameterCannotHaveZeroLength">
         <source>Parameter "{0}" cannot have zero length.</source>
-        <target state="translated"> "{0}"  0 </target>
+        <target state="new">Parameter "{0}" cannot have zero length.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.ParametersMustHaveTheSameLength">
         <source>Parameters "{0}" and "{1}" must have the same number of elements.</source>
-        <target state="translated"> "{0}"  "{1}" </target>
+        <target state="new">Parameters "{0}" and "{1}" must have the same number of elements.</target>
         <note />
       </trans-unit>
+      <trans-unit id="Shared.PathTooLong">
+        <source>Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</source>
+        <target state="new">Path: {0} exceeds the OS max path limit. The fully qualified file name must be less than {1} characters.</target>
+        <note />
+      </trans-unit>
+      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
+        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
+        <target state="new">MSB5020: Could not load the project file: "{0}". {1}</target>
+        <note>{StrBegin="MSB5020: "}</note>
+      </trans-unit>
       <trans-unit id="Shared.TaskResourceNotFound">
         <source>The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</source>
-        <target state="translated">"{1}"  "{0}"  "{0}" </target>
+        <target state="new">The resource string "{0}" for the "{1}" task cannot be found. Confirm that the resource name "{0}" is correctly spelled, and the resource exists in the task's assembly.</target>
         <note />
       </trans-unit>
       <trans-unit id="Shared.TaskResourcesNotRegistered">
         <source>The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</source>
-        <target state="translated">"{0}" "TaskLoggingHelper.FormatResourceString()"  "TaskResources" </target>
+        <target state="new">The "{0}" task has not registered its resources. In order to use the "TaskLoggingHelper.FormatResourceString()" method this task needs to register its resources either during construction, or via the "TaskResources" property.</target>
         <note>LOCALIZATION: "TaskLoggingHelper.FormatResourceString()" and "TaskResources" should not be localized.</note>
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="SolutionParseDuplicateProject">
         <source>MSB5004: The solution file has two projects named "{0}".</source>
-        <target state="translated">MSB5004:   "{0}"  2 </target>
+        <target state="new">MSB5004: The solution file has two projects named "{0}".</target>
         <note>{StrBegin="MSB5004: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameCharacters">
         <source>MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</source>
-        <target state="translated">MSB5005:  "{0}"   "{1}" </target>
+        <target state="new">MSB5005: Error parsing project section for project "{0}". The project file name "{1}" contains invalid characters.</target>
         <note>{StrBegin="MSB5005: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectFileNameEmpty">
         <source>MSB5006: Error parsing project section for project "{0}". The project file name is empty.</source>
-        <target state="translated">MSB5006:  "{0}"  </target>
+        <target state="new">MSB5006: Error parsing project section for project "{0}". The project file name is empty.</target>
         <note>{StrBegin="MSB5006: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidProjectSolutionConfigurationEntry">
         <source>MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="translated">MSB5007:   "{0}" </target>
+        <target state="new">MSB5007: Error parsing the project configuration section in solution file. The entry "{0}" is invalid.</target>
         <note>{StrBegin="MSB5007: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseInvalidSolutionConfigurationEntry">
         <source>MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</source>
-        <target state="translated">MSB5008:   "{0}" </target>
+        <target state="new">MSB5008: Error parsing the solution configuration section in solution file. The entry "{0}" is invalid.</target>
         <note>{StrBegin="MSB5008: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectError">
         <source>MSB5009: Error parsing the nested project section in solution file.</source>
-        <target state="translated">MSB5009:   </target>
+        <target state="new">MSB5009: Error parsing the nested project section in solution file.</target>
         <note>{StrBegin="MSB5009: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNestedProjectUndefinedError">
         <source>MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</source>
-        <target state="translated">MSB5023:   GUID "{0}"  "{1}" </target>
+        <target state="new">MSB5023: Error parsing the nested project section in solution file. A project with the GUID "{0}" is listed as being nested under project "{1}", but does not exist in the solution.</target>
         <note>{StrBegin="MSB5023: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseNoHeaderError">
         <source>MSB5010: No file format header found.</source>
-        <target state="translated">MSB5010: </target>
+        <target state="new">MSB5010: No file format header found.</target>
         <note>{StrBegin="MSB5010: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectDepGuidError">
         <source>MSB5011: Parent project GUID not found in "{0}" project dependency section.</source>
-        <target state="translated">MSB5011:  GUID  "{0}" </target>
+        <target state="new">MSB5011: Parent project GUID not found in "{0}" project dependency section.</target>
         <note>{StrBegin="MSB5011: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectEofError">
         <source>MSB5012: Unexpected end-of-file reached inside "{0}" project section.</source>
-        <target state="translated">MSB5012: "{0}"   EOF </target>
+        <target state="new">MSB5012: Unexpected end-of-file reached inside "{0}" project section.</target>
         <note>{StrBegin="MSB5012: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseProjectError">
         <source>MSB5013: Error parsing a project section.</source>
-        <target state="translated">MSB5013:  </target>
+        <target state="new">MSB5013: Error parsing a project section.</target>
         <note>{StrBegin="MSB5013: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseVersionMismatchError">
         <source>MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</source>
-        <target state="translated">MSB5014: MSBuild  {0}.0  {1}.0  </target>
+        <target state="new">MSB5014: File format version is not recognized.  MSBuild can only read solution files between versions {0}.0 and {1}.0, inclusive.</target>
         <note>{StrBegin="MSB5014: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
       <trans-unit id="SolutionParseWebProjectPropertiesError">
         <source>MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</source>
-        <target state="translated">MSB5015: "{0}"  WebsiteProperties </target>
+        <target state="new">MSB5015: The properties could not be read from the WebsiteProperties section of the "{0}" project.</target>
         <note>{StrBegin="MSB5015: "}UE: The solution filename is provided separately to loggers.</note>
       </trans-unit>
-      <trans-unit id="UnrecognizedSolutionComment">
-        <source>Unrecognized solution version "{0}", attempting to continue.</source>
-        <target state="translated">"{0}"  </target>
-        <note />
+      <trans-unit id="SubCategoryForSchemaValidationErrors">
+        <source>Schema validation</source>
+        <target state="new">Schema validation</target>
+        <note>
+      UE: this fragment is used to describe errors that are caused by schema validation. For example, if a normal error is
+      displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from schema validation would look like this:
+      "MSBUILD : Schema validation error MSB0000: This is an error."
+      LOCALIZATION: This fragment needs to be localized.
+    </note>
       </trans-unit>
       <trans-unit id="SubCategoryForSolutionParsingErrors">
         <source>Solution file</source>
-        <target state="translated"> </target>
+        <target state="new">Solution file</target>
         <note>UE: this fragment is used to describe errors found while parsing solution files. For example, if a normal error is
       displayed like this: "MSBUILD : error MSB0000: This is an error.", then an error from solution parsing would look like this:
       "MSBUILD : Solution file error MSB0000: This is an error."
       LOCALIZATION: This fragment needs to be localized.</note>
       </trans-unit>
-      <trans-unit id="Shared.InvalidProjectFile">
-        <source>MSB5019: The project file is malformed: "{0}". {1}</source>
-        <target state="translated">MSB5019:  : "{0}"{1}</target>
-        <note>{StrBegin="MSB5019: "}</note>
-      </trans-unit>
-      <trans-unit id="Shared.ProjectFileCouldNotBeLoaded">
-        <source>MSB5020: Could not load the project file: "{0}". {1}</source>
-        <target state="translated">MSB5020:   "{0}" {1}</target>
-        <note>{StrBegin="MSB5020: "}</note>
+      <trans-unit id="TaskNotMarshalByRef">
+        <source>MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</source>
+        <target state="new">MSB4077: The "{0}" task has been marked with the attribute LoadInSeparateAppDomain, but does not derive from MarshalByRefObject. Check that the task derives from MarshalByRefObject or AppDomainIsolatedTask.</target>
+        <note>{StrBegin="MSB4077: "}LOCALIZATION: &lt;LoadInSeparateAppDomain&gt;, &lt;MarshalByRefObject&gt;, &lt;AppDomainIsolatedTask&gt; should not be localized.</note>
       </trans-unit>
-      <trans-unit id="Shared.KillingProcessByCancellation">
-        <source>MSB5021: Terminating the task executable "{0}" and its child processes because the build was canceled.</source>
-        <target state="translated">MSB5021:  "{0}" </target>
-        <note>{StrBegin="MSB5021: "}</note>
+      <trans-unit id="UnauthorizedAccess">
+        <source>You do not have access to: {0}</source>
+        <target state="new">You do not have access to: {0}</target>
+        <note>Directory must have access</note>
       </trans-unit>
-      <trans-unit id="OM_NotSupportedReadOnlyCollection">
-        <source>This collection is read-only.</source>
-        <target state="translated"></target>
+      <trans-unit id="UnrecognizedSolutionComment">
+        <source>Unrecognized solution version "{0}", attempting to continue.</source>
+        <target state="new">Unrecognized solution version "{0}", attempting to continue.</target>
         <note />
       </trans-unit>
-      <trans-unit id="Shared.CanNotFindValidMSBuildLocation">
-        <source>MSB5024: Could not determine a valid location to MSBuild. Try running this process from the Developer Command Prompt for Visual Studio.</source>
-        <target state="translated">MSB5024: MSBuild Visual Studio  </target>
-        <note>{StrBegin="MSB5024: "}</note>
-      </trans-unit>
-      <trans-unit id="InvalidLogFileFormat">
-        <source>MSB4233: There was an exception while reading the log file: {0}</source>
-        <target state="translated">MSB4233:  : {0}</target>
-        <note>{StrBegin="MSB4233: "}This is shown when the Binary Logger can't read the log file.</note>
-      </trans-unit>
-      <trans-unit id="Shared.ParameterCannotHaveInvalidPathChars">
-        <source>Parameter "{0}" with assigned value "{1}" cannot have invalid path or invalid file characters.</source>
-        <target state="translated"> "{1}"  "{0}" </target>
-        <note />
+      <trans-unit id="UnrecognizedToolsVersion">
+        <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
+        <target state="new">MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</target>
+        <note>{StrBegin="MSB4132: "}LOCALIZATION: {1} contains a comma separated list.</note>
       </trans-unit>
     </body>
   </file>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 3ec69e93682..0a9784913d7 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -65,6 +65,21 @@
         <target state="translated">: {0}() OS    .    {1}  .</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132:   "{0}"()   .      {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index 2d38506af57..6d6f964b8a2 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -65,6 +65,21 @@
         <target state="translated">cieka: {0} przekracza limit maksymalnej dugoci cieki w systemie operacyjnym. W peni kwalifikowana nazwa pliku musi si skada z mniej ni {1} znakw.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Wersja narzdzi {0} nie zostaa rozpoznana. Dostpne wersje narzdzi to {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 4aa21acdb48..f2b419f77df 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Caminho: {0} excede o limite mximo do caminho do SO. O nome do arquivo totalmente qualificado deve ter menos de {1} caracteres.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: A verso das ferramentas "{0}" no  reconhecida. As verses das ferramentas disponveis so {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index d37b4d76c6c..111a49830f4 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -65,6 +65,21 @@
         <target state="translated">  {0}    .          {1}.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132:   "{0}"  .   : {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index 24caa67ffa5..b0b741a3960 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -65,6 +65,21 @@
         <target state="translated">Yol: {0}, iletim sisteminin en yksek yol snrn ayor. Tam dosya ad en fazla {1} karakter olmaldr.</target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: Aralar srm "{0}" tannmyor. Kullanlabilir ara srmleri unlardr: {1}.</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index 78941fb4a60..398938a8677 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -65,6 +65,21 @@
         <target state="translated">: {0}  OS  {1} </target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132: {0} {1}</target>
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 8053d2d6e4b..418a2c2a06b 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -65,6 +65,21 @@
         <target state="translated">: {0}  OS  {1} </target>
         <note />
       </trans-unit>
+      <trans-unit id="SolutionFilterFilterContainsProjectNotInSolution">
+        <source>MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</source>
+        <target state="new">MSB5028: Solution filter file at "{0}" includes project "{1}" that is not in the solution file at "{2}".</target>
+        <note>{StrBegin="MSB5028: "}UE: The project filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterJsonParsingError">
+        <source>MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</source>
+        <target state="new">MSB5025: Json in solution filter file "{0}" is incorrectly formatted.</target>
+        <note>{StrBegin="MSB5025: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
+      <trans-unit id="SolutionFilterMissingSolutionError">
+        <source>MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</source>
+        <target state="new">MSB5026: The solution filter file at "{0}" specifies there will be a solution file at "{1}", but that file does not exist.</target>
+        <note>{StrBegin="MSB5026: "}UE: The solution filename is provided separately to loggers.</note>
+      </trans-unit>
       <trans-unit id="UnrecognizedToolsVersion">
         <source>MSB4132: The tools version "{0}" is unrecognized. Available tools versions are {1}.</source>
         <target state="translated">MSB4132:  "{0}"  {1}</target>
diff --git a/src/Shared/TaskEngineAssemblyResolver.cs b/src/Shared/TaskEngineAssemblyResolver.cs
index 91aef3e99f7..e58b0ea73f0 100644
--- a/src/Shared/TaskEngineAssemblyResolver.cs
+++ b/src/Shared/TaskEngineAssemblyResolver.cs
@@ -7,7 +7,7 @@
 using System.Diagnostics;
 using System.Globalization;
 
-#if !FEATURE_ASSEMBLY_LOADFROM
+#if FEATURE_ASSEMBLYLOADCONTEXT
 using System.Runtime.Loader;
 #endif
 using Microsoft.Build.Shared;
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 388b91c81a1..78fa8799911 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -124,6 +124,23 @@ public bool LogProjectImports
             }
         }
 
+        private bool? _logTaskInputs;
+        public bool LogTaskInputs
+        {
+            get
+            {
+                if (_logTaskInputs == null)
+                {
+                    _logTaskInputs = Environment.GetEnvironmentVariable("MSBUILDLOGTASKINPUTS") == "1";
+                }
+                return _logTaskInputs.Value;
+            }
+            set
+            {
+                _logTaskInputs = value;
+            }
+        }
+
         /// <summary>
         /// Read information only once per file per ResolveAssemblyReference invocation.
         /// </summary>
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index d0cb1bf1aa6..828b8320823 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -19,7 +19,7 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal class TypeLoader
     {
-#if !FEATURE_ASSEMBLY_LOADFROM
+#if FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// AssemblyContextLoader used to load DLLs outside of msbuild.exe directory
         /// </summary>
@@ -41,7 +41,7 @@ internal class TypeLoader
         /// </summary>
         private Func<Type, object, bool> _isDesiredType;
 
-#if !FEATURE_ASSEMBLY_LOADFROM
+#if FEATURE_ASSEMBLYLOADCONTEXT
         static TypeLoader()
         {
             s_coreClrAssemblyLoader = new CoreClrAssemblyLoader();
@@ -152,7 +152,7 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)
             {
                 if (assemblyLoadInfo.AssemblyName != null)
                 {
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
                     loadedAssembly = Assembly.Load(assemblyLoadInfo.AssemblyName);
 #else
                     loadedAssembly = Assembly.Load(new AssemblyName(assemblyLoadInfo.AssemblyName));
@@ -160,27 +160,10 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)
                 }
                 else
                 {
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
                     loadedAssembly = Assembly.UnsafeLoadFrom(assemblyLoadInfo.AssemblyFile);
 #else
-                    // If the Assembly is provided via a file path, the following rules are used to load the assembly:
-                    // - if the simple name of the assembly exists in the same folder as msbuild.exe, then that assembly gets loaded, indifferent of the user specified path
-                    // - otherwise, the assembly from the user specified path is loaded, if it exists.
-
-                    var assemblyNameInExecutableDirectory = Path.Combine(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory,
-                        Path.GetFileName(assemblyLoadInfo.AssemblyFile));
-
-                    if (FileSystems.Default.FileExists(assemblyNameInExecutableDirectory))
-                    {
-                        var simpleName = Path.GetFileNameWithoutExtension(assemblyLoadInfo.AssemblyFile);
-                        loadedAssembly = Assembly.Load(new AssemblyName(simpleName));
-                    }
-                    else
-                    {
-                        var baseDir = Path.GetDirectoryName(assemblyLoadInfo.AssemblyFile);
-                        s_coreClrAssemblyLoader.AddDependencyLocation(baseDir);
-                        loadedAssembly = s_coreClrAssemblyLoader.LoadFromPath(assemblyLoadInfo.AssemblyFile);
-                    }
+                    loadedAssembly = s_coreClrAssemblyLoader.LoadFromPath(assemblyLoadInfo.AssemblyFile);
 #endif
                 }
             }
diff --git a/src/Tasks/AppConfig/AppConfig.cs b/src/Tasks/AppConfig/AppConfig.cs
index 1dafb54ad60..ce4f0954256 100644
--- a/src/Tasks/AppConfig/AppConfig.cs
+++ b/src/Tasks/AppConfig/AppConfig.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.IO;
 using System.Xml;
 
 using Microsoft.Build.Shared;
@@ -23,6 +24,11 @@ internal void Load(string appConfigFile)
             try
             {
                 var readerSettings = new XmlReaderSettings { DtdProcessing = DtdProcessing.Ignore };
+
+                // it's important to normalize the path as it may contain two slashes
+                // see https://github.com/microsoft/msbuild/issues/4335 for details.
+                appConfigFile = FileUtilities.NormalizePath(appConfigFile);
+
                 reader = XmlReader.Create(appConfigFile, readerSettings);
                 Read(reader);
             }
diff --git a/src/Tasks/AssemblyDependency/AssemblyInformation.cs b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
index c1d6344fec6..5acebabb7eb 100644
--- a/src/Tasks/AssemblyDependency/AssemblyInformation.cs
+++ b/src/Tasks/AssemblyDependency/AssemblyInformation.cs
@@ -14,7 +14,7 @@
 
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-#if !FEATURE_ASSEMBLY_LOADFROM || MONO
+#if FEATURE_ASSEMBLYLOADCONTEXT || MONO
 using System.Reflection.PortableExecutable;
 using System.Reflection.Metadata;
 #endif
@@ -30,7 +30,7 @@ internal class AssemblyInformation : DisposableBase
     {
         private AssemblyNameExtension[] _assemblyDependencies;
         private string[] _assemblyFiles;
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
         private readonly IMetaDataDispenser _metadataDispenser;
         private readonly IMetaDataAssemblyImport _assemblyImport;
         private static Guid s_importerGuid = new Guid(((GuidAttribute)Attribute.GetCustomAttribute(typeof(IMetaDataImport), typeof(GuidAttribute), false)).Value);
@@ -39,14 +39,14 @@ internal class AssemblyInformation : DisposableBase
         private readonly string _sourceFile;
         private FrameworkName _frameworkName;
 
-#if !FEATURE_ASSEMBLY_LOADFROM || MONO
+#if FEATURE_ASSEMBLYLOADCONTEXT || MONO
         private bool _metadataRead;
 #endif
 
-#if FEATURE_ASSEMBLY_LOADFROM && !MONO
+#if !FEATURE_ASSEMBLYLOADCONTEXT && !MONO
         private static string s_targetFrameworkAttribute = "System.Runtime.Versioning.TargetFrameworkAttribute";
 #endif
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
         // Borrowed from genman.
         private const int GENMAN_STRING_BUF_SIZE = 1024;
         private const int GENMAN_LOCALE_BUF_SIZE = 64;
@@ -68,7 +68,7 @@ internal AssemblyInformation(string sourceFile)
             ErrorUtilities.VerifyThrowArgumentNull(sourceFile, nameof(sourceFile));
             _sourceFile = sourceFile;
 
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             if (NativeMethodsShared.IsWindows)
             {
                 // Create the metadata dispenser and open scope on the source file.
@@ -82,7 +82,7 @@ internal AssemblyInformation(string sourceFile)
 #endif
         }
 
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
         private static Assembly ReflectionOnlyAssemblyResolve(object sender, ResolveEventArgs args)
         {
             string[] nameParts = args.Name.Split(MSBuildConstants.CommaChar);
@@ -274,7 +274,7 @@ private FrameworkName GetFrameworkName()
 // Assembly.GetCustomAttributes* for an attribute which belongs
 // to an assembly that mono cannot find, causes a crash!
 // Instead, opt for using PEReader and friends to get that info
-#if FEATURE_ASSEMBLY_LOADFROM && !MONO
+#if !FEATURE_ASSEMBLYLOADCONTEXT && !MONO
             if (!NativeMethodsShared.IsWindows)
             {
                 if (String.Equals(Environment.GetEnvironmentVariable("MONO29679"), "1", StringComparison.OrdinalIgnoreCase))
@@ -345,7 +345,7 @@ private FrameworkName GetFrameworkName()
 #endif
         }
 
-#if !FEATURE_ASSEMBLY_LOADFROM || MONO
+#if FEATURE_ASSEMBLYLOADCONTEXT || MONO
         /// <summary>
         /// Read everything from the assembly in a single stream.
         /// </summary>
@@ -454,7 +454,7 @@ private static AssemblyName GetAssemblyName(MetadataReader metadataReader, Assem
 
 // Enabling this for MONO, because it's required by GetFrameworkName.
 // More details are in the comment for that method
-#if !FEATURE_ASSEMBLY_LOADFROM || MONO
+#if FEATURE_ASSEMBLYLOADCONTEXT || MONO
         //  This method copied from DNX source: https://github.com/aspnet/dnx/blob/e0726f769aead073af2d8cd9db47b89e1745d574/src/Microsoft.Dnx.Tooling/Utils/LockFileUtils.cs#L385
         //  System.Reflection.Metadata 1.1 is expected to have an API that helps with this.
         /// <summary>
@@ -514,7 +514,7 @@ private static List<string> GetFixedStringArguments(MetadataReader reader, Custo
         }
 #endif
 
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// Release interface pointers on Dispose(). 
         /// </summary>
@@ -586,7 +586,7 @@ internal static string GetRuntimeVersion(string path)
         /// <returns>The array of assembly dependencies.</returns>
         private AssemblyNameExtension[] ImportAssemblyDependencies()
         {
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             var asmRefs = new List<AssemblyNameExtension>();
 
             if (!NativeMethodsShared.IsWindows)
@@ -683,7 +683,7 @@ private AssemblyNameExtension[] ImportAssemblyDependencies()
         /// <returns>The extra files of assembly dependencies.</returns>
         private string[] ImportFiles()
         {
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             var files = new List<string>();
             IntPtr fileEnum = IntPtr.Zero;
             var fileTokens = new UInt32[GENMAN_ENUM_TOKEN_BUF_SIZE];
@@ -726,7 +726,7 @@ private string[] ImportFiles()
 #endif
         }
 
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// Allocate assembly metadata structure buffer.
         /// </summary>
diff --git a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
index 6cf1ef92a57..c52420b8e19 100644
--- a/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
+++ b/src/Tasks/AssemblyDependency/ResolveAssemblyReference.cs
@@ -269,7 +269,7 @@ public ITaskItem[] Assemblies
 
         /// <summary>
         /// A list of assembly files that can be part of the search and resolution process.
-        /// These must be absolute filesnames, or project-relative filenames.
+        /// These must be absolute filenames, or project-relative filenames.
         ///
         /// Assembly files in this list will be considered when SearchPaths contains
         /// {CandidateAssemblyFiles} as one of the paths to consider.
@@ -1269,6 +1269,12 @@ private MessageImportance ChooseReferenceLoggingImportance(Reference reference)
         /// </summary>
         private void LogInputs()
         {
+            if (Traits.Instance.EscapeHatches.LogTaskInputs)
+            {
+                // the inputs will be logged automatically anyway, avoid duplication in the logs
+                return;
+            }
+
             if (!Silent)
             {
                 Log.LogMessageFromResources(MessageImportance.Low, "ResolveAssemblyReference.LogTaskPropertyFormat", "TargetFrameworkMoniker");
diff --git a/src/Tasks/GenerateResource.cs b/src/Tasks/GenerateResource.cs
index 1354d4f0661..cb87f14e533 100644
--- a/src/Tasks/GenerateResource.cs
+++ b/src/Tasks/GenerateResource.cs
@@ -2280,7 +2280,7 @@ internal string StronglyTypedClassName
         /// </summary>
         private bool _stronglyTypedClassIsPublic;
 
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// Class that gets called by the ResxResourceReader to resolve references
         /// to assemblies within the .RESX.
@@ -2428,7 +2428,7 @@ internal void Run(
             _portableLibraryCacheInfo = new List<ResGenDependencies.PortableLibraryFile>();
             _usePreserializedResources = usePreserializedResources;
 
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
             // If references were passed in, we will have to give the ResxResourceReader an object
             // by which it can resolve types that are referenced from within the .RESX.
             if ((_assemblyFiles != null) && (_assemblyFiles.Length > 0))
@@ -2439,7 +2439,7 @@ internal void Run(
 
             try
             {
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
                 // Install assembly resolution event handler.
                 _eventHandler = new ResolveEventHandler(ResolveAssembly);
                 AppDomain.CurrentDomain.AssemblyResolve += _eventHandler;
@@ -2461,7 +2461,7 @@ internal void Run(
             }
             finally
             {
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
                 // Remove the event handler.
                 AppDomain.CurrentDomain.AssemblyResolve -= _eventHandler;
                 _eventHandler = null;
@@ -2469,7 +2469,7 @@ internal void Run(
             }
         }
 
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// Callback to resolve assembly names to assemblies.
         /// </summary>
@@ -2987,7 +2987,7 @@ private void ReadResources(String filename, bool shouldUseSourcePath, String out
 
             if (format == Format.Assembly) // Multiple input .resources files within one assembly
             {
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
                 ReadAssemblyResources(filename, outFileOrDir);
 #else
                 throw new InputFormatNotSupportedException("Reading resources from Assembly not supported on .NET Core MSBuild");
@@ -3080,7 +3080,7 @@ private void AddResourcesUsingMinimalCoreResxParsing(string filename, ReaderInfo
             }
         }
 
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// Reads resources from an assembly.
         /// </summary>
@@ -3978,7 +3978,7 @@ internal int LinePosition
 #endregion // Code from ResGen.EXE
     }
 
-#if FEATURE_ASSEMBLY_LOADFROM
+#if !FEATURE_ASSEMBLYLOADCONTEXT
     /// <summary>
     /// This implemention of ITypeResolutionService is passed into the ResxResourceReader
     /// class, which calls back into the methods on this class in order to resolve types
diff --git a/src/Tasks/Microsoft.Common.CrossTargeting.targets b/src/Tasks/Microsoft.Common.CrossTargeting.targets
index b64cec1d544..041c365c8c1 100644
--- a/src/Tasks/Microsoft.Common.CrossTargeting.targets
+++ b/src/Tasks/Microsoft.Common.CrossTargeting.targets
@@ -38,7 +38,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Target Name="_ComputeTargetFrameworkItems" Returns="@(InnerOutput)">
     <ItemGroup>
       <_TargetFramework Include="$(TargetFrameworks)" />
-      <!-- Make normalization explicit: Trim; Deduplicate by keeping first occurence, case insensitive -->
+      <!-- Make normalization explicit: Trim; Deduplicate by keeping first occurrence, case insensitive -->
       <_TargetFrameworkNormalized Include="@(_TargetFramework->Trim()->Distinct())" />
       <_InnerBuildProjects Include="$(MSBuildProjectFile)">
         <AdditionalProperties>TargetFramework=%(_TargetFrameworkNormalized.Identity)</AdditionalProperties>
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
index 5ec095c77ce..a6281533708 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedInputFiles.cs
@@ -1060,7 +1060,7 @@ public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[]
         private void RemoveDependenciesFromEntryIfMissing(string rootingMarker)
         {
             // In the event of incomplete tracking information (i.e. this root was not present), just continue quietly
-            // as the user could have killed the tool being tracked, or another error occured during its execution.
+            // as the user could have killed the tool being tracked, or another error occurred during its execution.
             if (DependencyTable.TryGetValue(rootingMarker, out Dictionary<string, string> dependencies))
             {
                 var dependenciesWithoutMissingFiles = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
diff --git a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
index 585428902b4..5c906de1683 100644
--- a/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
+++ b/src/Utilities/TrackedDependencies/CanonicalTrackedOutputFiles.cs
@@ -757,7 +757,7 @@ public void RemoveDependenciesFromEntryIfMissing(ITaskItem[] source, ITaskItem[]
         private void RemoveDependenciesFromEntryIfMissing(string rootingMarker)
         {
             // In the event of incomplete tracking information (i.e. this root was not present), just continue quietly
-            // as the user could have killed the tool being tracked, or another error occured during its execution.
+            // as the user could have killed the tool being tracked, or another error occurred during its execution.
             if (DependencyTable.TryGetValue(rootingMarker, out Dictionary<string, DateTime> dependencies))
             {
                 var dependenciesWithoutMissingFiles = new Dictionary<string, DateTime>(StringComparer.OrdinalIgnoreCase);
