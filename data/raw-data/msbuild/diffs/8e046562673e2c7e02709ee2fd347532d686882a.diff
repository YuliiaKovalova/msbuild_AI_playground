diff --git a/src/Build/AssemblyInfo.cs b/src/Build/AssemblyInfo.cs
index 7e0091c5d47..b4dbc09c40a 100644
--- a/src/Build/AssemblyInfo.cs
+++ b/src/Build/AssemblyInfo.cs
@@ -19,6 +19,7 @@
 #endif
 [assembly: InternalsVisibleTo("Microsoft.Build.Framework.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Engine.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
+[assembly: InternalsVisibleTo("Microsoft.Build.BuildCheck.UnitTests, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.UnitTests.Shared, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Core, PublicKey=002400000480000094000000060200000024000052534131000400000100010007d1fa57c4aed9f0a32e84aa0faefd0de9e8fd6aec8f87fb03766c834c99921eb23be79ad9d5dcc1dd9ad236132102900b723cf980957fc4e177108fc607774f29e8320e92ea05ece4e821c0a5efe8f1645c4c0c93c1ab99285d622caa652c1dfad63d745d6f2de5f17e5eaf0fc4963d261c8a12436518206dc093344d5ad293")]
 [assembly: InternalsVisibleTo("Microsoft.Build.Conversion.Unittest, PublicKey=002400000480000094000000060200000024000052534131000400000100010015c01ae1f50e8cc09ba9eac9147cf8fd9fce2cfe9f8dce4f7301c4132ca9fb50ce8cbf1df4dc18dd4d210e4345c744ecb3365ed327efdbc52603faa5e21daa11234c8c4a73e51f03bf192544581ebe107adee3a34928e39d04e524a9ce729d5090bfd7dad9d10c722c0def9ccc08ff0a03790e48bcd1f9b6c476063e1966a1c4")]
diff --git a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
index b5b3454e36f..387af4a55b7 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/RequestBuilder.cs
@@ -1118,13 +1118,13 @@ private void SetProjectCurrentDirectory()
         /// </summary>
         private async Task<BuildResult> BuildProject()
         {
+            ErrorUtilities.VerifyThrow(_targetBuilder != null, "Target builder is null");
+
             // We consider this the entrypoint for the project build for purposes of BuildCheck processing 
 
             var buildCheckManager = (_componentHost.GetComponent(BuildComponentType.BuildCheckManagerProvider) as IBuildCheckManagerProvider)!.Instance;
             buildCheckManager.SetDataSource(BuildCheckDataSource.BuildExecution);
 
-            ErrorUtilities.VerifyThrow(_targetBuilder != null, "Target builder is null");
-
             // Make sure it is null before loading the configuration into the request, because if there is a problem
             // we do not wand to have an invalid projectLoggingContext floating around. Also if this is null the error will be
             // logged with the node logging context
@@ -1172,63 +1172,78 @@ private async Task<BuildResult> BuildProject()
                 BuildCheckDataSource.BuildExecution,
                 _requestEntry.Request.ParentBuildEventContext);
 
-            // Now that the project has started, parse a few known properties which indicate warning codes to treat as errors or messages
-            //
-            ConfigureWarningsAsErrorsAndMessages();
+            try
+            {
+                // Now that the project has started, parse a few known properties which indicate warning codes to treat as errors or messages
+                ConfigureWarningsAsErrorsAndMessages();
 
-            // Make sure to extract known immutable folders from properties and register them for fast up-to-date check
-            ConfigureKnownImmutableFolders();
+                // Make sure to extract known immutable folders from properties and register them for fast up-to-date check
+                ConfigureKnownImmutableFolders();
 
-            // See comment on Microsoft.Build.Internal.Utilities.GenerateToolsVersionToUse
-            _requestEntry.RequestConfiguration.RetrieveFromCache();
-            if (_requestEntry.RequestConfiguration.Project.UsingDifferentToolsVersionFromProjectFile)
-            {
-                _projectLoggingContext.LogComment(MessageImportance.Low, "UsingDifferentToolsVersionFromProjectFile", _requestEntry.RequestConfiguration.Project.OriginalProjectToolsVersion, _requestEntry.RequestConfiguration.Project.ToolsVersion);
-            }
+                // See comment on Microsoft.Build.Internal.Utilities.GenerateToolsVersionToUse
+                _requestEntry.RequestConfiguration.RetrieveFromCache();
+                if (_requestEntry.RequestConfiguration.Project.UsingDifferentToolsVersionFromProjectFile)
+                {
+                    _projectLoggingContext.LogComment(MessageImportance.Low,
+                        "UsingDifferentToolsVersionFromProjectFile",
+                        _requestEntry.RequestConfiguration.Project.OriginalProjectToolsVersion,
+                        _requestEntry.RequestConfiguration.Project.ToolsVersion);
+                }
 
-            _requestEntry.Request.BuildEventContext = _projectLoggingContext.BuildEventContext;
+                _requestEntry.Request.BuildEventContext = _projectLoggingContext.BuildEventContext;
 
-            // Determine the set of targets we need to build
-            string[] allTargets = _requestEntry.RequestConfiguration.GetTargetsUsedToBuildRequest(_requestEntry.Request).ToArray();
+                // Determine the set of targets we need to build
+                string[] allTargets = _requestEntry.RequestConfiguration
+                    .GetTargetsUsedToBuildRequest(_requestEntry.Request).ToArray();
 
-            ProjectErrorUtilities.VerifyThrowInvalidProject(allTargets.Length > 0, _requestEntry.RequestConfiguration.Project.ProjectFileLocation, "NoTargetSpecified");
+                ProjectErrorUtilities.VerifyThrowInvalidProject(allTargets.Length > 0,
+                    _requestEntry.RequestConfiguration.Project.ProjectFileLocation, "NoTargetSpecified");
 
-            // Set the current directory to that required by the project.
-            SetProjectCurrentDirectory();
+                // Set the current directory to that required by the project.
+                SetProjectCurrentDirectory();
 
-            // Transfer results and state from the previous node, if necessary.
-            // In order for the check for target completeness for this project to be valid, all of the target results from the project must be present
-            // in the results cache.  It is possible that this project has been moved from its original node and when it was its results did not come
-            // with it.  This would be signified by the ResultsNode value in the configuration pointing to a different node than the current one.  In that
-            // case we will need to request those results be moved from their original node to this one.
-            if ((_requestEntry.RequestConfiguration.ResultsNodeId != Scheduler.InvalidNodeId) &&
-                (_requestEntry.RequestConfiguration.ResultsNodeId != _componentHost.BuildParameters.NodeId))
-            {
-                // This indicates to the system that we will block waiting for a results transfer.  We will block here until those results become available.
-                await BlockOnTargetInProgress(Microsoft.Build.BackEnd.BuildRequest.InvalidGlobalRequestId, null);
+                // Transfer results and state from the previous node, if necessary.
+                // In order for the check for target completeness for this project to be valid, all of the target results from the project must be present
+                // in the results cache.  It is possible that this project has been moved from its original node and when it was its results did not come
+                // with it.  This would be signified by the ResultsNode value in the configuration pointing to a different node than the current one.  In that
+                // case we will need to request those results be moved from their original node to this one.
+                if ((_requestEntry.RequestConfiguration.ResultsNodeId != Scheduler.InvalidNodeId) &&
+                    (_requestEntry.RequestConfiguration.ResultsNodeId != _componentHost.BuildParameters.NodeId))
+                {
+                    // This indicates to the system that we will block waiting for a results transfer.  We will block here until those results become available.
+                    await BlockOnTargetInProgress(Microsoft.Build.BackEnd.BuildRequest.InvalidGlobalRequestId, null);
+
+                    // All of the results should now be on this node.
+                    ErrorUtilities.VerifyThrow(
+                        _requestEntry.RequestConfiguration.ResultsNodeId == _componentHost.BuildParameters.NodeId,
+                        "Results for configuration {0} were not retrieved from node {1}",
+                        _requestEntry.RequestConfiguration.ConfigurationId,
+                        _requestEntry.RequestConfiguration.ResultsNodeId);
+                }
 
-                // All of the results should now be on this node.
-                ErrorUtilities.VerifyThrow(_requestEntry.RequestConfiguration.ResultsNodeId == _componentHost.BuildParameters.NodeId, "Results for configuration {0} were not retrieved from node {1}", _requestEntry.RequestConfiguration.ConfigurationId, _requestEntry.RequestConfiguration.ResultsNodeId);
-            }
+                // Build the targets
+                BuildResult result = await _targetBuilder.BuildTargets(_projectLoggingContext, _requestEntry, this,
+                    allTargets, _requestEntry.RequestConfiguration.BaseLookup, _cancellationTokenSource.Token);
 
-            // Build the targets
-            BuildResult result = await _targetBuilder.BuildTargets(_projectLoggingContext, _requestEntry, this, allTargets, _requestEntry.RequestConfiguration.BaseLookup, _cancellationTokenSource.Token);
+                result = _requestEntry.Request.ProxyTargets == null
+                    ? result
+                    : CopyTargetResultsFromProxyTargetsToRealTargets(result);
 
-            result = _requestEntry.Request.ProxyTargets == null
-                ? result
-                : CopyTargetResultsFromProxyTargetsToRealTargets(result);
+                if (MSBuildEventSource.Log.IsEnabled())
+                {
+                    MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath,
+                        string.Join(", ", allTargets));
+                }
 
-            if (MSBuildEventSource.Log.IsEnabled())
+                return result;
+            }
+            finally
             {
-                MSBuildEventSource.Log.BuildProjectStop(_requestEntry.RequestConfiguration.ProjectFullPath, string.Join(", ", allTargets));
+                buildCheckManager.EndProjectRequest(
+                    BuildCheckDataSource.BuildExecution,
+                    _requestEntry.Request.ParentBuildEventContext);
             }
 
-            buildCheckManager.EndProjectRequest(
-                BuildCheckDataSource.BuildExecution,
-                _requestEntry.Request.ParentBuildEventContext);
-
-            return result;
-
             BuildResult CopyTargetResultsFromProxyTargetsToRealTargets(BuildResult resultFromTargetBuilder)
             {
                 var proxyTargetMapping = _requestEntry.Request.ProxyTargets.ProxyTargetToRealTargetMap;
diff --git a/src/Build/BuildCheck/API/BuildAnalyzer.cs b/src/Build/BuildCheck/API/BuildAnalyzer.cs
index 0cb8cbaa629..f249dc98cc5 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzer.cs
+++ b/src/Build/BuildCheck/API/BuildAnalyzer.cs
@@ -11,7 +11,7 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 /// <summary>
 /// Base class for build analyzers.
 /// Same base will be used for custom and built-in analyzers.
-/// <see cref="BuildAnalyzer"/> is a unit of build analysis execution. But it can contain multiple rules - each representing a distinct violation.
+/// <see cref="BuildAnalyzer"/> is a unit of build analysis execution, but it can contain multiple rules - each representing a distinct violation.
 /// </summary>
 public abstract class BuildAnalyzer : IDisposable
 {
@@ -36,9 +36,11 @@ public abstract class BuildAnalyzer : IDisposable
     public abstract void Initialize(ConfigurationContext configurationContext);
 
     /// <summary>
-    /// 
+    /// Used by the implementors to subscribe to data and events they are interested in.
     /// </summary>
-    /// <param name="registrationContext"></param>
+    /// <param name="registrationContext">
+    /// The context that enables subscriptions for data pumping from the infrastructure.
+    /// </param>
     public abstract void RegisterActions(IBuildCheckRegistrationContext registrationContext);
 
     public virtual void Dispose()
diff --git a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs b/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
index 30b34dfa65f..8b43dad4999 100644
--- a/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
+++ b/src/Build/BuildCheck/API/BuildAnalyzerRule.cs
@@ -5,8 +5,8 @@ namespace Microsoft.Build.Experimental.BuildCheck;
 
 /// <summary>
 /// Represents a rule that is a unit of build analysis.
-/// <see cref="BuildAnalyzer"/> is a unit of executing the analysis, but it can be discovering multiple distinct violation types.
-///  for this reason a single <see cref="BuildAnalyzer"/> can expose <see cref="BuildAnalyzerRule"/>s.
+/// <see cref="BuildAnalyzer"/> is a unit of executing the analysis, but it can be discovering multiple distinct violation types,
+///  for this reason a single <see cref="BuildAnalyzer"/> can expose multiple <see cref="BuildAnalyzerRule"/>s.
 /// </summary>
 public class BuildAnalyzerRule
 {
diff --git a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
index b7f79c796ac..5ed589905e2 100644
--- a/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/BuildCheckAcquisitionModule.cs
@@ -2,16 +2,26 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.BuildCheck.Infrastructure;
 using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 namespace Microsoft.Build.BuildCheck.Acquisition
 {
     internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
     {
+        private readonly ILoggingService _loggingService;
+
+        internal BuildCheckAcquisitionModule(ILoggingService loggingService)
+        {
+            _loggingService = loggingService;
+        }
+
 #if FEATURE_ASSEMBLYLOADCONTEXT
         /// <summary>
         /// AssemblyContextLoader used to load DLLs outside of msbuild.exe directory
@@ -19,7 +29,7 @@ internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
         private static readonly CoreClrAssemblyLoader s_coreClrAssemblyLoader = new();
 #endif
 
-        public BuildAnalyzerFactory? CreateBuildAnalyzerFactory(AnalyzerAcquisitionData analyzerAcquisitionData)
+        public IEnumerable<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, BuildEventContext buildEventContext)
         {
             try
             {
@@ -30,13 +40,24 @@ internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
                 assembly = Assembly.LoadFrom(analyzerAcquisitionData.AssemblyPath);
 #endif
 
-                Type? analyzerType = assembly.GetTypes().FirstOrDefault(t => typeof(BuildAnalyzer).IsAssignableFrom(t));
+                IEnumerable<Type> analyzerTypes = assembly.GetTypes().Where(t => typeof(BuildAnalyzer).IsAssignableFrom(t));
 
-                if (analyzerType != null)
+                if (analyzerTypes.Any())
                 {
-                    return () => Activator.CreateInstance(analyzerType) is not BuildAnalyzer instance
-                            ? throw new InvalidOperationException($"Failed to create an instance of type {analyzerType.FullName} as BuildAnalyzer.")
-                            : instance;
+                    var analyzersFactory = new List<BuildAnalyzerFactory>();
+                    foreach (Type analyzerType in analyzerTypes)
+                    {
+                        if (Activator.CreateInstance(analyzerType) is BuildAnalyzer instance)
+                        {
+                            analyzersFactory.Add(() => instance);
+                        }
+                        else
+                        {
+                            throw new InvalidOperationException($"Failed to create an instance of type {analyzerType.FullName} as BuildAnalyzer.");
+                        }
+                    }
+
+                    return analyzersFactory;
                 }
             }
             catch (ReflectionTypeLoadException ex)
@@ -45,13 +66,12 @@ internal class BuildCheckAcquisitionModule : IBuildCheckAcquisitionModule
                 {
                     foreach (Exception? loaderException in ex.LoaderExceptions)
                     {
-                        // How do we plan to handle these errors?
-                        Console.WriteLine(loaderException?.Message ?? "Unknown error occurred.");
+                        _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerFailedRuleLoading", loaderException?.Message);
                     }
                 }
             }
 
-            return null;
+            return Enumerable.Empty<BuildAnalyzerFactory>();
         }
     }
 }
diff --git a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
index 98df459aed5..166aa3fb210 100644
--- a/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
+++ b/src/Build/BuildCheck/Acquisition/IBuildCheckAcquisitionModule.cs
@@ -1,12 +1,14 @@
 ﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Collections.Generic;
 using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.BuildCheck.Acquisition
 {
     internal interface IBuildCheckAcquisitionModule
     {
-        BuildAnalyzerFactory? CreateBuildAnalyzerFactory(AnalyzerAcquisitionData analyzerAcquisitionData);
+        IEnumerable<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, BuildEventContext buildEventContext);
     }
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
index 6789ae47bd4..2b07416cd09 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckConnectorLogger.cs
@@ -8,102 +8,96 @@
 using Microsoft.Build.BuildCheck.Acquisition;
 using Microsoft.Build.Experimental.BuildCheck;
 using Microsoft.Build.Framework;
+using static Microsoft.Build.BuildCheck.Infrastructure.BuildCheckManagerProvider;
 
-namespace Microsoft.Build.BuildCheck.Infrastructure
+namespace Microsoft.Build.BuildCheck.Infrastructure;
+
+internal sealed class BuildCheckConnectorLogger : ILogger
 {
-    internal sealed class BuildCheckConnectorLogger : ILogger
+    private readonly Dictionary<Type, Action<BuildEventArgs>> _eventHandlers;
+    private readonly IBuildCheckManager _buildCheckManager;
+    private readonly IBuildAnalysisLoggingContextFactory _loggingContextFactory;
+
+    internal BuildCheckConnectorLogger(
+        IBuildAnalysisLoggingContextFactory loggingContextFactory,
+        IBuildCheckManager buildCheckManager)
     {
-        private readonly Dictionary<Type, Action<BuildEventArgs>> _eventHandlers;
-        private readonly IBuildCheckManager _buildCheckManager;
-        private readonly IBuildAnalysisLoggingContextFactory _loggingContextFactory;
+        _buildCheckManager = buildCheckManager;
+        _loggingContextFactory = loggingContextFactory;
+        _eventHandlers = GetBuildEventHandlers();
+    }
 
-        internal BuildCheckConnectorLogger(
-            IBuildAnalysisLoggingContextFactory loggingContextFactory,
-            IBuildCheckManager buildCheckManager)
-        {
-            _buildCheckManager = buildCheckManager;
-            _loggingContextFactory = loggingContextFactory;
-            _eventHandlers = GetBuildEventHandlers();
-        }
+    public LoggerVerbosity Verbosity { get; set; }
 
-        public LoggerVerbosity Verbosity { get; set; }
+    public string? Parameters { get; set; }
 
-        public string? Parameters { get; set; }
+    public void Initialize(IEventSource eventSource)
+    {
+        eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+        eventSource.BuildFinished += EventSource_BuildFinished;
+    }
 
-        public void Initialize(IEventSource eventSource)
-        {
-            eventSource.AnyEventRaised += EventSource_AnyEventRaised;
-            eventSource.BuildFinished += EventSource_BuildFinished;
-        }
+    public void Shutdown()
+    {
+    }
 
-        public void Shutdown()
+    private void HandleProjectEvaluationFinishedEvent(ProjectEvaluationFinishedEventArgs eventArgs)
+    {
+        if (!IsMetaProjFile(eventArgs.ProjectFile))
         {
-        }
+            _buildCheckManager.ProcessEvaluationFinishedEventArgs(
+                _loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!),
+                eventArgs);
 
-        private void HandleProjectEvaluationEvent(ProjectEvaluationFinishedEventArgs eventArgs)
-        {
-            if (!IsMetaProjFile(eventArgs.ProjectFile))
-            {
-                try
-                {
-                    _buildCheckManager.ProcessEvaluationFinishedEventArgs(_loggingContextFactory.CreateLoggingContext(eventArgs.BuildEventContext!), eventArgs);
-                }
-                catch (Exception exception)
-                {
-                    Console.WriteLine(exception);
-                    throw;
-                }
-
-                _buildCheckManager.EndProjectEvaluation(BuildCheckDataSource.EventArgs, eventArgs.BuildEventContext!);
-            }
+            _buildCheckManager.EndProjectEvaluation(BuildCheckDataSource.EventArgs, eventArgs.BuildEventContext!);
         }
+    }
 
-        private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventArgs eventArgs)
+    private void HandleProjectEvaluationStartedEvent(ProjectEvaluationStartedEventArgs eventArgs)
+    {
+        if (!IsMetaProjFile(eventArgs.ProjectFile))
         {
-            if (!IsMetaProjFile(eventArgs.ProjectFile))
-            {
-                _buildCheckManager.StartProjectEvaluation(BuildCheckDataSource.EventArgs, eventArgs.BuildEventContext!, eventArgs.ProjectFile!);
-            }
+            _buildCheckManager.StartProjectEvaluation(BuildCheckDataSource.EventArgs, eventArgs.BuildEventContext!, eventArgs.ProjectFile!);
         }
+    }
 
-        private bool IsMetaProjFile(string? projectFile) => !string.IsNullOrEmpty(projectFile) && projectFile!.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase);
+    private bool IsMetaProjFile(string? projectFile) => !string.IsNullOrEmpty(projectFile) && projectFile!.EndsWith(".metaproj", StringComparison.OrdinalIgnoreCase);
 
-        private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
+    private void EventSource_AnyEventRaised(object sender, BuildEventArgs e)
+    {
+        if (_eventHandlers.TryGetValue(e.GetType(), out Action<BuildEventArgs>? handler))
         {
-            if (_eventHandlers.TryGetValue(e.GetType(), out Action<BuildEventArgs>? handler))
-            {
-                handler(e);
-            }
+            handler(e);
         }
+    }
 
-        private readonly Dictionary<string, TimeSpan> _stats = new Dictionary<string, TimeSpan>();
+    private readonly Dictionary<string, TimeSpan> _stats = new Dictionary<string, TimeSpan>();
 
-        private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
-        {
-            _stats.Merge(_buildCheckManager.CreateTracingStats(), (span1, span2) => span1 + span2);
-            string msg = string.Join(Environment.NewLine, _stats.Select(a => a.Key + ": " + a.Value));
-
-            BuildEventContext buildEventContext = e.BuildEventContext
-                ?? new BuildEventContext(
-                    BuildEventContext.InvalidNodeId,
-                    BuildEventContext.InvalidTargetId,
-                    BuildEventContext.InvalidProjectContextId,
-                    BuildEventContext.InvalidTaskId);
+    private void EventSource_BuildFinished(object sender, BuildFinishedEventArgs e)
+    {
+        _stats.Merge(_buildCheckManager.CreateTracingStats(), (span1, span2) => span1 + span2);
+        string msg = string.Join(Environment.NewLine, _stats.Select(a => a.Key + ": " + a.Value));
 
-            LoggingContext loggingContext = _loggingContextFactory.CreateLoggingContext(buildEventContext);
+        BuildEventContext buildEventContext = e.BuildEventContext
+            ?? new BuildEventContext(
+                BuildEventContext.InvalidNodeId,
+                BuildEventContext.InvalidTargetId,
+                BuildEventContext.InvalidProjectContextId,
+                BuildEventContext.InvalidTaskId);
 
-            // Tracing: https://github.com/dotnet/msbuild/issues/9629
-            loggingContext.LogCommentFromText(MessageImportance.High, msg);
-        }
+        LoggingContext loggingContext = _loggingContextFactory.CreateLoggingContext(buildEventContext);
 
-        private Dictionary<Type, Action<BuildEventArgs>> GetBuildEventHandlers() => new()
-        {
-            { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationEvent((ProjectEvaluationFinishedEventArgs) e) },
-            { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs) e) },
-            { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
-            { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => _buildCheckManager.EndProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
-            { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => _stats.Merge(((BuildCheckTracingEventArgs)e).TracingData, (span1, span2) => span1 + span2) },
-            { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => _buildCheckManager.ProcessAnalyzerAcquisition(((BuildCheckAcquisitionEventArgs)e).ToAnalyzerAcquisitionData(), e.BuildEventContext!) },
-        };
+        // Tracing: https://github.com/dotnet/msbuild/issues/9629
+        loggingContext.LogCommentFromText(MessageImportance.High, msg);
     }
+
+    private Dictionary<Type, Action<BuildEventArgs>> GetBuildEventHandlers() => new()
+    {
+        { typeof(ProjectEvaluationFinishedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationFinishedEvent((ProjectEvaluationFinishedEventArgs) e) },
+        { typeof(ProjectEvaluationStartedEventArgs), (BuildEventArgs e) => HandleProjectEvaluationStartedEvent((ProjectEvaluationStartedEventArgs) e) },
+        { typeof(ProjectStartedEventArgs), (BuildEventArgs e) => _buildCheckManager.StartProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
+        { typeof(ProjectFinishedEventArgs), (BuildEventArgs e) => _buildCheckManager.EndProjectRequest(BuildCheckDataSource.EventArgs, e.BuildEventContext!) },
+        { typeof(BuildCheckTracingEventArgs), (BuildEventArgs e) => _stats.Merge(((BuildCheckTracingEventArgs)e).TracingData, (span1, span2) => span1 + span2) },
+        { typeof(BuildCheckAcquisitionEventArgs), (BuildEventArgs e) => _buildCheckManager.ProcessAnalyzerAcquisition(((BuildCheckAcquisitionEventArgs)e).ToAnalyzerAcquisitionData(), e.BuildEventContext!) },
+    };
 }
diff --git a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
index 5bfe3f92490..243406ca457 100644
--- a/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
+++ b/src/Build/BuildCheck/Infrastructure/BuildCheckManagerProvider.cs
@@ -73,7 +73,7 @@ internal sealed class BuildCheckManager : IBuildCheckManager
         internal BuildCheckManager(ILoggingService loggingService)
         {
             _analyzersRegistry = new List<BuildAnalyzerFactoryContext>();
-            _acquisitionModule = new BuildCheckAcquisitionModule();
+            _acquisitionModule = new BuildCheckAcquisitionModule(loggingService);
             _loggingService = loggingService;
             _buildEventsProcessor = new(_buildCheckCentralContext);
         }
@@ -99,10 +99,10 @@ public void ProcessAnalyzerAcquisition(AnalyzerAcquisitionData acquisitionData,
         {
             if (IsInProcNode)
             {
-                BuildAnalyzerFactory? factory = _acquisitionModule.CreateBuildAnalyzerFactory(acquisitionData);
-                if (factory != null)
+                var analyzersFactories = _acquisitionModule.CreateBuildAnalyzerFactories(acquisitionData, buildEventContext);
+                if (analyzersFactories.Any())
                 {
-                    RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, factory, buildEventContext);
+                    RegisterCustomAnalyzer(BuildCheckDataSource.EventArgs, analyzersFactories, buildEventContext);
                 }
                 else
                 {
@@ -145,18 +145,21 @@ private void RegisterBuiltInAnalyzers(BuildCheckDataSource buildCheckDataSource)
         }
 
         /// <summary>
-        /// To be used by acquisition module
-        /// Registeres the custom analyzer, the construction of analyzer is deferred until the first using project is encountered
+        /// To be used by acquisition module.
+        /// Registeres the custom analyzers, the construction of analyzers is deferred until the first using project is encountered.
         /// </summary>
-        internal void RegisterCustomAnalyzer(
+        internal void RegisterCustomAnalyzers(
             BuildCheckDataSource buildCheckDataSource,
-            BuildAnalyzerFactory factory,
+            IEnumerable<BuildAnalyzerFactory> factories,
             string[] ruleIds,
             bool defaultEnablement)
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
             {
-                _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(factory, ruleIds, defaultEnablement));
+                foreach (BuildAnalyzerFactory factory in factories)
+                {
+                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(factory, ruleIds, defaultEnablement));
+                }
             }
         }
 
@@ -166,17 +169,20 @@ internal void RegisterCustomAnalyzer(
         /// </summary>
         internal void RegisterCustomAnalyzer(
             BuildCheckDataSource buildCheckDataSource,
-            BuildAnalyzerFactory factory,
+            IEnumerable<BuildAnalyzerFactory> factories,
             BuildEventContext buildEventContext)
         {
             if (_enabledDataSources[(int)buildCheckDataSource])
             {
-                var instance = factory();
-                _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(
-                    factory,
-                    instance.SupportedRules.Select(r => r.Id).ToArray(),
-                    instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
-                _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.GetType().Name);
+                foreach (var factory in factories)
+                {
+                    var instance = factory();
+                    _analyzersRegistry.Add(new BuildAnalyzerFactoryContext(
+                        factory,
+                        instance.SupportedRules.Select(r => r.Id).ToArray(),
+                        instance.SupportedRules.Any(r => r.DefaultConfiguration.IsEnabled == true)));
+                    _loggingService.LogComment(buildEventContext, MessageImportance.Normal, "CustomAnalyzerSuccessfulAcquisition", instance.GetType().Name);
+                }         
             }
         }
 
@@ -209,6 +215,11 @@ private void SetupSingleAnalyzer(BuildAnalyzerFactoryContext analyzerFactoryCont
                 analyzerFactoryContext.MaterializedAnalyzer = wrapper;
                 BuildAnalyzer analyzer = wrapper.BuildAnalyzer;
 
+                // This is to facilitate possible perf improvement for custom analyzers - as we might want to
+                //  avoid loading the assembly and type just to check if it's supported.
+                // If we expose a way to declare the enablement status and rule ids during registration (e.g. via
+                //  optional arguments of the intrinsic property function) - we can then avoid loading it.
+                // But once loaded - we should verify that the declared enablement status and rule ids match the actual ones.
                 if (
                     analyzer.SupportedRules.Count != analyzerFactoryContext.RuleIds.Length
                     ||
@@ -272,12 +283,15 @@ private void SetupAnalyzersForNewProject(string projectFullPath, BuildEventConte
                     _loggingService.LogErrorFromText(buildEventContext, null, null, null,
                         new BuildEventFileInfo(projectFullPath),
                         e.Message);
-                    _loggingService.LogCommentFromText(buildEventContext, MessageImportance.High, $"Dismounting analyzer '{analyzerFactoryContext.FriendlyName}'");
                     analyzersToRemove.Add(analyzerFactoryContext);
                 }
             }
 
-            analyzersToRemove.ForEach(c => _analyzersRegistry.Remove(c));
+            analyzersToRemove.ForEach(c =>
+            {
+                _analyzersRegistry.Remove(c);
+                _loggingService.LogCommentFromText(buildEventContext, MessageImportance.High, $"Dismounting analyzer '{c.FriendlyName}'");
+            });
             foreach (var analyzerToRemove in analyzersToRemove.Select(a => a.MaterializedAnalyzer).Where(a => a != null))
             {
                 _buildCheckCentralContext.DeregisterAnalyzer(analyzerToRemove!);
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 7e1dd5ec428..1d59567f1c2 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -3911,7 +3911,7 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                     {
                         if (string.Equals(_methodMethodName, nameof(IntrinsicFunctions.RegisterAnalyzer), StringComparison.OrdinalIgnoreCase))
                         {
-                            if (TryGetArg(args, out string arg0) && _loggingContext != null)
+                            if (_loggingContext != null && TryGetArg(args, out string arg0))
                             {
                                 returnVal = IntrinsicFunctions.RegisterAnalyzer(arg0, _loggingContext);
                                 return true;
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index 8822c0212fe..b15e0af11dc 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -1,17 +1,17 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <root>
-  <!-- 
-    Microsoft ResX Schema 
-    
+  <!--
+    Microsoft ResX Schema
+
     Version 2.0
-    
-    The primary goals of this format is to allow a simple XML format 
-    that is mostly human readable. The generation and parsing of the 
-    various data types are done through the TypeConverter classes 
+
+    The primary goals of this format is to allow a simple XML format
+    that is mostly human readable. The generation and parsing of the
+    various data types are done through the TypeConverter classes
     associated with the data types.
-    
+
     Example:
-    
+
     ... ado.net/XML headers & schema ...
     <resheader name="resmimetype">text/microsoft-resx</resheader>
     <resheader name="version">2.0</resheader>
@@ -26,36 +26,36 @@
         <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
         <comment>This is a comment</comment>
     </data>
-                
-    There are any number of "resheader" rows that contain simple 
+
+    There are any number of "resheader" rows that contain simple
     name/value pairs.
-    
-    Each data row contains a name, and value. The row also contains a 
-    type or mimetype. Type corresponds to a .NET class that support 
-    text/value conversion through the TypeConverter architecture. 
-    Classes that don't support this are serialized and stored with the 
+
+    Each data row contains a name, and value. The row also contains a
+    type or mimetype. Type corresponds to a .NET class that support
+    text/value conversion through the TypeConverter architecture.
+    Classes that don't support this are serialized and stored with the
     mimetype set.
-    
-    The mimetype is used for serialized objects, and tells the 
-    ResXResourceReader how to depersist the object. This is currently not 
+
+    The mimetype is used for serialized objects, and tells the
+    ResXResourceReader how to depersist the object. This is currently not
     extensible. For a given mimetype the value must be set accordingly:
-    
-    Note - application/x-microsoft.net.object.binary.base64 is the format 
-    that the ResXResourceWriter will generate, however the reader can 
+
+    Note - application/x-microsoft.net.object.binary.base64 is the format
+    that the ResXResourceWriter will generate, however the reader can
     read any of the formats listed below.
-    
+
     mimetype: application/x-microsoft.net.object.binary.base64
-    value   : The object must be serialized with 
+    value   : The object must be serialized with
             : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
             : and then encoded with base64 encoding.
-    
+
     mimetype: application/x-microsoft.net.object.soap.base64
-    value   : The object must be serialized with 
+    value   : The object must be serialized with
             : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
             : and then encoded with base64 encoding.
 
     mimetype: application/x-microsoft.net.object.bytearray.base64
-    value   : The object must be serialized into a byte array 
+    value   : The object must be serialized into a byte array
             : using a System.ComponentModel.TypeConverter
             : and then encoded with base64 encoding.
     -->
@@ -142,7 +142,7 @@
   <data name="WaitingForEndOfBuild" xml:space="preserve">
     <value>The operation cannot be completed because EndBuild has already been called but existing submissions have not yet completed.</value>
   </data>
-  <data name="EnvironmentDerivedPropertyRead" xml:space="preserve">
+  <data name="EnvironmentDerivedPropertyRead">
     <value>Property '{0}' with value '{1}' expanded from the environment.</value>
   </data>
   <data name="SubmissionAlreadyComplete" xml:space="preserve">
@@ -476,7 +476,7 @@
     likely because of a programming error in the logger). When a logger dies, we cannot proceed with the build, and we throw a
     special exception to abort the build.</comment>
   </data>
-  <data name="General.TwoVectorsMustHaveSameLength" xml:space="preserve">
+  <data name="General.TwoVectorsMustHaveSameLength">
     <value>MSB3094: "{2}" refers to {0} item(s), and "{3}" refers to {1} item(s). They must have the same number of items.</value>
     <comment>{StrBegin="MSB3094: "}</comment>
   </data>
@@ -1162,7 +1162,7 @@
       LOCALIZATION: "{2}" is a localized message from a CLR/FX exception. Also, Microsoft.Build.Framework should not be localized
     </comment>
   </data>
-  <data name="TaskReturnedFalseButDidNotLogError" xml:space="preserve">
+  <data name="TaskReturnedFalseButDidNotLogError">
     <value>MSB4181: The "{0}" task returned false but did not log an error.</value>
     <comment>{StrBegin="MSB4181: "}</comment>
   </data>
@@ -1292,7 +1292,7 @@
     <value>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized.</value>
     <comment>{StrBegin="MSB4067: "}</comment>
   </data>
-  <data name="PropertyOutsidePropertyGroupInTarget" xml:space="preserve">
+  <data name="PropertyOutsidePropertyGroupInTarget" xml:space="preserve" Condition="$([MSBuild]::AreFeaturesEnabled('17.6'))">
     <value>MSB4067: The element &lt;{0}&gt; beneath element &lt;{1}&gt; is unrecognized. If you intended this to be a property, enclose it within a &lt;PropertyGroup&gt; element.</value>
     <comment>{StrBegin="MSB4067: "}</comment>
   </data>
@@ -1743,7 +1743,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>MSB4231: ProjectRootElement can't reload if it contains unsaved changes.</value>
     <comment>{StrBegin="MSB4231: "}</comment>
   </data>
-  <data name="LogTaskInputs.Truncated" xml:space="preserve">
+  <data name="LogTaskInputs.Truncated">
     <value>The parameters have been truncated beyond this point. To view all parameters, clear the MSBUILDTRUNCATETASKINPUTLOGGING environment variable.</value>
   </data>
   <data name="MetaprojectGenerated" xml:space="preserve">
@@ -1971,9 +1971,9 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     </comment>
   </data>
   <data name="ProjectCacheHitWithOutputs" xml:space="preserve">
-    <value>{0} -&gt; Cache Hit</value>
+    <value>{0} -> Cache Hit</value>
     <comment>
-      {StrBegin="{0} -&gt; "}LOCALIZATION: This string is used to indicate progress and matches the format for a log message from Microsoft.Common.CurrentVersion.targets. {0} is a project name.
+      {StrBegin="{0} -> "}LOCALIZATION: This string is used to indicate progress and matches the format for a log message from Microsoft.Common.CurrentVersion.targets. {0} is a project name.
     </comment>
   </data>
   <data name="ProjectCacheMissWithDefaultTargets" xml:space="preserve">
@@ -2000,7 +2000,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
       LOCALIZATION: {0} is a file path. {1} is a comma-separated list of target names
     </comment>
   </data>
-  <data name="DefaultSDKResolverError" xml:space="preserve">
+   <data name="DefaultSDKResolverError" xml:space="preserve">
     <value>MSB4276: The default SDK resolver failed to resolve SDK "{0}" because directory "{1}" did not exist.</value>
   </data>
   <data name="SDKResolverReturnedNull" xml:space="preserve">
@@ -2042,7 +2042,7 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <value>Imported files archive exceeded 2GB limit and it's not embedded.</value>
   </data>
   <data name="Binlog_FwdCompatUnsupported" xml:space="preserve">
-    <value>Forward compatible reading is not supported for file format version {0} (needs &gt;= 18).</value>
+    <value>Forward compatible reading is not supported for file format version {0} (needs >= 18).</value>
     <comment>
       LOCALIZATION: {0} is an integer number denoting version.
     </comment>
@@ -2100,7 +2100,18 @@ Utilization:          {0} Average Utilization: {1:###.0}</value>
     <comment>The message is emmited on successful loading of the custom analyzer in app domain.</comment>
   </data>
   <data name="CustomAnalyzerFailedAcquisition" xml:space="preserve">
-    <value>Failed to ragister the custom analyzer: {0}.</value>
+    <value>Failed to register the custom analyzer: {0}.</value>
     <comment>The message is emmited on failed loading of the custom analyzer in app domain.</comment>
   </data>
+  <data name="CustomAnalyzerFailedRuleLoading" xml:space="preserve">
+    <value>Failed to instantiate the custom analyzer rule with the next exception: {0}.</value>
+    <comment>The message is emmited on failed loading of the custom analyzer rule in app domain.</comment>
+  </data>
+  <!--
+        The Build message bucket is: MSB4000 - MSB4999
+
+        Next message code should be MSB4279
+
+        Don't forget to update this comment after using a new code.
+  -->
 </root>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 563cdcc63c2..b6012e4e25b 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 668a612bf7a..3c406a8aa02 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 1673d5e2a5a..b5ca6a54d32 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index 125669fa641..8bc5db5db18 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index cb083681300..8e77554cd99 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 3fd9a12302e..cdc074c9f8e 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index e6e302839ce..4ac484eee96 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index 2c0fd575dce..4b69db5542b 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index aeaa1eba431..54ea8154e0d 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 195a24979af..fe01a60fd98 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 0c4e6ecc1e0..6a943e4649c 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index b1fb3c6921d..e996b5c9b7e 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index 63ac69da9b3..8f91df055cf 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -208,10 +208,15 @@
     request a target to build itself (perhaps via a chain of other targets).</note>
       </trans-unit>
       <trans-unit id="CustomAnalyzerFailedAcquisition">
-        <source>Failed to ragister the custom analyzer: {0}.</source>
-        <target state="new">Failed to ragister the custom analyzer: {0}.</target>
+        <source>Failed to register the custom analyzer: {0}.</source>
+        <target state="new">Failed to register the custom analyzer: {0}.</target>
         <note>The message is emmited on failed loading of the custom analyzer in app domain.</note>
       </trans-unit>
+      <trans-unit id="CustomAnalyzerFailedRuleLoading">
+        <source>Failed to instantiate the custom analyzer rule with the next exception: {0}.</source>
+        <target state="new">Failed to instantiate the custom analyzer rule with the next exception: {0}.</target>
+        <note>The message is emmited on failed loading of the custom analyzer rule in app domain.</note>
+      </trans-unit>
       <trans-unit id="CustomAnalyzerSuccessfulAcquisition">
         <source>Custom analyzer {0} has been registered successfully.</source>
         <target state="new">Custom analyzer {0} has been registered successfully.</target>
diff --git a/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
new file mode 100644
index 00000000000..248b66ea6b0
--- /dev/null
+++ b/src/BuildCheck.UnitTests/BuildAnalyzerConfigurationInternalTests.cs
@@ -0,0 +1,43 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Xunit;
+using Microsoft.Build.BuildCheck.Infrastructure;
+using Microsoft.Build.Experimental.BuildCheck;
+using Shouldly;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class BuildAnalyzerConfigurationInternalTests
+{
+    [Theory]
+    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning, true, true)]
+    [InlineData("ruleId2", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Warning, true, true)]
+    [InlineData("ruleId", EvaluationAnalysisScope.ProjectOnly, BuildAnalyzerResultSeverity.Error, true, false)]
+    public void IsSameConfigurationAsTest(
+        string secondRuleId,
+        EvaluationAnalysisScope secondScope,
+        BuildAnalyzerResultSeverity secondSeverity,
+        bool secondEnabled,
+        bool isExpectedToBeSame)
+    {
+        BuildAnalyzerConfigurationInternal configuration1 = new BuildAnalyzerConfigurationInternal(
+                       ruleId: "ruleId",
+                       evaluationAnalysisScope: EvaluationAnalysisScope.ProjectOnly,
+                       severity: BuildAnalyzerResultSeverity.Warning,
+                       isEnabled: true);
+
+        BuildAnalyzerConfigurationInternal configuration2 = new BuildAnalyzerConfigurationInternal(
+            ruleId: secondRuleId,
+            evaluationAnalysisScope: secondScope,
+            severity: secondSeverity,
+            isEnabled: secondEnabled);
+
+        configuration1.IsSameConfigurationAs(configuration2).ShouldBe(isExpectedToBeSame);
+    }
+}
diff --git a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
index f632b2054ba..5b01f121d6b 100644
--- a/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
+++ b/src/BuildCheck.UnitTests/BuildCheckManagerProviderTests.cs
@@ -17,91 +17,90 @@
 using Xunit.Abstractions;
 using static Microsoft.Build.BuildCheck.Infrastructure.BuildCheckManagerProvider;
 
-namespace Microsoft.Build.BuildCheck.UnitTests
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class BuildCheckManagerTests
 {
-    public class BuildCheckManagerTests
-    {
-        private readonly IBuildCheckManager _testedInstance;
-        private readonly ILoggingService _loggingService;
-        private readonly MockLogger _logger;
+    private readonly IBuildCheckManager _testedInstance;
+    private readonly ILoggingService _loggingService;
+    private readonly MockLogger _logger;
 
-        public BuildCheckManagerTests(ITestOutputHelper output)
-        {
-            _loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
-            _logger = new MockLogger();
-            _loggingService.RegisterLogger(_logger);
-            _testedInstance = new BuildCheckManager(_loggingService);
-        }
+    public BuildCheckManagerTests(ITestOutputHelper output)
+    {
+        _loggingService = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
+        _logger = new MockLogger();
+        _loggingService.RegisterLogger(_logger);
+        _testedInstance = new BuildCheckManager(_loggingService);
+    }
 
-        [Theory]
-        [InlineData(true, "Custom analyzer BuildAnalyzerRuleMock has been registered successfully.")]
-        [InlineData(false, "Failed to ragister the custom analyzer: DummyPath.")]
-        public void ProcessAnalyzerAcquisitionTest(bool isAnalyzerRuleExist, string expectedMessage)
-        {
-            MockBuildCheckAcquisition(isAnalyzerRuleExist);
-            MockEnabledDataSourcesDefinition();
+    [Theory]
+    [InlineData(true, "Custom analyzer BuildAnalyzerRuleMock has been registered successfully.")]
+    [InlineData(false, "Failed to ragister the custom analyzer: DummyPath.")]
+    public void ProcessAnalyzerAcquisitionTest(bool isAnalyzerRuleExist, string expectedMessage)
+    {
+        MockBuildCheckAcquisition(isAnalyzerRuleExist);
+        MockEnabledDataSourcesDefinition();
 
-            _testedInstance.ProcessAnalyzerAcquisition(new AnalyzerAcquisitionData("DummyPath"), new BuildEventContext(1, 2, 3, 4, 5, 6, 7));
+        _testedInstance.ProcessAnalyzerAcquisition(new AnalyzerAcquisitionData("DummyPath"), new BuildEventContext(1, 2, 3, 4, 5, 6, 7));
 
-            _logger.AllBuildEvents.Where(be => be.GetType() == typeof(BuildMessageEventArgs))
-                .ShouldContain(be => be.Message == expectedMessage);
-        }
+        _logger.AllBuildEvents.Where(be => be.GetType() == typeof(BuildMessageEventArgs))
+            .ShouldContain(be => be.Message == expectedMessage);
+    }
 
-        private void MockBuildCheckAcquisition(bool isAnalyzerRuleExist) => MockField("_acquisitionModule", new BuildCheckAcquisitionModuleMock(isAnalyzerRuleExist));
+    private void MockBuildCheckAcquisition(bool isAnalyzerRuleExist) => MockField("_acquisitionModule", new BuildCheckAcquisitionModuleMock(isAnalyzerRuleExist));
 
-        private void MockEnabledDataSourcesDefinition() => MockField("_enabledDataSources", new[] { true, true });
+    private void MockEnabledDataSourcesDefinition() => MockField("_enabledDataSources", new[] { true, true });
 
-        private void MockField(string fieldName, object mockedValue)
+    private void MockField(string fieldName, object mockedValue)
+    {
+        var mockedField = _testedInstance.GetType().GetField(fieldName, BindingFlags.NonPublic | BindingFlags.Instance);
+        if (mockedField != null)
         {
-            var mockedField = _testedInstance.GetType().GetField(fieldName, BindingFlags.NonPublic | BindingFlags.Instance);
-            if (mockedField != null)
-            {
-                mockedField.SetValue(_testedInstance, mockedValue);
-            }
+            mockedField.SetValue(_testedInstance, mockedValue);
         }
     }
+}
 
-    internal sealed class BuildCheckAcquisitionModuleMock : IBuildCheckAcquisitionModule
-    {
-        private readonly bool _isAnalyzerRuleExistForTest = true;
+internal sealed class BuildCheckAcquisitionModuleMock : IBuildCheckAcquisitionModule
+{
+    private readonly bool _isAnalyzerRuleExistForTest = true;
 
-        internal BuildCheckAcquisitionModuleMock(bool isAnalyzerRuleExistForTest) => _isAnalyzerRuleExistForTest = isAnalyzerRuleExistForTest;
+    internal BuildCheckAcquisitionModuleMock(bool isAnalyzerRuleExistForTest) => _isAnalyzerRuleExistForTest = isAnalyzerRuleExistForTest;
 
-        public BuildAnalyzerFactory? CreateBuildAnalyzerFactory(AnalyzerAcquisitionData analyzerAcquisitionData) =>
-            _isAnalyzerRuleExistForTest
-            ? () => new BuildAnalyzerRuleMock()
-            : null;
-    }
+    public IEnumerable<BuildAnalyzerFactory> CreateBuildAnalyzerFactories(AnalyzerAcquisitionData analyzerAcquisitionData, BuildEventContext buildEventContext)
+        => _isAnalyzerRuleExistForTest
+        ? new List<BuildAnalyzerFactory>() { () => new BuildAnalyzerRuleMock() }
+        : new List<BuildAnalyzerFactory>();
+}
 
-    internal sealed class BuildAnalyzerRuleMock : BuildAnalyzer
-    {
-        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
-            "X01234",
-            "Title",
-            "Description",
-            "Message format: {0}",
-            new BuildAnalyzerConfiguration());
+internal sealed class BuildAnalyzerRuleMock : BuildAnalyzer
+{
+    public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule(
+        "X01234",
+        "Title",
+        "Description",
+        "Message format: {0}",
+        new BuildAnalyzerConfiguration());
 
-        public override string FriendlyName => "BuildAnalyzerRuleMock";
+    public override string FriendlyName => "BuildAnalyzerRuleMock";
 
-        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
+    public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } = new List<BuildAnalyzerRule>() { SupportedRule };
 
-        public override void Initialize(ConfigurationContext configurationContext)
-        {
-            // configurationContext to be used only if analyzer needs external configuration data.
-        }
+    public override void Initialize(ConfigurationContext configurationContext)
+    {
+        // configurationContext to be used only if analyzer needs external configuration data.
+    }
 
-        public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
-        {
-            registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
-        }
+    public override void RegisterActions(IBuildCheckRegistrationContext registrationContext)
+    {
+        registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+    }
 
-        private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
-        {
-            context.ReportResult(BuildCheckResult.Create(
-                SupportedRule,
-                ElementLocation.EmptyLocation,
-                "Argument for the message format"));
-        }
+    private void EvaluatedPropertiesAction(BuildCheckDataContext<EvaluatedPropertiesAnalysisData> context)
+    {
+        context.ReportResult(BuildCheckResult.Create(
+            SupportedRule,
+            ElementLocation.EmptyLocation,
+            "Argument for the message format"));
     }
 }
diff --git a/src/BuildCheck.UnitTests/EndToEndTests.cs b/src/BuildCheck.UnitTests/EndToEndTests.cs
index c523f879b8e..a0007d2c103 100644
--- a/src/BuildCheck.UnitTests/EndToEndTests.cs
+++ b/src/BuildCheck.UnitTests/EndToEndTests.cs
@@ -2,132 +2,136 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.IO;
+using System.Linq;
+using System.Reflection;
+using System.Text;
+using System.Threading.Tasks;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.Shared;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
 
-namespace Microsoft.Build.BuildCheck.UnitTests
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class EndToEndTests : IDisposable
 {
-    public class EndToEndTests : IDisposable
+    private readonly TestEnvironment _env;
+    public EndToEndTests(ITestOutputHelper output)
     {
-        private readonly TestEnvironment _env;
+        _env = TestEnvironment.Create(output);
 
-        public EndToEndTests(ITestOutputHelper output)
-        {
-            _env = TestEnvironment.Create(output);
+        // this is needed to ensure the binary logger does not pollute the environment
+        _env.WithEnvironmentInvariant();
+    }
 
-            // this is needed to ensure the binary logger does not pollute the environment
-            _env.WithEnvironmentInvariant();
-        }
+    public void Dispose() => _env.Dispose();
 
-        public void Dispose() => _env.Dispose();
+    [Theory]
+    [InlineData(true, true)]
+    [InlineData(false, true)]
+    [InlineData(false, false)]
+    public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool analysisRequested)
+    {
+        string contents = $"""
+            <Project Sdk="Microsoft.NET.Sdk" DefaultTargets="Hello">
+                
+                <PropertyGroup>
+                <OutputType>Exe</OutputType>
+                <TargetFramework>net8.0</TargetFramework>
+                <ImplicitUsings>enable</ImplicitUsings>
+                <Nullable>enable</Nullable>
+                </PropertyGroup>
+                  
+                <PropertyGroup Condition="$(Test) == true">
+                <TestProperty>Test</TestProperty>
+                </PropertyGroup>
+                 
+                <ItemGroup>
+                <ProjectReference Include=".\FooBar-Copy.csproj" />
+                </ItemGroup>
+                  
+                <Target Name="Hello">
+                <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+                </Target>
+                
+            </Project>
+            """;
 
-        [Theory]
-        [InlineData(true, true)]
-        [InlineData(false, true)]
-        [InlineData(false, false)]
-        public void SampleAnalyzerIntegrationTest(bool buildInOutOfProcessNode, bool analysisRequested)
-        {
-            string contents = $"""
-                <Project Sdk="Microsoft.NET.Sdk" DefaultTargets="Hello">
-                    
-                    <PropertyGroup>
-                    <OutputType>Exe</OutputType>
-                    <TargetFramework>net8.0</TargetFramework>
-                    <ImplicitUsings>enable</ImplicitUsings>
-                    <Nullable>enable</Nullable>
-                    </PropertyGroup>
-                      
-                    <PropertyGroup Condition="$(Test) == true">
-                    <TestProperty>Test</TestProperty>
-                    </PropertyGroup>
-                     
-                    <ItemGroup>
-                    <ProjectReference Include=".\FooBar-Copy.csproj" />
-                    </ItemGroup>
-                      
-                    <Target Name="Hello">
-                    <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
-                    </Target>
-                    
-                </Project>
-                """;
+        string contents2 = $"""
+            <Project Sdk="Microsoft.NET.Sdk">
+                               
+                <PropertyGroup>
+                <OutputType>Exe</OutputType>
+                <TargetFramework>net8.0</TargetFramework>
+                <ImplicitUsings>enable</ImplicitUsings>
+                <Nullable>enable</Nullable>
+                </PropertyGroup>
+                                 
+                <PropertyGroup Condition="$(Test) == true">
+                <TestProperty>Test</TestProperty>
+                </PropertyGroup>
+                                
+                <ItemGroup>
+                <Reference Include="bin/foo.dll" />
+                </ItemGroup>
+                                
+                <Target Name="Hello">
+                <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
+                </Target>
+                               
+            </Project>
+            """;
+        TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
+        TransientTestFile projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
+        TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
 
-            string contents2 = $"""
-                <Project Sdk="Microsoft.NET.Sdk">
-                                   
-                    <PropertyGroup>
-                    <OutputType>Exe</OutputType>
-                    <TargetFramework>net8.0</TargetFramework>
-                    <ImplicitUsings>enable</ImplicitUsings>
-                    <Nullable>enable</Nullable>
-                    </PropertyGroup>
-                                     
-                    <PropertyGroup Condition="$(Test) == true">
-                    <TestProperty>Test</TestProperty>
-                    </PropertyGroup>
-                                    
-                    <ItemGroup>
-                    <Reference Include="bin/foo.dll" />
-                    </ItemGroup>
-                                    
-                    <Target Name="Hello">
-                    <Message Importance="High" Condition="$(Test2) == true" Text="XYZABC" />
-                    </Target>
-                                   
-                </Project>
-                """;
-            TransientTestFolder workFolder = _env.CreateFolder(createFolder: true);
-            TransientTestFile projectFile = _env.CreateFile(workFolder, "FooBar.csproj", contents);
-            TransientTestFile projectFile2 = _env.CreateFile(workFolder, "FooBar-Copy.csproj", contents2);
+        // var cache = new SimpleProjectRootElementCache();
+        // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);
 
-            // var cache = new SimpleProjectRootElementCache();
-            // ProjectRootElement xml = ProjectRootElement.OpenProjectOrSolution(projectFile.Path, /*unused*/null, /*unused*/null, cache, false /*Not explicitly loaded - unused*/);
 
-            TransientTestFile config = _env.CreateFile(workFolder, "editorconfig.json",
-                /*lang=json,strict*/
-                """
-                {
-                    "BC0101": {
-                        "IsEnabled": true,
-                        "Severity": "Error"
-                    },
-                    "COND0543": {
-                        "IsEnabled": false,
-                        "Severity": "Error",
-                        "EvaluationAnalysisScope": "AnalyzedProjectOnly",
-                        "CustomSwitch": "QWERTY"
-                    },
-                    "BLA": {
-                        "IsEnabled": false
-                    }
+        TransientTestFile config = _env.CreateFile(workFolder, "editorconfig.json",
+            /*lang=json,strict*/
+            """
+            {
+                "BC0101": {
+                    "IsEnabled": true,
+                    "Severity": "Error"
+                },
+                "COND0543": {
+                    "IsEnabled": false,
+                    "Severity": "Error",
+                    "EvaluationAnalysisScope": "AnalyzedProjectOnly",
+                    "CustomSwitch": "QWERTY"
+                },
+                "BLA": {
+                    "IsEnabled": false
                 }
-                """);
+            }
+            """);
 
-            // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
-            // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
-            // See if there is a way of fixing it in the engine - tracked: https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=55702688.
-            _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
+        // OSX links /var into /private, which makes Path.GetTempPath() return "/var..." but Directory.GetCurrentDirectory return "/private/var...".
+        // This discrepancy breaks path equality checks in analyzers if we pass to MSBuild full path to the initial project.
+        // See if there is a way of fixing it in the engine - tracked: https://github.com/orgs/dotnet/projects/373/views/1?pane=issue&itemId=55702688.
+        _env.SetCurrentDirectory(Path.GetDirectoryName(projectFile.Path));
 
-            _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", buildInOutOfProcessNode ? "1" : "0");
-            _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
-            string output = RunnerUtilities.ExecBootstrapedMSBuild(
-                $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
-                (analysisRequested ? " -analyze" : string.Empty), out bool success);
-            _env.Output.WriteLine(output);
-            success.ShouldBeTrue();
-            // The conflicting outputs warning appears - but only if analysis was requested
-            if (analysisRequested)
-            {
-                output.ShouldContain("BC0101");
-            }
-            else
-            {
-                output.ShouldNotContain("BC0101");
-            }
+        _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", buildInOutOfProcessNode ? "1" : "0");
+        _env.SetEnvironmentVariable("MSBUILDLOGPROPERTIESANDITEMSAFTEREVALUATION", "1");
+        string output = RunnerUtilities.ExecBootstrapedMSBuild(
+            $"{Path.GetFileName(projectFile.Path)} /m:1 -nr:False -restore" +
+            (analysisRequested ? " -analyze" : string.Empty), out bool success);
+        _env.Output.WriteLine(output);
+        success.ShouldBeTrue();
+        // The conflicting outputs warning appears - but only if analysis was requested
+        if (analysisRequested)
+        {
+            output.ShouldContain("BC0101");
+        }
+        else
+        {
+            output.ShouldNotContain("BC0101");
         }
     }
 }
diff --git a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
index a2e65562ae1..3aa9eaff7d1 100644
--- a/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
+++ b/src/BuildCheck.UnitTests/Microsoft.Build.BuildCheck.UnitTests.csproj
@@ -1,5 +1,4 @@
 <Project Sdk="Microsoft.NET.Sdk">
-
   <PropertyGroup>
     <!-- Don't build a netfx version of this unit with dotnet, as the netfx bootstrap layout created with 'dotnet build' is incomplete. -->
     <TargetFrameworks>$(LatestDotNetCoreForMSBuild)</TargetFrameworks>
diff --git a/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
new file mode 100644
index 00000000000..05d1266d2ac
--- /dev/null
+++ b/src/BuildCheck.UnitTests/ParsedItemsAnalysisDataTests.cs
@@ -0,0 +1,46 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using System.Xml;
+using Microsoft.Build.Construction;
+using Microsoft.Build.Experimental.BuildCheck;
+using Microsoft.Build.UnitTests;
+using Xunit;
+
+namespace Microsoft.Build.BuildCheck.UnitTests;
+
+public class ParsedItemsAnalysisDataTests
+{
+    [Fact]
+    public void ItemsHolder_GetItemsOfType_ShouldFilterProperly()
+    {
+        ProjectRootElement root = ProjectRootElement.Create();
+
+        ProjectItemElement el1 = ProjectItemElement.CreateDisconnected("ItemB", root);
+        ProjectItemElement el2 = ProjectItemElement.CreateDisconnected("ItemB", root);
+        ProjectItemElement el3 = ProjectItemElement.CreateDisconnected("ItemA", root);
+        ProjectItemElement el4 = ProjectItemElement.CreateDisconnected("ItemB", root);
+        ProjectItemElement el5 = ProjectItemElement.CreateDisconnected("ItemA", root);
+
+        var items = new List<ProjectItemElement>()
+        {
+            el1,
+            el2,
+            el3,
+            el4,
+            el5
+        };
+        var itemsHolder = new ItemsHolder(items, new List<ProjectItemGroupElement>());
+
+        var itemsA = itemsHolder.GetItemsOfType("ItemA").ToList();
+        var itemsB = itemsHolder.GetItemsOfType("ItemB").ToList();
+
+        itemsA.ShouldBeSameIgnoringOrder(new List<ProjectItemElement>() { el3, el5 });
+        itemsB.ShouldBeSameIgnoringOrder(new List<ProjectItemElement>() { el1, el2, el4 });
+    }
+}
