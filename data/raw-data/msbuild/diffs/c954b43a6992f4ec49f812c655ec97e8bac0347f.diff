diff --git a/documentation/Home.md b/documentation/Home.md
deleted file mode 100644
index b7cf33e3e8b..00000000000
--- a/documentation/Home.md
+++ /dev/null
@@ -1,24 +0,0 @@
-# Getting Started
-
- * [What is MSBuild?](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild)
- * Building Testing and Debugging
-   * [Full Framework MSBuild](wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md)
-   * [.Net Core MSBuild](wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md)
-   * [Mono MSBuild](wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md)
-
-# Resources
- * [MSBuild Resources](wiki/MSBuild-Resources.md)
- * [Contributed documentation](Contributions/README.md)
- * [MSBuild Tips & Tricks](wiki/MSBuild-Tips-&-Tricks.md)
- * [Binary log](wiki/Binary-Log.md)
- * [Providing Binary Logs for investigation](wiki/Providing-Binary-Logs.md)
- * [Contributing Code](wiki/Contributing-Code.md)
- * [Target Maps](wiki/Target-Maps.md)
- * Tasks
-   * [ResolveAssemblyReference](wiki/ResolveAssemblyReference.md)
- * Problems?
-   * [Rebuilding when nothing changed](wiki/Rebuilding-when-nothing-changed.md)
-   * [Something's wrong in my build](wiki/Something's-wrong-in-my-build.md)
-   * [Microsoft.Build.Framework](wiki/Microsoft.Build.Framework.md)
-     *  Some gotchas around the Microsoft.Build.Framework project/assembly.
-
diff --git a/documentation/README.md b/documentation/README.md
new file mode 100644
index 00000000000..99fec003daf
--- /dev/null
+++ b/documentation/README.md
@@ -0,0 +1,86 @@
+Welcome to MSBuild docs!
+
+The folder contains collection of docs and references for MSBuild, detailed information on how to work with this repo, and covers in-depth technical topics related to implementation.
+
+## Getting Started
+
+* [What is MSBuild?](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild)
+* Building Testing and Debugging
+  * [Full Framework MSBuild](wiki/Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md)
+  * [.Net Core MSBuild](wiki/Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md)
+  * [macOS](wiki/Mac-Debugging.md)
+
+* [MSBuild resources](wiki/MSBuild-Resources.md)
+* [MSBuild tips & tricks](wiki/MSBuild-Tips-&-Tricks.md)
+
+## NuGet packages
+
+* [General information](consuming-nuget-package.md)
+
+## Release information
+
+* [Changelog](Changelog.md)
+* [Release process](release.md)
+* [Change waves](wiki/ChangeWaves.md)
+* [Interactions with the internal repository](wiki/Interactions-with-the-internal-repository.md)
+
+## Development and contributing
+
+* [Providing binary logs for investigation](wiki/Providing-Binary-Logs.md)
+* [Contributing code](wiki/Contributing-Code.md)
+   * [Contributing tasks](wiki/Contributing-Tasks.md)
+* [Error codes](assigning-msb-error-code.md)
+* [Deploying built MSBuild](Deploy-MSBuild.md)
+* [Events emitted by MSBuild](specs/event-source.md)
+* [Change waves (for developers)](wiki/ChangeWaves-Dev.md)
+* [GitHub labels](wiki/Labels.md)
+* [Localization](wiki/Localization.md)
+
+### Problems?
+
+* [Rebuilding when nothing changed](wiki/Rebuilding-when-nothing-changed.md)
+* [Something's wrong in my build](wiki/Something's-wrong-in-my-build.md)
+* [Some gotchas around the Microsoft.Build.Framework project/assembly](wiki/Microsoft.Build.Framework.md)
+* [GAC and MSBuild](wiki/UnGAC.md)
+* [When globbing returns original filespec](WhenGlobbingReturnsOriginalFilespec.md)
+
+## In-depth tech topics
+
+* [Reserved and built-in properties](Built-in-Propeties.md)
+* [`ProjectReference`](ProjectReference-Protocol.md)
+* [MSBuild Server](MSBuild-Server.md)
+* [Low priority nodes](specs/low-priority-switch.md)
+* [Project cache plugin](specs/project-cache.md)
+* [Support for remote host objects](specs/remote-host-object.md)
+* [Static graph](specs/static-graph.md)
+* [Single project isolated builds: implementation details](specs/single-project-isolated-builds.md)
+* [Task isolation](specs/task-isolation-and-dependencies.md)
+* [Threading in MSBuild worker nodes](specs/threading.md)
+* [Target maps](wiki/Target-Maps.md)
+* [Managing parallelism in MSBuild](specs/resource-management.md)
+* [SDK resolution](specs/sdk-resolvers-algorithm.md)
+
+### Tasks
+
+* [`ResolveAssemblyReference`](wiki/ResolveAssemblyReference.md)
+
+### Evaluation
+
+* [Evaluation profiling](evaluation-profiling.md)
+
+### Logging
+
+* [Binary log](wiki/Binary-Log.md)
+* [Live logger: how to opt in](livelogger/Opt-In-Mechanism.md)
+
+## Designs
+
+* [Resolve Assembly Reference as a service](design/rar-as-service.md)
+   * Prototype: https://github.com/dotnet/msbuild/issues/6193
+
+## Community contributions
+
+* [MSBuild overview](Contributions/MSBuild-overview.md)
+* [Solution parser](Contributions/solution-parser.md)
+
+Note: community contributions has documentation that was contributed by developers or users, but it might not been fully vetted for accuracy and correctness. Explanations in this folder may not be fully accurate, but can still be very informative for developing an understanding of MSBuild or a specific problem.
\ No newline at end of file
diff --git a/documentation/WhenGlobbingReturnsOriginalFilespec.md b/documentation/WhenGlobbingReturnsOriginalFilespec.md
index ac9a74c887f..d824eeeddcc 100644
--- a/documentation/WhenGlobbingReturnsOriginalFilespec.md
+++ b/documentation/WhenGlobbingReturnsOriginalFilespec.md
@@ -1,3 +1,5 @@
+# When globbing returns original filespec
+
 Original itemspec is returned when:
 - illegal filespec contains
 	- both wildcards and escaped wildcards (`%2a`, `%3f`)
diff --git a/documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md b/documentation/deprecated/Building-Testing-and-Debugging-on-Mono-MSBuild.md
similarity index 100%
rename from documentation/wiki/Building-Testing-and-Debugging-on-Mono-MSBuild.md
rename to documentation/deprecated/Building-Testing-and-Debugging-on-Mono-MSBuild.md
diff --git a/documentation/specs/rar-as-service.md b/documentation/design/rar-as-service.md
similarity index 100%
rename from documentation/specs/rar-as-service.md
rename to documentation/design/rar-as-service.md
diff --git a/documentation/specs/sdk-resolvers-algorithm.md b/documentation/specs/sdk-resolvers-algorithm.md
index eb962ad2644..e5cd05a0dd3 100644
--- a/documentation/specs/sdk-resolvers-algorithm.md
+++ b/documentation/specs/sdk-resolvers-algorithm.md
@@ -25,4 +25,35 @@ Note, that the manifest file, if exists, from ChangeWave 17.4 would have prefere
 The sdk discovery works according to the following algorithm:
 - First try locate the manifest file and use it. 
 - If it is not found, we try to locate the dll in the resolver's folder. 
-Both xml and dll name should match the following name pattern `...\SdkResolvers\(ResolverName)\(ResolverName).(xml/dll)`.
\ No newline at end of file
+Both xml and dll name should match the following name pattern `...\SdkResolvers\(ResolverName)\(ResolverName).(xml/dll)`.
+
+### Failed SDK Resolution
+
+> 🚧 Note
+>
+> This page is a work in progress.
+
+SDK resolvers previously attempted to continue when one critically fails (throws an unhandled exception). This lead to misleading error messages such as:
+
+```
+warning MSB4242: The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed to run. 's' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8.
+error MSB4236: The SDK 'Microsoft.NET.SDK.WorkloadAutoImportPropsLocator' specified could not be found. [C:\foo\bar.csproj]
+```
+
+`MSB4236` is a red herring while `MSB4242` is the real error despite being logged as a warning. Because of this, SDK resolvers now fail the build _immediately_ upon unhandled exceptions. These exceptions are propogated as `SdkResolverException`s, and `MSB4242` has been promoted to an error code. The new error message appears like so:
+
+```
+C:\src\temp\8-18>"C:\foo\dotnet-sdk-6.0.100-preview.7.21379.14-win-x64\dotnet.exe" build    
+Microsoft (R) Build Engine version 17.0.0-dev-21420-01+5df152759 for .NET
+Copyright (C) Microsoft Corporation. All rights reserved.
+
+C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed while attempting to resolve the SDK "Microsoft.NET.Sdk". Exception: "'s' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8."".
+
+Build FAILED.
+
+C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed while attempting to resolve the SDK "Microsoft.NET.Sdk". Exception: "'s' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8."".
+    0 Warning(s)
+    1 Error(s)
+
+Time Elapsed 00:00:00.15
+```
\ No newline at end of file
diff --git a/documentation/specs/sdk-resolvers.md b/documentation/specs/sdk-resolvers.md
deleted file mode 100644
index ddb73668e2b..00000000000
--- a/documentation/specs/sdk-resolvers.md
+++ /dev/null
@@ -1,29 +0,0 @@
-> 🚧 Note
->
-> This page is a work in progress.
-
-### Failed SDK Resolution
-SDK resolvers previously attempted to continue when one critically fails (throws an unhandled exception). This lead to misleading error messages such as:
-
-```
-warning MSB4242: The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed to run. 's' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8.
-error MSB4236: The SDK 'Microsoft.NET.SDK.WorkloadAutoImportPropsLocator' specified could not be found. [C:\foo\bar.csproj]
-```
-
-`MSB4236` is a red herring while `MSB4242` is the real error despite being logged as a warning. Because of this, SDK resolvers now fail the build _immediately_ upon unhandled exceptions. These exceptions are propogated as `SdkResolverException`s, and `MSB4242` has been promoted to an error code. The new error message appears like so:
-
-```
-C:\src\temp\8-18>"C:\foo\dotnet-sdk-6.0.100-preview.7.21379.14-win-x64\dotnet.exe" build    
-Microsoft (R) Build Engine version 17.0.0-dev-21420-01+5df152759 for .NET
-Copyright (C) Microsoft Corporation. All rights reserved.
-
-C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed while attempting to resolve the SDK "Microsoft.NET.Sdk". Exception: "'s' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8."".
-
-Build FAILED.
-
-C:\foo\bar.csproj : error MSB4242: SDK Resolver Failure: "The SDK resolver "Microsoft.DotNet.MSBuildWorkloadSdkResolver" failed while attempting to resolve the SDK "Microsoft.NET.Sdk". Exception: "'s' is an invalid start of a property name. Expected a '"'. LineNumber: 14 | BytePositionInLine: 8."".
-    0 Warning(s)
-    1 Error(s)
-
-Time Elapsed 00:00:00.15
-```
\ No newline at end of file
diff --git a/documentation/specs/static-graph-implementation-details.md b/documentation/specs/single-project-isolated-builds.md
similarity index 100%
rename from documentation/specs/static-graph-implementation-details.md
rename to documentation/specs/single-project-isolated-builds.md
diff --git a/documentation/wiki/Interactions-with-the-internal-repository.md b/documentation/wiki/Interactions-with-the-internal-repository.md
index a6b0b414114..916ac2bd78d 100644
--- a/documentation/wiki/Interactions-with-the-internal-repository.md
+++ b/documentation/wiki/Interactions-with-the-internal-repository.md
@@ -1,3 +1,5 @@
+# Interactions with the internal repository
+
 MSbuild got forked from an internal Microsoft repository. Although the Github repository is the official one, where development takes place, there are still some left-over connections to the internal one. This page attempts to document these.
 
 Changes to these files need to be migrated back into the internal repo because that's where they are localized:
diff --git a/documentation/wiki/Mac-Debugging.md b/documentation/wiki/Mac-Debugging.md
index e6458e6f978..fedab4908d6 100644
--- a/documentation/wiki/Mac-Debugging.md
+++ b/documentation/wiki/Mac-Debugging.md
@@ -1,6 +1,6 @@
-#Debugging with MacOS
+# Debugging with MacOS
 * Open terminal 
-  * Hit command-space, type terminal, hit enter. Alternatively, hit magnifying glass (spotlight) in upper-right corner and search for terminal.)
+  * Hit command-space, type terminal, hit enter. Alternatively, hit magnifying glass (spotlight) in upper-right corner and search for terminal.
 * Build and run tests
   * Navigation in terminal is similar to command prompt (cd), although you type `ls` in place of `dir`.
   * **Use `./build.sh -test` instead of `.\build.cmd -test`.**
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 841a48e4e64..d07f8cc81fc 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -1277,6 +1277,114 @@ public void GetTargetsListProjectReferenceTargetsOrDefaultComplexPropagation()
             }
         }
 
+        [Fact]
+        public void GetTargetsListSupportsTargetsMarkedSkipNonexistentTargets()
+        {
+            ProjectGraph graph = Helpers.CreateProjectGraph(
+                _env,
+                dependencyEdges: new Dictionary<int, int[]>
+                {
+                    { 1, new[] { 2 } },
+                },
+                extraContentPerProjectNumber: new Dictionary<int, string>
+                {
+                    {
+                        1,
+                        @"
+                          <ItemGroup>
+                            <ProjectReferenceTargets Include='Build' Targets='NonskippableTarget1' />
+                            <ProjectReferenceTargets Include='Build' Targets='NonskippableTarget2' SkipNonexistentTargets='false' />
+                            <ProjectReferenceTargets Include='Build' Targets='SkippableExistingTarget;SkippableNonexistentTarget' SkipNonexistentTargets='true' />
+                            <ProjectReference Include='2.proj' />
+                          </ItemGroup>
+                          <Target Name='Build'>
+                            <MSBuild Projects='2.proj' Targets='NonskippableTarget1; NonskippableTarget2' />
+                            <MSBuild Projects='2.proj' Targets='SkippableExistingTarget;SkippableNonexistentTarget' SkipNonexistentTargets='true' />
+                          </Target>"
+                    },
+                    {
+                        2,
+                        @"<Target Name='NonskippableTarget1'>
+                          </Target>
+                          <Target Name='NonskippableTarget2'>
+                          </Target>
+                          <Target Name='SkippableExistingTarget'>
+                          </Target>"
+                    },
+                });
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(entryProjectTargets: new[] { "Build" });
+            targetLists[key: GetFirstNodeWithProjectNumber(graph: graph, projectNum: 1)].ShouldBe(expected: new[] { "Build" });
+            targetLists[key: GetFirstNodeWithProjectNumber(graph: graph, projectNum: 2)].ShouldBe(expected: new[] { "NonskippableTarget1", "NonskippableTarget2", "SkippableExistingTarget" });
+            Dictionary<string, (BuildResult Result, MockLogger Logger)> results = ResultCacheBasedBuilds_Tests.BuildUsingCaches(
+                _env,
+                topoSortedNodes: graph.ProjectNodesTopologicallySorted,
+                generateCacheFiles: true,
+                expectedNodeBuildOutput: new Dictionary<ProjectGraphNode, string[]>(),
+                outputCaches: new Dictionary<ProjectGraphNode, string>(),
+                assertBuildResults: false,
+                targetListsPerNode: targetLists);
+            foreach (KeyValuePair<string, (BuildResult Result, MockLogger Logger)> result in results)
+            {
+                result.Value.Result.OverallResult.ShouldBe(BuildResultCode.Success);
+            }
+        }
+
+        [Fact]
+        public void SkipNonexistentTargetsDoesNotHideMissedTargetResults()
+        {
+            ProjectGraph graph = Helpers.CreateProjectGraph(
+                env: _env,
+                dependencyEdges: new Dictionary<int, int[]>
+                {
+                    { 1, new[] { 2 } },
+                },
+                extraContentPerProjectNumber: new Dictionary<int, string>
+                {
+                    {
+                        1,
+                        @"
+                          <ItemGroup>
+                            <!-- NonskippableTarget2 is not specified in the target protocol, which should cause the build to fail -->
+                            <ProjectReferenceTargets Include='Build' Targets='NonskippableTarget1;SkippableExistingTarget;SkippableNonexistentTarget' SkipNonexistentTargets='true' />
+                            <ProjectReference Include='2.proj' />
+                          </ItemGroup>
+                          <Target Name='Build'>
+                            <MSBuild Projects='2.proj' Targets='NonskippableTarget1;NonskippableTarget2;SkippableExistingTarget;SkippableNonexistentTarget' SkipNonexistentTargets='true' />
+                          </Target>"
+                    },
+                    {
+                        2,
+                        @"<Target Name='NonskippableTarget1'>
+                          </Target>
+                          <Target Name='NonskippableTarget2'>
+                          </Target>
+                          <Target Name='SkippableExistingTarget'>
+                          </Target>"
+                    },
+                });
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetLists = graph.GetTargetLists(entryProjectTargets: new[] { "Build" });
+            targetLists[key: GetFirstNodeWithProjectNumber(graph: graph, projectNum: 1)].ShouldBe(expected: new[] { "Build" });
+            targetLists[key: GetFirstNodeWithProjectNumber(graph: graph, projectNum: 2)].ShouldBe(expected: new[] { "NonskippableTarget1", "SkippableExistingTarget" });
+            Dictionary<string, (BuildResult Result, MockLogger Logger)> results = ResultCacheBasedBuilds_Tests.BuildUsingCaches(
+                env: _env,
+                topoSortedNodes: graph.ProjectNodesTopologicallySorted,
+                generateCacheFiles: true,
+                expectedNodeBuildOutput: new Dictionary<ProjectGraphNode, string[]>(),
+                outputCaches: new Dictionary<ProjectGraphNode, string>(),
+                assertBuildResults: false,
+                targetListsPerNode: targetLists);
+            results["2"].Result.OverallResult.ShouldBe(BuildResultCode.Success);
+            BuildResult project1BuildResult = results["1"].Result;
+            project1BuildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
+            MockLogger project1MockLogger = results["1"].Logger;
+            project1MockLogger.ErrorCount.ShouldBe(1);
+            string project1ErrorMessage = project1MockLogger.Errors.First().Message;
+            project1ErrorMessage.ShouldContain("MSB4252");
+            project1ErrorMessage.ShouldContain("1.proj");
+            project1ErrorMessage.ShouldContain("2.proj");
+            project1ErrorMessage.ShouldContain(" with the (NonskippableTarget1;NonskippableTarget2;SkippableExistingTarget;SkippableNonexistentTarget) target(s) but the build result for the built project is not in the engine cache");
+        }
+
         [Fact]
         public void ReferencedMultitargetingEntryPointNodeTargetListContainsDefaultTarget()
         {
diff --git a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
index 4e3337867ab..65ab4706791 100644
--- a/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
+++ b/src/Build.UnitTests/Graph/ResultCacheBasedBuilds_Tests.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Collections.Immutable;
 using System.IO;
 using System.Linq;
 using System.Text;
@@ -416,6 +417,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
         /// <param name="generateCacheFiles"></param>
         /// <param name="assertBuildResults"></param>
         /// <param name="expectedOutputProducer"></param>
+        /// <param name="targetListsPerNode">The list of targets to build per node.</param>
         /// <param name="projectIsolationMode">The isolation mode under which to run.</param>
         /// <returns></returns>
         internal static Dictionary<string, (BuildResult Result, MockLogger Logger)> BuildUsingCaches(
@@ -427,6 +429,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
             bool assertBuildResults = true,
             // (current node, expected output dictionary) -> actual expected output for current node
             Func<ProjectGraphNode, ExpectedNodeBuildOutput, string[]> expectedOutputProducer = null,
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetListsPerNode = null,
             ProjectIsolationMode projectIsolationMode = ProjectIsolationMode.False)
         {
             expectedOutputProducer ??= ((node, expectedOutputs) => expectedOutputs[node]);
@@ -460,7 +463,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
                     buildParameters.OutputResultsCacheFile = outputCaches[node];
                 }
 
-                var logger = new MockLogger();
+                var logger = new MockLogger(env.Output);
 
                 buildParameters.Loggers = new[] { logger };
 
@@ -468,7 +471,7 @@ public void MissingResultFromCacheShouldErrorDueToIsolatedBuildCacheEnforcement(
                     node.ProjectInstance.FullPath,
                     null,
                     buildParameters,
-                    node.ProjectInstance.DefaultTargets);
+                    targetListsPerNode?[node] != null ? targetListsPerNode?[node] : node.ProjectInstance.DefaultTargets);
 
                 results[ProjectNumber(node)] = (result, logger);
 
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index 73ce1de0e23..0c828f621ff 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -1397,7 +1397,7 @@ private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, Bui
                 ((IBuildComponentHost)this).LoggingService,
                 request.BuildEventContext,
                 false /* loaded by solution parser*/,
-                config.TargetNames,
+                config.RequestedTargets,
                 SdkResolverService,
                 request.SubmissionId);
 
@@ -2336,23 +2336,17 @@ private void HandleConfigurationRequest(int node, BuildRequestConfiguration unre
         /// </summary>
         private void HandleResult(int node, BuildResult result)
         {
-            // Update cache with the default and initial targets, as needed.
+            // Update cache with the default, initial, and project targets, as needed.
             BuildRequestConfiguration configuration = _configCache[result.ConfigurationId];
             if (result.DefaultTargets != null)
             {
-                // If the result has Default and Initial targets, we populate the configuration cache with them if it
+                // If the result has Default, Initial, and project targets, we populate the configuration cache with them if it
                 // doesn't already have entries.  This can happen if we created a configuration based on a request from
                 // an external node, but hadn't yet received a result since we may not have loaded the Project locally
-                // and thus wouldn't know what the default and initial targets were.
-                if (configuration.ProjectDefaultTargets == null)
-                {
-                    configuration.ProjectDefaultTargets = result.DefaultTargets;
-                }
-
-                if (configuration.ProjectInitialTargets == null)
-                {
-                    configuration.ProjectInitialTargets = result.InitialTargets;
-                }
+                // and thus wouldn't know what the default, initial, and project targets were.
+                configuration.ProjectDefaultTargets ??= result.DefaultTargets;
+                configuration.ProjectInitialTargets ??= result.InitialTargets;
+                configuration.ProjectTargets ??= result.ProjectTargets;
             }
 
             IEnumerable<ScheduleResponse> response = _scheduler.ReportResult(node, result);
diff --git a/src/Build/BackEnd/BuildManager/CacheSerialization.cs b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
index fa61c34aa64..3fa59bfe28b 100644
--- a/src/Build/BackEnd/BuildManager/CacheSerialization.cs
+++ b/src/Build/BackEnd/BuildManager/CacheSerialization.cs
@@ -97,7 +97,7 @@ public static string SerializeCaches(
                         // due to its dependency on a cached target whose side effects would
                         // not be taken into account. (E.g., the definition of a property.)
                         resultsCacheToSerialize.GetResultsForConfiguration(smallestConfigId)
-                            .KeepSpecificTargetResults(configCacheToSerialize[smallestConfigId].TargetNames);
+                            .KeepSpecificTargetResults(configCacheToSerialize[smallestConfigId].RequestedTargets);
                     }
 
                     translator.Translate(ref configCacheToSerialize);
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 99fff072659..250d4b4c8bf 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -809,6 +809,7 @@ private void EvaluateRequestStates()
                     // own cache.
                     completedEntry.Result.DefaultTargets = configuration.ProjectDefaultTargets;
                     completedEntry.Result.InitialTargets = configuration.ProjectInitialTargets;
+                    completedEntry.Result.ProjectTargets = configuration.ProjectTargets;
                 }
 
                 TraceEngine("ERS: Request is now {0}({1}) (nr {2}) has had its builder cleaned up.", completedEntry.Request.GlobalRequestId, completedEntry.Request.ConfigurationId, completedEntry.Request.NodeRequestId);
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 41a142a83fd..0c11f731cb5 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -1963,7 +1963,8 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF
             var configCache = (IConfigCache)_componentHost.GetComponent(BuildComponentType.ConfigCache);
 
             // do not check root requests as nothing depends on them
-            if (isolateProjects == ProjectIsolationMode.False || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints)
+            if (isolateProjects == ProjectIsolationMode.False || request.IsRootRequest || request.SkipStaticGraphIsolationConstraints
+                || SkipNonexistentTargetsIfExistentTargetsHaveResults(request))
             {
                 bool logComment = ((isolateProjects == ProjectIsolationMode.True || isolateProjects == ProjectIsolationMode.MessageUponIsolationViolation) && request.SkipStaticGraphIsolationConstraints);
                 if (logComment)
@@ -1975,14 +1976,14 @@ private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeF
                             NewBuildEventContext(),
                             MessageImportance.Normal,
                             "SkippedConstraintsOnRequest",
-                            configs.parentConfig.ProjectFullPath,
-                            configs.requestConfig.ProjectFullPath);
+                            configs.ParentConfig.ProjectFullPath,
+                            configs.RequestConfig.ProjectFullPath);
                 }
 
                 return true;
             }
 
-            var (requestConfig, parentConfig) = GetConfigurations();
+            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) = GetConfigurations();
 
             // allow self references (project calling the msbuild task on itself, potentially with different global properties)
             if (parentConfig.ProjectFullPath.Equals(requestConfig.ProjectFullPath, StringComparison.OrdinalIgnoreCase))
@@ -2021,20 +2022,20 @@ BuildEventContext NewBuildEventContext()
                     BuildEventContext.InvalidTaskId);
             }
 
-            (BuildRequestConfiguration requestConfig, BuildRequestConfiguration parentConfig) GetConfigurations()
+            (BuildRequestConfiguration RequestConfig, BuildRequestConfiguration ParentConfig) GetConfigurations()
             {
-                var buildRequestConfiguration = configCache[request.ConfigurationId];
+                BuildRequestConfiguration buildRequestConfiguration = configCache[request.ConfigurationId];
 
                 // Need the parent request. It might be blocked or executing; check both.
-                var parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId)
-                                    ?? _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);
+                SchedulableRequest parentRequest = _schedulingData.BlockedRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId)
+                    ?? _schedulingData.ExecutingRequests.FirstOrDefault(r => r.BuildRequest.GlobalRequestId == request.ParentGlobalRequestId);
 
                 ErrorUtilities.VerifyThrowInternalNull(parentRequest, nameof(parentRequest));
                 ErrorUtilities.VerifyThrow(
                     configCache.HasConfiguration(parentRequest.BuildRequest.ConfigurationId),
                     "All non root requests should have a parent with a loaded configuration");
 
-                var parentConfiguration = configCache[parentRequest.BuildRequest.ConfigurationId];
+                BuildRequestConfiguration parentConfiguration = configCache[parentRequest.BuildRequest.ConfigurationId];
                 return (buildRequestConfiguration, parentConfiguration);
             }
 
@@ -2042,6 +2043,40 @@ string ConcatenateGlobalProperties(BuildRequestConfiguration configuration)
             {
                 return string.Join("; ", configuration.GlobalProperties.Select<ProjectPropertyInstance, string>(p => $"{p.Name}={p.EvaluatedValue}"));
             }
+
+            bool SkipNonexistentTargetsIfExistentTargetsHaveResults(BuildRequest buildRequest)
+            {
+                // Return early if the top-level target(s) of this build request weren't requested to be skipped if nonexistent.
+                if ((buildRequest.BuildRequestDataFlags & BuildRequestDataFlags.SkipNonexistentTargets) != BuildRequestDataFlags.SkipNonexistentTargets)
+                {
+                    return false;
+                }
+
+                BuildResult requestResults = _resultsCache.GetResultsForConfiguration(buildRequest.ConfigurationId);
+
+                // On a self-referenced build, cache misses are allowed.
+                if (requestResults == null)
+                {
+                    return false;
+                }
+
+                // A cache miss on at least one existing target without results is disallowed,
+                // as it violates isolation constraints.
+                foreach (string target in request.Targets)
+                {
+                    if (_configCache[buildRequest.ConfigurationId]
+                        .ProjectTargets
+                        .Contains(target) &&
+                        !requestResults.HasResultsForTarget(target))
+                    {
+                        return false;
+                    }
+                }
+
+                // A cache miss on nonexistent targets on the reference is allowed, given the request
+                // to skip nonexistent targets.
+                return true;
+            }
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index b1616f43858..b720431fc5e 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -107,6 +107,11 @@ internal class BuildRequestConfiguration : IEquatable<BuildRequestConfiguration>
         /// </summary>
         private List<string> _projectDefaultTargets;
 
+        /// <summary>
+        /// The defined targets for the project.
+        /// </summary>
+        private HashSet<string> _projectTargets;
+
         /// <summary>
         /// This is the lookup representing the current project items and properties 'state'.
         /// </summary>
@@ -138,7 +143,7 @@ internal class BuildRequestConfiguration : IEquatable<BuildRequestConfiguration>
         /// <summary>
         /// The target names that were requested to execute.
         /// </summary>
-        internal IReadOnlyCollection<string> TargetNames { get; }
+        internal IReadOnlyCollection<string> RequestedTargets { get; }
 
         /// <summary>
         /// Initializes a configuration from a BuildRequestData structure.  Used by the BuildManager.
@@ -170,7 +175,7 @@ internal BuildRequestConfiguration(int configId, BuildRequestData data, string d
             _explicitToolsVersionSpecified = data.ExplicitToolsVersionSpecified;
             _toolsVersion = ResolveToolsVersion(data, defaultToolsVersion);
             _globalProperties = data.GlobalPropertiesDictionary;
-            TargetNames = new List<string>(data.TargetNames);
+            RequestedTargets = new List<string>(data.TargetNames);
 
             // The following information only exists when the request is populated with an existing project.
             if (data.ProjectInstance != null)
@@ -178,7 +183,7 @@ internal BuildRequestConfiguration(int configId, BuildRequestData data, string d
                 _project = data.ProjectInstance;
                 _projectInitialTargets = data.ProjectInstance.InitialTargets;
                 _projectDefaultTargets = data.ProjectInstance.DefaultTargets;
-
+                _projectTargets = GetProjectTargets(data.ProjectInstance.Targets);
                 if (data.PropertiesToTransfer != null)
                 {
                     _transferredProperties = new List<ProjectPropertyInstance>();
@@ -215,6 +220,7 @@ internal BuildRequestConfiguration(int configId, ProjectInstance instance)
             _project = instance;
             _projectInitialTargets = instance.InitialTargets;
             _projectDefaultTargets = instance.DefaultTargets;
+            _projectTargets = GetProjectTargets(instance.Targets);
             IsCacheable = false;
         }
 
@@ -231,13 +237,14 @@ private BuildRequestConfiguration(int configId, BuildRequestConfiguration other)
             _transferredProperties = other._transferredProperties;
             _projectDefaultTargets = other._projectDefaultTargets;
             _projectInitialTargets = other._projectInitialTargets;
+            _projectTargets = other._projectTargets;
             _projectFullPath = other._projectFullPath;
             _toolsVersion = other._toolsVersion;
             _explicitToolsVersionSpecified = other._explicitToolsVersionSpecified;
             _globalProperties = other._globalProperties;
             IsCacheable = other.IsCacheable;
             _configId = configId;
-            TargetNames = other.TargetNames;
+            RequestedTargets = other.RequestedTargets;
         }
 
         /// <summary>
@@ -404,9 +411,11 @@ private void SetProjectBasedState(ProjectInstance project)
             // Clear these out so the other accessors don't complain.  We don't want to generally enable resetting these fields.
             _projectDefaultTargets = null;
             _projectInitialTargets = null;
+            _projectTargets = null;
 
             ProjectDefaultTargets = _project.DefaultTargets;
             ProjectInitialTargets = _project.InitialTargets;
+            ProjectTargets = GetProjectTargets(_project.Targets);
 
             if (IsCached)
             {
@@ -548,6 +557,23 @@ public List<string> ProjectDefaultTargets
             }
         }
 
+        /// <summary>
+        /// Gets or sets the targets defined for the project.
+        /// </summary>
+        internal HashSet<string> ProjectTargets
+        {
+            [DebuggerStepThrough]
+            get => _projectTargets;
+            [DebuggerStepThrough]
+            set
+            {
+                ErrorUtilities.VerifyThrow(
+                    _projectTargets == null,
+                    "Targets cannot be reset once set.");
+                _projectTargets = value;
+            }
+        }
+
         /// <summary>
         /// Returns the node packet type
         /// </summary>
@@ -879,6 +905,7 @@ internal void TranslateForFutureUse(ITranslator translator)
             translator.Translate(ref _explicitToolsVersionSpecified);
             translator.Translate(ref _projectDefaultTargets);
             translator.Translate(ref _projectInitialTargets);
+            translator.Translate(ref _projectTargets);
             translator.TranslateDictionary(ref _globalProperties, ProjectPropertyInstance.FactoryForDeserialization);
         }
 
@@ -961,6 +988,13 @@ private bool InternalEquals(BuildRequestConfiguration other)
             }
         }
 
+        /// <summary>
+        /// Gets the set of project targets for this <see cref="BuildRequestConfiguration"/>.
+        /// </summary>
+        /// <param name="projectTargets">The project targets to transform into a set.</param>
+        /// <returns>The set of project targets for this <see cref="BuildRequestConfiguration"/>.</returns>
+        private HashSet<string> GetProjectTargets(IDictionary<string, ProjectTargetInstance> projectTargets) => projectTargets.Keys.ToHashSet();
+
         /// <summary>
         /// Determines what the real tools version is.
         /// </summary>
diff --git a/src/Build/BackEnd/Shared/BuildResult.cs b/src/Build/BackEnd/Shared/BuildResult.cs
index 7d4e073cb97..ca443451880 100644
--- a/src/Build/BackEnd/Shared/BuildResult.cs
+++ b/src/Build/BackEnd/Shared/BuildResult.cs
@@ -118,6 +118,8 @@ public class BuildResult : INodePacket, IBuildResults
 
         private string _schedulerInducedError;
 
+        private HashSet<string> _projectTargets;
+
         /// <summary>
         /// Constructor for serialization.
         /// </summary>
@@ -229,6 +231,7 @@ internal BuildResult(BuildResult result, int nodeRequestId)
             _circularDependency = result._circularDependency;
             _initialTargets = result._initialTargets;
             _defaultTargets = result._defaultTargets;
+            _projectTargets = result._projectTargets;
             _baseOverallResult = result.OverallResult == BuildResultCode.Success;
         }
 
@@ -245,6 +248,7 @@ internal BuildResult(BuildResult result, int submissionId, int configurationId,
             _circularDependency = result._circularDependency;
             _initialTargets = result._initialTargets;
             _defaultTargets = result._defaultTargets;
+            _projectTargets = result._projectTargets;
             _baseOverallResult = result.OverallResult == BuildResultCode.Success;
         }
 
@@ -434,6 +438,17 @@ internal List<string> DefaultTargets
             { _defaultTargets = value; }
         }
 
+        /// <summary>
+        /// The defined targets for the project associated with this build result.
+        /// </summary>
+        internal HashSet<string> ProjectTargets
+        {
+            [DebuggerStepThrough]
+            get => _projectTargets;
+            [DebuggerStepThrough]
+            set => _projectTargets = value;
+        }
+
         /// <summary>
         /// Container used to transport errors from the scheduler (issued while computing a build result)
         /// to the TaskHost that has the proper logging context (project id, target id, task id, file location)
@@ -557,6 +572,7 @@ void ITranslatable.Translate(ITranslator translator)
             translator.Translate(ref _nodeRequestId);
             translator.Translate(ref _initialTargets);
             translator.Translate(ref _defaultTargets);
+            translator.Translate(ref _projectTargets);
             translator.Translate(ref _circularDependency);
             translator.TranslateException(ref _requestException);
             translator.TranslateDictionary(ref _resultsByTarget, TargetResult.FactoryForDeserialization, CreateTargetResultDictionary);
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index 35b57e90b01..fa1642fb36b 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -63,6 +63,25 @@ public ReferenceInfo(ConfigurationMetadata referenceConfiguration, ProjectItemIn
             }
         }
 
+        private readonly struct TargetSpecification
+        {
+            public TargetSpecification(string target, bool skipIfNonexistent)
+            {
+                // Verify that if this target is skippable then it equals neither 
+                // ".default" nor ".projectReferenceTargetsOrDefaultTargets".
+                ErrorUtilities.VerifyThrow(
+                    !skipIfNonexistent || (!target.Equals(MSBuildConstants.DefaultTargetsMarker)
+                    && !target.Equals(MSBuildConstants.ProjectReferenceTargetsOrDefaultTargetsMarker)),
+                    target + " cannot be marked as SkipNonexistentTargets");
+                Target = target;
+                SkipIfNonexistent = skipIfNonexistent;
+            }
+
+            public string Target { get; }
+
+            public bool SkipIfNonexistent { get; }
+        }
+
         public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection _projectCollection, ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory)
         {
             IEnumerable<ProjectItemInstance> projectReferenceItems;
@@ -391,10 +410,10 @@ private static void RemoveFromPropertyDictionary(
 
         public readonly struct TargetsToPropagate
         {
-            private readonly ImmutableList<string> _outerBuildTargets;
-            private readonly ImmutableList<string> _allTargets;
+            private readonly ImmutableList<TargetSpecification> _outerBuildTargets;
+            private readonly ImmutableList<TargetSpecification> _allTargets;
 
-            private TargetsToPropagate(ImmutableList<string> outerBuildTargets, ImmutableList<string> nonOuterBuildTargets)
+            private TargetsToPropagate(ImmutableList<TargetSpecification> outerBuildTargets, ImmutableList<TargetSpecification> nonOuterBuildTargets)
             {
                 _outerBuildTargets = outerBuildTargets;
 
@@ -416,23 +435,22 @@ private TargetsToPropagate(ImmutableList<string> outerBuildTargets, ImmutableLis
             /// <returns></returns>
             public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance project, ImmutableList<string> entryTargets)
             {
-                var targetsForOuterBuild = ImmutableList.CreateBuilder<string>();
-                var targetsForInnerBuild = ImmutableList.CreateBuilder<string>();
+                ImmutableList<TargetSpecification>.Builder targetsForOuterBuild = ImmutableList.CreateBuilder<TargetSpecification>();
+                ImmutableList<TargetSpecification>.Builder targetsForInnerBuild = ImmutableList.CreateBuilder<TargetSpecification>();
 
-                var projectReferenceTargets = project.GetItems(ItemTypeNames.ProjectReferenceTargets);
+                ICollection<ProjectItemInstance> projectReferenceTargets = project.GetItems(ItemTypeNames.ProjectReferenceTargets);
 
-                foreach (var entryTarget in entryTargets)
+                foreach (string entryTarget in entryTargets)
                 {
-                    foreach (var projectReferenceTarget in projectReferenceTargets)
+                    foreach (ProjectItemInstance projectReferenceTarget in projectReferenceTargets)
                     {
                         if (projectReferenceTarget.EvaluatedInclude.Equals(entryTarget, StringComparison.OrdinalIgnoreCase))
                         {
-                            var targetsMetadataValue = projectReferenceTarget.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
-
-                            var targetsAreForOuterBuild = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue(ProjectReferenceTargetIsOuterBuildMetadataName));
-
-                            var targets = ExpressionShredder.SplitSemiColonSeparatedList(targetsMetadataValue).ToArray();
-
+                            string targetsMetadataValue = projectReferenceTarget.GetMetadataValue(ItemMetadataNames.ProjectReferenceTargetsMetadataName);
+                            bool skipNonexistentTargets = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue("SkipNonexistentTargets"));
+                            bool targetsAreForOuterBuild = MSBuildStringIsTrue(projectReferenceTarget.GetMetadataValue(ProjectReferenceTargetIsOuterBuildMetadataName));
+                            TargetSpecification[] targets = ExpressionShredder.SplitSemiColonSeparatedList(targetsMetadataValue)
+                                .Select(t => new TargetSpecification(t, skipNonexistentTargets)).ToArray();
                             if (targetsAreForOuterBuild)
                             {
                                 targetsForOuterBuild.AddRange(targets);
@@ -450,11 +468,20 @@ public static TargetsToPropagate FromProjectAndEntryTargets(ProjectInstance proj
 
             public ImmutableList<string> GetApplicableTargetsForReference(ProjectInstance reference)
             {
-                return (GetProjectType(reference)) switch
+                ImmutableList<string> RemoveNonexistentTargetsIfSkippable(ImmutableList<TargetSpecification> targets)
+                {
+                    // Keep targets that are non-skippable or that exist but are skippable.
+                    return targets
+                        .Where(t => !t.SkipIfNonexistent || reference.Targets.ContainsKey(t.Target))
+                        .Select(t => t.Target)
+                        .ToImmutableList();
+                }
+
+                return GetProjectType(reference) switch
                 {
-                    ProjectType.InnerBuild => _allTargets,
-                    ProjectType.OuterBuild => _outerBuildTargets,
-                    ProjectType.NonMultitargeting => _allTargets,
+                    ProjectType.InnerBuild => RemoveNonexistentTargetsIfSkippable(_allTargets),
+                    ProjectType.OuterBuild => RemoveNonexistentTargetsIfSkippable(_outerBuildTargets),
+                    ProjectType.NonMultitargeting => RemoveNonexistentTargetsIfSkippable(_allTargets),
                     _ => throw new ArgumentOutOfRangeException(),
                 };
             }
diff --git a/src/MSBuild/LiveLogger/ANSIBuilder.cs b/src/MSBuild/LiveLogger/ANSIBuilder.cs
index b34ae90bc33..7ea63b39940 100644
--- a/src/MSBuild/LiveLogger/ANSIBuilder.cs
+++ b/src/MSBuild/LiveLogger/ANSIBuilder.cs
@@ -9,7 +9,7 @@ namespace Microsoft.Build.Logging.LiveLogger
 {
     internal static class ANSIBuilder
     {
-        public static string ANSIRegex = @"\x1b(?:[@-Z\-_]|\[[0-?]*[ -\/]*[@-~])";
+        public static string ANSIRegex = @"\x1b(?:[@-Z\-_]|\[[0-?]*[ -\/]*[@-~]|(?:\]8;;.*?\x1b\\))";
         // TODO: This should replace ANSIRegex once LiveLogger's API is internal
         public static Regex ANSIRegexRegex = new Regex(ANSIRegex);
         public static string ANSIRemove(string text)
@@ -17,6 +17,12 @@ public static string ANSIRemove(string text)
             return ANSIRegexRegex.Replace(text, "");
         }
 
+        /// <summary>
+        /// Find a place to break a string after a number of visible characters, not counting VT-100 codes.
+        /// </summary>
+        /// <param name="text">String to split.</param>
+        /// <param name="position">Number of visible characters to split after.</param>
+        /// <returns>Index in <paramref name="text"/> that represents <paramref name="position"/> visible characters.</returns>
         // TODO: This should be an optional parameter for ANSIBreakpoint(string text, int positioon, int initialPosition = 0)
         public static int ANSIBreakpoint(string text, int position)
         {
@@ -29,34 +35,33 @@ public static int ANSIBreakpoint(string text, int position, int initialPosition)
                 return text.Length;
             }
             int nonAnsiIndex = 0;
-            // Match nextMatch = Regex.Match(text, ANSIRegex);
             Match nextMatch = ANSIRegexRegex.Match(text, initialPosition);
-            int i = 0;
-            while (i < text.Length && nonAnsiIndex != position)
+            int logicalIndex = 0;
+            while (logicalIndex < text.Length && nonAnsiIndex != position)
             {
                 // Jump over ansi codes
-                if (i == nextMatch.Index && nextMatch.Length > 0)
+                if (logicalIndex == nextMatch.Index && nextMatch.Length > 0)
                 {
-                    i += nextMatch.Length;
+                    logicalIndex += nextMatch.Length;
                     nextMatch = nextMatch.NextMatch();
                 }
                 // Increment non ansi index
                 nonAnsiIndex++;
-                i++;
+                logicalIndex++;
             }
-            return i;
+            return logicalIndex;
         }
 
-        public static List<string> ANSIWrap(string text, int position)
+        public static List<string> ANSIWrap(string text, int maxLength)
         {
             ReadOnlySpan<char> textSpan = text.AsSpan();
             List<string> result = new();
-            int breakpoint = ANSIBreakpoint(text, position);
+            int breakpoint = ANSIBreakpoint(text, maxLength);
             while (textSpan.Length > breakpoint)
             {
                 result.Add(textSpan.Slice(0, breakpoint).ToString());
                 textSpan = textSpan.Slice(breakpoint);
-                breakpoint = ANSIBreakpoint(text, position, breakpoint);
+                breakpoint = ANSIBreakpoint(text, maxLength, breakpoint);
             }
             result.Add(textSpan.ToString());
             return result;
@@ -115,12 +120,12 @@ public static string SpaceBetween(string leftText, string rightText, int width)
                 string result = String.Empty;
                 string leftNoFormatString = ANSIRemove(leftText);
                 string rightNoFormatString = ANSIRemove(rightText);
-                if (leftNoFormatString.Length + rightNoFormatString.Length > Console.BufferWidth)
+                if (leftNoFormatString.Length + rightNoFormatString.Length >= width)
                 {
                     return leftText + rightText;
                 }
 
-                int space = Console.BufferWidth - (leftNoFormatString.Length + rightNoFormatString.Length);
+                int space = width - (leftNoFormatString.Length + rightNoFormatString.Length);
                 result += leftText;
                 result += new string(' ', space - 1);
                 result += rightText;
@@ -221,11 +226,10 @@ public static string Overlined(string text)
                 return String.Format("\x1b[53m{0}\x1b[55m", text);
             }
 
-            // TODO: Right now only replaces \ with /. Needs review to make sure it works on all or most terminal emulators.
-            public static string Hyperlink(string text, string url)
+            public static string Hyperlink(string text, string rawUrl)
             {
-                // return String.Format("\x1b[]8;;{0}\x1b\\{1}\x1b[]8;\x1b\\", text, url);
-                return url.Replace("\\", "/");
+                string url = rawUrl.Length > 0 ? new System.Uri(rawUrl).AbsoluteUri : rawUrl;
+                return $"\x1b]8;;{url}\x1b\\{text}\x1b]8;;\x1b\\";
             }
 
             public static string DECLineDrawing(string text)
diff --git a/src/MSBuild/LiveLogger/LiveLogger.cs b/src/MSBuild/LiveLogger/LiveLogger.cs
index 80504c45443..1dcbe2080bb 100644
--- a/src/MSBuild/LiveLogger/LiveLogger.cs
+++ b/src/MSBuild/LiveLogger/LiveLogger.cs
@@ -1,4 +1,4 @@
-// Licensed to the .NET Foundation under one or more agreements.
+﻿// Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
@@ -256,18 +256,23 @@ private void console_CancelKeyPressed(object? sender, ConsoleCancelEventArgs eve
         public void Shutdown()
         {
             TerminalBuffer.Terminate();
-            // TODO: Remove. There is a bug that causes switching to main buffer without deleting the contents of the alternate buffer
-            Console.Clear();
             int errorCount = 0;
             int warningCount = 0;
             foreach (var project in projects)
             {
+                if (project.Value.AdditionalDetails.Count == 0)
+                {
+                    continue;
+                }
+
+                Console.WriteLine(project.Value.ToANSIString());
                 errorCount += project.Value.ErrorCount;
                 warningCount += project.Value.WarningCount;
                 foreach (var message in project.Value.AdditionalDetails)
                 {
-                    Console.WriteLine(message.ToANSIString());
+                    Console.WriteLine($"    └── {message.ToANSIString()}");
                 }
+                Console.WriteLine();
             }
 
             // Emmpty line
diff --git a/src/MSBuild/LiveLogger/MessageNode.cs b/src/MSBuild/LiveLogger/MessageNode.cs
index 0d969a61774..7d6029e041d 100644
--- a/src/MSBuild/LiveLogger/MessageNode.cs
+++ b/src/MSBuild/LiveLogger/MessageNode.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.IO;
 using Microsoft.Build.Framework;
 
 namespace Microsoft.Build.Logging.LiveLogger
@@ -15,7 +16,8 @@ public enum MessageType
         {
             HighPriorityMessage,
             Warning,
-            Error
+            Error,
+            ProjectOutputMessage
         }
         public string Message;
         public TerminalBufferLine? Line;
@@ -24,6 +26,7 @@ public enum MessageType
         public string? FilePath;
         public int? LineNumber;
         public int? ColumnNumber;
+        public string? ProjectOutputExecutablePath;
         public MessageNode(LazyFormattedBuildEventArgs args)
         {
             Message = args.Message ?? string.Empty;
@@ -34,8 +37,20 @@ public MessageNode(LazyFormattedBuildEventArgs args)
             // Get type
             switch (args)
             {
-                case BuildMessageEventArgs:
-                    Type = MessageType.HighPriorityMessage;
+                case BuildMessageEventArgs message:
+                    // Detect output messages
+                    var finalOutputMarker = " -> ";
+                    int i = message.Message!.IndexOf(finalOutputMarker, StringComparison.Ordinal);
+                    if (i > 0)
+                    {
+                        Type = MessageType.ProjectOutputMessage;
+                        ProjectOutputExecutablePath = message.Message!.Substring(i + finalOutputMarker.Length);
+                    }
+                    else
+                    {
+                        Type = MessageType.HighPriorityMessage;
+                        Code = message.Subcategory;
+                    }
                     break;
                 case BuildWarningEventArgs warning:
                     Type = MessageType.Warning;
@@ -66,9 +81,11 @@ public string ToANSIString()
                     return $"❌ {ANSIBuilder.Formatting.Color(
                         $"Error {Code}: {FilePath}({LineNumber},{ColumnNumber}) {Message}",
                         ANSIBuilder.Formatting.ForegroundColor.Red)}";
+                case MessageType.ProjectOutputMessage:
+                    return $"⚙️ {ANSIBuilder.Formatting.Hyperlink(ProjectOutputExecutablePath!, Path.GetDirectoryName(ProjectOutputExecutablePath)!)}";
                 case MessageType.HighPriorityMessage:
                 default:
-                    return $"ℹ️ {ANSIBuilder.Formatting.Italic(Message)}";
+                    return $"ℹ️ {Code}{(Code is not null ? ": " : string.Empty)} {ANSIBuilder.Formatting.Italic(Message)}";
             }
         }
 
diff --git a/src/MSBuild/LiveLogger/ProjectNode.cs b/src/MSBuild/LiveLogger/ProjectNode.cs
index ce66c2d21b9..e8980c1fb40 100644
--- a/src/MSBuild/LiveLogger/ProjectNode.cs
+++ b/src/MSBuild/LiveLogger/ProjectNode.cs
@@ -25,6 +25,7 @@ private static string GetUnambiguousPath(string path)
         public string ProjectPath;
         public string TargetFramework;
         public bool Finished;
+        public string? ProjectOutputExecutable;
         // Line to display project info
         public TerminalBufferLine? Line;
         // Targets
@@ -55,6 +56,29 @@ public ProjectNode(ProjectStartedEventArgs args)
             }
         }
 
+        public string ToANSIString()
+        {
+            ANSIBuilder.Formatting.ForegroundColor color = ANSIBuilder.Formatting.ForegroundColor.Default;
+            string icon = ANSIBuilder.Formatting.Blinking(ANSIBuilder.Graphics.Spinner()) + " ";
+
+            if (Finished && WarningCount + ErrorCount == 0)
+            {
+                color = ANSIBuilder.Formatting.ForegroundColor.Green;
+                icon = "✓";
+            }
+            else if (ErrorCount > 0)
+            {
+                color = ANSIBuilder.Formatting.ForegroundColor.Red;
+                icon = "X";
+            }
+            else if (WarningCount > 0)
+            {
+                color = ANSIBuilder.Formatting.ForegroundColor.Yellow;
+                icon = "✓";
+            }
+            return icon + " " + ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), color) + " " + ANSIBuilder.Formatting.Inverse(TargetFramework);
+        }
+
         // TODO: Rename to Render() after LiveLogger's API becomes internal
         public void Log()
         {
@@ -65,16 +89,7 @@ public void Log()
 
             ShouldRerender = false;
             // Project details
-            string lineContents = ANSIBuilder.Alignment.SpaceBetween(
-                // Show indicator
-                (Finished ? ANSIBuilder.Formatting.Color("✓", ANSIBuilder.Formatting.ForegroundColor.Green) : ANSIBuilder.Formatting.Blinking(ANSIBuilder.Graphics.Spinner())) +
-                // Project
-                ANSIBuilder.Formatting.Dim("Project: ") +
-                // Project file path with color
-                $"{ANSIBuilder.Formatting.Color(ANSIBuilder.Formatting.Bold(GetUnambiguousPath(ProjectPath)), Finished ? ANSIBuilder.Formatting.ForegroundColor.Green : ANSIBuilder.Formatting.ForegroundColor.Default)} [{TargetFramework ?? "*"}]",
-                $"({MessageCount} Messages, {WarningCount} Warnings, {ErrorCount} Errors)",
-                Console.WindowWidth);
-
+            string lineContents = ANSIBuilder.Alignment.SpaceBetween(ToANSIString(), $"({MessageCount} ℹ️, {WarningCount} ⚠️, {ErrorCount} ❌)", Console.BufferWidth - 1);
             // Create or update line
             if (Line is null)
             {
@@ -168,6 +183,12 @@ public TargetNode AddTarget(TargetStartedEventArgs args)
 
             MessageCount++;
             MessageNode node = new MessageNode(args);
+            // Add output executable path
+            if (node.ProjectOutputExecutablePath is not null)
+            {
+                ProjectOutputExecutable = node.ProjectOutputExecutablePath;
+            }
+
             AdditionalDetails.Add(node);
             return node;
         }
diff --git a/src/MSBuild/LiveLogger/TerminalBuffer.cs b/src/MSBuild/LiveLogger/TerminalBuffer.cs
index b4268af4c8b..676e9d09829 100644
--- a/src/MSBuild/LiveLogger/TerminalBuffer.cs
+++ b/src/MSBuild/LiveLogger/TerminalBuffer.cs
@@ -81,10 +81,12 @@ public static void Initialize()
         public static void Terminate()
         {
             IsTerminated = true;
+            // Delete contents from alternate buffer before switching back to main buffer
+            Console.Write(
+                ANSIBuilder.Cursor.Home() +
+                ANSIBuilder.Eraser.DisplayCursorToEnd());
             // Reset configuration for buffer and cursor, and clear screen
             Console.Write(ANSIBuilder.Buffer.UseMainBuffer());
-            Console.Write(ANSIBuilder.Eraser.Display());
-            Console.Clear();
             Console.Write(ANSIBuilder.Cursor.Visible());
             Lines = new();
         }
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index 2a3a575218c..68d24c68b48 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1364,7 +1364,7 @@ public static BuildResult BuildProjectFileUsingBuildManager(
             string projectFile,
             MockLogger logger = null,
             BuildParameters parameters = null,
-            List<string> defaultTargets = null)
+            IList<string> targetsToBuild = null)
         {
             using (var buildManager = new BuildManager())
             {
@@ -1381,7 +1381,7 @@ public static BuildResult BuildProjectFileUsingBuildManager(
                     projectFile,
                     new Dictionary<string, string>(),
                     MSBuildConstants.CurrentToolsVersion,
-                    defaultTargets?.ToArray() ?? Array.Empty<string>(),
+                    targetsToBuild?.ToArray() ?? Array.Empty<string>(),
                     null);
 
                 var result = buildManager.Build(
diff --git a/src/Tasks/Microsoft.Managed.After.targets b/src/Tasks/Microsoft.Managed.After.targets
index 48264892122..fc33d41e1c4 100644
--- a/src/Tasks/Microsoft.Managed.After.targets
+++ b/src/Tasks/Microsoft.Managed.After.targets
@@ -41,11 +41,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     <_MainReferenceTargetForBuild Condition="'$(BuildProjectReferences)' == '' or '$(BuildProjectReferences)' == 'true'">.projectReferenceTargetsOrDefaultTargets</_MainReferenceTargetForBuild>
     <_MainReferenceTargetForBuild Condition="'$(_MainReferenceTargetForBuild)' == ''">GetTargetPath</_MainReferenceTargetForBuild>
 
-    <ProjectReferenceTargetsForBuildInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForBuildInOuterBuild)</ProjectReferenceTargetsForBuildInOuterBuild>
-    <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
+    <ProjectReferenceTargetsForBuild>$(_MainReferenceTargetForBuild);GetNativeManifest;$(_RecursiveTargetForContentCopying);$(ProjectReferenceTargetsForBuild)</ProjectReferenceTargetsForBuild>
 
-    <ProjectReferenceTargetsForCleanInOuterBuild>GetTargetFrameworks;$(ProjectReferenceTargetsForCleanInOuterBuild)</ProjectReferenceTargetsForCleanInOuterBuild>
-    <ProjectReferenceTargetsForClean>Clean;GetTargetFrameworksWithPlatformForSingleTargetFramework;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
+    <ProjectReferenceTargetsForClean>Clean;$(ProjectReferenceTargetsForClean)</ProjectReferenceTargetsForClean>
 
     <ProjectReferenceTargetsForRebuild>$(ProjectReferenceTargetsForClean);$(ProjectReferenceTargetsForBuild);$(ProjectReferenceTargetsForRebuild)</ProjectReferenceTargetsForRebuild>
 
@@ -59,11 +57,21 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
   <ItemGroup Condition="'$(IsGraphBuild)' == 'true'">
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuildInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForBuildInOuterBuild)' != '' " OuterBuild="true" />
+    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" />
     <ProjectReferenceTargets Include="Build" Targets="$(ProjectReferenceTargetsForBuild)" Condition=" '$(ProjectReferenceTargetsForBuild)' != '' " />
-
+    
     <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForCleanInOuterBuild)" Condition=" '$(ProjectReferenceTargetsForCleanInOuterBuild)' != '' " OuterBuild="true" />
+    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworks" OuterBuild="true" SkipNonexistentTargets="true" />
     <ProjectReferenceTargets Include="Clean" Targets="$(ProjectReferenceTargetsForClean)" Condition=" '$(ProjectReferenceTargetsForClean)' != '' " />
 
+    <!--
+     Note: SkipNonexistentTargets="true" on the following three items means that an outer build node's call to its existent GetTargetFrameworks target will fail if its inner build nodes don't define GetTargetFrameworksWithPlatformForSingleTargetFrameworks.
+     This is necessary since the P2P protocol cannot express the targets called from the outer build to the inner build.
+     -->
+    <ProjectReferenceTargets Include="Build" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
+    <ProjectReferenceTargets Include="Clean" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
+    <ProjectReferenceTargets Include="Rebuild" Targets="GetTargetFrameworksWithPlatformForSingleTargetFramework" SkipNonexistentTargets="true" />
+
     <ProjectReferenceTargets Include="Rebuild" Targets="$(ProjectReferenceTargetsForRebuild)" Condition=" '$(ProjectReferenceTargetsForRebuild)' != '' " />
 
     <ProjectReferenceTargets Include="Publish" Targets="$(ProjectReferenceTargetsForPublish)" Condition=" '$(ProjectReferenceTargetsForPublish)' != '' " />
