diff --git a/ref/Microsoft.Build/net/Microsoft.Build.cs b/ref/Microsoft.Build/net/Microsoft.Build.cs
index 0e5ce8174b3..5c734ccf1d0 100644
--- a/ref/Microsoft.Build/net/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/net/Microsoft.Build.cs
@@ -65,9 +65,9 @@ internal ProjectElementContainer() { }
         public System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement> AllChildren { get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> Children { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> ChildrenReversed { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
-        public int Count { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement FirstChild { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement LastChild { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public int Count { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Construction.ProjectElement FirstChild { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Construction.ProjectElement LastChild { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public void AppendChild(Microsoft.Build.Construction.ProjectElement child) { }
         protected internal virtual Microsoft.Build.Construction.ProjectElementContainer DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) { throw null; }
         public virtual void DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer element) { }
@@ -244,7 +244,7 @@ internal ProjectRootElement() { }
         public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
         public string DefaultTargets { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } [System.Diagnostics.DebuggerStepThroughAttribute]set { } }
         public Microsoft.Build.Construction.ElementLocation DefaultTargetsLocation { get { throw null; } }
-        public string DirectoryPath { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
+        public string DirectoryPath { get { throw null; } }
         public System.Text.Encoding Encoding { get { throw null; } }
         public string FullPath { get { throw null; } set { } }
         public bool HasUnsavedChanges { get { throw null; } }
@@ -442,7 +442,7 @@ public partial class ProjectUsingTaskParameterElement : Microsoft.Build.Construc
         internal ProjectUsingTaskParameterElement() { }
         public override string Condition { get { throw null; } set { } }
         public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string Name { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } set { } }
+        public string Name { get { throw null; } set { } }
         public string Output { get { throw null; } set { } }
         public Microsoft.Build.Construction.ElementLocation OutputLocation { get { throw null; } }
         public string ParameterType { get { throw null; } set { } }
@@ -581,7 +581,7 @@ public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDicti
         public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> ItemsIgnoringCondition { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<string> ItemTypes { get { throw null; } }
         public int LastEvaluationId { get { throw null; } }
-        public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty> Properties { get { throw null; } }
         public bool SkipEvaluation { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
@@ -589,7 +589,7 @@ public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDicti
         public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance> Targets { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
         public bool ThrowInsteadOfSplittingItemElement { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string ToolsVersion { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectRootElement Xml { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Construction.ProjectRootElement Xml { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItem(string itemType, string unevaluatedInclude) { throw null; }
         public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
         public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItemFast(string itemType, string unevaluatedInclude) { throw null; }
@@ -1302,7 +1302,7 @@ internal ProjectPropertyInstance() { }
         public string EvaluatedValue { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } [System.Diagnostics.DebuggerStepThroughAttribute]set { } }
         public virtual bool IsImmutable { get { throw null; } }
         [System.Diagnostics.DebuggerBrowsableAttribute((System.Diagnostics.DebuggerBrowsableState)(0))]
-        public string Name { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
+        public string Name { get { throw null; } }
         bool System.IEquatable<Microsoft.Build.Execution.ProjectPropertyInstance>.Equals(Microsoft.Build.Execution.ProjectPropertyInstance other) { throw null; }
         public override string ToString() { throw null; }
     }
diff --git a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
index 60fe7aeecdf..74950bbeb22 100644
--- a/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
+++ b/ref/Microsoft.Build/netstandard/Microsoft.Build.cs
@@ -65,9 +65,9 @@ internal ProjectElementContainer() { }
         public System.Collections.Generic.IEnumerable<Microsoft.Build.Construction.ProjectElement> AllChildren { get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> Children { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Construction.ProjectElement> ChildrenReversed { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
-        public int Count { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement FirstChild { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
-        public Microsoft.Build.Construction.ProjectElement LastChild { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public int Count { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Construction.ProjectElement FirstChild { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Construction.ProjectElement LastChild { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public void AppendChild(Microsoft.Build.Construction.ProjectElement child) { }
         protected internal virtual Microsoft.Build.Construction.ProjectElementContainer DeepClone(Microsoft.Build.Construction.ProjectRootElement factory, Microsoft.Build.Construction.ProjectElementContainer parent) { throw null; }
         public virtual void DeepCopyFrom(Microsoft.Build.Construction.ProjectElementContainer element) { }
@@ -244,7 +244,7 @@ internal ProjectRootElement() { }
         public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
         public string DefaultTargets { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } [System.Diagnostics.DebuggerStepThroughAttribute]set { } }
         public Microsoft.Build.Construction.ElementLocation DefaultTargetsLocation { get { throw null; } }
-        public string DirectoryPath { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
+        public string DirectoryPath { get { throw null; } }
         public System.Text.Encoding Encoding { get { throw null; } }
         public string FullPath { get { throw null; } set { } }
         public bool HasUnsavedChanges { get { throw null; } }
@@ -442,7 +442,7 @@ public partial class ProjectUsingTaskParameterElement : Microsoft.Build.Construc
         internal ProjectUsingTaskParameterElement() { }
         public override string Condition { get { throw null; } set { } }
         public override Microsoft.Build.Construction.ElementLocation ConditionLocation { get { throw null; } }
-        public string Name { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } set { } }
+        public string Name { get { throw null; } set { } }
         public string Output { get { throw null; } set { } }
         public Microsoft.Build.Construction.ElementLocation OutputLocation { get { throw null; } }
         public string ParameterType { get { throw null; } set { } }
@@ -581,7 +581,7 @@ public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDicti
         public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectItem> ItemsIgnoringCondition { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
         public System.Collections.Generic.ICollection<string> ItemTypes { get { throw null; } }
         public int LastEvaluationId { get { throw null; } }
-        public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get { throw null; } }
         public System.Collections.Generic.ICollection<Microsoft.Build.Evaluation.ProjectProperty> Properties { get { throw null; } }
         public bool SkipEvaluation { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
@@ -589,7 +589,7 @@ public Project(System.Xml.XmlReader xmlReader, System.Collections.Generic.IDicti
         public System.Collections.Generic.IDictionary<string, Microsoft.Build.Execution.ProjectTargetInstance> Targets { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
         public bool ThrowInsteadOfSplittingItemElement { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } [System.Runtime.CompilerServices.CompilerGeneratedAttribute]set { } }
         public string ToolsVersion { get { throw null; } }
-        public Microsoft.Build.Construction.ProjectRootElement Xml { [System.Diagnostics.DebuggerStepThroughAttribute, System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
+        public Microsoft.Build.Construction.ProjectRootElement Xml { [System.Runtime.CompilerServices.CompilerGeneratedAttribute]get { throw null; } }
         public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItem(string itemType, string unevaluatedInclude) { throw null; }
         public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItem(string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<string, string>> metadata) { throw null; }
         public System.Collections.Generic.IList<Microsoft.Build.Evaluation.ProjectItem> AddItemFast(string itemType, string unevaluatedInclude) { throw null; }
@@ -1297,7 +1297,7 @@ internal ProjectPropertyInstance() { }
         public string EvaluatedValue { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } [System.Diagnostics.DebuggerStepThroughAttribute]set { } }
         public virtual bool IsImmutable { get { throw null; } }
         [System.Diagnostics.DebuggerBrowsableAttribute((System.Diagnostics.DebuggerBrowsableState)(0))]
-        public string Name { [System.Diagnostics.DebuggerStepThroughAttribute]get { throw null; } }
+        public string Name { get { throw null; } }
         bool System.IEquatable<Microsoft.Build.Execution.ProjectPropertyInstance>.Equals(Microsoft.Build.Execution.ProjectPropertyInstance other) { throw null; }
         public override string ToString() { throw null; }
     }
diff --git a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
index 2d3cb2eddfb..df8df482ae7 100644
--- a/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
+++ b/src/Build.OM.UnitTests/Definition/ProjectCollection_Tests.cs
@@ -367,10 +367,10 @@ public void GetLoadedProjectRootElementWrongCollection()
         [Fact]
         public void ErrorTwoProjectsEquivalentOneCollection()
         {
+            _ = new Project { FullPath = "c:\\x" };
             Assert.Throws<InvalidOperationException>(() =>
             {
                 _ = new Project { FullPath = "c:\\x" };
-                _ = new Project { FullPath = "c:\\x" };
             });
         }
 
@@ -578,7 +578,6 @@ public void SettingGlobalPropertiesOnCollectionUpdatesProjects()
         {
             var collection = new ProjectCollection();
             var project1 = new Project(collection) { FullPath = "c:\\y" };
-            // load into collection
             Assert.Equal(0, project1.GlobalProperties.Count);
 
             collection.SetGlobalProperty("g1", "v1");
diff --git a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
index d553fb3b6c1..be085666dfb 100644
--- a/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildEventArgTransportSink_Tests.cs
@@ -28,7 +28,7 @@ public void PropertyTests()
             BuildEventArgTransportSink sink = new BuildEventArgTransportSink(PacketProcessor);
             Assert.Null(sink.Name);
 
-            string name = "Test Name";
+            const string name = "Test Name";
             sink.Name = name;
             Assert.Equal(0, string.Compare(sink.Name, name, StringComparison.OrdinalIgnoreCase));
         }
@@ -41,9 +41,8 @@ public void TestConstructorNullSendDataDelegate()
         {
             Assert.Throws<InternalErrorException>(() =>
             {
-                BuildEventArgTransportSink transportSink = new BuildEventArgTransportSink(null);
-            }
-           );
+                var transportSink = new BuildEventArgTransportSink(null);
+            });
         }
         /// <summary>
         /// Verify consume throws the correct exception when a null build event is passed in
@@ -67,16 +66,17 @@ public void TestConsumeMessageBuildEvent()
         {
             bool wentInHandler = false;
             BuildMessageEventArgs messageEvent = new BuildMessageEventArgs("My message", "Help me keyword", "Sender", MessageImportance.High);
-            SendDataDelegate transportDelegate = delegate (INodePacket packet)
-                                                 {
-                                                     wentInHandler = true;
-                                                     LogMessagePacket loggingPacket = packet as LogMessagePacket;
-                                                     Assert.NotNull(loggingPacket);
-                                                     BuildMessageEventArgs messageEventFromPacket = loggingPacket.NodeBuildEvent.Value.Value as BuildMessageEventArgs;
-                                                     Assert.Equal(messageEventFromPacket, messageEvent);
-                                                 };
-
-            BuildEventArgTransportSink transportSink = new BuildEventArgTransportSink(transportDelegate);
+
+            void TransportDelegate(INodePacket packet)
+            {
+                wentInHandler = true;
+                LogMessagePacket loggingPacket = packet as LogMessagePacket;
+                Assert.NotNull(loggingPacket);
+                BuildMessageEventArgs messageEventFromPacket = loggingPacket.NodeBuildEvent.Value.Value as BuildMessageEventArgs;
+                Assert.Equal(messageEventFromPacket, messageEvent);
+            }
+
+            BuildEventArgTransportSink transportSink = new BuildEventArgTransportSink(TransportDelegate);
             transportSink.Consume(messageEvent, 0);
             Assert.True(wentInHandler); // "Expected to go into transport delegate"
         }
@@ -89,12 +89,13 @@ public void TestConsumeBuildStartedEvent()
         {
             bool wentInHandler = false;
             BuildStartedEventArgs buildStarted = new BuildStartedEventArgs("Start", "Help");
-            SendDataDelegate transportDelegate = delegate (INodePacket packet)
+
+            void TransportDelegate(INodePacket packet)
             {
                 wentInHandler = true;
-            };
+            }
 
-            BuildEventArgTransportSink transportSink = new BuildEventArgTransportSink(transportDelegate);
+            BuildEventArgTransportSink transportSink = new BuildEventArgTransportSink(TransportDelegate);
             transportSink.Consume(buildStarted, 0);
             Assert.True(transportSink.HaveLoggedBuildStartedEvent);
             Assert.False(transportSink.HaveLoggedBuildFinishedEvent);
@@ -109,12 +110,13 @@ public void TestConsumeBuildFinishedEvent()
         {
             bool wentInHandler = false;
             BuildFinishedEventArgs buildFinished = new BuildFinishedEventArgs("Finished", "Help", true);
-            SendDataDelegate transportDelegate = delegate (INodePacket packet)
+
+            void TransportDelegate(INodePacket packet)
             {
                 wentInHandler = true;
-            };
+            }
 
-            BuildEventArgTransportSink transportSink = new BuildEventArgTransportSink(transportDelegate);
+            BuildEventArgTransportSink transportSink = new BuildEventArgTransportSink(TransportDelegate);
             transportSink.Consume(buildFinished, 0);
             Assert.False(transportSink.HaveLoggedBuildStartedEvent);
             Assert.True(transportSink.HaveLoggedBuildFinishedEvent);
@@ -130,19 +132,20 @@ public void TestConsumeBuildFinishedEvent()
         public void TestShutDown()
         {
             SendDataDelegate transportDelegate = PacketProcessor;
-            WeakReference weakTransportDelegateReference = new WeakReference(transportDelegate);
-            BuildEventArgTransportSink transportSink = new BuildEventArgTransportSink(transportDelegate);
+            var weakTransportDelegateReference = new WeakReference<SendDataDelegate>(transportDelegate);
+            var transportSink = new BuildEventArgTransportSink(transportDelegate);
 
             transportSink.ShutDown();
 
-            Assert.NotNull(weakTransportDelegateReference.Target);
+            Assert.True(weakTransportDelegateReference.TryGetTarget(out SendDataDelegate sendData));
+            Assert.NotNull(sendData);
             transportDelegate = null;
             GC.Collect();
             GC.WaitForPendingFinalizers();
 
             // Expected shutdown to null out the sendData delegate, the two garbage collections
             // should have collected the sendDataDelegate causing the weak reference to die.
-            Assert.Null(weakTransportDelegateReference.Target); // " Expected delegate to be dead"
+            Assert.False(weakTransportDelegateReference.TryGetTarget(out _));  // " Expected delegate to be dead"
         }
 
         /// <summary>
@@ -154,7 +157,7 @@ public void TestShutDown()
         /// garbage collected until the class it was instantiated in is collected itself.
         /// </summary>
         /// <param name="packet">Packet to process</param>
-        private void PacketProcessor(INodePacket packet)
+        private static void PacketProcessor(INodePacket packet)
         {
         }
     }
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 1deccf1fbd1..91f70b7139c 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -557,7 +557,7 @@ public void ReportConfigurationResponse(BuildRequestConfigurationResponse respon
         /// <param name="host">The host.</param>
         public void InitializeComponent(IBuildComponentHost host)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(host, "host");
+            ErrorUtilities.VerifyThrowArgumentNull(host, nameof(host));
             ErrorUtilities.VerifyThrow(_componentHost == null, "BuildRequestEngine already initialized!");
             _componentHost = host;
             _configCache = (IConfigCache)host.GetComponent(BuildComponentType.ConfigCache);
@@ -1255,7 +1255,7 @@ private int GetNextBuildRequestId()
         private void IssueConfigurationRequest(BuildRequestConfiguration config)
         {
             ErrorUtilities.VerifyThrowArgument(config.WasGeneratedByNode, "InvalidConfigurationId");
-            ErrorUtilities.VerifyThrowArgumentNull(config, "config");
+            ErrorUtilities.VerifyThrowArgumentNull(config, nameof(config));
             ErrorUtilities.VerifyThrowInvalidOperation(_unresolvedConfigurations.HasConfiguration(config.ConfigurationId), "NoUnresolvedConfiguration");
             TraceEngine("Issuing configuration request for node config {0}", config.ConfigurationId);
             RaiseNewConfigurationRequest(config);
@@ -1267,7 +1267,7 @@ private void IssueConfigurationRequest(BuildRequestConfiguration config)
         /// <param name="blocker">The information about why the request is blocked.</param>
         private void IssueBuildRequest(BuildRequestBlocker blocker)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(blocker, "blocker");
+            ErrorUtilities.VerifyThrowArgumentNull(blocker, nameof(blocker));
 
             if (blocker.BuildRequests == null)
             {
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
index 8fa564ac9a5..20e108c9c73 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEntry.cs
@@ -144,7 +144,7 @@ internal BuildRequestEntry(BuildRequest request, BuildRequestConfiguration reque
         /// <summary>
         /// Returns the object used to lock for synchronization of long-running operations.
         /// </summary>
-        public Object GlobalLock { [DebuggerStepThrough] get; }
+        public Object GlobalLock { get; }
 
         /// <summary>
         /// Returns the root directory for the project being built by this request.
@@ -155,22 +155,22 @@ internal BuildRequestEntry(BuildRequest request, BuildRequestConfiguration reque
         /// <summary>
         /// Returns the current state of the build request.
         /// </summary>
-        public BuildRequestEntryState State { [DebuggerStepThrough] get; private set; }
+        public BuildRequestEntryState State { get; private set; }
 
         /// <summary>
         /// Returns the request which originated this entry.
         /// </summary>
-        public BuildRequest Request { [DebuggerStepThrough] get; }
+        public BuildRequest Request { get; }
 
         /// <summary>
         /// Returns the build request configuration
         /// </summary>
-        public BuildRequestConfiguration RequestConfiguration { [DebuggerStepThrough] get; }
+        public BuildRequestConfiguration RequestConfiguration { get; }
 
         /// <summary>
         /// Returns the overall result for this request.
         /// </summary>
-        public BuildResult Result { [DebuggerStepThrough] get; private set; }
+        public BuildResult Result { get; private set; }
 
         /// <summary>
         /// Returns the request builder.
@@ -178,10 +178,7 @@ internal BuildRequestEntry(BuildRequest request, BuildRequestConfiguration reque
         public IRequestBuilder Builder
         {
             [DebuggerStepThrough]
-            get
-            {
-                return _requestBuilder;
-            }
+            get => _requestBuilder;
 
             [DebuggerStepThrough]
             set
diff --git a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
index 2fa0af6cfdc..6b55e4af09c 100644
--- a/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
+++ b/src/Build/BackEnd/Shared/BuildRequestConfiguration.cs
@@ -266,7 +266,7 @@ private BuildRequestConfiguration(INodePacketTranslator translator)
         /// <summary>
         /// Flag indicating whether or not the configuration is actually building.
         /// </summary>
-        public bool IsActivelyBuilding => (_activelyBuildingTargets != null) && (_activelyBuildingTargets.Count > 0);
+        public bool IsActivelyBuilding => _activelyBuildingTargets?.Count > 0;
 
         /// <summary>
         /// Flag indicating whether or not the configuration has been loaded before.
@@ -319,12 +319,7 @@ public bool IsTraversal
         /// <summary>
         /// Returns true if this configuration was generated on a node and has not yet been resolved.
         /// </summary>
-        public bool WasGeneratedByNode
-        {
-            [DebuggerStepThrough]
-            get
-            { return _configId < 0; }
-        }
+        public bool WasGeneratedByNode => _configId < 0;
 
         /// <summary>
         /// Sets or returns the configuration id
@@ -332,10 +327,7 @@ public bool WasGeneratedByNode
         public int ConfigurationId
         {
             [DebuggerStepThrough]
-            get
-            {
-                return _configId;
-            }
+            get => _configId;
 
             [DebuggerStepThrough]
             set
@@ -348,12 +340,7 @@ public int ConfigurationId
         /// <summary>
         /// Returns the filename of the project to build.
         /// </summary>
-        public string ProjectFullPath
-        {
-            [DebuggerStepThrough]
-            get
-            { return _projectFullPath; }
-        }
+        public string ProjectFullPath => _projectFullPath;
 
         /// <summary>
         /// The tools version specified for the configuration.
@@ -361,22 +348,12 @@ public string ProjectFullPath
         /// May have originated from a /tv switch, or an MSBuild task,
         /// or a Project tag, or the default.
         /// </summary>
-        public string ToolsVersion
-        {
-            [DebuggerStepThrough]
-            get
-            { return _toolsVersion; }
-        }
+        public string ToolsVersion => _toolsVersion;
 
         /// <summary>
         /// Returns the global properties to use to build this project.
         /// </summary>
-        public PropertyDictionary<ProjectPropertyInstance> GlobalProperties
-        {
-            [DebuggerStepThrough]
-            get
-            { return _globalProperties; }
-        }
+        public PropertyDictionary<ProjectPropertyInstance> GlobalProperties => _globalProperties;
 
         /// <summary>
         /// Sets or returns the project to build.
@@ -474,11 +451,7 @@ internal void CreateUniqueGlobalProperty()
         /// </summary>
         public List<string> ProjectInitialTargets
         {
-            [DebuggerStepThrough]
-            get
-            {
-                return _projectInitialTargets;
-            }
+            get => _projectInitialTargets;
 
             [DebuggerStepThrough]
             set
@@ -494,10 +467,7 @@ public List<string> ProjectInitialTargets
         public List<string> ProjectDefaultTargets
         {
             [DebuggerStepThrough]
-            get
-            {
-                return _projectDefaultTargets;
-            }
+            get => _projectDefaultTargets;
 
             [DebuggerStepThrough]
             set
@@ -510,12 +480,7 @@ public List<string> ProjectDefaultTargets
         /// <summary>
         /// Returns the node packet type
         /// </summary>
-        public NodePacketType Type
-        {
-            [DebuggerStepThrough]
-            get
-            { return NodePacketType.BuildRequestConfiguration; }
-        }
+        public NodePacketType Type => NodePacketType.BuildRequestConfiguration;
 
         /// <summary>
         /// Returns the lookup which collects all items and properties during the run of this project.
@@ -526,8 +491,12 @@ public Lookup BaseLookup
             {
                 ErrorUtilities.VerifyThrow(!IsCached, "Configuration is cached, we shouldn't be accessing the lookup.");
 
-                return _baseLookup ??
-                       (_baseLookup = new Lookup(Project.ItemsToBuildWith, Project.PropertiesToBuildWith));
+                if (_baseLookup == null)
+                {
+                    _baseLookup = new Lookup(Project.ItemsToBuildWith, Project.PropertiesToBuildWith);
+                }
+
+                return _baseLookup;
             }
         }
 
@@ -561,12 +530,7 @@ public string SavedCurrentDirectory
         /// Whether the tools version was set by the /tv switch or passed in through an msbuild callback
         /// directly or indirectly.
         /// </summary>
-        public bool ExplicitToolsVersionSpecified
-        {
-            [DebuggerStepThrough]
-            get
-            { return _explicitToolsVersionSpecified; }
-        }
+        public bool ExplicitToolsVersionSpecified => _explicitToolsVersionSpecified;
 
         /// <summary>
         /// Gets or sets the node on which this configuration's results are stored.
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index f9e41462901..d356e1421da 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -102,6 +102,11 @@ internal class TaskExecutionHost : ITaskExecutionHost, IDisposable
         /// </summary>
         private ItemBucket _batchBucket;
 
+        /// <summary>
+        /// The task type retrieved from the assembly.
+        /// </summary>
+        private TaskFactoryWrapper _taskFactoryWrapper;
+
         /// <summary>
         /// Set to true if the execution has been cancelled.
         /// </summary>
@@ -182,7 +187,11 @@ internal TaskExecutionHost()
         /// <summary>
         /// FOR UNIT TESTING ONLY
         /// </summary>
-        internal TaskFactoryWrapper _UNITTESTONLY_TaskFactoryWrapper { get; set; }
+        internal TaskFactoryWrapper _UNITTESTONLY_TaskFactoryWrapper
+        {
+            get => _taskFactoryWrapper;
+            set => _taskFactoryWrapper = value;
+        }
 
 #if FEATURE_APPDOMAIN
         /// <summary>
@@ -236,24 +245,24 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
         /// <returns>True if the task is found in the task registry false if otherwise.</returns>
         TaskRequirements? ITaskExecutionHost.FindTask(IDictionary<string, string> taskIdentityParameters)
         {
-            if (_UNITTESTONLY_TaskFactoryWrapper == null)
+            if (_taskFactoryWrapper == null)
             {
-                _UNITTESTONLY_TaskFactoryWrapper = FindTaskInRegistry(taskIdentityParameters);
+                _taskFactoryWrapper = FindTaskInRegistry(taskIdentityParameters);
             }
 
-            if (_UNITTESTONLY_TaskFactoryWrapper == null)
+            if (_taskFactoryWrapper == null)
             {
                 return null;
             }
 
             TaskRequirements requirements = TaskRequirements.None;
 
-            if (_UNITTESTONLY_TaskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute())
+            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute())
             {
                 requirements = requirements | TaskRequirements.RequireSTAThread;
             }
 
-            if (_UNITTESTONLY_TaskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute())
+            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute())
             {
                 requirements = requirements | TaskRequirements.RequireSeparateAppDomain;
 
@@ -276,7 +285,7 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
             _taskLoggingContext = loggingContext;
             _batchBucket = batchBucket;
 
-            if (_UNITTESTONLY_TaskFactoryWrapper == null)
+            if (_taskFactoryWrapper == null)
             {
                 return false;
             }
@@ -290,7 +299,7 @@ bool ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, It
             if (null == _resolver)
             {
                 _resolver = new TaskEngineAssemblyResolver();
-                _resolver.Initialize(_UNITTESTONLY_TaskFactoryWrapper.TaskFactoryLoadedType.Assembly.AssemblyFile);
+                _resolver.Initialize(_taskFactoryWrapper.TaskFactoryLoadedType.Assembly.AssemblyFile);
                 _resolver.InstallHandler();
             }
 #endif
@@ -389,13 +398,13 @@ bool ITaskExecutionHost.SetTaskParameters(IDictionary<string, Tuple<string, Elem
         /// <returns>True of the outputs were gathered successfully, false otherwise.</returns>
         bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName)
         {
-            ErrorUtilities.VerifyThrow(_UNITTESTONLY_TaskFactoryWrapper != null, "Need a taskFactoryWrapper to retrieve outputs from.");
+            ErrorUtilities.VerifyThrow(_taskFactoryWrapper != null, "Need a taskFactoryWrapper to retrieve outputs from.");
 
             bool gatheredGeneratedOutputsSuccessfully = true;
 
             try
             {
-                TaskPropertyInfo parameter = _UNITTESTONLY_TaskFactoryWrapper.GetProperty(parameterName);
+                TaskPropertyInfo parameter = _taskFactoryWrapper.GetProperty(parameterName);
 
                 // flag an error if we find a parameter that has no .NET property equivalent
                 ProjectErrorUtilities.VerifyThrowInvalidProject
@@ -410,7 +419,7 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                 // output parameters must have their corresponding .NET properties marked with the Output attribute
                 ProjectErrorUtilities.VerifyThrowInvalidProject
                 (
-                    _UNITTESTONLY_TaskFactoryWrapper.GetNamesOfPropertiesWithOutputAttribute.ContainsKey(parameterName),
+                    _taskFactoryWrapper.GetNamesOfPropertiesWithOutputAttribute.ContainsKey(parameterName),
                     parameterLocation,
                     "UnmarkedOutputTaskParameter",
                     parameter.Name,
@@ -511,9 +520,9 @@ void ITaskExecutionHost.CleanupForBatch()
         {
             try
             {
-                if (_UNITTESTONLY_TaskFactoryWrapper != null && TaskInstance != null)
+                if (_taskFactoryWrapper != null && TaskInstance != null)
                 {
-                    _UNITTESTONLY_TaskFactoryWrapper.TaskFactory.CleanupTask(TaskInstance);
+                    _taskFactoryWrapper.TaskFactory.CleanupTask(TaskInstance);
                 }
             }
             finally
@@ -535,7 +544,7 @@ void ITaskExecutionHost.CleanupForTask()
             }
 #endif
 
-            _UNITTESTONLY_TaskFactoryWrapper = null;
+            _taskFactoryWrapper = null;
 
             // We must null this out because it could be a COM object (or any other ref-counted object) which needs to
             // be released.
@@ -795,7 +804,7 @@ private void RecordItemForDisconnectIfNecessary(TaskItem item)
         /// </summary>
         private ITaskItem[] GetItemOutputs(TaskPropertyInfo parameter)
         {
-            object outputs = _UNITTESTONLY_TaskFactoryWrapper.GetPropertyValue(TaskInstance, parameter);
+            object outputs = _taskFactoryWrapper.GetPropertyValue(TaskInstance, parameter);
 
             if (!(outputs is ITaskItem[] taskItemOutputs))
             {
@@ -810,7 +819,7 @@ private ITaskItem[] GetItemOutputs(TaskPropertyInfo parameter)
         /// </summary>
         private string[] GetValueOutputs(TaskPropertyInfo parameter)
         {
-            object outputs = _UNITTESTONLY_TaskFactoryWrapper.GetPropertyValue(TaskInstance, parameter);
+            object outputs = _taskFactoryWrapper.GetPropertyValue(TaskInstance, parameter);
 
             Array convertibleOutputs = parameter.PropertyType.IsArray ? (Array)outputs : new[] { outputs };
 
@@ -935,7 +944,7 @@ private ITask InstantiateTask(IDictionary<string, string> taskIdentityParameters
 
             try
             {
-                if (_UNITTESTONLY_TaskFactoryWrapper.TaskFactory is AssemblyTaskFactory assemblyTaskFactory)
+                if (_taskFactoryWrapper.TaskFactory is AssemblyTaskFactory assemblyTaskFactory)
                 {
                     task = assemblyTaskFactory.CreateTaskInstance(_taskLocation, _taskLoggingContext, _buildComponentHost, taskIdentityParameters,
 #if FEATURE_APPDOMAIN
@@ -946,12 +955,12 @@ private ITask InstantiateTask(IDictionary<string, string> taskIdentityParameters
                 else
                 {
                     TaskFactoryLoggingHost loggingHost = new TaskFactoryLoggingHost(_buildEngine.IsRunningMultipleNodes, _taskLocation, _taskLoggingContext);
-                    ITaskFactory2 taskFactory2 = _UNITTESTONLY_TaskFactoryWrapper.TaskFactory as ITaskFactory2;
+                    ITaskFactory2 taskFactory2 = _taskFactoryWrapper.TaskFactory as ITaskFactory2;
                     try
                     {
                         if (taskFactory2 == null)
                         {
-                            task = _UNITTESTONLY_TaskFactoryWrapper.TaskFactory.CreateTask(loggingHost);
+                            task = _taskFactoryWrapper.TaskFactory.CreateTask(loggingHost);
                         }
                         else
                         {
@@ -973,7 +982,7 @@ private ITask InstantiateTask(IDictionary<string, string> taskIdentityParameters
                     new BuildEventFileInfo(_taskLocation),
                     "TaskInstantiationFailureErrorInvalidCast",
                     _taskName,
-                    _UNITTESTONLY_TaskFactoryWrapper.TaskFactory.FactoryName,
+                    _taskFactoryWrapper.TaskFactory.FactoryName,
                     e.Message
                 );
             }
@@ -986,7 +995,7 @@ private ITask InstantiateTask(IDictionary<string, string> taskIdentityParameters
                     new BuildEventFileInfo(_taskLocation),
                     "TaskInstantiationFailureError",
                     _taskName,
-                    _UNITTESTONLY_TaskFactoryWrapper.TaskFactory.FactoryName,
+                    _taskFactoryWrapper.TaskFactory.FactoryName,
                     Environment.NewLine + e.InnerException
                 );
             }
@@ -1003,7 +1012,7 @@ private ITask InstantiateTask(IDictionary<string, string> taskIdentityParameters
                     new BuildEventFileInfo(_taskLocation),
                     "TaskInstantiationFailureError",
                     _taskName,
-                    _UNITTESTONLY_TaskFactoryWrapper.TaskFactory.FactoryName,
+                    _taskFactoryWrapper.TaskFactory.FactoryName,
                     e.Message
                 );
             }
@@ -1029,7 +1038,7 @@ out bool parameterSet
             try
             {
                 // check if the task has a .NET property corresponding to the parameter
-                TaskPropertyInfo parameter = _UNITTESTONLY_TaskFactoryWrapper.GetProperty(parameterName);
+                TaskPropertyInfo parameter = _taskFactoryWrapper.GetProperty(parameterName);
 
                 if (parameter != null)
                 {
@@ -1311,7 +1320,7 @@ object parameterValue
 
             try
             {
-                _UNITTESTONLY_TaskFactoryWrapper.SetPropertyValue(TaskInstance, parameter, parameterValue);
+                _taskFactoryWrapper.SetPropertyValue(TaskInstance, parameter, parameterValue);
                 success = true;
             }
             catch (LoggerException)
@@ -1543,12 +1552,12 @@ private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string ou
         /// <returns>Gets a list of properties which are required.</returns>
         private IDictionary<string, string> GetNamesOfPropertiesWithRequiredAttribute()
         {
-            ErrorUtilities.VerifyThrow(_UNITTESTONLY_TaskFactoryWrapper != null, "Expected taskFactoryWrapper to not be null");
+            ErrorUtilities.VerifyThrow(_taskFactoryWrapper != null, "Expected taskFactoryWrapper to not be null");
             IDictionary<string, string> requiredParameters = null;
 
             try
             {
-                requiredParameters = _UNITTESTONLY_TaskFactoryWrapper.GetNamesOfPropertiesWithRequiredAttribute;
+                requiredParameters = _taskFactoryWrapper.GetNamesOfPropertiesWithRequiredAttribute;
             }
             catch (Exception e) // Catching Exception, but rethrowing unless it's a well-known exception.
             {
diff --git a/src/Build/Collections/ItemDictionary.cs b/src/Build/Collections/ItemDictionary.cs
index f385aee96ed..c57a4108a23 100644
--- a/src/Build/Collections/ItemDictionary.cs
+++ b/src/Build/Collections/ItemDictionary.cs
@@ -396,6 +396,7 @@ internal Enumerator(IEnumerable<ICollection<T>> listEnumerable)
             /// <summary>
             /// Get the current item
             /// </summary>
+            /// <remarks>Undefined if enumerator is before or after collection: we return null.</remarks>
             public T Current => _itemEnumerator?.Current;
 
             /// <summary>
diff --git a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
index 547295c4226..2ad4638c0a8 100644
--- a/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
+++ b/src/Build/Collections/RetrievableEntryHashSet/HashSet.cs
@@ -10,6 +10,7 @@
 #if FEATURE_SECURITY_PERMISSIONS
 using System.Security.Permissions;
 #endif
+using System.Text;
 using System.Diagnostics.CodeAnalysis;
 using System.Security;
 using Microsoft.Build.Shared;
@@ -77,12 +78,12 @@ namespace Microsoft.Build.Collections
     /// the same time. 
     /// </summary>
     /// <typeparam name="T"></typeparam>
-    [DebuggerTypeProxy(typeof(HashSetDebugView<>))]
+    [DebuggerTypeProxy(typeof(Microsoft.Build.Collections.HashSetDebugView<>))]
     [DebuggerDisplay("Count = {Count}")]
     [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix", Justification = "By design")]
-    [Serializable]
+    [Serializable()]
 #if FEATURE_SECURITY_PERMISSIONS
-    [HostProtection(MayLeakOnAbort = true)]
+    [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
 #endif
     internal class RetrievableEntryHashSet<T> : ICollection<T>,
         ISerializable, IDeserializationCallback,
@@ -91,6 +92,8 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
     {
         // store lower 31 bits of hash code
         private const int Lower31BitMask = 0x7FFFFFFF;
+        // cutoff point, above which we won't do stackallocs. This corresponds to 100 integers.
+        private const int StackAllocThreshold = 100;
         // when constructing a hashset from an existing collection, it may contain duplicates, 
         // so this is used as the max acceptable excess ratio of capacity to count. Note that
         // this is only used on the ctor and not to automatically shrink if the hashset has, e.g,
@@ -112,6 +115,7 @@ internal class RetrievableEntryHashSet<T> : ICollection<T>,
         private IEqualityComparer<string> _comparer;
         private IConstrainedEqualityComparer<string> _constrainedComparer;
         private int _version;
+        private bool _readOnly;
 
         // temporary variable needed during deserialization
         private SerializationInfo _siInfo;
@@ -136,13 +140,13 @@ public RetrievableEntryHashSet(IEqualityComparer<string> comparer)
         public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<string> comparer, bool readOnly = false)
             : this(collection, comparer)
         {
-            IsReadOnly = true; // Set after possible initialization from another collection
+            _readOnly = true; // Set after possible initialization from another collection
         }
 
         public RetrievableEntryHashSet(IEnumerable<KeyValuePair<string, T>> collection, IEqualityComparer<string> comparer, bool readOnly = false)
             : this(collection.Values(), comparer, readOnly)
         {
-            IsReadOnly = true; // Set after possible initialization from another collection
+            _readOnly = true; // Set after possible initialization from another collection
         }
 
         /// <summary>
@@ -166,7 +170,7 @@ public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<stri
         {
             if (collection == null)
             {
-                throw new ArgumentNullException(nameof(collection));
+                throw new ArgumentNullException("collection");
             }
 
             Contract.EndContractBlock();
@@ -175,13 +179,14 @@ public RetrievableEntryHashSet(IEnumerable<T> collection, IEqualityComparer<stri
             // may contain duplicates, so call TrimExcess if resulting hashset is larger than
             // threshold
             int suggestedCapacity = 0;
-            if (collection is ICollection<T> coll)
+            ICollection<T> coll = collection as ICollection<T>;
+            if (coll != null)
             {
                 suggestedCapacity = coll.Count;
             }
             Initialize(suggestedCapacity);
 
-            UnionWith(collection);
+            this.UnionWith(collection);
             if ((_count == 0 && _slots.Length > HashHelpers.GetMinPrime()) ||
                 (_count > 0 && _slots.Length / _count > ShrinkThreshold))
             {
@@ -219,14 +224,20 @@ public ICollection<string> Keys
         }
 
         // Convenience to minimise change to callers used to dictionaries
-        public ICollection<T> Values => this;
+        public ICollection<T> Values
+        {
+            get { return this; }
+        }
 
         #region ICollection<T> methods
 
         // Convenience to minimise change to callers used to dictionaries
         internal T this[string name]
         {
-            get => Get(name);
+            get
+            {
+                return Get(name);
+            }
 
             set
             {
@@ -251,7 +262,7 @@ void ICollection<T>.Add(T item)
         /// </summary>
         public void Clear()
         {
-            if (IsReadOnly)
+            if (_readOnly)
             {
                 ErrorUtilities.ThrowInvalidOperation("OM_NotSupportedReadOnlyCollection");
             }
@@ -290,8 +301,8 @@ public bool ContainsKey(string key)
 
         T IDictionary<string, T>.this[string name]
         {
-            get => Get(name);
-            set => Add(value);
+            get { return Get(name); }
+            set { Add(value); }
         }
 
         /// <summary>
@@ -331,19 +342,13 @@ public T Get(string key)
         public T Get(string key, int index, int length)
         {
             if (length < 0)
-            {
-                throw new ArgumentOutOfRangeException(nameof(length));
-            }
+                throw new ArgumentOutOfRangeException("length");
 
-            if (index < 0 || index > (key?.Length ?? 0) - length)
-            {
-                throw new ArgumentOutOfRangeException(nameof(index));
-            }
+            if (index < 0 || index > (key == null ? 0 : key.Length) - length)
+                throw new ArgumentOutOfRangeException("index");
 
             if (_constrainedComparer == null)
-            {
                 throw new InvalidOperationException("Cannot do a constrained lookup on this collection.");
-            }
         
             return GetCore(key, index, length);
         }
@@ -404,7 +409,7 @@ bool ICollection<KeyValuePair<string, T>>.Remove(KeyValuePair<string, T> entry)
         /// <returns>true if removed; false if not (i.e. if the item wasn't in the HashSet)</returns>
         public bool Remove(string item)
         {
-            if (IsReadOnly)
+            if (_readOnly)
             {
                 ErrorUtilities.ThrowInvalidOperation("OM_NotSupportedReadOnlyCollection");
             }
@@ -454,19 +459,25 @@ public bool Remove(string item)
         /// <summary>
         /// Number of elements in this hashset
         /// </summary>
-        public int Count => _count;
+        public int Count
+        {
+            get { return _count; }
+        }
 
         /// <summary>
         /// Whether this is readonly
         /// </summary>
-        public bool IsReadOnly { get; private set; }
+        public bool IsReadOnly
+        {
+            get { return _readOnly; }
+        }
 
         /// <summary>
         /// Permanently prevent changes to the set.
         /// </summary>
         internal void MakeReadOnly()
         {
-            IsReadOnly = true;
+            _readOnly = true;
         }
 
         #endregion
@@ -480,7 +491,7 @@ public Enumerator GetEnumerator()
 
         IEnumerator<KeyValuePair<string, T>> IEnumerable<KeyValuePair<string, T>>.GetEnumerator()
         {
-            foreach (T entry in this)
+            foreach (var entry in this)
             {
                 yield return new KeyValuePair<string, T>(entry.Key, entry);
             }
@@ -506,16 +517,16 @@ public virtual void GetObjectData(SerializationInfo info, StreamingContext conte
         {
             if (info == null)
             {
-                throw new ArgumentNullException(nameof(info));
+                throw new ArgumentNullException("info");
             }
 
             // need to serialize version to avoid problems with serializing while enumerating
             info.AddValue(VersionName, _version);
             info.AddValue(ComparerName, _comparer, typeof(IEqualityComparer<string>));
-            info.AddValue(CapacityName, _buckets?.Length ?? 0);
+            info.AddValue(CapacityName, _buckets == null ? 0 : _buckets.Length);
             if (_buckets != null)
             {
-                var array = new T[_count];
+                T[] array = new T[_count];
                 CopyTo(array);
                 info.AddValue(ElementsName, array, typeof(T[]));
             }
@@ -546,7 +557,7 @@ public virtual void OnDeserialization(Object sender)
                 _buckets = new int[capacity];
                 _slots = new Slot[capacity];
 
-                var array = (T[])_siInfo.GetValue(ElementsName, typeof(T[]));
+                T[] array = (T[])_siInfo.GetValue(ElementsName, typeof(T[]));
 
                 if (array == null)
                 {
@@ -584,9 +595,7 @@ public void Add(T item)
         void IDictionary<string, T>.Add(string key, T item)
         {
             if (key != item.Key)
-            {
                 throw new InvalidOperationException();
-            }
 
             AddEvenIfPresent(item);
         }
@@ -610,7 +619,7 @@ public void UnionWith(IEnumerable<T> other)
         {
             if (other == null)
             {
-                throw new ArgumentNullException(nameof(other));
+                throw new ArgumentNullException("other");
             }
             Contract.EndContractBlock();
 
@@ -979,12 +988,10 @@ public bool SetEquals(IEnumerable<T> other) {
         void ICollection<KeyValuePair<string, T>>.CopyTo(KeyValuePair<string, T>[] array, int index)
         {
             if (index < 0 || Count > array.Length - index)
-            {
-                throw new ArgumentException(nameof(index));
-            }
+                throw new ArgumentException("index");
 
             int i = index;
-            foreach (T entry in this)
+            foreach (var entry in this)
             {
                 array[i] = new KeyValuePair<string, T>(entry.Key, entry);
                 i++;
@@ -998,20 +1005,20 @@ public void CopyTo(T[] array, int arrayIndex, int count)
         {
             if (array == null)
             {
-                throw new ArgumentNullException(nameof(array));
+                throw new ArgumentNullException("array");
             }
             Contract.EndContractBlock();
 
             // check array index valid index into array
             if (arrayIndex < 0)
             {
-                throw new ArgumentOutOfRangeException(nameof(arrayIndex));
+                throw new ArgumentOutOfRangeException("arrayIndex");
             }
 
             // also throw if count less than 0
             if (count < 0)
             {
-                throw new ArgumentOutOfRangeException(nameof(count));
+                throw new ArgumentOutOfRangeException("count");
             }
 
             // will array, starting at arrayIndex, be able to hold elements? Note: not
@@ -1019,7 +1026,7 @@ public void CopyTo(T[] array, int arrayIndex, int count)
             // count of 0; subsequent check takes care of the rest)
             if (arrayIndex > array.Length || count > array.Length - arrayIndex)
             {
-                throw new ArgumentException(nameof(arrayIndex));
+                throw new ArgumentException("arrayIndex");
             }
 
             int numCopied = 0;
@@ -1102,8 +1109,8 @@ public void TrimExcess()
                 // similar to IncreaseCapacity but moves down elements in case add/remove/etc
                 // caused fragmentation
                 int newSize = HashHelpers.GetPrime(_count);
-                var newSlots = new Slot[newSize];
-                var newBuckets = new int[newSize];
+                Slot[] newSlots = new Slot[newSize];
+                int[] newBuckets = new int[newSize];
 
                 // move down slots and rehash at the same time. newIndex keeps track of current 
                 // position in newSlots array
@@ -1180,13 +1187,13 @@ private void IncreaseCapacity()
             }
 
             // Able to increase capacity; copy elements to larger array and rehash
-            var newSlots = new Slot[newSize];
+            Slot[] newSlots = new Slot[newSize];
             if (_slots != null)
             {
                 Array.Copy(_slots, 0, newSlots, 0, _lastIndex);
             }
 
-            var newBuckets = new int[newSize];
+            int[] newBuckets = new int[newSize];
             for (int i = 0; i < _lastIndex; i++)
             {
                 int bucket = newSlots[i].hashCode % newSize;
@@ -1203,9 +1210,10 @@ private void IncreaseCapacity()
         /// ** MSBUILD: Modified so that it DOES add even if present. It will return false in that case, though.**
         /// </summary>
         /// <param name="value">value to find</param>
-        private void AddEvenIfPresent(T value)
+        /// <returns></returns>
+        private bool AddEvenIfPresent(T value)
         {
-            if (IsReadOnly)
+            if (_readOnly)
             {
                 ErrorUtilities.ThrowInvalidOperation("OM_NotSupportedReadOnlyCollection");
             }
@@ -1226,7 +1234,7 @@ private void AddEvenIfPresent(T value)
                     // as it may be a different object with the same name,
                     // and we want "last wins" semantics
                     _slots[i].value = value;
-                    return;
+                    return false;
                 }
             }
             int index;
@@ -1252,6 +1260,7 @@ private void AddEvenIfPresent(T value)
             _buckets[bucket] = index + 1;
             _count++;
             _version++;
+            return true;
         }
 
         /// <summary>
@@ -1260,19 +1269,20 @@ private void AddEvenIfPresent(T value)
         /// </summary>
         internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet<T> other)
         {
-            if (ReferenceEquals(this, other))
+            if (Object.ReferenceEquals(this, other))
             {
                 return true;
             }
 
-            if (Count != other.Count)
+            if (this.Count != other.Count)
             {
                 return false;
             }
 
+            T ours;
             foreach (T element in other)
             {
-                if (!TryGetValue(element.Key, out T ours) || !ReferenceEquals(element, ours))
+                if (!TryGetValue(element.Key, out ours) || !Object.ReferenceEquals(element, ours))
                 {
                     return false;
                 }
@@ -1616,9 +1626,10 @@ private unsafe ElementCount CheckUniqueAndUnfoundElements(IEnumerable<T> other,
         /// <summary>
         /// Copies this to an array. Used for DebugView
         /// </summary>
+        /// <returns></returns>
         internal T[] ToArray()
         {
-            var newArray = new T[Count];
+            T[] newArray = new T[Count];
             CopyTo(newArray);
             return newArray;
         }
@@ -1692,9 +1703,7 @@ private int InternalGetHashCode(string item, int index, int length)
         {
             // No need to check for null 'item' as we own all comparers
             if (_constrainedComparer != null)
-            {
                 return _constrainedComparer.GetHashCode(item, index, length) & Lower31BitMask;
-            }
 
             return InternalGetHashCode(item);
         }
@@ -1732,21 +1741,22 @@ internal struct Slot
 #if !SILVERLIGHT
         [Serializable()]
 #if FEATURE_SECURITY_PERMISSIONS
-        [HostProtection(MayLeakOnAbort = true)]
+        [System.Security.Permissions.HostProtection(MayLeakOnAbort = true)]
 #endif
 #endif
-        public struct Enumerator : IEnumerator<T>, IEnumerator
+        public struct Enumerator : IEnumerator<T>, System.Collections.IEnumerator
         {
-            private readonly RetrievableEntryHashSet<T> _set;
+            private RetrievableEntryHashSet<T> _set;
             private int _index;
-            private readonly int _version;
+            private int _version;
+            private T _current;
 
             internal Enumerator(RetrievableEntryHashSet<T> set)
             {
                 _set = set;
                 _index = 0;
                 _version = set._version;
-                Current = default(T);
+                _current = default(T);
             }
 
             public void Dispose()
@@ -1764,20 +1774,26 @@ public bool MoveNext()
                 {
                     if (_set._slots[_index].hashCode >= 0)
                     {
-                        Current = _set._slots[_index].value;
+                        _current = _set._slots[_index].value;
                         _index++;
                         return true;
                     }
                     _index++;
                 }
                 _index = _set._lastIndex + 1;
-                Current = default(T);
+                _current = default(T);
                 return false;
             }
 
-            public T Current { get; private set; }
+            public T Current
+            {
+                get
+                {
+                    return _current;
+                }
+            }
 
-            Object IEnumerator.Current
+            Object System.Collections.IEnumerator.Current
             {
                 get
                 {
@@ -1789,7 +1805,7 @@ Object IEnumerator.Current
                 }
             }
 
-            void IEnumerator.Reset()
+            void System.Collections.IEnumerator.Reset()
             {
                 if (_version != _set._version)
                 {
@@ -1797,7 +1813,7 @@ void IEnumerator.Reset()
                 }
 
                 _index = 0;
-                Current = default(T);
+                _current = default(T);
             }
         }
     }
diff --git a/src/Build/Collections/Triple.cs b/src/Build/Collections/Triple.cs
deleted file mode 100644
index e4a65ad7b16..00000000000
--- a/src/Build/Collections/Triple.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-//-----------------------------------------------------------------------
-// </copyright>
-// <summary>A struct of three objects</summary>
-//-----------------------------------------------------------------------
-
-namespace Microsoft.Build.Collections
-{
-    /// <summary>
-    /// A struct containing three objects
-    /// </summary>
-    /// <typeparam name="A">Type of first object</typeparam>
-    /// <typeparam name="B">Type of second object</typeparam>
-    /// <typeparam name="C">Type of third object</typeparam>
-    internal struct Triple<A, B, C>
-    {
-
-        /// <summary>
-        /// Constructor
-        /// </summary>
-        public Triple(A first, B second, C third)
-        {
-            First = first;
-            Second = second;
-            Third = third;
-        }
-
-        /// <summary>
-        /// First
-        /// </summary>
-        public A First { get; }
-
-        /// <summary>
-        /// Second
-        /// </summary>
-        public B Second { get; }
-
-        /// <summary>
-        /// Third
-        /// </summary>
-        public C Third { get; }
-    }
-}
diff --git a/src/Build/Collections/WeakReference.cs b/src/Build/Collections/WeakReference.cs
deleted file mode 100644
index 01fd34cb632..00000000000
--- a/src/Build/Collections/WeakReference.cs
+++ /dev/null
@@ -1,58 +0,0 @@
-// Copyright (c) Microsoft. All rights reserved.
-// Licensed under the MIT license. See LICENSE file in the project root for full license information.
-//-----------------------------------------------------------------------
-// </copyright>
-// <summary>Strongly typed weak reference</summary>
-//-----------------------------------------------------------------------
-
-using System;
-using Microsoft.Build.Shared;
-
-namespace Microsoft.Build.Collections
-{
-    /// <summary>
-    /// Strongly typed weak reference
-    /// </summary>
-    /// <typeparam name="T">Type of the target of the weak reference</typeparam>
-    internal class WeakReference<T>
-        where T : class
-    {
-        /// <summary>
-        /// Cache the hashcode so that it is still available even if the target has been 
-        /// collected. This allows this object to be still found in a table so it can be removed.
-        /// </summary>
-        private readonly int _hashcode;
-
-        /// <summary>
-        /// Backing weak reference
-        /// </summary>
-        private readonly WeakReference _weakReference;
-
-        /// <summary>
-        /// Constructor.
-        /// Target may not be null.
-        /// </summary>
-        internal WeakReference(T target)
-        {
-            ErrorUtilities.VerifyThrowInternalNull(target, nameof(target));
-
-            _weakReference = new WeakReference(target);
-            _hashcode = target.GetHashCode();
-        }
-
-        /// <summary>
-        /// Target wrapped by this weak reference.
-        /// If it returns null, its value may have been collected, or it may actually "wrap" null.
-        /// To distinguish these cases, compare the WeakReference object itself to WeakReference.Null.
-        /// </summary>
-        internal T Target => (T)_weakReference.Target;
-
-        /// <summary>
-        /// Returns the hashcode of the wrapped target.
-        /// </summary>
-        public override int GetHashCode()
-        {
-            return _hashcode;
-        }
-    }
-}
diff --git a/src/Build/Collections/WeakValueDictionary.cs b/src/Build/Collections/WeakValueDictionary.cs
index 1808176b447..ef787a9b5ab 100644
--- a/src/Build/Collections/WeakValueDictionary.cs
+++ b/src/Build/Collections/WeakValueDictionary.cs
@@ -5,6 +5,7 @@
 // <summary>Dictionary that does not prevent values from being garbage collected.</summary>
 //-----------------------------------------------------------------------
 
+using System;
 using System.Collections.Generic;
 using System.Diagnostics;
 using Microsoft.Build.Shared;
@@ -65,7 +66,7 @@ public IEnumerable<K> Keys
 
                 foreach (KeyValuePair<K, WeakReference<V>> pair in _dictionary)
                 {
-                    if (pair.Value?.Target != null)
+                    if (pair.Value?.TryGetTarget(out _) ?? false)
                     {
                         keys.Add(pair.Key);
                     }
@@ -95,9 +96,7 @@ public V this[K key]
                     return null;
                 }
 
-                V value = wrappedValue.Target;
-
-                if (value == null)
+                if (!wrappedValue.TryGetTarget(out V value))
                 {
                     _dictionary.Remove(key);
 
@@ -175,15 +174,13 @@ public bool TryGetValue(K key, out V value)
                 return true;
             }
 
-            value = wrappedValue.Target;
-
-            if (value == null)
+            if (!wrappedValue.TryGetTarget(out value))
             {
                 _dictionary.Remove(key);
                 return false;
             }
 
-            return result;
+            return true;
         }
 
         /// <summary>
@@ -213,9 +210,7 @@ public int Scavenge()
                     continue;
                 }
 
-                V value = entry.Value.Target;
-
-                if (value == null)
+                if (!entry.Value.TryGetTarget(out _))
                 {
                     remove = remove ?? new List<K>();
                     remove.Add(entry.Key);
diff --git a/src/Build/Construction/ProjectElementContainer.cs b/src/Build/Construction/ProjectElementContainer.cs
index 471e54f239c..b9e7db4cea4 100644
--- a/src/Build/Construction/ProjectElementContainer.cs
+++ b/src/Build/Construction/ProjectElementContainer.cs
@@ -84,33 +84,19 @@ public ICollection<ProjectElement> ChildrenReversed
         /// <summary>
         /// Number of children of any kind
         /// </summary>
-        public int Count { [DebuggerStepThrough]
-            get; private set;
-        }
+        public int Count { get; private set; }
 
         /// <summary>
         /// First child, if any, otherwise null.
         /// Cannot be set directly; use <see cref="PrependChild">PrependChild()</see>.
         /// </summary>
-        public ProjectElement FirstChild
-        {
-            [DebuggerStepThrough]
-            get;
-            [DebuggerStepThrough]
-            private set;
-        }
+        public ProjectElement FirstChild { get; private set; }
 
         /// <summary>
         /// Last child, if any, otherwise null.
         /// Cannot be set directly; use <see cref="AppendChild">AppendChild()</see>.
         /// </summary>
-        public ProjectElement LastChild
-        {
-            [DebuggerStepThrough]
-            get;
-            [DebuggerStepThrough]
-            private set;
-        }
+        public ProjectElement LastChild { get; private set; }
 
         /// <summary>
         /// Insert the child after the reference child.
diff --git a/src/Build/Construction/ProjectRootElement.cs b/src/Build/Construction/ProjectRootElement.cs
index 6cf94025b8d..46aa198aabf 100644
--- a/src/Build/Construction/ProjectRootElement.cs
+++ b/src/Build/Construction/ProjectRootElement.cs
@@ -363,8 +363,8 @@ public override string Condition
         /// </summary>
         public string DirectoryPath
         {
-            [DebuggerStepThrough] get { return _directory ?? String.Empty; }
-            internal set { _directory = value; }
+            get => _directory ?? String.Empty;
+            internal set => _directory = value;
             // Used during solution load to ensure solutions which were created from a file have a location.
         }
 
@@ -453,10 +453,7 @@ public Encoding Encoding
         public string DefaultTargets
         {
             [DebuggerStepThrough]
-            get
-            {
-                return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.defaultTargets);
-            }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.defaultTargets);
 
             [DebuggerStepThrough]
             set
@@ -473,10 +470,7 @@ public string DefaultTargets
         public string InitialTargets
         {
             [DebuggerStepThrough]
-            get
-            {
-                return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.initialTargets);
-            }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.initialTargets);
 
             [DebuggerStepThrough]
             set
@@ -495,10 +489,7 @@ public string InitialTargets
         public string Sdk
         {
             [DebuggerStepThrough]
-            get
-            {
-                return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.sdk);
-            }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.sdk);
 
             [DebuggerStepThrough]
             set
@@ -515,10 +506,7 @@ public string Sdk
         public string TreatAsLocalProperty
         {
             [DebuggerStepThrough]
-            get
-            {
-                return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.treatAsLocalProperty);
-            }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.treatAsLocalProperty);
 
             [DebuggerStepThrough]
             set
@@ -535,10 +523,7 @@ public string TreatAsLocalProperty
         public string ToolsVersion
         {
             [DebuggerStepThrough]
-            get
-            {
-                return ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.toolsVersion);
-            }
+            get => ProjectXmlUtilities.GetAttributeValue(XmlElement, XMakeAttributes.toolsVersion);
 
             [DebuggerStepThrough]
             set
diff --git a/src/Build/Construction/ProjectSdkElement.cs b/src/Build/Construction/ProjectSdkElement.cs
index c645668b44d..904d7cd800d 100644
--- a/src/Build/Construction/ProjectSdkElement.cs
+++ b/src/Build/Construction/ProjectSdkElement.cs
@@ -1,9 +1,6 @@
 // Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 //-----------------------------------------------------------------------
-// </copyright>
-// <summary>Definition of ProjectSdkElement class.</summary>
-//-----------------------------------------------------------------------
 
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
diff --git a/src/Build/Construction/ProjectUsingTaskParameterElement.cs b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
index 6c032444d62..bd1122042be 100644
--- a/src/Build/Construction/ProjectUsingTaskParameterElement.cs
+++ b/src/Build/Construction/ProjectUsingTaskParameterElement.cs
@@ -51,11 +51,7 @@ public override string Condition
         /// </summary>
         public string Name
         {
-            [DebuggerStepThrough]
-            get
-            {
-                return XmlElement.Name;
-            }
+            get => XmlElement.Name;
 
             set
             {
diff --git a/src/Build/Construction/Solution/SolutionFile.cs b/src/Build/Construction/Solution/SolutionFile.cs
index 16af6dbc6ab..a4fb99b55ed 100644
--- a/src/Build/Construction/Solution/SolutionFile.cs
+++ b/src/Build/Construction/Solution/SolutionFile.cs
@@ -631,8 +631,6 @@ private void ValidateSolutionFileVersion(string versionString)
         ///  EndProject
         /// 
         /// </summary>
-        /// <param name="firstLine"></param>
-        /// <returns></returns>
         private void ParseProject(string firstLine)
         {
             ErrorUtilities.VerifyThrow(!string.IsNullOrEmpty(firstLine), "ParseProject() got a null firstLine!");
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 4bebceb938b..bc273c2cc97 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -613,7 +613,7 @@ private enum BuildEnabledSetting
         /// Can never be null.
         /// Cannot be modified.
         /// </summary>
-        public ProjectCollection ProjectCollection { [DebuggerStepThrough] get; }
+        public ProjectCollection ProjectCollection { get; }
 
         /// <summary>
         /// The backing Xml project.
@@ -622,7 +622,7 @@ private enum BuildEnabledSetting
         /// <remarks>
         /// There is no setter here as that doesn't make sense. If you have a new ProjectRootElement, evaluate it into a new Project.
         /// </remarks>
-        public ProjectRootElement Xml { [DebuggerStepThrough] get; }
+        public ProjectRootElement Xml { get; }
 
         /// <summary>
         /// Whether this project is dirty such that it needs reevaluation.
@@ -2875,7 +2875,7 @@ internal class Data : IItemProvider<ProjectItem>, IPropertyProvider<ProjectPrope
             /// Almost always, projects have the same set of targets because they all import the same ones.
             /// So we keep around the last set seen and if ours is the same at the end of evaluation, unify the references.
             /// </summary>
-            private static System.WeakReference<RetrievableEntryHashSet<ProjectTargetInstance>> s_typicalTargetsCollection;
+            private static WeakReference<RetrievableEntryHashSet<ProjectTargetInstance>> s_typicalTargetsCollection;
 
             /// <summary>
             /// List of names of the properties that, while global, are still treated as overridable 
@@ -3197,7 +3197,7 @@ public void FinishEvaluation()
                 if (s_typicalTargetsCollection == null)
                 {
                     Targets.TrimExcess();
-                    s_typicalTargetsCollection = new System.WeakReference<RetrievableEntryHashSet<ProjectTargetInstance>>(Targets);
+                    s_typicalTargetsCollection = new WeakReference<RetrievableEntryHashSet<ProjectTargetInstance>>(Targets);
                 }
                 else
                 {
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 9965d5b98df..fda711c7117 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -861,7 +861,6 @@ internal int MaxNodeCount
         /// - So that the owner of this project collection can force the XML to be loaded again
         /// from disk, by doing <see cref="UnloadAllProjects"/>.
         /// </summary>
-        // No locks required because this field is only set in the constructor.
         internal ProjectRootElementCache ProjectRootElementCache { get; }
 
         /// <summary>
@@ -1258,7 +1257,7 @@ public void UnloadProject(ProjectRootElement projectRootElement)
         {
             using (_locker.EnterWriteLock())
             {
-                ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, "projectRootElement");
+                ErrorUtilities.VerifyThrowArgumentNull(projectRootElement, nameof(projectRootElement));
 
                 Project conflictingProject = LoadedProjects.FirstOrDefault(project => project.UsesProjectRootElement(projectRootElement));
 
@@ -1430,17 +1429,16 @@ public bool TryUnloadProject(ProjectRootElement projectRootElement)
         /// </summary>
         internal void OnAfterRenameLoadedProject(string oldFullPathIfAny, Project project)
         {
-            using (_locker.EnterWriteLock())
+            if (project.FullPath == null)
             {
-                if (project.FullPath == null)
-                {
-                    return;
-                }
+                return;
+            }
 
+            using (_locker.EnterWriteLock())
+            {
                 if (oldFullPathIfAny != null)
                 {
                     bool existed = _loadedProjects.RemoveProject(oldFullPathIfAny, project);
-
                     ErrorUtilities.VerifyThrowInvalidOperation(existed, "OM_ProjectWasNotLoaded");
                 }
 
@@ -1510,7 +1508,7 @@ protected virtual void Dispose(bool disposing)
         /// <returns><c>true</c> if the toolset was found and removed; <c>false</c> otherwise.</returns>
         private bool RemoveToolsetInternal(string toolsVersion)
         {
-            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, "toolsVersion");
+            ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
             Debug.Assert(_locker.IsWriteLockHeld);
 
             if (!_toolsets.ContainsKey(toolsVersion))
@@ -1531,7 +1529,7 @@ private bool RemoveToolsetInternal(string toolsVersion)
         /// </summary>
         private void RegisterLoggerInternal(ILogger logger)
         {
-            ErrorUtilities.VerifyThrowArgumentNull(logger, "logger");
+            ErrorUtilities.VerifyThrowArgumentNull(logger, nameof(logger));
             Debug.Assert(_locker.IsWriteLockHeld);
             _loggingService.RegisterLogger(new ReusableLogger(logger));
         }
@@ -1814,7 +1812,7 @@ internal class ReusableLogger : INodeLogger, IEventSource3
             /// </summary>
             public ReusableLogger(ILogger originalLogger)
             {
-                ErrorUtilities.VerifyThrowArgumentNull(originalLogger, "originalLogger");
+                ErrorUtilities.VerifyThrowArgumentNull(originalLogger, nameof(originalLogger));
                 _originalLogger = originalLogger;
             }
 
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index 86d75870473..07773fa689b 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -51,11 +51,7 @@ private ProjectPropertyInstance(string name, string escapedValue)
         /// the project's properties table.
         /// </remarks>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        public string Name
-        {
-            [DebuggerStepThrough]
-            get => _name;
-        }
+        public string Name => _name;
 
         /// <summary>
         /// Evaluated value of the property.
@@ -90,31 +86,19 @@ public string EvaluatedValue
         /// Setter assumes caller has protected global properties, if necessary.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        string IProperty.EvaluatedValueEscaped
-        {
-            [DebuggerStepThrough]
-            get => _escapedValue;
-        }
+        string IProperty.EvaluatedValueEscaped => _escapedValue;
 
         /// <summary>
         /// Implementation of IKeyed exposing the property name
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        string IKeyed.Key
-        {
-            [DebuggerStepThrough]
-            get => Name;
-        }
+        string IKeyed.Key => Name;
 
         /// <summary>
         /// Implementation of IValued
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        string IValued.EscapedValue
-        {
-            [DebuggerStepThrough]
-            get => _escapedValue;
-        }
+        string IValued.EscapedValue => _escapedValue;
 
         #region IEquatable<ProjectPropertyInstance> Members
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 7f50ecb73cf..90e0fd9bd5a 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -388,9 +388,7 @@
     <Compile Include="Collections\PropertyDictionary.cs" />
     <Compile Include="..\Shared\ReadOnlyCollection.cs" />
     <Compile Include="Collections\ReadOnlyConvertingDictionary.cs" />
-    <Compile Include="Collections\Triple.cs" />
     <!-- ######################## -->
-    <Compile Include="Collections\WeakReference.cs" />
     <Compile Include="Collections\WeakValueDictionary.cs" />
     <!-- #### CONSTRUCTION MODEL ### -->
     <Compile Include="Construction\ProjectElement.cs" />
diff --git a/src/Shared/OpportunisticIntern.cs b/src/Shared/OpportunisticIntern.cs
index c87f9f86ee8..ea91a1de46d 100644
--- a/src/Shared/OpportunisticIntern.cs
+++ b/src/Shared/OpportunisticIntern.cs
@@ -21,7 +21,6 @@
 #else
 using MSBuildConstants = Microsoft.Build.Shared.MSBuildConstants;
 #endif
-    
 
 namespace Microsoft.Build
 {
@@ -37,7 +36,7 @@ namespace Microsoft.Build
     /// The thresholds and sizes were determined by experimentation to give the best number of bytes saved
     /// at reasonable elapsed time cost.
     /// </summary>
-    static internal class OpportunisticIntern
+    internal static class OpportunisticIntern
     {
         private static readonly bool s_useSimpleConcurrency = Traits.Instance.UseSimpleInternConcurrency;
 
@@ -59,28 +58,28 @@ static internal class OpportunisticIntern
         /// <summary>
         /// The smallest size a string can be to be considered small.
         /// </summary>
-        private static readonly int s_smallMruThreshhold = AssignViaEnvironment("MSBUILDSMALLINTERNTHRESHOLD", 50);
+        private static readonly int s_smallMruThreshold = AssignViaEnvironment("MSBUILDSMALLINTERNTHRESHOLD", 50);
 
         /// <summary>
         /// The smallest size a string can be to be considered large.
         /// </summary>
-        private static readonly int s_largeMruThreshhold = AssignViaEnvironment("MSBUILDLARGEINTERNTHRESHOLD", 70);
+        private static readonly int s_largeMruThreshold = AssignViaEnvironment("MSBUILDLARGEINTERNTHRESHOLD", 70);
 
         /// <summary>
         /// The smallest size a string can be to be considered huge.
         /// </summary>
-        private static readonly int s_hugeMruThreshhold = AssignViaEnvironment("MSBUILDHUGEINTERNTHRESHOLD", 200);
+        private static readonly int s_hugeMruThreshold = AssignViaEnvironment("MSBUILDHUGEINTERNTHRESHOLD", 200);
 
         /// <summary>
         /// The smallest size a string can be to be ginormous.
         /// 8K for large object heap.
         /// </summary>
-        private static readonly int s_ginormousThreshhold = AssignViaEnvironment("MSBUILDGINORMOUSINTERNTHRESHOLD", 8000);
+        private static readonly int s_ginormousThreshold = AssignViaEnvironment("MSBUILDGINORMOUSINTERNTHRESHOLD", 8000);
 
         /// <summary>
         /// Manages the separate MRU lists.
         /// </summary>
-        private static BucketedPrioritizedStringList s_si = new BucketedPrioritizedStringList(/*gatherStatistics*/ false, s_smallMruSize, s_largeMruSize, s_hugeMruSize, s_smallMruThreshhold, s_largeMruThreshhold, s_hugeMruThreshhold, s_ginormousThreshhold, s_useSimpleConcurrency);
+        private static BucketedPrioritizedStringList s_si = new BucketedPrioritizedStringList(/*gatherStatistics*/ false, s_smallMruSize, s_largeMruSize, s_hugeMruSize, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
 
         #region Statistics
         /// <summary>
@@ -118,10 +117,7 @@ internal interface IInternable
             /// <summary>
             /// Indexer into the target. Presumed to be fast.
             /// </summary>
-            char this[int index]
-            {
-                get;
-            }
+            char this[int index] { get; }
 
             /// <summary>
             /// Convert target to string. Presumed to be slow (and will be called just once).
@@ -143,13 +139,12 @@ char this[int index]
         /// <summary>
         /// Assign an int from an environment variable. If its not present, use the default.
         /// </summary>
-        static internal int AssignViaEnvironment(string env, int @default)
+        internal static int AssignViaEnvironment(string env, int @default)
         {
-            string threshhold = Environment.GetEnvironmentVariable(env);
-            if (!String.IsNullOrEmpty(threshhold))
+            string threshold = Environment.GetEnvironmentVariable(env);
+            if (!String.IsNullOrEmpty(threshold))
             {
-                int result;
-                if (Int32.TryParse(threshhold, out result))
+                if (Int32.TryParse(threshold, out int result))
                 {
                     return result;
                 }
@@ -164,11 +159,11 @@ static internal int AssignViaEnvironment(string env, int @default)
         internal static void EnableStatisticsGathering()
         {
             // Statistics include several 'what if' scenarios such as doubling the size of the MRU lists.
-            s_si = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize, s_largeMruSize, s_hugeMruSize, s_smallMruThreshhold, s_largeMruThreshhold, s_hugeMruThreshhold, s_ginormousThreshhold, s_useSimpleConcurrency);
-            s_whatIfInfinite = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, Int32.MaxValue, Int32.MaxValue, Int32.MaxValue, s_smallMruThreshhold, s_largeMruThreshhold, s_hugeMruThreshhold, s_ginormousThreshhold, s_useSimpleConcurrency);
-            s_whatIfDoubled = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize * 2, s_largeMruSize * 2, s_hugeMruSize * 2, s_smallMruThreshhold, s_largeMruThreshhold, s_hugeMruThreshhold, s_ginormousThreshhold, s_useSimpleConcurrency);
-            s_whatIfHalved = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize / 2, s_largeMruSize / 2, s_hugeMruSize / 2, s_smallMruThreshhold, s_largeMruThreshhold, s_hugeMruThreshhold, s_ginormousThreshhold, s_useSimpleConcurrency);
-            s_whatIfZero = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, 0, 0, 0, s_smallMruThreshhold, s_largeMruThreshhold, s_hugeMruThreshhold, s_ginormousThreshhold, s_useSimpleConcurrency);
+            s_si = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize, s_largeMruSize, s_hugeMruSize, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
+            s_whatIfInfinite = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, Int32.MaxValue, Int32.MaxValue, Int32.MaxValue, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
+            s_whatIfDoubled = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize * 2, s_largeMruSize * 2, s_hugeMruSize * 2, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
+            s_whatIfHalved = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, s_smallMruSize / 2, s_largeMruSize / 2, s_hugeMruSize / 2, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
+            s_whatIfZero = new BucketedPrioritizedStringList(/*gatherStatistics*/ true, 0, 0, 0, s_smallMruThreshold, s_largeMruThreshold, s_hugeMruThreshold, s_ginormousThreshold, s_useSimpleConcurrency);
         }
 
         /// <summary>
@@ -252,7 +247,7 @@ internal struct StringBuilderInternTarget : IInternable
             /// <summary>
             /// The held StringBuilder
             /// </summary>
-            private StringBuilder _target;
+            private readonly StringBuilder _target;
 
             /// <summary>
             /// Pointless comment about constructor.
@@ -265,24 +260,12 @@ internal StringBuilderInternTarget(StringBuilder target)
             /// <summary>
             /// The length of the target.
             /// </summary>
-            public int Length
-            {
-                get
-                {
-                    return _target.Length;
-                }
-            }
+            public int Length => _target.Length;
 
             /// <summary>
             /// Indexer into the target. Presumed to be fast.
             /// </summary>
-            public char this[int index]
-            {
-                get
-                {
-                    return _target[index];
-                }
-            }
+            public char this[int index] => _target[index];
 
             /// <summary>
             /// Never reference equals to string.
@@ -343,17 +326,12 @@ internal struct CharArrayInternTarget : IInternable
             /// <summary>
             /// Start index for the string
             /// </summary>
-            private int _startIndex;
-
-            /// <summary>
-            /// Number of characters.
-            /// </summary>
-            private int _count;
+            private readonly int _startIndex;
 
             /// <summary>
             /// The held array
             /// </summary>
-            private char[] _target;
+            private readonly char[] _target;
 
             /// <summary>
             /// Pointless comment about constructor.
@@ -376,19 +354,13 @@ internal CharArrayInternTarget(char[] target, int startIndex, int count)
 #endif
                 _target = target;
                 _startIndex = startIndex;
-                _count = count;
+                Length = count;
             }
 
             /// <summary>
             /// The length of the target.
             /// </summary>
-            public int Length
-            {
-                get
-                {
-                    return _count;
-                }
-            }
+            public int Length { get; }
 
             /// <summary>
             /// Indexer into the target. Presumed to be fast.
@@ -397,7 +369,7 @@ public char this[int index]
             {
                 get
                 {
-                    if (index > _startIndex + _count - 1 || index < 0)
+                    if (index > _startIndex + Length - 1 || index < 0)
                     {
                         ErrorUtilities.ThrowInternalError("past end");
                     }
@@ -422,7 +394,7 @@ public string ExpensiveConvertToString()
                 // PERF NOTE: This will be an allocation hot-spot because the char[] is finally determined to
                 // not be internable. There is still only one conversion of char[] into string it has just
                 // moved into this single spot.
-                return new String(_target, _startIndex, _count);
+                return new String(_target, _startIndex, Length);
             }
 
             /// <summary>
@@ -431,11 +403,11 @@ public string ExpensiveConvertToString()
             public bool IsOrdinalEqualToStringOfSameLength(string other)
             {
 #if DEBUG
-                ErrorUtilities.VerifyThrow(other.Length == this.Length, "should be same length");
+                ErrorUtilities.VerifyThrow(other.Length == Length, "should be same length");
 #endif
                 // Backwards because the end of the string is (by observation of Australian Government build) more likely to be different earlier in the loop.
                 // For example, C:\project1, C:\project2
-                for (int i = _count - 1; i >= 0; --i)
+                for (int i = Length - 1; i >= 0; --i)
                 {
                     if (_target[i + _startIndex] != other[i])
                     {
@@ -463,7 +435,7 @@ internal struct StringInternTarget : IInternable
             /// <summary>
             /// Stores the wrapped string.
             /// </summary>
-            private string _target;
+            private readonly string _target;
 
             /// <summary>
             /// Constructor of the class
@@ -471,27 +443,21 @@ internal struct StringInternTarget : IInternable
             /// <param name="target">The string to wrap</param>
             internal StringInternTarget(string target)
             {
-                ErrorUtilities.VerifyThrowArgumentLength(target, "target");
+                ErrorUtilities.VerifyThrowArgumentLength(target, nameof(target));
                 _target = target;
             }
 
             /// <summary>
             /// Gets the length of the target string.
             /// </summary>
-            public int Length
-            {
-                get { return _target.Length; }
-            }
+            public int Length => _target.Length;
 
             /// <summary>
             /// Gets the n character in the target string.
             /// </summary>
             /// <param name="index">Index of the character to gather.</param>
             /// <returns>The character in the position marked by index.</returns>
-            public char this[int index]
-            {
-                get { return _target[index]; }
-            }
+            public char this[int index] => _target[index];
 
             /// <summary>
             /// Returns the target which is already a string.
@@ -533,54 +499,54 @@ private class BucketedPrioritizedStringList
             /// <summary>
             /// The small string Mru list.
             /// </summary>
-            private PrioritizedStringList _smallMru;
+            private readonly PrioritizedStringList _smallMru;
 
             /// <summary>
             /// The large string Mru list.
             /// </summary>
-            private PrioritizedStringList _largeMru;
+            private readonly PrioritizedStringList _largeMru;
 
             /// <summary>
             /// The huge string Mru list.
             /// </summary>
-            private PrioritizedStringList _hugeMru;
+            private readonly PrioritizedStringList _hugeMru;
 
             /// <summary>
             /// Three most recently used strings over 8K.
             /// </summary>
-            private LinkedList<WeakReference> _ginormous = new LinkedList<WeakReference>();
+            private readonly LinkedList<WeakReference> _ginormous = new LinkedList<WeakReference>();
 
             /// <summary>
             /// The smallest size a string can be to be considered small.
             /// </summary>
-            private int _smallMruThreshhold;
+            private readonly int _smallMruThreshold;
 
             /// <summary>
             /// The smallest size a string can be to be considered large.
             /// </summary>
-            private int _largeMruThreshhold;
+            private readonly int _largeMruThreshold;
 
             /// <summary>
             /// The smallest size a string can be to be considered huge.
             /// </summary>
-            private int _hugeMruThreshhold;
+            private readonly int _hugeMruThreshold;
 
             /// <summary>
             /// The smallest size a string can be to be ginormous.
             /// </summary>
-            private int _ginormousThreshhold;
+            private readonly int _ginormousThreshold;
 
             private readonly bool _useSimpleConcurrency;
 
 #if !CLR2COMPATIBILITY
-            private ConcurrentDictionary<string, string> _internedStrings = new ConcurrentDictionary<string, string>(StringComparer.Ordinal);
+            private readonly ConcurrentDictionary<string, string> _internedStrings = new ConcurrentDictionary<string, string>(StringComparer.Ordinal);
 #endif
 
             #region Statistics
             /// <summary>
             /// Whether or not to gather statistics
             /// </summary>
-            private bool _gatherStatistics = false;
+            private readonly bool _gatherStatistics;
 
             /// <summary>
             /// Number of times interning worked.
@@ -625,36 +591,36 @@ private class BucketedPrioritizedStringList
             /// <summary>
             /// Whether or not to track ginormous strings.
             /// </summary>
-            private bool _dontTrack;
+            private readonly bool _dontTrack;
 
             /// <summary>
             /// The time spent interning.
             /// </summary>
-            private Stopwatch _stopwatch;
+            private readonly Stopwatch _stopwatch;
 
             /// <summary>
             /// Strings which did not intern
             /// </summary>
-            private Dictionary<string, int> _missedStrings;
+            private readonly Dictionary<string, int> _missedStrings;
 
             /// <summary>
             /// Strings which we didn't attempt to intern
             /// </summary>
-            private Dictionary<string, int> _rejectedStrings;
+            private readonly Dictionary<string, int> _rejectedStrings;
 
             /// <summary>
             /// Number of ginormous strings to keep
             /// By observation of Auto7, there are about three variations of the huge solution config blob
             /// There aren't really any other strings of this size, but make it 10 to be sure. (There will barely be any misses)
             /// </summary>
-            private int _ginormousSize = 10;
+            private const int GinormousSize = 10;
 
             #endregion
 
             /// <summary>
             /// Construct.
             /// </summary>
-            internal BucketedPrioritizedStringList(bool gatherStatistics, int smallMruSize, int largeMruSize, int hugeMruSize, int smallMruThreshhold, int largeMruThreshhold, int hugeMruThreshhold, int ginormousThreshhold, bool useSimpleConcurrency)
+            internal BucketedPrioritizedStringList(bool gatherStatistics, int smallMruSize, int largeMruSize, int hugeMruSize, int smallMruThreshold, int largeMruThreshold, int hugeMruThreshold, int ginormousThreshold, bool useSimpleConcurrency)
             {
                 if (smallMruSize == 0 && largeMruSize == 0 && hugeMruSize == 0)
                 {
@@ -664,13 +630,13 @@ internal BucketedPrioritizedStringList(bool gatherStatistics, int smallMruSize,
                 _smallMru = new PrioritizedStringList(smallMruSize);
                 _largeMru = new PrioritizedStringList(largeMruSize);
                 _hugeMru = new PrioritizedStringList(hugeMruSize);
-                _smallMruThreshhold = smallMruThreshhold;
-                _largeMruThreshhold = largeMruThreshhold;
-                _hugeMruThreshhold = hugeMruThreshhold;
-                _ginormousThreshhold = ginormousThreshhold;
+                _smallMruThreshold = smallMruThreshold;
+                _largeMruThreshold = largeMruThreshold;
+                _hugeMruThreshold = hugeMruThreshold;
+                _ginormousThreshold = ginormousThreshold;
                 _useSimpleConcurrency = useSimpleConcurrency;
 
-                for (int i = 0; i < _ginormousSize; i++)
+                for (int i = 0; i < GinormousSize; i++)
                 {
                     _ginormous.AddFirst(new WeakReference(String.Empty));
                 }
@@ -701,8 +667,7 @@ internal string InterningToString(IInternable candidate)
                 }
                 else
                 {
-                    string result;
-                    TryIntern(candidate, out result);
+                    TryIntern(candidate, out string result);
                     return result;
                 }
             }
@@ -716,7 +681,7 @@ internal void ReportStatistics(string heading)
                 Console.WriteLine("\n{0}{1}{0}", new String('=', 41 - (title.Length / 2)), title);
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Hits", _internHits, "hits");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Misses", _internMisses, "misses");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Rejects (as shorter than " + s_smallMruThreshhold + " bytes)", _internRejects, "rejects");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Intern Rejects (as shorter than " + s_smallMruThreshold + " bytes)", _internRejects, "rejects");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Strings*", _internEliminatedStrings, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Eliminated Chars", _internEliminatedChars, "chars");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Estimated Eliminated Bytes", _internEliminatedChars * 2, "bytes");
@@ -724,21 +689,21 @@ internal void ReportStatistics(string heading)
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
                 KeyValuePair<int, int> held = _smallMru.Statistics();
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings MRU Size", s_smallMruSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings (>=" + _smallMruThreshhold + " chars) Held", held.Key, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Strings (>=" + _smallMruThreshold + " chars) Held", held.Key, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Small Estimated Bytes Held", held.Value * 2, "bytes");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
                 held = _largeMru.Statistics();
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings MRU Size", s_largeMruSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings  (>=" + _largeMruThreshhold + " chars) Held", held.Key, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Strings  (>=" + _largeMruThreshold + " chars) Held", held.Key, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Large Estimated Bytes Held", held.Value * 2, "bytes");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
                 held = _hugeMru.Statistics();
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings MRU Size", s_hugeMruSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings  (>=" + _hugeMruThreshhold + " chars) Held", held.Key, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Strings  (>=" + _hugeMruThreshold + " chars) Held", held.Key, "strings");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Huge Estimated Bytes Held", held.Value * 2, "bytes");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous Strings MRU Size", _ginormousSize, "strings");
-                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous (>=" + _ginormousThreshhold + " chars)  Hits", _ginormousHits, "hits");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous Strings MRU Size", GinormousSize, "strings");
+                Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous (>=" + _ginormousThreshold + " chars)  Hits", _ginormousHits, "hits");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous Misses", _ginormousMisses, "misses");
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Ginormous Chars Saved", _ginormousCharsSaved, "chars");
                 Console.WriteLine("|---------------------------------------------------------------------------------|");
@@ -747,7 +712,7 @@ internal void ReportStatistics(string heading)
                 Console.WriteLine("||{0,50}|{1,20:N0}|{2,8}|", "Time Spent Interning", _stopwatch.ElapsedMilliseconds, "ms");
                 Console.WriteLine("{0}{0}", new String('=', 41));
 
-                var topMissingString =
+                IEnumerable<string> topMissingString =
                     _missedStrings
                     .OrderByDescending(kv => kv.Value * kv.Key.Length)
                     .Take(15)
@@ -757,7 +722,7 @@ internal void ReportStatistics(string heading)
                 Console.WriteLine("##########Top Missed Strings:  \n{0} ", String.Join("\n==============\n", topMissingString.ToArray()));
                 Console.WriteLine();
 
-                var topRejectedString =
+                IEnumerable<string> topRejectedString =
                     _rejectedStrings
                     .OrderByDescending(kv => kv.Value * kv.Key.Length)
                     .Take(15)
@@ -949,7 +914,7 @@ internal void ReportStatistics(string heading)
                             }
                         }
                     }
-                    else if (length > _ginormousThreshhold)
+                    else if (length > _ginormousThreshold)
                     {
                         lock (_ginormous)
                         {
@@ -957,8 +922,7 @@ internal void ReportStatistics(string heading)
 
                             while (current != null)
                             {
-                                string last = current.Value.Target as string;
-                                if (last != null && last.Length == candidate.Length && candidate.IsOrdinalEqualToStringOfSameLength(last))
+                                if (current.Value.Target is string last && last.Length == candidate.Length && candidate.IsOrdinalEqualToStringOfSameLength(last))
                                 {
                                     interned = last;
                                     _ginormousHits++;
@@ -976,7 +940,7 @@ internal void ReportStatistics(string heading)
                             _ginormousMisses++;
                             interned = candidate.ExpensiveConvertToString();
 
-                            var lastNode = _ginormous.Last;
+                            LinkedListNode<WeakReference> lastNode = _ginormous.Last;
                             _ginormous.RemoveLast();
                             _ginormous.AddFirst(lastNode);
                             lastNode.Value.Target = interned;
@@ -992,21 +956,21 @@ internal void ReportStatistics(string heading)
                         return true;
                     }
 #endif
-                    else if (length >= _hugeMruThreshhold)
+                    else if (length >= _hugeMruThreshold)
                     {
                         lock (_hugeMru)
                         {
                             return _hugeMru.TryGet(candidate, out interned);
                         }
                     }
-                    else if (length >= _largeMruThreshhold)
+                    else if (length >= _largeMruThreshold)
                     {
                         lock (_largeMru)
                         {
                             return _largeMru.TryGet(candidate, out interned);
                         }
                     }
-                    else if (length >= _smallMruThreshhold)
+                    else if (length >= _smallMruThreshold)
                     {
                         lock (_smallMru)
                         {
@@ -1024,9 +988,8 @@ internal void ReportStatistics(string heading)
             /// </summary>
             private string InternWithStatistics(IInternable candidate)
             {
-                string result;
                 _stopwatch.Start();
-                bool? interned = TryIntern(candidate, out result);
+                bool? interned = TryIntern(candidate, out string result);
                 _stopwatch.Stop();
 
                 if (interned.HasValue && !interned.Value)
@@ -1034,8 +997,7 @@ private string InternWithStatistics(IInternable candidate)
                     // Could not intern.
                     _internMisses++;
 
-                    int priorCount = 0;
-                    _missedStrings.TryGetValue(result, out priorCount);
+                    _missedStrings.TryGetValue(result, out int priorCount);
                     _missedStrings[result] = priorCount + 1;
 
                     return result;
@@ -1045,8 +1007,7 @@ private string InternWithStatistics(IInternable candidate)
                     // Decided not to attempt interning
                     _internRejects++;
 
-                    int priorCount = 0;
-                    _rejectedStrings.TryGetValue(result, out priorCount);
+                    _rejectedStrings.TryGetValue(result, out int priorCount);
                     _rejectedStrings[result] = priorCount + 1;
 
                     return result;
@@ -1158,8 +1119,7 @@ internal bool TryGet(IInternable candidate, out string interned)
                     {
                         // Not found. Create a new entry and place it at the top.
                         Node old = _mru;
-                        _mru = new Node(candidate.ExpensiveConvertToString());
-                        _mru.Next = old;
+                        _mru = new Node(candidate.ExpensiveConvertToString()) { Next = old };
 
                         // Cache miss. Use this opportunity to discard any element over the max size.
                         if (itemCount >= _size && secondPrior != null)
@@ -1211,7 +1171,7 @@ internal Node(string value)
                     /// <summary>
                     /// The held string.
                     /// </summary>
-                    internal string Value { get; private set; }
+                    internal string Value { get; }
                 }
             }
         }
