diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index b9f70530519..4bb0202ce95 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,9 +1,9 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ProductDependencies>
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.23408.2">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.source-build-reference-packages" Version="8.0.0-alpha.1.23414.1">
       <Uri>https://github.com/dotnet/source-build-reference-packages</Uri>
-      <Sha>41f1a158d460e11ded6cffd6340f9e671e2b0a5c</Sha>
+      <Sha>45f5554ac6813e1e155c47fd80ec146c684f65e8</Sha>
       <SourceBuild RepoName="source-build-reference-packages" ManagedOnly="true" />
     </Dependency>
     <!-- Necessary for source-build due to being a transitive dependency of System.Reflection.MetadataLoadContext.
@@ -43,28 +43,28 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23404.2">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.23411.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1d39647dd408f7afd99cce01f26bba1d6bdeb248</Sha>
+      <Sha>9b2af35a6702526dc8a7c5fcadcc44efd0dca170</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23381.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
+    <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23408.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
       <Uri>https://github.com/dotnet/xliff-tasks</Uri>
-      <Sha>d3553ca27fb1c128f302f52b73c0079e65d62ea8</Sha>
+      <Sha>493329204079519072f0241ed26f692bdee0d60c</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.8.0-preview.1.56">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.8.0-preview.1.60">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>a39baac1e0fc3126a767b7261beb3804a28e4a97</Sha>
+      <Sha>c94490d7af33f4198ed552787623cf9227996006</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.8.0-1.23406.1">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.8.0-1.23412.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>e3ede0e8fee242f6bf988f3c71a6ba5e8217faa3</Sha>
+      <Sha>3793c732f895cca7d98d44e85b38c241e309e425</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.23404.2">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.23411.1">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>1d39647dd408f7afd99cce01f26bba1d6bdeb248</Sha>
+      <Sha>9b2af35a6702526dc8a7c5fcadcc44efd0dca170</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 19d43220e2d..98fa9f7bb16 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,11 +48,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.23404.2</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.23411.1</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.8.0-1.23406.1</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.8.0-preview.1.56</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.8.0-1.23412.1</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.8.0-preview.1.60</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>7.0.3</SystemTextJsonVersion>
     <SystemThreadingTasksDataflowVersion>7.0.0</SystemThreadingTasksDataflowVersion>
diff --git a/eng/common/native/init-distro-rid.sh b/eng/common/native/init-distro-rid.sh
new file mode 100644
index 00000000000..aba9fe24028
--- /dev/null
+++ b/eng/common/native/init-distro-rid.sh
@@ -0,0 +1,132 @@
+#!/usr/bin/env bash
+
+# getNonPortableDistroRid
+#
+# Input:
+#   targetOs: (str)
+#   targetArch: (str)
+#   rootfsDir: (str)
+#
+# Return:
+#   non-portable rid
+getNonPortableDistroRid()
+{
+    local targetOs="$1"
+    local targetArch="$2"
+    local rootfsDir="$3"
+    local nonPortableRid=""
+
+    if [ "$targetOs" = "linux" ]; then
+        if [ -e "${rootfsDir}/etc/os-release" ]; then
+            source "${rootfsDir}/etc/os-release"
+
+            if [[ "${ID}" == "rhel" || "${ID}" == "rocky" || "${ID}" == "alpine" ]]; then
+                # remove the last version digit
+                VERSION_ID="${VERSION_ID%.*}"
+            fi
+
+            if [[ "${VERSION_ID:-}" =~ ^([[:digit:]]|\.)+$ ]]; then
+                nonPortableRid="${ID}.${VERSION_ID}-${targetArch}"
+            else
+                # Rolling release distros either do not set VERSION_ID, set it as blank or
+                # set it to non-version looking string (such as TEMPLATE_VERSION_ID on ArchLinux);
+                # so omit it here to be consistent with everything else.
+                nonPortableRid="${ID}-${targetArch}"
+            fi
+
+        elif [ -e "${rootfsDir}/android_platform" ]; then
+            source "$rootfsDir"/android_platform
+            nonPortableRid="$RID"
+        fi
+    fi
+
+    if [ "$targetOs" = "freebsd" ]; then
+        # $rootfsDir can be empty. freebsd-version is shell script and it should always work.
+        __freebsd_major_version=$($rootfsDir/bin/freebsd-version | { read v; echo "${v%%.*}"; })
+        nonPortableRid="freebsd.$__freebsd_major_version-${targetArch}"
+    elif command -v getprop && getprop ro.product.system.model 2>&1 | grep -qi android; then
+        __android_sdk_version=$(getprop ro.build.version.sdk)
+        nonPortableRid="android.$__android_sdk_version-${targetArch}"
+    elif [ "$targetOs" = "illumos" ]; then
+        __uname_version=$(uname -v)
+        case "$__uname_version" in
+            omnios-*)
+                __omnios_major_version=$(echo "${__uname_version:8:2}")
+                nonPortableRid=omnios."$__omnios_major_version"-"$targetArch"
+            ;;
+            joyent_*)
+                __smartos_major_version=$(echo "${__uname_version:7:4}")
+                nonPortableRid=smartos."$__smartos_major_version"-"$targetArch"
+            ;;
+            illumos_*)
+                nonPortableRid=openindiana-"$targetArch"
+            ;;
+        esac
+    elif [ "$targetOs" = "solaris" ]; then
+        __uname_version=$(uname -v)
+        __solaris_major_version=$(echo "${__uname_version%.*}")
+        nonPortableRid=solaris."$__solaris_major_version"-"$targetArch"
+    elif [ "$targetOs" = "haiku" ]; then
+        __uname_release=$(uname -r)
+        nonPortableRid=haiku.r"$__uname_release"-"$targetArch"
+    fi
+
+    echo "$(echo $nonPortableRid | tr '[:upper:]' '[:lower:]')"
+}
+
+# initDistroRidGlobal
+#
+# Input:
+#   os: (str)
+#   arch: (str)
+#   isPortable: (int)
+#   rootfsDir?: (nullable:string)
+#
+# Return:
+#   None
+#
+# Notes:
+#
+# It is important to note that the function does not return anything, but it
+# exports the following variables on success:
+#
+#   __DistroRid   : Non-portable rid of the target platform.
+#   __PortableTargetOS  : OS-part of the portable rid that corresponds to the target platform.
+#
+initDistroRidGlobal()
+{
+    local targetOs="$1"
+    local targetArch="$2"
+    local isPortable="$3"
+    local rootfsDir=""
+    if [ "$#" -ge 4 ]; then
+        rootfsDir="$4"
+    fi
+
+    if [ -n "${rootfsDir}" ]; then
+        # We may have a cross build. Check for the existence of the rootfsDir
+        if [ ! -e "${rootfsDir}" ]; then
+            echo "Error rootfsDir has been passed, but the location is not valid."
+            exit 1
+        fi
+    fi
+
+    __DistroRid=$(getNonPortableDistroRid "${targetOs}" "${targetArch}" "${rootfsDir}")
+
+    if [ -z "${__PortableTargetOS:-}" ]; then
+        __PortableTargetOS="$targetOs"
+
+        STRINGS="$(command -v strings || true)"
+        if [ -z "$STRINGS" ]; then
+            STRINGS="$(command -v llvm-strings || true)"
+        fi
+
+        # Check for musl-based distros (e.g Alpine Linux, Void Linux).
+        if "${rootfsDir}/usr/bin/ldd" --version 2>&1 | grep -q musl ||
+                ( [ -n "$STRINGS" ] && "$STRINGS" "${rootfsDir}/usr/bin/ldd" 2>&1 | grep -q musl ); then
+            __PortableTargetOS="linux-musl"
+        fi
+    fi
+
+    export __DistroRid __PortableTargetOS
+}
diff --git a/eng/common/native/init-os-and-arch.sh b/eng/common/native/init-os-and-arch.sh
new file mode 100644
index 00000000000..e693617a6c2
--- /dev/null
+++ b/eng/common/native/init-os-and-arch.sh
@@ -0,0 +1,80 @@
+#!/usr/bin/env bash
+
+# Use uname to determine what the OS is.
+OSName=$(uname -s | tr '[:upper:]' '[:lower:]')
+
+if command -v getprop && getprop ro.product.system.model 2>&1 | grep -qi android; then
+    OSName="android"
+fi
+
+case "$OSName" in
+freebsd|linux|netbsd|openbsd|sunos|android|haiku)
+    os="$OSName" ;;
+darwin)
+    os=osx ;;
+*)
+    echo "Unsupported OS $OSName detected!"
+    exit 1 ;;
+esac
+
+# On Solaris, `uname -m` is discouraged, see https://docs.oracle.com/cd/E36784_01/html/E36870/uname-1.html
+# and `uname -p` returns processor type (e.g. i386 on amd64).
+# The appropriate tool to determine CPU is isainfo(1) https://docs.oracle.com/cd/E36784_01/html/E36870/isainfo-1.html.
+if [ "$os" = "sunos" ]; then
+    if uname -o 2>&1 | grep -q illumos; then
+        os="illumos"
+    else
+        os="solaris"
+    fi
+    CPUName=$(isainfo -n)
+else
+    # For the rest of the operating systems, use uname(1) to determine what the CPU is.
+    CPUName=$(uname -m)
+fi
+
+case "$CPUName" in
+    arm64|aarch64)
+        arch=arm64
+        ;;
+
+    loongarch64)
+        arch=loongarch64
+        ;;
+
+    riscv64)
+        arch=riscv64
+        ;;
+
+    amd64|x86_64)
+        arch=x64
+        ;;
+
+    armv7l|armv8l)
+        if (NAME=""; . /etc/os-release; test "$NAME" = "Tizen"); then
+            arch=armel
+        else
+            arch=arm
+        fi
+        ;;
+
+    armv6l)
+        arch=armv6
+        ;;
+
+    i[3-6]86)
+        echo "Unsupported CPU $CPUName detected, build might not succeed!"
+        arch=x86
+        ;;
+
+    s390x)
+        arch=s390x
+        ;;
+
+    ppc64le)
+        arch=ppc64le
+        ;;
+    *)
+        echo "Unknown CPU $CPUName detected!"
+        exit 1
+        ;;
+esac
diff --git a/global.json b/global.json
index 7a53e9c91ab..4027cac3796 100644
--- a/global.json
+++ b/global.json
@@ -3,13 +3,13 @@
     "allowPrerelease": true
   },
   "tools": {
-    "dotnet": "8.0.100-preview.6.23330.14",
+    "dotnet": "8.0.100-preview.7.23376.3",
     "vs": {
       "version": "17.6.0"
     },
     "xcopy-msbuild": "17.6.0-2"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23404.2"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.23411.1"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
new file mode 100644
index 00000000000..27b30d71997
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/LoggingConfigurationTelemetry_Tests.cs
@@ -0,0 +1,85 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+using System;
+using System.Globalization;
+using System.Linq;
+using Microsoft.Build.Framework.Telemetry;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests.Telemetry;
+
+public class LoggingConfigurationTelemetry_Tests
+{
+    [Fact]
+    public void LoggingConfigurationTelemetryIsThere()
+    {
+        KnownTelemetry.LoggingConfigurationTelemetry.ShouldNotBeNull();
+    }
+
+    [Fact]
+    public void BuildTelemetryConstructedHasNoProperties()
+    {
+        LoggingConfigurationTelemetry telemetry = new();
+
+        telemetry.EventName.ShouldBe("loggingConfiguration");
+        telemetry.TerminalLogger.ShouldBe(false);
+        telemetry.TerminalLoggerUserIntent.ShouldBeNull();
+        telemetry.TerminalLoggerUserIntentSource.ShouldBeNull();
+        telemetry.TerminalLoggerDefault.ShouldBeNull();
+        telemetry.TerminalLoggerDefaultSource.ShouldBeNull();
+        telemetry.ConsoleLogger.ShouldBe(false);
+        telemetry.ConsoleLoggerType.ShouldBeNull();
+        telemetry.ConsoleLoggerVerbosity.ShouldBeNull();
+        telemetry.FileLogger.ShouldBe(false);
+        telemetry.FileLoggerVerbosity.ShouldBeNull();
+        telemetry.FileLoggersCount.ShouldBe(0);
+        telemetry.FileLoggerVerbosity.ShouldBeNull();
+        telemetry.BinaryLogger.ShouldBe(false);
+        telemetry.BinaryLoggerUsedDefaultName.ShouldBe(false);
+
+        telemetry.UpdateEventProperties();
+        telemetry.Properties.Where(kv => kv.Value != bool.FalseString).ShouldBeEmpty();
+    }
+
+    [Fact]
+    public void BuildTelemetryCreateProperProperties()
+    {
+        LoggingConfigurationTelemetry telemetry = new()
+        {
+            TerminalLogger = true,
+            TerminalLoggerUserIntent = "on",
+            TerminalLoggerUserIntentSource = "arg",
+            TerminalLoggerDefault = "auto",
+            TerminalLoggerDefaultSource = "sdk",
+            ConsoleLogger = true,
+            ConsoleLoggerType = "serial",
+            ConsoleLoggerVerbosity = "minimal",
+            FileLogger = true,
+            FileLoggerType = "serial",
+            FileLoggersCount = 2,
+            FileLoggerVerbosity = "normal",
+            BinaryLogger = true,
+            BinaryLoggerUsedDefaultName = true
+        };
+
+        telemetry.UpdateEventProperties();
+
+        telemetry.Properties["TerminalLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["TerminalLoggerUserIntent"].ShouldBe("on");
+        telemetry.Properties["TerminalLoggerUserIntentSource"].ShouldBe("arg");
+        telemetry.Properties["TerminalLoggerDefault"].ShouldBe("auto");
+        telemetry.Properties["TerminalLoggerDefaultSource"].ShouldBe("sdk");
+        telemetry.Properties["ConsoleLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["ConsoleLoggerType"].ShouldBe("serial");
+        telemetry.Properties["ConsoleLoggerVerbosity"].ShouldBe("minimal");
+        telemetry.Properties["FileLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["FileLoggerType"].ShouldBe("serial");
+        telemetry.Properties["FileLoggersCount"].ShouldBe("2");
+        telemetry.Properties["FileLoggerVerbosity"].ShouldBe("normal");
+        telemetry.Properties["BinaryLogger"].ShouldBe(bool.TrueString);
+        telemetry.Properties["BinaryLoggerUsedDefaultName"].ShouldBe(bool.TrueString);
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
index 8d7f7f5936d..64ffc8fba5c 100644
--- a/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
+++ b/src/Build.UnitTests/BackEnd/TaskBuilderTestTask.cs
@@ -17,228 +17,973 @@ namespace Microsoft.Build.UnitTests.BackEnd
     /// </summary>
     public class TaskBuilderTestTask : IGeneratedTask
     {
+        /// <summary>
+        /// A custom <see cref="IConvertible"/> value type.
+        /// </summary>
+        /// <remarks>
+        /// Types like this one can be used only as Output parameter types because they can be converted to string
+        /// but not from string.
+        /// </remarks>
+        [Serializable]
+        public struct CustomStruct : IConvertible
+        {
+            private readonly object _value;
+
+            /// <summary>
+            /// Using <see cref="IConvertible"/> as the type of the <see cref="_value"/> field triggers a BinaryFormatter bug.
+            /// </summary>
+            private IConvertible Value => (IConvertible)_value;
+
+            public CustomStruct(IConvertible value)
+            {
+                _value = value;
+            }
+
+            public TypeCode GetTypeCode() => Value.GetTypeCode();
+            public bool ToBoolean(IFormatProvider provider) => Value.ToBoolean(provider);
+            public byte ToByte(IFormatProvider provider) => Value.ToByte(provider);
+            public char ToChar(IFormatProvider provider) => Value.ToChar(provider);
+            public DateTime ToDateTime(IFormatProvider provider) => Value.ToDateTime(provider);
+            public decimal ToDecimal(IFormatProvider provider) => Value.ToDecimal(provider);
+            public double ToDouble(IFormatProvider provider) => Value.ToDouble(provider);
+            public short ToInt16(IFormatProvider provider) => Value.ToInt16(provider);
+            public int ToInt32(IFormatProvider provider) => Value.ToInt32(provider);
+            public long ToInt64(IFormatProvider provider) => Value.ToInt64(provider);
+            public sbyte ToSByte(IFormatProvider provider) => Value.ToSByte(provider);
+            public float ToSingle(IFormatProvider provider) => Value.ToSingle(provider);
+            public string ToString(IFormatProvider provider) => Value.ToString(provider);
+            public object ToType(Type conversionType, IFormatProvider provider) => Value.ToType(conversionType, provider);
+            public ushort ToUInt16(IFormatProvider provider) => Value.ToUInt16(provider);
+            public uint ToUInt32(IFormatProvider provider) => Value.ToUInt32(provider);
+            public ulong ToUInt64(IFormatProvider provider) => Value.ToUInt64(provider);
+        }
+
+        /// <summary>
+        /// The <see cref="CustomStruct"/> value returned from <see cref="CustomStructOutput"/>.
+        /// </summary>
+        internal static readonly CustomStruct s_customStruct = new CustomStruct(42);
+
+        /// <summary>
+        /// The <see cref="CustomStruct[]"/> value returned from <see cref="CustomStructArrayOutput"/>.
+        /// </summary>
+        internal static readonly CustomStruct[] s_customStructArray = new CustomStruct[] { new CustomStruct(43), new CustomStruct(44) };
+
         /// <summary>
         /// The task host.
         /// </summary>
-        private ITestTaskHost _testTaskHost;
+        private ITestTaskHost _testTaskHost;
+
+        /// <summary>
+        /// The value to return from Execute.
+        /// </summary>
+        private bool _executeReturnValue;
+
+        /// <summary>
+        /// The value for the BoolOutput.
+        /// </summary>
+        private bool _boolOutput;
+
+        /// <summary>
+        /// The value for the BoolArrayOutput.
+        /// </summary>
+        private bool[] _boolArrayOutput;
+
+        /// <summary>
+        /// The value for the ByteOutput.
+        /// </summary>
+        private byte _byteOutput;
+
+        /// <summary>
+        /// The value for the ByteArrayOutput.
+        /// </summary>
+        private byte[] _byteArrayOutput;
+
+        /// <summary>
+        /// The value for the SByteOutput.
+        /// </summary>
+        private sbyte _sbyteOutput;
+
+        /// <summary>
+        /// The value for the SByteArrayOutput.
+        /// </summary>
+        private sbyte[] _sbyteArrayOutput;
+
+        /// <summary>
+        /// The value for the DoubleOutput.
+        /// </summary>
+        private double _doubleOutput;
+
+        /// <summary>
+        /// The value for the DoubleArrayOutput.
+        /// </summary>
+        private double[] _doubleArrayOutput;
+
+        /// <summary>
+        /// The value for the FloatOutput.
+        /// </summary>
+        private float _floatOutput;
+
+        /// <summary>
+        /// The value for the FloatArrayOutput.
+        /// </summary>
+        private float[] _floatArrayOutput;
+
+        /// <summary>
+        /// The value for the ShortOutput.
+        /// </summary>
+        private short _shortOutput;
+
+        /// <summary>
+        /// The value for the ShortArrayOutput.
+        /// </summary>
+        private short[] _shortArrayOutput;
+
+        /// <summary>
+        /// The value for the UShortOutput.
+        /// </summary>
+        private ushort _ushortOutput;
+
+        /// <summary>
+        /// The value for the UShortArrayOutput.
+        /// </summary>
+        private ushort[] _ushortArrayOutput;
+
+        /// <summary>
+        /// The value for the IntOutput.
+        /// </summary>
+        private int _intOutput;
+
+        /// <summary>
+        /// The value for the IntArrayOutput.
+        /// </summary>
+        private int[] _intArrayOutput;
+
+        /// <summary>
+        /// The value for the UIntOutput.
+        /// </summary>
+        private uint _uintOutput;
+
+        /// <summary>
+        /// The value for the UIntArrayOutput.
+        /// </summary>
+        private uint[] _uintArrayOutput;
+
+        /// <summary>
+        /// The value for the LongOutput.
+        /// </summary>
+        private long _longOutput;
+
+        /// <summary>
+        /// The value for the LongArrayOutput.
+        /// </summary>
+        private long[] _longArrayOutput;
+
+        /// <summary>
+        /// The value for the ULongOutput.
+        /// </summary>
+        private ulong _ulongOutput;
+
+        /// <summary>
+        /// The value for the ULongArrayOutput.
+        /// </summary>
+        private ulong[] _ulongArrayOutput;
+
+        /// <summary>
+        /// The value for the DecimalOutput.
+        /// </summary>
+        private decimal _decimalOutput;
+
+        /// <summary>
+        /// The value for the DecimalArrayOutput.
+        /// </summary>
+        private decimal[] _decimalArrayOutput;
+
+        /// <summary>
+        /// The value for the CharOutput.
+        /// </summary>
+        private char _charOutput;
+
+        /// <summary>
+        /// The value for the CharArrayOutput.
+        /// </summary>
+        private char[] _charArrayOutput;
+
+        /// <summary>
+        /// The value for the StringOutput.
+        /// </summary>
+        private string _stringOutput;
+
+        /// <summary>
+        /// The value for the StringArrayOutput.
+        /// </summary>
+        private string[] _stringArrayOutput;
+
+        /// <summary>
+        /// The value for the DateTimeOutput.
+        /// </summary>
+        private DateTime _dateTimeOutput;
+
+        /// <summary>
+        /// The value for the DateTimeArrayOutput.
+        /// </summary>
+        private DateTime[] _dateTimeArrayOutput;
+
+        /// <summary>
+        /// The value for the ItemOutput.
+        /// </summary>
+        private ITaskItem _itemOutput;
+
+        /// <summary>
+        /// The value for the ItemArrayOutput.
+        /// </summary>
+        private ITaskItem[] _itemArrayOutput;
+
+        /// <summary>
+        /// Property determining if Execute() should throw or not.
+        /// </summary>
+        public bool ThrowOnExecute
+        {
+            internal get;
+            set;
+        }
+
+        /// <summary>
+        /// A boolean parameter.
+        /// </summary>
+        public bool BoolParam
+        {
+            set
+            {
+                _boolOutput = value;
+                _testTaskHost?.ParameterSet("BoolParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A boolean array parameter.
+        /// </summary>
+        public bool[] BoolArrayParam
+        {
+            set
+            {
+                _boolArrayOutput = value;
+                _testTaskHost?.ParameterSet("BoolArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A byte parameter.
+        /// </summary>
+        public byte ByteParam
+        {
+            set
+            {
+                _byteOutput = value;
+                _testTaskHost?.ParameterSet("ByteParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A byte array parameter.
+        /// </summary>
+        public byte[] ByteArrayParam
+        {
+            set
+            {
+                _byteArrayOutput = value;
+                _testTaskHost?.ParameterSet("ByteArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An sbyte parameter.
+        /// </summary>
+        public sbyte SByteParam
+        {
+            set
+            {
+                _sbyteOutput = value;
+                _testTaskHost?.ParameterSet("SByteParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An sbyte array parameter.
+        /// </summary>
+        public sbyte[] SByteArrayParam
+        {
+            set
+            {
+                _sbyteArrayOutput = value;
+                _testTaskHost?.ParameterSet("SByteArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A double parameter.
+        /// </summary>
+        public double DoubleParam
+        {
+            set
+            {
+                _doubleOutput = value;
+                _testTaskHost?.ParameterSet("DoubleParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A double array parameter.
+        /// </summary>
+        public double[] DoubleArrayParam
+        {
+            set
+            {
+                _doubleArrayOutput = value;
+                _testTaskHost?.ParameterSet("DoubleArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A float parameter.
+        /// </summary>
+        public float FloatParam
+        {
+            set
+            {
+                _floatOutput = value;
+                _testTaskHost?.ParameterSet("FloatParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A float array parameter.
+        /// </summary>
+        public float[] FloatArrayParam
+        {
+            set
+            {
+                _floatArrayOutput = value;
+                _testTaskHost?.ParameterSet("FloatArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A short parameter.
+        /// </summary>
+        public short ShortParam
+        {
+            set
+            {
+                _shortOutput = value;
+                _testTaskHost?.ParameterSet("ShortParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A short array parameter.
+        /// </summary>
+        public short[] ShortArrayParam
+        {
+            set
+            {
+                _shortArrayOutput = value;
+                _testTaskHost?.ParameterSet("ShortArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ushort parameter.
+        /// </summary>
+        public ushort UShortParam
+        {
+            set
+            {
+                _ushortOutput = value;
+                _testTaskHost?.ParameterSet("UShortParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ushort array parameter.
+        /// </summary>
+        public ushort[] UShortArrayParam
+        {
+            set
+            {
+                _ushortArrayOutput = value;
+                _testTaskHost?.ParameterSet("UShortArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An integer parameter.
+        /// </summary>
+        public int IntParam
+        {
+            set
+            {
+                _intOutput = value;
+                _testTaskHost?.ParameterSet("IntParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An integer array parameter.
+        /// </summary>
+        public int[] IntArrayParam
+        {
+            set
+            {
+                _intArrayOutput = value;
+                _testTaskHost?.ParameterSet("IntArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A uint parameter.
+        /// </summary>
+        public uint UIntParam
+        {
+            set
+            {
+                _uintOutput = value;
+                _testTaskHost?.ParameterSet("UIntParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A uint array parameter.
+        /// </summary>
+        public uint[] UIntArrayParam
+        {
+            set
+            {
+                _uintArrayOutput = value;
+                _testTaskHost?.ParameterSet("UIntArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A long parameter.
+        /// </summary>
+        public long LongParam
+        {
+            set
+            {
+                _longOutput = value;
+                _testTaskHost?.ParameterSet("LongParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A long array parameter.
+        /// </summary>
+        public long[] LongArrayParam
+        {
+            set
+            {
+                _longArrayOutput = value;
+                _testTaskHost?.ParameterSet("LongArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ulong parameter.
+        /// </summary>
+        public ulong ULongParam
+        {
+            set
+            {
+                _ulongOutput = value;
+                _testTaskHost?.ParameterSet("ULongParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A ulong array parameter.
+        /// </summary>
+        public ulong[] ULongArrayParam
+        {
+            set
+            {
+                _ulongArrayOutput = value;
+                _testTaskHost?.ParameterSet("ULongArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A decimal parameter.
+        /// </summary>
+        public decimal DecimalParam
+        {
+            set
+            {
+                _decimalOutput = value;
+                _testTaskHost?.ParameterSet("DecimalParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A decimal array parameter.
+        /// </summary>
+        public decimal[] DecimalArrayParam
+        {
+            set
+            {
+                _decimalArrayOutput = value;
+                _testTaskHost?.ParameterSet("DecimalArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A char parameter.
+        /// </summary>
+        public char CharParam
+        {
+            set
+            {
+                _charOutput = value;
+                _testTaskHost?.ParameterSet("CharParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A char array parameter.
+        /// </summary>
+        public char[] CharArrayParam
+        {
+            set
+            {
+                _charArrayOutput = value;
+                _testTaskHost?.ParameterSet("CharArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A string parameter.
+        /// </summary>
+        public string StringParam
+        {
+            set
+            {
+                _stringOutput = value;
+                _testTaskHost?.ParameterSet("StringParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A string array parameter.
+        /// </summary>
+        public string[] StringArrayParam
+        {
+            set
+            {
+                _stringArrayOutput = value;
+                _testTaskHost?.ParameterSet("StringArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A DateTime parameter.
+        /// </summary>
+        public DateTime DateTimeParam
+        {
+            set
+            {
+                _dateTimeOutput = value;
+                _testTaskHost?.ParameterSet("DateTimeParam", value);
+            }
+        }
+
+        /// <summary>
+        /// A DateTime array parameter.
+        /// </summary>
+        public DateTime[] DateTimeArrayParam
+        {
+            set
+            {
+                _dateTimeArrayOutput = value;
+                _testTaskHost?.ParameterSet("DateTimeArrayParam", value);
+            }
+        }
+
+        /// <summary>
+        /// An item parameter.
+        /// </summary>
+        public ITaskItem ItemParam
+        {
+            set
+            {
+                _itemOutput = value;
+                _testTaskHost?.ParameterSet("ItemParam", value);
+            }
+        }
 
         /// <summary>
-        /// The value to return from Execute
+        /// An item array parameter.
         /// </summary>
-        private bool _executeReturnValue;
+        public ITaskItem[] ItemArrayParam
+        {
+            set
+            {
+                _itemArrayOutput = value;
+                _testTaskHost?.ParameterSet("ItemArrayParam", value);
+            }
+        }
 
         /// <summary>
-        /// The value for the BoolOutput
+        /// The Execute return value parameter.
         /// </summary>
-        private bool _boolOutput;
+        [Required]
+        public bool ExecuteReturnParam
+        {
+            set
+            {
+                _executeReturnValue = value;
+                _testTaskHost?.ParameterSet("ExecuteReturnParam", value);
+            }
+        }
 
         /// <summary>
-        /// The value for the BoolArrayOutput
+        /// A boolean output.
         /// </summary>
-        private bool[] _boolArrayOutput;
+        [Output]
+        public bool BoolOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("BoolOutput", _boolOutput);
+                return _boolOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the IntOutput
+        /// A boolean array output.
         /// </summary>
-        private int _intOutput;
+        [Output]
+        public bool[] BoolArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("BoolArrayOutput", _boolArrayOutput);
+                return _boolArrayOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the IntArrayOutput
+        /// A byte output.
         /// </summary>
-        private int[] _intArrayOutput;
+        [Output]
+        public byte ByteOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("ByteOutput", _byteOutput);
+                return _byteOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the StringOutput
+        /// A byte array output.
         /// </summary>
-        private string _stringOutput;
+        [Output]
+        public byte[] ByteArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("ByteArrayOutput", _byteArrayOutput);
+                return _byteArrayOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the StringArrayOutput
+        /// An sbyte output.
         /// </summary>
-        private string[] _stringArrayOutput;
+        [Output]
+        public sbyte SByteOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("SByteOutput", _sbyteOutput);
+                return _sbyteOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the ItemOutput
+        /// An sbyte array output.
         /// </summary>
-        private ITaskItem _itemOutput;
+        [Output]
+        public sbyte[] SByteArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("SByteArrayOutput", _sbyteArrayOutput);
+                return _sbyteArrayOutput;
+            }
+        }
 
         /// <summary>
-        /// The value for the ItemArrayOutput
+        /// A double output.
         /// </summary>
-        private ITaskItem[] _itemArrayOutput;
+        [Output]
+        public double DoubleOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DoubleOutput", _doubleOutput);
+                return _doubleOutput;
+            }
+        }
 
         /// <summary>
-        /// Property determining if Execute() should throw or not.
+        /// A double array output.
         /// </summary>
-        public bool ThrowOnExecute
+        [Output]
+        public double[] DoubleArrayOutput
         {
-            internal get;
-            set;
+            get
+            {
+                _testTaskHost?.OutputRead("DoubleArrayOutput", _doubleArrayOutput);
+                return _doubleArrayOutput;
+            }
         }
 
         /// <summary>
-        /// A boolean parameter
+        /// A float output.
         /// </summary>
-        public bool BoolParam
+        [Output]
+        public float FloatOutput
         {
-            set
+            get
             {
-                _boolOutput = value;
-                _testTaskHost?.ParameterSet("BoolParam", value);
+                _testTaskHost?.OutputRead("FloatOutput", _floatOutput);
+                return _floatOutput;
             }
         }
 
         /// <summary>
-        /// A boolean array parameter
+        /// A float array output.
         /// </summary>
-        public bool[] BoolArrayParam
+        [Output]
+        public float[] FloatArrayOutput
         {
-            set
+            get
             {
-                _boolArrayOutput = value;
-                _testTaskHost?.ParameterSet("BoolArrayParam", value);
+                _testTaskHost?.OutputRead("FloatArrayOutput", _floatArrayOutput);
+                return _floatArrayOutput;
             }
         }
 
         /// <summary>
-        /// An integer parameter
+        /// A short output.
         /// </summary>
-        public int IntParam
+        [Output]
+        public short ShortOutput
         {
-            set
+            get
             {
-                _intOutput = value;
-                _testTaskHost?.ParameterSet("IntParam", value);
+                _testTaskHost?.OutputRead("ShortOutput", _shortOutput);
+                return _shortOutput;
             }
         }
 
         /// <summary>
-        /// An integer array parameter.
+        /// A short array output.
         /// </summary>
-        public int[] IntArrayParam
+        [Output]
+        public short[] ShortArrayOutput
         {
-            set
+            get
             {
-                _intArrayOutput = value;
-                _testTaskHost?.ParameterSet("IntArrayParam", value);
+                _testTaskHost?.OutputRead("ShortArrayOutput", _shortArrayOutput);
+                return _shortArrayOutput;
             }
         }
 
         /// <summary>
-        /// A string parameter.
+        /// A ushort output.
         /// </summary>
-        public string StringParam
+        [Output]
+        public ushort UShortOutput
         {
-            set
+            get
             {
-                _stringOutput = value;
-                _testTaskHost?.ParameterSet("StringParam", value);
+                _testTaskHost?.OutputRead("UShortOutput", _ushortOutput);
+                return _ushortOutput;
             }
         }
 
         /// <summary>
-        /// A string array parameter.
+        /// A ushort array output.
         /// </summary>
-        public string[] StringArrayParam
+        [Output]
+        public ushort[] UShortArrayOutput
         {
-            set
+            get
             {
-                _stringArrayOutput = value;
-                _testTaskHost?.ParameterSet("StringArrayParam", value);
+                _testTaskHost?.OutputRead("UShortArrayOutput", _ushortArrayOutput);
+                return _ushortArrayOutput;
             }
         }
 
         /// <summary>
-        /// An item parameter.
+        /// An integer output.
         /// </summary>
-        public ITaskItem ItemParam
+        [Output]
+        public int IntOutput
         {
-            set
+            get
             {
-                _itemOutput = value;
-                _testTaskHost?.ParameterSet("ItemParam", value);
+                _testTaskHost?.OutputRead("IntOutput", _intOutput);
+                return _intOutput;
             }
         }
 
         /// <summary>
-        /// An item array parameter.
+        /// An integer array output.
         /// </summary>
-        public ITaskItem[] ItemArrayParam
+        [Output]
+        public int[] IntArrayOutput
         {
-            set
+            get
             {
-                _itemArrayOutput = value;
-                _testTaskHost?.ParameterSet("ItemArrayParam", value);
+                _testTaskHost?.OutputRead("IntArrayOutput", _intArrayOutput);
+                return _intArrayOutput;
             }
         }
 
         /// <summary>
-        /// The Execute return value parameter.
+        /// A uint output.
         /// </summary>
-        [Required]
-        public bool ExecuteReturnParam
+        [Output]
+        public uint UIntOutput
         {
-            set
+            get
             {
-                _executeReturnValue = value;
-                _testTaskHost?.ParameterSet("ExecuteReturnParam", value);
+                _testTaskHost?.OutputRead("UIntOutput", _uintOutput);
+                return _uintOutput;
             }
         }
 
         /// <summary>
-        /// A boolean output.
+        /// A uint array output.
         /// </summary>
         [Output]
-        public bool BoolOutput
+        public uint[] UIntArrayOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("BoolOutput", _boolOutput);
-                return _boolOutput;
+                _testTaskHost?.OutputRead("UIntArrayOutput", _uintArrayOutput);
+                return _uintArrayOutput;
             }
         }
 
         /// <summary>
-        /// A boolean array output
+        /// A long output.
         /// </summary>
         [Output]
-        public bool[] BoolArrayOutput
+        public long LongOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("BoolArrayOutput", _boolArrayOutput);
-                return _boolArrayOutput;
+                _testTaskHost?.OutputRead("LongOutput", _longOutput);
+                return _longOutput;
             }
         }
 
         /// <summary>
-        /// An integer output
+        /// A long array output.
         /// </summary>
         [Output]
-        public int IntOutput
+        public long[] LongArrayOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("IntOutput", _intOutput);
-                return _intOutput;
+                _testTaskHost?.OutputRead("LongArrayOutput", _longArrayOutput);
+                return _longArrayOutput;
             }
         }
 
         /// <summary>
-        /// An integer array output
+        /// A ulong output.
         /// </summary>
         [Output]
-        public int[] IntArrayOutput
+        public ulong ULongOutput
         {
             get
             {
-                _testTaskHost?.OutputRead("IntArrayOutput", _intArrayOutput);
-                return _intArrayOutput;
+                _testTaskHost?.OutputRead("ULongOutput", _ulongOutput);
+                return _ulongOutput;
+            }
+        }
+
+        /// <summary>
+        /// A ulong array output.
+        /// </summary>
+        [Output]
+        public ulong[] ULongArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("ULongArrayOutput", _ulongArrayOutput);
+                return _ulongArrayOutput;
+            }
+        }
+
+        /// <summary>
+        /// A decimal output.
+        /// </summary>
+        [Output]
+        public decimal DecimalOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DecimalOutput", _decimalOutput);
+                return _decimalOutput;
+            }
+        }
+
+        /// <summary>
+        /// A decimal array output.
+        /// </summary>
+        [Output]
+        public decimal[] DecimalArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DecimalArrayOutput", _decimalArrayOutput);
+                return _decimalArrayOutput;
+            }
+        }
+
+        /// <summary>
+        /// A char output.
+        /// </summary>
+        [Output]
+        public char CharOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CharOutput", _charOutput);
+                return _charOutput;
+            }
+        }
+
+        /// <summary>
+        /// A char array output.
+        /// </summary>
+        [Output]
+        public char[] CharArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CharArrayOutput", _charArrayOutput);
+                return _charArrayOutput;
             }
         }
 
         /// <summary>
-        /// A string output
+        /// A string output.
         /// </summary>
         [Output]
         public string StringOutput
@@ -290,7 +1035,59 @@ public string NullStringOutput
         }
 
         /// <summary>
-        /// A null ITaskItem output
+        /// A DateTime output
+        /// </summary>
+        [Output]
+        public DateTime DateTimeOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DateTimeOutput", _dateTimeOutput);
+                return _dateTimeOutput;
+            }
+        }
+
+        /// <summary>
+        /// A DateTime array output.
+        /// </summary>
+        [Output]
+        public DateTime[] DateTimeArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("DateTimeArrayOutput", _dateTimeArrayOutput);
+                return _dateTimeArrayOutput;
+            }
+        }
+
+        /// <summary>
+        /// A CustomStruct output.
+        /// </summary>
+        [Output]
+        public CustomStruct CustomStructOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CustomStructOutput", s_customStruct);
+                return s_customStruct;
+            }
+        }
+
+        /// <summary>
+        /// A CustomStruct array output.
+        /// </summary>
+        [Output]
+        public CustomStruct[] CustomStructArrayOutput
+        {
+            get
+            {
+                _testTaskHost?.OutputRead("CustomStructArrayOutput", s_customStructArray);
+                return s_customStructArray;
+            }
+        }
+
+        /// <summary>
+        /// A null ITaskItem output.
         /// </summary>
         [Output]
         public ITaskItem NullITaskItemOutput
@@ -303,7 +1100,7 @@ public ITaskItem NullITaskItemOutput
         }
 
         /// <summary>
-        /// A null string array output
+        /// A null string array output.
         /// </summary>
         [Output]
         public string[] NullStringArrayOutput
@@ -316,7 +1113,7 @@ public string[] NullStringArrayOutput
         }
 
         /// <summary>
-        /// A null ITaskItem array output
+        /// A null ITaskItem array output.
         /// </summary>
         [Output]
         public ITaskItem[] NullITaskItemArrayOutput
@@ -329,7 +1126,7 @@ public ITaskItem[] NullITaskItemArrayOutput
         }
 
         /// <summary>
-        /// A string array output
+        /// A string array output.
         /// </summary>
         [Output]
         public string[] StringArrayOutput
@@ -342,7 +1139,7 @@ public string[] StringArrayOutput
         }
 
         /// <summary>
-        /// A task item output
+        /// A task item output.
         /// </summary>
         [Output]
         public ITaskItem ItemOutput
@@ -355,7 +1152,7 @@ public ITaskItem ItemOutput
         }
 
         /// <summary>
-        /// A task item array output
+        /// A task item array output.
         /// </summary>
         [Output]
         public ITaskItem[] ItemArrayOutput
@@ -368,7 +1165,7 @@ public ITaskItem[] ItemArrayOutput
         }
 
         /// <summary>
-        /// A task item array output that is null
+        /// A task item array output that is null.
         /// </summary>
         [Output]
         public ITaskItem[] ItemArrayNullOutput
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index a3226a7df75..5bf7c1a47eb 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -3,7 +3,10 @@
 
 using System;
 using System.Diagnostics;
+using System.Globalization;
 using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.BackEnd;
 
@@ -58,37 +61,159 @@ public void TaskNodesDieAfterBuild()
             }
         }
 
-        [Fact]
-        public void VariousParameterTypesCanBeTransmittedToAndRecievedFromTaskHost()
+        [Theory]
+        [InlineData(false)]
+        [InlineData(true)]
+        public void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost(bool testLegacyImplementation)
         {
             using TestEnvironment env = TestEnvironment.Create(_output);
 
+            ChangeWaves.ResetStateForTests();
+            if (testLegacyImplementation)
+            {
+                env.SetEnvironmentVariable("MSBUILDDISABLEFEATURESFROMVERSION", ChangeWaves.Wave17_6.ToString());
+                BuildEnvironmentHelper.ResetInstance_ForUnitTestsOnly();
+            }
+
+            string boolParam = "True";
+            string boolArrayParam = "False;True;False";
+            string byteParam = "42";
+            string byteArrayParam = "11;22;33";
+            string sbyteParam = "-42";
+            string sbyteArrayParam = "-11;-22;-33";
+            string doubleParam = "3.14";
+            string doubleArrayParam = "3.14;2.72";
+            string floatParam = "0.5";
+            string floatArrayParam = "0.6;0.7;0.8";
+            string shortParam = "-100";
+            string shortArrayParam = "-200;-300;999";
+            string ushortParam = "100";
+            string ushortArrayParam = "200;300;999";
+            string intParam = "-314";
+            string intArrayParam = "42;-67;98";
+            string uintParam = "314";
+            string uintArrayParam = "4200000;67;98";
+            string longParam = "-120000000000";
+            string longArrayParam = "-120000000000;0;1";
+            string ulongParam = "120000000000";
+            string ulongArrayParam = "120000000000;0;1";
+            string decimalParam = "0.999999999999";
+            string decimalArrayParam = "-0.999999999999";
+            string charParam = "A";
+            string charArrayParam = "A;b;2";
+            string stringParam = "stringParamInput";
+            string stringArrayParam = "stringArrayParamInput1;stringArrayParamInput2;stringArrayParamInput3";
+            string dateTimeParam = "01/01/2001 10:15:00";
+            string dateTimeArrayParam = "01/01/2001 10:15:00;02/02/2002 11:30:00;03/03/2003 12:45:00";
+
             string projectContents = $@"
 <Project>
     <UsingTask TaskName=""{nameof(TaskBuilderTestTask)}"" AssemblyFile=""{typeof(TaskBuilderTestTask).Assembly.Location}"" TaskFactory=""TaskHostFactory"" />
-    <Target Name='{nameof(VariousParameterTypesCanBeTransmittedToAndRecievedFromTaskHost)}'>
+    <Target Name='{nameof(VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost)}'>
         <{nameof(TaskBuilderTestTask)}
             ExecuteReturnParam=""true""
-            BoolParam=""true""
-            BoolArrayParam=""false;true;false""
-            IntParam=""314""
-            IntArrayParam=""42;67;98""
-            StringParam=""stringParamInput""
-            StringArrayParam=""stringArrayParamInput1;stringArrayParamInput2;stringArrayParamInput3"">
+            BoolParam=""{boolParam}""
+            BoolArrayParam=""{boolArrayParam}""
+            ByteParam=""{byteParam}""
+            ByteArrayParam=""{byteArrayParam}""
+            SByteParam=""{sbyteParam}""
+            SByteArrayParam=""{sbyteArrayParam}""
+            DoubleParam=""{doubleParam}""
+            DoubleArrayParam=""{doubleArrayParam}""
+            FloatParam=""{floatParam}""
+            FloatArrayParam=""{floatArrayParam}""
+            ShortParam=""{shortParam}""
+            ShortArrayParam=""{shortArrayParam}""
+            UShortParam=""{ushortParam}""
+            UShortArrayParam=""{ushortArrayParam}""
+            IntParam=""{intParam}""
+            IntArrayParam=""{intArrayParam}""
+            UIntParam=""{uintParam}""
+            UIntArrayParam=""{uintArrayParam}""
+            LongParam=""{longParam}""
+            LongArrayParam=""{longArrayParam}""
+            ULongParam=""{ulongParam}""
+            ULongArrayParam=""{ulongArrayParam}""
+            DecimalParam=""{decimalParam}""
+            DecimalArrayParam=""{decimalArrayParam}""
+            CharParam=""{charParam}""
+            CharArrayParam=""{charArrayParam}""
+            StringParam=""{stringParam}""
+            StringArrayParam=""{stringArrayParam}""
+            DateTimeParam=""{dateTimeParam}""
+            DateTimeArrayParam=""{dateTimeArrayParam}"">
 
             <Output PropertyName=""BoolOutput"" TaskParameter=""BoolOutput"" />
             <Output PropertyName=""BoolArrayOutput"" TaskParameter=""BoolArrayOutput"" />
+            <Output PropertyName=""ByteOutput"" TaskParameter=""ByteOutput"" />
+            <Output PropertyName=""ByteArrayOutput"" TaskParameter=""ByteArrayOutput"" />
+            <Output PropertyName=""SByteOutput"" TaskParameter=""SByteOutput"" />
+            <Output PropertyName=""SByteArrayOutput"" TaskParameter=""SByteArrayOutput"" />
+            <Output PropertyName=""DoubleOutput"" TaskParameter=""DoubleOutput"" />
+            <Output PropertyName=""DoubleArrayOutput"" TaskParameter=""DoubleArrayOutput"" />
+            <Output PropertyName=""FloatOutput"" TaskParameter=""FloatOutput"" />
+            <Output PropertyName=""FloatArrayOutput"" TaskParameter=""FloatArrayOutput"" />
+            <Output PropertyName=""ShortOutput"" TaskParameter=""ShortOutput"" />
+            <Output PropertyName=""ShortArrayOutput"" TaskParameter=""ShortArrayOutput"" />
+            <Output PropertyName=""UShortOutput"" TaskParameter=""UShortOutput"" />
+            <Output PropertyName=""UShortArrayOutput"" TaskParameter=""UShortArrayOutput"" />
             <Output PropertyName=""IntOutput"" TaskParameter=""IntOutput"" />
             <Output PropertyName=""IntArrayOutput"" TaskParameter=""IntArrayOutput"" />
-            <Output PropertyName=""EnumOutput"" TaskParameter=""EnumOutput"" />
+            <Output PropertyName=""UIntOutput"" TaskParameter=""UIntOutput"" />
+            <Output PropertyName=""UIntArrayOutput"" TaskParameter=""UIntArrayOutput"" />
+            <Output PropertyName=""LongOutput"" TaskParameter=""LongOutput"" />
+            <Output PropertyName=""LongArrayOutput"" TaskParameter=""LongArrayOutput"" />
+            <Output PropertyName=""ULongOutput"" TaskParameter=""ULongOutput"" />
+            <Output PropertyName=""ULongArrayOutput"" TaskParameter=""ULongArrayOutput"" />
+            <Output PropertyName=""DecimalOutput"" TaskParameter=""DecimalOutput"" />
+            <Output PropertyName=""DecimalArrayOutput"" TaskParameter=""DecimalArrayOutput"" />
+            <Output PropertyName=""CharOutput"" TaskParameter=""CharOutput"" />
+            <Output PropertyName=""CharArrayOutput"" TaskParameter=""CharArrayOutput"" />
             <Output PropertyName=""StringOutput"" TaskParameter=""StringOutput"" />
             <Output PropertyName=""StringArrayOutput"" TaskParameter=""StringArrayOutput"" />
+            <Output PropertyName=""DateTimeOutput"" TaskParameter=""DateTimeOutput"" />
+            <Output PropertyName=""DateTimeArrayOutput"" TaskParameter=""DateTimeArrayOutput"" />
+            <Output PropertyName=""CustomStructOutput"" TaskParameter=""CustomStructOutput"" />
+            <Output PropertyName=""EnumOutput"" TaskParameter=""EnumOutput"" />
         </{nameof(TaskBuilderTestTask)}>
     </Target>
 </Project>";
             TransientTestProjectWithFiles project = env.CreateTestProjectWithFiles(projectContents);
             ProjectInstance projectInstance = new(project.ProjectFile);
             projectInstance.Build(new[] { new MockLogger(env.Output) }).ShouldBeTrue();
+
+            projectInstance.GetPropertyValue("BoolOutput").ShouldBe(boolParam);
+            projectInstance.GetPropertyValue("BoolArrayOutput").ShouldBe(boolArrayParam);
+            projectInstance.GetPropertyValue("ByteOutput").ShouldBe(byteParam);
+            projectInstance.GetPropertyValue("ByteArrayOutput").ShouldBe(byteArrayParam);
+            projectInstance.GetPropertyValue("SByteOutput").ShouldBe(sbyteParam);
+            projectInstance.GetPropertyValue("SByteArrayOutput").ShouldBe(sbyteArrayParam);
+            projectInstance.GetPropertyValue("DoubleOutput").ShouldBe(doubleParam);
+            projectInstance.GetPropertyValue("DoubleArrayOutput").ShouldBe(doubleArrayParam);
+            projectInstance.GetPropertyValue("FloatOutput").ShouldBe(floatParam);
+            projectInstance.GetPropertyValue("FloatArrayOutput").ShouldBe(floatArrayParam);
+            projectInstance.GetPropertyValue("ShortOutput").ShouldBe(shortParam);
+            projectInstance.GetPropertyValue("ShortArrayOutput").ShouldBe(shortArrayParam);
+            projectInstance.GetPropertyValue("UShortOutput").ShouldBe(ushortParam);
+            projectInstance.GetPropertyValue("UShortArrayOutput").ShouldBe(ushortArrayParam);
+            projectInstance.GetPropertyValue("IntOutput").ShouldBe(intParam);
+            projectInstance.GetPropertyValue("IntArrayOutput").ShouldBe(intArrayParam);
+            projectInstance.GetPropertyValue("UIntOutput").ShouldBe(uintParam);
+            projectInstance.GetPropertyValue("UIntArrayOutput").ShouldBe(uintArrayParam);
+            projectInstance.GetPropertyValue("LongOutput").ShouldBe(longParam);
+            projectInstance.GetPropertyValue("LongArrayOutput").ShouldBe(longArrayParam);
+            projectInstance.GetPropertyValue("ULongOutput").ShouldBe(ulongParam);
+            projectInstance.GetPropertyValue("ULongArrayOutput").ShouldBe(ulongArrayParam);
+            projectInstance.GetPropertyValue("DecimalOutput").ShouldBe(decimalParam);
+            projectInstance.GetPropertyValue("DecimalArrayOutput").ShouldBe(decimalArrayParam);
+            projectInstance.GetPropertyValue("CharOutput").ShouldBe(charParam);
+            projectInstance.GetPropertyValue("CharArrayOutput").ShouldBe(charArrayParam);
+            projectInstance.GetPropertyValue("StringOutput").ShouldBe(stringParam);
+            projectInstance.GetPropertyValue("StringArrayOutput").ShouldBe(stringArrayParam);
+            projectInstance.GetPropertyValue("DateTimeOutput").ShouldBe(dateTimeParam);
+            projectInstance.GetPropertyValue("DateTimeArrayOutput").ShouldBe(dateTimeArrayParam);
+            projectInstance.GetPropertyValue("CustomStructOutput").ShouldBe(TaskBuilderTestTask.s_customStruct.ToString(CultureInfo.InvariantCulture));
+            projectInstance.GetPropertyValue("EnumOutput").ShouldBe(TargetBuiltReason.BeforeTargets.ToString());
         }
     }
 }
diff --git a/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
new file mode 100644
index 00000000000..40a33b6aacb
--- /dev/null
+++ b/src/Build.UnitTests/TerminalLoggerConfiguration_Tests.cs
@@ -0,0 +1,233 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+#nullable disable
+using System;
+using System.Collections.Generic;
+using Microsoft.Build.Framework.Telemetry;
+using Microsoft.Build.UnitTests.Shared;
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.UnitTests;
+
+/// <summary>
+/// End to end tests for the terminal logger configuration.
+/// We need to execute msbuild process as tested code path is also in XMake.cs.
+/// Also verifies that the telemetry is logged correctly.
+/// Because we need to test the telemetry for the terminal logger, we need to use the MockLogger which outputs all telemetry properties.
+/// </summary>
+public class TerminalLoggerConfiguration_Tests : IDisposable
+{
+    private readonly TestEnvironment _env;
+
+    private readonly string _cmd;
+    private readonly ITestOutputHelper _output;
+
+    public TerminalLoggerConfiguration_Tests(ITestOutputHelper output)
+    {
+        _env = TestEnvironment.Create(output);
+        _output = output;
+
+        TransientTestFolder logFolder = _env.CreateFolder(createFolder: true);
+        TransientTestFile projectFile = _env.CreateFile(logFolder, "myProj.proj", $"""
+            <Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" DefaultTargets="Hello">
+                <Target Name="Hello">
+                  <Message Text="Hello, world!" />
+                </Target>
+            </Project>
+            """);
+        _cmd = $"{projectFile.Path} -target:Hello -logger:{typeof(MockLogger).FullName},{typeof(MockLogger).Assembly.Location};ReportTelemetry";
+    }
+
+    /// <summary>
+    /// TearDown
+    /// </summary>
+    public void Dispose()
+    {
+        _env.Dispose();
+    }
+
+    [Theory]
+    [InlineData("on")]
+    [InlineData("true")]
+    public void TerminalLoggerOn(string tlValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tl:{tlValue}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = bool.FalseString,
+            TerminalLoggerDefaultSource = "msbuild",
+            TerminalLoggerUserIntent = tlValue,
+            TerminalLoggerUserIntentSource = "arg",
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("")]
+    [InlineData("auto")]
+    public void TerminalLoggerWithTlAutoIsOff(string tlValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tl:{tlValue}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = false,
+            TerminalLoggerDefault = bool.FalseString,
+            TerminalLoggerDefaultSource = "msbuild",
+            TerminalLoggerUserIntent = tlValue,
+            TerminalLoggerUserIntentSource = "arg",
+            ConsoleLogger = true,
+            ConsoleLoggerType = "parallel",
+            ConsoleLoggerVerbosity = "normal",
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldNotBeTerminalLog(output);
+    }
+
+
+    [Fact]
+    public void TerminalLoggerDefaultByEnv()
+    {
+        _env.SetEnvironmentVariable("DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER", bool.TrueString);
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tlp:default={bool.TrueString}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = bool.TrueString,
+            TerminalLoggerDefaultSource = "DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER",
+            TerminalLoggerUserIntent = null,
+            TerminalLoggerUserIntentSource = null,
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("MSBUILDLIVELOGGER")]
+    [InlineData("MSBUILDTERMINALLOGGER")]
+    public void TerminalLoggerOnByEnv(string envVarSource)
+    {
+        _env.SetEnvironmentVariable(envVarSource, bool.TrueString);
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = bool.FalseString,
+            TerminalLoggerDefaultSource = "msbuild",
+            TerminalLoggerUserIntent = bool.TrueString,
+            TerminalLoggerUserIntentSource = envVarSource,
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("on")]
+    [InlineData("true")]
+    public void TerminalLoggerDefaultOn(string defaultValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tlp:default={defaultValue}", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = true,
+            TerminalLoggerDefault = defaultValue,
+            TerminalLoggerDefaultSource = "sdk",
+            TerminalLoggerUserIntent = null,
+            TerminalLoggerUserIntentSource = null,
+            ConsoleLogger = false,
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldBeTerminalLog(output);
+    }
+
+    [Theory]
+    [InlineData("off")]
+    [InlineData("false")]
+    public void TerminalLoggerDefaultOff(string defaultValue)
+    {
+        string output = RunnerUtilities.ExecMSBuild($"{_cmd} -tlp:default={defaultValue} -v:m", out bool success);
+        success.ShouldBeTrue();
+
+        LoggingConfigurationTelemetry expectedTelemetry = new LoggingConfigurationTelemetry
+        {
+            TerminalLogger = false,
+            TerminalLoggerDefault = defaultValue,
+            TerminalLoggerDefaultSource = "sdk",
+            TerminalLoggerUserIntent = null,
+            TerminalLoggerUserIntentSource = null,
+            ConsoleLogger = true,
+            ConsoleLoggerVerbosity = "minimal",
+            ConsoleLoggerType = "parallel", 
+            FileLogger = false,
+        };
+
+        expectedTelemetry.UpdateEventProperties();
+        foreach (KeyValuePair<string, string> pair in expectedTelemetry.Properties)
+        {
+            output.ShouldContain($"{expectedTelemetry.EventName}:{pair.Key}={pair.Value}");
+        }
+
+        // Test if there is ANSI clear screen sequence, which shall only occur when the terminal logger was enabled.
+        ShouldNotBeTerminalLog(output);
+    }
+
+    private static void ShouldBeTerminalLog(string output) => output.ShouldContain("\x1b[?25l");
+    private static void ShouldNotBeTerminalLog(string output) => output.ShouldNotContain("\x1b[?25l");
+}
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index f7c18f5c7cd..9173872ac7a 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -566,6 +566,10 @@ public void BeginBuild(BuildParameters parameters)
                 // Log deferred messages and response files
                 LogDeferredMessages(loggingService, _deferredBuildMessages);
 
+                // Log known deferred telemetry
+                KnownTelemetry.LoggingConfigurationTelemetry.UpdateEventProperties();
+                loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.LoggingConfigurationTelemetry.EventName, KnownTelemetry.LoggingConfigurationTelemetry.Properties);
+
                 InitializeCaches();
 
                 _projectCacheService = new ProjectCacheService(
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index 6dfc5cfb26d..fb8e59007e3 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -5,6 +5,7 @@
 using System.IO;
 using System.IO.Compression;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 
@@ -191,6 +192,8 @@ public void Initialize(IEventSource eventSource)
             LogInitialInfo();
 
             eventSource.AnyEventRaised += EventSource_AnyEventRaised;
+
+            KnownTelemetry.LoggingConfigurationTelemetry.BinaryLogger = true;
         }
 
         private void EventArgsWriter_EmbedFile(string filePath)
@@ -356,6 +359,7 @@ private void ProcessParameters()
             {
                 FilePath = "msbuild.binlog";
             }
+            KnownTelemetry.LoggingConfigurationTelemetry.BinaryLoggerUsedDefaultName = FilePath == "msbuild.binlog";
 
             try
             {
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index be295c3bf94..136b0c94d7f 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -4,6 +4,7 @@
 using System;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 using BaseConsoleLogger = Microsoft.Build.BackEnd.Logging.BaseConsoleLogger;
 using ParallelConsoleLogger = Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger;
@@ -158,10 +159,26 @@ private void InitializeBaseConsoleLogger()
             if (_numberOfProcessors == 1 && !useMPLogger)
             {
                 _consoleLogger = new SerialConsoleLogger(_verbosity, _write, _colorSet, _colorReset);
+                if (this is FileLogger)
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.FileLoggerType = "serial";
+                }
+                else
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLoggerType = "serial";
+                }
             }
             else
             {
                 _consoleLogger = new ParallelConsoleLogger(_verbosity, _write, _colorSet, _colorReset);
+                if (this is FileLogger)
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.FileLoggerType = "parallel";
+                }
+                else
+                {
+                    KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLoggerType = "parallel";
+                }
             }
 
             if (_showSummary != null)
@@ -339,6 +356,12 @@ public virtual void Initialize(IEventSource eventSource, int nodeCount)
             _numberOfProcessors = nodeCount;
             InitializeBaseConsoleLogger();
             _consoleLogger.Initialize(eventSource, nodeCount);
+
+            if (this is not FileLogger)
+            {
+                KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLogger = true;
+                KnownTelemetry.LoggingConfigurationTelemetry.ConsoleLoggerVerbosity = Verbosity.ToString();
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Logging/FileLogger.cs b/src/Build/Logging/FileLogger.cs
index 180d58a2a08..bd0abc891b9 100644
--- a/src/Build/Logging/FileLogger.cs
+++ b/src/Build/Logging/FileLogger.cs
@@ -7,6 +7,7 @@
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -87,6 +88,9 @@ private void InitializeFileLogger(IEventSource eventSource, int nodeCount)
             // Finally, ask the base console logger class to initialize. It may
             // want to make decisions based on our verbosity, so we do this last.
             base.Initialize(eventSource, nodeCount);
+            KnownTelemetry.LoggingConfigurationTelemetry.FileLoggersCount++;
+            KnownTelemetry.LoggingConfigurationTelemetry.FileLogger = true;
+            KnownTelemetry.LoggingConfigurationTelemetry.FileLoggerVerbosity = Verbosity.ToString();
 
             if (!SkipProjectStartedText && Verbosity >= LoggerVerbosity.Normal)
             {
diff --git a/src/Framework/BinaryTranslator.cs b/src/Framework/BinaryTranslator.cs
index a2eab07d302..995cfebfbc7 100644
--- a/src/Framework/BinaryTranslator.cs
+++ b/src/Framework/BinaryTranslator.cs
@@ -116,6 +116,26 @@ public void Translate(ref bool value)
                 value = _reader.ReadBoolean();
             }
 
+            /// <summary>
+            /// Translates an <see langword="bool"/> array.
+            /// </summary>
+            /// <param name="array">The array to be translated.</param>
+            public void Translate(ref bool[] array)
+            {
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = _reader.ReadInt32();
+                array = new bool[count];
+
+                for (int i = 0; i < count; i++)
+                {
+                    array[i] = _reader.ReadBoolean();
+                }
+            }
+
             /// <summary>
             /// Translates a byte.
             /// </summary>
@@ -808,6 +828,26 @@ public void Translate(ref bool value)
                 _writer.Write(value);
             }
 
+            /// <summary>
+            /// Translates an <see langword="bool"/> array.
+            /// </summary>
+            /// <param name="array">The array to be translated.</param>
+            public void Translate(ref bool[] array)
+            {
+                if (!TranslateNullable(array))
+                {
+                    return;
+                }
+
+                int count = array.Length;
+                _writer.Write(count);
+
+                for (int i = 0; i < count; i++)
+                {
+                    _writer.Write(array[i]);
+                }
+            }
+
             /// <summary>
             /// Translates a byte.
             /// </summary>
diff --git a/src/Framework/ITranslator.cs b/src/Framework/ITranslator.cs
index abe32f8d96f..930cc45f6b2 100644
--- a/src/Framework/ITranslator.cs
+++ b/src/Framework/ITranslator.cs
@@ -104,6 +104,12 @@ BinaryWriter Writer
         /// <param name="value">The value to be translated.</param>
         void Translate(ref bool value);
 
+        /// <summary>
+        /// Translates an <see langword="bool"/> array.
+        /// </summary>
+        /// <param name="array">The array to be translated.</param>
+        void Translate(ref bool[] array);
+
         /// <summary>
         /// Translates a byte.
         /// </summary>
diff --git a/src/Framework/Telemetry/KnownTelemetry.cs b/src/Framework/Telemetry/KnownTelemetry.cs
index 2a335fa0930..7685bdda537 100644
--- a/src/Framework/Telemetry/KnownTelemetry.cs
+++ b/src/Framework/Telemetry/KnownTelemetry.cs
@@ -15,4 +15,9 @@ internal static class KnownTelemetry
     /// Null means there are no prior collected build telemetry data, new clean instance shall be created for particular build.
     /// </summary>
     public static BuildTelemetry? PartialBuildTelemetry { get; set; }
+
+    /// <summary>
+    /// Describes how logging was configured.
+    /// </summary>
+    public static LoggingConfigurationTelemetry LoggingConfigurationTelemetry { get; } = new LoggingConfigurationTelemetry();
 }
diff --git a/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
new file mode 100644
index 00000000000..5281c43b9d2
--- /dev/null
+++ b/src/Framework/Telemetry/LoggingConfigurationTelemetry.cs
@@ -0,0 +1,150 @@
+﻿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Globalization;
+
+namespace Microsoft.Build.Framework.Telemetry;
+
+internal class LoggingConfigurationTelemetry : TelemetryBase
+{
+    public override string EventName => "loggingConfiguration";
+
+    /// <summary>
+    /// True if terminal logger was used.
+    /// </summary>
+    public bool TerminalLogger { get; set; }
+
+    /// <summary>
+    /// What was user intent:
+    ///   on | true -> user intent to enable logging
+    ///   off | false -> user intent to disable logging
+    ///   auto -> user intent to use logging if terminal allows it
+    ///   null -> no user intent, using default
+    /// </summary>
+    public string? TerminalLoggerUserIntent { get; set; }
+
+    /// <summary>
+    /// How was user intent signaled:
+    ///   arg -> from command line argument or rsp file
+    ///   MSBUILDTERMINALLOGGER -> from environment variable
+    ///   MSBUILDLIVELOGGER -> from environment variable
+    ///   null -> no user intent
+    /// </summary>
+    public string? TerminalLoggerUserIntentSource { get; set; }
+
+    /// <summary>
+    /// The default behavior of terminal logger if user intent is not specified:
+    ///   on | true -> enable logging
+    ///   off | false -> disable logging
+    ///   auto -> use logging if terminal allows it
+    ///   null -> unspecified
+    /// </summary>
+    public string? TerminalLoggerDefault { get; set; }
+
+    /// <summary>
+    /// How was default behavior signaled:
+    ///   sdk -> from SDK
+    ///   DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER -> from environment variable
+    ///   msbuild -> MSBuild hardcoded default
+    ///   null -> unspecified
+    /// </summary>
+    public string? TerminalLoggerDefaultSource { get; set; }
+
+    /// <summary>
+    /// True if console logger was used.
+    /// </summary>
+    public bool ConsoleLogger { get; set; }
+
+    /// <summary>
+    /// Type of console logger: serial | parallel
+    /// </summary>
+    public string? ConsoleLoggerType { get; set; }
+
+    /// <summary>
+    /// Verbosity of console logger: quiet | minimal | normal | detailed | diagnostic
+    /// </summary>
+    public string? ConsoleLoggerVerbosity { get; set; }
+
+
+    /// <summary>
+    /// True if file logger was used.
+    /// </summary>
+    public bool FileLogger { get; set; }
+
+    /// <summary>
+    /// Type of file logger: serial | parallel
+    /// </summary>
+    public string? FileLoggerType { get; set; }
+
+    /// <summary>
+    /// Number of file loggers.
+    /// </summary>
+    public int FileLoggersCount { get; set; }
+
+    /// <summary>
+    /// Verbosity of file logger: quiet | minimal | normal | detailed | diagnostic
+    /// </summary>
+    public string? FileLoggerVerbosity { get; set; }
+
+    /// <summary>
+    /// True if binary logger was used.
+    /// </summary>
+    public bool BinaryLogger { get; set; }
+
+    /// <summary>
+    /// True if binary logger used default name i.e. no LogFile was specified.
+    /// </summary>
+    public bool BinaryLoggerUsedDefaultName { get; set; }
+
+    public override void UpdateEventProperties()
+    {
+        Properties["TerminalLogger"] = TerminalLogger.ToString(CultureInfo.InvariantCulture);
+
+        if (TerminalLoggerUserIntent != null)
+        {
+            Properties["TerminalLoggerUserIntent"] = TerminalLoggerUserIntent;
+        }
+
+        if (TerminalLoggerUserIntentSource != null)
+        {
+            Properties["TerminalLoggerUserIntentSource"] = TerminalLoggerUserIntentSource;
+        }
+
+        if (TerminalLoggerDefault != null)
+        {
+            Properties["TerminalLoggerDefault"] = TerminalLoggerDefault;
+        }
+
+        if (TerminalLoggerDefaultSource != null)
+        {
+            Properties["TerminalLoggerDefaultSource"] = TerminalLoggerDefaultSource;
+        }
+
+        Properties["ConsoleLogger"] = ConsoleLogger.ToString(CultureInfo.InvariantCulture);
+        if (ConsoleLoggerType != null)
+        {
+            Properties["ConsoleLoggerType"] = ConsoleLoggerType;
+        }
+
+        if (ConsoleLoggerVerbosity != null)
+        {
+            Properties["ConsoleLoggerVerbosity"] = ConsoleLoggerVerbosity;
+        }
+
+        Properties["FileLogger"] = FileLogger.ToString(CultureInfo.InvariantCulture);
+        if (FileLoggerType != null)
+        {
+            Properties["FileLoggerType"] = FileLoggerType;
+            Properties["FileLoggersCount"] = FileLoggersCount.ToString(CultureInfo.InvariantCulture);
+        }
+
+        if (FileLoggerVerbosity != null)
+        {
+            Properties["FileLoggerVerbosity"] = FileLoggerVerbosity;
+        }
+
+        Properties["BinaryLogger"] = BinaryLogger.ToString(CultureInfo.InvariantCulture);
+        Properties["BinaryLoggerUsedDefaultName"] = BinaryLoggerUsedDefaultName.ToString(CultureInfo.InvariantCulture);
+    }
+}
diff --git a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
index 49afdbbf22f..4e1dddaf992 100644
--- a/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
+++ b/src/MSBuild.UnitTests/CommandLineSwitches_Tests.cs
@@ -203,6 +203,28 @@ public void FileLoggerParametersIdentificationTests(string fileloggerparameters)
             unquoteParameters.ShouldBeTrue();
         }
 
+        [Theory]
+        [InlineData("tlp")]
+        [InlineData("TLP")]
+        [InlineData("terminalLoggerParameters")]
+        [InlineData("TERMINALLOGGERPARAMETERS")]
+        public void TerminalLoggerParametersIdentificationTests(string terminalLoggerParameters)
+        {
+            CommandLineSwitches.ParameterizedSwitch parameterizedSwitch;
+            string duplicateSwitchErrorMessage;
+            bool multipleParametersAllowed;
+            string missingParametersErrorMessage;
+            bool unquoteParameters;
+            bool emptyParametersAllowed;
+
+            CommandLineSwitches.IsParameterizedSwitch(terminalLoggerParameters, out parameterizedSwitch, out duplicateSwitchErrorMessage, out multipleParametersAllowed, out missingParametersErrorMessage, out unquoteParameters, out emptyParametersAllowed).ShouldBeTrue();
+            parameterizedSwitch.ShouldBe(CommandLineSwitches.ParameterizedSwitch.TerminalLoggerParameters);
+            duplicateSwitchErrorMessage.ShouldBeNull();
+            multipleParametersAllowed.ShouldBeFalse();
+            missingParametersErrorMessage.ShouldNotBeNull();
+            unquoteParameters.ShouldBeTrue();
+        }
+
 #if FEATURE_NODE_REUSE
         [Theory]
         [InlineData("nr")]
diff --git a/src/MSBuild/CommandLineSwitches.cs b/src/MSBuild/CommandLineSwitches.cs
index 0ad85e467d8..f7275f81502 100644
--- a/src/MSBuild/CommandLineSwitches.cs
+++ b/src/MSBuild/CommandLineSwitches.cs
@@ -90,6 +90,7 @@ internal enum ParameterizedSwitch
             FileLoggerParameters8,
             FileLoggerParameters9,
             TerminalLogger,
+            TerminalLoggerParameters,
             NodeReuse,
             Preprocess,
             Targets,
@@ -248,6 +249,7 @@ internal ParameterizedSwitchInfo(
             new ParameterizedSwitchInfo(  new string[] { "fileloggerparameters9", "flp9" },     ParameterizedSwitch.FileLoggerParameters9,      null,                           false,          "MissingFileLoggerParameterError",     true,   false),
             // To not break existing use, keep supporting live logger switches
             new ParameterizedSwitchInfo(  new string[] { "livelogger", "ll", "terminallogger", "tl" }, ParameterizedSwitch.TerminalLogger,      null,                           true,           null,                                  true,   true),
+            new ParameterizedSwitchInfo(  new string[] { "terminalloggerparameters", "tlp" },   ParameterizedSwitch.TerminalLoggerParameters,   null,                           false,          "MissingTerminalLoggerParameterError", true,   false),
             new ParameterizedSwitchInfo(  new string[] { "nodereuse", "nr" },                   ParameterizedSwitch.NodeReuse,                  null,                           false,          "MissingNodeReuseParameterError",      true,   false),
             new ParameterizedSwitchInfo(  new string[] { "preprocess", "pp" },                  ParameterizedSwitch.Preprocess,                 null,                           false,          null,                                  true,   false),
             new ParameterizedSwitchInfo(  new string[] { "targets", "ts" },                     ParameterizedSwitch.Targets,                    null,                           false,          null,                                  true,   false),
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 6ec39bba3c9..2c935aff7b2 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -1167,6 +1167,15 @@
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </comment>
   </data>
+  <data name="MissingTerminalLoggerParameterError" UESanitized="true" Visibility="Public">
+    <value>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</value>
+    <comment>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </comment>
+  </data>
   <data name="MissingNodeReuseParameterError" UESanitized="true" Visibility="Public">
     <value>MSBUILD : error MSB1041: Specify one or more parameters for node reuse if using the -nodeReuse switch</value>
     <comment>{StrBegin="MSBUILD : error MSB1041: "}
@@ -1509,7 +1518,7 @@
     <!--
         The command line message bucket is: MSB1001 - MSB1999
 
-        Next error code should be MSB1066.
+        Next error code should be MSB1067.
 
         Don't forget to update this comment after using the new code.
   -->
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 4976dd10dc3..e6a476b3e62 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -1345,6 +1345,16 @@ Když se nastaví na MessageUponIsolationViolation (nebo jeho krátký
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 4d9dc20862d..a46ccf6d8e7 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -1332,6 +1332,16 @@ Dieses Protokollierungsformat ist standardmäßig aktiviert.
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index 328d8021303..9f96cd34cec 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -1339,6 +1339,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 894031b249e..4f47f42754b 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -1332,6 +1332,16 @@ Remarque : verbosité des enregistreurs d’événements de fichiers
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 1f3735f97f8..bc3680ba361 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -1343,6 +1343,16 @@ Nota: livello di dettaglio dei logger di file
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index a8c7e7ebb28..4570b627fd2 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -1332,6 +1332,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index b5c595ebd23..fe84ab098dc 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -1332,6 +1332,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index 281f5ba70d0..843e4c18183 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -1343,6 +1343,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index a6f169c8507..01b3db027b5 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -1333,6 +1333,16 @@ arquivo de resposta.
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 09051d698ae..26c3dcc2dd1 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -1331,6 +1331,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 3dfeed45d10..669b02a92b8 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -1336,6 +1336,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index f4ee7990aaf..924411e326d 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -1332,6 +1332,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index d8a665ef32d..16866b4f8bc 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -1332,6 +1332,16 @@
       {StrBegin="MSBUILD : error MSB1004: "}UE: This happens if the user does something like "msbuild.exe -target". The user must pass in an actual target name
       following the switch, as in "msbuild.exe -target:blah".
       LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
+    </note>
+      </trans-unit>
+      <trans-unit id="MissingTerminalLoggerParameterError">
+        <source>MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</source>
+        <target state="new">MSBUILD : error MSB1066: Specify one or more parameters for the terminal logger if using the -terminalLoggerParameters switch</target>
+        <note>
+      {StrBegin="MSBUILD : error MSB1066: "}
+      UE: This happens if the user does something like "msbuild.exe -termionalLoggerParameters:". The user must pass in one or more parameters
+      after the switch e.g. "msbuild.exe -terminalLoggerParameters:default=auto".
+      LOCALIZATION: The prefix "MSBUILD : error MSBxxxx:" should not be localized.
     </note>
       </trans-unit>
       <trans-unit id="MissingToolsVersionError">
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index 9097ee42210..f9abb1c670f 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -2446,7 +2446,7 @@ private static bool ProcessCommandLineSwitches(
 
                     outputResultsCache = ProcessOutputResultsCache(commandLineSwitches);
 
-                    bool terminallogger = ProcessTerminalLoggerConfiguration(commandLineSwitches);
+                    bool useTerminalLogger = ProcessTerminalLoggerConfiguration(commandLineSwitches, out string aggregatedTerminalLoggerParameters);
 
                     // figure out which loggers are going to listen to build events
                     string[][] groupedFileLoggerParameters = commandLineSwitches.GetFileLoggerParameters();
@@ -2457,7 +2457,8 @@ private static bool ProcessCommandLineSwitches(
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Verbosity],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoConsoleLogger],
                         commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.DistributedFileLogger],
-                        terminallogger,
+                        useTerminalLogger,
+                        aggregatedTerminalLoggerParameters,
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.FileLoggerParameters], // used by DistributedFileLogger
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.ConsoleLoggerParameters],
                         commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.BinaryLogger],
@@ -2514,87 +2515,200 @@ private static bool ProcessCommandLineSwitches(
             return invokeBuild;
         }
 
-        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches)
+        private static bool ProcessTerminalLoggerConfiguration(CommandLineSwitches commandLineSwitches, out string aggregatedParameters)
         {
-            string terminalloggerArg;
+            aggregatedParameters = AggregateParameters(commandLineSwitches);
+            string defaultValue = FindDefaultValue(aggregatedParameters);
 
-            // Command line wins, so check it first
-            if (commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.TerminalLogger))
+            string terminalLoggerArg = null;
+            if (!TryFromCommandLine(commandLineSwitches) && !TryFromEnvironmentVariables())
             {
+                ApplyDefault();
+            }
+
+            terminalLoggerArg = NormalizeIntoBooleanValues();
+
+            bool useTerminalLogger = false;
+            if (!TrueOrFalse())
+            {
+                ItMustBeAuto();
+            }
+
+            return KnownTelemetry.LoggingConfigurationTelemetry.TerminalLogger = useTerminalLogger;
+
+            static bool CheckIfTerminalIsSupportedAndTryEnableAnsiColorCodes()
+            {
+                (var acceptAnsiColorCodes, var outputIsScreen, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+
+                if (!outputIsScreen)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedRedirected"), MessageImportance.Low));
+                    return false;
+                }
+
+                // TerminalLogger is not used if the terminal does not support ANSI/VT100 escape sequences.
+                if (!acceptAnsiColorCodes)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedNotSupported"), MessageImportance.Low));
+                    return false;
+                }
+
+                if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
+                {
+                    s_globalMessagesToLogInBuildLoggers.Add(
+                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedDisabled"), MessageImportance.Low));
+                    return false;
+                }
+
+                return true;
+            }
+
+            string FindDefaultValue(string s)
+            {
+                // Find default configuration so it is part of telemetry even when default is not used.
+                // Default can be stored in /tlp:default=true|false|on|off|auto
+                string terminalLoggerDefault = null;
+                foreach (string parameter in s.Split(MSBuildConstants.SemicolonChar))
+                {
+                    if (string.IsNullOrWhiteSpace(parameter))
+                    {
+                        continue;
+                    }
+
+                    string[] parameterAndValue = parameter.Split(MSBuildConstants.EqualsChar);
+                    if (parameterAndValue[0].Equals("default", StringComparison.InvariantCultureIgnoreCase) && parameterAndValue.Length > 1)
+                    {
+                        terminalLoggerDefault = parameterAndValue[1];
+                    }
+                }
+
+                if (terminalLoggerDefault == null)
+                {
+                    terminalLoggerDefault = bool.FalseString;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefault = bool.FalseString;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefaultSource = "msbuild";
+                }
+                else
+                {
+                    // Lets check DOTNET CLI env var
+                    string dotnetCliEnvVar = Environment.GetEnvironmentVariable("DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER");
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefault = terminalLoggerDefault;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerDefaultSource = string.IsNullOrWhiteSpace(dotnetCliEnvVar) ? "sdk" : "DOTNET_CLI_CONFIGURE_MSBUILD_TERMINAL_LOGGER";
+                }
+
+                return terminalLoggerDefault;
+            }
+
+            bool TryFromCommandLine(CommandLineSwitches commandLineSwitches1)
+            {
+                if (!commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.TerminalLogger))
+                {
+                    return false;
+                }
+
                 // There's a switch set, but there might be more than one
-                string[] switches = commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.TerminalLogger];
+                string[] switches = commandLineSwitches1[CommandLineSwitches.ParameterizedSwitch.TerminalLogger];
 
-                terminalloggerArg = switches[switches.Length - 1];
+                terminalLoggerArg = switches[switches.Length - 1];
 
                 // if the switch was set but not to an explicit value, the value is "auto"
-                if (string.IsNullOrEmpty(terminalloggerArg))
+                if (string.IsNullOrEmpty(terminalLoggerArg))
                 {
-                    terminalloggerArg = "auto";
+                    terminalLoggerArg = "auto";
                 }
+
+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalLoggerArg ?? string.Empty;
+                KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = "arg";
+
+                return true;
             }
-            else
+
+            bool TryFromEnvironmentVariables()
             {
                 // Keep MSBUILDLIVELOGGER supporitng existing use. But MSBUILDTERMINALLOGGER takes precedence.
                 string liveLoggerArg = Environment.GetEnvironmentVariable("MSBUILDLIVELOGGER");
-                terminalloggerArg = Environment.GetEnvironmentVariable("MSBUILDTERMINALLOGGER");
-                if (!string.IsNullOrEmpty(terminalloggerArg))
+                terminalLoggerArg = Environment.GetEnvironmentVariable("MSBUILDTERMINALLOGGER");
+                if (!string.IsNullOrEmpty(terminalLoggerArg))
                 {
                     s_globalMessagesToLogInBuildLoggers.Add(
-                        new BuildManager.DeferredBuildMessage($"The environment variable MSBUILDTERMINALLOGGER was set to {terminalloggerArg}.", MessageImportance.Low));
+                        new BuildManager.DeferredBuildMessage($"The environment variable MSBUILDTERMINALLOGGER was set to {terminalLoggerArg}.", MessageImportance.Low));
+
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalLoggerArg;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = "MSBUILDTERMINALLOGGER";
                 }
                 else if (!string.IsNullOrEmpty(liveLoggerArg))
                 {
-                    terminalloggerArg = liveLoggerArg;
+                    terminalLoggerArg = liveLoggerArg;
                     s_globalMessagesToLogInBuildLoggers.Add(
                         new BuildManager.DeferredBuildMessage($"The environment variable MSBUILDLIVELOGGER was set to {liveLoggerArg}.", MessageImportance.Low));
+
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntent = terminalLoggerArg;
+                    KnownTelemetry.LoggingConfigurationTelemetry.TerminalLoggerUserIntentSource = "MSBUILDLIVELOGGER";
                 }
                 else
                 {
                     return false;
                 }
+
+                return true;
             }
 
-            // We now have a string. It can be "true" or "false" which means just that:
-            if (bool.TryParse(terminalloggerArg, out bool result))
+            string NormalizeIntoBooleanValues()
             {
-                return result;
+                // We now have a string`. It can be "true" or "false" which means just that:
+                if (terminalLoggerArg.Equals("on", StringComparison.InvariantCultureIgnoreCase))
+                {
+                    terminalLoggerArg = bool.TrueString;
+                }
+                else if (terminalLoggerArg.Equals("off", StringComparison.InvariantCultureIgnoreCase))
+                {
+                    terminalLoggerArg = bool.FalseString;
+                }
+
+                return terminalLoggerArg;
             }
 
-            // or it can be "auto", meaning "enable if we can"
-            if (!terminalloggerArg.Equals("auto", StringComparison.OrdinalIgnoreCase))
+            void ApplyDefault()
             {
-                CommandLineSwitchException.Throw("InvalidTerminalLoggerValue", terminalloggerArg);
+                terminalLoggerArg = defaultValue;
             }
 
-            return DoesEnvironmentSupportTerminalLogger();
-
-            static bool DoesEnvironmentSupportTerminalLogger()
+            string AggregateParameters(CommandLineSwitches switches)
             {
-                (var acceptAnsiColorCodes, var outputIsScreen, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+                string[] terminalLoggerParameters = switches[CommandLineSwitches.ParameterizedSwitch.TerminalLoggerParameters];
+                return terminalLoggerParameters?.Length > 0 ? MSBuildApp.AggregateParameters(string.Empty, terminalLoggerParameters) : string.Empty;
+            }
 
-                if (!outputIsScreen)
+            bool TrueOrFalse()
+            {
+                if (bool.TryParse(terminalLoggerArg, out bool result))
                 {
-                    s_globalMessagesToLogInBuildLoggers.Add(
-                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedRedirected"), MessageImportance.Low));
-                    return false;
-                }
+                    useTerminalLogger = result;
 
-                // TerminalLogger is not used if the terminal does not support ANSI/VT100 escape sequences.
-                if (!acceptAnsiColorCodes)
-                {
-                    s_globalMessagesToLogInBuildLoggers.Add(
-                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedNotSupported"), MessageImportance.Low));
-                    return false;
+                    // Try Enable Ansi Color Codes when terminal logger is enabled/enforced.
+                    if (result)
+                    {
+                        // This needs to be called so Ansi Color Codes are enabled for the terminal logger.
+                        (_, _, s_originalConsoleMode) = NativeMethodsShared.QueryIsScreenAndTryEnableAnsiColorCodes();
+                    }
+
+                    return true;
                 }
 
-                if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
+                return false;
+            }
+
+            void ItMustBeAuto()
+            {
+                // or it can be "auto", meaning "enable if we can"
+                if (!terminalLoggerArg.Equals("auto", StringComparison.OrdinalIgnoreCase))
                 {
-                    s_globalMessagesToLogInBuildLoggers.Add(
-                        new BuildManager.DeferredBuildMessage(ResourceUtilities.GetResourceString("TerminalLoggerNotUsedDisabled"), MessageImportance.Low));
-                    return false;
+                    CommandLineSwitchException.Throw("InvalidTerminalLoggerValue", terminalLoggerArg);
                 }
 
-                return true;
+                useTerminalLogger = CheckIfTerminalIsSupportedAndTryEnableAnsiColorCodes();
             }
         }
 
@@ -3354,6 +3468,7 @@ private static ILogger[] ProcessLoggingSwitches(
             bool noConsoleLogger,
             bool distributedFileLogger,
             bool terminalloggerOptIn,
+            string aggregatedTerminalLoggerParameters,
             string[] fileLoggerParameters,
             string[] consoleLoggerParameters,
             string[] binaryLoggerParameters,
@@ -3389,7 +3504,7 @@ private static ILogger[] ProcessLoggingSwitches(
             // Choose default console logger
             if (terminalloggerOptIn)
             {
-                ProcessTerminalLogger(noConsoleLogger, distributedLoggerRecords, cpuCount, loggers);
+                ProcessTerminalLogger(noConsoleLogger, aggregatedTerminalLoggerParameters, distributedLoggerRecords, cpuCount, loggers);
             }
             else
             {
@@ -3565,8 +3680,8 @@ internal static void ProcessConsoleLoggerSwitch(
             }
         }
 
-        private static void ProcessTerminalLogger(
-            bool noConsoleLogger,
+        private static void ProcessTerminalLogger(bool noConsoleLogger,
+            string aggregatedLoggerParameters,
             List<DistributedLoggerRecord> distributedLoggerRecords,
             int cpuCount,
             List<ILogger> loggers)
@@ -3574,7 +3689,10 @@ private static void ProcessTerminalLogger(
             if (!noConsoleLogger)
             {
                 // A central logger will be created for both single proc and multiproc.
-                TerminalLogger logger = new TerminalLogger();
+                TerminalLogger logger = new TerminalLogger()
+                {
+                    Parameters = aggregatedLoggerParameters
+                };
 
                 // Check to see if there is a possibility we will be logging from an out-of-proc node.
                 // If so (we're multi-proc or the in-proc node is disabled), we register a distributed logger.
diff --git a/src/Shared/Resources/xlf/Strings.shared.cs.xlf b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
index a7a838dcec0..cdffb07fb6f 100644
--- a/src/Shared/Resources/xlf/Strings.shared.cs.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.cs.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">Použití nezabezpečeného BinaryFormatteru během serializace vlastního typu události {0}. Tento způsob bude brzy zastaralý. Místo toho prosím použijte Extended*EventArgs. Další informace najdete zde: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.de.xlf b/src/Shared/Resources/xlf/Strings.shared.de.xlf
index eb2c72f18bb..9faa13d7602 100644
--- a/src/Shared/Resources/xlf/Strings.shared.de.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.de.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">Verwendung eines unsicheren BinaryFormatter während der Serialisierung des benutzerdefinierten Ereignistyps '{0}'. Dies wird in Kürze eingestellt. Verwenden Sie stattdessen Extended*EventArgs. Weitere Informationen: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.es.xlf b/src/Shared/Resources/xlf/Strings.shared.es.xlf
index 4f6b6a3717b..dc91f2bd810 100644
--- a/src/Shared/Resources/xlf/Strings.shared.es.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.es.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">Uso de BinaryFormatter no seguro durante la serialización del tipo de evento personalizado "{0}". Esto estará en desuso pronto. En su lugar, use Extended*EventArgs. Más información: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.fr.xlf b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
index 9fad518160a..c812aa833db 100644
--- a/src/Shared/Resources/xlf/Strings.shared.fr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.fr.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">Utilisation de BinaryFormatter non sécurisé lors de la sérialisation d’un type d’événement personnalisé '{0}'. Cette opération sera bientôt déconseillée. Utilisez Extended*EventArgs à la place. Plus d’informations : https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.it.xlf b/src/Shared/Resources/xlf/Strings.shared.it.xlf
index ff315cf6bff..2ed5a530e64 100644
--- a/src/Shared/Resources/xlf/Strings.shared.it.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.it.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">Utilizzo di BinaryFormatter non sicuro durante la serializzazione del tipo di evento personalizzato '{0}'. Questa operazione verrà presto deprecata. Usare invece Extended*EventArgs. Altre informazioni: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ja.xlf b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
index b14d491c9d4..0d17c4c2a44 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ja.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ja.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">カスタム イベントの種類 '{0}' のシリアル化中のセキュリティで保護されていない BinaryFormatter の使用。これは間もなく非推奨になります。代わりに Extended*EventArgs を使用してください。詳細情報: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ko.xlf b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
index 26638d94686..e8bbabfd3e9 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ko.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ko.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">사용자 지정 이벤트 유형 '{0}'의 직렬화 중 보안되지 않은 BinaryFormatter 사용. 이 항목은 곧 지원 중단될 예정입니다. 대신 Extended*EventArgs를 사용하세요. 추가 정보: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pl.xlf b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
index e5c9b0c4175..272e8877783 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pl.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pl.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">Użycie niezabezpieczonego formatu BinaryFormatter podczas serializacji niestandardowego typu zdarzenia „{0}”. Wkrótce ta funkcja będzie przestarzała. Zamiast tego należy użyć Extended*EventArgs. Więcej informacji: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
index 7fb547ef6c1..3b4308d3b6d 100644
--- a/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.pt-BR.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">Uso de BinaryFormatter não seguro durante a serialização do tipo de evento personalizado '{0}'. Isso será obsoleto em breve. Em vez disso, use Extended*EventArgs. Mais informações: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.ru.xlf b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
index 0a44097c8b5..eebaa4e6caa 100644
--- a/src/Shared/Resources/xlf/Strings.shared.ru.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.ru.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">Использование небезопасного BinaryFormatter во время сериализации настраиваемого типа события "{0}". Скоро этот параметр станет нерекомендуемым. Вместо этого используйте Extended*EventArgs. Дополнительные сведения: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.tr.xlf b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
index 48528aa1dbc..775a8cc8718 100644
--- a/src/Shared/Resources/xlf/Strings.shared.tr.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.tr.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">'{0}' özel olay türünü serileştirme işlemi sırasında güvenli olmayan BinaryFormatter kullanımı. Bu özellik yakında kullanımdan kaldırılacak. Lütfen bunun yerine Extended*EventArgs özelliğini kullanın. Daha fazla bilgi: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
index efcc3ebebdb..7e9f0b6897d 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hans.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">在自定义事件类型“{0}”的序列化期间使用了不安全的 BinaryFormatter。这将很快被弃用。请改用 Extended*EventArgs。详细信息: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
index 6cea109f0f8..94fd6cd9fcc 100644
--- a/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
+++ b/src/Shared/Resources/xlf/Strings.shared.zh-Hant.xlf
@@ -24,7 +24,7 @@
       </trans-unit>
       <trans-unit id="DeprecatedEventSerialization">
         <source>Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</source>
-        <target state="new">Usage of unsecure BinaryFormatter during serialization of custom event type '{0}'. This will be deprecated soon. Please use Extended*EventArgs instead. More info: https://aka.ms/msbuild/eventargs</target>
+        <target state="translated">自訂事件類型 '{0}' 序列化期間使用不安全的 BinaryFormatter。即將取代此項目。請改用 Extended*EventArgs。更多資訊: https://aka.ms/msbuild/eventargs</target>
         <note />
       </trans-unit>
       <trans-unit id="ExpectedEventToBeSerializable">
diff --git a/src/Shared/TaskParameter.cs b/src/Shared/TaskParameter.cs
index 564ce2c4ed6..4595adaba62 100644
--- a/src/Shared/TaskParameter.cs
+++ b/src/Shared/TaskParameter.cs
@@ -24,47 +24,37 @@ namespace Microsoft.Build.BackEnd
     internal enum TaskParameterType
     {
         /// <summary>
-        /// Parameter is null
+        /// Parameter is null.
         /// </summary>
         Null,
 
         /// <summary>
-        /// Parameter is a string
+        /// Parameter is of a type described by a <see cref="TypeCode"/>.
         /// </summary>
-        String,
+        PrimitiveType,
 
         /// <summary>
-        /// Parameter is an array of strings
+        /// Parameter is an array of a type described by a <see cref="TypeCode"/>.
         /// </summary>
-        StringArray,
+        PrimitiveTypeArray,
 
         /// <summary>
-        /// Parameter is <c>true</c> or <c>false</c>.
-        /// </summary>
-        Bool,
-
-        /// <summary>
-        /// Parameter is an <see langword="int"/>.
-        /// </summary>
-        Int,
-
-        /// <summary>
-        /// Parameter is a value type.  Note:  Must be serializable
+        /// Parameter is a value type.  Note:  Must be <see cref="IConvertible"/>.
         /// </summary>
         ValueType,
 
         /// <summary>
-        /// Parameter is an array of value types.  Note:  Must be serializable.
+        /// Parameter is an array of value types.  Note:  Must be <see cref="IConvertible"/>.
         /// </summary>
         ValueTypeArray,
 
         /// <summary>
-        /// Parameter is an ITaskItem
+        /// Parameter is an ITaskItem.
         /// </summary>
         ITaskItem,
 
         /// <summary>
-        /// Parameter is an array of ITaskItems
+        /// Parameter is an array of ITaskItems.
         /// </summary>
         ITaskItemArray,
 
@@ -72,7 +62,7 @@ internal enum TaskParameterType
         /// An invalid parameter -- the value of this parameter contains the exception
         /// that is thrown when trying to access it.
         /// </summary>
-        Invalid
+        Invalid,
     }
 
     /// <summary>
@@ -86,10 +76,15 @@ internal class TaskParameter :
         ITranslatable
     {
         /// <summary>
-        /// The TaskParameterType of the wrapped parameter
+        /// The TaskParameterType of the wrapped parameter.
         /// </summary>
         private TaskParameterType _parameterType;
 
+        /// <summary>
+        /// The <see cref="TypeCode"/> of the wrapped parameter if it's a primitive type.
+        /// </summary>
+        private TypeCode _parameterTypeCode;
+
         /// <summary>
         /// The actual task parameter that we're wrapping
         /// </summary>
@@ -124,9 +119,11 @@ public TaskParameter(object wrappedParameter)
 
             if (wrappedParameterType.IsArray)
             {
-                if (wrappedParameterType == typeof(string[]))
+                TypeCode typeCode = Type.GetTypeCode(wrappedParameterType.GetElementType());
+                if (typeCode != TypeCode.Object && typeCode != TypeCode.DBNull)
                 {
-                    _parameterType = TaskParameterType.StringArray;
+                    _parameterType = TaskParameterType.PrimitiveTypeArray;
+                    _parameterTypeCode = typeCode;
                     _wrappedParameter = wrappedParameter;
                 }
                 else if (typeof(ITaskItem[]).GetTypeInfo().IsAssignableFrom(wrappedParameterType.GetTypeInfo()))
@@ -158,37 +155,27 @@ public TaskParameter(object wrappedParameter)
             else
             {
                 // scalar parameter
-                if (wrappedParameterType == typeof(string))
-                {
-                    _parameterType = TaskParameterType.String;
-                    _wrappedParameter = wrappedParameter;
-                }
-                else if (typeof(ITaskItem).IsAssignableFrom(wrappedParameterType))
-                {
-                    _parameterType = TaskParameterType.ITaskItem;
-                    _wrappedParameter = CreateNewTaskItemFrom((ITaskItem)wrappedParameter);
-                }
                 // Preserve enums as strings: the enum type itself may not
                 // be loaded on the other side of the serialization, but
                 // we would convert to string anyway after pulling the
                 // task output into a property or item.
-                else if (wrappedParameterType.IsEnum)
+                if (wrappedParameterType.IsEnum)
                 {
-                    _parameterType = TaskParameterType.String;
-                    _wrappedParameter = (string)Convert.ChangeType(wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+                    wrappedParameter = (string)Convert.ChangeType(wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+                    wrappedParameterType = typeof(string);
                 }
-                // Also stringify known common value types, to avoid calling
-                // TranslateDotNet when they'll just be stringified on the
-                // output side
-                else if (wrappedParameterType == typeof(bool))
+
+                TypeCode typeCode = Type.GetTypeCode(wrappedParameterType);
+                if (typeCode != TypeCode.Object && typeCode != TypeCode.DBNull)
                 {
-                    _parameterType = TaskParameterType.Bool;
+                    _parameterType = TaskParameterType.PrimitiveType;
+                    _parameterTypeCode = typeCode;
                     _wrappedParameter = wrappedParameter;
                 }
-                else if (wrappedParameterType == typeof(int))
+                else if (typeof(ITaskItem).IsAssignableFrom(wrappedParameterType))
                 {
-                    _parameterType = TaskParameterType.Int;
-                    _wrappedParameter = wrappedParameter;
+                    _parameterType = TaskParameterType.ITaskItem;
+                    _wrappedParameter = CreateNewTaskItemFrom((ITaskItem)wrappedParameter);
                 }
                 else if (wrappedParameterType.GetTypeInfo().IsValueType)
                 {
@@ -203,31 +190,26 @@ public TaskParameter(object wrappedParameter)
         }
 
         /// <summary>
-        /// Constructor for deserialization
+        /// Constructor for deserialization.
         /// </summary>
         private TaskParameter()
         {
         }
 
         /// <summary>
-        /// The TaskParameterType of the wrapped parameter
+        /// The TaskParameterType of the wrapped parameter.
         /// </summary>
-        public TaskParameterType ParameterType
-        {
-            [DebuggerStepThrough]
-            get
-            { return _parameterType; }
-        }
+        public TaskParameterType ParameterType => _parameterType;
 
         /// <summary>
-        /// The actual task parameter that we're wrapping
+        /// The <see cref="TypeCode"/> of the wrapper parameter if it's a primitive or array of primitives.
         /// </summary>
-        public object WrappedParameter
-        {
-            [DebuggerStepThrough]
-            get
-            { return _wrappedParameter; }
-        }
+        public TypeCode ParameterTypeCode => _parameterTypeCode;
+
+        /// <summary>
+        /// The actual task parameter that we're wrapping.
+        /// </summary>
+        public object WrappedParameter => _wrappedParameter;
 
         /// <summary>
         /// TaskParameter's ToString should just pass through to whatever it's wrapping.
@@ -242,44 +224,38 @@ public override string ToString()
         /// </summary>
         public void Translate(ITranslator translator)
         {
-            translator.TranslateEnum<TaskParameterType>(ref _parameterType, (int)_parameterType);
+            translator.TranslateEnum(ref _parameterType, (int)_parameterType);
 
             switch (_parameterType)
             {
                 case TaskParameterType.Null:
                     _wrappedParameter = null;
                     break;
-                case TaskParameterType.String:
-                    string stringParam = (string)_wrappedParameter;
-                    translator.Translate(ref stringParam);
-                    _wrappedParameter = stringParam;
+                case TaskParameterType.PrimitiveType:
+                    TranslatePrimitiveType(translator);
                     break;
-                case TaskParameterType.StringArray:
-                    string[] stringArrayParam = (string[])_wrappedParameter;
-                    translator.Translate(ref stringArrayParam);
-                    _wrappedParameter = stringArrayParam;
+                case TaskParameterType.PrimitiveTypeArray:
+                    TranslatePrimitiveTypeArray(translator);
                     break;
-                case TaskParameterType.Bool:
-                    bool boolParam = _wrappedParameter switch
+                case TaskParameterType.ValueType:
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
                     {
-                        bool hadValue => hadValue,
-                        _ => default,
-                    };
-                    translator.Translate(ref boolParam);
-                    _wrappedParameter = boolParam;
-                    break;
-                case TaskParameterType.Int:
-                    int intParam = _wrappedParameter switch
+                        TranslateValueType(translator);
+                    }
+                    else
                     {
-                        int hadValue => hadValue,
-                        _ => default,
-                    };
-                    translator.Translate(ref intParam);
-                    _wrappedParameter = intParam;
+                        translator.TranslateDotNet(ref _wrappedParameter);
+                    }
                     break;
-                case TaskParameterType.ValueType:
                 case TaskParameterType.ValueTypeArray:
-                    translator.TranslateDotNet(ref _wrappedParameter);
+                    if (ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_8))
+                    {
+                        TranslateValueTypeArray(translator);
+                    }
+                    else
+                    {
+                        translator.TranslateDotNet(ref _wrappedParameter);
+                    }
                     break;
                 case TaskParameterType.ITaskItem:
                     TranslateITaskItem(translator);
@@ -537,6 +513,223 @@ private bool TranslateNullable<T>(ITranslator translator, T value)
             return haveRef;
         }
 
+        /// <summary>
+        /// Serializes or deserializes a primitive type value wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        private void TranslatePrimitiveType(ITranslator translator)
+        {
+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);
+
+            switch (_parameterTypeCode)
+            {
+                case TypeCode.Boolean:
+                    bool boolParam = _wrappedParameter is bool wrappedBool ? wrappedBool : default;
+                    translator.Translate(ref boolParam);
+                    _wrappedParameter = boolParam;
+                    break;
+
+                case TypeCode.Byte:
+                    byte byteParam = _wrappedParameter is byte wrappedByte ? wrappedByte : default;
+                    translator.Translate(ref byteParam);
+                    _wrappedParameter = byteParam;
+                    break;
+
+                case TypeCode.Int16:
+                    short shortParam = _wrappedParameter is short wrappedShort ? wrappedShort : default;
+                    translator.Translate(ref shortParam);
+                    _wrappedParameter = shortParam;
+                    break;
+
+                case TypeCode.UInt16:
+                    ushort ushortParam = _wrappedParameter is ushort wrappedUShort ? wrappedUShort : default;
+                    translator.Translate(ref ushortParam);
+                    _wrappedParameter = ushortParam;
+                    break;
+
+                case TypeCode.Int64:
+                    long longParam = _wrappedParameter is long wrappedLong ? wrappedLong : default;
+                    translator.Translate(ref longParam);
+                    _wrappedParameter = longParam;
+                    break;
+
+                case TypeCode.Double:
+                    double doubleParam = _wrappedParameter is double wrappedDouble ? wrappedDouble : default;
+                    translator.Translate(ref doubleParam);
+                    _wrappedParameter = doubleParam;
+                    break;
+
+                case TypeCode.String:
+                    string stringParam = (string)_wrappedParameter;
+                    translator.Translate(ref stringParam);
+                    _wrappedParameter = stringParam;
+                    break;
+
+                case TypeCode.DateTime:
+                    DateTime dateTimeParam = _wrappedParameter is DateTime wrappedDateTime ? wrappedDateTime : default;
+                    translator.Translate(ref dateTimeParam);
+                    _wrappedParameter = dateTimeParam;
+                    break;
+
+                default:
+                    // Fall back to converting to/from string for types that don't have ITranslator support.
+                    string stringValue = null;
+                    if (translator.Mode == TranslationDirection.WriteToStream)
+                    {
+                        stringValue = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+                    }
+
+                    translator.Translate(ref stringValue);
+
+                    if (translator.Mode == TranslationDirection.ReadFromStream)
+                    {
+                        _wrappedParameter = Convert.ChangeType(stringValue, _parameterTypeCode, CultureInfo.InvariantCulture);
+                    }
+                    break;
+            }
+        }
+
+        /// <summary>
+        /// Serializes or deserializes an array of primitive type values wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        private void TranslatePrimitiveTypeArray(ITranslator translator)
+        {
+            translator.TranslateEnum(ref _parameterTypeCode, (int)_parameterTypeCode);
+
+            switch (_parameterTypeCode)
+            {
+                case TypeCode.Boolean:
+                    bool[] boolArrayParam = (bool[])_wrappedParameter;
+                    translator.Translate(ref boolArrayParam);
+                    _wrappedParameter = boolArrayParam;
+                    break;
+
+                case TypeCode.Int32:
+                    int[] intArrayParam = (int[])_wrappedParameter;
+                    translator.Translate(ref intArrayParam);
+                    _wrappedParameter = intArrayParam;
+                    break;
+
+                case TypeCode.String:
+                    string[] stringArrayParam = (string[])_wrappedParameter;
+                    translator.Translate(ref stringArrayParam);
+                    _wrappedParameter = stringArrayParam;
+                    break;
+
+                default:
+                    // Fall back to converting to/from string for types that don't have ITranslator support.
+                    if (translator.Mode == TranslationDirection.WriteToStream)
+                    {
+                        Array array = (Array)_wrappedParameter;
+                        int length = array.Length;
+
+                        translator.Translate(ref length);
+
+                        for (int i = 0; i < length; i++)
+                        {
+                            string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);
+                            translator.Translate(ref valueString);
+                        }
+                    }
+                    else
+                    {
+                        Type elementType = _parameterTypeCode switch
+                        {
+                            TypeCode.Char => typeof(char),
+                            TypeCode.SByte => typeof(sbyte),
+                            TypeCode.Byte => typeof(byte),
+                            TypeCode.Int16 => typeof(short),
+                            TypeCode.UInt16 => typeof(ushort),
+                            TypeCode.UInt32 => typeof(uint),
+                            TypeCode.Int64 => typeof(long),
+                            TypeCode.UInt64 => typeof(ulong),
+                            TypeCode.Single => typeof(float),
+                            TypeCode.Double => typeof(double),
+                            TypeCode.Decimal => typeof(decimal),
+                            TypeCode.DateTime => typeof(DateTime),
+                            _ => throw new NotImplementedException(),
+                        };
+
+                        int length = 0;
+                        translator.Translate(ref length);
+
+                        Array array = Array.CreateInstance(elementType, length);
+                        for (int i = 0; i < length; i++)
+                        {
+                            string valueString = null;
+                            translator.Translate(ref valueString);
+                            array.SetValue(Convert.ChangeType(valueString, _parameterTypeCode, CultureInfo.InvariantCulture), i);
+                        }
+                        _wrappedParameter = array;
+                    }
+                    break;
+            }
+        }
+
+        /// <summary>
+        /// Serializes or deserializes the value type instance wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        /// <remarks>
+        /// The value type is converted to/from string using the <see cref="Convert"/> class. Note that we require
+        /// task parameter types to be <see cref="IConvertible"/> so this conversion is guaranteed to work for parameters
+        /// that have made it this far.
+        /// </remarks>
+        private void TranslateValueType(ITranslator translator)
+        {
+            string valueString = null;
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                valueString = (string)Convert.ChangeType(_wrappedParameter, typeof(string), CultureInfo.InvariantCulture);
+            }
+
+            translator.Translate(ref valueString);
+
+            if (translator.Mode == TranslationDirection.ReadFromStream)
+            {
+                // We don't know how to convert the string back to the original value type. This is fine because output
+                // task parameters are anyway converted to strings by the engine (see TaskExecutionHost.GetValueOutputs)
+                // and input task parameters of custom value types are not supported.
+                _wrappedParameter = valueString;
+            }
+        }
+
+        /// <summary>
+        /// Serializes or deserializes the value type array instance wrapped by this <see cref="TaskParameter"/>.
+        /// </summary>
+        /// <remarks>
+        /// The array is assumed to be non-null.
+        /// </remarks>
+        private void TranslateValueTypeArray(ITranslator translator)
+        {
+            if (translator.Mode == TranslationDirection.WriteToStream)
+            {
+                Array array = (Array)_wrappedParameter;
+                int length = array.Length;
+
+                translator.Translate(ref length);
+
+                for (int i = 0; i < length; i++)
+                {
+                    string valueString = Convert.ToString(array.GetValue(i), CultureInfo.InvariantCulture);
+                    translator.Translate(ref valueString);
+                }
+            }
+            else
+            {
+                int length = 0;
+                translator.Translate(ref length);
+
+                string[] stringArray = new string[length];
+                for (int i = 0; i < length; i++)
+                {
+                    translator.Translate(ref stringArray[i]);
+                }
+
+                // We don't know how to convert the string array back to the original value type array.
+                // This is fine because the engine would eventually convert it to strings anyway.
+                _wrappedParameter = stringArray;
+            }
+        }
+
         /// <summary>
         /// Super simple ITaskItem derivative that we can use as a container for read items.
         /// </summary>
diff --git a/src/Shared/UnitTests/MockLogger.cs b/src/Shared/UnitTests/MockLogger.cs
index c52765ccd49..df21aa2f2e6 100644
--- a/src/Shared/UnitTests/MockLogger.cs
+++ b/src/Shared/UnitTests/MockLogger.cs
@@ -26,7 +26,7 @@ namespace Microsoft.Build.UnitTests
      * up a raw string (fullLog) that contains all messages, warnings, errors.
      * Thread-safe.
      */
-    internal sealed class MockLogger : ILogger
+    public sealed class MockLogger : ILogger
     {
         #region Properties
 
@@ -138,6 +138,11 @@ internal sealed class MockLogger : ILogger
         /// </summary>
         internal List<BuildFinishedEventArgs> BuildFinishedEvents { get; } = new List<BuildFinishedEventArgs>();
 
+        /// <summary>
+        /// List of Telemetry events
+        /// </summary>
+        internal List<TelemetryEventArgs> TelemetryEvents { get; } = new();
+
         internal List<BuildEventArgs> AllBuildEvents { get; } = new List<BuildEventArgs>();
 
         /*
@@ -175,11 +180,7 @@ internal string FullLog
          * The mock logger does not take parameters.
          * 
          */
-        public string Parameters
-        {
-            get => null;
-            set {/* do nothing */}
-        }
+        public string Parameters { get; set; }
 
         /*
          * Method:  Initialize
@@ -190,6 +191,10 @@ public string Parameters
         public void Initialize(IEventSource eventSource)
         {
             eventSource.AnyEventRaised += LoggerEventHandler;
+            if (eventSource is IEventSource2 eventSource2)
+            {
+                eventSource2.TelemetryLogged += TelemetryEventHandler;
+            }
 
             if (_profileEvaluation)
             {
@@ -197,6 +202,12 @@ public void Initialize(IEventSource eventSource)
                 eventSource3.ShouldNotBeNull();
                 eventSource3.IncludeEvaluationProfiles();
             }
+
+            // Apply parameters
+            if (Parameters?.IndexOf("reporttelemetry", StringComparison.OrdinalIgnoreCase) >= 0)
+            {
+                _reportTelemetry = true;
+            }
         }
 
         /// <summary>
@@ -222,6 +233,10 @@ public void Shutdown()
         }
         #endregion
 
+        public MockLogger() : this(null)
+        {
+        }
+
         public MockLogger(ITestOutputHelper testOutputHelper = null, bool profileEvaluation = false, bool printEventsToStdout = true, LoggerVerbosity verbosity = LoggerVerbosity.Normal)
         {
             _testOutputHelper = testOutputHelper;
@@ -383,6 +398,27 @@ internal void LoggerEventHandler(object sender, BuildEventArgs eventArgs)
             }
         }
 
+        internal void TelemetryEventHandler(object sender, BuildEventArgs eventArgs)
+        {
+            lock (_lockObj)
+            {
+                if (eventArgs is TelemetryEventArgs telemetryEventArgs)
+                {
+                    TelemetryEvents.Add(telemetryEventArgs);
+
+                    if (_reportTelemetry)
+                    {
+                        // Log telemetry events to the full log so we can verify them in end-to-end tests by captured outputs.
+                        _fullLog.AppendLine($"Telemetry:{telemetryEventArgs.EventName}");
+                        foreach (KeyValuePair<string, string> pair in telemetryEventArgs.Properties)
+                        {
+                            _fullLog.AppendLine($"    {telemetryEventArgs.EventName}:{pair.Key}={pair.Value}");
+                        }
+                    }
+                }
+            }
+        }
+
         private void PrintFullLog()
         {
             if (_printEventsToStdout)
@@ -397,6 +433,7 @@ private void PrintFullLog()
             typeof(ProjectCollection).GetTypeInfo().Assembly));
 
         private static ResourceManager s_engineResourceManager;
+        private bool _reportTelemetry;
 
         // Gets the resource string given the resource ID
         public static string GetString(string stringId) => EngineResourceManager.GetString(stringId, CultureInfo.CurrentUICulture);
diff --git a/src/Shared/UnitTests/TaskParameter_Tests.cs b/src/Shared/UnitTests/TaskParameter_Tests.cs
index a33b226229a..6b23cbac9aa 100644
--- a/src/Shared/UnitTests/TaskParameter_Tests.cs
+++ b/src/Shared/UnitTests/TaskParameter_Tests.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Globalization;
 
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
@@ -39,96 +40,124 @@ public void NullParameter()
             Assert.Equal(TaskParameterType.Null, t2.ParameterType);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a string parameter is OK.
-        /// </summary>
-        [Fact]
-        public void StringParameter()
+        [Theory]
+        [InlineData(typeof(bool), (int)TypeCode.Boolean, "True")]
+        [InlineData(typeof(byte), (int)TypeCode.Byte, "127")]
+        [InlineData(typeof(sbyte), (int)TypeCode.SByte, "-127")]
+        [InlineData(typeof(double), (int)TypeCode.Double, "3.14")]
+        [InlineData(typeof(float), (int)TypeCode.Single, "3.14")]
+        [InlineData(typeof(short), (int)TypeCode.Int16, "-20000")]
+        [InlineData(typeof(ushort), (int)TypeCode.UInt16, "30000")]
+        [InlineData(typeof(int), (int)TypeCode.Int32, "-1")]
+        [InlineData(typeof(uint), (int)TypeCode.UInt32, "1")]
+        [InlineData(typeof(long), (int)TypeCode.Int64, "-1000000000000")]
+        [InlineData(typeof(ulong), (int)TypeCode.UInt64, "1000000000000")]
+        [InlineData(typeof(decimal), (int)TypeCode.Decimal, "29.99")]
+        [InlineData(typeof(char), (int)TypeCode.Char, "q")]
+        [InlineData(typeof(string), (int)TypeCode.String, "foo")]
+        [InlineData(typeof(DateTime), (int)TypeCode.DateTime, "1/1/2000 12:12:12")]
+        public void PrimitiveParameter(Type type, int expectedTypeCodeAsInt, string testValueAsString)
         {
-            TaskParameter t = new TaskParameter("foo");
+            TypeCode expectedTypeCode = (TypeCode)expectedTypeCodeAsInt;
+
+            object value = Convert.ChangeType(testValueAsString, type, CultureInfo.InvariantCulture);
+            TaskParameter t = new TaskParameter(value);
 
-            Assert.Equal("foo", t.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t.ParameterType);
+            Assert.Equal(value, t.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveType, t.ParameterType);
+            Assert.Equal(expectedTypeCode, t.ParameterTypeCode);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal("foo", t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t2.ParameterType);
+            Assert.Equal(value, t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveType, t2.ParameterType);
+            Assert.Equal(expectedTypeCode, t2.ParameterTypeCode);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a string array parameter is OK.
-        /// </summary>
-        [Fact]
-        public void StringArrayParameter()
+        [Theory]
+        [InlineData(typeof(bool), (int)TypeCode.Boolean, "True;False;True")]
+        [InlineData(typeof(byte), (int)TypeCode.Byte, "127;100;0")]
+        [InlineData(typeof(sbyte), (int)TypeCode.SByte, "-127;-126;12")]
+        [InlineData(typeof(double), (int)TypeCode.Double, "3.14;3.15")]
+        [InlineData(typeof(float), (int)TypeCode.Single, "3.14;3.15")]
+        [InlineData(typeof(short), (int)TypeCode.Int16, "-20000;0;-1")]
+        [InlineData(typeof(ushort), (int)TypeCode.UInt16, "30000;20000;10")]
+        [InlineData(typeof(int), (int)TypeCode.Int32, "-1;-2")]
+        [InlineData(typeof(uint), (int)TypeCode.UInt32, "1;5;6")]
+        [InlineData(typeof(long), (int)TypeCode.Int64, "-1000000000000;0")]
+        [InlineData(typeof(ulong), (int)TypeCode.UInt64, "1000000000000;0")]
+        [InlineData(typeof(decimal), (int)TypeCode.Decimal, "29.99;0.88")]
+        [InlineData(typeof(char), (int)TypeCode.Char, "q;r;c")]
+        [InlineData(typeof(string), (int)TypeCode.String, "foo;bar")]
+        [InlineData(typeof(DateTime), (int)TypeCode.DateTime, "1/1/2000 12:12:12;2/2/2000 13:13:13")]
+        public void PrimitiveArrayParameter(Type type, int expectedTypeCodeAsInt, string testValueAsString)
         {
-            TaskParameter t = new TaskParameter(new string[] { "foo", "bar" });
+            TypeCode expectedTypeCode = (TypeCode)expectedTypeCodeAsInt;
 
-            Assert.Equal(TaskParameterType.StringArray, t.ParameterType);
+            string[] values = testValueAsString.Split(';');
+            Array array = Array.CreateInstance(type, values.Length);
+            for (int i = 0; i < values.Length; i++)
+            {
+                object value = Convert.ChangeType(values[i], type, CultureInfo.InvariantCulture);
+                array.SetValue(value, i);
+            }
 
-            string[] wrappedParameter = t.WrappedParameter as string[];
-            Assert.NotNull(wrappedParameter);
-            Assert.Equal(2, wrappedParameter.Length);
-            Assert.Equal("foo", wrappedParameter[0]);
-            Assert.Equal("bar", wrappedParameter[1]);
+            TaskParameter t = new TaskParameter(array);
+
+            Assert.Equal(array, t.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveTypeArray, t.ParameterType);
+            Assert.Equal(expectedTypeCode, t.ParameterTypeCode);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal(TaskParameterType.StringArray, t2.ParameterType);
-
-            string[] wrappedParameter2 = t2.WrappedParameter as string[];
-            Assert.NotNull(wrappedParameter2);
-            Assert.Equal(2, wrappedParameter2.Length);
-            Assert.Equal("foo", wrappedParameter2[0]);
-            Assert.Equal("bar", wrappedParameter2[1]);
+            Assert.Equal(array, t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.PrimitiveTypeArray, t2.ParameterType);
+            Assert.Equal(expectedTypeCode, t2.ParameterTypeCode);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a value type (integer) parameter is OK.
-        /// </summary>
         [Fact]
-        public void IntParameter()
+        public void ValueTypeParameter()
         {
-            TaskParameter t = new TaskParameter(1);
+            TaskBuilderTestTask.CustomStruct value = new TaskBuilderTestTask.CustomStruct(3.14);
+            TaskParameter t = new TaskParameter(value);
 
-            Assert.Equal(1, t.WrappedParameter);
-            Assert.Equal(TaskParameterType.Int, t.ParameterType);
+            Assert.Equal(value, t.WrappedParameter);
+            Assert.Equal(TaskParameterType.ValueType, t.ParameterType);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
-            Assert.Equal(1, t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.Int, t2.ParameterType);
+            // Custom IConvertible structs are deserialized into strings.
+            Assert.Equal(value.ToString(CultureInfo.InvariantCulture), t2.WrappedParameter);
+            Assert.Equal(TaskParameterType.ValueType, t2.ParameterType);
         }
 
-        /// <summary>
-        /// Verifies that construction and serialization with a parameter that is an array of value types (ints) is OK.
-        /// </summary>
         [Fact]
-        public void IntArrayParameter()
+        public void ValueTypeArrayParameter()
         {
-            TaskParameter t = new TaskParameter(new int[] { 2, 15 });
-
+            TaskBuilderTestTask.CustomStruct[] value = new TaskBuilderTestTask.CustomStruct[]
+            {
+                new TaskBuilderTestTask.CustomStruct(3.14),
+                new TaskBuilderTestTask.CustomStruct(2.72),
+            };
+            TaskParameter t = new TaskParameter(value);
+
+            Assert.Equal(value, t.WrappedParameter);
             Assert.Equal(TaskParameterType.ValueTypeArray, t.ParameterType);
 
-            int[] wrappedParameter = t.WrappedParameter as int[];
-            Assert.NotNull(wrappedParameter);
-            Assert.Equal(2, wrappedParameter.Length);
-            Assert.Equal(2, wrappedParameter[0]);
-            Assert.Equal(15, wrappedParameter[1]);
-
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
+            // Custom IConvertible structs are deserialized into strings.
+            Assert.True(t2.WrappedParameter is string[]);
             Assert.Equal(TaskParameterType.ValueTypeArray, t2.ParameterType);
 
-            int[] wrappedParameter2 = t2.WrappedParameter as int[];
-            Assert.NotNull(wrappedParameter2);
-            Assert.Equal(2, wrappedParameter2.Length);
-            Assert.Equal(2, wrappedParameter2[0]);
-            Assert.Equal(15, wrappedParameter2[1]);
+            string[] stringArray = (string[])t2.WrappedParameter;
+            Assert.Equal(2, stringArray.Length);
+            Assert.Equal(value[0].ToString(CultureInfo.InvariantCulture), stringArray[0]);
+            Assert.Equal(value[1].ToString(CultureInfo.InvariantCulture), stringArray[1]);
         }
 
         private enum TestEnumForParameter
@@ -143,55 +172,15 @@ public void EnumParameter()
             TaskParameter t = new TaskParameter(TestEnumForParameter.SomethingElse);
 
             Assert.Equal("SomethingElse", t.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t.ParameterType);
+            Assert.Equal(TaskParameterType.PrimitiveType, t.ParameterType);
+            Assert.Equal(TypeCode.String, t.ParameterTypeCode);
 
             ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
             TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
 
             Assert.Equal("SomethingElse", t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.String, t2.ParameterType);
-        }
-
-        [Fact]
-        public void BoolParameter()
-        {
-            TaskParameter t = new TaskParameter(true);
-
-            Assert.Equal(true, t.WrappedParameter);
-            Assert.Equal(TaskParameterType.Bool, t.ParameterType);
-
-            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
-            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
-
-            Assert.Equal(true, t2.WrappedParameter);
-            Assert.Equal(TaskParameterType.Bool, t2.ParameterType);
-        }
-
-        /// <summary>
-        /// Verifies that construction and serialization with a parameter that is an array of value types (ints) is OK.
-        /// </summary>
-        [Fact]
-        public void BoolArrayParameter()
-        {
-            TaskParameter t = new TaskParameter(new bool[] { false, true });
-
-            Assert.Equal(TaskParameterType.ValueTypeArray, t.ParameterType);
-
-            bool[] wrappedParameter = t.WrappedParameter as bool[];
-            Assert.NotNull(wrappedParameter);
-            Assert.Equal(2, wrappedParameter.Length);
-            Assert.False(wrappedParameter[0]);
-            Assert.True(wrappedParameter[1]);
-
-            ((ITranslatable)t).Translate(TranslationHelpers.GetWriteTranslator());
-            TaskParameter t2 = TaskParameter.FactoryForDeserialization(TranslationHelpers.GetReadTranslator());
-
-            Assert.Equal(TaskParameterType.ValueTypeArray, t2.ParameterType);
-
-            bool[] wrappedParameter2 = Assert.IsType<bool[]>(t2.WrappedParameter);
-            Assert.Equal(2, wrappedParameter2.Length);
-            Assert.False(wrappedParameter2[0]);
-            Assert.True(wrappedParameter2[1]);
+            Assert.Equal(TaskParameterType.PrimitiveType, t2.ParameterType);
+            Assert.Equal(TypeCode.String, t2.ParameterTypeCode);
         }
 
         /// <summary>
diff --git a/src/StringTools/CompatibilitySuppressions.xml b/src/StringTools/CompatibilitySuppressions.xml
deleted file mode 100644
index f5eff188d66..00000000000
--- a/src/StringTools/CompatibilitySuppressions.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<!-- https://learn.microsoft.com/en-us/dotnet/fundamentals/package-validation/diagnostic-ids -->
-<Suppressions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
-  <Suppression>
-    <!-- Dropped net35 for 17.5; see https://github.com/dotnet/msbuild/pull/8198 -->
-    <DiagnosticId>PKV006</DiagnosticId>
-    <Target>.NETFramework,Version=v3.5</Target>
-  </Suppression>
-</Suppressions>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index f7b0c673aba..ad309e55ee2 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -2476,9 +2476,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
     ====================================================================================================
   -->
   <Target Name="GenerateBindingRedirects"
-    Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath);$(ResolveAssemblyReferencesStateFile);$(SuggestedBindingRedirectsCacheFile)"
+    Inputs="$(MSBuildAllProjects);@(AppConfigWithTargetPath);$(SuggestedBindingRedirectsCacheFile)"
     Outputs="$(_GenerateBindingRedirectsIntermediateAppConfig)"
-    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and '@(SuggestedBindingRedirects)' != ''"
+    Condition="'$(AutoGenerateBindingRedirects)' == 'true' and '$(GenerateBindingRedirectsOutputType)' == 'true' and '@(SuggestedBindingRedirects)' != '' and '$(DesignTimeBuild)' != 'true' and '$(BuildingProject)' == 'true'"
     DependsOnTargets="_GenerateSuggestedBindingRedirectsCache">
 
     <GenerateBindingRedirects
