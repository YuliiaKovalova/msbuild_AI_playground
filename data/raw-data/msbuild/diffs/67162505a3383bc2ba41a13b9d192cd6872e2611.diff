diff --git a/.github/policies/resourceManagement.yml b/.github/policies/resourceManagement.yml
index 5b8c19d80a5..effb189ad06 100644
--- a/.github/policies/resourceManagement.yml
+++ b/.github/policies/resourceManagement.yml
@@ -152,5 +152,21 @@ configuration:
       - addReply:
           reply: Hello! I noticed that you're targeting one of our servicing branches. Please consider updating the version.
       description: Comment on vs* branches
+    - if:
+      - payloadType: Pull_Request
+      - or:
+        - isAction:
+            action: Opened
+        - isAction:
+            action: Reopened
+      - or:
+        - filesMatchPattern:
+            pattern: ^.+\.swr$
+        - filesMatchPattern:
+            pattern: src/Package/MSBuild.VSSetup.*/.*
+      then:
+      - addReply:
+          reply: Hello @${issueAuthor}, I noticed that youâ€™re changing an *.swr file or any file under src/Package/MSBuild.VSSetup.*. Please make sure to validate this change by an experimental VS insertion. This is accomplished by pushing to an exp/* branch, which requires write permissions to this repo.
+      description: Remind to run VS Perf DDRITs when deployed assemblies change
 onFailure: 
 onSuccess: 
diff --git a/.opt-prof.yml b/.opt-prof.yml
index d569cf29f20..2f752db4225 100644
--- a/.opt-prof.yml
+++ b/.opt-prof.yml
@@ -21,8 +21,6 @@ resources:
     project: DevDiv
     source: DartLab
     branch: main
-    tags:
-    - production
   - pipeline: DartLab.OptProf
     source: DartLab.OptProf
     branch: main
@@ -32,7 +30,6 @@ resources:
   - repository: DartLabTemplates
     type: git
     name: DartLab.Templates
-    ref: refs/tags/Production
   - repository: DartLabOptProfTemplates
     type: git
     name: DartLab.OptProf
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 528f761dc3e..3bf73e47ab0 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -22,7 +22,7 @@ variables:
   - name: OptProfDrop
     value: ''
   - name: SourceBranch
-    value: $(IbcBranchName)
+    value: $(IbcSourceBranchName)
   # If we're not on a vs* branch, use main as our optprof collection branch
   - ${{ if not(startsWith(variables['Build.SourceBranch'], 'refs/heads/vs')) }}:
     - name: SourceBranch
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 86ff4fe515e..f2ad4211e16 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -33,6 +33,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Load NuGet.Frameworks into secondary AppDomain (MSBuild.exe only)](https://github.com/dotnet/msbuild/pull/9446)
 - [Update Traits when environment has been changed](https://github.com/dotnet/msbuild/pull/9655)
 - [Exec task does not trim leading whitespaces for ConsoleOutput](https://github.com/dotnet/msbuild/pull/9722)
+- [Introduce [MSBuild]::StableStringHash overloads](https://github.com/dotnet/msbuild/issues/9519)
 - [Keep the encoding of standard output & error consistent with the console code page for ToolTask](https://github.com/dotnet/msbuild/pull/9539)
 
 
diff --git a/documentation/wiki/MSBuild-Environment-Variables.md b/documentation/wiki/MSBuild-Environment-Variables.md
index 01c8b7fb66c..39daa716718 100644
--- a/documentation/wiki/MSBuild-Environment-Variables.md
+++ b/documentation/wiki/MSBuild-Environment-Variables.md
@@ -1,12 +1,33 @@
-# MSBuild environment variables
+# MSBuild environment variables list
 
-- [MsBuildSkipEagerWildCardEvaluationRegexes](#msbuildskipeagerwildcardevaluationregexes)
+This document describes the environment variables that are respected in MSBuild, its purpose and usage. 
 
+Some of the env variables listed here are unsupported, meaning there is no guarantee that variable or a specific combination of multiple variables will be respected in upcoming release, so please use at your own risk.
 
-### MsBuildSkipEagerWildCardEvaluationRegexes
+* `MSBuildDebugEngine=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
+  * Set this to cause any MSBuild invocation launched within this environment to emit binary logs and additional debugging information to `<DIRECTORY>`. Useful when debugging build or evaluation issues when you can't directly influence the MSBuild invocation, such as in Visual Studio. More details on [capturing binary logs](./Providing-Binary-Logs.md)
+* `MSBUILDTARGETOUTPUTLOGGING=1`
+   * Set this to enable [printing all target outputs to the log](https://learn.microsoft.com/archive/blogs/msbuild/displaying-target-output-items-using-the-console-logger).
+* `MSBUILDLOGTASKINPUTS=1`
+   * Log task inputs (not needed if there are any diagnostic loggers already).
+ * `MSBUILDEMITSOLUTION=1`
+   * Save the generated .proj file for the .sln that is used to build the solution. The generated files are emitted into a binary log by default and their presence on disk can break subsequent builds.
+* `MSBUILDENABLEALLPROPERTYFUNCTIONS=1`
+   * Enable [additional property functions](https://devblogs.microsoft.com/visualstudio/msbuild-property-functions/). If you need this level of detail you are generally served better with a binary log than the text log.
+* `MSBUILDLOGVERBOSERARSEARCHRESULTS=1`
+   * In ResolveAssemblyReference task, log verbose search results.
+* `MSBUILDLOGCODETASKFACTORYOUTPUT=1`
+   * Dump generated code for task to a <GUID>.txt file in the TEMP directory
+* `MSBUILDDISABLENODEREUSE=1`
+   * Set this to not leave MSBuild processes behind (see `/nr:false`, but the environment variable is useful to also set this for Visual Studio for example).
+* `MSBUILDLOGASYNC=1`
+   * Enable asynchronous logging.
+* `MSBUILDDEBUGONSTART=1`
+   * Launches debugger on build start. Works on Windows operating systems only.  
+   * Setting the value of 2 allows for manually attaching a debugger to a process ID. This works on Windows and non-Windows operating systems.
+* `MSBUILDDEBUGSCHEDULER=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
+   * Dumps scheduler state at specified directory (`MSBUILDDEBUGSCHEDULER` is implied by `MSBuildDebugEngine`).
 
-If specified, overrides the default behavior of glob expansion. 
-
-During glob expansion, if the path with wildcards that is being processed matches one of the regular expressions provided in the [environment variable](#msbuildskipeagerwildcardevaluationregexes), the path is not processed (expanded). 
-
-The value of the envvironment variable is a list of regular expressions, separated by semilcon (;).
\ No newline at end of file
+* `MsBuildSkipEagerWildCardEvaluationRegexes`
+  *  If specified, overrides the default behavior of glob expansion. During glob expansion, if the path with wildcards that is being processed matches one of the regular expressions provided in the [environment variable](#msbuildskipeagerwildcardevaluationregexes), the path is not processed (expanded). 
+  * The value of the environment  variable is a list of regular expressions, separated by semicolon (;).
\ No newline at end of file
diff --git a/documentation/wiki/MSBuild-Tips-&-Tricks.md b/documentation/wiki/MSBuild-Tips-&-Tricks.md
index 94b9ec2f91b..17b137ae33d 100644
--- a/documentation/wiki/MSBuild-Tips-&-Tricks.md
+++ b/documentation/wiki/MSBuild-Tips-&-Tricks.md
@@ -6,37 +6,22 @@ See the [MSBuild Command-Line Reference](https://learn.microsoft.com/visualstudi
  * `MSBuild.exe -nr:false`
    * Disable node reuse (`/nodeReuse:false`). Don't leave MSBuild.exe processes hanging around (and possibly locking files) after the build completes. See more details in MSBuild command line help (/?). See also `MSBUILDDISABLENODEREUSE=1` below. Note that using this when building repeatedly will cause slower builds.
  * `MSBuild.exe -bl`
-   * Records all build events to a structured binary log file. The [MSBuildStructuredLog](https://github.com/KirillOsenkov/MSBuildStructuredLog) tool can be used to analyze this file.
+   * Records all build events to a structured [binary log file](./Providing-Binary-Logs.md). The [MSBuildStructuredLog](https://github.com/KirillOsenkov/MSBuildStructuredLog) tool can be used to analyze this file.
  * `MSBuild.exe -noconlog`
    * Used to suppress the usage of the console logger, which is otherwise always attached.
  * `MSBuild.exe -flp:v=diag`
    * Passes parameters to the file logger. If you want to attach multiple file loggers, you do so by specifying additional parameters in the switches /flp1, /flp2, /flp3, and so on.
 
+
+# Building MSBuild
+
+The documentation on building MSBuild:
+- [Full Framework MSBuild](./Building-Testing-and-Debugging-on-Full-Framework-MSBuild.md)
+- [.Net Core MSBuild](./Building-Testing-and-Debugging-on-.Net-Core-MSBuild.md)
+
 # Environment Variables
 
- * `MSBuildDebugEngine=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
-  * Set this to cause any MSBuild invocation launched within this environment to emit binary logs and additional debugging information to `<DIRECTORY>`. Useful when debugging build or evaluation issues when you can't directly influence the MSBuild invocation, such as in Visual Studio.
- * `MSBUILDTARGETOUTPUTLOGGING=1`
-   * Set this to enable [printing all target outputs to the log](https://learn.microsoft.com/archive/blogs/msbuild/displaying-target-output-items-using-the-console-logger).
- * `MSBUILDLOGTASKINPUTS=1`
-   * Log task inputs (not needed if there are any diagnostic loggers already).
- * `MSBUILDEMITSOLUTION=1`
-   * Save the generated .proj file for the .sln that is used to build the solution.
- * `MSBUILDENABLEALLPROPERTYFUNCTIONS=1`
-   * Enable [additional property functions](https://devblogs.microsoft.com/visualstudio/msbuild-property-functions/).
- * `MSBUILDLOGVERBOSERARSEARCHRESULTS=1`
-   * In ResolveAssemblyReference task, log verbose search results.
- * `MSBUILDLOGCODETASKFACTORYOUTPUT=1`
-   * Dump generated code for task to a <GUID>.txt file in the TEMP directory
- * `MSBUILDDISABLENODEREUSE=1`
-   * Set this to not leave MSBuild processes behind (see `/nr:false` above, but the environment variable is useful to also set this for Visual Studio for example).
- * `MSBUILDLOGASYNC=1`
-   * Enable asynchronous logging.
- * `MSBUILDDEBUGONSTART=1`
-   * Launch debugger on build start.
-   * Setting the value of 2 allows for manually attaching a debugger to a process ID.
- * `MSBUILDDEBUGSCHEDULER=1` & `MSBUILDDEBUGPATH=<DIRECTORY>`
-   * Dumps scheduler state at specified directory (`MSBUILDDEBUGSCHEDULER` is implied by `MSBuildDebugEngine`).
+The list of environment variables could be found [here](./MSBuild-Environment-Variables.md)
 
 # TreatAsLocalProperty
 If MSBuild.exe is passed properties on the command line, such as `/p:Platform=AnyCPU` then this value overrides whatever assignments you have to that property inside property groups. For instance, `<Platform>x86</Platform>` will be ignored. To make sure your local assignment to properties overrides whatever they pass on the command line, add the following at the top of your MSBuild project file:
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 3cbca66f8b2..9cf2b0ee820 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -67,14 +67,14 @@
     </Dependency>
   </ProductDependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24158.4">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="8.0.0-beta.24165.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>052a4b9e7a9bdb9744c86c05665f1b46e4d59b15</Sha>
+      <Sha>f311667e0587f19c3fa9553a909975662107a351</Sha>
     </Dependency>
     <!-- Intermediate is necessary for source build. -->
-    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24158.4">
+    <Dependency Name="Microsoft.SourceBuild.Intermediate.arcade" Version="8.0.0-beta.24165.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>052a4b9e7a9bdb9744c86c05665f1b46e4d59b15</Sha>
+      <Sha>f311667e0587f19c3fa9553a909975662107a351</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="Microsoft.DotNet.XliffTasks" Version="1.0.0-beta.23475.1" CoherentParentDependency="Microsoft.DotNet.Arcade.Sdk">
@@ -87,18 +87,18 @@
       <Sha>73f0850939d96131c28cf6ea6ee5aacb4da0083a</Sha>
       <SourceBuild RepoName="xliff-tasks" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="NuGet.Build.Tasks" Version="6.10.0-preview.2.78">
+    <Dependency Name="NuGet.Build.Tasks" Version="6.10.0-preview.2.81">
       <Uri>https://github.com/nuget/nuget.client</Uri>
-      <Sha>2fdd0d41e33c3354de2750fe154b56751a6682aa</Sha>
+      <Sha>1845d6bd450a7453d573035371c9fec43683d1ef</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24161.2">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.10.0-3.24168.1">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>01b7c233fdda946c1a5628d4692ed827a07e33dd</Sha>
+      <Sha>2348a50bb566b39305c474793b43edb5635db6f4</Sha>
       <SourceBuild RepoName="roslyn" ManagedOnly="true" />
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24158.4">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="8.0.0-beta.24165.4">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>052a4b9e7a9bdb9744c86c05665f1b46e4d59b15</Sha>
+      <Sha>f311667e0587f19c3fa9553a909975662107a351</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 132e1e07e4e..68276f7464f 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -48,11 +48,11 @@
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
     <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24158.4</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>8.0.0-beta.24165.4</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>7.0.0</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24161.2</MicrosoftNetCompilersToolsetVersion>
-    <NuGetBuildTasksVersion>6.10.0-preview.2.78</NuGetBuildTasksVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.10.0-3.24168.1</MicrosoftNetCompilersToolsetVersion>
+    <NuGetBuildTasksVersion>6.10.0-preview.2.81</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
   </PropertyGroup>
   <Target Name="OverrideArcadeFileVersion" AfterTargets="_InitializeAssemblyVersion">
diff --git a/eng/common/templates-official/job/job.yml b/eng/common/templates-official/job/job.yml
index 647e3f92e5f..a2709d10562 100644
--- a/eng/common/templates-official/job/job.yml
+++ b/eng/common/templates-official/job/job.yml
@@ -206,9 +206,11 @@ jobs:
         continueOnError: true
         condition: always()
     - ${{ if and(ne(parameters.artifacts.publish.logs, 'false'), ne(parameters.artifacts.publish.logs, '')) }}:
-      - publish: artifacts/log
-        artifact: ${{ coalesce(parameters.artifacts.publish.logs.name, 'Logs_Build_$(Agent.Os)_$(_BuildConfig)') }}
-        displayName: Publish logs
+      - task: 1ES.PublishPipelineArtifact@1
+        inputs:
+          targetPath: 'artifacts/log'
+          artifactName: ${{ coalesce(parameters.artifacts.publish.logs.name, 'Logs_Build_$(Agent.Os)_$(_BuildConfig)') }}
+        displayName: 'Publish logs'
         continueOnError: true
         condition: always()
 
@@ -253,7 +255,9 @@ jobs:
         IgnoreDirectories: ${{ parameters.componentGovernanceIgnoreDirectories }}
 
   - ${{ if eq(parameters.enableBuildRetry, 'true') }}:
-    - publish: $(Build.SourcesDirectory)\eng\common\BuildConfiguration
-      artifact: BuildConfiguration
-      displayName: Publish build retry configuration
-      continueOnError: true
+    - task: 1ES.PublishPipelineArtifact@1
+      inputs:
+        targetPath: '$(Build.SourcesDirectory)\eng\common\BuildConfiguration'
+        artifactName: 'BuildConfiguration'
+      displayName: 'Publish build retry configuration'
+      continueOnError: true
\ No newline at end of file
diff --git a/eng/common/templates-official/job/publish-build-assets.yml b/eng/common/templates-official/job/publish-build-assets.yml
index ea5104625fa..53138622fe7 100644
--- a/eng/common/templates-official/job/publish-build-assets.yml
+++ b/eng/common/templates-official/job/publish-build-assets.yml
@@ -94,14 +94,16 @@ jobs:
       inputs:
         targetType: inline
         script: |
-          Add-Content -Path "$(Build.StagingDirectory)/ReleaseConfigs.txt" -Value $(BARBuildId)
-          Add-Content -Path "$(Build.StagingDirectory)/ReleaseConfigs.txt" -Value "$(DefaultChannels)"
-          Add-Content -Path "$(Build.StagingDirectory)/ReleaseConfigs.txt" -Value $(IsStableBuild)
+          New-Item -Path "$(Build.StagingDirectory)/ReleaseConfigs" -ItemType Directory -Force
+          $filePath = "$(Build.StagingDirectory)/ReleaseConfigs/ReleaseConfigs.txt"
+          Add-Content -Path $filePath -Value $(BARBuildId)
+          Add-Content -Path $filePath -Value "$(DefaultChannels)"
+          Add-Content -Path $filePath -Value $(IsStableBuild)
     
     - task: 1ES.PublishBuildArtifacts@1
       displayName: Publish ReleaseConfigs Artifact
       inputs:
-        PathtoPublish: '$(Build.StagingDirectory)/ReleaseConfigs.txt'
+        PathtoPublish: '$(Build.StagingDirectory)/ReleaseConfigs'
         PublishLocation: Container
         ArtifactName: ReleaseConfigs
 
diff --git a/global.json b/global.json
index daf524dfe83..644248c5b89 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
     "xcopy-msbuild": "17.8.5"
   },
   "msbuild-sdks": {
-    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24158.4"
+    "Microsoft.DotNet.Arcade.Sdk": "8.0.0-beta.24165.4"
   }
 }
diff --git a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
index 0649b96b566..67eba7e0b12 100644
--- a/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/NodePackets_Tests.cs
@@ -74,6 +74,7 @@ public void VerifyEventType()
             ResponseFileUsedEventArgs responseFileUsed = new("path");
             UninitializedPropertyReadEventArgs uninitializedPropertyRead = new("prop", "message", "help", "sender", MessageImportance.Normal);
             EnvironmentVariableReadEventArgs environmentVariableRead = new("env", "message", "help", "sender", MessageImportance.Normal);
+            GeneratedFileUsedEventArgs generatedFileUsed = new GeneratedFileUsedEventArgs("path", "some content");
 
             VerifyLoggingPacket(buildFinished, LoggingEventType.BuildFinishedEvent);
             VerifyLoggingPacket(buildStarted, LoggingEventType.BuildStartedEvent);
@@ -106,6 +107,7 @@ public void VerifyEventType()
             VerifyLoggingPacket(responseFileUsed, LoggingEventType.ResponseFileUsedEvent);
             VerifyLoggingPacket(uninitializedPropertyRead, LoggingEventType.UninitializedPropertyRead);
             VerifyLoggingPacket(environmentVariableRead, LoggingEventType.EnvironmentVariableReadEvent);
+            VerifyLoggingPacket(generatedFileUsed, LoggingEventType.GeneratedFileUsedEvent);
         }
 
         private static BuildEventContext CreateBuildEventContext()
@@ -307,6 +309,7 @@ public void TestTranslation()
                         ExtendedMetadata = new Dictionary<string, string> { { "m1", "v1" }, { "m2", "v2" } },
                         BuildEventContext = new BuildEventContext(1, 2, 3, 4, 5, 6, 7)
                     },
+                    new GeneratedFileUsedEventArgs("path", "some content"),
                 };
                 foreach (BuildEventArgs arg in testArgs)
                 {
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 99474115048..46170961e81 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -547,6 +547,7 @@ public void RoundtripResponseFileUsedEventArgs()
                 e => e.ResponseFilePath);
         }
 
+
         [Fact]
         public void RoundtripCriticalBuildMessageEventArgs()
         {
diff --git a/src/Build.UnitTests/Evaluation/Expander_Tests.cs b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
index d7744692f25..b7744d6ed4f 100644
--- a/src/Build.UnitTests/Evaluation/Expander_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Expander_Tests.cs
@@ -3890,8 +3890,14 @@ public void PropertyStringConstructorConsumingItemMetadata(string metadatumName,
             result.ShouldBe(metadatumValue);
         }
 
-        [Fact]
-        public void PropertyFunctionHashCodeSameOnlyIfStringSame()
+        public static IEnumerable<object[]> GetHashAlgoTypes()
+            => Enum.GetNames(typeof(IntrinsicFunctions.StringHashingAlgorithm))
+                .Append(null)
+                .Select(t => new object[] { t });
+
+        [Theory]
+        [MemberData(nameof(GetHashAlgoTypes))]
+        public void PropertyFunctionHashCodeSameOnlyIfStringSame(string hashType)
         {
             PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
             Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
@@ -3906,8 +3912,9 @@ public void PropertyFunctionHashCodeSameOnlyIfStringSame()
                 "cat12s",
                 "cat1s"
             };
-            int[] hashes = stringsToHash.Select(toHash =>
-                (int)expander.ExpandPropertiesLeaveTypedAndEscaped($"$([MSBuild]::StableStringHash('{toHash}'))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance))
+            string hashTypeString = hashType == null ? "" : $", '{hashType}'";
+            object[] hashes = stringsToHash.Select(toHash =>
+                expander.ExpandPropertiesLeaveTypedAndEscaped($"$([MSBuild]::StableStringHash('{toHash}'{hashTypeString}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance))
                 .ToArray();
             for (int a = 0; a < hashes.Length; a++)
             {
@@ -3925,6 +3932,33 @@ public void PropertyFunctionHashCodeSameOnlyIfStringSame()
             }
         }
 
+        [Theory]
+        [MemberData(nameof(GetHashAlgoTypes))]
+        public void PropertyFunctionHashCodeReturnsExpectedType(string hashType)
+        {
+            PropertyDictionary<ProjectPropertyInstance> pg = new PropertyDictionary<ProjectPropertyInstance>();
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander = new Expander<ProjectPropertyInstance, ProjectItemInstance>(pg, FileSystems.Default);
+            Type expectedType;
+
+            expectedType = hashType switch
+            {
+                null => typeof(int),
+                "Legacy" => typeof(int),
+                "Fnv1a32bit" => typeof(int),
+                "Fnv1a32bitFast" => typeof(int),
+                "Fnv1a64bit" => typeof(long),
+                "Fnv1a64bitFast" => typeof(long),
+                "Sha256" => typeof(string),
+                _ => throw new ArgumentOutOfRangeException(nameof(hashType))
+            };
+
+
+            string hashTypeString = hashType == null ? "" : $", '{hashType}'";
+            object hashValue = expander.ExpandPropertiesLeaveTypedAndEscaped($"$([MSBuild]::StableStringHash('FooBar'{hashTypeString}))", ExpanderOptions.ExpandProperties, MockElementLocation.Instance);
+
+            hashValue.ShouldBeOfType(expectedType);
+        }
+
         [Theory]
         [InlineData("easycase")]
         [InlineData("")]
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index b98f902e994..cc8e5ac2efa 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -4159,7 +4159,15 @@ private bool TryExecuteWellKnownFunction(out object returnVal, object objectInst
                         {
                             if (TryGetArg(args, out string arg0))
                             {
-                                returnVal = IntrinsicFunctions.StableStringHash(arg0);
+                                // Prevent loading methods refs from StringTools if ChangeWave opted out.
+                                returnVal = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_10)
+                                    ? IntrinsicFunctions.StableStringHash(arg0)
+                                    : IntrinsicFunctions.StableStringHashLegacy(arg0);
+                                return true;
+                            }
+                            else if (TryGetArgs(args, out string arg1, out string arg2) && Enum.TryParse<IntrinsicFunctions.StringHashingAlgorithm>(arg2, true, out var hashAlgorithm))
+                            {
+                                returnVal = IntrinsicFunctions.StableStringHash(arg1, hashAlgorithm);
                                 return true;
                             }
                         }
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index 37312b8c83e..6f8c5ed00f6 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
 using System.Text;
@@ -14,6 +15,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
 using Microsoft.Build.Utilities;
+using Microsoft.NET.StringTools;
 using Microsoft.Win32;
 
 // Needed for DoesTaskHostExistForParameters
@@ -397,12 +399,60 @@ internal static string ConvertFromBase64(string toDecode)
             return Encoding.UTF8.GetString(Convert.FromBase64String(toDecode));
         }
 
+        internal enum StringHashingAlgorithm
+        {
+            // Legacy way of calculating StableStringHash - which was derived from string GetHashCode
+            Legacy,
+            // FNV-1a 32bit hash
+            Fnv1a32bit,
+            // Custom FNV-1a 32bit hash - optimized for speed by hashing by the whole chars (not individual bytes)
+            Fnv1a32bitFast,
+            // FNV-1a 64bit hash
+            Fnv1a64bit,
+            // Custom FNV-1a 64bit hash - optimized for speed by hashing by the whole chars (not individual bytes)
+            Fnv1a64bitFast,
+            // SHA256 hash - gets the hex string of the hash (with no prefix)
+            Sha256
+        }
+
         /// <summary>
-        /// Hash the string independent of bitness and target framework.
+        /// Legacy implementation that doesn't lead to JIT pulling the new functions from StringTools (so those must not be referenced anywhere in the function body)
+        ///  - for cases where the calling code would erroneously load old version of StringTools alongside of the new version of Microsoft.Build.
+        /// Should be removed once Wave17_10 is removed.
         /// </summary>
-        internal static int StableStringHash(string toHash)
-        {
-            return CommunicationsUtilities.GetHashCode(toHash);
+        internal static object StableStringHashLegacy(string toHash)
+            => CommunicationsUtilities.GetHashCode(toHash);
+
+        /// <summary>
+        /// Hash the string independent of bitness, target framework and default codepage of the environment.
+        /// We do not want this to be inlined, as then the Expander would call directly the new overload, and hence
+        ///  JIT load the functions from StringTools - so we would not be able to prevent their loading with ChangeWave as we do now.
+        /// </summary>
+        [MethodImpl(MethodImplOptions.NoInlining)]
+        internal static object StableStringHash(string toHash)
+            => StableStringHash(toHash, StringHashingAlgorithm.Legacy);
+
+        internal static object StableStringHash(string toHash, StringHashingAlgorithm algo) =>
+            algo switch
+            {
+                StringHashingAlgorithm.Legacy => CommunicationsUtilities.GetHashCode(toHash),
+                StringHashingAlgorithm.Fnv1a32bit => FowlerNollVo1aHash.ComputeHash32(toHash),
+                StringHashingAlgorithm.Fnv1a32bitFast => FowlerNollVo1aHash.ComputeHash32Fast(toHash),
+                StringHashingAlgorithm.Fnv1a64bit => FowlerNollVo1aHash.ComputeHash64(toHash),
+                StringHashingAlgorithm.Fnv1a64bitFast => FowlerNollVo1aHash.ComputeHash64Fast(toHash),
+                StringHashingAlgorithm.Sha256 => CalculateSha256(toHash),
+                _ => throw new ArgumentOutOfRangeException(nameof(algo), algo, null)
+            };
+
+        private static string CalculateSha256(string toHash)
+        {
+            var sha = System.Security.Cryptography.SHA256.Create();
+            var hashResult = new StringBuilder();
+            foreach (byte theByte in sha.ComputeHash(Encoding.UTF8.GetBytes(toHash)))
+            {
+                hashResult.Append(theByte.ToString("x2"));
+            }
+            return hashResult.ToString();
         }
 
         /// <summary>
diff --git a/src/Build/Instance/TaskFactoryLoggingHost.cs b/src/Build/Instance/TaskFactoryLoggingHost.cs
index 1fbad6a47b6..c8e70102bda 100644
--- a/src/Build/Instance/TaskFactoryLoggingHost.cs
+++ b/src/Build/Instance/TaskFactoryLoggingHost.cs
@@ -340,7 +340,9 @@ internal bool IsEventSerializable(BuildEventArgs e)
 #pragma warning disable SYSLIB0050
             // Types which are not serializable and are not IExtendedBuildEventArgs as
             // those always implement custom serialization by WriteToStream and CreateFromStream.
-            if (!e.GetType().GetTypeInfo().IsSerializable && e is not IExtendedBuildEventArgs)
+            if (!e.GetType().GetTypeInfo().IsSerializable &&
+                e is not IExtendedBuildEventArgs &&
+                e is not GeneratedFileUsedEventArgs)
 #pragma warning restore SYSLIB0050
             {
                 _loggingContext.LogWarning(null, new BuildEventFileInfo(string.Empty), "ExpectedEventToBeSerializable", e.GetType().Name);
diff --git a/src/Build/Logging/BinaryLogger/BinaryLogger.cs b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
index a9e6f75705f..54de65d1d05 100644
--- a/src/Build/Logging/BinaryLogger/BinaryLogger.cs
+++ b/src/Build/Logging/BinaryLogger/BinaryLogger.cs
@@ -67,6 +67,8 @@ public sealed class BinaryLogger : ILogger
         //   - Making ProjectStartedEventArgs, ProjectEvaluationFinishedEventArgs, AssemblyLoadBuildEventArgs equal
         //     between de/serialization roundtrips.
         //   - Adding serialized events lengths - to support forward compatible reading
+        // version 19:
+        //   - GeneratedFileUsedEventArgs exposed for brief period of time (so let's continue with 20)
 
         // This should be never changed.
         // The minimum version of the binary log reader that can read log of above version.
@@ -333,19 +335,29 @@ private void Write(BuildEventArgs e)
         {
             if (stream != null)
             {
-                // TODO: think about queuing to avoid contention
-                lock (eventArgsWriter)
+                if (projectImportsCollector != null)
                 {
-                    eventArgsWriter.Write(e);
+                    CollectImports(e);
                 }
 
-                if (projectImportsCollector != null)
+                if (DoNotWriteToBinlog(e))
                 {
-                    CollectImports(e);
+                    return;
+                }
+
+                // TODO: think about queuing to avoid contention
+                lock (eventArgsWriter)
+                {
+                    eventArgsWriter.Write(e);
                 }
             }
         }
 
+        private static bool DoNotWriteToBinlog(BuildEventArgs e)
+        {
+            return e is GeneratedFileUsedEventArgs;
+        }
+
         private void CollectImports(BuildEventArgs e)
         {
             if (e is ProjectImportedEventArgs importArgs && importArgs.ImportedProjectFile != null)
@@ -364,6 +376,11 @@ private void CollectImports(BuildEventArgs e)
             {
                 projectImportsCollector.AddFile(responseFileArgs.ResponseFilePath);
             }
+            else if (e is GeneratedFileUsedEventArgs generatedFileUsedEventArgs && generatedFileUsedEventArgs.FilePath != null)
+            {
+                string fullPath = Path.GetFullPath(generatedFileUsedEventArgs.FilePath);
+                projectImportsCollector.AddFileFromMemory(fullPath, generatedFileUsedEventArgs.Content);
+            }
         }
 
         /// <summary>
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 8a8311e1fd6..a3ce5efa3c5 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -15,6 +15,8 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Utilities;
+using Microsoft.NET.StringTools;
 
 #nullable disable
 
@@ -1260,9 +1262,9 @@ private void Write(IExtendedBuildEventArgs extendedData)
 
         internal readonly struct HashKey : IEquatable<HashKey>
         {
-            private readonly ulong value;
+            private readonly long value;
 
-            private HashKey(ulong i)
+            private HashKey(long i)
             {
                 value = i;
             }
@@ -1275,13 +1277,13 @@ public HashKey(string text)
                 }
                 else
                 {
-                    value = FnvHash64.GetHashCode(text);
+                    value = FowlerNollVo1aHash.ComputeHash64Fast(text);
                 }
             }
 
             public static HashKey Combine(HashKey left, HashKey right)
             {
-                return new HashKey(FnvHash64.Combine(left.value, right.value));
+                return new HashKey(FowlerNollVo1aHash.Combine64(left.value, right.value));
             }
 
             public HashKey Add(HashKey other) => Combine(this, other);
@@ -1311,35 +1313,5 @@ public override string ToString()
                 return value.ToString();
             }
         }
-
-        internal static class FnvHash64
-        {
-            public const ulong Offset = 14695981039346656037;
-            public const ulong Prime = 1099511628211;
-
-            public static ulong GetHashCode(string text)
-            {
-                ulong hash = Offset;
-
-                unchecked
-                {
-                    for (int i = 0; i < text.Length; i++)
-                    {
-                        char ch = text[i];
-                        hash = (hash ^ ch) * Prime;
-                    }
-                }
-
-                return hash;
-            }
-
-            public static ulong Combine(ulong left, ulong right)
-            {
-                unchecked
-                {
-                    return (left ^ right) * Prime;
-                }
-            }
-        }
     }
 }
diff --git a/src/Framework.UnitTests/GeneratedFileUsedEventArgs_Tests.cs b/src/Framework.UnitTests/GeneratedFileUsedEventArgs_Tests.cs
new file mode 100644
index 00000000000..576c37e265f
--- /dev/null
+++ b/src/Framework.UnitTests/GeneratedFileUsedEventArgs_Tests.cs
@@ -0,0 +1,38 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Text;
+using System.Threading.Tasks;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Framework.UnitTests
+{
+    public class GeneratedFileUsedEventArgs_Tests
+    {
+        [Fact]
+        public void SerializationDeserializationTest()
+        {
+            string filePath = "path";
+            string content = "content";
+            GeneratedFileUsedEventArgs arg = new(filePath, content);
+
+            using MemoryStream stream = new MemoryStream();
+            using BinaryWriter bw = new BinaryWriter(stream);
+            arg.WriteToStream(bw);
+
+            stream.Position = 0;
+            using BinaryReader br = new BinaryReader(stream);
+            GeneratedFileUsedEventArgs argDeserialized = new();
+            int packetVersion = (Environment.Version.Major * 10) + Environment.Version.Minor;
+            argDeserialized.CreateFromStream(br, packetVersion);
+
+            argDeserialized.FilePath.ShouldBe(filePath);
+            argDeserialized.Content.ShouldBe(content);
+        }
+    }
+}
diff --git a/src/Framework/BuildCop/BuildCopEventArgs.cs b/src/Framework/BuildCheck/BuildCheckEventArgs.cs
similarity index 100%
rename from src/Framework/BuildCop/BuildCopEventArgs.cs
rename to src/Framework/BuildCheck/BuildCheckEventArgs.cs
diff --git a/src/Framework/BuildCop/IBuildCopResult.cs b/src/Framework/BuildCheck/IBuildCheckResult.cs
similarity index 100%
rename from src/Framework/BuildCop/IBuildCopResult.cs
rename to src/Framework/BuildCheck/IBuildCheckResult.cs
diff --git a/src/Framework/Features.cs b/src/Framework/Features.cs
index 48d3f785a63..ec1183c94f5 100644
--- a/src/Framework/Features.cs
+++ b/src/Framework/Features.cs
@@ -44,6 +44,7 @@ public static class Features
         {
             { "BuildCheck.Beta", FeatureStatus.Preview },
             { "EvaluationContext_SharedSDKCachePolicy", FeatureStatus.Available }, // EvaluationContext supports the SharingPolicy.SharedSDKCache flag.
+            { "TerminalLogger_MultiLineHandler", FeatureStatus.Available }, // TerminalLogger has better explicit support for rendering multi-line messages
             // Add more features here.
         };
 
diff --git a/src/Framework/GeneratedFileUsedEventArgs.cs b/src/Framework/GeneratedFileUsedEventArgs.cs
new file mode 100644
index 00000000000..f64ba9521ff
--- /dev/null
+++ b/src/Framework/GeneratedFileUsedEventArgs.cs
@@ -0,0 +1,60 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+
+namespace Microsoft.Build.Framework
+{
+    /// <summary>
+    /// Arguments for the generated file used event
+    /// </summary>
+    internal class GeneratedFileUsedEventArgs : BuildMessageEventArgs
+    {
+        public GeneratedFileUsedEventArgs()
+        {
+        }
+
+        /// <summary>
+        /// Initializes a new instance of the <see cref="GeneratedFileUsedEventArgs"/> class.
+        /// </summary>
+        /// 
+        public GeneratedFileUsedEventArgs(string filePath, string content)
+        // We are not sending the event to binlog (just the file), so we do not want it
+        // to have any stringified representation for other logs either.
+            : base(string.Empty, null, null, MessageImportance.Low)
+        {
+            FilePath = filePath;
+            Content = content;
+        }
+
+        /// <summary>
+        /// The file path relative to the current project.
+        /// </summary>
+        public string? FilePath { set; get; }
+
+        /// <summary>
+        /// The content of the file.
+        /// </summary>
+        public string? Content { set; get; }
+
+        internal override void WriteToStream(BinaryWriter writer)
+        {
+            base.WriteToStream(writer);
+
+            if (FilePath != null && Content != null)
+            {
+                writer.Write(FilePath);
+                writer.Write(Content);
+            }
+        }
+
+        internal override void CreateFromStream(BinaryReader reader, int version)
+        {
+            base.CreateFromStream(reader, version);
+
+            FilePath = reader.ReadString();
+            Content = reader.ReadString();
+        }
+    }
+}
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
index aeec26abf26..04778898b3c 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Linux.verified.txt
@@ -1,5 +1,9 @@
 ï»¿]9;4;3;\  project [33;1msucceeded with warnings[m (0.2s)
-    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
 [?25l[1F
 [?25h
 Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
index 3b6fcaf238d..c469153e853 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.OSX.verified.txt
@@ -1,5 +1,9 @@
 ï»¿  project [33;1msucceeded with warnings[m (0.2s)
-    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
 [?25l[1F
 [?25h
 Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
index aeec26abf26..04778898b3c 100644
--- a/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
+++ b/src/MSBuild.UnitTests/Snapshots/TerminalLogger_Tests.PrintBuildSummary_SucceededWithWarnings.Windows.verified.txt
@@ -1,5 +1,9 @@
 ï»¿]9;4;3;\  project [33;1msucceeded with warnings[m (0.2s)
-    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: Warning!
+    directory/[1mfile[m(1,2,3,4): [33;1mwarning[m [33;1mAA0000[m: 
+      A
+      Multi
+      Line
+      Warning!
 [?25l[1F
 [?25h
 Build [33;1msucceeded with warnings[m in 5.0s
diff --git a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
index 75749517b55..a1c6889502a 100644
--- a/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
+++ b/src/MSBuild.UnitTests/TerminalLogger_Tests.cs
@@ -42,6 +42,8 @@ public class TerminalLogger_Tests : IEventSource, IDisposable
 
         private VerifySettings _settings = new();
 
+        private readonly CultureInfo _originalCulture = Thread.CurrentThread.CurrentCulture;
+
         public TerminalLogger_Tests()
         {
             _mockTerminal = new Terminal(_outputWriter);
@@ -52,6 +54,9 @@ public TerminalLogger_Tests()
             _terminallogger.CreateStopwatch = () => new MockStopwatch();
 
             UseProjectRelativeDirectory("Snapshots");
+
+            // Avoids issues with different cultures on different machines
+            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
         }
 
         #region IEventSource implementation
@@ -93,6 +98,7 @@ public TerminalLogger_Tests()
         public void Dispose()
         {
             _terminallogger.Shutdown();
+            Thread.CurrentThread.CurrentCulture = _originalCulture;
         }
 
         #endregion
@@ -220,7 +226,7 @@ public Task PrintBuildSummary_SucceededWithWarnings()
         {
             InvokeLoggerCallbacksForSimpleProject(succeeded: true, () =>
             {
-                WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("Warning!"));
+                WarningRaised?.Invoke(_eventSender, MakeWarningEventArgs("A\nMulti\r\nLine\nWarning!"));
             });
 
             return Verify(_outputWriter.ToString(), _settings).UniqueForOSPlatform();
diff --git a/src/MSBuild/TerminalLogger/TerminalLogger.cs b/src/MSBuild/TerminalLogger/TerminalLogger.cs
index 195ebb95789..9c8e7e4b624 100644
--- a/src/MSBuild/TerminalLogger/TerminalLogger.cs
+++ b/src/MSBuild/TerminalLogger/TerminalLogger.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Text;
 using System.Threading;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
@@ -12,6 +13,7 @@
 
 #if NET7_0_OR_GREATER
 using System.Diagnostics.CodeAnalysis;
+using System.Globalization;
 #endif
 #if NETFRAMEWORK
 using Microsoft.IO;
@@ -42,6 +44,8 @@ internal sealed partial class TerminalLogger : INodeLogger
     private static readonly string[] _immediateMessageKeywords = { "[CredentialProvider]", "--interactive" };
 #endif
 
+    private static readonly string[] newLineStrings = { "\r\n", "\n" };
+
     /// <summary>
     /// A wrapper over the project context ID passed to us in <see cref="IEventSource"/> logger events.
     /// </summary>
@@ -574,6 +578,7 @@ private void TargetStarted(object sender, TargetStartedEventArgs e)
 
             string projectFile = Path.GetFileNameWithoutExtension(e.ProjectFile);
 
+
             var isTestTarget = e.TargetName == _testStartTarget;
 
             var targetName = isTestTarget ? "Testing" : e.TargetName;
@@ -725,19 +730,16 @@ private void MessageRaised(object sender, BuildMessageEventArgs e)
     private void WarningRaised(object sender, BuildWarningEventArgs e)
     {
         BuildEventContext? buildEventContext = e.BuildEventContext;
-        string message = EventArgsFormatting.FormatEventMessage(
+        string message = FormatEventMessage(
                 category: AnsiCodes.Colorize("warning", TerminalColor.Yellow),
                 subcategory: e.Subcategory,
                 message: e.Message,
                 code: AnsiCodes.Colorize(e.Code, TerminalColor.Yellow),
                 file: HighlightFileName(e.File),
-                projectFile: e.ProjectFile ?? null,
                 lineNumber: e.LineNumber,
                 endLineNumber: e.EndLineNumber,
                 columnNumber: e.ColumnNumber,
-                endColumnNumber: e.EndColumnNumber,
-                threadId: e.ThreadId,
-                logOutputProperties: null);
+                endColumnNumber: e.EndColumnNumber);
 
         if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
@@ -774,19 +776,16 @@ private bool IsImmediateMessage(string message) =>
     private void ErrorRaised(object sender, BuildErrorEventArgs e)
     {
         BuildEventContext? buildEventContext = e.BuildEventContext;
-        string message = EventArgsFormatting.FormatEventMessage(
+        string message = FormatEventMessage(
                 category: AnsiCodes.Colorize("error", TerminalColor.Red),
                 subcategory: e.Subcategory,
                 message: e.Message,
                 code: AnsiCodes.Colorize(e.Code, TerminalColor.Red),
                 file: HighlightFileName(e.File),
-                projectFile: e.ProjectFile ?? null,
                 lineNumber: e.LineNumber,
                 endLineNumber: e.EndLineNumber,
                 columnNumber: e.ColumnNumber,
-                endColumnNumber: e.EndColumnNumber,
-                threadId: e.ThreadId,
-                logOutputProperties: null);
+                endColumnNumber: e.EndColumnNumber);
 
         if (buildEventContext is not null && _projects.TryGetValue(new ProjectContext(buildEventContext), out Project? project))
         {
@@ -938,5 +937,107 @@ private int NodeIndexForContext(BuildEventContext context)
             : path;
     }
 
+    private string FormatEventMessage(
+            string category,
+            string subcategory,
+            string? message,
+            string code,
+            string? file,
+            int lineNumber,
+            int endLineNumber,
+            int columnNumber,
+            int endColumnNumber)
+    {
+        message ??= string.Empty;
+        StringBuilder builder = new(128);
+
+        if (string.IsNullOrEmpty(file))
+        {
+            builder.Append("MSBUILD : ");    // Should not be localized.
+        }
+        else
+        {
+            builder.Append(file);
+
+            if (lineNumber == 0)
+            {
+                builder.Append(" : ");
+            }
+            else
+            {
+                if (columnNumber == 0)
+                {
+                    builder.Append(endLineNumber == 0 ?
+                        $"({lineNumber}): " :
+                        $"({lineNumber}-{endLineNumber}): ");
+                }
+                else
+                {
+                    if (endLineNumber == 0)
+                    {
+                        builder.Append(endColumnNumber == 0 ?
+                            $"({lineNumber},{columnNumber}): " :
+                            $"({lineNumber},{columnNumber}-{endColumnNumber}): ");
+                    }
+                    else
+                    {
+                        builder.Append(endColumnNumber == 0 ?
+                            $"({lineNumber}-{endLineNumber},{columnNumber}): " :
+                            $"({lineNumber},{columnNumber},{endLineNumber},{endColumnNumber}): ");
+                    }
+                }
+            }
+        }
+
+        if (!string.IsNullOrEmpty(subcategory))
+        {
+            builder.Append(subcategory);
+            builder.Append(' ');
+        }
+
+        builder.Append($"{category} {code}: ");
+
+        // render multi-line message in a special way
+        if (message.IndexOf('\n') >= 0)
+        {
+            const string indent = $"{Indentation}{Indentation}{Indentation}";
+            string[] lines = message.Split(newLineStrings, StringSplitOptions.None);
+
+            foreach (string line in lines)
+            {
+                if (indent.Length + line.Length > Terminal.Width) // custom wrapping with indentation
+                {
+                    WrapText(builder, line, Terminal.Width, indent);
+                }
+                else
+                {
+                    builder.AppendLine();
+                    builder.Append(indent);
+                    builder.Append(line);
+                }
+            }
+        }
+        else
+        {
+            builder.Append(message);
+        }
+
+        return builder.ToString();
+    }
+
+    private static void WrapText(StringBuilder sb, string text, int maxLength, string indent)
+    {
+        int start = 0;
+        while (start < text.Length)
+        {
+            int length = Math.Min(maxLength - indent.Length, text.Length - start);
+            sb.AppendLine();
+            sb.Append(indent);
+            sb.Append(text.AsSpan().Slice(start, length));
+
+            start += length;
+        }
+    }
+
     #endregion
 }
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index ac9c638e003..d2849ba5f45 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -1849,6 +1849,26 @@ internal static void SetConsoleUI()
             CultureInfo.CurrentUICulture = desiredCulture;
             CultureInfo.DefaultThreadCurrentUICulture = desiredCulture;
 
+#if RUNTIME_TYPE_NETCORE
+            if (EncodingUtilities.CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding())
+#else
+            if (EncodingUtilities.CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding()
+                && !CultureInfo.CurrentUICulture.TwoLetterISOLanguageName.Equals("en", StringComparison.InvariantCultureIgnoreCase))
+#endif
+            {
+                try
+                {
+                    // Setting both encodings causes a change in the CHCP, making it so we don't need to P-Invoke CHCP ourselves.
+                    Console.OutputEncoding = Encoding.UTF8;
+                    // If the InputEncoding is not set, the encoding will work in CMD but not in PowerShell, as the raw CHCP page won't be changed.
+                    Console.InputEncoding = Encoding.UTF8;
+                }
+                catch (Exception ex) when (ex is IOException || ex is SecurityException)
+                {
+                    // The encoding is unavailable. Do nothing.
+                }
+            }
+
             // Determine if the language can be displayed in the current console codepage, otherwise set to US English
             int codepage;
 
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index 3a90c6a33ae..291594fcfdc 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -211,30 +211,35 @@ internal enum LoggingEventType : int
         /// </summary>
         ExtendedCriticalBuildMessageEvent = 33,
 
+        /// <summary>
+        /// Event is a <see cref="GeneratedFileUsedEventArgs"/>
+        /// </summary>
+        GeneratedFileUsedEvent = 34,
+        
         /// <summary>
         /// Event is <see cref="BuildCheckResultMessage"/>
         /// </summary>
-        BuildCheckMessageEvent = 34,
+        BuildCheckMessageEvent = 35,
 
         /// <summary>
         /// Event is <see cref="BuildCheckResultWarning"/>
         /// </summary>
-        BuildCheckWarningEvent = 35,
+        BuildCheckWarningEvent = 36,
 
         /// <summary>
         /// Event is <see cref="BuildCheckResultError"/>
         /// </summary>
-        BuildCheckErrorEvent = 36,
+        BuildCheckErrorEvent = 37,
 
         /// <summary>
         /// Event is <see cref="BuildCheckTracingEventArgs"/>
         /// </summary>
-        BuildCheckTracingEvent = 37,
+        BuildCheckTracingEvent = 38,
 
         /// <summary>
         /// Event is <see cref="BuildCheckAcquisitionEventArgs"/>
         /// </summary>
-        BuildCheckAcquisitionEvent = 38,
+        BuildCheckAcquisitionEvent = 39,
     }
     #endregion
 
@@ -619,7 +624,8 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
                 LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
                 LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
-                LoggingEventType.ResponseFileUsedEvent => new ResponseFileUsedEventArgs(null),
+                LoggingEventType.ResponseFileUsedEvent => new ResponseFileUsedEventArgs(null),               
+
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
                 LoggingEventType.AssemblyLoadEvent => new AssemblyLoadBuildEventArgs(),
                 LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
@@ -640,6 +646,7 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.PropertyInitialValueSet => new PropertyInitialValueSetEventArgs(),
                 LoggingEventType.PropertyReassignment => new PropertyReassignmentEventArgs(),
                 LoggingEventType.UninitializedPropertyRead => new UninitializedPropertyReadEventArgs(),
+                LoggingEventType.GeneratedFileUsedEvent => new GeneratedFileUsedEventArgs(),
                 LoggingEventType.BuildCheckMessageEvent => new BuildCheckResultMessage(),
                 LoggingEventType.BuildCheckWarningEvent => new BuildCheckResultWarning(),
                 LoggingEventType.BuildCheckErrorEvent => new BuildCheckResultError(),
@@ -756,6 +763,10 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.UninitializedPropertyRead;
             }
+            else if (eventType == typeof(GeneratedFileUsedEventArgs))
+            {
+                return LoggingEventType.GeneratedFileUsedEvent;
+            }
             else if (eventType == typeof(BuildCheckResultMessage))
             {
                 return LoggingEventType.BuildCheckMessageEvent;
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index da848678ded..9a5315b1b32 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -503,6 +503,21 @@ public void LogMessageFromResources(MessageImportance importance, string message
 #endif
         }
 
+        /// <summary>
+        /// Logs a file generated from the given data.
+        /// </summary>
+        /// <param name="filePath">The file path relative to the currecnt project.</param>
+        /// <param name="content">The content of the file.</param>
+        public void LogIncludeGeneratedFile(string filePath, string content)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(filePath, nameof(filePath));
+            ErrorUtilities.VerifyThrowArgumentNull(content, nameof(content));
+
+            var e = new GeneratedFileUsedEventArgs(filePath, content);
+
+            BuildEngine.LogMessageEvent(e);
+        }
+
         /// <summary>
         /// Flatten the inner exception message
         /// </summary>
diff --git a/src/StringTools/FowlerNollVo1aHash.cs b/src/StringTools/FowlerNollVo1aHash.cs
new file mode 100644
index 00000000000..5a9a876e4c0
--- /dev/null
+++ b/src/StringTools/FowlerNollVo1aHash.cs
@@ -0,0 +1,145 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Runtime.InteropServices;
+using System;
+
+namespace Microsoft.NET.StringTools
+{
+    /// <summary>
+    /// Fowler/Noll/Vo hashing.
+    /// </summary>
+    public static class FowlerNollVo1aHash
+    {
+        // Fowler/Noll/Vo hashing.
+        // http://www.isthe.com/chongo/tech/comp/fnv/
+        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash
+        // http://www.isthe.com/chongo/src/fnv/hash_32a.c
+
+        // 32 bit FNV prime and offset basis for FNV-1a.
+        private const uint fnvPrimeA32Bit = 16777619;
+        private const uint fnvOffsetBasisA32Bit = 2166136261;
+
+        // 64 bit FNV prime and offset basis for FNV-1a.
+        private const long fnvPrimeA64Bit = 1099511628211;
+        private const long fnvOffsetBasisA64Bit = unchecked((long)14695981039346656037);
+
+        /// <summary>
+        /// Computes 32 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).
+        /// </summary>
+        /// <param name="text">String to be hashed.</param>
+        /// <returns>32 bit signed hash</returns>
+        public static int ComputeHash32(string text)
+        {
+            uint hash = fnvOffsetBasisA32Bit;
+
+            unchecked
+            {
+                for (int i = 0; i < text.Length; i++)
+                {
+                    char ch = text[i];
+                    byte b = (byte)ch;
+                    hash ^= b;
+                    hash *= fnvPrimeA32Bit;
+
+                    b = (byte)(ch >> 8);
+                    hash ^= b;
+                    hash *= fnvPrimeA32Bit;
+                }
+            }
+
+            return unchecked((int)hash);
+        }
+
+        /// <summary>
+        /// Computes 32 bit Fowler/Noll/Vo-1a inspired hash of a string.
+        /// The hashing algorithm process the data by the whole 16bit chars, instead of by bytes.
+        ///  this speeds up the hashing process almost by 2x, while not significantly increasing collisions rate.
+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a
+        /// </summary>
+        /// <param name="text">String to be hashed.</param>
+        /// <returns>32 bit unsigned hash</returns>
+        public static int ComputeHash32Fast(string text)
+        {
+            uint hash = fnvOffsetBasisA32Bit;
+
+            unchecked
+            {
+                for (int i = 0; i < text.Length; i++)
+                {
+                    char ch = text[i];
+
+                    hash = (hash ^ ch) * fnvPrimeA32Bit;
+                }
+            }
+
+            return unchecked((int)hash);
+        }
+
+        /// <summary>
+        /// Computes 64 bit Fowler/Noll/Vo-1a inspired hash of a string.
+        /// The hashing algorithm process the data by the whole 16bit chars, instead of by bytes.
+        ///  this speeds up the hashing process almost by 2x, while not significantly increasing collisions rate.
+        /// Analysis: https://github.com/KirillOsenkov/MSBuildStructuredLog/wiki/String-Hashing#faster-fnv-1a
+        /// </summary>
+        /// <param name="text">String to be hashed.</param>
+        /// <returns>64 bit unsigned hash</returns>
+        public static long ComputeHash64Fast(string text)
+        {
+            long hash = fnvOffsetBasisA64Bit;
+
+            unchecked
+            {
+                for (int i = 0; i < text.Length; i++)
+                {
+                    char ch = text[i];
+
+                    hash = (hash ^ ch) * fnvPrimeA64Bit;
+                }
+            }
+
+            return hash;
+        }
+
+        /// <summary>
+        /// Computes 64 bit Fowler/Noll/Vo-1a hash of a string (regardless of encoding).
+        /// </summary>
+        /// <param name="text">String to be hashed.</param>
+        /// <returns>64 bit unsigned hash</returns>
+        public static long ComputeHash64(string text)
+        {
+            long hash = fnvOffsetBasisA64Bit;
+
+            unchecked
+            {
+                for (int i = 0; i < text.Length; i++)
+                {
+                    char ch = text[i];
+                    byte b = (byte)ch;
+                    hash ^= b;
+                    hash *= fnvPrimeA64Bit;
+
+                    b = (byte)(ch >> 8);
+                    hash ^= b;
+                    hash *= fnvPrimeA64Bit;
+                }
+            }
+
+            return hash;
+        }
+
+        /// <summary>
+        /// Combines two 64 bit hashes generated by <see cref="FowlerNollVo1aHash"/> class into one.
+        /// </summary>
+        /// <param name="left">First hash value to be combined.</param>
+        /// <param name="right">Second hash value to be combined.</param>
+        /// <returns></returns>
+        public static long Combine64(long left, long right)
+        {
+            unchecked
+            {
+                return (left ^ right) * fnvPrimeA64Bit;
+            }
+        }
+    }
+}
diff --git a/src/StringTools/SpanBasedStringBuilder.cs b/src/StringTools/SpanBasedStringBuilder.cs
index 0bea471d8be..01c9c70c18c 100644
--- a/src/StringTools/SpanBasedStringBuilder.cs
+++ b/src/StringTools/SpanBasedStringBuilder.cs
@@ -154,12 +154,12 @@ public void Dispose()
         /// Appends a string.
         /// </summary>
         /// <param name="value">The string to append.</param>
-        public void Append(string value)
+        public void Append(string? value)
         {
             if (!string.IsNullOrEmpty(value))
             {
-                _spans.Add(value.AsMemory());
-                Length += value.Length;
+                _spans.Add(value!.AsMemory());
+                Length += value!.Length;
             }
         }
 
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs b/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs
new file mode 100644
index 00000000000..20542cd8ce8
--- /dev/null
+++ b/src/Tasks.UnitTests/CodeTaskFactoryEmbeddedFileInBinlogTestHelper.cs
@@ -0,0 +1,133 @@
+ï»¿// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+using System.IO;
+using System.IO.Compression;
+using Microsoft.Build.Logging;
+using Microsoft.Build.UnitTests;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Tasks.UnitTests
+{
+    internal enum FactoryType
+    {
+        CodeTaskFactory,
+        RoslynCodeTaskFactory,
+    }
+
+    internal static class CodeTaskFactoryEmbeddedFileInBinlogTestHelper
+    {
+        internal static void BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+            FactoryType factoryType,
+            string taskName,
+            string sourceContent,
+            bool buildShouldSucceed)
+        {
+            using var env = TestEnvironment.Create();
+
+            TransientTestFolder folder = env.CreateFolder(createFolder: true);
+
+            var sourceClass = env.CreateFile(folder, $"{taskName}.cs", sourceContent);
+
+            string projectFileContents = $"""
+                <Project>
+
+                  <UsingTask
+                    TaskName="{taskName}"
+                    TaskFactory="{factoryType}"
+                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
+                    <Task>
+                      <Code Type="Class" Language="cs" Source="{sourceClass.Path}">
+                      </Code>
+                    </Task>
+                  </UsingTask>
+
+                    <Target Name="SayHello">
+                        <{taskName} />
+                    </Target>
+
+                </Project>
+                """;
+
+            TransientTestFile binlog = env.ExpectFile(".binlog");
+
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+
+            Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result, out string projectDirectoryPath);
+
+            Assert.Equal(buildShouldSucceed, result);
+
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            // For unix-based systems path uses '/'
+            projectDirectoryPath = NativeMethodsShared.IsWindows ? projectDirectoryPath.Replace(":\\", "\\") : projectDirectoryPath.Replace("/", "\\");
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(
+                zE => zE.FullName.StartsWith(projectDirectoryPath) && zE.Name.EndsWith($"{taskName}-compilation-file.tmp"),
+                $"Binlog's embedded files didn't have the expected '{projectDirectoryPath}/{{guid}}-{taskName}-compilation-file.tmp'.");
+        }
+
+        internal static void BuildAndCheckForEmbeddedFileInBinlog(
+            FactoryType factoryType,
+            string taskName,
+            string taskXml,
+            bool buildShouldSucceed)
+        {
+            string projectFileContents = $"""
+                <Project>
+
+                  <UsingTask
+                    TaskName="{taskName}"
+                    TaskFactory="{factoryType}"
+                    AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
+                    {taskXml}
+                  </UsingTask>
+
+                    <Target Name="SayHello">
+                        <{taskName} />
+                    </Target>
+
+                </Project>
+                """;
+
+            using var env = TestEnvironment.Create();
+
+            TransientTestFile binlog = env.ExpectFile(".binlog");
+
+            var binaryLogger = new BinaryLogger()
+            {
+                Parameters = $"LogFile={binlog.Path}",
+                CollectProjectImports = BinaryLogger.ProjectImportsCollectionMode.ZipFile,
+            };
+
+            Helpers.BuildProjectWithNewOMAndBinaryLogger(projectFileContents, binaryLogger, out bool result, out string projectDirectory);
+
+            Assert.Equal(buildShouldSucceed, result);
+
+            string projectImportsZipPath = Path.ChangeExtension(binlog.Path, ".ProjectImports.zip");
+            using var fileStream = new FileStream(projectImportsZipPath, FileMode.Open);
+            using var zipArchive = new ZipArchive(fileStream, ZipArchiveMode.Read);
+
+            // A path like "C:\path" in ZipArchive is saved as "C\path"
+            // For unix-based systems path uses '/'
+            projectDirectory = NativeMethodsShared.IsWindows ? projectDirectory.Replace(":\\", "\\") : projectDirectory.Replace("/", "\\");
+
+            // Can't just compare `Name` because `ZipArchive` does not handle unix directory separators well
+            // thus producing garbled fully qualified paths in the actual .ProjectImports.zip entries
+            zipArchive.Entries.ShouldContain(
+                zE => zE.FullName.StartsWith(projectDirectory) && zE.Name.EndsWith($"{taskName}-compilation-file.tmp"),
+                $"Binlog's embedded files didn't have the expected '{projectDirectory}/{{guid}}-{taskName}-compilation-file.tmp'.");
+        }
+    }
+}
diff --git a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
index f6d0b3a01ed..784e05d8bae 100644
--- a/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
+++ b/src/Tasks.UnitTests/CodeTaskFactoryTests.cs
@@ -16,6 +16,7 @@ namespace Microsoft.Build.UnitTests
 #if FEATURE_CODETASKFACTORY
 
     using System.CodeDom.Compiler;
+    using Microsoft.Build.Tasks.UnitTests;
 
     public sealed class CodeTaskFactoryTests
     {
@@ -1120,6 +1121,81 @@ public void RedundantMSBuildReferences()
             MockLogger mockLogger = Helpers.BuildProjectWithNewOMExpectSuccess(projectFileContents);
             mockLogger.AssertLogContains("Hello, World!");
         }
+
+        [Fact]
+        public void EmbedsGeneratedFromSourceFileInBinlog()
+        {
+            string taskName = "HelloTask";
+
+            string sourceContent = $$"""
+                namespace InlineTask
+                {
+                    using Microsoft.Build.Utilities;
+
+                    public class {{taskName}} : Task
+                    {
+                        public override bool Execute()
+                        {
+                            Log.LogMessage("Hello, world!");
+                            return !Log.HasLoggedErrors;
+                        }
+                    }
+                }
+                """;
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, taskName, sourceContent, true);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFromSourceFileInBinlogWhenFailsToCompile()
+        {
+            string taskName = "HelloTask";
+
+            string sourceContent =  $$"""
+                namespace InlineTask
+                {
+                    using Microsoft.Build.Utilities;
+
+                    public class {{taskName}} : Task
+                    {
+                """;
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, taskName, sourceContent, false);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFileInBinlog()
+        {
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!"");
+                		   ]]>
+                    </Code>
+                </Task>";
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, "HelloTask", taskXml, true);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFileInBinlogWhenFailsToCompile()
+        {
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!
+                		   ]]>
+                    </Code>
+                </Task>";
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.CodeTaskFactory, "HelloTask", taskXml, false);
+        }
     }
 #else
     public sealed class CodeTaskFactoryTests
diff --git a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
index 967dfe65a42..0a142052398 100644
--- a/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
+++ b/src/Tasks.UnitTests/RoslynCodeTaskFactory_Tests.cs
@@ -644,6 +644,81 @@ public override bool Execute()
             }
         }
 
+        [Fact]
+        public void EmbedsGeneratedFromSourceFileInBinlog()
+        {
+            string taskName = "HelloTask";
+
+            string sourceContent = $$"""
+                namespace InlineTask
+                {
+                    using Microsoft.Build.Utilities;
+
+                    public class {{taskName}} : Task
+                    {
+                        public override bool Execute()
+                        {
+                            Log.LogMessage("Hello, world!");
+                            return !Log.HasLoggedErrors;
+                        }
+                    }
+                }
+                """;
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, taskName, sourceContent, true);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFromSourceFileInBinlogWhenFailsToCompile()
+        {
+            string taskName = "HelloTask";
+
+            string sourceContent =  $$"""
+                namespace InlineTask
+                {
+                    using Microsoft.Build.Utilities;
+
+                    public class {{taskName}} : Task
+                    {
+                """;
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildFromSourceAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, taskName, sourceContent, false);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFileInBinlog()
+        {
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!"");
+                		   ]]>
+                    </Code>
+                </Task>";
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, "HelloTask", taskXml, true);
+        }
+
+        [Fact]
+        public void EmbedsGeneratedFileInBinlogWhenFailsToCompile()
+        {
+            string taskXml = @"
+                <Task>
+                    <Code Type=""Fragment"" Language=""cs"">
+                        <![CDATA[
+                              Log.LogMessage(""Hello, World!
+                		   ]]>
+                    </Code>
+                </Task>";
+
+            CodeTaskFactoryEmbeddedFileInBinlogTestHelper.BuildAndCheckForEmbeddedFileInBinlog(
+                FactoryType.RoslynCodeTaskFactory, "HelloTask", taskXml, false);
+        }
+
 #if !FEATURE_RUN_EXE_IN_TESTS
         [Fact]
         public void RoslynCodeTaskFactory_UsingAPI()
diff --git a/src/Tasks/CodeTaskFactory.cs b/src/Tasks/CodeTaskFactory.cs
index 73eb0403611..f863c969cbf 100644
--- a/src/Tasks/CodeTaskFactory.cs
+++ b/src/Tasks/CodeTaskFactory.cs
@@ -791,6 +791,10 @@ private Assembly CompileInMemoryAssembly()
                 // Our code generation is complete, grab the source from the builder ready for compilation
                 string fullCode = codeBuilder.ToString();
 
+                // Embed generated file in the binlog
+                string fileNameInBinlog = $"{Guid.NewGuid()}-{_nameOfTask}-compilation-file.tmp";
+                _log.LogIncludeGeneratedFile(fileNameInBinlog, fullCode);
+
                 var fullSpec = new FullTaskSpecification(finalReferencedAssemblies, fullCode);
                 if (!s_compiledTaskCache.TryGetValue(fullSpec, out Assembly existingAssembly))
                 {
diff --git a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
index 63d7fd5b8ae..7989a98917a 100644
--- a/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
+++ b/src/Tasks/RoslynCodeTaskFactory/RoslynCodeTaskFactory.cs
@@ -685,6 +685,10 @@ private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTask
 
             try
             {
+                // Embed generated file in the binlog
+                string fileNameInBinlog = $"{Guid.NewGuid()}-{_taskName}-compilation-file.tmp";
+                _log.LogIncludeGeneratedFile(fileNameInBinlog, taskInfo.SourceCode);
+
                 // Create the code
                 File.WriteAllText(sourceCodePath, taskInfo.SourceCode);
 
diff --git a/src/UnitTests.Shared/ObjectModelHelpers.cs b/src/UnitTests.Shared/ObjectModelHelpers.cs
index a7609b3a908..ce51be22785 100644
--- a/src/UnitTests.Shared/ObjectModelHelpers.cs
+++ b/src/UnitTests.Shared/ObjectModelHelpers.cs
@@ -1359,6 +1359,20 @@ private static void BuildProjectWithNewOM(string content, ref MockLogger logger,
             result = project.Build(loggers);
         }
 
+        public static void BuildProjectWithNewOMAndBinaryLogger(string content, BinaryLogger binaryLogger, out bool result, out string projectDirectory)
+        {
+            // Replace the nonstandard quotes with real ones
+            content = ObjectModelHelpers.CleanupFileContents(content);
+
+            Project project = new Project(XmlReader.Create(new StringReader(content)), null, toolsVersion: null);
+
+            List<ILogger> loggers = new List<ILogger>() { binaryLogger };
+
+            result = project.Build(loggers);
+
+            projectDirectory = project.DirectoryPath;
+        }
+
         public static MockLogger BuildProjectContentUsingBuildManagerExpectResult(string content, BuildResultCode expectedResult)
         {
             var logger = new MockLogger();
diff --git a/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json b/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
new file mode 100644
index 00000000000..071723c97cc
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/.template.config/template.json
@@ -0,0 +1,49 @@
+{
+    "$schema": "http://json.schemastore.org/template",
+    "author": "Microsoft",
+    "classifications": [
+      "Common",
+      "Library"
+    ],
+    "name": "MSBuild custom analyzer skeleton project.",
+    "generatorVersions": "[1.0.0.0-*)",
+    "description": "A project for creating a MSBuild analyzer library that targets .NET Standard",
+    "groupIdentity": "Microsoft.AnalyzerTemplate",
+    "identity": "Microsoft.AnalyzerTemplate",
+    "shortName": "msbuildanalyzer",
+    "tags": {
+      "language": "C#",
+      "type": "project"
+    },
+    "sourceName": "Company.AnalyzerTemplate",
+    "preferNameDirectory": true,
+    "primaryOutputs": [
+      {
+        "path": "Company.AnalyzerTemplate.csproj"
+      }
+   ],
+   "symbols": {
+    "MicrosoftBuildVersion": {
+      "type": "parameter",
+      "description": "Overrides the default Microsoft.Build version where analyzer's interfaces are placed",
+      "datatype": "text",
+      "defaultValue": "17.9.5",
+      "replaces": "1.0.0-MicrosoftBuildPackageVersion",
+      "displayName": "Microsoft.Build default package version override"
+    }
+   },
+    "postActions": [
+      {
+        "id": "restore",
+        "condition": "(!skipRestore)",
+        "description": "Restore NuGet packages required by this project.",
+        "manualInstructions": [
+          {
+            "text": "Run 'dotnet restore'"
+          }
+        ],
+        "actionId": "210D431B-A78B-4D2F-B762-4ED3E3EA9025",
+        "continueOnError": true
+      }
+    ]
+  }
\ No newline at end of file
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs b/template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs
new file mode 100644
index 00000000000..e6d225f21dd
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/Analyzer1.cs
@@ -0,0 +1,34 @@
+ï»¿using System;
+
+namespace Company.AnalyzerTemplate
+{
+    public sealed class Analyzer1 : BuildAnalyzer
+    {
+        public static BuildAnalyzerRule SupportedRule = new BuildAnalyzerRule("X01234", "Title",
+            "Description", "Category",
+            "Message format: {0}",
+            new BuildAnalyzerConfiguration() { Severity = BuildAnalyzerResultSeverity.Warning, IsEnabled = true });
+
+        public override string FriendlyName => "Company.Analyzer1";
+
+        public override IReadOnlyList<BuildAnalyzerRule> SupportedRules { get; } =[SupportedRule];
+
+        public override void Initialize(ConfigurationContext configurationContext)
+        {
+            // configurationContext to be used only if analyzer needs external configuration data.
+        }
+
+        public override void RegisterActions(IBuildCopRegistrationContext registrationContext)
+        {
+            registrationContext.RegisterEvaluatedPropertiesAction(EvaluatedPropertiesAction);
+        }
+        
+        private void EvaluatedPropertiesAction(BuildCopDataContext<EvaluatedPropertiesAnalysisData> context)
+        {
+            context.ReportResult(BuildCopResult.Create(
+                SupportedRule,
+                ElementLocation.EmptyLocation,
+                "Argument for the message format");
+        }
+    }
+}
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj b/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
new file mode 100644
index 00000000000..6de9fb1f434
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/Company.AnalyzerTemplate.csproj
@@ -0,0 +1,45 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+  <PropertyGroup>
+	  <TargetFramework>netstandard2.0</TargetFramework>
+	  <DevelopmentDependency>true</DevelopmentDependency>
+	  <IncludeBuildOutput>false</IncludeBuildOutput>
+	  <GeneratePackageOnBuild>True</GeneratePackageOnBuild>
+	  <!-- The output structure was modified for msbuild develomplent needs.-->
+    <NoWarn>NU5101;NU5128</NoWarn>
+  </PropertyGroup>
+
+  <ItemGroup>
+	  <None Include="Directory.Build.props" Pack="true" PackagePath="build\Directory.Build.props" />
+	  <Content Include="README.md" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <!-- Please add IncludeInPackage field to all third party dependencies. See the example below.-->
+    <PackageReference Include="Microsoft.Build" PrivateAssets="all" IncludeInPackage="true" />
+  </ItemGroup>
+
+  <Target Name="AddNuGetDlls" BeforeTargets="_GetPackageFiles">
+	<!-- Merge the collection of PackageReference and Assemblies using the NuGetPackageId key.
+       This produces a new list containing the DLL path and the "IncludeInPackage" metadata-->
+	<JoinItems Left="@(ResolvedCompileFileDefinitions)" LeftKey="NuGetPackageId" LeftMetadata="*" Right="@(PackageReference)" RightKey="" RightMetadata="*" ItemSpecToUse="Left">
+		<Output TaskParameter="JoinResult" ItemName="_PackagesToPack" />
+	</JoinItems>
+
+	<ItemGroup>
+		<!-- Remove NETStandard DLLs -->
+		<_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(NuGetPackageId) == 'NETStandard.Library'" />
+		<_PackagesToPack Remove="@(_PackagesToPack)" Condition="%(_PackagesToPack.IncludeInPackage) != 'true'" />
+	</ItemGroup>
+
+	<Message Importance="High" Text="Adding DLLs from the following packages: @(_PackagesToPack->'%(NuGetPackageId)')" />
+
+	<ItemGroup>
+		<!-- Update the collection of items to pack with the DLLs from the NuGet packages -->
+		<None Include="@(_PackagesToPack)" Pack="true" PackagePath="lib" Visible="false" />
+
+		<!-- Add the DLL produced by the current project to the NuGet package -->
+		<None Include="$(OutputPath)\$(AssemblyName).dll" Pack="true" PackagePath="lib" Visible="false" />
+	</ItemGroup>
+</Target>
+</Project>
diff --git a/template_feed/Microsoft.AnalyzerTemplate/Directory.Build.props b/template_feed/Microsoft.AnalyzerTemplate/Directory.Build.props
new file mode 100644
index 00000000000..8de4380640c
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/Directory.Build.props
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+	  <MSBuildAnalyzer>$([MSBuild]::RegisterAnalyzer($(MSBuildThisFileDirectory)..\lib\Company.AnalyzerTemplate.dll))</MSBuildAnalyzer>
+  </PropertyGroup>
+  <ItemGroup>
+    <PackageVersion Include="Microsoft.Build" Version="1.0.0-MicrosoftBuildPackageVersion" />
+  </ItemGroup>
+</Project>
diff --git a/template_feed/Microsoft.AnalyzerTemplate/README.md b/template_feed/Microsoft.AnalyzerTemplate/README.md
new file mode 100644
index 00000000000..4f29145e7f0
--- /dev/null
+++ b/template_feed/Microsoft.AnalyzerTemplate/README.md
@@ -0,0 +1,21 @@
+# MSBuild Custom Analyzer Template
+
+## Overview
+MSBuild Custom Analyzer Template is a .NET template designed to streamline the creation of MSBuild analyzer libraries. This template facilitates the development of custom analyzers targeting .NET Standard, enabling developers to inspect and enforce conventions, standards, or patterns within their MSBuild builds.
+
+## Features
+- Simplified template for creating MSBuild analyzer libraries.
+- Targeting .NET Standard for cross-platform compatibility.
+- Provides a starting point for implementing custom analysis rules.
+
+## Getting Started
+To use the MSBuild Custom Analyzer Template, follow these steps:
+1. Install the template using the following command:
+   ```bash
+   dotnet new install msbuildanalyzer
+2. Instantiate a custom template:
+   ```bash
+   dotnet new msbuildanalyzer -n <ProjectName>
+
+### Prerequisites
+- .NET SDK installed on your machine.
\ No newline at end of file
