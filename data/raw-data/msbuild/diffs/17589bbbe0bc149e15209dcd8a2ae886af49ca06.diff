diff --git a/.editorconfig b/.editorconfig
index 2927cad5369..6330961d5d0 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -1,4 +1,4 @@
-﻿# editorconfig.org
+﻿﻿﻿# editorconfig.org
 
 # top-most EditorConfig file
 root = true
@@ -298,6 +298,12 @@ dotnet_diagnostic.IDE0048.severity = suggestion
 # Member name can be simplified
 dotnet_diagnostic.IDE0049.severity = suggestion
 
+# Remove unused private member
+dotnet_diagnostic.IDE0051.severity = suggestion
+
+# Remove unread private member
+dotnet_diagnostic.IDE0052.severity = suggestion
+
 # Use compound assignment
 dotnet_diagnostic.IDE0054.severity = suggestion
 
@@ -428,6 +434,9 @@ dotnet_diagnostic.IDE0073.severity = error
 # Use 'System.Threading.Lock'
 dotnet_diagnostic.IDE0330.severity = suggestion
 
+# Use implicitly typed lambda
+dotnet_diagnostic.IDE0350.severity = suggestion
+
 # Value types are incompatible with null values. https://xunit.net/xunit.analyzers/rules/xUnit1012
 dotnet_diagnostic.xUnit1012.severity = warning
 
@@ -447,4 +456,4 @@ dotnet_diagnostic.xUnit1031.severity = none
 # However to fix the warning for collections with 1 elements we should use Assert.Single() instead of Assert.Equal(1, collection.Count)
 # The latter brings incosistency in the codebase and some times in one test case.
 # So we are disabling this rule with respect to the above mentioned reasons.
-dotnet_diagnostic.xUnit2013.severity = none
+dotnet_diagnostic.xUnit2013.severity = none
\ No newline at end of file
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index 35bf1f4cc3a..60cdae216b6 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -1725,7 +1725,7 @@ public void CancelledBuildWithDelay40_WithThreatSwap()
         /// A canceled build which waits for the task to get started before canceling.  Because it is a 12.0 task, we should
         /// cancel the task and exit out after a short period wherein we wait for the task to exit cleanly.
         /// </summary>
-        [Fact]
+        [WindowsFullFrameworkOnlyFact]
         public void CancelledBuildInTaskHostWithDelay40()
         {
             string contents = CleanupFileContents(@$"
@@ -4384,7 +4384,7 @@ public override bool Execute()
             }
         }
 
-        [Theory]
+        [WindowsFullFrameworkOnlyTheory]
         [InlineData("", false)] // regular task host, input logging disabled
         [InlineData("", true)] // regular task host, input logging enabled
         [InlineData("TaskHostFactory", false)] // OOP task host, input logging disabled
diff --git a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
index 959142d4a67..68b8b63ea32 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostConfiguration_Tests.cs
@@ -38,6 +38,7 @@ public void ConstructorWithNullName()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
+                    runtime: "TaskHost",
                     nodeId: 1,
                     startupDirectory: Directory.GetCurrentDirectory(),
                     buildProcessEnvironment: null,
@@ -73,6 +74,7 @@ public void ConstructorWithEmptyName()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
+                    runtime: "TaskHost",
                     nodeId: 1,
                     startupDirectory: Directory.GetCurrentDirectory(),
                     buildProcessEnvironment: null,
@@ -108,6 +110,7 @@ public void ConstructorWithNullLocation()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
+                    runtime: "TaskHost",
                     nodeId: 1,
                     startupDirectory: Directory.GetCurrentDirectory(),
                     buildProcessEnvironment: null,
@@ -145,6 +148,7 @@ public void ConstructorWithEmptyLocation()
             Assert.Throws<InternalErrorException>(() =>
             {
                 TaskHostConfiguration config = new TaskHostConfiguration(
+                    runtime: "TaskHost",
                     nodeId: 1,
                     startupDirectory: Directory.GetCurrentDirectory(),
                     buildProcessEnvironment: null,
@@ -180,6 +184,7 @@ public void ConstructorWithEmptyLocation()
         public void TestValidConstructors()
         {
             TaskHostConfiguration config = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -206,6 +211,7 @@ public void TestValidConstructors()
                 warningsAsMessages: null);
 
             TaskHostConfiguration config2 = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -233,6 +239,7 @@ public void TestValidConstructors()
 
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             TaskHostConfiguration config3 = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -265,6 +272,7 @@ public void TestValidConstructors()
             parameters2.Add("ItemArray", new ITaskItem[] { new TaskItem("DEF"), new TaskItem("GHI"), new TaskItem("JKL") });
 
             TaskHostConfiguration config4 = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -297,6 +305,7 @@ public void TestValidConstructors()
             WarningsAsErrors.Add("MSB1237");
 
             TaskHostConfiguration config5 = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -336,6 +345,7 @@ public void TestTranslationWithNullDictionary()
             };
 
             TaskHostConfiguration config = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -387,6 +397,7 @@ public void TestTranslationWithAppDomainSetup(byte[] configBytes)
             AppDomainSetup setup = new AppDomainSetup();
 
             TaskHostConfiguration config = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -433,6 +444,7 @@ public void TestTranslationWithAppDomainSetup(byte[] configBytes)
         public void TestTranslationWithEmptyDictionary()
         {
             TaskHostConfiguration config = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -484,6 +496,7 @@ public void TestTranslationWithValueTypesInDictionary()
             parameters.Add("Text", "Foo");
             parameters.Add("BoolValue", false);
             TaskHostConfiguration config = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -533,6 +546,7 @@ public void TestTranslationWithITaskItemInDictionary()
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemValue", new TaskItem("Foo"));
             TaskHostConfiguration config = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -581,6 +595,7 @@ public void TestTranslationWithITaskItemArrayInDictionary()
             IDictionary<string, object> parameters = new Dictionary<string, object>();
             parameters.Add("TaskItemArrayValue", new ITaskItem[] { new TaskItem("Foo"), new TaskItem("Baz") });
             TaskHostConfiguration config = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -636,6 +651,7 @@ public void TestTranslationWithWarningsAsErrors()
             WarningsAsErrors.Add("MSB1236");
             WarningsAsErrors.Add("MSB1237");
             TaskHostConfiguration config = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
@@ -686,6 +702,7 @@ public void TestTranslationWithWarningsAsMessages()
             WarningsAsMessages.Add("MSB1236");
             WarningsAsMessages.Add("MSB1237");
             TaskHostConfiguration config = new TaskHostConfiguration(
+                runtime: "TaskHost",
                 nodeId: 1,
                 startupDirectory: Directory.GetCurrentDirectory(),
                 buildProcessEnvironment: null,
diff --git a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
index 401b0f9ea49..d262cc75191 100644
--- a/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskHostFactory_Tests.cs
@@ -4,11 +4,13 @@
 using System;
 using System.Diagnostics;
 using System.Globalization;
+using System.IO;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.UnitTests;
 using Microsoft.Build.UnitTests.BackEnd;
-
+using Microsoft.Build.UnitTests.Shared;
+using Microsoft.VisualStudio.TestPlatform.Utilities;
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -21,12 +23,9 @@ public sealed class TaskHostFactory_Tests
     {
         private ITestOutputHelper _output;
 
-        public TaskHostFactory_Tests(ITestOutputHelper testOutputHelper)
-        {
-            _output = testOutputHelper;
-        }
+        public TaskHostFactory_Tests(ITestOutputHelper testOutputHelper) => _output = testOutputHelper;
 
-        [Fact]
+        [WindowsFullFrameworkOnlyFact]
         public void TaskNodesDieAfterBuild()
         {
             using (TestEnvironment env = TestEnvironment.Create())
@@ -40,6 +39,7 @@ public void TaskNodesDieAfterBuild()
         </ProcessIdTask>
     </Target>
 </Project>";
+
                 TransientTestFile project = env.CreateFile("testProject.csproj", pidTaskProject);
                 ProjectInstance projectInstance = new(project.Path);
                 projectInstance.Build().ShouldBeTrue();
@@ -60,7 +60,7 @@ public void TaskNodesDieAfterBuild()
             }
         }
 
-        [Fact]
+        [WindowsFullFrameworkOnlyFact]
         private void VariousParameterTypesCanBeTransmittedToAndReceivedFromTaskHost()
         {
             using TestEnvironment env = TestEnvironment.Create(_output);
diff --git a/src/Build.UnitTests/EscapingInProjects_Tests.cs b/src/Build.UnitTests/EscapingInProjects_Tests.cs
index 2f2931fc8e3..b93109c592b 100644
--- a/src/Build.UnitTests/EscapingInProjects_Tests.cs
+++ b/src/Build.UnitTests/EscapingInProjects_Tests.cs
@@ -106,7 +106,7 @@ public void SemicolonInPropertyPassedIntoStringParam()
         /// Make sure I can define a property with escaped characters and pass it into
         /// a string parameter of a task, in this case the Message task.
         /// </summary>
-        [Fact]
+        [WindowsFullFrameworkOnlyFact]
         public void SemicolonInPropertyPassedIntoStringParam_UsingTaskHost()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
@@ -603,7 +603,7 @@ public void ItemTransformContainingSemicolon()
         /// Do an item transform, where the transform expression contains an unescaped semicolon as well
         /// as an escaped percent sign.
         /// </summary>
-        [Fact]
+        [WindowsFullFrameworkOnlyFact]
         public void ItemTransformContainingSemicolon_InTaskHost()
         {
             MockLogger logger = Helpers.BuildProjectWithNewOMExpectSuccess(@"
@@ -730,7 +730,7 @@ public void EscapedWildcardsShouldNotBeExpanded()
         /// If %2A (escaped '*') or %3F (escaped '?') is in an item's Include, it should be treated
         /// literally, not as a wildcard
         /// </summary>
-        [Fact]
+        [WindowsFullFrameworkOnlyFact]
         public void EscapedWildcardsShouldNotBeExpanded_InTaskHost()
         {
             MockLogger logger = new();
diff --git a/src/Build.UnitTests/Instance/TaskItem_Tests.cs b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
index af1e84b2397..5d9d08a80ed 100644
--- a/src/Build.UnitTests/Instance/TaskItem_Tests.cs
+++ b/src/Build.UnitTests/Instance/TaskItem_Tests.cs
@@ -288,7 +288,7 @@ public void Escaping1()
         /// <summary>
         /// Flushing an item through a task run in the task host also should not mess up special characters on the metadata.
         /// </summary>
-        [Fact]
+        [WindowsFullFrameworkOnlyFact]
         public void Escaping2()
         {
             string content = ObjectModelHelpers.CleanupFileContents(@"
@@ -342,7 +342,7 @@ public void Escaping2()
         /// <summary>
         /// Flushing an item through a task run in the task host also should not mess up the escaping of the itemspec either.
         /// </summary>
-        [Fact]
+        [WindowsFullFrameworkOnlyFact]
         public void Escaping3()
         {
             string content = ObjectModelHelpers.CleanupFileContents(@"
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
index b78001c5f3d..ecfcba8af40 100644
--- a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -213,8 +213,8 @@ private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShu
                 bool continueReading = true;
                 do
                 {
-                    // Ordering of the wait handles is important. The first signalled wait handle in the array
-                    // will be returned by WaitAny if multiple wait handles are signalled. We prefer to have the
+                    // Ordering of the wait handles is important. The first signaled wait handle in the array
+                    // will be returned by WaitAny if multiple wait handles are signaled. We prefer to have the
                     // terminate event triggered so that we cannot get into a situation where packets are being
                     // spammed to the client and it never gets an opportunity to shutdown.
                     WaitHandle[] handles =
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
index ff60a441e23..744784dc13f 100644
--- a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -38,12 +38,12 @@ public void ShutdownComponent()
         public Process Start(string msbuildLocation, string commandLineArgs, int nodeId)
         {
             // Disable MSBuild server for a child process.
-            // In case of starting msbuild server it prevents an infinite recurson. In case of starting msbuild node we also do not want this variable to be set.
+            // In case of starting msbuild server it prevents an infinite recursion. In case of starting msbuild node we also do not want this variable to be set.
             return DisableMSBuildServer(() => StartInternal(msbuildLocation, commandLineArgs));
         }
 
         /// <summary>
-        /// Creates a new MSBuild process
+        /// Creates new MSBuild or dotnet process.
         /// </summary>
         private Process StartInternal(string msbuildLocation, string commandLineArgs)
         {
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index 1064b2c709a..0d8d83d11c6 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -183,7 +183,8 @@ protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate ter
         /// <summary>
         /// Finds or creates a child processes which can act as a node.
         /// </summary>
-        protected IList<NodeContext> GetNodes(string msbuildLocation,
+        protected IList<NodeContext> GetNodes(
+            string msbuildLocation,
             string commandLineArgs,
             int nextNodeId,
             INodePacketFactory factory,
@@ -335,6 +336,7 @@ bool StartNewNode(int nodeId)
                     // Create the node process
                     INodeLauncher nodeLauncher = (INodeLauncher)_componentHost.GetComponent(BuildComponentType.NodeLauncher);
                     Process msbuildProcess = nodeLauncher.Start(msbuildLocation, commandLineArgs, nodeId);
+
                     _processesToIgnore.TryAdd(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id), default);
 
                     // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
@@ -507,11 +509,11 @@ internal static void ConnectToPipeStream(NamedPipeClientStream nodeStream, strin
             }
 #endif
 
-            int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
+            KeyValuePair<string, int>[] handshakeComponents = handshake.RetrieveHandshakeComponents();
             for (int i = 0; i < handshakeComponents.Length; i++)
             {
                 CommunicationsUtilities.Trace("Writing handshake part {0} ({1}) to pipe {2}", i, handshakeComponents[i], pipeName);
-                nodeStream.WriteIntForHandshake(handshakeComponents[i]);
+                nodeStream.WriteIntForHandshake(handshakeComponents[i].Value);
             }
 
             // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
index 95df655f7c9..1cb6b3dc791 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcTaskHost.cs
@@ -42,6 +42,11 @@ internal class NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase, INodeP
         /// </summary>
         private static string s_baseTaskHostPathArm64;
 
+        /// <summary>
+        /// Store the NET path for MSBuildTaskHost so that we don't have to keep recalculating it.
+        /// </summary>
+        private static string s_baseTaskHostPathNet;
+
         /// <summary>
         /// Store the path for the 32-bit MSBuildTaskHost so that we don't have to keep re-calculating it.
         /// </summary>
@@ -395,12 +400,9 @@ internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostConte
                 {
                     s_msbuildName = Environment.GetEnvironmentVariable("MSBUILD_EXE_NAME");
 
-                    if (s_msbuildName == null)
-                    {
-                        s_msbuildName = (hostContext & HandshakeOptions.NET) == HandshakeOptions.NET
-                            ? "MSBuild.dll"
+                    s_msbuildName ??= (hostContext & HandshakeOptions.NET) == HandshakeOptions.NET
+                            ? (NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet")
                             : "MSBuild.exe";
-                    }
                 }
 
                 return s_msbuildName;
@@ -409,26 +411,28 @@ internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostConte
 
         /// <summary>
         /// Given a TaskHostContext, return the appropriate location of the
-        /// executable (MSBuild or MSBuildTaskHost) that we wish to use, or null
-        /// if that location cannot be resolved.
+        /// executable (MSBuild, MSBuildTaskHost or dotnet) and path to MSBuild.dll if we want to use a custom one.
+        /// null is returned if executable cannot be resolved.
         /// </summary>
-        internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostContext)
+        internal static (string msbuildExecutable, string msbuildAssemblyPath) GetMSBuildLocationFromHostContext(HandshakeOptions hostContext)
         {
             string toolName = GetTaskHostNameFromHostContext(hostContext);
             string toolPath = null;
+            string msbuildAssemblyPath = null;
 
             s_baseTaskHostPath = BuildEnvironmentHelper.Instance.MSBuildToolsDirectory32;
             s_baseTaskHostPath64 = BuildEnvironmentHelper.Instance.MSBuildToolsDirectory64;
             s_baseTaskHostPathArm64 = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryArm64;
+            s_baseTaskHostPathNet = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryNET;
 
-            ErrorUtilities.VerifyThrowInternalErrorUnreachable((hostContext & HandshakeOptions.TaskHost) == HandshakeOptions.TaskHost);
+            ErrorUtilities.VerifyThrowInternalErrorUnreachable(IsHandshakeOptionEnabled(HandshakeOptions.TaskHost));
 
-            if ((hostContext & HandshakeOptions.Arm64) == HandshakeOptions.Arm64 && (hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
+            if (IsHandshakeOptionEnabled(HandshakeOptions.Arm64) && IsHandshakeOptionEnabled(HandshakeOptions.CLR2))
             {
                 // Unsupported, throw.
                 ErrorUtilities.ThrowInternalError("ARM64 CLR2 task hosts are not supported.");
             }
-            else if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64 && (hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
+            else if (IsHandshakeOptionEnabled(HandshakeOptions.X64) && IsHandshakeOptionEnabled(HandshakeOptions.CLR2))
             {
                 if (s_pathToX64Clr2 == null)
                 {
@@ -442,7 +446,7 @@ internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostCo
 
                 toolPath = s_pathToX64Clr2;
             }
-            else if ((hostContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2)
+            else if (IsHandshakeOptionEnabled(HandshakeOptions.CLR2))
             {
                 if (s_pathToX32Clr2 == null)
                 {
@@ -455,40 +459,35 @@ internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostCo
 
                 toolPath = s_pathToX32Clr2;
             }
-            else if ((hostContext & HandshakeOptions.X64) == HandshakeOptions.X64)
+            else if (IsHandshakeOptionEnabled(HandshakeOptions.X64) && !IsHandshakeOptionEnabled(HandshakeOptions.NET))
             {
-                if (s_pathToX64Clr4 == null)
-                {
-                    s_pathToX64Clr4 = s_baseTaskHostPath64;
-                }
+                s_pathToX64Clr4 ??= s_baseTaskHostPath64;
 
                 toolPath = s_pathToX64Clr4;
             }
-            else if ((hostContext & HandshakeOptions.Arm64) == HandshakeOptions.Arm64)
+            else if (IsHandshakeOptionEnabled(HandshakeOptions.Arm64))
             {
-                if (s_pathToArm64Clr4 == null)
-                {
-                    s_pathToArm64Clr4 = s_baseTaskHostPathArm64;
-                }
+                s_pathToArm64Clr4 ??= s_baseTaskHostPathArm64;
 
                 toolPath = s_pathToArm64Clr4;
             }
+            else if (IsHandshakeOptionEnabled(HandshakeOptions.NET))
+            {
+                msbuildAssemblyPath = Path.Combine(BuildEnvironmentHelper.Instance.MSBuildAssemblyDirectory, "MSBuild.dll");
+                toolPath = s_baseTaskHostPathNet;
+            }
             else
             {
-                if (s_pathToX32Clr4 == null)
-                {
-                    s_pathToX32Clr4 = s_baseTaskHostPath;
-                }
+                s_pathToX32Clr4 ??= s_baseTaskHostPath;
 
                 toolPath = s_pathToX32Clr4;
             }
 
-            if (toolName != null && toolPath != null)
-            {
-                return Path.Combine(toolPath, toolName);
-            }
+            return toolName != null && toolPath != null
+                ? (msbuildExecutable: Path.Combine(toolPath, toolName), msbuildAssemblyPath)
+                : (msbuildExecutable: null, null);
 
-            return null;
+            bool IsHandshakeOptionEnabled(HandshakeOptions option) => (hostContext & option) == option;
         }
 
         /// <summary>
@@ -546,24 +545,33 @@ internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factor
                 return false;
             }
 
-            // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we
-            // want to start up an MSBuild task host node.
-            string commandLineArgs = $" /nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority} ";
-
-            string msbuildLocation = GetMSBuildLocationFromHostContext(hostContext);
+            (string msbuildExecutable, string msbuildAssemblyLocation) = GetMSBuildLocationFromHostContext(hostContext);
 
             // we couldn't even figure out the location we're trying to launch ... just go ahead and fail.
-            if (msbuildLocation == null)
+            if (msbuildExecutable == null)
             {
                 return false;
             }
 
-            CommunicationsUtilities.Trace("For a host context of {0}, spawning executable from {1}.", hostContext.ToString(), msbuildLocation ?? "MSBuild.exe");
+            string commandLineArgs;
+            if (msbuildAssemblyLocation != null)
+            {
+                // For dotnet.exe, the dll path must come first, then -- to separate application arguments
+                commandLineArgs = $"\"{msbuildAssemblyLocation}\" -- /nodemode:2 ";
+            }
+            else
+            {
+                // Start the new process.  We pass in a node mode with a node number of 2, to indicate that we
+                // want to start up an MSBuild task host node.
+                commandLineArgs = $"/nologo /nodemode:2 /nodereuse:{ComponentHost.BuildParameters.EnableNodeReuse} /low:{ComponentHost.BuildParameters.LowPriority}";
+            }
+
+            CommunicationsUtilities.Trace("For a host context of {0}, spawning executable from {1}.", hostContext.ToString(), msbuildExecutable ?? "MSBuild.exe");
 
             // There is always one task host per host context so we always create just 1 one task host node here.
             int nodeId = (int)hostContext;
             IList<NodeContext> nodeContexts = GetNodes(
-                msbuildLocation,
+                msbuildExecutable,
                 commandLineArgs,
                 nodeId,
                 this,
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index 9523e2ea4ca..6248b2aed2e 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -337,11 +337,13 @@ public bool InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket bat
                 return false;
             }
 
-            string realTaskAssemblyLoaction = TaskInstance.GetType().Assembly.Location;
-            if (!string.IsNullOrWhiteSpace(realTaskAssemblyLoaction) &&
-                realTaskAssemblyLoaction != _taskFactoryWrapper.TaskFactoryLoadedType.Path)
+            // TODO ask why for net task host it returns false net472\MSBuild\Current\Bin\Microsoft.Build.dll instead of path to a custom task.
+            // Interestingly TaskInstance._taskType contains the correct path.
+            string realTaskAssemblyLocation = TaskInstance.GetType().Assembly.Location;
+            if (!string.IsNullOrWhiteSpace(realTaskAssemblyLocation) &&
+                realTaskAssemblyLocation != _taskFactoryWrapper.TaskFactoryLoadedType.Path)
             {
-                _taskLoggingContext.LogComment(MessageImportance.Normal, "TaskAssemblyLocationMismatch", realTaskAssemblyLoaction, _taskFactoryWrapper.TaskFactoryLoadedType.Path);
+                _taskLoggingContext.LogComment(MessageImportance.Normal, "TaskAssemblyLocationMismatch", realTaskAssemblyLocation, _taskFactoryWrapper.TaskFactoryLoadedType.Path);
             }
 
             TaskInstance.BuildEngine = _buildEngine;
diff --git a/src/Build/Evaluation/IntrinsicFunctions.cs b/src/Build/Evaluation/IntrinsicFunctions.cs
index fc86d54e613..65690f45bd8 100644
--- a/src/Build/Evaluation/IntrinsicFunctions.cs
+++ b/src/Build/Evaluation/IntrinsicFunctions.cs
@@ -507,7 +507,7 @@ internal static bool DoesTaskHostExist(string runtime, string architecture)
             parameters.Add(XMakeAttributes.architecture, architecture);
 
             HandshakeOptions desiredContext = CommunicationsUtilities.GetHandshakeOptions(taskHost: true, taskHostParameters: parameters);
-            string taskHostLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(desiredContext);
+            string taskHostLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(desiredContext).msbuildExecutable;
 
             if (taskHostLocation != null && FileUtilities.FileExistsNoThrow(taskHostLocation))
             {
diff --git a/src/Build/Instance/TaskFactories/TaskHostTask.cs b/src/Build/Instance/TaskFactories/TaskHostTask.cs
index fdb9dc2373a..a7e10a840c1 100644
--- a/src/Build/Instance/TaskFactories/TaskHostTask.cs
+++ b/src/Build/Instance/TaskFactories/TaskHostTask.cs
@@ -266,6 +266,7 @@ public bool Execute()
 
             TaskHostConfiguration hostConfiguration =
                 new TaskHostConfiguration(
+                        runtime,
                         _buildComponentHost.BuildParameters.NodeId,
                         NativeMethodsShared.GetCurrentDirectory(),
                         CommunicationsUtilities.GetEnvironmentVariables(),
@@ -581,7 +582,7 @@ private void HandleLoggedMessage(LogMessagePacket logMessagePacket)
         /// </summary>
         private void LogErrorUnableToCreateTaskHost(HandshakeOptions requiredContext, string runtime, string architecture, NodeFailedToLaunchException e)
         {
-            string msbuildLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(requiredContext) ??
+            string msbuildLocation = NodeProviderOutOfProcTaskHost.GetMSBuildLocationFromHostContext(requiredContext).msbuildExecutable ??
                 // We don't know the path -- probably we're trying to get a 64-bit assembly on a
                 // 32-bit machine.  At least give them the exe name to look for, though ...
                 ((requiredContext & HandshakeOptions.CLR2) == HandshakeOptions.CLR2 ? "MSBuildTaskHost.exe" : "MSBuild.exe");
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.Core.xsd b/src/MSBuild/MSBuild/Microsoft.Build.Core.xsd
index 25586b6c97b..28a5a819acc 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.Core.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.Core.xsd
@@ -329,7 +329,7 @@
         <xs:attribute name="Runtime" type="msb:runtime" use="optional">
           <xs:annotation>
             <xs:documentation>
-              <!-- _locID_text="UsingTaskType_Runtime" _locComment="" -->Defines the .NET runtime version of the task host that this task should be run in.  Currently supported values:  CLR2, CLR4, CurrentRuntime, and * (any).  If Runtime is not specified, either the task will be run within the MSBuild process, or the task host will be launched using the runtime of the parent MSBuild process
+              <!-- _locID_text="UsingTaskType_Runtime" _locComment="" -->Defines the .NET runtime version of the task host that this task should be run in.  Currently supported values:  CLR2, CLR4, NET, CurrentRuntime, and * (any).  If Runtime is not specified, either the task will be run within the MSBuild process, or the task host will be launched using the runtime of the parent MSBuild process
             </xs:documentation>
           </xs:annotation>
         </xs:attribute>
@@ -618,6 +618,7 @@
             <xs:enumeration value="CurrentRuntime" />
             <xs:enumeration value="CLR2" />
             <xs:enumeration value="CLR4" />
+            <xs:enumeration value="NET" />
           </xs:restriction>
         </xs:simpleType>
       </xs:union>
diff --git a/src/Shared/BuildEnvironmentHelper.cs b/src/Shared/BuildEnvironmentHelper.cs
index f93696c6aba..0b315bfd1f8 100644
--- a/src/Shared/BuildEnvironmentHelper.cs
+++ b/src/Shared/BuildEnvironmentHelper.cs
@@ -610,6 +610,8 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
 
                 MSBuildToolsDirectory32 = MSBuildToolsDirectoryRoot;
                 MSBuildToolsDirectory64 = existsCheck(potentialAmd64FromX86) ? Path.Combine(MSBuildToolsDirectoryRoot, "amd64") : CurrentMSBuildToolsDirectory;
+                MSBuildToolsDirectoryNET = Environment.GetEnvironmentVariable("MSBuildToolsDirectoryNET") ?? "";
+                MSBuildAssemblyDirectory = Environment.GetEnvironmentVariable("MSBuildAssemblyDirectory") ?? "";
 #if RUNTIME_TYPE_NETCORE
                 // Fall back to "current" for any architecture since .NET SDK doesn't
                 // support cross-arch task invocations.
@@ -662,6 +664,16 @@ NativeMethodsShared.ProcessorArchitectures.X64 or NativeMethodsShared.ProcessorA
         /// </summary>
         internal string MSBuildToolsDirectoryArm64 { get; }
 
+        /// <summary>
+        /// Path to the NET tools directory.
+        /// </summary>
+        internal string MSBuildToolsDirectoryNET { get; }
+
+        /// <summary>
+        /// Path to the MSBuild assembly.
+        /// </summary>
+        internal string MSBuildAssemblyDirectory { get; }
+
         /// <summary>
         /// Path to the Sdks folder for this MSBuild instance.
         /// </summary>
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 13d4f1bef25..94469087ee6 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -41,48 +41,50 @@ internal enum HandshakeOptions
         None = 0,
 
         /// <summary>
-        /// Process is a TaskHost
+        /// Process is a TaskHost.
         /// </summary>
         TaskHost = 1,
 
         /// <summary>
-        /// Using the 2.0 CLR
+        /// Using the 2.0 CLR.
         /// </summary>
         CLR2 = 2,
 
         /// <summary>
-        /// 64-bit Intel process
+        /// 64-bit Intel process.
         /// </summary>
         X64 = 4,
 
         /// <summary>
-        /// Node reuse enabled
+        /// Node reuse enabled.
         /// </summary>
         NodeReuse = 8,
 
         /// <summary>
-        /// Building with BelowNormal priority
+        /// Building with BelowNormal priority.
         /// </summary>
         LowPriority = 16,
 
         /// <summary>
-        /// Building with administrator privileges
+        /// Building with administrator privileges.
         /// </summary>
         Administrator = 32,
 
         /// <summary>
-        /// Using the .NET Core/.NET 5.0+ runtime
+        /// Using the .NET Core/.NET 5.0+ runtime.
         /// </summary>
         NET = 64,
 
         /// <summary>
-        /// ARM64 process
+        /// ARM64 process.
         /// </summary>
         Arm64 = 128,
     }
 
     internal class Handshake
     {
+        public static int NetTaskHostHandshakeVersion = 99;
+
         protected readonly int options;
         protected readonly int salt;
         protected readonly int fileVersionMajor;
@@ -106,15 +108,29 @@ protected Handshake(HandshakeOptions nodeType, bool includeSessionId)
             CommunicationsUtilities.Trace("Building handshake for node type {0}, (version {1}): options {2}.", nodeType, handshakeVersion, options);
 
             string handshakeSalt = Environment.GetEnvironmentVariable("MSBUILDNODEHANDSHAKESALT");
-            CommunicationsUtilities.Trace("Handshake salt is {0}", handshakeSalt);
-            string toolsDirectory = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;
+            CommunicationsUtilities.Trace("Handshake salt is " + handshakeSalt);
+            bool isNetTaskHost = (nodeType & HandshakeOptions.NET) == HandshakeOptions.NET;
+            string toolsDirectory = isNetTaskHost
+                ? BuildEnvironmentHelper.Instance.MSBuildAssemblyDirectory
+                : BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;
             CommunicationsUtilities.Trace("Tools directory root is {0}", toolsDirectory);
             salt = CommunicationsUtilities.GetHashCode($"{handshakeSalt}{toolsDirectory}");
-            Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion);
-            fileVersionMajor = fileVersion.Major;
-            fileVersionMinor = fileVersion.Minor;
-            fileVersionBuild = fileVersion.Build;
-            fileVersionPrivate = fileVersion.Revision;
+            if (isNetTaskHost)
+            {
+                // hardcode version to activate json protocol that allows to have more version flexibility
+                fileVersionMajor = NetTaskHostHandshakeVersion;
+                fileVersionMinor = NetTaskHostHandshakeVersion;
+                fileVersionBuild = NetTaskHostHandshakeVersion;
+                fileVersionPrivate = NetTaskHostHandshakeVersion;
+            }
+            else
+            {
+                Version fileVersion = new Version(FileVersionInfo.GetVersionInfo(Assembly.GetExecutingAssembly().Location).FileVersion);
+                fileVersionMajor = fileVersion.Major;
+                fileVersionMinor = fileVersion.Minor;
+                fileVersionBuild = fileVersion.Build;
+                fileVersionPrivate = fileVersion.Revision;
+            }
 
             // This reaches out to NtQuerySystemInformation. Due to latency, allow skipping for derived handshake if unused.
             if (includeSessionId)
@@ -125,24 +141,18 @@ protected Handshake(HandshakeOptions nodeType, bool includeSessionId)
         }
 
         // This is used as a key, so it does not need to be human readable.
-        public override string ToString()
-        {
-            return $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}";
-        }
-
-        public virtual int[] RetrieveHandshakeComponents()
-        {
-            return
-            [
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)
-            ];
-        }
+        public override string ToString() => String.Format("{0} {1} {2} {3} {4} {5} {6}", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);
+
+        public virtual KeyValuePair<string, int>[] RetrieveHandshakeComponents() =>
+        [
+            new KeyValuePair<string, int>(nameof(options), CommunicationsUtilities.AvoidEndOfHandshakeSignal(options)),
+            new KeyValuePair<string, int>(nameof(salt), CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt)),
+            new KeyValuePair<string, int>(nameof(fileVersionMajor), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor)),
+            new KeyValuePair<string, int>(nameof(fileVersionMinor), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor)),
+            new KeyValuePair<string, int>(nameof(fileVersionBuild), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild)),
+            new KeyValuePair<string, int>(nameof(fileVersionPrivate), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate)),
+            new KeyValuePair<string, int>(nameof(sessionId), CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId))
+        ];
 
         public virtual string GetKey() => $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}".ToString(CultureInfo.InvariantCulture);
 
@@ -163,24 +173,18 @@ internal ServerNodeHandshake(HandshakeOptions nodeType)
         {
         }
 
-        public override int[] RetrieveHandshakeComponents()
-        {
-            return
-            [
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
-                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
-            ];
-        }
+        public override KeyValuePair<string, int>[] RetrieveHandshakeComponents() =>
+        [
+            new KeyValuePair<string, int>(nameof(options), CommunicationsUtilities.AvoidEndOfHandshakeSignal(options)),
+            new KeyValuePair<string, int>(nameof(salt), CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt)),
+            new KeyValuePair<string, int>(nameof(fileVersionMajor), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor)),
+            new KeyValuePair<string, int>(nameof(fileVersionMinor), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor)),
+            new KeyValuePair<string, int>(nameof(fileVersionBuild), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild)),
+            new KeyValuePair<string, int>(nameof(fileVersionPrivate), CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate))
+        ];
 
-        public override string GetKey()
-        {
-            return $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate}"
+        public override string GetKey() => $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate}"
                 .ToString(CultureInfo.InvariantCulture);
-        }
 
         /// <summary>
         /// Computes Handshake stable hash string representing whole state of handshake.
@@ -514,6 +518,7 @@ bool isProvider
                 {
                     CommunicationsUtilities.Trace("Expected end of handshake signal but received {0}. Probably the host is a different MSBuild build.", valueRead);
                 }
+
                 throw new InvalidOperationException();
             }
         }
@@ -618,7 +623,12 @@ internal static async ValueTask<int> ReadAsync(Stream stream, byte[] buffer, int
         /// <summary>
         /// Given the appropriate information, return the equivalent HandshakeOptions.
         /// </summary>
-        internal static HandshakeOptions GetHandshakeOptions(bool taskHost, string architectureFlagToSet = null, bool nodeReuse = false, bool lowPriority = false, IDictionary<string, string> taskHostParameters = null)
+        internal static HandshakeOptions GetHandshakeOptions(
+            bool taskHost,
+            string architectureFlagToSet = null,
+            bool nodeReuse = false,
+            bool lowPriority = false,
+            IDictionary<string, string> taskHostParameters = null)
         {
             HandshakeOptions context = taskHost ? HandshakeOptions.TaskHost : HandshakeOptions.None;
 
@@ -870,7 +880,7 @@ private static void TraceCore(int nodeId, string message)
         /// they will return the same hash code.
         /// This is as implemented in CLR String.GetHashCode() [ndp\clr\src\BCL\system\String.cs]
         /// but stripped out architecture specific defines
-        /// that causes the hashcode to be different and this causes problem in cross-architecture handshaking
+        /// that causes the hashcode to be different and this causes problem in cross-architecture handshaking.
         /// </summary>
         internal static int GetHashCode(string fileVersion)
         {
@@ -901,9 +911,6 @@ internal static int GetHashCode(string fileVersion)
             }
         }
 
-        internal static int AvoidEndOfHandshakeSignal(int x)
-        {
-            return x == EndOfHandshakeSignal ? ~x : x;
-        }
+        internal static int AvoidEndOfHandshakeSignal(int x) => x == EndOfHandshakeSignal ? ~x : x;
     }
 }
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index fbaeb4dbde2..6d216eb3f76 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System;
+using System.Collections.Generic;
 using System.Diagnostics.CodeAnalysis;
 #if CLR2COMPATIBILITY
 using Microsoft.Build.Shared.Concurrent;
@@ -117,6 +118,11 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// </summary>
         private BinaryWriter _binaryWriter;
 
+        /// <summary>
+        /// The set of property names from handshake responsible for node version./>
+        /// </summary>
+        private readonly IList<string> _versionHandshakeGroup = ["fileVersionMajor", "fileVersionMinor", "fileVersionBuild", "fileVersionPrivate"];
+
         #endregion
 
         #region INodeEndpoint Events
@@ -261,7 +267,7 @@ internal void InternalConstruct(string pipeName = null)
         #endregion
 
         /// <summary>
-        /// Returns the host handshake for this node endpoint
+        /// Returns the host handshake for this node endpoint.
         /// </summary>
         protected abstract Handshake GetHandshake();
 
@@ -395,7 +401,7 @@ private void PacketPumpProc()
                     Handshake handshake = GetHandshake();
                     try
                     {
-                        int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
+                        KeyValuePair<string, int>[] handshakeComponents = handshake.RetrieveHandshakeComponents();
                         for (int i = 0; i < handshakeComponents.Length; i++)
                         {
 #pragma warning disable SA1111, SA1009 // Closing parenthesis should be on line of last parameter
@@ -407,12 +413,21 @@ private void PacketPumpProc()
                             );
 #pragma warning restore SA1111, SA1009 // Closing parenthesis should be on line of last parameter
 
-                            if (handshakePart != handshakeComponents[i])
+                            if (handshakePart != handshakeComponents[i].Value)
                             {
-                                CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshakePart, handshakeComponents[i]);
-                                _pipeServer.WriteIntForHandshake(i + 1);
-                                gotValidConnection = false;
-                                break;
+                                // NET Task host allows to connect to MSBuild.dll with the different handshake version.
+                                // We agreed to hardcode a value of 99 to bypass the protection for this scenario.
+                                if (_versionHandshakeGroup.Contains(handshakeComponents[i].Key) && handshakeComponents[i].Value == Handshake.NetTaskHostHandshakeVersion)
+                                {
+                                    CommunicationsUtilities.Trace("Handshake for NET Host. Child host {0} for {1}.", handshakePart, handshakeComponents[i].Key);
+                                }
+                                else
+                                {
+                                    CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshakePart, handshakeComponents[i]);
+                                    _pipeServer.WriteIntForHandshake(i + 1);
+                                    gotValidConnection = false;
+                                    break;
+                                }
                             }
                         }
 
@@ -515,8 +530,8 @@ private void PacketPumpProc()
         private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream localWritePipe,
             ConcurrentQueue<INodePacket> localPacketQueue, AutoResetEvent localPacketAvailable, AutoResetEvent localTerminatePacketPump)
         {
-            // Ordering of the wait handles is important.  The first signalled wait handle in the array
-            // will be returned by WaitAny if multiple wait handles are signalled.  We prefer to have the
+            // Ordering of the wait handles is important.  The first signaled wait handle in the array
+            // will be returned by WaitAny if multiple wait handles are signaled.  We prefer to have the
             // terminate event triggered so that we cannot get into a situation where packets are being
             // spammed to the endpoint and it never gets an opportunity to shutdown.
             CommunicationsUtilities.Trace("Entering read loop.");
@@ -687,8 +702,8 @@ private void RunReadLoop(BufferedReadStream localReadPipe, NamedPipeServerStream
             while (!exitLoop);
         }
 
-#endregion
+        #endregion
 
-#endregion
+        #endregion
     }
 }
diff --git a/src/Shared/NodePipeBase.cs b/src/Shared/NodePipeBase.cs
index 2ee91e536c1..190908c0841 100644
--- a/src/Shared/NodePipeBase.cs
+++ b/src/Shared/NodePipeBase.cs
@@ -7,6 +7,8 @@
 using System.Threading;
 using Microsoft.Build.BackEnd;
 using Microsoft.Build.Framework;
+using System.Collections.Generic;
+
 
 #if !TASKHOST
 using System.Buffers.Binary;
@@ -81,7 +83,7 @@ protected NodePipeBase(string pipeName, Handshake handshake)
 
         protected string PipeName { get; }
 
-        protected int[] HandshakeComponents { get; }
+        protected KeyValuePair<string, int>[] HandshakeComponents { get; }
 
         public void Dispose()
         {
diff --git a/src/Shared/NodePipeClient.cs b/src/Shared/NodePipeClient.cs
index a521f4f34d2..9474327236d 100644
--- a/src/Shared/NodePipeClient.cs
+++ b/src/Shared/NodePipeClient.cs
@@ -77,7 +77,7 @@ private void PerformHandshake(int timeout)
             for (int i = 0; i < HandshakeComponents.Length; i++)
             {
                 CommunicationsUtilities.Trace("Writing handshake part {0} ({1}) to pipe {2}", i, HandshakeComponents[i], PipeName);
-                _pipeClient.WriteIntForHandshake(HandshakeComponents[i]);
+                _pipeClient.WriteIntForHandshake(HandshakeComponents[i].Value);
             }
 
             // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.
diff --git a/src/Shared/NodePipeServer.cs b/src/Shared/NodePipeServer.cs
index 0b9855f2a1c..f5117575a07 100644
--- a/src/Shared/NodePipeServer.cs
+++ b/src/Shared/NodePipeServer.cs
@@ -194,7 +194,7 @@ private bool ValidateHandshake()
                 int handshakePart = _pipeServer.ReadIntForHandshake(byteToAccept: i == 0 ? CommunicationsUtilities.handshakeVersion : null);
 #endif
 
-                if (handshakePart != HandshakeComponents[i])
+                if (handshakePart != HandshakeComponents[i].Value)
                 {
                     CommunicationsUtilities.Trace("Handshake failed. Received {0} from host not {1}. Probably the host is a different MSBuild build.", handshakePart, HandshakeComponents[i]);
                     _pipeServer.WriteIntForHandshake(i + 1);
diff --git a/src/Shared/TaskHostConfiguration.cs b/src/Shared/TaskHostConfiguration.cs
index df56c4efc53..b5b34a6502f 100644
--- a/src/Shared/TaskHostConfiguration.cs
+++ b/src/Shared/TaskHostConfiguration.cs
@@ -42,6 +42,11 @@ internal class TaskHostConfiguration : INodePacket
         /// </summary>
         private CultureInfo _uiCulture = CultureInfo.CurrentUICulture;
 
+        /// <summary>
+        /// Task host runtime.
+        /// </summary>
+        private string _runtime;
+
 #if FEATURE_APPDOMAIN
         /// <summary>
         /// The AppDomainSetup that we may want to use on AppDomainIsolated tasks.
@@ -98,8 +103,9 @@ internal class TaskHostConfiguration : INodePacket
 
 #if FEATURE_APPDOMAIN
         /// <summary>
-        /// Constructor
+        /// Constructor.
         /// </summary>
+        /// <param name="runtime">Task host runtime.</param>
         /// <param name="nodeId">The ID of the node being configured.</param>
         /// <param name="startupDirectory">The startup directory for the task being executed.</param>
         /// <param name="buildProcessEnvironment">The set of environment variables to apply to the task execution process.</param>
@@ -120,8 +126,9 @@ internal class TaskHostConfiguration : INodePacket
         /// <param name="warningsAsMessages">Warning codes to be treated as messages for the current project.</param>
 #else
         /// <summary>
-        /// Constructor
+        /// Constructor.
         /// </summary>
+        /// <param name="runtime">Task host runtime.</param>
         /// <param name="nodeId">The ID of the node being configured.</param>
         /// <param name="startupDirectory">The startup directory for the task being executed.</param>
         /// <param name="buildProcessEnvironment">The set of environment variables to apply to the task execution process.</param>
@@ -141,6 +148,7 @@ internal class TaskHostConfiguration : INodePacket
         /// <param name="warningsAsMessages">Warning codes to be treated as messages for the current project.</param>
 #endif
         public TaskHostConfiguration(
+                string runtime,
                 int nodeId,
                 string startupDirectory,
                 IDictionary<string, string> buildProcessEnvironment,
@@ -178,6 +186,7 @@ public TaskHostConfiguration(
                 }
             }
 
+            _runtime = runtime;
             _culture = culture;
             _uiCulture = uiCulture;
 #if FEATURE_APPDOMAIN
@@ -416,20 +425,27 @@ public void Translate(ITranslator translator)
             translator.TranslateCulture(ref _culture);
             translator.TranslateCulture(ref _uiCulture);
 #if FEATURE_APPDOMAIN
-            byte[] appDomainConfigBytes = null;
 
-            // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
-            if (translator.Mode == TranslationDirection.WriteToStream)
+            // Skip AppDomain configuration when targeting .NET Task Host (Runtime="Net").
+            // Although MSBuild.exe runs under .NET Framework and has AppDomain support,
+            // we don't transmit AppDomain config when communicating with dotnet.exe (it is not supported in .NET 5+).
+            if (!StringComparer.OrdinalIgnoreCase.Equals(_runtime, XMakeAttributes.MSBuildRuntimeValues.net))
             {
-                appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
-            }
+                byte[] appDomainConfigBytes = null;
+
+                // Set the configuration bytes just before serialization in case the SetConfigurationBytes was invoked during lifetime of this instance.
+                if (translator.Mode == TranslationDirection.WriteToStream)
+                {
+                    appDomainConfigBytes = _appDomainSetup?.GetConfigurationBytes();
+                }
 
-            translator.Translate(ref appDomainConfigBytes);
+                translator.Translate(ref appDomainConfigBytes);
 
-            if (translator.Mode == TranslationDirection.ReadFromStream)
-            {
-                _appDomainSetup = new AppDomainSetup();
-                _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
+                if (translator.Mode == TranslationDirection.ReadFromStream)
+                {
+                    _appDomainSetup = new AppDomainSetup();
+                    _appDomainSetup.SetConfigurationBytes(appDomainConfigBytes);
+                }
             }
 #endif
             translator.Translate(ref _lineNumberOfTask);
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index a6ebead50e0..3bde8d046c0 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -20,6 +20,7 @@ public static class RunnerUtilities
         public static ArtifactsLocationAttribute ArtifactsLocationAttribute = Assembly.GetExecutingAssembly().GetCustomAttribute<ArtifactsLocationAttribute>()
                                                    ?? throw new InvalidOperationException("This test assembly does not have the ArtifactsLocationAttribute");
 
+
         internal static BootstrapLocationAttribute BootstrapLocationAttribute = Assembly.GetExecutingAssembly().GetCustomAttribute<BootstrapLocationAttribute>()
                                                    ?? throw new InvalidOperationException("This test assembly does not have the BootstrapLocationAttribute");
         public static string BootstrapMsBuildBinaryLocation => BootstrapLocationAttribute.BootstrapMsBuildBinaryLocation;
