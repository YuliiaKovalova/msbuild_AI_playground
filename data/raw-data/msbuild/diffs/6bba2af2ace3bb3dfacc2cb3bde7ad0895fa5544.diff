diff --git a/README.md b/README.md
index d96c05bcda0..343c9d9c866 100644
--- a/README.md
+++ b/README.md
@@ -8,11 +8,15 @@ The [changelog](documentation/Changelog.md) has detailed information about chang
 
 ### Build Status
 
-The current development branch is `main`. Changes in `main` will go into a future update of MSBuild, which will release with Visual Studio 17.2 and a corresponding version of the .NET Core SDK.
+The current development branch is `main`. Changes in `main` will go into a future update of MSBuild, which will release with Visual Studio 17.4 and a corresponding version of the .NET Core SDK.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=main)
 
-We have forked for MSBuild 17.2 in the branch [`vs17.2`](https://github.com/Microsoft/msbuild/tree/vs17.2). Changes to that branch need special approval.
+We have forked for MSBuild 17.3 in the branch [`vs17.3`](https://github.com/Microsoft/msbuild/tree/vs17.3). Changes to that branch need special approval.
+
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.3)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.3)
+
+17.2 builds from the branch [`vs17.2`](https://github.com/Microsoft/msbuild/tree/vs17.2). Only high-priority bugfixes will be considered for servicing 17.2.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.2)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.2)
 
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 664a32ac397..dcd1abc5b09 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -11,6 +11,7 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 | Build | Sets up a BuildManager to receive build requests. |
 | BuildProject | Builds a project file. |
 | CachedSdkResolverServiceResolveSdk | The caching SDK resolver service is resolving an SDK. |
+| CreateLoadedType | Creates a LoadedType object from an assembly loaded via MetadataLoadContext. |
 | CopyUpToDate | Checks whether the Copy task needs to execute. |
 | Evaluate | Evaluates a project, running several other parts of MSBuild in the process. |
 | EvaluateCondition | Checks whether a condition is true and removes false conditionals. |
diff --git a/eng/Packages.props b/eng/Packages.props
index 6511b043564..b189ed67979 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -21,6 +21,7 @@
     <PackageReference Update="System.Net.Http" Version="4.3.4" />
     <PackageReference Update="System.Memory" Version="4.5.5" />
     <PackageReference Update="System.Reflection.Metadata" Version="6.0.0" />
+    <PackageReference Update="System.Reflection.MetadataLoadContext" Version="6.0.0" />
     <PackageReference Update="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
     <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
     <PackageReference Update="System.Security.Permissions" Version="6.0.0" />
diff --git a/eng/Versions.props b/eng/Versions.props
index c47015583c7..301d24fe4bd 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,7 +2,7 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.3.0</VersionPrefix>
+    <VersionPrefix>17.4.0</VersionPrefix>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
diff --git a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
index ffd6ed0068e..a7ffe38e44f 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
@@ -220,7 +220,7 @@ public void CreatableByTaskFactoryMismatchedIdentity()
         public void VerifyGetTaskParameters()
         {
             TaskPropertyInfo[] propertyInfos = _taskFactory.GetTaskParameters();
-            LoadedType comparisonType = new LoadedType(typeof(TaskToTestFactories), _loadInfo);
+            LoadedType comparisonType = new LoadedType(typeof(TaskToTestFactories), _loadInfo, typeof(TaskToTestFactories).GetTypeInfo().Assembly);
             PropertyInfo[] comparisonInfo = comparisonType.Type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
             Assert.Equal(comparisonInfo.Length, propertyInfos.Length);
 
diff --git a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
index 07e0760970e..ca6d7535564 100644
--- a/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/LoggingService_Tests.cs
@@ -801,18 +801,6 @@ public void TreatWarningsAsErrorWhenAllSpecified(int loggerMode, int nodeId)
             logger.Errors.ShouldHaveSingleItem();
         }
 
-        [Fact]
-        public void VerifyWarningsPromotedToErrorsAreCounted()
-        {
-            ILoggingService ls = LoggingService.CreateLoggingService(LoggerMode.Synchronous, 1);
-            ls.WarningsAsErrors = new HashSet<string>();
-            ls.WarningsAsErrors.Add("FOR123");
-            BuildWarningEventArgs warningArgs = new("abc", "FOR123", "", 0, 0, 0, 0, "warning message", "keyword", "sender");
-            warningArgs.BuildEventContext = new BuildEventContext(1, 2, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidProjectContextId, 5, 6);
-            ls.LogBuildEvent(warningArgs);
-            ls.HasBuildSubmissionLoggedErrors(1).ShouldBeTrue();
-        }
-
         /// <summary>
         /// Verifies that a warning is logged as a low importance message when it's warning code is specified.
         /// </summary>
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index 9f3cd6388b1..66f29308551 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1161,7 +1161,7 @@ private void InitializeHost(bool throwOnExecute)
 #else
             AssemblyLoadInfo loadInfo = AssemblyLoadInfo.Create(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).GetTypeInfo().FullName, null);
 #endif
-            LoadedType loadedType = new LoadedType(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory), loadInfo);
+            LoadedType loadedType = new LoadedType(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory), loadInfo, typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).GetTypeInfo().Assembly);
 
             TaskBuilderTestTask.TaskBuilderTestTaskFactory taskFactory = new TaskBuilderTestTask.TaskBuilderTestTaskFactory();
             taskFactory.ThrowOnExecute = throwOnExecute;
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 4f11a043242..cb255f7ae9b 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -1,13 +1,12 @@
 ï»¿using System;
 using System.Collections.Generic;
-using System.IO;
 using System.Text;
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
-using Microsoft.Build.UnitTests.Shared;
+
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -139,46 +138,6 @@ public void BinaryLoggerShouldSupportFilePathExplicitParameter()
             ObjectModelHelpers.BuildProjectExpectSuccess(s_testProject, binaryLogger);
         }
 
-        [Fact]
-        public void UnusedEnvironmentVariablesDoNotAppearInBinaryLog()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                env.SetEnvironmentVariable("MSBUILDONLYLOGUSEDENVIRONMENTVARIABLES", "1");
-                env.SetEnvironmentVariable("EnvVar1", "itsValue");
-                env.SetEnvironmentVariable("EnvVar2", "value2");
-                env.SetEnvironmentVariable("EnvVar3", "value3");
-                string contents = @"
-<Project DefaultTargets=""PrintEnvVar"">
-
-<PropertyGroup>
-<MyProp1>value</MyProp1>
-<MyProp2>$(EnvVar2)</MyProp2>
-</PropertyGroup>
-
-<Target Name=""PrintEnvVar"">
-<Message Text=""Environment variable EnvVar3 has value $(EnvVar3)"" Importance=""High"" />
-</Target>
-
-</Project>";
-                TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
-                TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
-                BinaryLogger logger = new();
-                logger.Parameters = _logFile;
-                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -bl:{logger.Parameters}", out bool success);
-                success.ShouldBeTrue();
-                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
-                success.ShouldBeTrue();
-                string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
-                text.ShouldContain("EnvVar2");
-                text.ShouldContain("value2");
-                text.ShouldContain("EnvVar3");
-                text.ShouldContain("value3");
-                text.ShouldNotContain("EnvVar1");
-                text.ShouldNotContain("itsValue");
-            }
-        }
-
         [Fact]
         public void BinaryLoggerShouldNotThrowWhenMetadataCannotBeExpanded()
         {
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 9b9deeef04a..4ad1bb35cac 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -24,36 +24,30 @@ public BuildEventArgsSerializationTests()
             _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void RoundtripBuildStartedEventArgs(bool serializeAllEnvironmentVariables)
+        [Fact]
+        public void RoundtripBuildStartedEventArgs()
         {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                env.SetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES", serializeAllEnvironmentVariables ? "1" : null);
-                var args = new BuildStartedEventArgs(
-                    "Message",
-                    "HelpKeyword",
-                    DateTime.Parse("3/1/2017 11:11:56 AM"));
-                Roundtrip(args,
-                    e => e.Message,
-                    e => e.HelpKeyword,
-                    e => e.Timestamp.ToString());
-
-                args = new BuildStartedEventArgs(
-                    "M",
-                    null,
-                    new Dictionary<string, string>
-                    {
+            var args = new BuildStartedEventArgs(
+                "Message",
+                "HelpKeyword",
+                DateTime.Parse("3/1/2017 11:11:56 AM"));
+            Roundtrip(args,
+                e => e.Message,
+                e => e.HelpKeyword,
+                e => e.Timestamp.ToString());
+
+            args = new BuildStartedEventArgs(
+                "M",
+                null,
+                new Dictionary<string, string>
+                {
                     { "SampleName", "SampleValue" }
-                    });
-                Roundtrip(args,
-                    e => serializeAllEnvironmentVariables ? TranslationHelpers.ToString(e.BuildEnvironment) : null,
-                    e => e.HelpKeyword,
-                    e => e.ThreadId.ToString(),
-                    e => e.SenderName);
-            }
+                });
+            Roundtrip(args,
+                e => TranslationHelpers.ToString(e.BuildEnvironment),
+                e => e.HelpKeyword,
+                e => e.ThreadId.ToString(),
+                e => e.SenderName);
         }
 
         [Fact]
@@ -179,17 +173,6 @@ public void RoundtripTaskStartedEventArgs()
                 e => e.ColumnNumber.ToString());
         }
 
-        [Fact]
-        public void RoundtripEnvironmentVariableReadEventArgs()
-        {
-            EnvironmentVariableReadEventArgs args = new("VarName", "VarValue");
-            args.BuildEventContext = new BuildEventContext(4, 5, 6, 7);
-            Roundtrip(args,
-                e => e.Message,
-                e => e.EnvironmentVariableName,
-                e => e.BuildEventContext.ToString());
-        }
-
         [Fact]
         public void RoundtripTaskFinishedEventArgs()
         {
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 51d649107b5..997e40b8c83 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4522,7 +4522,7 @@ public void VerifyMSBuildLogsAMessageWhenLocalPropertyCannotOverrideValueOfGloba
         [Fact]
         public void VerifyPropertyTrackingLoggingDefault()
         {
-            // Having just environment variables defined should default to nothing being logged except one environment variable read.
+            // Having nothing defined should default to nothing being logged.
             this.VerifyPropertyTrackingLoggingScenario(
                 null,
                 logger =>
@@ -4535,9 +4535,7 @@ public void VerifyPropertyTrackingLoggingDefault()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldHaveSingleItem()
-                        .EnvironmentVariableName
-                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
+                        .ShouldBeEmpty();
 
                     logger
                         .AllBuildEvents
@@ -4566,9 +4564,7 @@ public void VerifyPropertyTrackingLoggingPropertyReassignment()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldHaveSingleItem()
-                        .EnvironmentVariableName
-                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
+                        .ShouldBeEmpty();
 
                     logger
                         .AllBuildEvents
@@ -4597,9 +4593,7 @@ public void VerifyPropertyTrackingLoggingNone()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldHaveSingleItem()
-                        .EnvironmentVariableName
-                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
+                        .ShouldBeEmpty();
 
                     logger
                         .AllBuildEvents
@@ -4628,9 +4622,7 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldHaveSingleItem()
-                        .EnvironmentVariableName
-                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
+                        .ShouldBeEmpty();
 
                     logger
                         .AllBuildEvents
@@ -4714,9 +4706,7 @@ public void VerifyPropertyTrackingLoggingUninitializedPropertyRead()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldHaveSingleItem()
-                        .EnvironmentVariableName
-                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
+                        .ShouldBeEmpty();
 
                     logger
                         .AllBuildEvents
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index 6159f3af2c1..c6f7af84e57 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -22,7 +22,6 @@
 using System.Collections.Generic;
 using System.IO;
 using Xunit.Abstractions;
-using Shouldly;
 
 #nullable disable
 
@@ -81,41 +80,55 @@ public UtilitiesTestReadOnlyLoad()
         [Fact]
         public void CommentsInPreprocessing()
         {
-            using TestEnvironment env = TestEnvironment.Create();
-            XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();
+            Microsoft.Build.Construction.XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();
 
-            TransientTestFile inputFile = env.CreateFile("tempInput.tmp", ObjectModelHelpers.CleanupFileContents(@"
-<Project DefaultTargets='Build'>
-<Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets'/>
-</Project>"));
-            TransientTestFile outputFile = env.CreateFile("tempOutput.tmp");
+            string input = FileUtilities.GetTemporaryFile();
+            string output = FileUtilities.GetTemporaryFile();
 
-            env.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
+            string _initialLoadFilesWriteable = Environment.GetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE");
+            try
+            {
+                Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
+
+                string content = ObjectModelHelpers.CleanupFileContents(@"
+<Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+  <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets'/>
+</Project>");
+                File.WriteAllText(input, content);
 
 #if FEATURE_GET_COMMANDLINE
-            MSBuildApp.Execute(@"c:\bin\msbuild.exe """ + inputFile.Path +
-                (NativeMethodsShared.IsUnixLike ? @""" -pp:""" : @""" /pp:""") + outputFile.Path + @"""")
-                .ShouldBe(MSBuildApp.ExitType.Success);
+                Assert.Equal(MSBuildApp.ExitType.Success, MSBuildApp.Execute(@"c:\bin\msbuild.exe """ + input +
+                    (NativeMethodsShared.IsUnixLike ? @""" -pp:""" : @""" /pp:""") + output + @""""));
 #else
-            Assert.Equal(
-                MSBuildApp.ExitType.Success,
-                MSBuildApp.Execute(
-                    new[] { @"c:\bin\msbuild.exe", '"' + inputFile.Path + '"',
-                '"' + (NativeMethodsShared.IsUnixLike ? "-pp:" : "/pp:") + outputFile.Path + '"'}));
+                Assert.Equal(
+                    MSBuildApp.ExitType.Success,
+                    MSBuildApp.Execute(
+                        new[] { @"c:\bin\msbuild.exe", '"' + input + '"',
+                    '"' + (NativeMethodsShared.IsUnixLike ? "-pp:" : "/pp:") + output + '"'}));
 #endif
 
-            bool foundDoNotModify = false;
-            foreach (string line in File.ReadLines(outputFile.Path))
-            {
-                line.ShouldNotContain("<!---->", "This is what it will look like if we're loading read/only");
-
-                if (line.Contains("DO NOT MODIFY")) // this is in a comment in our targets
+                bool foundDoNotModify = false;
+                foreach (string line in File.ReadLines(output))
                 {
-                    foundDoNotModify = true;
+                    if (line.Contains("<!---->")) // This is what it will look like if we're loading read/only
+                    {
+                        Assert.True(false);
+                    }
+
+                    if (line.Contains("DO NOT MODIFY")) // this is in a comment in our targets
+                    {
+                        foundDoNotModify = true;
+                    }
                 }
-            }
 
-            foundDoNotModify.ShouldBeTrue();
+                Assert.True(foundDoNotModify);
+            }
+            finally
+            {
+                File.Delete(input);
+                File.Delete(output);
+                Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", _initialLoadFilesWriteable);
+            }
         }
 
         [Fact]
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 6d6a42d2d88..2f08099b333 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -8,6 +8,7 @@
 using System.Linq;
 using System.Reflection;
 using System.Threading;
+using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using InternalLoggerException = Microsoft.Build.Exceptions.InternalLoggerException;
@@ -1431,8 +1432,20 @@ private void LoggingEventProcessor(object loggingEvent)
         /// </summary>
         private void RouteBuildEvent(object loggingEvent)
         {
-            BuildEventArgs buildEventArgs = loggingEvent as BuildEventArgs ?? (loggingEvent as KeyValuePair<int, BuildEventArgs>?)?.Value;
-            ErrorUtilities.VerifyThrow(buildEventArgs is not null, "Unknown logging item in queue:" + loggingEvent.GetType().FullName);
+            BuildEventArgs buildEventArgs = null;
+
+            if (loggingEvent is BuildEventArgs bea)
+            {
+                buildEventArgs = bea;
+            }
+            else if (loggingEvent is KeyValuePair<int, BuildEventArgs> kvp)
+            {
+                buildEventArgs = kvp.Value;
+            }
+            else
+            {
+                ErrorUtilities.ThrowInternalError("Unknown logging item in queue:" + loggingEvent.GetType().FullName);
+            }
 
             if (buildEventArgs is BuildWarningEventArgs warningEvent)
             {
@@ -1528,7 +1541,7 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
             TryRaiseProjectStartedEvent(eventArg);
 
             // The event has not been through a filter yet. All events must go through a filter before they make it to a logger
-            if (_filterEventSource != null) // Loggers may not be registered
+            if (_filterEventSource != null)   // Loggers may not be registered
             {
                 // Send the event to the filter, the Consume will not return until all of the loggers which have registered to the event have process
                 // them.
@@ -1549,7 +1562,7 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
                         {
                             if (!sink.HaveLoggedBuildStartedEvent)
                             {
-                                sink.Consume(eventArg, pair.Key);
+                                sink.Consume(eventArg, (int)pair.Key);
                             }
 
                             // Reset the HaveLoggedBuildStarted event because no one else will be sending a build started event to any loggers at this time.
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index b9348623878..214a5118c2c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -388,11 +388,14 @@ public void LogBuildStarted()
                 message = ResourceUtilities.GetResourceString("BuildStarted");
             }
 
-            IDictionary<string, string> environmentProperties = _componentHost?.BuildParameters != null && Traits.Instance.LogAllEnvironmentVariables ?
-                _componentHost.BuildParameters.BuildProcessEnvironment
-                : null;
+            IDictionary<string, string> environmentProperties = null;
 
-            BuildStartedEventArgs buildEvent = new(message, helpKeyword: null, environmentProperties);
+            if (_componentHost?.BuildParameters != null)
+            {
+                environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
+            }
+
+            BuildStartedEventArgs buildEvent = new BuildStartedEventArgs(message, null /* no help keyword */, environmentProperties);
 
             // Raise the event with the filters
             ProcessLoggingEvent(buildEvent);
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index b7f2fcf4bc2..bc39a5ccd32 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using static Microsoft.Build.Execution.ProjectPropertyInstance;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 #nullable disable
@@ -72,17 +71,6 @@ internal ProjectLoggingContext(
         {
         }
 
-        private IEnumerable<DictionaryEntry> FilterEnvironmentDerivedProperties(PropertyDictionary<ProjectPropertyInstance> properties)
-        {
-            foreach (ProjectPropertyInstance property in properties)
-            {
-                if (property is not EnvironmentDerivedProjectPropertyInstance)
-                {
-                    yield return new DictionaryEntry(property.Name, property.EvaluatedValue);
-                }
-            }
-        }
-
         /// <summary>
         /// Constructs a project logging contexts.
         /// </summary>
@@ -112,19 +100,7 @@ private ProjectLoggingContext(
                 !LoggingService.IncludeEvaluationPropertiesAndItems &&
                 (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
             {
-                if (projectProperties is null)
-                {
-                    properties = Enumerable.Empty<DictionaryEntry>();
-                }
-                else if (Traits.Instance.LogAllEnvironmentVariables)
-                {
-                    properties = projectProperties.GetCopyOnReadEnumerable(property => new DictionaryEntry(property.Name, property.EvaluatedValue));
-                }
-                else
-                {
-                    properties = FilterEnvironmentDerivedProperties(projectProperties);
-                }
-
+                properties = projectProperties?.GetCopyOnReadEnumerable(property => new DictionaryEntry(property.Name, property.EvaluatedValue)) ?? Enumerable.Empty<DictionaryEntry>();
                 items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? Enumerable.Empty<DictionaryEntry>();
             }
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 4bbb3ae656d..8c3cdb46bb8 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -345,17 +345,8 @@ void EvaluateProjectIfNecessary(CacheRequest request)
             async Task LateInitializePluginForVsWorkaround(CacheRequest request)
             {
                 var (_, configuration) = request;
-                var solutionPath = configuration.Project.GetPropertyValue(SolutionProjectGenerator.SolutionPathPropertyName);
                 var solutionConfigurationXml = configuration.Project.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents);
 
-                ErrorUtilities.VerifyThrow(
-                    solutionPath != null && !string.IsNullOrWhiteSpace(solutionPath) && solutionPath != "*Undefined*",
-                    $"Expected VS to set a valid SolutionPath property but got: {solutionPath}");
-
-                ErrorUtilities.VerifyThrow(
-                    FileSystems.Default.FileExists(solutionPath),
-                    $"Solution file does not exist: {solutionPath}");
-
                 ErrorUtilities.VerifyThrow(
                     string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,
                     "Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.");
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 32b7c6b1b1a..505bc1d2df1 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -15,7 +15,6 @@
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
-using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -84,7 +83,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.KeepMetadata))
                             {
-                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation, LoggingContext).ToList();
+                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation).ToList();
                                 if (keepMetadataEvaluated.Count > 0)
                                 {
                                     keepMetadata = new HashSet<string>(keepMetadataEvaluated);
@@ -93,7 +92,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.RemoveMetadata))
                             {
-                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation, LoggingContext).ToList();
+                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation).ToList();
                                 if (removeMetadataEvaluated.Count > 0)
                                 {
                                     removeMetadata = new HashSet<string>(removeMetadataEvaluated);
@@ -102,7 +101,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.MatchOnMetadata))
                             {
-                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation, LoggingContext).ToList();
+                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation).ToList();
                                 if (matchOnMetadataEvaluated.Count > 0)
                                 {
                                     matchOnMetadata = new HashSet<string>(matchOnMetadataEvaluated);
@@ -115,7 +114,7 @@ internal override void ExecuteTask(Lookup lookup)
                                 (child.Exclude.Length != 0))
                             {
                                 // It's an item -- we're "adding" items to the world
-                                ExecuteAdd(child, bucket, keepMetadata, removeMetadata, LoggingContext);
+                                ExecuteAdd(child, bucket, keepMetadata, removeMetadata);
                             }
                             else if (child.Remove.Length != 0)
                             {
@@ -125,7 +124,7 @@ internal override void ExecuteTask(Lookup lookup)
                             else
                             {
                                 // It's a modify -- changing existing items
-                                ExecuteModify(child, bucket, keepMetadata, removeMetadata, LoggingContext);
+                                ExecuteModify(child, bucket, keepMetadata, removeMetadata);
                             }
                         }
                     }
@@ -151,8 +150,7 @@ internal override void ExecuteTask(Lookup lookup)
         /// <param name="bucket">The batching bucket.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        /// <param name="loggingContext">Context for logging</param>
-        private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata, LoggingContext loggingContext = null)
+        private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata)
         {
             // First, collect up the appropriate metadata collections.  We need the one from the item definition, if any, and
             // the one we are using for this batching bucket.
@@ -166,7 +164,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
             bucket.Expander.Metadata = metadataTable;
 
             // Second, expand the item include and exclude, and filter existing metadata as appropriate.
-            List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata, loggingContext);
+            List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata);
 
             // Third, expand the metadata.           
             foreach (ProjectItemGroupTaskMetadataInstance metadataInstance in child.Metadata)
@@ -181,12 +179,11 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     metadataInstance.Location,
                     LoggingContext.LoggingService,
                     LoggingContext.BuildEventContext,
-                    FileSystems.Default,
-                    loggingContext: loggingContext);
+                    FileSystems.Default);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and 
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
@@ -248,7 +245,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
             List<ProjectItemInstance> itemsToRemove;
             if (matchOnMetadata == null)
             {
-                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander, LoggingContext);
+                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander);
             }
             else
             {
@@ -280,8 +277,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
         /// <param name="bucket">The batching bucket.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        /// <param name="loggingContext">Context for this operation.</param>
-        private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata, LoggingContext loggingContext = null)
+        private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata)
         {
             ICollection<ProjectItemInstance> group = bucket.Lookup.GetItems(child.ItemType);
             if (group == null || group.Count == 0)
@@ -321,12 +317,11 @@ private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     metadataInstance.ConditionLocation,
                     LoggingContext.LoggingService,
                     LoggingContext.BuildEventContext,
-                    FileSystems.Default,
-                    loggingContext: loggingContext);
+                    FileSystems.Default);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
                     metadataToSet[metadataInstance.Name] = Lookup.MetadataModification.CreateFromNewValue(evaluatedValue);
                 }
             }
@@ -362,7 +357,6 @@ private void GetBatchableValuesFromBuildItemGroupChild(List<string> parameterVal
         /// <param name="expander">The expander to use.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        /// <param name="loggingContext">Context for logging</param>
         /// <remarks>
         /// This code is very close to that which exists in the Evaluator.EvaluateItemXml method.  However, because
         /// it invokes type constructors, and those constructors take arguments of fundamentally different types, it has not
@@ -374,8 +368,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             ProjectItemGroupTaskItemInstance originalItem,
             Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
             ISet<string> keepMetadata,
-            ISet<string> removeMetadata,
-            LoggingContext loggingContext = null
+            ISet<string> removeMetadata
         )
         {
             // todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
@@ -383,7 +376,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
             // Expand properties and metadata in Include
-            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation, loggingContext);
+            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation);
 
             if (evaluatedInclude.Length == 0)
             {
@@ -394,7 +387,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             var excludes = ImmutableList<string>.Empty.ToBuilder();
             if (originalItem.Exclude.Length > 0)
             {
-                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation, loggingContext);
+                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation);
 
                 if (evaluatedExclude.Length > 0)
                 {
@@ -523,15 +516,13 @@ private List<ProjectItemInstance> ExpandItemIntoItems
         /// <param name="specification">The specification to match against the items.</param>
         /// <param name="specificationLocation">The specification to match against the provided items</param>
         /// <param name="expander">The expander to use</param>
-        /// <param name="loggingContext">Context for logging</param>
         /// <returns>A list of matching items</returns>
         private List<ProjectItemInstance> FindItemsMatchingSpecification
             (
             ICollection<ProjectItemInstance> items,
             string specification,
             ElementLocation specificationLocation,
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
-            LoggingContext loggingContext = null
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander
             )
         {
             if (items.Count == 0 || specification.Length == 0)
@@ -544,7 +535,7 @@ private List<ProjectItemInstance> FindItemsMatchingSpecification
             HashSet<string> specificationsToFind = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             // Split by semicolons
-            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation, loggingContext);
+            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation);
 
             foreach (string piece in specificationPieces)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index e1479768ff2..49a849c4313 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -353,8 +353,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 _target.ConditionLocation,
                 projectLoggingContext.LoggingService,
                 projectLoggingContext.BuildEventContext,
-                FileSystems.Default,
-                loggingContext: projectLoggingContext);
+                FileSystems.Default);
 
             if (!condition)
             {
@@ -393,7 +392,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 return new List<TargetSpecification>();
             }
 
-            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation, projectLoggingContext);
+            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation);
             List<TargetSpecification> dependencyTargets = new List<TargetSpecification>();
             foreach (string escapedDependency in dependencies)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 4835778b4c1..ec05dfd174f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -381,8 +381,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 _targetChildInstance.ConditionLocation,
                 _targetLoggingContext.LoggingService,
                 _targetLoggingContext.BuildEventContext,
-                FileSystems.Default,
-                loggingContext: _targetLoggingContext);
+                FileSystems.Default);
 
             if (!condition)
             {
@@ -624,7 +623,7 @@ private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTas
                     if (!_targetLoggingContext.LoggingService.OnlyLogCriticalEvents)
                     {
                         // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation, loggingContext: _targetLoggingContext);
+                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation);
 
                         // Whilst we are within the processing of the task, we haven't actually started executing it, so
                         // our skip task message needs to be in the context of the target. However any errors should be reported
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index bfbe4b83f41..f3b18d6a93e 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -23,6 +23,7 @@
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Task = System.Threading.Tasks.Task;
+using System.Linq;
 
 #nullable disable
 
@@ -256,12 +257,12 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
 
             TaskRequirements requirements = TaskRequirements.None;
 
-            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute())
+            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute)
             {
                 requirements |= TaskRequirements.RequireSTAThread;
             }
 
-            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute())
+            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute)
             {
                 requirements |= TaskRequirements.RequireSeparateAppDomain;
 
@@ -399,6 +400,14 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
             try
             {
                 TaskPropertyInfo parameter = _taskFactoryWrapper.GetProperty(parameterName);
+                foreach (TaskPropertyInfo prop in _taskFactoryWrapper.TaskFactoryLoadedType.Properties)
+                {
+                    if (prop.Name.Equals(parameterName, StringComparison.OrdinalIgnoreCase))
+                    {
+                        parameter = prop;
+                        break;
+                    }
+                }
 
                 // flag an error if we find a parameter that has no .NET property equivalent
                 ProjectErrorUtilities.VerifyThrowInvalidProject
@@ -420,17 +429,14 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                     _taskName
                 );
 
-                // grab the outputs from the task's designated output parameter (which is a .NET property)
-                Type type = parameter.PropertyType;
-
                 EnsureParameterInitialized(parameter, _batchBucket.Lookup);
 
-                if (TaskParameterTypeVerifier.IsAssignableToITask(type))
+                if (parameter.IsAssignableToITask)
                 {
                     ITaskItem[] outputs = GetItemOutputs(parameter);
                     GatherTaskItemOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation, parameter);
                 }
-                else if (TaskParameterTypeVerifier.IsValueTypeOutputParameter(type))
+                else if (parameter.IsValueTypeOutputParameter)
                 {
                     string[] outputs = GetValueOutputs(parameter);
                     GatherArrayStringAndValueOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation, parameter);
@@ -897,12 +903,14 @@ private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskId
                 // Map to an intrinsic task, if necessary.
                 if (String.Equals(returnClass.TaskFactory.TaskType.FullName, "Microsoft.Build.Tasks.MSBuild", StringComparison.OrdinalIgnoreCase))
                 {
-                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(MSBuild)), new LoadedType(typeof(MSBuild), AssemblyLoadInfo.Create(typeof(TaskExecutionHost).GetTypeInfo().Assembly.FullName, null)), _taskName, null);
+                    Assembly taskExecutionHostAssembly = typeof(TaskExecutionHost).GetTypeInfo().Assembly;
+                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(MSBuild)), new LoadedType(typeof(MSBuild), AssemblyLoadInfo.Create(taskExecutionHostAssembly.FullName, null), taskExecutionHostAssembly), _taskName, null);
                     _intrinsicTasks[_taskName] = returnClass;
                 }
                 else if (String.Equals(returnClass.TaskFactory.TaskType.FullName, "Microsoft.Build.Tasks.CallTarget", StringComparison.OrdinalIgnoreCase))
                 {
-                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(CallTarget)), new LoadedType(typeof(CallTarget), AssemblyLoadInfo.Create(typeof(TaskExecutionHost).GetTypeInfo().Assembly.FullName, null)), _taskName, null);
+                    Assembly taskExecutionHostAssembly = typeof(TaskExecutionHost).GetTypeInfo().Assembly;
+                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(CallTarget)), new LoadedType(typeof(CallTarget), AssemblyLoadInfo.Create(taskExecutionHostAssembly.FullName, null), taskExecutionHostAssembly), _taskName, null);
                     _intrinsicTasks[_taskName] = returnClass;
                 }
             }
@@ -1008,12 +1016,43 @@ out bool parameterSet
             try
             {
                 // check if the task has a .NET property corresponding to the parameter
-                TaskPropertyInfo parameter = _taskFactoryWrapper.GetProperty(parameterName);
+                LoadedType loadedType = _taskFactoryWrapper.TaskFactoryLoadedType;
+                int indexOfParameter = -1;
+                for (int i = 0; i < loadedType.Properties.Length; i++)
+                {
+                    if (loadedType.Properties[i].Name.Equals(parameterName))
+                    {
+                        indexOfParameter = i;
+                        break;
+                    }
+                }
 
-                if (parameter != null)
+                // For most tasks, finding the parameter in our list of known properties is equivalent to
+                // saying the task was properly invoked, as far as this parameter is concerned. However,
+                // that is not true for CodeTaskFactories like RoslynCodeTaskFactory. In that case, they
+                // will often have a list of parameters under the UsingTask declaration. Fortunately, if
+                // your TaskFactory is RoslynCodeTaskFactory, it isn't TaskHostFactory, which means the
+                // types are fully loaded at this stage, and we can access them as we had in the past.
+                TaskPropertyInfo parameter = null;
+                Type parameterType = null;
+                if (indexOfParameter != -1)
+                {
+                    parameter = loadedType.Properties[indexOfParameter];
+                    parameterType = Type.GetType(
+                        loadedType.PropertyAssemblyQualifiedNames?[indexOfParameter] ??
+                        parameter.PropertyType.AssemblyQualifiedName);
+                }
+                else
                 {
-                    Type parameterType = parameter.PropertyType;
+                    parameter = _taskFactoryWrapper.GetProperty(parameterName);
+                    if (parameter != null)
+                    {
+                        parameterType = Type.GetType(parameter.PropertyType.AssemblyQualifiedName);
+                    }
+                }
 
+                if (parameter != null)
+                {
                     EnsureParameterInitialized(parameter, _batchBucket.Lookup);
 
                     // try to set the parameter
@@ -1068,30 +1107,15 @@ out parameterSet
                 else
                 {
                     // flag an error if we find a parameter that has no .NET property equivalent
-                    if (_taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly is null)
-                    {
-                        _taskLoggingContext.LogError
-                            (
-                            new BuildEventFileInfo( parameterLocation ),
-                            "UnexpectedTaskAttribute",
-                            parameterName,
-                            _taskName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.Type.Assembly.FullName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.Type.Assembly.Location
-                            );
-                    }
-                    else
-                    {
-                        _taskLoggingContext.LogError
-                            (
-                            new BuildEventFileInfo( parameterLocation ),
-                            "UnexpectedTaskAttribute",
-                            parameterName,
-                            _taskName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly.FullName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly.Location
-                            );
-                    }
+                    _taskLoggingContext.LogError
+                        (
+                        new BuildEventFileInfo( parameterLocation ),
+                        "UnexpectedTaskAttribute",
+                        parameterName,
+                        _taskName,
+                        _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssemblyName.FullName,
+                        _taskFactoryWrapper.TaskFactoryLoadedType.Path
+                        );
                 }
             }
             catch (AmbiguousMatchException)
@@ -1174,7 +1198,7 @@ out bool taskParameterSet
                 else
                 {
                     // Expand out all the metadata, properties, and item vectors in the string.
-                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation, _targetLoggingContext);
+                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation);
 
                     if (expandedParameterValue.Length == 0)
                     {
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 294b523e07e..6fb05e271d0 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2924,7 +2924,7 @@ public override bool SetGlobalProperty(string name, string escapedValue)
                     string originalValue = (existing == null) ? String.Empty : ((IProperty)existing).EvaluatedValueEscaped;
 
                     _data.GlobalPropertiesDictionary.Set(ProjectPropertyInstance.Create(name, escapedValue));
-                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, isGlobalProperty: true, mayBeReserved: false, loggingContext: null));
+                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, true /* is global */, false /* may not be reserved name */));
 
                     ProjectCollection.AfterUpdateLoadedProjectGlobalProperties(Owner);
                     MarkDirty();
@@ -4394,9 +4394,9 @@ public IItemDefinition<ProjectMetadata> GetItemDefinition(string itemType)
             /// <summary>
             /// Sets a property which is not derived from Xml.
             /// </summary>
-            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
+            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
             {
-                ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext);
+                ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
                 Properties.Set(property);
 
                 AddToAllEvaluatedPropertiesList(property);
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 157fc4366ec..b3e808c3c9a 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -3,10 +3,8 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
@@ -96,18 +94,7 @@ public string EvaluatedValue
         string IProperty.EvaluatedValueEscaped
         {
             [DebuggerStepThrough]
-            get
-            {
-                if (this is EnvironmentDerivedProjectProperty environmentProperty && environmentProperty.loggingContext is { IsValid: true } loggingContext && !environmentProperty._loggedEnvProperty)
-                {
-                    EnvironmentVariableReadEventArgs args = new(Name, EvaluatedValueEscapedInternal);
-                    args.BuildEventContext = loggingContext.BuildEventContext;
-                    loggingContext.LogBuildEvent(args);
-                    environmentProperty._loggedEnvProperty = true;
-                }
-
-                return EvaluatedValueEscapedInternal;
-            }
+            get => EvaluatedValueEscapedInternal;
         }
 
         /// <summary>
@@ -250,10 +237,9 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
         /// This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
         /// All other properties originate in XML, and should have a backing XML object.
         /// </summary>
-        internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext = null)
+        internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved)
         {
-            return !isGlobalProperty && !mayBeReserved ? new EnvironmentDerivedProjectProperty(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext) :
-                new ProjectPropertyNotXmlBacked(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
+            return new ProjectPropertyNotXmlBacked(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
         }
 
         /// <summary>
@@ -642,18 +628,5 @@ public override bool IsImported
                 get { return false; }
             }
         }
-
-        private class EnvironmentDerivedProjectProperty : ProjectPropertyNotXmlBacked
-        {
-            internal bool _loggedEnvProperty = false;
-            internal LoggingContext loggingContext;
-
-            internal EnvironmentDerivedProjectProperty(
-                Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext)
-                : base(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved)
-            {
-                this.loggingContext = loggingContext;
-            }
-        }
     }
 }
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 183ce5117d6..31dd956ed2e 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -17,7 +17,6 @@ namespace Microsoft.Build.Evaluation
     using ElementLocation = Microsoft.Build.Construction.ElementLocation;
     using Microsoft.Build.Shared;
     using Microsoft.Build.Shared.FileSystem;
-    using Microsoft.Build.BackEnd.Logging;
 
     internal static class ConditionEvaluator
     {
@@ -182,8 +181,7 @@ internal static bool EvaluateCondition<P, I>
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null,
-            LoggingContext loggingContext = null)
+            ProjectRootElementCacheBase projectRootElementCache = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -198,8 +196,7 @@ internal static bool EvaluateCondition<P, I>
                 loggingServices,
                 buildEventContext,
                 fileSystem,
-                projectRootElementCache,
-                loggingContext);
+                projectRootElementCache);
         }
 
         /// <summary>
@@ -221,8 +218,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null,
-            LoggingContext loggingContext = null
+            ProjectRootElementCacheBase projectRootElementCache = null
         )
             where P : class, IProperty
             where I : class, IItem
@@ -283,7 +279,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             {
                 try
                 {
-                    result = parsedExpression.Evaluate(state, loggingContext);
+                    result = parsedExpression.Evaluate(state);
                 }
                 finally
                 {
@@ -357,7 +353,7 @@ internal interface IConditionEvaluationState
             ///     May return null if the expression would expand to non-empty and it broke out early.
             ///     Otherwise, returns the correctly expanded expression.
             /// </summary>
-            string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null);
+            string ExpandIntoStringBreakEarly(string expression);
 
             /// <summary>
             ///     Expands the specified expression into a list of TaskItem's.
@@ -367,7 +363,7 @@ internal interface IConditionEvaluationState
             /// <summary>
             ///     Expands the specified expression into a string.
             /// </summary>
-            string ExpandIntoString(string expression, LoggingContext loggingContext = null);
+            string ExpandIntoString(string expression);
 
             /// <summary>
             ///     PRE cache
@@ -444,11 +440,11 @@ internal ConditionEvaluationState
             /// May return null if the expression would expand to non-empty and it broke out early.
             /// Otherwise, returns the correctly expanded expression.
             /// </summary>
-            public string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null)
+            public string ExpandIntoStringBreakEarly(string expression)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation, loggingContext);
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation);
 
                 _expander.WarnForUninitializedProperties = originalValue;
 
@@ -475,13 +471,12 @@ public IList<TaskItem> ExpandIntoTaskItems(string expression)
             /// Expands the specified expression into a string.
             /// </summary>
             /// <param name="expression">The expression to expand.</param>
-            /// <param name="loggingContext"></param>
             /// <returns>The expanded string.</returns>
-            public string ExpandIntoString(string expression, LoggingContext loggingContext = null)
+            public string ExpandIntoString(string expression)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation, loggingContext);
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation);
 
                 _expander.WarnForUninitializedProperties = originalValue;
 
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index 47481c625c3..94513436e9c 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -1,7 +1,6 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -19,9 +18,9 @@ internal sealed class AndExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                      state.ElementLocation,
@@ -38,7 +37,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                          state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index 4ec222243fd..e0b57181361 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
@@ -30,7 +29,7 @@ internal FunctionCallExpressionNode(string functionName, List<GenericExpressionN
         /// <summary>
         /// Evaluate node as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (String.Equals(_functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index 50efb172cf7..d6007133404 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.BackEnd.Logging;
+
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -14,9 +14,9 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class GenericExpressionNode
     {
-        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null);
-        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null);
-        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null);
+        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result);
+        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result);
+        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result);
 
         /// <summary>
         /// Returns true if this node evaluates to an empty string,
@@ -25,7 +25,7 @@ internal abstract class GenericExpressionNode
         /// to empty than to fully evaluate it.)
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
         {
             return false;
         }
@@ -34,7 +34,7 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
+        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state);
 
         /// <summary>
         /// Value before any item and property expressions are expanded
@@ -52,17 +52,16 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// The main evaluate entry point for expression trees
         /// </summary>
         /// <param name="state"></param>
-        /// <param name="loggingContext"></param>
         /// <returns></returns>
-        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!TryBoolEvaluate(state, out bool boolValue, loggingContext))
+            if (!TryBoolEvaluate(state, out bool boolValue))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ConditionNotBooleanDetail",
                     state.Condition,
-                    GetExpandedValue(state, loggingContext));
+                    GetExpandedValue(state));
             }
 
             return boolValue;
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 1ef13748bdc..65e23c7718f 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -1,7 +1,6 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -37,7 +36,7 @@ internal abstract class MultipleComparisonNode : OperatorExpressionNode
         /// Order in which comparisons are attempted is numeric, boolean, then string.
         /// Updates conditioned properties table.
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             ProjectErrorUtilities.VerifyThrowInvalidProject
                 (LeftChild != null && RightChild != null,
@@ -51,8 +50,8 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // and we know which do, then we already have enough information to evaluate this expression.
             // That means we don't have to fully expand a condition like " '@(X)' == '' " 
             // which is a performance advantage if @(X) is a huge item list.
-            bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);
-            bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);
+            bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
+            bool rightEmpty = RightChild.EvaluatesToEmpty(state);
             if (leftEmpty || rightEmpty)
             {
                 UpdateConditionedProperties(state);
@@ -69,13 +68,13 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                 // is 17.0).
                 return Compare(leftNumericValue, rightNumericValue);
             }
-            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue, loggingContext) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue, loggingContext))
+            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue))
             {
                 return Compare(leftBoolValue, rightBoolValue);
             }
 
-            string leftExpandedValue = LeftChild.GetExpandedValue(state, loggingContext);
-            string rightExpandedValue = RightChild.GetExpandedValue(state, loggingContext);
+            string leftExpandedValue = LeftChild.GetExpandedValue(state);
+            string rightExpandedValue = RightChild.GetExpandedValue(state);
 
             ProjectErrorUtilities.VerifyThrowInvalidProject
                 (leftExpandedValue != null && rightExpandedValue != null,
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index 1d2e1d6311e..e5b00ac781a 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -1,7 +1,6 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -19,9 +18,9 @@ internal sealed class NotExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
@@ -45,9 +44,9 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Returns expanded value with '!' prepended. Useful for error messages.
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
-            return "!" + LeftChild.GetExpandedValue(state, loggingContext);
+            return "!" + LeftChild.GetExpandedValue(state);
         }
 
         internal override string DebuggerDisplay => $"(not {LeftChild.DebuggerDisplay})";
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index f161ad5d18b..02c242ceef5 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.BackEnd.Logging;
+
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -38,7 +38,7 @@ internal abstract class NumericComparisonExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             bool isLeftNum = LeftChild.TryNumericEvaluate(state, out double leftNum);
             bool isLeftVersion = LeftChild.TryVersionEvaluate(state, out Version leftVersion);
@@ -53,7 +53,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     state.Condition,
                     /* helpfully display unexpanded token and expanded result in error message */
                     isLeftNum ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
-                    isLeftNum ? RightChild.GetExpandedValue(state, loggingContext) : LeftChild.GetExpandedValue(state, loggingContext));
+                    isLeftNum ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
             }
 
             return (isLeftNum, isLeftVersion, isRightNum, isRightVersion) switch
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index 7725d9962dc..66fa552443d 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -3,7 +3,7 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
+
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -23,18 +23,18 @@ internal NumericExpressionNode(string value)
             _value = value;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
             return Version.TryParse(_value, out result);
         }
@@ -50,7 +50,7 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Get the expanded value
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             return _value;
         }
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index a3f76ff20ff..c6e4b4c349c 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -13,21 +12,21 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class OperatorExpressionNode : GenericExpressionNode
     {
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            result = BoolEvaluate(state, loggingContext);
+            result = BoolEvaluate(state);
             return true;
         }
 
-        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
+        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
             result = default;
             return false;
@@ -37,7 +36,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             return null;
         }
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index fa1816c2e1d..250e8c9602c 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -1,7 +1,6 @@
 ï»¿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -19,15 +18,15 @@ internal sealed class OrExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ExpressionDoesNotEvaluateToBoolean",
                     LeftChild.GetUnexpandedValue(state),
-                    LeftChild.GetExpandedValue(state, loggingContext),
+                    LeftChild.GetExpandedValue(state),
                     state.Condition);
             }
 
@@ -38,7 +37,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                         state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 43dd324e7a8..7017b0b5023 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -31,34 +30,34 @@ internal StringExpressionNode(string value, bool expandable)
             _expandable = expandable;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state, loggingContext), out result);
+            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state), out result);
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
+            if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
                 result = ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state, loggingContext), out result);
+                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state), out result);
             }
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
+            if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
                 result = Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return Version.TryParse(GetExpandedValue(state, loggingContext), out result);
+                return Version.TryParse(GetExpandedValue(state), out result);
             }
         }
 
@@ -69,7 +68,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// to empty than to fully evaluate it.
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (_cachedExpandedValue == null)
             {
@@ -94,7 +93,7 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
                             break;
                     }
 
-                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value, loggingContext);
+                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value);
 
                     if (expandBreakEarly == null)
                     {
@@ -130,13 +129,13 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (_cachedExpandedValue == null)
             {
                 if (_expandable)
                 {
-                    _cachedExpandedValue = state.ExpandIntoString(_value, loggingContext);
+                    _cachedExpandedValue = state.ExpandIntoString(_value);
                 }
                 else
                 {
@@ -169,7 +168,7 @@ internal override void ResetState()
         /// but now cause the project to throw InvalidProjectException when
         /// ToolsVersion is "Current". https://github.com/dotnet/msbuild/issues/4150
         /// </remarks>
-        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (!_shouldBeTreatedAsVisualStudioVersion.HasValue)
             {
@@ -177,7 +176,7 @@ private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionE
 
                 // Do this check first, because if it's not (common) we can early-out and the next
                 // expansion will be cheap because this will populate the cached expanded value.
-                if (string.Equals(GetExpandedValue(state, loggingContext), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
+                if (string.Equals(GetExpandedValue(state), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
                 {
                     // and it is just an expansion of MSBuildToolsVersion
                     _shouldBeTreatedAsVisualStudioVersion = string.Equals(_value, "$(MSBuildToolsVersion)", StringComparison.OrdinalIgnoreCase);
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index ebce24983ad..b3154221e9f 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using ObjectModel = System.Collections.ObjectModel;
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
@@ -24,15 +25,13 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using static Microsoft.Build.Execution.ProjectPropertyInstance;
-using Constants = Microsoft.Build.Internal.Constants;
-using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
+using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
-using ObjectModel = System.Collections.ObjectModel;
+using Constants = Microsoft.Build.Internal.Constants;
+using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using SdkReferencePropertyExpansionMode = Microsoft.Build.Framework.EscapeHatches.SdkReferencePropertyExpansionMode;
-using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 
 #nullable disable
 
@@ -812,30 +811,13 @@ private void Evaluate()
             if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
             {
                 globalProperties = _data.GlobalPropertiesDictionary;
-                properties = Traits.Instance.LogAllEnvironmentVariables ? _data.Properties : FilterOutEnvironmentDerivedProperties(_data.Properties);
+                properties = _data.Properties;
                 items = _data.Items;
             }
 
             _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);
         }
 
-        private IEnumerable FilterOutEnvironmentDerivedProperties(PropertyDictionary<P> dictionary)
-        {
-            List<P> list = new(dictionary.Count);
-            foreach (P p in dictionary)
-            {
-                if (p is EnvironmentDerivedProjectPropertyInstance ||
-                    (p is ProjectProperty pp && pp.IsEnvironmentProperty))
-                {
-                    continue;
-                }
-
-                list.Add(p);
-            }
-
-            return list;
-        }
-
         private void CollectProjectCachePlugins()
         {
             foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))
@@ -1069,8 +1051,8 @@ private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<Pr
         /// </summary>
         private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets, Dictionary<string, List<TargetSpecification>> targetsWhichRunBeforeByTarget, Dictionary<string, List<TargetSpecification>> targetsWhichRunAfterByTarget)
         {
-            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation, _evaluationLoggingContext);
-            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation, _evaluationLoggingContext);
+            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation);
+            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation);
 
             foreach (string beforeTarget in beforeTargets)
             {
@@ -1215,7 +1197,7 @@ private void AddEnvironmentProperties()
         {
             foreach (ProjectPropertyInstance environmentProperty in _environmentProperties)
             {
-                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true, loggingContext: _evaluationLoggingContext);
+                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true);
             }
         }
 
@@ -1316,7 +1298,7 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                 // it is the same as what we are setting the value on. Note: This needs to be set before we expand the property we are currently setting.
                 _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
 
-                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location, _evaluationLoggingContext);
+                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location);
 
                 // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
                 // during evaluation.
@@ -2021,7 +2003,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
         {
             imports = null;
 
-            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation, _evaluationLoggingContext);
+            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
             ElementLocation importLocationInProject = importElement.Location;
 
             if (String.IsNullOrWhiteSpace(importExpressionEscaped))
@@ -2446,8 +2428,7 @@ private bool EvaluateCondition(ProjectElement element, string condition, Expande
                     element.ConditionLocation,
                     _evaluationLoggingContext.LoggingService,
                     _evaluationLoggingContext.BuildEventContext,
-                    _evaluationContext.FileSystem,
-                    loggingContext: _evaluationLoggingContext
+                    _evaluationContext.FileSystem
                     );
 
                 return result;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 88e5fea6c1b..9bc57cab1ed 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -26,7 +26,6 @@
 using TaskItemFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory;
 
 using Microsoft.NET.StringTools;
-using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -419,9 +418,9 @@ internal static bool ExpressionContainsItemVector(string expression)
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
-            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext);
+            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation);
 
             return (result == null) ? null : EscapingUtilities.UnescapeAll(result);
         }
@@ -433,7 +432,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
             if (expression.Length == 0)
             {
@@ -443,7 +442,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem, loggingContext);
+            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
 
@@ -473,11 +472,11 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
-        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
             ErrorUtilities.VerifyThrow((options & ExpanderOptions.BreakOnNotEmpty) == 0, "not supported");
 
-            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext));
+            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation));
         }
 
         /// <summary>
@@ -1077,8 +1076,7 @@ internal static string ExpandPropertiesLeaveEscaped(
                 ExpanderOptions options,
                 IElementLocation elementLocation,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext = null)
+                IFileSystem fileSystem)
             {
                 return
                     ConvertToString(
@@ -1088,8 +1086,7 @@ internal static string ExpandPropertiesLeaveEscaped(
                             options,
                             elementLocation,
                             usedUninitializedProperties,
-                            fileSystem,
-                            loggingContext));
+                            fileSystem));
             }
 
             /// <summary>
@@ -1115,8 +1112,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 ExpanderOptions options,
                 IElementLocation elementLocation,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext = null)
+                IFileSystem fileSystem)
             {
                 if (((options & ExpanderOptions.ExpandProperties) == 0) || String.IsNullOrEmpty(expression))
                 {
@@ -1230,7 +1226,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         }
                         else // This is a regular property
                         {
-                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties, loggingContext);
+                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties);
                         }
 
                         if (propertyValue != null)
@@ -1468,7 +1464,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties, LoggingContext loggingContext = null)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
             {
                 T property = properties.GetProperty(propertyName, startIndex, endIndex);
 
@@ -1513,11 +1509,6 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 }
                 else
                 {
-                    if (property is ProjectPropertyInstance.EnvironmentDerivedProjectPropertyInstance environmentDerivedProperty)
-                    {
-                        environmentDerivedProperty.loggingContext = loggingContext;
-                    }
-
                     propertyValue = property.EvaluatedValueEscaped;
                 }
 
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 497207e7024..cf0b17d457f 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -267,7 +267,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null);
+        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false);
 
         /// <summary>
         /// Sets a property which comes from the Xml.
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index d7f58c8088a..65c1fd8b486 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -157,23 +156,21 @@ private bool InitReferencedItemsIfNecessary()
         /// <param name="itemSpecLocation">The xml location the itemspec comes from</param>
         /// <param name="projectDirectory">The directory that the project is in.</param>
         /// <param name="expandProperties">Expand properties before breaking down fragments. Defaults to true</param>
-        /// <param name="loggingContext">Context in which to log</param>
         public ItemSpec(
             string itemSpec,
             Expander<P, I> expander,
             IElementLocation itemSpecLocation,
             string projectDirectory,
-            bool expandProperties = true,
-            LoggingContext loggingContext = null)
+            bool expandProperties = true)
         {
             ItemSpecString = itemSpec;
             Expander = expander;
             ItemSpecLocation = itemSpecLocation;
 
-            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties, loggingContext);
+            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties);
         }
 
-        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties, LoggingContext loggingContext)
+        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties)
         {
             // Code corresponds to Evaluator.CreateItemsFromInclude
             var evaluatedItemspecEscaped = ItemSpecString;
@@ -189,8 +186,7 @@ private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocat
                 evaluatedItemspecEscaped = Expander.ExpandIntoStringLeaveEscaped(
                     ItemSpecString,
                     ExpanderOptions.ExpandProperties,
-                    itemSpecLocation,
-                    loggingContext);
+                    itemSpecLocation);
             }
 
             var semicolonCount = 0;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index ecae588cd20..0255a8fbf2d 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
-using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -308,9 +307,9 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
                 return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped);
             }
 
-            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, LoggingContext loggingContext = null)
+            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
             {
-                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext: loggingContext);
+                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
             }
         }
     }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index f0c19a5c681..f78cc28be71 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -262,7 +262,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                                 continue;
                             }
 
-                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location, _lazyEvaluator._loggingContext);
+                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location);
                             evaluatedValue = FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath);
 
                             metadataTable.SetValue(metadataElement, evaluatedValue);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 871ad820e6a..28fe97350da 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -99,8 +99,7 @@ LazyItemEvaluator<P, I, M, D> lazyEvaluator
                     element.ConditionLocation,
                     lazyEvaluator._loggingContext.LoggingService,
                     lazyEvaluator._loggingContext.BuildEventContext,
-                    lazyEvaluator.FileSystem,
-                    loggingContext: lazyEvaluator._loggingContext
+                    lazyEvaluator.FileSystem
                     );
                 MSBuildEventSource.Log.EvaluateConditionStop(condition, result);
 
@@ -625,7 +624,7 @@ private RemoveOperation BuildRemoveOperation(string rootDirectory, ProjectItemEl
 
         private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLocation itemSpecLocation, OperationBuilder builder)
         {
-            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory, loggingContext: _loggingContext);
+            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory);
 
             foreach (ItemSpecFragment fragment in builder.ItemSpec.Fragments)
             {
@@ -636,7 +635,7 @@ private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLoca
             }
         }
 
-        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander, LoggingContext loggingContext = null)
+        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander)
         {
             // Since we're just attempting to expand properties in order to find referenced items and not expanding metadata,
             // unexpected errors may occur when evaluating property functions on unexpanded metadata. Just ignore them if that happens.
@@ -650,8 +649,7 @@ private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(IColle
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Value,
                     expanderOptions,
-                    metadatumElement.Location,
-                    loggingContext);
+                    metadatumElement.Location);
 
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Condition,
@@ -666,7 +664,7 @@ private void ProcessMetadataElements(ProjectItemElement itemElement, OperationBu
             {
                 operationBuilder.Metadata.AddRange(itemElement.Metadata);
 
-                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander, _loggingContext));
+                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander));
                 if (itemsAndMetadataFound.Items != null)
                 {
                     foreach (var itemType in itemsAndMetadataFound.Items)
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index b113e73a6ec..da81aaf21b5 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -79,10 +79,10 @@ public P GetProperty(string name, int startIndex, int endIndex)
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
+        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
         {
             P originalProperty = _wrapped.GetProperty(name);
-            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, loggingContext);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable);
 
             this.TrackPropertyWrite(
                 originalProperty,
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 0237d7f0ad8..94344843b96 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1475,10 +1475,10 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// immutable if we are immutable.
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
-        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable, LoggingContext loggingContext)
+        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable)
         {
             // Mutability not verified as this is being populated during evaluation
-            ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable, isEnvironmentVariable, loggingContext);
+            ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable);
             _properties.Set(property);
             return property;
         }
@@ -2966,7 +2966,7 @@ private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, b
             {
                 // Allow reserved property names, since this is how they are added to the project instance. 
                 // The caller has prevented users setting them themselves.
-                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable, property.IsEnvironmentProperty);
+                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable);
                 _properties.Set(instance);
             }
         }
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index c6fd6293e5d..e935b611067 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -10,8 +10,6 @@
 using Microsoft.Build.BackEnd;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -86,21 +84,8 @@ public string EvaluatedValue
         /// Setter assumes caller has protected global properties, if necessary.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        string IProperty.EvaluatedValueEscaped
-        {
-            get
-            {
-                if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty)
-                {
-                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);
-                    args.BuildEventContext = envProperty.loggingContext.BuildEventContext;
-                    envProperty.loggingContext.LogBuildEvent(args);
-                    envProperty._loggedEnvProperty = true;
-                }
-
-                return _escapedValue;
-            }
-        }
+        string IProperty.EvaluatedValueEscaped => _escapedValue;
+
         /// <summary>
         /// Implementation of IKeyed exposing the property name
         /// </summary>
@@ -197,9 +182,9 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue,
         /// This flags should ONLY be set by the evaluator or by cloning; after the ProjectInstance is created, they must be illegal.
         /// If name is invalid or reserved, throws ArgumentException.
         /// </summary>
-        internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable, bool isEnvironmentProperty = false, LoggingContext loggingContext = null)
+        internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable)
         {
-            return Create(name, escapedValue, mayBeReserved, null, isImmutable, isEnvironmentProperty, loggingContext);
+            return Create(name, escapedValue, mayBeReserved, null, isImmutable);
         }
 
         /// <summary>
@@ -227,7 +212,7 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue,
         /// </summary>
         internal static ProjectPropertyInstance Create(ProjectPropertyInstance that)
         {
-            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: that.IsImmutable, that is EnvironmentDerivedProjectPropertyInstance);
+            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: that.IsImmutable);
         }
 
         /// <summary>
@@ -236,7 +221,7 @@ internal static ProjectPropertyInstance Create(ProjectPropertyInstance that)
         /// </summary>
         internal static ProjectPropertyInstance Create(ProjectPropertyInstance that, bool isImmutable)
         {
-            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: isImmutable, that is EnvironmentDerivedProjectPropertyInstance);
+            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: isImmutable);
         }
 
         /// <summary>
@@ -293,7 +278,7 @@ internal ProjectPropertyElement ToProjectPropertyElement(ProjectElementContainer
         /// as it should never be needed for any subsequent messages, and is just extra bulk.
         /// Inherits mutability from project if any.
         /// </summary>
-        private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable, bool isEnvironmentProperty = false, LoggingContext loggingContext = null)
+        private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable)
         {
             // Does not check immutability as this is only called during build (which is already protected) or evaluation
             ErrorUtilities.VerifyThrowArgumentNull(escapedValue, nameof(escapedValue));
@@ -310,10 +295,11 @@ private static ProjectPropertyInstance Create(string name, string escapedValue,
                 XmlUtilities.VerifyThrowProjectValidElementName(name, location);
             }
 
-            ProjectPropertyInstance instance = isEnvironmentProperty ? new EnvironmentDerivedProjectPropertyInstance(name, escapedValue, loggingContext) :
-                isImmutable ? new ProjectPropertyInstanceImmutable(name, escapedValue) :
-                new ProjectPropertyInstance(name, escapedValue);
-            return instance;
+            if (isImmutable)
+            {
+                return new ProjectPropertyInstanceImmutable(name, escapedValue);
+            }
+            return new ProjectPropertyInstance(name, escapedValue);
         }
 
         /// <summary>
@@ -341,27 +327,5 @@ internal ProjectPropertyInstanceImmutable(string name, string escapedValue)
             /// </remarks>
             public override bool IsImmutable => true;
         }
-
-        internal class EnvironmentDerivedProjectPropertyInstance : ProjectPropertyInstance
-        {
-            internal EnvironmentDerivedProjectPropertyInstance(string name, string escapedValue, LoggingContext loggingContext)
-                : base(name, escapedValue)
-            {
-                this.loggingContext = loggingContext;
-            }
-
-            /// <summary>
-            /// Whether this object can be changed. An immutable object cannot be made mutable.
-            /// </summary>
-            /// <remarks>
-            /// The environment is captured at the start of the build, so environment-derived
-            /// properties can't change.
-            /// </remarks>
-            public override bool IsImmutable => true;
-
-            internal bool _loggedEnvProperty = false;
-
-            internal LoggingContext loggingContext;
-        }
     }
 }
diff --git a/src/Build/Instance/ReflectableTaskPropertyInfo.cs b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
index 571ba866933..66c846646dc 100644
--- a/src/Build/Instance/ReflectableTaskPropertyInfo.cs
+++ b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
@@ -52,6 +52,22 @@ internal ReflectableTaskPropertyInfo(PropertyInfo propertyInfo)
             _propertyInfo = propertyInfo;
         }
 
+        /// <summary>
+        /// Initializes a new <see cref="ReflectableTaskPropertyInfo"/> with three precomputed parameters. This is specifically
+        /// used with MetadataLoadContext, as these parameters cannot be computed for the property type passed in directly but
+        /// rather the relevant base type.
+        /// </summary>
+        internal ReflectableTaskPropertyInfo(PropertyInfo propertyInfo, bool output, bool required, bool isAssignableToITaskItemType)
+            : base(
+            propertyInfo.Name,
+            propertyInfo.PropertyType,
+            output,
+            required)
+        {
+            _propertyInfo = propertyInfo;
+            IsAssignableToITask = isAssignableToITaskItemType;
+        }
+
         /// <summary>
         /// Gets or sets the reflection-produced PropertyInfo.
         /// </summary>
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 37433613a00..bc191a256a9 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using System.Reflection;
 #if FEATURE_APPDOMAIN
 using System.Threading.Tasks;
@@ -149,14 +150,7 @@ public bool Initialize(string taskName, IDictionary<string, string> factoryIdent
         /// </summary>
         public TaskPropertyInfo[] GetTaskParameters()
         {
-            PropertyInfo[] infos = _loadedType.Type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
-            var propertyInfos = new TaskPropertyInfo[infos.Length];
-            for (int i = 0; i < infos.Length; i++)
-            {
-                propertyInfos[i] = new ReflectableTaskPropertyInfo(infos[i]);
-            }
-
-            return propertyInfos;
+            return _loadedType.Properties;
         }
 
         /// <summary>
@@ -279,7 +273,7 @@ string taskProjectFile
             {
                 ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
                 _taskName = taskName;
-                _loadedType = _typeLoader.Load(taskName, loadInfo);
+                _loadedType = _typeLoader.Load(taskName, loadInfo, _taskHostFactoryExplicitlyRequested);
                 ProjectErrorUtilities.VerifyThrowInvalidProject(_loadedType != null, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, String.Empty);
             }
             catch (TargetInvocationException e)
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index c7169a09dad..458c6956422 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -436,7 +436,7 @@ ElementLocation elementLocation
                         targetLoggingContext.LogComment(MessageImportance.Low, "TaskFoundFromFactory", taskName, taskFactory.Name);
                     }
 
-                    if (taskFactory.TaskFactoryLoadedType.HasSTAThreadAttribute())
+                    if (taskFactory.TaskFactoryLoadedType.HasSTAThreadAttribute)
                     {
                         targetLoggingContext.LogComment(MessageImportance.Low, "TaskNeedsSTA", taskName);
                     }
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 1089888ff12..e9db5412a24 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -4,14 +4,18 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -247,14 +251,7 @@ private void Write(BuildStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.BuildStarted);
             WriteBuildEventArgsFields(e);
-            if (Traits.Instance.LogAllEnvironmentVariables)
-            {
-                Write(e.BuildEnvironment);
-            }
-            else
-            {
-                Write(0);
-            }
+            Write(e.BuildEnvironment);
         }
 
         private void Write(BuildFinishedEventArgs e)
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index a449baea912..1f9b5eecf54 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -1204,21 +1204,16 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)
         /// </summary>
         private void PrintMessage(BuildMessageEventArgs e, bool lightenText)
         {
-            string nonNullMessage = null;
-
-            if (e is EnvironmentVariableReadEventArgs environmentPropertyReadEventArgs)
-            {
-                nonNullMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentPropertyReadEventArgs.EnvironmentVariableName, e.Message);
-            }
+            string nonNullMessage;
 
             // Include file information if present.
             if (e.File != null)
             {
-                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e), nonNullMessage);
+                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e));
             }
             else
             {
-                nonNullMessage ??= e.Message ?? string.Empty;
+                nonNullMessage = e.Message ?? string.Empty;
             }
 
             int prefixAdjustment = 0;
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 4404357b05e..e677526406b 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -511,15 +511,18 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                     setColor(ConsoleColor.DarkGray);
                 }
 
-                string nonNullMessage = e is EnvironmentVariableReadEventArgs environmentDerivedProperty ?
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentDerivedProperty.EnvironmentVariableName, e.Message)
-                    : e.Message ?? String.Empty;
+                string nonNullMessage;
 
                 // Include file information if present.
                 if (e.File != null)
                 {
                     nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile);
                 }
+                else
+                {
+                    // null messages are ok -- treat as blank line
+                    nonNullMessage = e.Message ?? String.Empty;
+                }
 
                 WriteLinePretty(nonNullMessage);
 
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 30c38da91e5..309d14bdc83 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -35,6 +35,7 @@
     <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
+    <PackageReference Include="System.Reflection.MetadataLoadContext" />
 
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
   </ItemGroup>
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
index ecaad75bd4e..93740b15de2 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -1101,6 +1101,7 @@ Microsoft.Build.Execution.HostServices.GetNodeAffinity(string projectFile) -> Mi
 Microsoft.Build.Execution.HostServices.HostServices() -> void
 Microsoft.Build.Execution.HostServices.OnRenameProject(string oldFullPath, string newFullPath) -> void
 Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, Microsoft.Build.Framework.ITaskHost hostObject) -> void
+Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName) -> void
 Microsoft.Build.Execution.HostServices.SetNodeAffinity(string projectFile, Microsoft.Build.Execution.NodeAffinity nodeAffinity) -> void
 Microsoft.Build.Execution.HostServices.UnregisterProject(string projectFullPath) -> void
 Microsoft.Build.Execution.ITargetResult
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index e610ce450ea..e69de29bb2d 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1 +0,0 @@
-Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName) -> void
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index db8651cce57..10018e5f8f1 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -142,9 +142,6 @@
   <data name="WaitingForEndOfBuild" xml:space="preserve">
     <value>The operation cannot be completed because EndBuild has already been called but existing submissions have not yet completed.</value>
   </data>
-  <data name="EnvironmentDerivedPropertyRead">
-    <value>Property '{0}' with value '{1}' expanded from the environment.</value>
-  </data>
   <data name="SubmissionAlreadyComplete" xml:space="preserve">
     <value>The operation cannot be completed because the submission has already been executed.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 295e744c203..bc4f28a26e1 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: ZadanÃ½ vÃ½stupnÃ­ soubor mezipamÄti pro vÃ½sledky je prÃ¡zdnÃ½.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">ÄÃ­st promÄnnou prostÅedÃ­ {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 354bbd025b6..2d5371cd4e4 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: Die angegebene Cachedatei fÃ¼r Ausgabeergebnisse ist leer.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Umgebungsvariable "{0}" lesen</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 0ff85f2cfc1..ae8a6a1e189 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: El archivo de cachÃ© de resultados de salida especificado estÃ¡ vacÃ­o.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Leer la variable de entorno "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index bd86334a1d6..0ffddfbe011 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: Le fichier cache des rÃ©sultats de sortie spÃ©cifiÃ© est vide.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Lire la variable d'environnement "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index b3ffd7d5a8f..11aec49efc6 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: il file della cache dei risultati di output specificato Ã¨ vuoto.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Legge la variabile di ambiente "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 20194a207f9..1bf7a2f0d24 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: æå®ãããåºåçµæã­ã£ãã·ã¥ ãã¡ã¤ã«ã¯ç©ºã§ãã</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">ç°å¢å¤æ° "{0}" ã®èª­ã¿åã</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 64edef66ee4..8f5d34f5cce 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: ì§ì í ì¶ë ¥ ê²°ê³¼ ìºì íì¼ì´ ë¹ì´ ììµëë¤.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">íê²½ ë³ì "{0}" ì½ê¸°</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index ef425e1af33..b893482a44e 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: OkreÅlony plik wyjÅciowej pamiÄci podrÄcznej wynikÃ³w jest pusty.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Odczytaj zmiennÄ ÅrodowiskowÄ â{0}â</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 57edd51b8b6..ad14ba37ca1 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: o arquivo de cache do resultado de saÃ­da especificado estÃ¡ vazio.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Ler a variÃ¡vel de ambiente "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 9355b218d8e..04004fbdfe1 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹ Ð²ÑÑÐ¾Ð´Ð½Ð¾Ð¹ ÑÐ°Ð¹Ð» ÐºÑÑÐ° ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ¾Ð² Ð¿ÑÑÑÐ¾Ð¹.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Ð§ÑÐµÐ½Ð¸Ðµ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ ÑÑÐµÐ´Ñ "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 439af5cefad..5fc8f54ba4e 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: Belirtilen Ã§Ä±kÄ±Å sonucu Ã¶nbellek dosyasÄ± boÅ.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">"{0}" ortam deÄiÅkenini oku</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index ca550fb5c8d..4a9d18a374e 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: æå®çè¾åºç»æç¼å­æä»¶ä¸ºç©ºã</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">è¯»åç¯å¢åéâ{0}â</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index f1f0c28e519..214240db01c 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: æå®çè¼¸åºçµæå¿«åæªæ¡æ¯ç©ºçã</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">è®åç°å¢è®æ¸ "{0}"</target>
diff --git a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
index eca867cd1cc..2bf43e98406 100644
--- a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
@@ -27,7 +27,7 @@ public void EventArgsCtors()
             buildFinishedEvent = new BuildFinishedEventArgs("{0}", "HelpKeyword", true, new DateTime(), "Message");
             buildFinishedEvent = new BuildFinishedEventArgs(null, null, true);
             buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime());
-            buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime(), messageArgs: null);
+            buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime(), null);
         }
 
         /// <summary>
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index f2f4cc9070f..e169219952d 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -623,6 +623,30 @@ public void SdkResolverServiceLoadResolversStop(string manifestName, int resolve
             WriteEvent(84, manifestName, resolverCount);
         }
 
+        [Event(85, Keywords = Keywords.All)]
+        public void CreateLoadedTypeStart(string assemblyName)
+        {
+            WriteEvent(85, assemblyName);
+        }
+
+        [Event(86, Keywords = Keywords.All)]
+        public void CreateLoadedTypeStop(string assemblyName)
+        {
+            WriteEvent(86, assemblyName);
+        }
+
+        [Event(87, Keywords = Keywords.All)]
+        public void LoadAssemblyAndFindTypeStart()
+        {
+            WriteEvent(87);
+        }
+
+        [Event(88, Keywords = Keywords.All)]
+        public void LoadAssemblyAndFindTypeStop(string assemblyPath, int numberOfPublicTypesSearched)
+        {
+            WriteEvent(88, assemblyPath, numberOfPublicTypesSearched);
+        }
+
         #endregion
     }
 }
diff --git a/src/Framework/TaskPropertyInfo.cs b/src/Framework/TaskPropertyInfo.cs
index 449354b5e43..3d06ce4d747 100644
--- a/src/Framework/TaskPropertyInfo.cs
+++ b/src/Framework/TaskPropertyInfo.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Reflection;
 
 #nullable disable
 
@@ -26,6 +27,9 @@ public TaskPropertyInfo(string name, Type typeOfParameter, bool output, bool req
             PropertyType = typeOfParameter;
             Output = output;
             Required = required;
+            Type elementType = typeOfParameter.IsArray ? typeOfParameter.GetElementType() : typeOfParameter;
+            IsValueTypeOutputParameter = elementType.GetTypeInfo().IsValueType || elementType.FullName.Equals("System.String");
+            IsAssignableToITask = typeof(ITaskItem).IsAssignableFrom(elementType);
         }
 
         /// <summary>
@@ -62,5 +66,8 @@ public TaskPropertyInfo(string name, Type typeOfParameter, bool output, bool req
         /// Whether the Log and LogItemMetadata properties have been assigned already.
         /// </summary>
         internal bool Initialized = false;
+
+        internal bool IsValueTypeOutputParameter { get; private set; }
+        internal bool IsAssignableToITask { get; set; }
     }
 }
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index 23735453ed0..cf60eb140c9 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -91,15 +92,6 @@ public Traits()
         /// </summary>
         public readonly bool LogPropertyFunctionsRequiringReflection = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection"));
 
-        /// <summary>
-        /// Log all environment variables whether or not they are used in a build in the binary log.
-        /// </summary>
-        public bool LogAllEnvironmentVariables => string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDONLYLOGUSEDENVIRONMENTVARIABLES"))
-#if !TASKHOST
-            && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4)
-#endif
-            ;
-
         /// <summary>
         /// Log property tracking information.
         /// </summary>
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index b94a19f997d..a6e2e036e5e 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -76,6 +76,7 @@
       <Link>FileUtilities.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Build\Instance\ReflectableTaskPropertyInfo.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <Link>FileUtilitiesRegex.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 132326e7230..68a92c2f0a5 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1958,7 +1958,7 @@ elementFormDefault="qualified">
         <xs:documentation><!-- _locID_text="PreserveCompilationContext" _locComment="" -->Value indicating whether reference assemblies can be used in dynamic compilation</xs:documentation>
       </xs:annotation>
     </xs:element>
-    <xs:element name="ProduceReferenceAssemblies" type="msb:boolean" substitutionGroup="msb:Property" />
+    <xs:element name="ProduceReferenceAssembly" type="msb:boolean" substitutionGroup="msb:Property" />
     <xs:element name="ProductName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ProductVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ProjectGuid" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index adb4e7931cc..10655f84b09 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -115,7 +115,7 @@ IDictionary<string, TaskParameter> taskParams
             try
             {
                 TypeLoader typeLoader = new TypeLoader(TaskLoader.IsTaskClass);
-                taskType = typeLoader.Load(taskName, AssemblyLoadInfo.Create(null, taskLocation));
+                taskType = typeLoader.Load(taskName, AssemblyLoadInfo.Create(null, taskLocation), false);
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
@@ -133,7 +133,7 @@ IDictionary<string, TaskParameter> taskParams
             }
 
             OutOfProcTaskHostTaskResult taskResult;
-            if (taskType.HasSTAThreadAttribute())
+            if (taskType.HasSTAThreadAttribute)
             {
 #if FEATURE_APARTMENT_STATE
                 taskResult = InstantiateAndExecuteTaskInSTAThread(oopTaskHostNode, taskType, taskName, taskLocation, taskFile, taskLine, taskColumn,
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 941490997b3..4cdef2986d2 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -91,6 +91,16 @@
           <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
           <codeBase version="4.1.4.0" href="..\System.Numerics.Vectors.dll"/>
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Reflection.Metadata.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index ad07688b88f..3f412c2716a 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -68,6 +68,14 @@
           <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index ec7f04055ae..beca5404f56 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+ï»¿<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -39,10 +39,6 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
-    <!-- EnvironmentVariableReadEventArgs shouldn't be used in TaskHosts, but it means we need fewer ifdefs. -->
-    <Compile Include="..\Framework\EnvironmentVariableReadEventArgs.cs">
-      <Link>EnvironmentVariableReadEventArgs.cs</Link>
-    </Compile>
     <Compile Include="..\Framework\BuildEnvironmentState.cs">
       <Link>BuildEnvironmentState.cs</Link>
     </Compile>
diff --git a/src/MSBuildTaskHost/TypeLoader.cs b/src/MSBuildTaskHost/TypeLoader.cs
index 5b4833472c4..8b749fe1d72 100644
--- a/src/MSBuildTaskHost/TypeLoader.cs
+++ b/src/MSBuildTaskHost/TypeLoader.cs
@@ -126,11 +126,13 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
         /// Loads the specified type if it exists in the given assembly. If the type name is fully qualified, then a match (if
         /// any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type
         /// found will be returned.
+        /// The unusued bool is to match the signature of the Shared copy of TypeLoader.
         /// </summary>
         internal LoadedType Load
         (
             string typeName,
-            AssemblyLoadInfo assembly
+            AssemblyLoadInfo assembly,
+            bool _
         )
         {
             return GetLoadedType(s_cacheOfLoadedTypesByFilter, typeName, assembly);
@@ -284,7 +286,7 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)
                     return null;
                 });
 
-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;
+                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly ?? type.Assembly) : null;
             }
 
             /// <summary>
diff --git a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
index 37d86a19b97..dbdb1d17ad5 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
+++ b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
@@ -47,28 +47,28 @@ folder InstallDir:\MSBuild\Current\Bin\arm64\MSBuild
   file source=$(Arm64BinPath)\MSBuild\Microsoft.Build.CommonTypes.xsd
 
 folder InstallDir:\MSBuild\Current\Bin\arm64\cs
-  file source=$(Arm64BinPath)cs\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)cs\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\de
-  file source=$(Arm64BinPath)de\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)de\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\es
-  file source=$(Arm64BinPath)es\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)es\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\fr
-  file source=$(Arm64BinPath)fr\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)fr\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\it
-  file source=$(Arm64BinPath)it\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)it\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ja
-  file source=$(Arm64BinPath)ja\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)ja\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ko
-  file source=$(Arm64BinPath)ko\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)ko\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\pl
-  file source=$(Arm64BinPath)pl\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)pl\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\pt-BR
-  file source=$(Arm64BinPath)pt-BR\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)pt-BR\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ru
-  file source=$(Arm64BinPath)ru\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)ru\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\tr
-  file source=$(Arm64BinPath)tr\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)tr\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hans
-  file source=$(Arm64BinPath)zh-Hans\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)zh-Hans\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hant
-  file source=$(Arm64BinPath)zh-Hant\MSBuild.resources.dll vs.file.ngenArchitecture=all
\ No newline at end of file
+  file source=$(Arm64BinPath)zh-Hant\MSBuild.resources.dll
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 793a3d5be1c..8f326c34c2f 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -40,6 +40,8 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -92,83 +94,83 @@ folder InstallDir:\MSBuild\Current\Bin\SdkResolvers\Microsoft.Build.NuGetSdkReso
   file source=$(SourceDir)MSBuild\SdkResolvers\VS\Microsoft.Build.NuGetSdkResolver.xml
 
 folder InstallDir:\MSBuild\Current\Bin\cs
-  file source=$(X86BinPath)cs\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)cs\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)cs\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)cs\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)cs\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)cs\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)cs\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)cs\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)cs\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)cs\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\de
-  file source=$(X86BinPath)de\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)de\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)de\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)de\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)de\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)de\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)de\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)de\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)de\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)de\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\es
-  file source=$(X86BinPath)es\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)es\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)es\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)es\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)es\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)es\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)es\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)es\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)es\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)es\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\fr
-  file source=$(X86BinPath)fr\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)fr\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)fr\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)fr\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)fr\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)fr\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)fr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)fr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)fr\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)fr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\it
-  file source=$(X86BinPath)it\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)it\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)it\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)it\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)it\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)it\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)it\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)it\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)it\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)it\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\ja
-  file source=$(X86BinPath)ja\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ja\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ja\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ja\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)ja\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)ja\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)ja\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)ja\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)ja\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)ja\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\ko
-  file source=$(X86BinPath)ko\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ko\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ko\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ko\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)ko\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)ko\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)ko\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)ko\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)ko\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)ko\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\pl
-  file source=$(X86BinPath)pl\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pl\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pl\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pl\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)pl\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)pl\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)pl\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)pl\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)pl\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)pl\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\pt-BR
-  file source=$(X86BinPath)pt-BR\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pt-BR\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pt-BR\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pt-BR\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)pt-BR\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)pt-BR\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)pt-BR\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)pt-BR\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)pt-BR\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)pt-BR\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\ru
-  file source=$(X86BinPath)ru\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ru\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ru\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ru\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)ru\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)ru\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)ru\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)ru\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)ru\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)ru\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\tr
-  file source=$(X86BinPath)tr\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)tr\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)tr\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)tr\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)tr\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)tr\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)tr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)tr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)tr\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)tr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\zh-Hans
-  file source=$(X86BinPath)zh-Hans\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hans\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hans\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hans\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)zh-Hans\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)zh-Hans\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)zh-Hans\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)zh-Hans\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)zh-Hans\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)zh-Hans\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\zh-Hant
-  file source=$(X86BinPath)zh-Hant\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hant\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hant\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hant\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)zh-Hant\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)zh-Hant\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)zh-Hant\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)zh-Hant\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)zh-Hant\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)zh-Hant\MSBuildTaskHost.resources.dll
 
 folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X64BinPath)MSBuild.exe vs.file.ngenArchitecture=x64
@@ -185,6 +187,8 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenArchitecture=all
@@ -231,83 +235,83 @@ folder InstallDir:\MSBuild\Current\Bin\amd64\MSBuild
   file source=$(X86BinPath)\MSBuild\Microsoft.Build.CommonTypes.xsd
 
 folder InstallDir:\MSBuild\Current\Bin\amd64\cs
-  file source=$(X64BinPath)cs\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)cs\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)cs\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)cs\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)cs\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)cs\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)cs\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)cs\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)cs\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)cs\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\de
-  file source=$(X64BinPath)de\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)de\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)de\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)de\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)de\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)de\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)de\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)de\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)de\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)de\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\es
-  file source=$(X64BinPath)es\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)es\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)es\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)es\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)es\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)es\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)es\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)es\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)es\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)es\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\fr
-  file source=$(X64BinPath)fr\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)fr\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)fr\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)fr\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)fr\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)fr\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)fr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)fr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)fr\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)fr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\it
-  file source=$(X64BinPath)it\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)it\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)it\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)it\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)it\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)it\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)it\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)it\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)it\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)it\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\ja
-  file source=$(X64BinPath)ja\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ja\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ja\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ja\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)ja\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)ja\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)ja\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)ja\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)ja\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)ja\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\ko
-  file source=$(X64BinPath)ko\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ko\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ko\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ko\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)ko\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)ko\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)ko\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)ko\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)ko\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)ko\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\pl
-  file source=$(X64BinPath)pl\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pl\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pl\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pl\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)pl\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)pl\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)pl\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)pl\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)pl\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)pl\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\pt-BR
-  file source=$(X64BinPath)pt-BR\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pt-BR\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pt-BR\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pt-BR\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)pt-BR\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)pt-BR\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)pt-BR\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)pt-BR\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)pt-BR\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)pt-BR\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\ru
-  file source=$(X64BinPath)ru\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ru\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ru\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ru\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)ru\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)ru\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)ru\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)ru\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)ru\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)ru\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\tr
-  file source=$(X64BinPath)tr\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)tr\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)tr\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)tr\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)tr\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)tr\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)tr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)tr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)tr\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)tr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hans
-  file source=$(X64BinPath)zh-Hans\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hans\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hans\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hans\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)zh-Hans\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)zh-Hans\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)zh-Hans\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)zh-Hans\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)zh-Hans\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)zh-Hans\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hant
-  file source=$(X64BinPath)zh-Hant\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hant\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hant\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hant\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)zh-Hant\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)zh-Hant\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)zh-Hant\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)zh-Hant\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll
 
 folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
   file source=$(SourceDir)Package\MSBuild.VSSetup\MSBuild.clientenabledpkg
diff --git a/src/Shared/EnvironmentUtilities.cs b/src/Shared/EnvironmentUtilities.cs
index 01cf349f2f8..e9e0482619f 100644
--- a/src/Shared/EnvironmentUtilities.cs
+++ b/src/Shared/EnvironmentUtilities.cs
@@ -4,6 +4,8 @@
 using System;
 using System.Runtime.InteropServices;
 
+#nullable disable
+
 namespace Microsoft.Build.Shared
 {
     internal static partial class EnvironmentUtilities
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index 7c0db803f70..e3bcdf9fcba 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -53,11 +53,10 @@ internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProj
         /// <param name="e">Message to format</param>
         /// <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
         /// <param name="projectConfigurationDescription">Properties to Print along with message</param>
-        /// <param name="nonNullMessage">The complete message (including property name) for an environment-derived property</param>
         /// <returns>The formatted message string.</returns>
-        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription, string nonNullMessage = null)
+        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription)
         {
-            return FormatEventMessage("message", e.Subcategory, nonNullMessage ?? e.Message,
+            return FormatEventMessage("message", e.Subcategory, e.Message,
                             e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber,
                             e.ColumnNumber, e.EndColumnNumber, e.ThreadId, projectConfigurationDescription);
         }
@@ -145,14 +144,13 @@ internal static string FormatEventMessage(BuildMessageEventArgs e)
         /// </summary>
         /// <param name="e">Message to format</param>
         /// <param name="showProjectFile">Show project file or not</param>
-        /// <param name="nonNullMessage">For an EnvironmentVariableReadEventArgs, adds an explanatory note and the name of the variable.</param>
         /// <returns>The formatted message string.</returns>
-        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string nonNullMessage = null)
+        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             // "message" should not be localized
-            return FormatEventMessage("message", e.Subcategory, nonNullMessage ?? e.Message,
+            return FormatEventMessage("message", e.Subcategory, e.Message,
                 e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber, e.ColumnNumber, e.EndColumnNumber, e.ThreadId, null);
         }
 
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 9628a41db61..da24b87b134 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -174,6 +174,8 @@ internal static bool CanWriteToDirectory(string directory)
             try
             {
                 string testFilePath = Path.Combine(directory, $"MSBuild_{Guid.NewGuid().ToString("N")}_testFile.txt");
+                FileInfo file = new(testFilePath);
+                file.Directory.Create(); // If the directory already exists, this method does nothing.
                 File.WriteAllText(testFilePath, $"MSBuild process {Process.GetCurrentProcess().Id} successfully wrote to file.");
                 File.Delete(testFilePath);
                 return true;
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index eeae7eb79ab..a929313f47d 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -2,7 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Generic;
+using System.Linq;
 using System.Reflection;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 
 #nullable disable
@@ -15,15 +19,7 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal sealed class LoadedType
     {
-        #region Constructors
-
-        /// <summary>
-        /// Creates an instance of this class for the given type.
-        /// </summary>
-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo)
-            : this(type, assemblyLoadInfo, null)
-        {
-        }
+        #region Constructor
 
         /// <summary>
         /// Creates an instance of this class for the given type.
@@ -31,75 +27,141 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo)
         /// <param name="type">The Type to be loaded</param>
         /// <param name="assemblyLoadInfo">Information used to load the assembly</param>
         /// <param name="loadedAssembly">The assembly which has been loaded, if any</param>
-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly)
+        /// <param name="loadedViaMetadataLoadContext">Whether this type was loaded via MetadataLoadContext</param>
+        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly, bool loadedViaMetadataLoadContext = false)
         {
             ErrorUtilities.VerifyThrow(type != null, "We must have the type.");
             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, "We must have the assembly the type was loaded from.");
+            ErrorUtilities.VerifyThrow(loadedAssembly is not null, "The assembly should always be loaded even if only by MetadataLoadContext.");
+
+            Type = type;
+            Assembly = assemblyLoadInfo;
+
+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();
+            LoadedAssemblyName = loadedAssembly.GetName();
+            Path = loadedAssembly.Location;
+            LoadedAssembly = loadedAssembly;
+
+#if !NET35
+            // Properties set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the
+            // properties and reflect over them without needing them to be fully loaded, so it also isn't need for TaskHosts.
+            // MetadataLoadContext-loaded Type objects don't support testing for inherited attributes, so we manually walk the BaseType chain.
+            Type t = type;
+            while (t is not null)
+            {
+                if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(LoadInSeparateAppDomainAttribute))))
+                {
+                    HasLoadInSeparateAppDomainAttribute = true;
+                }
+
+                if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(RunInSTAAttribute))))
+                {
+                    HasSTAThreadAttribute = true;
+                }
+
+                if (t.IsMarshalByRef)
+                {
+                    IsMarshalByRef = true;
+                }
+
+                t = t.BaseType;
+            }
+
+            PropertyInfo[] props = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
+            Properties = new ReflectableTaskPropertyInfo[props.Length];
+            if (loadedViaMetadataLoadContext)
+            {
+                PropertyAssemblyQualifiedNames = new string[props.Length];
+            }
 
-            _type = type;
-            _assembly = assemblyLoadInfo;
-            _loadedAssembly = loadedAssembly;
+            for (int i = 0; i < props.Length; i++)
+            {
+                bool outputAttribute = false;
+                bool requiredAttribute = false;
+                foreach (CustomAttributeData attr in CustomAttributeData.GetCustomAttributes(props[i]))
+                {
+                    if (attr.AttributeType.Name.Equals(nameof(OutputAttribute)))
+                    {
+                        outputAttribute = true;
+                    }
+                    else if (attr.AttributeType.Name.Equals(nameof(RequiredAttribute)))
+                    {
+                        requiredAttribute = true;
+                    }
+                }
+
+                bool isAssignableToITask = false;
+
+                // Check whether it's assignable to ITaskItem or ITaskItem[]. Simplify to just checking for ITaskItem.
+                Type pt = props[i].PropertyType;
+                if (pt.IsArray)
+                {
+                    pt = pt.GetElementType();
+                }
+
+                // Microsoft.Build.Framework.ITaskItem is different when loaded normally versus via MetadataLoadContext. This is the only reliable way to see
+                // whether this property derives from ITaskItem.
+                while (pt is not null)
+                {
+                    if (pt.FullName.Equals("Microsoft.Build.Framework.ITaskItem"))
+                    {
+                        isAssignableToITask = true;
+                        break;
+                    }
+                    else
+                    {
+                        pt = pt.BaseType;
+                    }
+                }
 
-            CheckForHardcodedSTARequirement();
-            HasLoadInSeparateAppDomainAttribute();
-            HasSTAThreadAttribute();
+                Properties[i] = new ReflectableTaskPropertyInfo(props[i], outputAttribute, requiredAttribute, isAssignableToITask);
+                if (loadedViaMetadataLoadContext)
+                {
+                    PropertyAssemblyQualifiedNames[i] = Properties[i].PropertyType.AssemblyQualifiedName;
+                }
+            }
+#endif
         }
 
 
         #endregion
 
-        #region Methods
         /// <summary>
         /// Gets whether there's a LoadInSeparateAppDomain attribute on this type.
-        /// Caches the result - since it can't change during the build.
         /// </summary>
-        /// <returns></returns>
-        public bool HasLoadInSeparateAppDomainAttribute()
-        {
-            if (_hasLoadInSeparateAppDomainAttribute == null)
-            {
-                _hasLoadInSeparateAppDomainAttribute = this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */);
-            }
-
-            return (bool)_hasLoadInSeparateAppDomainAttribute;
-        }
+        public bool HasLoadInSeparateAppDomainAttribute { get; }
 
         /// <summary>
         /// Gets whether there's a STAThread attribute on the Execute method of this type.
-        /// Caches the result - since it can't change during the build.
         /// </summary>
-        /// <returns></returns>
-        public bool HasSTAThreadAttribute()
-        {
-            if (_hasSTAThreadAttribute == null)
-            {
-                _hasSTAThreadAttribute = this.Type.GetTypeInfo().IsDefined(typeof(RunInSTAAttribute), true /* inherited */);
-            }
-
-            return (bool)_hasSTAThreadAttribute;
-        }
+        public bool HasSTAThreadAttribute { get; }
 
-        #endregion
+        /// <summary>
+        /// Gets whether this type implements MarshalByRefObject.
+        /// </summary>
+        public bool IsMarshalByRef { get; }
 
         /// <summary>
         /// Determines if the task has a hardcoded requirement for STA thread usage.
         /// </summary>
-        private void CheckForHardcodedSTARequirement()
+        private bool CheckForHardcodedSTARequirement()
         {
             // Special hard-coded attributes for certain legacy tasks which need to run as STA because they were written before
             // we changed to running all tasks in MTA.
-            if (String.Equals("Microsoft.Build.Tasks.Xaml.PartialClassGenerationTask", _type.FullName, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals("Microsoft.Build.Tasks.Xaml.PartialClassGenerationTask", Type.FullName, StringComparison.OrdinalIgnoreCase))
             {
-                AssemblyName assemblyName = _type.GetTypeInfo().Assembly.GetName();
+                AssemblyName assemblyName = Type.GetTypeInfo().Assembly.GetName();
                 Version lastVersionToForce = new Version(3, 5);
                 if (assemblyName.Version.CompareTo(lastVersionToForce) > 0)
                 {
                     if (String.Equals(assemblyName.Name, "PresentationBuildTasks", StringComparison.OrdinalIgnoreCase))
                     {
-                        _hasSTAThreadAttribute = true;
+                        return true;
                     }
                 }
             }
+
+            return false;
         }
 
         #region Properties
@@ -108,55 +170,33 @@ private void CheckForHardcodedSTARequirement()
         /// Gets the type that was loaded from an assembly.
         /// </summary>
         /// <value>The loaded type.</value>
-        internal Type Type
-        {
-            get
-            {
-                return _type;
-            }
-        }
+        internal Type Type { get; private set; }
+
+        internal AssemblyName LoadedAssemblyName { get; private set; }
+
+        internal string Path { get; private set; }
 
         /// <summary>
         /// If we loaded an assembly for this type.
         /// We use this information to help created AppDomains to resolve types that it could not load successfully
         /// </summary>
-        internal Assembly LoadedAssembly
-        {
-            get
-            {
-                return _loadedAssembly;
-            }
-        }
+        internal Assembly LoadedAssembly { get; private set; }
+
+#if !NET35
+        internal ReflectableTaskPropertyInfo[] Properties { get; private set; }
+#endif
+
+        /// <summary>
+        /// Assembly-qualified names for properties. Only has a value if this type was loaded using MetadataLoadContext.
+        /// </summary>
+        internal string[] PropertyAssemblyQualifiedNames { get; private set; }
 
         /// <summary>
         /// Gets the assembly the type was loaded from.
         /// </summary>
         /// <value>The assembly info for the loaded type.</value>
-        internal AssemblyLoadInfo Assembly
-        {
-            get
-            {
-                return _assembly;
-            }
-        }
+        internal AssemblyLoadInfo Assembly { get; private set; }
 
         #endregion
-
-        // the type that was loaded
-        private Type _type;
-        // the assembly the type was loaded from
-        private AssemblyLoadInfo _assembly;
-
-        // whether the loadinseparateappdomain attribute is applied to this type
-        private bool? _hasLoadInSeparateAppDomainAttribute;
-
-        // whether the STAThread attribute is applied to this type
-        private bool? _hasSTAThreadAttribute;
-
-        /// <summary>
-        /// Assembly, if any, that we loaded for this type.
-        /// We use this information to help created AppDomains to resolve types that it could not load successfully
-        /// </summary>
-        private Assembly _loadedAssembly;
     }
 }
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index bd010ed294f..7e592d7513d 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -130,11 +130,6 @@ internal enum LoggingEventType : int
         /// Event is a TelemetryEventArgs
         /// </summary>
         Telemetry = 18,
-
-        /// <summary>
-        /// Event is an EnvironmentVariableReadEventArgs
-        /// </summary>
-        EnvironmentVariableReadEvent = 19,
     }
     #endregion
 
@@ -328,8 +323,7 @@ internal void WriteToStream(ITranslator translator)
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
                 if (_buildEvent is ProjectEvaluationStartedEventArgs ||
-                    _buildEvent is ProjectEvaluationFinishedEventArgs ||
-                    _buildEvent is EnvironmentVariableReadEventArgs)
+                    _buildEvent is ProjectEvaluationFinishedEventArgs)
                 {
                     // switch to serialization methods that we provide in this file
                     // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
@@ -409,7 +403,6 @@ internal void ReadFromStream(ITranslator translator)
                 else
                 {
                     _buildEvent = ReadEventFromStream(_eventType, translator);
-                    ErrorUtilities.VerifyThrow(_buildEvent is not null, "Not Supported LoggingEventType {0}", _eventType.ToString());
                 }
             }
             else
@@ -516,7 +509,6 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.TaskStartedEvent => new TaskStartedEventArgs(null, null, null, null, null),
                 LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
                 LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
-                LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
                 LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
                 LoggingEventType.ProjectEvaluationStartedEvent => new ProjectEvaluationStartedEventArgs(),
@@ -615,10 +607,6 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildErrorEvent;
             }
-            else if (eventType == typeof(EnvironmentVariableReadEventArgs))
-            {
-                return LoggingEventType.EnvironmentVariableReadEvent;
-            }
             else
             {
                 return LoggingEventType.CustomEvent;
@@ -673,29 +661,12 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
                 case LoggingEventType.ProjectFinishedEvent:
                     WriteExternalProjectFinishedEventToStream((ExternalProjectFinishedEventArgs)buildEvent, translator);
                     break;
-                case LoggingEventType.EnvironmentVariableReadEvent:
-                    WriteEnvironmentVariableReadEventArgs((EnvironmentVariableReadEventArgs)buildEvent, translator);
-                    break;
                 default:
                     ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
                     break;
             }
         }
 
-        /// <summary>
-        /// Serializes EnvironmentVariableRead Event argument to the stream. Does not work properly on TaskHosts due to BuildEventContext serialization not being
-        /// enabled on TaskHosts, but that shouldn't matter, as this should never be called from a TaskHost anyway.
-        /// </summary>
-        private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator)
-        {
-            string name = environmentVariableReadEventArgs.EnvironmentVariableName;
-            translator.Translate(ref name);
-            BuildEventContext context = environmentVariableReadEventArgs.BuildEventContext;
-#if !CLR2COMPATIBILITY
-            translator.Translate(ref context);
-#endif
-        }
-
         /// <summary>
         /// Serialize ExternalProjectFinished Event Argument to the stream
         /// </summary>
@@ -1030,33 +1001,33 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
             translator.Translate(ref helpKeyword);
             translator.Translate(ref senderName);
 
-            return eventType switch
+            BuildEventArgs buildEvent = null;
+            switch (eventType)
             {
-                LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),
-                _ => null,
-            };
-        }
+                case LoggingEventType.TaskCommandLineEvent:
+                    buildEvent = ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                case LoggingEventType.BuildErrorEvent:
+                    buildEvent = ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                case LoggingEventType.ProjectStartedEvent:
+                    buildEvent = ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                case LoggingEventType.ProjectFinishedEvent:
+                    buildEvent = ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                case LoggingEventType.BuildMessageEvent:
+                    buildEvent = ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                case LoggingEventType.BuildWarningEvent:
+                    buildEvent = ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                default:
+                    ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
+                    break;
+            }
 
-        /// <summary>
-        /// Read and reconstruct an EnvironmentVariableReadEventArgs from the stream. This message should never be called from a TaskHost, so although the context translation does not work, that's ok.
-        /// </summary>
-        private EnvironmentVariableReadEventArgs ReadEnvironmentVariableReadEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
-        {
-            string environmentVariableName = null;
-            translator.Translate(ref environmentVariableName);
-            BuildEventContext context = null;
-#if !CLR2COMPATIBILITY
-            translator.Translate(ref context);
-#endif
-            EnvironmentVariableReadEventArgs args = new(environmentVariableName, message);
-            args.BuildEventContext = context;
-            return args;
+            return buildEvent;
         }
 
         /// <summary>
diff --git a/src/Shared/TaskLoader.cs b/src/Shared/TaskLoader.cs
index 0ab62f70203..f66497dc018 100644
--- a/src/Shared/TaskLoader.cs
+++ b/src/Shared/TaskLoader.cs
@@ -53,7 +53,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
             )
         {
 #if FEATURE_APPDOMAIN
-            bool separateAppDomain = loadedType.HasLoadInSeparateAppDomainAttribute();
+            bool separateAppDomain = loadedType.HasLoadInSeparateAppDomainAttribute;
             s_resolverLoadedType = null;
             taskAppDomain = null;
             ITask taskInstanceInOtherAppDomain = null;
@@ -64,7 +64,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
 #if FEATURE_APPDOMAIN
                 if (separateAppDomain)
                 {
-                    if (!loadedType.Type.GetTypeInfo().IsMarshalByRef)
+                    if (!loadedType.IsMarshalByRef)
                     {
                         logError
                         (
@@ -107,7 +107,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
 
                         if (loadedType.LoadedAssembly != null)
                         {
-                            taskAppDomain.Load(loadedType.LoadedAssembly.GetName());
+                            taskAppDomain.Load(loadedType.LoadedAssemblyName);
                         }
 
                         // Hook up last minute dumping of any exceptions 
@@ -176,13 +176,9 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
         /// </summary>
         internal static Assembly AssemblyResolver(object sender, ResolveEventArgs args)
         {
-            if ((s_resolverLoadedType?.LoadedAssembly != null))
+            if (args.Name.Equals(s_resolverLoadedType.LoadedAssemblyName.FullName, StringComparison.OrdinalIgnoreCase))
             {
-                // Match the name being requested by the resolver with the FullName of the assembly we have loaded
-                if (args.Name.Equals(s_resolverLoadedType.LoadedAssembly.FullName, StringComparison.Ordinal))
-                {
-                    return s_resolverLoadedType.LoadedAssembly;
-                }
+                return s_resolverLoadedType.LoadedAssembly ?? Assembly.Load(s_resolverLoadedType.Path);
             }
 
             return null;
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index fe5ea680c49..3f640e0ec0f 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -5,10 +5,14 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
 using System.IO;
 using System.Reflection;
+using System.Runtime.InteropServices;
+#if !NETFRAMEWORK
+using System.Runtime.Loader;
+#endif
 using System.Threading;
+using Microsoft.Build.Eventing;
 
 #nullable disable
 
@@ -41,6 +45,10 @@ internal class TypeLoader
         /// </summary>
         private Func<Type, object, bool> _isDesiredType;
 
+        private static MetadataLoadContext _context;
+
+        private static string[] runtimeAssemblies = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), "*.dll");
+
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -139,26 +147,20 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
         /// <returns></returns>
         private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)
         {
-            Assembly loadedAssembly = null;
-
             try
             {
                 if (assemblyLoadInfo.AssemblyName != null)
                 {
-#if !FEATURE_ASSEMBLYLOADCONTEXT
-                    loadedAssembly = Assembly.Load(assemblyLoadInfo.AssemblyName);
-#else
-                    loadedAssembly = Assembly.Load(new AssemblyName(assemblyLoadInfo.AssemblyName));
-#endif
+                    return Assembly.Load(assemblyLoadInfo.AssemblyName);
                 }
                 else
                 {
 #if !FEATURE_ASSEMBLYLOADCONTEXT
-                    loadedAssembly = Assembly.UnsafeLoadFrom(assemblyLoadInfo.AssemblyFile);
+                    return Assembly.UnsafeLoadFrom(assemblyLoadInfo.AssemblyFile);
 #else
-                    var baseDir = Path.GetDirectoryName(assemblyLoadInfo.AssemblyFile);
+                    string baseDir = Path.GetDirectoryName(assemblyLoadInfo.AssemblyFile);
                     s_coreClrAssemblyLoader.AddDependencyLocation(baseDir);
-                    loadedAssembly = s_coreClrAssemblyLoader.LoadFromPath(assemblyLoadInfo.AssemblyFile);
+                    return s_coreClrAssemblyLoader.LoadFromPath(assemblyLoadInfo.AssemblyFile);
 #endif
                 }
             }
@@ -169,8 +171,16 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)
                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again
                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);
             }
+        }
+
+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)
+        {
+            string path = assemblyLoadInfo.AssemblyFile;
+            List<string> localPaths = new(Directory.GetFiles(Path.GetDirectoryName(path), "*.dll"));
+            localPaths.AddRange(runtimeAssemblies);
 
-            return loadedAssembly;
+            _context = new(new PathAssemblyResolver(localPaths));
+            return _context.LoadFromAssemblyPath(path);
         }
 
         /// <summary>
@@ -181,10 +191,11 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)
         internal LoadedType Load
         (
             string typeName,
-            AssemblyLoadInfo assembly
+            AssemblyLoadInfo assembly,
+            bool useTaskHost = false
         )
         {
-            return GetLoadedType(s_cacheOfLoadedTypesByFilter, typeName, assembly);
+            return GetLoadedType(s_cacheOfLoadedTypesByFilter, typeName, assembly, useTaskHost);
         }
 
         /// <summary>
@@ -199,7 +210,7 @@ internal LoadedType ReflectionOnlyLoad
             AssemblyLoadInfo assembly
         )
         {
-            return GetLoadedType(s_cacheOfReflectionOnlyLoadedTypesByFilter, typeName, assembly);
+            return GetLoadedType(s_cacheOfReflectionOnlyLoadedTypesByFilter, typeName, assembly, useTaskHost: false);
         }
 
         /// <summary>
@@ -207,7 +218,7 @@ AssemblyLoadInfo assembly
         /// any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type
         /// found will be returned.
         /// </summary>
-        private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly)
+        private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly, bool useTaskHost)
         {
             // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which 
             // will map a specific AssemblyLoadInfo to a AssemblyInfoToLoadedTypes class which knows how to find a typeName in a given assembly.
@@ -218,7 +229,7 @@ private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>,
             AssemblyInfoToLoadedTypes typeNameToType =
                 loadInfoToType.GetOrAdd(assembly, (_) => new AssemblyInfoToLoadedTypes(_isDesiredType, _));
 
-            return typeNameToType.GetLoadedTypeByTypeName(typeName);
+            return typeNameToType.GetLoadedTypeByTypeName(typeName, useTaskHost);
         }
 
         /// <summary>
@@ -256,6 +267,8 @@ private class AssemblyInfoToLoadedTypes
             /// </summary>
             private Dictionary<string, Type> _publicTypeNameToType;
 
+            private ConcurrentDictionary<string, LoadedType> _publicTypeNameToLoadedType;
+
             /// <summary>
             /// Have we scanned the public types for this assembly yet.
             /// </summary>
@@ -278,19 +291,24 @@ internal AssemblyInfoToLoadedTypes(Func<Type, object, bool> typeFilter, Assembly
 
                 _isDesiredType = typeFilter;
                 _assemblyLoadInfo = loadInfo;
-                _typeNameToType = new ConcurrentDictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
+                _typeNameToType = new(StringComparer.OrdinalIgnoreCase);
                 _publicTypeNameToType = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
+                _publicTypeNameToLoadedType = new(StringComparer.OrdinalIgnoreCase);
             }
 
             /// <summary>
             /// Determine if a given type name is in the assembly or not. Return null if the type is not in the assembly
             /// </summary>
-            internal LoadedType GetLoadedTypeByTypeName(string typeName)
+            internal LoadedType GetLoadedTypeByTypeName(string typeName, bool useTaskHost)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(typeName, nameof(typeName));
 
-                // Only one thread should be doing operations on this instance of the object at a time.
+                if (useTaskHost && _assemblyLoadInfo.AssemblyFile is not null)
+                {
+                    return GetLoadedTypeFromTypeNameUsingMetadataLoadContext(typeName);
+                }
 
+                // Only one thread should be doing operations on this instance of the object at a time.
                 Type type = _typeNameToType.GetOrAdd(typeName, (key) =>
                 {
                     if ((_assemblyLoadInfo.AssemblyName != null) && (typeName.Length > 0))
@@ -336,14 +354,40 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)
                     return null;
                 });
 
-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;
+                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly ?? type.Assembly, loadedViaMetadataLoadContext: false) : null;
+            }
+
+            private LoadedType GetLoadedTypeFromTypeNameUsingMetadataLoadContext(string typeName)
+            {
+                return _publicTypeNameToLoadedType.GetOrAdd(typeName, typeName =>
+                {
+                    MSBuildEventSource.Log.LoadAssemblyAndFindTypeStart();
+                    Assembly loadedAssembly = LoadAssemblyUsingMetadataLoadContext(_assemblyLoadInfo);
+                    int numberOfTypesSearched = 0;
+                    foreach (Type publicType in loadedAssembly.GetExportedTypes())
+                    {
+                        numberOfTypesSearched++;
+                        if (_isDesiredType(publicType, null) && (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(publicType.FullName, typeName)))
+                        {
+                            MSBuildEventSource.Log.CreateLoadedTypeStart(loadedAssembly.FullName);
+                            LoadedType loadedType = new(publicType, _assemblyLoadInfo, loadedAssembly, loadedViaMetadataLoadContext: true);
+                            _context?.Dispose();
+                            _context = null;
+                            MSBuildEventSource.Log.CreateLoadedTypeStop(loadedAssembly.FullName);
+                            return loadedType;
+                        }
+                    }
+
+                    MSBuildEventSource.Log.LoadAssemblyAndFindTypeStop(_assemblyLoadInfo.AssemblyFile, numberOfTypesSearched);
+
+                    return null;
+                });
             }
 
             /// <summary>
             /// Scan the assembly pointed to by the assemblyLoadInfo for public types. We will use these public types to do partial name matching on 
             /// to find tasks, loggers, and task factories.
             /// </summary>
-            [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Reflection.Assembly.LoadFrom", Justification = "Necessary in this case.")]
             private void ScanAssemblyForPublicTypes()
             {
                 // we need to search the assembly for the type...
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 49e86433de5..6ede3f2d7fb 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -258,6 +258,17 @@ public TransientTestFile ExpectFile(string extension = ".tmp")
             return WithTransientTestState(new TransientTestFile(extension, createFile: false, expectedAsOutput: true));
         }
 
+        /// <summary>
+        /// Create a temp file name under a specific temporary folder. The file is expected to exist when the test completes.
+        /// </summary>
+        /// <param name="transientTestFolder">Temp folder</param>
+        /// <param name="extension">Extension of the file (defaults to '.tmp')</param>
+        /// <returns></returns>
+        public TransientTestFile ExpectFile(TransientTestFolder transientTestFolder, string extension = ".tmp")
+        {
+            return WithTransientTestState(new TransientTestFile(transientTestFolder.Path, extension, createFile: false, expectedAsOutput: true));
+        }
+
         /// <summary>
         ///     Creates a test variant used to add a unique temporary folder during a test. Will be deleted when the test
         ///     completes.
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index 15ac5335951..70ebb93fafe 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -10,8 +10,7 @@
     <PackageId>Microsoft.NET.StringTools</PackageId>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
 
-    <VersionPrefix>1.0.0</VersionPrefix>
-    <AssemblyVersion></AssemblyVersion>
+    <AssemblyVersion>1.0.0.0</AssemblyVersion>
     <SemanticVersioningV1>true</SemanticVersioningV1>
 
     <AssemblyName>Microsoft.NET.StringTools</AssemblyName>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 7819000499b..2512de4342c 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -4355,9 +4355,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems)"/>
     </ItemGroup>
 
-    <!-- For single file publish, we need to include the SF bundle EXE and files excluded from the bundle EXE in the clickonce manifest -->
+    <!-- For single file publish, we need to include the SF bundle EXE, application icon file and files excluded from the bundle EXE in the clickonce manifest -->
     <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
-      <_ClickOnceFiles Include="$(PublishedSingleFilePath)"/>
+      <_ClickOnceFiles Include="$(PublishedSingleFilePath);@(_DeploymentManifestIconFile)"/>
       <_ClickOnceFiles Include="@(_FilesExcludedFromBundle)"/>
 
       <!-- Include file association icons from Content as loose files -->
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
index 8f3cbf42ee6..942972d067e 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -1135,6 +1135,22 @@ Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion47Path.get -> string
 Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion48Path.get -> string
 Microsoft.Build.Tasks.GetFrameworkPath.GetFrameworkPath() -> void
 Microsoft.Build.Tasks.GetFrameworkPath.Path.get -> string
+Microsoft.Build.Tasks.GetInstalledSDKLocations
+Microsoft.Build.Tasks.GetInstalledSDKLocations.GetInstalledSDKLocations() -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.get -> string[]
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.get -> string[]
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.get -> string
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.get -> string
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.get -> bool
+Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.set -> void
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.get -> bool
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.set -> void
@@ -1151,6 +1167,39 @@ Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.get -> st
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.set -> void
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.get -> string
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles
+Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.GetSDKReferenceFiles() -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.RedistFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.get -> string[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.References.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.set -> void
 Microsoft.Build.Tasks.Hash
 Microsoft.Build.Tasks.Hash.Hash() -> void
 Microsoft.Build.Tasks.Hash.HashResult.get -> string
@@ -1279,6 +1328,26 @@ Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetPlatformWith32BitPreference(str
 Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetSubsystemVersion(string subsystemVersion) -> bool
 Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
 Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded.Compile() -> bool
+Microsoft.Build.Tasks.IFixedTypeInfo
+Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(object pUnkOuter, ref System.Guid riid, out object ppvObj) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(out System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, out int pIndex) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, System.IntPtr pBstrDllName, System.IntPtr pBstrName, System.IntPtr pwOrdinal) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(int index, out System.IntPtr ppFuncDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(int index, out System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(int memid, out string pBstrMops) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out Microsoft.Build.Tasks.IFixedTypeInfo ppTI) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeOfImplType(int index, out System.IntPtr href) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeAttr(out System.IntPtr ppTypeAttr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeComp(out System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetVarDesc(int index, out System.IntPtr ppVarDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, System.IntPtr pVarResult, System.IntPtr pExcepInfo, out int puArgErr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr pFuncDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr pTypeAttr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr pVarDesc) -> void
 Microsoft.Build.Tasks.LC
 Microsoft.Build.Tasks.LC.LC() -> void
 Microsoft.Build.Tasks.LC.LicenseTarget.get -> Microsoft.Build.Framework.ITaskItem
@@ -1604,6 +1673,35 @@ Microsoft.Build.Tasks.ResolveProjectBase.GetProjectItem(Microsoft.Build.Framewor
 Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
 Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.set -> void
 Microsoft.Build.Tasks.ResolveProjectBase.ResolveProjectBase() -> void
+Microsoft.Build.Tasks.ResolveSDKReference
+Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.get -> bool
+Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.get -> bool
+Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.References.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.References.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.ResolveSDKReference() -> void
+Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.get -> bool
+Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.set -> void
 Microsoft.Build.Tasks.RoslynCodeTaskFactory
 Microsoft.Build.Tasks.RoslynCodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
 Microsoft.Build.Tasks.RoslynCodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
@@ -1862,7 +1960,9 @@ override Microsoft.Build.Tasks.GetAssemblyIdentity.Execute() -> bool
 override Microsoft.Build.Tasks.GetCompatiblePlatform.Execute() -> bool
 override Microsoft.Build.Tasks.GetFileHash.Execute() -> bool
 override Microsoft.Build.Tasks.GetFrameworkPath.Execute() -> bool
+override Microsoft.Build.Tasks.GetInstalledSDKLocations.Execute() -> bool
 override Microsoft.Build.Tasks.GetReferenceAssemblyPaths.Execute() -> bool
+override Microsoft.Build.Tasks.GetSDKReferenceFiles.Execute() -> bool
 override Microsoft.Build.Tasks.Hash.Execute() -> bool
 override Microsoft.Build.Tasks.LC.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
 override Microsoft.Build.Tasks.LC.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
@@ -1883,6 +1983,7 @@ override Microsoft.Build.Tasks.ResolveComReference.Execute() -> bool
 override Microsoft.Build.Tasks.ResolveKeySource.Execute() -> bool
 override Microsoft.Build.Tasks.ResolveManifestFiles.Execute() -> bool
 override Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveSDKReference.Execute() -> bool
 override Microsoft.Build.Tasks.SGen.Execute() -> bool
 override Microsoft.Build.Tasks.SGen.GenerateFullPathToTool() -> string
 override Microsoft.Build.Tasks.SGen.ToolName.get -> string
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index 968242348e3..d176aa94e3e 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -19,105 +19,4 @@ Microsoft.Build.Tasks.BuildUri.UriScheme.get -> string
 Microsoft.Build.Tasks.BuildUri.UriScheme.set -> void
 Microsoft.Build.Tasks.BuildUri.UriUserName.get -> string
 Microsoft.Build.Tasks.BuildUri.UriUserName.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations
-Microsoft.Build.Tasks.GetInstalledSDKLocations.GetInstalledSDKLocations() -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.get -> string[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.get -> string[]
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.get -> bool
-Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.GetSDKReferenceFiles() -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.get -> bool
-Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.RedistFiles.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.get -> string[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.set -> void
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.get -> string
-Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.set -> void
-Microsoft.Build.Tasks.IFixedTypeInfo
-Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(object pUnkOuter, ref System.Guid riid, out object ppvObj) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(out System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, out int pIndex) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, System.IntPtr pBstrDllName, System.IntPtr pBstrName, System.IntPtr pwOrdinal) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(int index, out System.IntPtr ppFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(int index, out System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(int memid, out string pBstrMops) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out Microsoft.Build.Tasks.IFixedTypeInfo ppTI) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeOfImplType(int index, out System.IntPtr href) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeAttr(out System.IntPtr ppTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeComp(out System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetVarDesc(int index, out System.IntPtr ppVarDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, System.IntPtr pVarResult, System.IntPtr pExcepInfo, out int puArgErr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr pFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr pTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr pVarDesc) -> void
-Microsoft.Build.Tasks.ResolveSDKReference
-Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.References.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.References.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.ResolveSDKReference() -> void
-Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
-Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.get -> string
-Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.set -> void
-Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.get -> bool
-Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.set -> void
 override Microsoft.Build.Tasks.BuildUri.Execute() -> bool
-override Microsoft.Build.Tasks.GetInstalledSDKLocations.Execute() -> bool
-override Microsoft.Build.Tasks.GetSDKReferenceFiles.Execute() -> bool
-override Microsoft.Build.Tasks.ResolveSDKReference.Execute() -> bool
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index f9532864e15..2629634f436 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -862,7 +862,7 @@ private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs bui
                         _firstProjectStartedEventContext = buildEvent.BuildEventContext;
 
                         // We've never seen a project started event, so raise the build started event and save this project started event.
-                        BuildStartedEventArgs startedEvent = new BuildStartedEventArgs(_buildStartedEvent.Message, _buildStartedEvent.HelpKeyword, Traits.Instance.LogAllEnvironmentVariables ? _buildStartedEvent.BuildEnvironment : null);
+                        BuildStartedEventArgs startedEvent = new BuildStartedEventArgs(_buildStartedEvent.Message, _buildStartedEvent.HelpKeyword, _buildStartedEvent.BuildEnvironment);
                         RaiseBuildStartedEvent(sender, startedEvent);
                     }
 
diff --git a/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
index f7bb4031d5e..9efcc6b3e9d 100644
--- a/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -1,3 +1,4 @@
+abstract Microsoft.Build.Utilities.AppDomainIsolatedTask.Execute() -> bool
 abstract Microsoft.Build.Utilities.Logger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
 abstract Microsoft.Build.Utilities.Task.Execute() -> bool
 abstract Microsoft.Build.Utilities.ToolTask.GenerateFullPathToTool() -> string
@@ -33,6 +34,26 @@ const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDKConfiguration
 const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatform = "TargetPlatform" -> string
 const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformMinVersion = "TargetPlatformMinVersion" -> string
 const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformVersion = "TargetPlatformVersion" -> string
+Microsoft.Build.Utilities.AppDomainIsolatedTask
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask() -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources) -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.get -> string
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.get -> System.Resources.ResourceManager
+Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.set -> void
+Microsoft.Build.Utilities.AssemblyFoldersExInfo
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.AssemblyFoldersExInfo(Microsoft.Win32.RegistryHive hive, Microsoft.Win32.RegistryView view, string registryKey, string directoryPath, System.Version targetFrameworkVersion) -> void
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.DirectoryPath.get -> string
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.Hive.get -> Microsoft.Win32.RegistryHive
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.Key.get -> string
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.TargetFrameworkVersion.get -> System.Version
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.View.get -> Microsoft.Win32.RegistryView
 Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo
 Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.AssemblyFoldersFromConfigInfo(string directoryPath, System.Version targetFrameworkVersion) -> void
 Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.DirectoryPath.get -> string
@@ -278,6 +299,7 @@ Microsoft.Build.Utilities.VisualStudioVersion.Version150 = 4 -> Microsoft.Build.
 Microsoft.Build.Utilities.VisualStudioVersion.Version160 = 5 -> Microsoft.Build.Utilities.VisualStudioVersion
 Microsoft.Build.Utilities.VisualStudioVersion.Version170 = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
 Microsoft.Build.Utilities.VisualStudioVersion.VersionLatest = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
+override Microsoft.Build.Utilities.AppDomainIsolatedTask.InitializeLifetimeService() -> object
 override Microsoft.Build.Utilities.CommandLineBuilder.ToString() -> string
 override Microsoft.Build.Utilities.TargetPlatformSDK.Equals(object obj) -> bool
 override Microsoft.Build.Utilities.TargetPlatformSDK.GetHashCode() -> int
@@ -290,6 +312,7 @@ static Microsoft.Build.Utilities.ToolLocationHelper.CurrentToolsVersion.get -> s
 static Microsoft.Build.Utilities.ToolLocationHelper.FilterPlatformExtensionSDKs(System.Version targetPlatformVersion, System.Collections.Generic.IDictionary<string, string> extensionSdks) -> System.Collections.Generic.IDictionary<string, string>
 static Microsoft.Build.Utilities.ToolLocationHelper.FilterTargetPlatformSdks(System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> targetPlatformSdkList, System.Version osVersion, System.Version vsVersion) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
 static Microsoft.Build.Utilities.ToolLocationHelper.FindRootFolderWhereAllFilesExist(string possibleRoots, string relativeFilePaths) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersExInfo>
 static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>
 static Microsoft.Build.Utilities.ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, System.Runtime.Versioning.FrameworkName frameworkName) -> string
 static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
diff --git a/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index b08b45a21d6..e69de29bb2d 100644
--- a/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,23 +0,0 @@
-abstract Microsoft.Build.Utilities.AppDomainIsolatedTask.Execute() -> bool
-Microsoft.Build.Utilities.AppDomainIsolatedTask
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask() -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.set -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.AssemblyFoldersExInfo(Microsoft.Win32.RegistryHive hive, Microsoft.Win32.RegistryView view, string registryKey, string directoryPath, System.Version targetFrameworkVersion) -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.DirectoryPath.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Hive.get -> Microsoft.Win32.RegistryHive
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Key.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.TargetFrameworkVersion.get -> System.Version
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.View.get -> Microsoft.Win32.RegistryView
-override Microsoft.Build.Utilities.AppDomainIsolatedTask.InitializeLifetimeService() -> object
-static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersExInfo>
\ No newline at end of file
