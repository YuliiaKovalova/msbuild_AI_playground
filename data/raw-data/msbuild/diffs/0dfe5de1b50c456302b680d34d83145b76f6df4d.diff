diff --git a/.github/fabricbot.json b/.github/fabricbot.json
new file mode 100644
index 00000000000..805c4d1eeb1
--- /dev/null
+++ b/.github/fabricbot.json
@@ -0,0 +1,662 @@
+{
+  "version": "1.0",
+  "tasks": [
+    {
+      "taskType": "trigger",
+      "capabilityId": "AutoMerge",
+      "subCapability": "AutoMerge",
+      "version": "1.0",
+      "id": "_eeVr2w4J",
+      "config": {
+        "taskName": "Automatically squash and  merge PR once CI passes",
+        "label": "auto-merge",
+        "minMinutesOpen": "12",
+        "mergeType": "squash",
+        "deleteBranches": true,
+        "requireAllStatuses": true,
+        "minimumNumberOfCheckRuns": 4,
+        "removeLabelOnPush": true
+      }
+    },
+    {
+      "taskType": "trigger",
+      "capabilityId": "IssueResponder",
+      "subCapability": "PullRequestResponder",
+      "version": "1.0",
+      "id": "0aePnH83s",
+      "config": {
+        "conditions": {
+          "operator": "and",
+          "operands": [
+            {
+              "name": "prTargetsBranch",
+              "parameters": {
+                "branchName": "master"
+              }
+            },
+            {
+              "name": "isAction",
+              "parameters": {
+                "action": "merged"
+              }
+            },
+            {
+              "operator": "not",
+              "operands": [
+                {
+                  "name": "isInMilestone",
+                  "parameters": {}
+                }
+              ]
+            }
+          ]
+        },
+        "eventType": "pull_request",
+        "eventNames": [
+          "pull_request",
+          "issues",
+          "project_card"
+        ],
+        "actions": [
+          {
+            "name": "addMilestone",
+            "parameters": {
+              "milestoneName": "current-release"
+            }
+          }
+        ],
+        "taskName": "\"Current\" milestone for merged master PRs"
+      },
+      "disabled": true
+    },
+    {
+      "taskType": "scheduled",
+      "capabilityId": "ScheduledSearch",
+      "subCapability": "ScheduledSearch",
+      "version": "1.1",
+      "id": "Vs-iCm9G2_R4ZwMN511fw",
+      "config": {
+        "frequency": [
+          {
+            "weekDay": 0,
+            "hours": [
+              17
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 1,
+            "hours": [
+              17
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 2,
+            "hours": [
+              17
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 3,
+            "hours": [
+              17
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 4,
+            "hours": [
+              17
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 5,
+            "hours": [
+              17
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 6,
+            "hours": [
+              17
+            ],
+            "timezoneOffset": -7
+          }
+        ],
+        "searchTerms": [
+          {
+            "name": "isOpen",
+            "parameters": {}
+          },
+          {
+            "name": "hasLabel",
+            "parameters": {
+              "label": "needs-more-info"
+            }
+          },
+          {
+            "name": "noLabel",
+            "parameters": {
+              "label": "needs-attention"
+            }
+          },
+          {
+            "name": "notPartOfMilestone",
+            "parameters": {
+              "milestone": "Backlog"
+            }
+          },
+          {
+            "name": "notPartOfMilestone",
+            "parameters": {
+              "milestone": "Discussion"
+            }
+          },
+          {
+            "name": "noLabel",
+            "parameters": {
+              "label": "needs-triage"
+            }
+          },
+          {
+            "name": "isIssue",
+            "parameters": {}
+          },
+          {
+            "name": "noLabel",
+            "parameters": {
+              "label": "stale"
+            }
+          },
+          {
+            "name": "noActivitySince",
+            "parameters": {
+              "days": 30
+            }
+          },
+          {
+            "name": "noLabel",
+            "parameters": {
+              "label": "bot-exclude"
+            }
+          }
+        ],
+        "taskName": "Mark Stale Issues",
+        "actions": [
+          {
+            "name": "addLabel",
+            "parameters": {
+              "label": "stale"
+            }
+          },
+          {
+            "name": "addReply",
+            "parameters": {
+              "comment": "This issue is marked as stale because feedback has been requested for 30 days with no response. Please respond within 14 days or this issue will be closed due to inactivity."
+            }
+          }
+        ]
+      }
+    },
+    {
+      "taskType": "scheduled",
+      "capabilityId": "ScheduledSearch",
+      "subCapability": "ScheduledSearch",
+      "version": "1.1",
+      "id": "zyeSRvg_Epub_oXWwaxj3",
+      "config": {
+        "frequency": [
+          {
+            "weekDay": 0,
+            "hours": [
+              12
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 1,
+            "hours": [
+              12
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 2,
+            "hours": [
+              12
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 3,
+            "hours": [
+              12
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 4,
+            "hours": [
+              12
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 5,
+            "hours": [
+              12
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 6,
+            "hours": [
+              12
+            ],
+            "timezoneOffset": -7
+          }
+        ],
+        "searchTerms": [
+          {
+            "name": "isOpen",
+            "parameters": {}
+          },
+          {
+            "name": "hasLabel",
+            "parameters": {
+              "label": "stale"
+            }
+          },
+          {
+            "name": "noLabel",
+            "parameters": {
+              "label": "bot-exclude"
+            }
+          },
+          {
+            "name": "noActivitySince",
+            "parameters": {
+              "days": 14
+            }
+          },
+          {
+            "name": "notPartOfMilestone",
+            "parameters": {
+              "milestone": "Backlog"
+            }
+          },
+          {
+            "name": "notPartOfMilestone",
+            "parameters": {
+              "milestone": "Discussion"
+            }
+          },
+          {
+            "name": "noLabel",
+            "parameters": {
+              "label": "needs-attention"
+            }
+          }
+        ],
+        "taskName": "Close Stale Issues",
+        "actions": [
+          {
+            "name": "closeIssue",
+            "parameters": {}
+          },
+          {
+            "name": "addReply",
+            "parameters": {
+              "comment": "This issue was closed due to inactivity. If you can still reproduce this bug, please comment with the requested information, detailed steps to reproduce the problem, or any other notes that might help in the investigation."
+            }
+          },
+          {
+            "name": "addLabel",
+            "parameters": {
+              "label": "closed-by-bot"
+            }
+          }
+        ]
+      },
+      "disabled": false
+    },
+    {
+      "taskType": "trigger",
+      "capabilityId": "IssueResponder",
+      "subCapability": "IssueCommentResponder",
+      "version": "1.0",
+      "id": "WBzbPosGhniXQtQgm8oMm",
+      "config": {
+        "conditions": {
+          "operator": "and",
+          "operands": [
+            {
+              "name": "isOpen",
+              "parameters": {}
+            },
+            {
+              "name": "hasLabel",
+              "parameters": {
+                "label": "stale"
+              }
+            },
+            {
+              "operator": "not",
+              "operands": [
+                {
+                  "name": "hasLabel",
+                  "parameters": {
+                    "label": "bot-exclude"
+                  }
+                }
+              ]
+            }
+          ]
+        },
+        "eventType": "issue",
+        "eventNames": [
+          "issue_comment"
+        ],
+        "taskName": "Unstale Open Issues that get comments",
+        "actions": [
+          {
+            "name": "removeLabel",
+            "parameters": {
+              "label": "stale"
+            }
+          },
+          {
+            "name": "addLabel",
+            "parameters": {
+              "label": "needs-attention"
+            }
+          }
+        ]
+      },
+      "disabled": false
+    },
+    {
+      "taskType": "trigger",
+      "capabilityId": "IssueResponder",
+      "subCapability": "IssueCommentResponder",
+      "version": "1.0",
+      "id": "GU-AG9bRpCo1aFfE07jUZ",
+      "config": {
+        "conditions": {
+          "operator": "and",
+          "operands": [
+            {
+              "operator": "not",
+              "operands": [
+                {
+                  "name": "isOpen",
+                  "parameters": {}
+                }
+              ]
+            },
+            {
+              "name": "hasLabel",
+              "parameters": {
+                "label": "stale"
+              }
+            },
+            {
+              "operator": "not",
+              "operands": [
+                {
+                  "name": "hasLabel",
+                  "parameters": {
+                    "label": "bot-exclude"
+                  }
+                }
+              ]
+            }
+          ]
+        },
+        "eventType": "issue",
+        "eventNames": [
+          "issue_comment"
+        ],
+        "taskName": "Apply needs-attention to closed stale issues that get comments",
+        "actions": [
+          {
+            "name": "addLabel",
+            "parameters": {
+              "label": "needs-attention"
+            }
+          }
+        ]
+      }
+    },
+    {
+      "taskType": "trigger",
+      "capabilityId": "IssueResponder",
+      "subCapability": "IssuesOnlyResponder",
+      "version": "1.0",
+      "id": "ny85tm-H4saOfDbOgErD3",
+      "config": {
+        "conditions": {
+          "operator": "and",
+          "operands": [
+            {
+              "name": "labelAdded",
+              "parameters": {
+                "label": "needs-more-info"
+              }
+            },
+            {
+              "name": "hasLabel",
+              "parameters": {
+                "label": "needs-triage"
+              }
+            }
+          ]
+        },
+        "eventType": "issue",
+        "eventNames": [
+          "issues",
+          "project_card"
+        ],
+        "taskName": "remove needs-triage when needs-more-info is applied",
+        "actions": [
+          {
+            "name": "removeLabel",
+            "parameters": {
+              "label": "needs-triage"
+            }
+          }
+        ]
+      }
+    },
+    {
+      "taskType": "trigger",
+      "capabilityId": "IssueResponder",
+      "subCapability": "IssuesOnlyResponder",
+      "version": "1.0",
+      "id": "hpVo319FrpinWBwXVnK8s",
+      "config": {
+        "conditions": {
+          "operator": "and",
+          "operands": [
+            {
+              "name": "addedToMilestone",
+              "parameters": {
+                "milestoneName": "Backlog"
+              }
+            }
+          ]
+        },
+        "eventType": "issue",
+        "eventNames": [
+          "issues",
+          "project_card"
+        ],
+        "taskName": "When added to backlog, remove `needs-triage`",
+        "actions": [
+          {
+            "name": "removeLabel",
+            "parameters": {
+              "label": "needs-triage"
+            }
+          }
+        ]
+      }
+    },
+    {
+      "taskType": "scheduled",
+      "capabilityId": "ScheduledSearch",
+      "subCapability": "ScheduledSearch",
+      "version": "1.1",
+      "id": "0JHwKtkOQj0mLYc7iUySl",
+      "config": {
+        "frequency": [
+          {
+            "weekDay": 0,
+            "hours": [
+              11,
+              12,
+              13
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 1,
+            "hours": [
+              11,
+              12,
+              13
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 2,
+            "hours": [
+              11,
+              12,
+              13
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 3,
+            "hours": [
+              11,
+              12,
+              13
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 4,
+            "hours": [
+              11,
+              12,
+              13
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 5,
+            "hours": [
+              11,
+              12,
+              13
+            ],
+            "timezoneOffset": -7
+          },
+          {
+            "weekDay": 6,
+            "hours": [
+              11,
+              12,
+              13
+            ],
+            "timezoneOffset": -7
+          }
+        ],
+        "searchTerms": [
+          {
+            "name": "hasLabel",
+            "parameters": {
+              "label": "bot-test"
+            }
+          },
+          {
+            "name": "created",
+            "parameters": {
+              "operator": "<",
+              "days": 1
+            }
+          }
+        ],
+        "taskName": "Post comment to bot-test",
+        "actions": [
+          {
+            "name": "removeLabel",
+            "parameters": {
+              "label": "bot-test"
+            }
+          }
+        ]
+      }
+    },
+    {
+      "taskType": "trigger",
+      "capabilityId": "IssueResponder",
+      "subCapability": "IssueCommentResponder",
+      "version": "1.0",
+      "id": "4T-htFPPX7DIas5-BKvde",
+      "config": {
+        "conditions": {
+          "operator": "and",
+          "operands": [
+            {
+              "name": "isActivitySender",
+              "parameters": {
+                "user": {
+                  "type": "author"
+                }
+              }
+            },
+            {
+              "name": "hasLabel",
+              "parameters": {
+                "label": "needs-more-info"
+              }
+            }
+          ]
+        },
+        "eventType": "issue",
+        "eventNames": [
+          "issue_comment"
+        ],
+        "taskName": "author responds to `needs-more-info` gets `author-responded`",
+        "actions": [
+          {
+            "name": "addLabel",
+            "parameters": {
+              "label": "needs-attention"
+            }
+          },
+          {
+            "name": "addLabel",
+            "parameters": {
+              "label": "author-responded"
+            }
+          },
+          {
+            "name": "addLabel",
+            "parameters": {
+              "label": "needs-more-info"
+            }
+          }
+        ]
+      }
+    }
+  ],
+  "userGroups": []
+}
diff --git a/.vsts-dotnet.yml b/.vsts-dotnet.yml
index 145b6b67a88..b7096d2c9fa 100644
--- a/.vsts-dotnet.yml
+++ b/.vsts-dotnet.yml
@@ -147,6 +147,7 @@ stages:
         channelName: $(VisualStudio.ChannelName)
         manifests: $(VisualStudio.SetupManifestList)
         outputFolder: '$(Build.SourcesDirectory)\artifacts\VSSetup\$(BuildConfiguration)\Insertion'
+        bootstrapperCoreVersion: 
       displayName: 'OptProf - Build VS bootstrapper'
       condition: succeeded()
 
diff --git a/README.md b/README.md
index d96c05bcda0..343c9d9c866 100644
--- a/README.md
+++ b/README.md
@@ -8,11 +8,15 @@ The [changelog](documentation/Changelog.md) has detailed information about chang
 
 ### Build Status
 
-The current development branch is `main`. Changes in `main` will go into a future update of MSBuild, which will release with Visual Studio 17.2 and a corresponding version of the .NET Core SDK.
+The current development branch is `main`. Changes in `main` will go into a future update of MSBuild, which will release with Visual Studio 17.4 and a corresponding version of the .NET Core SDK.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=main)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=main)
 
-We have forked for MSBuild 17.2 in the branch [`vs17.2`](https://github.com/Microsoft/msbuild/tree/vs17.2). Changes to that branch need special approval.
+We have forked for MSBuild 17.3 in the branch [`vs17.3`](https://github.com/Microsoft/msbuild/tree/vs17.3). Changes to that branch need special approval.
+
+[![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.3)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.3)
+
+17.2 builds from the branch [`vs17.2`](https://github.com/Microsoft/msbuild/tree/vs17.2). Only high-priority bugfixes will be considered for servicing 17.2.
 
 [![Build Status](https://dev.azure.com/dnceng/public/_apis/build/status/Microsoft/msbuild/msbuild-pr?branchName=vs17.2)](https://dev.azure.com/dnceng/public/_build/latest?definitionId=887&branchName=vs17.2)
 
diff --git a/documentation/MSBuild-Server.md b/documentation/MSBuild-Server.md
index 355cd8e1383..9337295dac6 100644
--- a/documentation/MSBuild-Server.md
+++ b/documentation/MSBuild-Server.md
@@ -1,6 +1,11 @@
 # MSBuild Server
 
-MSBuild Server is basically an another type of node which can accept build request from clients and utilize worker nodes in current fashion to build projects. Main purpose of the server node is to avoid expensive MSBuild process start during build from tools like .NET SDK.
+MSBuild Server nodes accept build requests from clients and use worker nodes in the current fashion to build projects. The main purpose of the server node is to preserve caches between builds and avoid expensive MSBuild process start operations during build from tools like the .NET SDK.
+
+## Usage
+
+The primary ways to use MSBuild are via Visual Studio and via the CLI using the `dotnet build`/`dotnet msbuild` commands. MSBuild Server is not supported in Visual Studio because Visual Studio itself works like MSBuild Server. For the CLI, the server functionality is enabled by default and can be disabled by setting the `DOTNET_CLI_DO_NOT_USE_MSBUILD_SERVER` environment variable to value `1`.
+To re-enable MSBuild Server, remove the variable or set its value to `0`.
 
 ## Communication protocol
 
@@ -8,12 +13,12 @@ The server node uses same IPC approach as current worker nodes - named pipes. Th
 
 1. Try to connect to server
    - If server is not running, start new instance
-   - If server is busy, fallback to classic build 
+   - If server is busy or the connection is broken, fall back to previous build behavior
 2. Initiate handshake
-2. Issue build command with `EntryNodeCommand` packet
+2. Issue build command with `ServerNodeBuildCommand` packet
 3. Read packets from pipe
-   - When `EntryNodeConsoleWrite` packet type is recieved, write content to appropriate output stream with respected coloring
-   - When `EntryNodeResponse` packet type is recieved, build is done and client writes trace message with exit code
+   - Write content to the appropriate output stream (respecting coloring) with the `ServerNodeConsoleWrite` packet
+   - After the build completes, the `ServerNodeBuildResult` packet indicates the exit code
 
 ### Pipe name convention & handshake
 
@@ -25,7 +30,7 @@ Handshake is a procedure ensuring that client is connecting to a compatible serv
 
 Server requires to introduce new packet types for IPC.
 
-`EntryNodeCommand` contains all of the information necessary for a server to run a build.
+`ServerNodeBuildCommand` contains all of the information necessary for a server to run a build.
 
 | Property name            | Type                         | Description |
 |---|---|---|
@@ -34,21 +39,22 @@ Server requires to introduce new packet types for IPC.
 | BuildProcessEnvironment  | IDictionary<String, String>  | Environment variables for current build |
 | Culture                  | CultureInfo                  | The culture value for current build |
 | UICulture                | CultureInfo                  | The UI culture value for current build |
+| ConsoleConfiguration     | TargetConsoleConfiguration   | Console configuration of target Console at which the output will be rendered |
 
-`EntryNodeConsoleWrite` contains information for console output.
+`ServerNodeConsoleWrite` contains information for console output.
 
 | Property name            | Type          | Description |
 |---|---|---|
 | Text                     | String        | The text that is written to the output stream. It includes ANSI escape codes for formatting. |
 | OutputType               | Byte          | Identification of the output stream (1 = standard output, 2 = error output) |
 
-`EntryNodeResponse` informs about finished build.
+`ServerNodeBuildResult` indicates how the build finished.
 
 | Property name            | Type          | Description |
 |---|---|---|
 | ExitCode                 | Int32         | The exit code of the build |
 | ExitType                 | String        | The exit type of the build |
 
-`EntryNodeCancel` cancels the current build.
+`ServerNodeBuildCancel` cancels the current build.
 
 This type is intentionally empty and properties for build cancelation could be added in future.
diff --git a/documentation/specs/event-source.md b/documentation/specs/event-source.md
index 664a32ac397..f646f120114 100644
--- a/documentation/specs/event-source.md
+++ b/documentation/specs/event-source.md
@@ -11,6 +11,7 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 | Build | Sets up a BuildManager to receive build requests. |
 | BuildProject | Builds a project file. |
 | CachedSdkResolverServiceResolveSdk | The caching SDK resolver service is resolving an SDK. |
+| CreateLoadedType | Creates a LoadedType object from an assembly loaded via MetadataLoadContext. |
 | CopyUpToDate | Checks whether the Copy task needs to execute. |
 | Evaluate | Evaluates a project, running several other parts of MSBuild in the process. |
 | EvaluateCondition | Checks whether a condition is true and removes false conditionals. |
@@ -21,6 +22,7 @@ EventSource is primarily used to profile code. For MSBuild specifically, a major
 | GenerateResourceOverall | Uses resource APIs to transform resource files into strongly-typed resource classes. |
 | LoadDocument | Loads an XMLDocumentWithLocation from a path.
 | MSBuildExe | Executes MSBuild from the command line. |
+| MSBuildServerBuild | Executes a build from the MSBuildServer node. |
 | PacketReadSize | Reports the size of a packet sent between nodes. Note that this does not include time information. |
 | Parse | Parses an XML document into a ProjectRootElement. |
 | ProjectGraphConstruction | Constructs a dependency graph among projects. |
diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index 2158cd2a8a5..c527f09e244 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -27,6 +27,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Respect deps.json when loading assemblies](https://github.com/dotnet/msbuild/pull/7520)
 - [Consider `Platform` as default during Platform Negotiation](https://github.com/dotnet/msbuild/pull/7511)
 - [Adding accepted SDK name match pattern to SDK manifests](https://github.com/dotnet/msbuild/pull/7597)
+- [MSBuild server](https://github.com/dotnet/msbuild/pull/7634)
 
 ### 17.0
 - [Scheduler should honor BuildParameters.DisableInprocNode](https://github.com/dotnet/msbuild/pull/6400)
diff --git a/documentation/wiki/Contributing-Code.md b/documentation/wiki/Contributing-Code.md
index 02760fb0b8b..71db1a4961d 100644
--- a/documentation/wiki/Contributing-Code.md
+++ b/documentation/wiki/Contributing-Code.md
@@ -11,7 +11,7 @@ Because our focus right now is on maintaining backwards compatibility, the team
 
 When you are ready to proceed with making a change, get set up to [build](Home.md "See 'Building Testing and Debugging'") the code and familiarize yourself with our workflow and our coding conventions. These two blogs posts on contributing code to open source projects are good too: [Open Source Contribution Etiquette by Miguel de Icaza](https://tirania.org/blog/archive/2010/Dec-31.html) and [Don’t “Push” Your Pull Requests by Ilya Grigorik](https://www.igvita.com/2011/12/19/dont-push-your-pull-requests/).
 
-You must sign a Contributor License Agreement (CLA) before submitting your pull request. To complete the CLA, submit a request via the form and electronically sign the CLA when you receive the email containing the link to the document. You need to complete the CLA only once to cover all Microsoft Open Technologies OSS projects.
+You will have to sign a Contributor License Agreement (CLA) before we can accept your pull request. To complete the CLA, submit a pull request and a bot will comment with a link where you can electronically sign the CLA. You need to complete the CLA only once to cover all Microsoft Open Technologies OSS projects.
 
 ### Developer Workflow
 
diff --git a/eng/Packages.props b/eng/Packages.props
index 050046704e7..56ad3fae93e 100644
--- a/eng/Packages.props
+++ b/eng/Packages.props
@@ -10,26 +10,29 @@
   <ItemGroup>
     <PackageReference Update="Microsoft.Build.NuGetSdkResolver" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="Microsoft.CodeAnalysis.Build.Tasks" Version="$(MicrosoftNetCompilersToolsetVersion)" />
-    <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="4.2.0-1.22102.8" />
+    <PackageReference Update="Microsoft.CodeAnalysis.Collections" Version="$(MicrosoftCodeAnalysisCollectionsVersion)" />
     <PackageReference Update="Microsoft.DotNet.XUnitExtensions" Version="$(MicrosoftDotNetXUnitExtensionsVersion)" />
     <PackageReference Update="Microsoft.IO.Redist" Version="$(MicrosoftIORedistVersion)" />
     <PackageReference Update="Microsoft.Net.Compilers.Toolset" Version="$(MicrosoftNetCompilersToolsetVersion)" />
     <PackageReference Update="NuGet.Build.Tasks" Version="$(NuGetBuildTasksVersion)" />
     <PackageReference Update="NuGet.Frameworks" Version="$(NuGetBuildTasksVersion)" />
-    <PackageReference Update="System.Collections.Immutable" Version="6.0.0" />
-    <PackageReference Update="System.Configuration.ConfigurationManager" Version="6.0.0" />
-    <PackageReference Update="System.Net.Http" Version="4.3.4" />
+    <PackageReference Update="System.Collections.Immutable" Version="$(SystemCollectionsImmutableVersion)" />
+    <PackageReference Update="System.Configuration.ConfigurationManager" Version="$(SystemConfigurationConfigurationManagerVersion)" />
+
     <!-- 
         Modifying the version of System.Memory is very high impact and often causes downstream breaks on repos that depend on us.
         When updating the version of System.Memory, file a breaking change here: https://github.com/dotnet/docs/issues/new?assignees=gewarren&labels=breaking-change%2CPri1%2Cdoc-idea&template=breaking-change.yml&title=%5BBreaking+change%5D%3A+ 
     -->
-    <PackageReference Update="System.Memory" Version="4.5.5" />
-    <PackageReference Update="System.Reflection.Metadata" Version="6.0.0" />
+    <PackageReference Update="System.Memory" Version="$(SystemMemoryVersion)" />
+
+    <PackageReference Update="System.Net.Http" Version="$(SystemNetHttpVersion)" />
+    <PackageReference Update="System.Reflection.Metadata" Version="$(SystemReflectionMetadataVersion)" />
+    <PackageReference Update="System.Reflection.MetadataLoadContext" Version="$(SystemReflectionMetadataLoadContextVersion)" />
     <PackageReference Update="System.Resources.Extensions" Version="$(SystemResourcesExtensionsPackageVersion)" />
     <PackageReference Update="System.Runtime.CompilerServices.Unsafe" Version="$(SystemRuntimeCompilerServicesUnsafeVersion)" />
-    <PackageReference Update="System.Security.Permissions" Version="6.0.0" />
-    <PackageReference Update="System.Security.Principal.Windows" Version="5.0.0" />
-    <PackageReference Update="System.Text.Encoding.CodePages" Version="6.0.0" />
+    <PackageReference Update="System.Security.Permissions" Version="$(SystemSecurityPermissionsVersion)" />
+    <PackageReference Update="System.Security.Principal.Windows" Version="$(SystemSecurityPrincipalWindowsVersion)" />
+    <PackageReference Update="System.Text.Encoding.CodePages" Version="$(SystemTextEncodingCodePagesVersion)" />
     <PackageReference Update="System.Text.Json" Version="$(SystemTextJsonVersion)" />
     <PackageReference Update="System.Threading.Tasks.Dataflow" Version="$(SystemThreadingTasksDataflowVersion)" />
     <PackageReference Update="xunit.assert" Version="$(XUnitVersion)" />
diff --git a/eng/Version.Details.xml b/eng/Version.Details.xml
index 7756215e8f6..a4ca5158faa 100644
--- a/eng/Version.Details.xml
+++ b/eng/Version.Details.xml
@@ -1,22 +1,22 @@
 <?xml version="1.0" encoding="utf-8"?>
 <Dependencies>
   <ToolsetDependencies>
-    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22314.7">
+    <Dependency Name="Microsoft.DotNet.Arcade.Sdk" Version="6.0.0-beta.22362.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>fdd3a242bc813f371023adff4e4c05c0be705d2a</Sha>
+      <Sha>0197c12c259247557fbf7f8305a8928331c16dd6</Sha>
       <SourceBuild RepoName="arcade" ManagedOnly="true" />
     </Dependency>
     <Dependency Name="NuGet.Build.Tasks" Version="6.2.0-rc.146">
       <Uri>https://github.com/nuget/nuget.client</Uri>
       <Sha>b8a61266d9a6780cb7eb9c1942695cf813fdef0a</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.2.0-4.22307.8">
+    <Dependency Name="Microsoft.Net.Compilers.Toolset" Version="4.3.0-3.22329.30">
       <Uri>https://github.com/dotnet/roslyn</Uri>
-      <Sha>9521db7e5f69e3e84bab147a138dbf5adf57aff9</Sha>
+      <Sha>29e657c0582904529bae2a87c227220e03f509cf</Sha>
     </Dependency>
-    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22314.7">
+    <Dependency Name="Microsoft.DotNet.XUnitExtensions" Version="6.0.0-beta.22362.2">
       <Uri>https://github.com/dotnet/arcade</Uri>
-      <Sha>fdd3a242bc813f371023adff4e4c05c0be705d2a</Sha>
+      <Sha>0197c12c259247557fbf7f8305a8928331c16dd6</Sha>
     </Dependency>
   </ToolsetDependencies>
 </Dependencies>
diff --git a/eng/Versions.props b/eng/Versions.props
index 4c92e1424a4..4fe264d8fce 100644
--- a/eng/Versions.props
+++ b/eng/Versions.props
@@ -2,7 +2,7 @@
 <!-- Copyright (c) .NET Foundation and contributors. All rights reserved. Licensed under the MIT license. See License.txt in the project root for full license information. -->
 <Project>
   <PropertyGroup>
-    <VersionPrefix>17.3.0</VersionPrefix>
+    <VersionPrefix>17.4.0</VersionPrefix>
     <AssemblyVersion>15.1.0.0</AssemblyVersion>
     <PreReleaseVersionLabel>preview</PreReleaseVersionLabel>
     <DotNetUseShippingVersions>true</DotNetUseShippingVersions>
@@ -25,17 +25,27 @@
   </PropertyGroup>
   <!-- Production Dependencies -->
   <PropertyGroup>
+    <SystemCollectionsImmutableVersion>6.0.0</SystemCollectionsImmutableVersion>
+    <SystemConfigurationConfigurationManagerVersion>6.0.0</SystemConfigurationConfigurationManagerVersion>
+    <SystemMemoryVersion>4.5.5</SystemMemoryVersion>
+    <SystemNetHttpVersion>4.3.4</SystemNetHttpVersion>
+    <SystemReflectionMetadataLoadContextVersion>6.0.0</SystemReflectionMetadataLoadContextVersion>
+    <SystemReflectionMetadataVersion>6.0.0</SystemReflectionMetadataVersion>
     <SystemResourcesExtensionsPackageVersion>6.0.0</SystemResourcesExtensionsPackageVersion>
+    <SystemSecurityPermissionsVersion>6.0.0</SystemSecurityPermissionsVersion>
+    <SystemSecurityPrincipalWindowsVersion>5.0.0</SystemSecurityPrincipalWindowsVersion>
+    <SystemTextEncodingCodePagesVersion>6.0.0</SystemTextEncodingCodePagesVersion>
   </PropertyGroup>
   <!-- Toolset Dependencies -->
   <PropertyGroup>
     <!-- DotNetCliVersion MUST match the dotnet version in global.json.
          Otherwise, this version of dotnet will not be installed and the build will error out. -->
     <DotNetCliVersion>$([System.Text.RegularExpressions.Regex]::Match($([System.IO.File]::ReadAllText('$(MSBuildThisFileDirectory)..\global.json')), '"dotnet": "([^"]*)"').Groups.get_Item(1))</DotNetCliVersion>
-    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22314.7</MicrosoftDotNetXUnitExtensionsVersion>
+    <MicrosoftCodeAnalysisCollectionsVersion>4.2.0-1.22102.8</MicrosoftCodeAnalysisCollectionsVersion>
+    <MicrosoftDotNetXUnitExtensionsVersion>6.0.0-beta.22362.2</MicrosoftDotNetXUnitExtensionsVersion>
     <MicrosoftExtensionsDependencyModelVersion>6.0.0-preview.2.21154.6</MicrosoftExtensionsDependencyModelVersion>
     <MicrosoftIORedistVersion>6.0.0</MicrosoftIORedistVersion>
-    <MicrosoftNetCompilersToolsetVersion>4.2.0-4.22307.8</MicrosoftNetCompilersToolsetVersion>
+    <MicrosoftNetCompilersToolsetVersion>4.3.0-3.22329.30</MicrosoftNetCompilersToolsetVersion>
     <NuGetBuildTasksVersion>6.2.0-rc.146</NuGetBuildTasksVersion>
     <SystemRuntimeCompilerServicesUnsafeVersion>6.0.0</SystemRuntimeCompilerServicesUnsafeVersion>
     <SystemTextJsonVersion>6.0.0</SystemTextJsonVersion>
diff --git a/eng/common/internal/NuGet.config b/eng/common/internal/NuGet.config
new file mode 100644
index 00000000000..19d3d311b16
--- /dev/null
+++ b/eng/common/internal/NuGet.config
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<configuration>
+  <packageSources>
+    <clear />
+    <add key="dotnet-core-internal-tooling" value="https://pkgs.dev.azure.com/devdiv/_packaging/dotnet-core-internal-tooling/nuget/v3/index.json" />
+  </packageSources>
+</configuration>
diff --git a/eng/common/internal/Tools.csproj b/eng/common/internal/Tools.csproj
index beb9c4648ea..7f5ce6d6081 100644
--- a/eng/common/internal/Tools.csproj
+++ b/eng/common/internal/Tools.csproj
@@ -8,6 +8,9 @@
   <ItemGroup>
     <!-- Clear references, the SDK may add some depending on UsuingToolXxx settings, but we only want to restore the following -->
     <PackageReference Remove="@(PackageReference)"/>
+    <PackageReference Include="Microsoft.ManifestTool.CrossPlatform" Version="$(MicrosoftManifestToolCrossPlatformVersion)" />
+    <PackageReference Include="Microsoft.VisualStudioEng.MicroBuild.Core" Version="$(MicrosoftVisualStudioEngMicroBuildCoreVersion)" />
+    <PackageReference Include="Microsoft.VisualStudioEng.MicroBuild.Plugins.SwixBuild" Version="$(MicrosoftVisualStudioEngMicroBuildPluginsSwixBuildVersion)" />
     <PackageReference Include="Microsoft.DotNet.IBCMerge" Version="$(MicrosoftDotNetIBCMergeVersion)" Condition="'$(UsingToolIbcOptimization)' == 'true'" />
     <PackageReference Include="Drop.App" Version="$(DropAppVersion)" ExcludeAssets="all" Condition="'$(UsingToolVisualStudioIbcTraining)' == 'true'"/>
   </ItemGroup>
diff --git a/eng/dependabot/Packages.props b/eng/dependabot/Packages.props
index 06cf49477ed..dabc0805ea8 100644
--- a/eng/dependabot/Packages.props
+++ b/eng/dependabot/Packages.props
@@ -1,35 +1,64 @@
 <Project>
 
   <!-- Packages in this file have versions updated periodically by Dependabot.
-       Versions managed by Darc/Maestro should be in ..\Packages.props. -->
+  Versions managed by Darc/Maestro should be in ..\Packages.props.
+
+  Make sure to update the binding redirects (in src\MSBuild\app.config and src\MSBuild\app.amd64.config) for any changes to
+  the list of assemblies redistributed by MSBuild (non-MSBuild assemblies in the .vsix package).
+
+  Packages must be set to their package version property if it exists (ex. BenchmarkDotNetVersion) since source-build uses
+  these properties to override package versions if necessary. -->
 
-  <!--
-    Make sure to update the binding redirects (in src\MSBuild\app.config and src\MSBuild\app.amd64.config) for any changes to
-    the list of assemblies redistributed by MSBuild (non-MSBuild assemblies in the .vsix package).
-     -->
   <ItemGroup>
     <PackageReference Update="BenchmarkDotNet" Version="0.13.1" />
+    <PackageReference Update="BenchmarkDotNet" Condition="'$(BenchmarkDotNetVersion)' != ''" Version="$(BenchmarkDotNetVersion)" />
+
     <PackageReference Update="LargeAddressAware" Version="1.0.5" />
+    <PackageReference Update="LargeAddressAware" Condition="'$(LargeAddressAwareVersion)' != ''" Version="$(LargeAddressAwareVersion)" />
+
     <PackageReference Update="Microsoft.CodeAnalysis.PublicApiAnalyzers" Version="3.3.3" />
+    <PackageReference Update="Microsoft.CodeAnalysis.PublicApiAnalyzers" Condition="'$(MicrosoftCodeAnalysisPublicApiAnalyzersVersion)' != ''" Version="$(MicrosoftCodeAnalysisPublicApiAnalyzersVersion)" />
+
     <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" />
+    <PackageReference Update="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Condition="'$(MicrosoftVisualStudioSDKEmbedInteropTypesVersion)' != ''" Version="$(MicrosoftVisualStudioSDKEmbedInteropTypesVersion)" />
+
     <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Version="3.2.2146" PrivateAssets="All" />
+    <PackageReference Update="Microsoft.VisualStudio.Setup.Configuration.Interop" Condition="'$(MicrosoftVisualStudioSetupConfigurationInteropVersion)' != ''" Version="$(MicrosoftVisualStudioSetupConfigurationInteropVersion)" PrivateAssets="All" />
+
     <PackageReference Update="Microsoft.Win32.Registry" Version="5.0.0" />
+    <PackageReference Update="Microsoft.Win32.Registry" Condition="'$(MicrosoftWin32RegistryVersion)' != ''" Version="$(MicrosoftWin32RegistryVersion)" />
+
+    <PackageReference Update="Newtonsoft.Json" Version="13.0.1" />
+    <PackageReference Update="Newtonsoft.Json" Condition="'$(NewtonsoftJsonVersion)' != ''" Version="$(NewtonsoftJsonVersion)" />
+
     <PackageReference Update="PdbGit" Version="3.0.41" />
+    <PackageReference Update="PdbGit" Condition="'$(PdbGitVersion)' != ''" Version="$(PdbGitVersion)" />
+
     <PackageReference Update="Shouldly" Version="3.0.0" />
+    <PackageReference Update="Shouldly" Condition="'$(ShouldlyVersion)' != ''" Version="$(ShouldlyVersion)" />
+
     <PackageReference Update="System.CodeDom" Version="6.0.0" />
+    <PackageReference Update="System.CodeDom" Condition="'$(SystemCodeDomVersion)' != ''" Version="$(SystemCodeDomVersion)" />
+
     <PackageReference Update="System.Private.Uri" Version="4.3.2" />
+    <PackageReference Update="System.Private.Uri" Condition="'$(SystemPrivateUriVersion)' != ''" Version="$(SystemPrivateUriVersion)" />
+
     <PackageReference Update="System.Runtime" Version="4.3.1" />
+    <PackageReference Update="System.Runtime" Condition="'$(SystemRuntimeVersion)' != ''" Version="$(SystemRuntimeVersion)" />
+
     <PackageReference Update="System.Security.Cryptography.Pkcs" Version="6.0.1" />
+    <PackageReference Update="System.Security.Cryptography.Pkcs" Condition="'$(SystemSecurityCryptographyPkcsVersion)' != ''" Version="$(SystemSecurityCryptographyPkcsVersion)" />
+
     <PackageReference Update="System.Security.Cryptography.Xml" Version="6.0.0" />
+    <PackageReference Update="System.Security.Cryptography.Xml" Condition="'$(SystemSecurityCryptographyXmlVersion)' != ''" Version="$(SystemSecurityCryptographyXmlVersion)" />
+
     <PackageReference Update="System.Security.Cryptography.X509Certificates" Version="4.3.2" />
+    <PackageReference Update="System.Security.Cryptography.X509Certificates" Condition="'$(SystemSecurityCryptographyX509CertificatesVersion)' != ''" Version="$(SystemSecurityCryptographyX509CertificatesVersion)" />
   </ItemGroup>
 
   <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true' AND $(ProjectIsDeprecated) != 'true'">
     <GlobalPackageReference Include="Microsoft.CodeAnalysis.BannedApiAnalyzers" Version="3.3.3" />
     <GlobalPackageReference Include="StyleCop.Analyzers" Version="1.2.0-beta.435" PrivateAssets="all"/>
-  </ItemGroup>
-
-  <ItemGroup>
     <GlobalPackageReference Include="Microsoft.VisualStudio.SDK.EmbedInteropTypes" Version="15.0.36" PrivateAssets="All" Condition="'$(TargetFrameworkIdentifier)' == '.NETFramework'" />
   </ItemGroup>
 
diff --git a/global.json b/global.json
index 471f88dbc9b..a843753a471 100644
--- a/global.json
+++ b/global.json
@@ -10,6 +10,6 @@
   },
   "msbuild-sdks": {
     "Microsoft.Build.CentralPackageVersions": "2.0.1",
-    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22314.7"
+    "Microsoft.DotNet.Arcade.Sdk": "6.0.0-beta.22362.2"
   }
 }
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index ef1959fc3b6..f6044dd6940 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -121,6 +121,7 @@ if ($runtime -eq "Desktop") {
         FileToCopy "$bootstrapBinDirectory\System.Collections.Immutable.dll"
         FileToCopy "$bootstrapBinDirectory\System.Memory.dll"
         FileToCopy "$bootstrapBinDirectory\System.Numerics.Vectors.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Reflection.MetadataLoadContext.dll"
         FileToCopy "$bootstrapBinDirectory\System.Resources.Extensions.dll"
         FileToCopy "$bootstrapBinDirectory\System.Runtime.CompilerServices.Unsafe.dll"
         FileToCopy "$bootstrapBinDirectory\System.Text.Encodings.Web.dll"
diff --git a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
index 9760dcf7a92..51d86b2f804 100644
--- a/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
+++ b/src/Build.OM.UnitTests/Microsoft.Build.Engine.OM.UnitTests.csproj
@@ -1,4 +1,4 @@
-﻿<Project Sdk="Microsoft.NET.Sdk">
+<Project Sdk="Microsoft.NET.Sdk">
 
   <Import Project="..\Shared\FileSystemSources.proj" />
   <Import Project="..\Shared\DebuggingSources.proj" />
@@ -78,8 +78,8 @@
     <Compile Include="..\Shared\UnitTests\TestData\GlobbingTestData.cs">
       <Link>TestData\GlobbingTestData.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\ProcessExtensions.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
-
     <None Include="..\Shared\UnitTests\App.config">
       <Link>App.config</Link>
       <SubType>Designer</SubType>
diff --git a/src/Build.OM.UnitTests/NugetRestoreTests.cs b/src/Build.OM.UnitTests/NugetRestoreTests.cs
index 3c75c36b772..daf8cbea8d0 100644
--- a/src/Build.OM.UnitTests/NugetRestoreTests.cs
+++ b/src/Build.OM.UnitTests/NugetRestoreTests.cs
@@ -10,8 +10,6 @@
 #endif
 using Xunit.Abstractions;
 
-#nullable disable
-
 namespace Microsoft.Build.Engine.OM.UnitTests
 {
     public sealed class NugetRestoreTests
@@ -29,7 +27,7 @@ public NugetRestoreTests(ITestOutputHelper output)
         [Fact]
         public void TestOldNuget()
         {
-            string msbuildExePath = Path.GetDirectoryName(RunnerUtilities.PathToCurrentlyRunningMsBuildExe);
+            string msbuildExePath = Path.GetDirectoryName(RunnerUtilities.PathToCurrentlyRunningMsBuildExe)!;
             using TestEnvironment testEnvironment = TestEnvironment.Create();
             TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
             // The content of the solution isn't known to matter, but having a custom solution makes it easier to add requirements should they become evident.
diff --git a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
index ffd6ed0068e..c9266d1c53f 100644
--- a/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/AssemblyTaskFactory_Tests.cs
@@ -220,7 +220,7 @@ public void CreatableByTaskFactoryMismatchedIdentity()
         public void VerifyGetTaskParameters()
         {
             TaskPropertyInfo[] propertyInfos = _taskFactory.GetTaskParameters();
-            LoadedType comparisonType = new LoadedType(typeof(TaskToTestFactories), _loadInfo);
+            LoadedType comparisonType = new LoadedType(typeof(TaskToTestFactories), _loadInfo, typeof(TaskToTestFactories).GetTypeInfo().Assembly, typeof(ITaskItem));
             PropertyInfo[] comparisonInfo = comparisonType.Type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
             Assert.Equal(comparisonInfo.Length, propertyInfos.Length);
 
diff --git a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
index eae0afe3751..fdaf722b36c 100644
--- a/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/BuildManager_Tests.cs
@@ -4211,15 +4211,17 @@ public void GraphBuildInvalid()
         {
             string project1 = _env.CreateFile(".proj").Path;
             string project2 = _env.CreateFile(".proj").Path;
+            string project3 = _env.CreateFile(".proj").Path;
 
             File.WriteAllText(project1, CleanupFileContents($@"
 <Project>
   <ItemGroup>
     <ProjectReferenceTargets Include='Build' Targets='Build' />
     <ProjectReference Include='{project2}' />
+    <ProjectReference Include='{project3}' />
   </ItemGroup>
   <Target Name='Build'>
-    <MsBuild Projects='{project2}' Targets='Build' />
+    <MsBuild Projects='@(ProjectReference)' Targets='Build' />
   </Target>
 </Project>
 "));
@@ -4227,14 +4229,22 @@ public void GraphBuildInvalid()
 <Project>
   <WellThisIsntValid>
 </Project>
+"));
+            File.WriteAllText(project3, CleanupFileContents(@"
+<Project>
+  <WellThisIsntValid>
+</Project>
 "));
 
             var data = new GraphBuildRequestData(new ProjectGraphEntryPoint(project1), Array.Empty<string>());
 
             GraphBuildResult result = _buildManager.Build(_parameters, data);
-            result.OverallResult.ShouldBe(BuildResultCode.Failure);
-            result.Exception.ShouldBeOfType<InvalidProjectFileException>()
-                .ProjectFile.ShouldBe(project2);
+            result.ShouldHaveFailed();
+
+            AggregateException aggException = result.Exception.ShouldBeOfType<AggregateException>();
+            aggException.InnerExceptions.Count.ShouldBe(2);
+            aggException.InnerExceptions[0].ShouldBeOfType<InvalidProjectFileException>().ProjectFile.ShouldBeOneOf(project2, project3);
+            aggException.InnerExceptions[1].ShouldBeOfType<InvalidProjectFileException>().ProjectFile.ShouldBeOneOf(project2, project3);
         }
 
         [Fact]
diff --git a/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs b/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs
new file mode 100644
index 00000000000..a0ae7a9fafd
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/KnownTelemetry_Tests.cs
@@ -0,0 +1,121 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable disable
+using System;
+using System.Globalization;
+using Microsoft.Build.Framework.Telemetry;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.UnitTests.Telemetry;
+
+public class KnownTelemetry_Tests
+{
+    [Fact]
+    public void BuildTelemetryCanBeSetToNull()
+    {
+        KnownTelemetry.BuildTelemetry = new BuildTelemetry();
+        KnownTelemetry.BuildTelemetry = null;
+
+        KnownTelemetry.BuildTelemetry.ShouldBeNull();
+    }
+
+    [Fact]
+    public void BuildTelemetryCanBeSet()
+    {
+        BuildTelemetry buildTelemetry = new BuildTelemetry();
+        KnownTelemetry.BuildTelemetry = buildTelemetry;
+
+        KnownTelemetry.BuildTelemetry.ShouldBeSameAs(buildTelemetry);
+    }
+
+    [Fact]
+    public void BuildTelemetryConstructedHasNoProperties()
+    {
+        BuildTelemetry buildTelemetry = new BuildTelemetry();
+
+        buildTelemetry.DisplayVersion.ShouldBeNull();
+        buildTelemetry.EventName.ShouldBe("build");
+        buildTelemetry.FinishedAt.ShouldBeNull();
+        buildTelemetry.FrameworkName.ShouldBeNull();
+        buildTelemetry.Host.ShouldBeNull();
+        buildTelemetry.InitialServerState.ShouldBeNull();
+        buildTelemetry.InnerStartAt.ShouldBeNull();
+        buildTelemetry.Project.ShouldBeNull();
+        buildTelemetry.ServerFallbackReason.ShouldBeNull();
+        buildTelemetry.StartAt.ShouldBeNull();
+        buildTelemetry.Success.ShouldBeNull();
+        buildTelemetry.Target.ShouldBeNull();
+        buildTelemetry.Version.ShouldBeNull();
+
+        buildTelemetry.UpdateEventProperties();
+        buildTelemetry.Properties.ShouldBeEmpty();
+    }
+
+    [Fact]
+    public void BuildTelemetryCreateProperProperties()
+    {
+        BuildTelemetry buildTelemetry = new BuildTelemetry();
+
+        DateTime startAt = new DateTime(2023, 01, 02, 10, 11, 22);
+        DateTime innerStartAt = new DateTime(2023, 01, 02, 10, 20, 30);
+        DateTime finishedAt = new DateTime(2023, 12, 13, 14, 15, 16);
+
+        buildTelemetry.DisplayVersion = "Some Display Version";
+        buildTelemetry.FinishedAt = finishedAt;
+        buildTelemetry.FrameworkName = "new .NET";
+        buildTelemetry.Host = "Host description";
+        buildTelemetry.InitialServerState = "hot";
+        buildTelemetry.InnerStartAt = innerStartAt;
+        buildTelemetry.Project = @"C:\\dev\\theProject";
+        buildTelemetry.ServerFallbackReason = "busy";
+        buildTelemetry.StartAt = startAt;
+        buildTelemetry.Success = true;
+        buildTelemetry.Target = "clean";
+        buildTelemetry.Version = new Version(1, 2, 3, 4);
+
+        buildTelemetry.UpdateEventProperties();
+        buildTelemetry.Properties.Count.ShouldBe(11);
+
+        buildTelemetry.Properties["BuildEngineDisplayVersion"].ShouldBe("Some Display Version");
+        buildTelemetry.Properties["BuildEngineFrameworkName"].ShouldBe("new .NET");
+        buildTelemetry.Properties["BuildEngineHost"].ShouldBe("Host description");
+        buildTelemetry.Properties["InitialMSBuildServerState"].ShouldBe("hot");
+        buildTelemetry.Properties["ProjectPath"].ShouldBe(@"C:\\dev\\theProject");
+        buildTelemetry.Properties["ServerFallbackReason"].ShouldBe("busy");
+        buildTelemetry.Properties["BuildSuccess"].ShouldBe("True");
+        buildTelemetry.Properties["BuildTarget"].ShouldBe("clean");
+        buildTelemetry.Properties["BuildEngineVersion"].ShouldBe("1.2.3.4");
+
+        // verify computed
+        buildTelemetry.Properties["BuildDurationInMilliseconds"] = (finishedAt - startAt).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+        buildTelemetry.Properties["InnerBuildDurationInMilliseconds"] = (finishedAt - innerStartAt).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+    }
+
+    [Fact]
+    public void BuildTelemetryHandleNullsInRecordedTimes()
+    {
+        BuildTelemetry buildTelemetry = new BuildTelemetry();
+
+        buildTelemetry.StartAt = DateTime.MinValue;
+        buildTelemetry.FinishedAt = null;
+        buildTelemetry.UpdateEventProperties();
+        buildTelemetry.Properties.ShouldBeEmpty();
+
+        buildTelemetry.StartAt = null;
+        buildTelemetry.FinishedAt = DateTime.MaxValue;
+        buildTelemetry.UpdateEventProperties();
+        buildTelemetry.Properties.ShouldBeEmpty();
+
+        buildTelemetry.InnerStartAt = DateTime.MinValue;
+        buildTelemetry.FinishedAt = null;
+        buildTelemetry.UpdateEventProperties();
+        buildTelemetry.Properties.ShouldBeEmpty();
+
+        buildTelemetry.InnerStartAt = null;
+        buildTelemetry.FinishedAt = DateTime.MaxValue;
+        buildTelemetry.UpdateEventProperties();
+        buildTelemetry.Properties.ShouldBeEmpty();
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
index 55a1959e969..0226f87e7a7 100644
--- a/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/MSBuild_Tests.cs
@@ -314,6 +314,56 @@ public void SkipNonexistentProjectsBuildingInParallel()
             Assert.DoesNotContain(error, logger.FullLog);
         }
 
+        /// <summary>
+        /// Verifies that nonexistent projects are skipped when requested when building in parallel.
+        /// DDB # 125831
+        /// </summary>
+        [Fact]
+        public void SkipNonexistentProjectsAsMetadataBuildingInParallel()
+        {
+            ObjectModelHelpers.DeleteTempProjectDirectory();
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(
+                "SkipNonexistentProjectsMain.csproj",
+                @"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                    <Target Name=`t` >
+                        <ItemGroup>
+                            <ProjectReference Include=`this_project_does_not_exist_warn.csproj` >
+                                <SkipNonexistentProjects>true</SkipNonexistentProjects>
+                            </ProjectReference>
+                            <ProjectReference Include=`this_project_does_not_exist_error.csproj` >
+                            </ProjectReference>
+                            <ProjectReference Include=`foo.csproj` >
+                                <SkipNonexistentProjects>false</SkipNonexistentProjects>
+                            </ProjectReference>
+                        </ItemGroup>
+                        <MSBuild Projects=`@(ProjectReference)` BuildInParallel=`true` />
+                    </Target>
+                </Project>
+                ");
+
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(
+                "foo.csproj",
+                @"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                    <Target Name=`t` >
+                        <Message Text=`Hello from foo.csproj`/>
+                    </Target>
+                </Project>
+                ");
+
+            MockLogger logger = new MockLogger(_testOutput);
+            ObjectModelHelpers.BuildTempProjectFileExpectFailure(@"SkipNonexistentProjectsMain.csproj", logger);
+
+            logger.AssertLogContains("Hello from foo.csproj");
+            string message = String.Format(AssemblyResources.GetString("MSBuild.ProjectFileNotFoundMessage"), "this_project_does_not_exist_warn.csproj");
+            string error = String.Format(AssemblyResources.GetString("MSBuild.ProjectFileNotFound"), "this_project_does_not_exist_warn.csproj");
+            string error2 = String.Format(AssemblyResources.GetString("MSBuild.ProjectFileNotFound"), "this_project_does_not_exist_error.csproj");
+            Assert.Equal(0, logger.WarningCount);
+            Assert.Equal(1, logger.ErrorCount);
+            Assert.Contains(message, logger.FullLog); // for the missing project
+            Assert.Contains(error2, logger.FullLog);
+            Assert.DoesNotContain(error, logger.FullLog);
+        }
+
         [Fact]
         public void LogErrorWhenBuildingVCProj()
         {
diff --git a/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs b/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
new file mode 100644
index 00000000000..a5d7d8be2a2
--- /dev/null
+++ b/src/Build.UnitTests/BackEnd/RedirectConsoleWriter_Tests.cs
@@ -0,0 +1,31 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.IO;
+using System.Text;
+using System.Threading.Tasks;
+using Microsoft.Build.Experimental;
+using Shouldly;
+using Xunit;
+
+namespace Microsoft.Build.Engine.UnitTests.BackEnd
+{
+    public class RedirectConsoleWriter_Tests
+    {
+        [Fact]
+        public async Task EmitConsoleMessages()
+        {
+            StringBuilder sb = new StringBuilder();
+
+            using (TextWriter writer = OutOfProcServerNode.RedirectConsoleWriter.Create(text => sb.Append(text)))
+            {
+                writer.WriteLine("Line 1");
+                await Task.Delay(80); // should be somehow bigger than `RedirectConsoleWriter` flush period - see its constructor
+                writer.Write("Line 2");
+            }
+
+            sb.ToString().ShouldBe($"Line 1{Environment.NewLine}Line 2");
+        }
+    }
+}
diff --git a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
index 64b62861d6f..a90afeabc38 100644
--- a/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TargetUpToDateChecker_Tests.cs
@@ -16,6 +16,7 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -919,6 +920,8 @@ bool includeOutput2
         private static readonly DateTime New = new DateTime(2002, 1, 1);
 
         [Fact(Skip = "Creating a symlink on Windows requires elevation.")]
+        [SkipOnPlatform(TestPlatforms.AnyUnix, "Windows-specific test")]
+        [SupportedOSPlatform("windows")]
         public void NewSymlinkOldDestinationIsUpToDate()
         {
             SimpleSymlinkInputCheck(symlinkWriteTime: New,
@@ -928,6 +931,8 @@ public void NewSymlinkOldDestinationIsUpToDate()
         }
 
         [Fact(Skip = "Creating a symlink on Windows requires elevation.")]
+        [SkipOnPlatform(TestPlatforms.AnyUnix, "Windows-specific test")]
+        [SupportedOSPlatform("windows")]
         public void OldSymlinkOldDestinationIsUpToDate()
         {
             SimpleSymlinkInputCheck(symlinkWriteTime: Old,
@@ -937,6 +942,8 @@ public void OldSymlinkOldDestinationIsUpToDate()
         }
 
         [Fact(Skip = "Creating a symlink on Windows requires elevation.")]
+        [SkipOnPlatform(TestPlatforms.AnyUnix, "Windows-specific test")]
+        [SupportedOSPlatform("windows")]
         public void OldSymlinkNewDestinationIsNotUpToDate()
         {
             SimpleSymlinkInputCheck(symlinkWriteTime: Old,
@@ -946,6 +953,8 @@ public void OldSymlinkNewDestinationIsNotUpToDate()
         }
 
         [Fact(Skip = "Creating a symlink on Windows requires elevation.")]
+        [SkipOnPlatform(TestPlatforms.AnyUnix, "Windows-specific test")]
+        [SupportedOSPlatform("windows")]
         public void NewSymlinkNewDestinationIsNotUpToDate()
         {
             SimpleSymlinkInputCheck(symlinkWriteTime: Middle,
@@ -956,12 +965,15 @@ public void NewSymlinkNewDestinationIsNotUpToDate()
 
         [DllImport("kernel32.dll")]
         [return: MarshalAs(UnmanagedType.Bool)]
+        [SupportedOSPlatform("windows")]
         static extern bool CreateSymbolicLink(string lpSymlinkFileName, string lpTargetFileName, UInt32 dwFlags);
 
         [DllImport("kernel32.dll", SetLastError = true)]
+        [SupportedOSPlatform("windows")]
         private static extern bool SetFileTime(SafeFileHandle hFile, ref long creationTime,
             ref long lastAccessTime, ref long lastWriteTime);
 
+        [SupportedOSPlatform("windows")]
         private void SimpleSymlinkInputCheck(DateTime symlinkWriteTime, DateTime targetWriteTime,
             DateTime outputWriteTime, bool expectedOutOfDate)
         {
diff --git a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
index 9f3cd6388b1..ed7e39fdcca 100644
--- a/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
+++ b/src/Build.UnitTests/BackEnd/TaskExecutionHost_Tests.cs
@@ -1161,7 +1161,7 @@ private void InitializeHost(bool throwOnExecute)
 #else
             AssemblyLoadInfo loadInfo = AssemblyLoadInfo.Create(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).GetTypeInfo().FullName, null);
 #endif
-            LoadedType loadedType = new LoadedType(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory), loadInfo);
+            LoadedType loadedType = new LoadedType(typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory), loadInfo, typeof(TaskBuilderTestTask.TaskBuilderTestTaskFactory).GetTypeInfo().Assembly, typeof(ITaskItem));
 
             TaskBuilderTestTask.TaskBuilderTestTaskFactory taskFactory = new TaskBuilderTestTask.TaskBuilderTestTaskFactory();
             taskFactory.ThrowOnExecute = throwOnExecute;
diff --git a/src/Build.UnitTests/BinaryLogger_Tests.cs b/src/Build.UnitTests/BinaryLogger_Tests.cs
index 71983787418..cb255f7ae9b 100644
--- a/src/Build.UnitTests/BinaryLogger_Tests.cs
+++ b/src/Build.UnitTests/BinaryLogger_Tests.cs
@@ -1,13 +1,12 @@
 ﻿using System;
 using System.Collections.Generic;
-using System.IO;
 using System.Text;
 
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Logging;
-using Microsoft.Build.UnitTests.Shared;
+
 using Shouldly;
 using Xunit;
 using Xunit.Abstractions;
@@ -139,45 +138,6 @@ public void BinaryLoggerShouldSupportFilePathExplicitParameter()
             ObjectModelHelpers.BuildProjectExpectSuccess(s_testProject, binaryLogger);
         }
 
-        [Fact]
-        public void UnusedEnvironmentVariablesDoNotAppearInBinaryLog()
-        {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                env.SetEnvironmentVariable("EnvVar1", "itsValue");
-                env.SetEnvironmentVariable("EnvVar2", "value2");
-                env.SetEnvironmentVariable("EnvVar3", "value3");
-                string contents = @"
-<Project DefaultTargets=""PrintEnvVar"">
-
-<PropertyGroup>
-<MyProp1>value</MyProp1>
-<MyProp2>$(EnvVar2)</MyProp2>
-</PropertyGroup>
-
-<Target Name=""PrintEnvVar"">
-<Message Text=""Environment variable EnvVar3 has value $(EnvVar3)"" Importance=""High"" />
-</Target>
-
-</Project>";
-                TransientTestFolder logFolder = env.CreateFolder(createFolder: true);
-                TransientTestFile projectFile = env.CreateFile(logFolder, "myProj.proj", contents);
-                BinaryLogger logger = new();
-                logger.Parameters = _logFile;
-                RunnerUtilities.ExecMSBuild($"{projectFile.Path} -bl:{logger.Parameters}", out bool success);
-                success.ShouldBeTrue();
-                RunnerUtilities.ExecMSBuild($"{logger.Parameters} -flp:logfile={Path.Combine(logFolder.Path, "logFile.log")};verbosity=diagnostic", out success);
-                success.ShouldBeTrue();
-                string text = File.ReadAllText(Path.Combine(logFolder.Path, "logFile.log"));
-                text.ShouldContain("EnvVar2");
-                text.ShouldContain("value2");
-                text.ShouldContain("EnvVar3");
-                text.ShouldContain("value3");
-                text.ShouldNotContain("EnvVar1");
-                text.ShouldNotContain("itsValue");
-            }
-        }
-
         [Fact]
         public void BinaryLoggerShouldNotThrowWhenMetadataCannotBeExpanded()
         {
diff --git a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
index 9b9deeef04a..4ad1bb35cac 100644
--- a/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
+++ b/src/Build.UnitTests/BuildEventArgsSerialization_Tests.cs
@@ -24,36 +24,30 @@ public BuildEventArgsSerializationTests()
             _ = ItemGroupLoggingHelper.ItemGroupIncludeLogMessagePrefix;
         }
 
-        [Theory]
-        [InlineData(true)]
-        [InlineData(false)]
-        public void RoundtripBuildStartedEventArgs(bool serializeAllEnvironmentVariables)
+        [Fact]
+        public void RoundtripBuildStartedEventArgs()
         {
-            using (TestEnvironment env = TestEnvironment.Create())
-            {
-                env.SetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES", serializeAllEnvironmentVariables ? "1" : null);
-                var args = new BuildStartedEventArgs(
-                    "Message",
-                    "HelpKeyword",
-                    DateTime.Parse("3/1/2017 11:11:56 AM"));
-                Roundtrip(args,
-                    e => e.Message,
-                    e => e.HelpKeyword,
-                    e => e.Timestamp.ToString());
-
-                args = new BuildStartedEventArgs(
-                    "M",
-                    null,
-                    new Dictionary<string, string>
-                    {
+            var args = new BuildStartedEventArgs(
+                "Message",
+                "HelpKeyword",
+                DateTime.Parse("3/1/2017 11:11:56 AM"));
+            Roundtrip(args,
+                e => e.Message,
+                e => e.HelpKeyword,
+                e => e.Timestamp.ToString());
+
+            args = new BuildStartedEventArgs(
+                "M",
+                null,
+                new Dictionary<string, string>
+                {
                     { "SampleName", "SampleValue" }
-                    });
-                Roundtrip(args,
-                    e => serializeAllEnvironmentVariables ? TranslationHelpers.ToString(e.BuildEnvironment) : null,
-                    e => e.HelpKeyword,
-                    e => e.ThreadId.ToString(),
-                    e => e.SenderName);
-            }
+                });
+            Roundtrip(args,
+                e => TranslationHelpers.ToString(e.BuildEnvironment),
+                e => e.HelpKeyword,
+                e => e.ThreadId.ToString(),
+                e => e.SenderName);
         }
 
         [Fact]
@@ -179,17 +173,6 @@ public void RoundtripTaskStartedEventArgs()
                 e => e.ColumnNumber.ToString());
         }
 
-        [Fact]
-        public void RoundtripEnvironmentVariableReadEventArgs()
-        {
-            EnvironmentVariableReadEventArgs args = new("VarName", "VarValue");
-            args.BuildEventContext = new BuildEventContext(4, 5, 6, 7);
-            Roundtrip(args,
-                e => e.Message,
-                e => e.EnvironmentVariableName,
-                e => e.BuildEventContext.ToString());
-        }
-
         [Fact]
         public void RoundtripTaskFinishedEventArgs()
         {
diff --git a/src/Build.UnitTests/ConsoleLogger_Tests.cs b/src/Build.UnitTests/ConsoleLogger_Tests.cs
index 1a44ce8fdb0..be8dfc1cdb2 100644
--- a/src/Build.UnitTests/ConsoleLogger_Tests.cs
+++ b/src/Build.UnitTests/ConsoleLogger_Tests.cs
@@ -20,6 +20,7 @@
 using Xunit;
 using Xunit.Abstractions;
 using Microsoft.Build.Execution;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -2461,6 +2462,7 @@ public void TestNewLineAfterProjectFinished()
         /// Check to see what kind of device we are outputting the log to, is it a character device, a file, or something else
         /// this can be used by loggers to modify their outputs based on the device they are writing to
         /// </summary>
+        [SupportedOSPlatform("windows")]
         internal bool IsRunningWithCharacterFileType()
         {
             // Get the std out handle
diff --git a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
index 2b50c83925d..780b83ffa0b 100644
--- a/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
+++ b/src/Build.UnitTests/Construction/SolutionProjectGenerator_Tests.cs
@@ -123,6 +123,161 @@ public void BuildProjectAsTarget()
             }
         }
 
+        /// <summary>
+        /// Build Solution with Multiple Targets (ex. Clean;Build;Custom).
+        /// </summary>
+        [Fact]
+        public void BuildProjectWithMultipleTargets()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "classlib"), createFolder: true);
+                TransientTestFile classLibrary = testEnvironment.CreateFile(classLibFolder, "classlib.csproj",
+                    @"<Project>
+                  <Target Name=""Build"">
+                      <Message Text=""classlib.Build""/>
+                  </Target>
+                  <Target Name=""Clean"">
+                      <Message Text=""classlib.Clean""/>
+                  </Target>
+                  <Target Name=""Custom"">
+                      <Message Text=""classlib.Custom""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "simpleProject"), createFolder: true);
+                TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectFolder, "simpleProject.csproj",
+                    @"<Project>
+                  <Target Name=""Build"">
+                      <Message Text=""simpleProject.Build""/>
+                  </Target>
+                  <Target Name=""Clean"">
+                      <Message Text=""simpleProject.Clean""/>
+                  </Target>
+                  <Target Name=""Custom"">
+                      <Message Text=""simpleProject.Custom""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "testFolder.sln",
+                    @"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 16
+VisualStudioVersion = 16.6.30114.105
+MinimumVisualStudioVersion = 10.0.40219.1
+Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""simpleProject"", ""simpleProject\simpleProject.csproj"", ""{AA52A05F-A9C0-4C89-9933-BF976A304C91}""
+EndProject
+Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""classlib"", ""classlib\classlib.csproj"", ""{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}""
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x86 = Debug|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.ActiveCfg = Debug|x86
+		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.Build.0 = Debug|x86
+		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.ActiveCfg = Debug|x86
+		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.Build.0 = Debug|x86
+	EndGlobalSection
+EndGlobal
+                ");
+
+                string output = RunnerUtilities.ExecMSBuild(solutionFile.Path + " /t:Clean;Build;Custom", out bool success);
+                success.ShouldBeTrue();
+                output.ShouldContain("classlib.Build");
+                output.ShouldContain("classlib.Clean");
+                output.ShouldContain("classlib.Custom");
+                output.ShouldContain("simpleProject.Build");
+                output.ShouldContain("simpleProject.Clean");
+                output.ShouldContain("simpleProject.Custom");
+            }
+        }
+
+
+        /// <summary>
+        /// Build Solution with Multiple Targets (ex. Clean;Build;Custom).
+        /// </summary>
+        [Fact]
+        public void BuildProjectWithMultipleTargetsInParallel()
+        {
+            using (TestEnvironment testEnvironment = TestEnvironment.Create())
+            {
+                TransientTestFolder folder = testEnvironment.CreateFolder(createFolder: true);
+                TransientTestFolder classLibFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "classlib"), createFolder: true);
+                TransientTestFile classLibrary = testEnvironment.CreateFile(classLibFolder, "classlib.csproj",
+                    @"<Project>
+                  <Target Name=""Build"">
+                      <Message Text=""classlib.Build""/>
+                  </Target>
+                  <Target Name=""Clean"">
+                      <Message Text=""classlib.Clean""/>
+                  </Target>
+                  <Target Name=""Custom"">
+                      <Message Text=""classlib.Custom""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                TransientTestFolder simpleProjectFolder = testEnvironment.CreateFolder(Path.Combine(folder.Path, "simpleProject"), createFolder: true);
+                TransientTestFile simpleProject = testEnvironment.CreateFile(simpleProjectFolder, "simpleProject.csproj",
+                    @"<Project>
+                  <Target Name=""Build"">
+                      <Message Text=""simpleProject.Build""/>
+                  </Target>
+                  <Target Name=""Clean"">
+                      <Message Text=""simpleProject.Clean""/>
+                  </Target>
+                  <Target Name=""Custom"">
+                      <Message Text=""simpleProject.Custom""/>
+                  </Target>
+                  </Project>
+                    ");
+
+                TransientTestFile solutionFile = testEnvironment.CreateFile(folder, "testFolder.sln",
+                    @"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 16
+VisualStudioVersion = 16.6.30114.105
+MinimumVisualStudioVersion = 10.0.40219.1
+Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""simpleProject"", ""simpleProject\simpleProject.csproj"", ""{AA52A05F-A9C0-4C89-9933-BF976A304C91}""
+EndProject
+Project(""{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}"") = ""classlib"", ""classlib\classlib.csproj"", ""{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}""
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x86 = Debug|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.ActiveCfg = Debug|x86
+		{AA52A05F-A9C0-4C89-9933-BF976A304C91}.Debug|x86.Build.0 = Debug|x86
+		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.ActiveCfg = Debug|x86
+		{80B8E6B8-E46D-4456-91B1-848FD35C4AB9}.Debug|x86.Build.0 = Debug|x86
+	EndGlobalSection
+EndGlobal
+                ");
+
+                try
+                {
+                    Environment.SetEnvironmentVariable("MSBuildSolutionBatchTargets", "1");
+                    var output = RunnerUtilities.ExecMSBuild(solutionFile.Path + " /m /t:Clean;Build;Custom", out bool success);
+                    success.ShouldBeTrue();
+                    output.ShouldContain("classlib.Build");
+                    output.ShouldContain("classlib.Clean");
+                    output.ShouldContain("classlib.Custom");
+                    output.ShouldContain("simpleProject.Build");
+                    output.ShouldContain("simpleProject.Clean");
+                    output.ShouldContain("simpleProject.Custom");
+                }
+                finally
+                {
+                    Environment.SetEnvironmentVariable("MSBuildSolutionBatchTargets", "");
+                }
+            }
+        }
+
         /// <summary>
         /// Verify the AddNewErrorWarningMessageElement method
         /// </summary>
diff --git a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
index 51d649107b5..997e40b8c83 100644
--- a/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
+++ b/src/Build.UnitTests/Evaluation/Evaluator_Tests.cs
@@ -4522,7 +4522,7 @@ public void VerifyMSBuildLogsAMessageWhenLocalPropertyCannotOverrideValueOfGloba
         [Fact]
         public void VerifyPropertyTrackingLoggingDefault()
         {
-            // Having just environment variables defined should default to nothing being logged except one environment variable read.
+            // Having nothing defined should default to nothing being logged.
             this.VerifyPropertyTrackingLoggingScenario(
                 null,
                 logger =>
@@ -4535,9 +4535,7 @@ public void VerifyPropertyTrackingLoggingDefault()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldHaveSingleItem()
-                        .EnvironmentVariableName
-                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
+                        .ShouldBeEmpty();
 
                     logger
                         .AllBuildEvents
@@ -4566,9 +4564,7 @@ public void VerifyPropertyTrackingLoggingPropertyReassignment()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldHaveSingleItem()
-                        .EnvironmentVariableName
-                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
+                        .ShouldBeEmpty();
 
                     logger
                         .AllBuildEvents
@@ -4597,9 +4593,7 @@ public void VerifyPropertyTrackingLoggingNone()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldHaveSingleItem()
-                        .EnvironmentVariableName
-                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
+                        .ShouldBeEmpty();
 
                     logger
                         .AllBuildEvents
@@ -4628,9 +4622,7 @@ public void VerifyPropertyTrackingLoggingPropertyInitialValue()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldHaveSingleItem()
-                        .EnvironmentVariableName
-                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
+                        .ShouldBeEmpty();
 
                     logger
                         .AllBuildEvents
@@ -4714,9 +4706,7 @@ public void VerifyPropertyTrackingLoggingUninitializedPropertyRead()
                     logger
                         .AllBuildEvents
                         .OfType<EnvironmentVariableReadEventArgs>()
-                        .ShouldHaveSingleItem()
-                        .EnvironmentVariableName
-                        .ShouldBe("DEFINED_ENVIRONMENT_VARIABLE2");
+                        .ShouldBeEmpty();
 
                     logger
                         .AllBuildEvents
diff --git a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
index f1a31f7dbe6..f198b324c2c 100644
--- a/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/GetCompatiblePlatformGraph_Tests.cs
@@ -75,6 +75,47 @@ public void ValidateSetPlatformOverride()
             }
         }
 
+        [Fact]
+        public void ResolvesMultipleReferencesToSameProject()
+        {
+            using (var env = TestEnvironment.Create())
+            {
+
+                TransientTestFile entryProject = CreateProjectFile(env, 1, extraContent: @"<PropertyGroup>
+                                                                                                <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                                                                <Platform>x64</Platform>
+                                                                                                <PlatformLookupTable>win32=x64</PlatformLookupTable>
+                                                                                            </PropertyGroup>
+                                                                                            <ItemGroup>
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)2.proj"" />
+                                                                                                <ProjectReference Include=""$(MSBuildThisFileDirectory)3.proj"" />
+                                                                                            </ItemGroup>");
+                var proj2 = env.CreateFile("2.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <EnableDynamicPlatformResolution>true</EnableDynamicPlatformResolution>
+                                                            <Platforms>AnyCPU</Platforms>
+                                                        </PropertyGroup>
+                                                        <ItemGroup>
+                                                            <ProjectReference Include=""$(MSBuildThisFileDirectory)3.proj"" />
+                                                        </ItemGroup>
+                                                    </Project>");
+
+                var proj3 = env.CreateFile("3.proj", @"
+                                                    <Project>
+                                                        <PropertyGroup>
+                                                            <Platforms>AnyCPU</Platforms>
+                                                        </PropertyGroup>
+                                                    </Project>");
+
+
+                ProjectGraph graph = new ProjectGraph(entryProject.Path);
+                GetFirstNodeWithProjectNumber(graph, 2).ProjectInstance.GlobalProperties["Platform"].ShouldBe("AnyCPU");
+                GetFirstNodeWithProjectNumber(graph, 3).ProjectInstance.GlobalProperties["Platform"].ShouldBe("AnyCPU");
+                graph.ProjectNodes.Count.ShouldBe(3);
+            }
+        }
+
         [Fact]
         public void ResolvesViaPlatformLookupTable()
         {
diff --git a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
index 592bec82908..318c2c6f92f 100644
--- a/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
+++ b/src/Build.UnitTests/Graph/GraphLoadedFromSolution_tests.cs
@@ -78,12 +78,10 @@ public void StaticGraphShouldNotSupportNestedSolutions()
                 defaultTargets: null,
                 extraContent: referenceToSolution);
 
-            var exception = Should.Throw<InvalidOperationException>(
-                () =>
-                {
-                    new ProjectGraph(root.Path);
-                });
+            var aggException = Should.Throw<AggregateException>(() => new ProjectGraph(root.Path));
+            aggException.InnerExceptions.ShouldHaveSingleItem();
 
+            var exception = aggException.InnerExceptions[0].ShouldBeOfType<InvalidOperationException>();
             exception.Message.ShouldContain("MSB4263:");
         }
 
diff --git a/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs b/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
index f4251fcde21..26575faf9aa 100644
--- a/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
+++ b/src/Build.UnitTests/Graph/ParallelWorkSet_Tests.cs
@@ -1,7 +1,6 @@
 ﻿using System;
 using System.Collections.Generic;
 using System.Threading;
-using Microsoft.Build.Shared;
 using Microsoft.Build.UnitTests;
 using Shouldly;
 using Xunit;
@@ -19,7 +18,7 @@ private class ParallelWorkSetTestCase
 
             internal Dictionary<string, string> ExpectedCompletedWork =
                 new Dictionary<string, string>(StringComparer.Ordinal);
-            internal bool ShouldExpectException { get; set; }
+            internal int NumExpectedExceptions { get; set; }
         }
 
         private struct WorkItem
@@ -55,7 +54,7 @@ public void GivenExceptionsOnCompletionThread_CompletesAndThrowsException()
                         WorkFunc = () => throw new Exception()
                     }
                 },
-                ShouldExpectException = true
+                NumExpectedExceptions = 3
             });
         }
 
@@ -83,7 +82,7 @@ public void GivenExceptionsOnWorkerThread_CompletesAndThrowsExceptions()
                         WorkFunc = () => throw new Exception()
                     }
                 },
-                ShouldExpectException = true
+                NumExpectedExceptions = 3
             });
         }
 
@@ -236,15 +235,33 @@ private void TestParallelWorkSet(ParallelWorkSetTestCase tt)
         {
             _workSet = new ParallelWorkSet<string, string>(tt.DegreeOfParallelism, StringComparer.Ordinal, CancellationToken.None);
 
+            List<Exception> observedExceptions = new();
+
             foreach (WorkItem workItem in tt.WorkItemsToAdd)
             {
-                _workSet.AddWork(workItem.Key, workItem.WorkFunc);
+                _workSet.AddWork(
+                    workItem.Key,
+                    () =>
+                    {
+                        try
+                        {
+                            return workItem.WorkFunc();
+                        }
+                        catch (Exception ex)
+                        {
+                            lock (observedExceptions)
+                            {
+                                observedExceptions.Add(ex);
+                            }
+
+                            throw;
+                        }
+                    });
             }
 
-            if (tt.ShouldExpectException)
+            if (tt.NumExpectedExceptions > 0)
             {
-                Should.Throw<Exception>(() => _workSet.WaitForAllWorkAndComplete());
-
+                Should.Throw<AggregateException>(() => _workSet.WaitForAllWorkAndComplete()).InnerExceptions.ShouldBeSetEquivalentTo(observedExceptions);
                 return;
             }
 
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 9e443496105..2877d25f1bb 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -201,10 +201,13 @@ public void ConstructWithProjectInstanceFactory_FactoryReturnsNull_Throws()
             {
                 TransientTestFile entryProject = CreateProjectFile(env, 1);
 
-                Should.Throw<InvalidOperationException>(() => new ProjectGraph(
+                var aggException = Should.Throw<AggregateException>(() => new ProjectGraph(
                     entryProject.Path,
                     ProjectCollection.GlobalProjectCollection,
                     (projectPath, globalProperties, projectCollection) => null));
+                aggException.InnerExceptions.ShouldHaveSingleItem();
+
+                aggException.InnerExceptions[0].ShouldBeOfType<InvalidOperationException>();
             }
         }
 
@@ -554,7 +557,10 @@ public void ConstructWithInvalidProperties()
 </Project>");
                 CreateProjectFile(env, 3);
 
-                Should.Throw<InvalidProjectFileException>(() => new ProjectGraph(entryProject.Path));
+                var aggException = Should.Throw<AggregateException>(() => new ProjectGraph(entryProject.Path));
+                aggException.InnerExceptions.ShouldHaveSingleItem();
+
+                aggException.InnerExceptions[0].ShouldBeOfType<InvalidProjectFileException>();
             }
         }
 
@@ -2007,7 +2013,7 @@ public void AllNodesShouldHaveGraphBuildGlobalProperty(Dictionary<int, int[]> ed
         {
             using (var env = TestEnvironment.Create())
             {
-                var projectGraph = Helpers.CreateProjectGraph(env, edges, globalProperties, null, entryPoints);
+                var projectGraph = Helpers.CreateProjectGraph(env, edges, globalProperties, entryPoints: entryPoints);
 
                 var dot = projectGraph.ToDot();
 
@@ -2042,7 +2048,6 @@ public void GraphShouldSupportTransitiveReferences(Dictionary<int, int[]> edges)
             var graph = Helpers.CreateProjectGraph(
                 env: _env,
                 dependencyEdges: edges,
-                extraContentPerProjectNumber: null,
                 extraContentForAllNodes: EnableTransitiveProjectReferencesPropertyGroup
                 );
 
diff --git a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
index ed4766f5450..73732f6d3ba 100644
--- a/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
+++ b/src/Build.UnitTests/ProjectCache/ProjectCacheTests.cs
@@ -93,11 +93,11 @@ public class GraphCacheResponse
                         </ItemGroup>
                     </Target>";
 
-            private Dictionary<int, int[]> GraphEdges { get; }
+            private Dictionary<int, int[]?> GraphEdges { get; }
 
             public Dictionary<int, CacheResult> NonCacheMissResults { get; }
 
-            public GraphCacheResponse(Dictionary<int, int[]> graphEdges, Dictionary<int, CacheResult>? nonCacheMissResults = null, IDictionary<int, string>? extraContentPerProjectNumber = null)
+            public GraphCacheResponse(Dictionary<int, int[]?> graphEdges, Dictionary<int, CacheResult>? nonCacheMissResults = null, IDictionary<int, string>? extraContentPerProjectNumber = null)
             {
                 _extraContentPerProjectNumber = extraContentPerProjectNumber;
                 GraphEdges = graphEdges;
@@ -105,13 +105,11 @@ public GraphCacheResponse(Dictionary<int, int[]> graphEdges, Dictionary<int, Cac
             }
 
             public ProjectGraph CreateGraph(TestEnvironment env)
-            {
-                return Helpers.CreateProjectGraph(
+                => Helpers.CreateProjectGraph(
                     env,
                     GraphEdges,
-                    _extraContentPerProjectNumber,
-                    P2PTargets);
-            }
+                    extraContentPerProjectNumber: _extraContentPerProjectNumber,
+                    extraContentForAllNodes: P2PTargets);
 
             public static CacheResult SuccessfulProxyTargetResult()
             {
@@ -159,12 +157,11 @@ public CacheResult GetExpectedCacheResultForProjectNumber(int projectNumber)
 
             public override string ToString()
             {
-                // return base.ToString();
                 return string.Join(
                     ", ",
                     GraphEdges.Select(e => $"{Node(e.Key)}->{FormatChildren(e.Value)}"));
 
-                string FormatChildren(int[] children)
+                string FormatChildren(int[]? children)
                 {
                     return children == null
                         ? "Null"
@@ -338,15 +335,15 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
             get
             {
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
-                        {1, null!}
+                        {1, null}
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
-                        {1, null!}
+                        {1, null}
                     },
                     new Dictionary<int, CacheResult>
                     {
@@ -354,9 +351,9 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
-                        {1, null!}
+                        {1, null}
                     },
                     new Dictionary<int, CacheResult>
                     {
@@ -364,13 +361,13 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, new[] {2}}
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, new[] {2}}
                     },
@@ -380,7 +377,7 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, new[] {2}}
                     },
@@ -390,7 +387,7 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, new[] {2}}
                     },
@@ -401,7 +398,7 @@ public static IEnumerable<GraphCacheResponse> SuccessfulGraphs
                     });
 
                 yield return new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, new[] {2, 3, 7}},
                         {2, new[] {4}},
@@ -446,7 +443,7 @@ public static IEnumerable<object[]> SuccessfulGraphsWithBuildParameters
                         yield return new object[]
                         {
                             graph,
-                            ((BuildParameters) buildParameters.First()).Clone()
+                            buildParameters[0]
                         };
                     }
                 }
@@ -470,17 +467,19 @@ public void ProjectCacheByBuildParametersAndGraphBuildWorks(GraphCacheResponse t
                     graph)
             };
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
-
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             graphResult.ShouldHaveSucceeded();
 
-            buildSession.Dispose();
-
-            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+            logger.FullLog.ShouldContain("Static graph based");
 
-            AssertCacheBuild(graph, testData, mockCache, buildSession.Logger, graphResult.ResultsByNode, targets: "Build");
+            AssertCacheBuild(graph, testData, mockCache, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
         [Theory]
@@ -501,80 +500,60 @@ public void ProjectCacheByBuildParametersAndBottomUpBuildWorks(GraphCacheRespons
                 ProjectCacheDescriptor = projectCacheDescriptor
             };
 
-
-            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+            MockLogger logger;
             var nodesToBuildResults = new Dictionary<ProjectGraphNode, BuildResult>();
-
-            foreach (var node in graph.ProjectNodesTopologicallySorted)
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
             {
-                var buildResult = buildSession.BuildProjectFile(node.ProjectInstance.FullPath);
+                logger = buildSession.Logger;
 
-                buildResult.ShouldHaveSucceeded();
+                foreach (var node in graph.ProjectNodesTopologicallySorted)
+                {
+                    var buildResult = buildSession.BuildProjectFile(node.ProjectInstance.FullPath);
 
-                nodesToBuildResults[node] = buildResult;
-            }
+                    buildResult.ShouldHaveSucceeded();
 
-            buildSession.Dispose();
+                    nodesToBuildResults[node] = buildResult;
+                }
+            }
 
-            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+            logger.FullLog.ShouldContain("Static graph based");
 
-            AssertCacheBuild(graph, testData, mockCache, buildSession.Logger, nodesToBuildResults, targets: null);
+            AssertCacheBuild(graph, testData, mockCache, logger, nodesToBuildResults, targets: null);
         }
 
         [Theory]
         [MemberData(nameof(SuccessfulGraphsWithBuildParameters))]
-        public void ProjectCacheByVsWorkaroundWorks(GraphCacheResponse testData, BuildParameters buildParameters)
+        public void ProjectCacheByVsScenarioWorks(GraphCacheResponse testData, BuildParameters buildParameters)
         {
-            ProjectGraph? graph = null;
-
-            var (logger, nodesToBuildResults) = BuildGraphByVsWorkaround(
-                () =>
-                {
-                    graph = testData.CreateGraph(_env);
-                    return graph;
-                },
-                buildParameters);
+            (MockLogger logger, ProjectGraph graph, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) = BuildGraphVsScenario(testData, buildParameters);
 
-            graph.ShouldNotBeNull();
-
-            AssertCacheBuild(graph!, testData, null, logger, nodesToBuildResults, targets: null);
+            AssertCacheBuild(graph, testData, null, logger, nodesToBuildResults, targets: null);
         }
 
         [Fact]
-        public void ProjectCacheByVsWorkaroundIgnoresSlnDisabledProjects()
+        public void ProjectCacheByVsScenarioIgnoresSlnDisabledProjects()
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
-                    {1, new[] {2}}
+                    { 1, new[] { 2 } },
                 },
                 extraContentPerProjectNumber: new Dictionary<int, string>()
                 {
-                    {1, "<PropertyGroup> <BuildProjectInSolution>false</BuildProjectInSolution> </PropertyGroup>"}
+                    { 1, "<PropertyGroup> <BuildProjectInSolution>false</BuildProjectInSolution> </PropertyGroup>" },
                 });
 
-            ProjectGraph? graph = null;
-
-            var (logger, nodesToBuildResults) = BuildGraphByVsWorkaround(
-                graphProducer: () =>
-                {
-                    graph = testData.CreateGraph(_env);
-                    return graph;
-                },
-                assertBuildResults: false
-            );
+            (MockLogger logger, ProjectGraph graph, _) = BuildGraphVsScenario(testData, assertBuildResults: false);
 
-            graph.ShouldNotBeNull();
-
-            logger.FullLog.ShouldNotContain($"EntryPoint: {graph!.GraphRoots.First().ProjectInstance.FullPath}");
+            logger.FullLog.ShouldNotContain($"EntryPoint: {graph.GraphRoots.First().ProjectInstance.FullPath}");
             logger.FullLog.ShouldContain($"EntryPoint: {graph.GraphRoots.First().ProjectReferences.First().ProjectInstance.FullPath}");
         }
 
         [Fact]
-        public void ProjectCacheByVsWorkaroundShouldNotSupportSolutionOnlyDependencies()
+        public void ProjectCacheByVsScenarioShouldNotSupportSolutionOnlyDependencies()
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, Array.Empty<int>()}
                 },
@@ -583,25 +562,24 @@ public void ProjectCacheByVsWorkaroundShouldNotSupportSolutionOnlyDependencies()
                     {1, $"<PropertyGroup> <ProjectDependency>{Guid.NewGuid()}</ProjectDependency> </PropertyGroup>"}
                 });
 
-            var (logger, nodeResults) = BuildGraphByVsWorkaround(
-                graphProducer: () => testData.CreateGraph(_env),
-                assertBuildResults: false);
+            (_, _, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) = BuildGraphVsScenario(testData, assertBuildResults: false);
 
-            nodeResults.ShouldHaveSingleItem();
+            nodesToBuildResults.ShouldHaveSingleItem();
 
-            var buildResult = nodeResults.First().Value;
+            var buildResult = nodesToBuildResults.First().Value;
             buildResult.OverallResult.ShouldBe(BuildResultCode.Failure);
             buildResult.Exception.Message.ShouldContain("Project cache service does not support solution only dependencies when running under Visual Studio.");
         }
 
-        private (MockLogger logger, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) BuildGraphByVsWorkaround(
-            Func<ProjectGraph> graphProducer,
+        private (MockLogger logger, ProjectGraph projectGraph, Dictionary<ProjectGraphNode, BuildResult> nodesToBuildResults) BuildGraphVsScenario(
+            GraphCacheResponse testData,
             BuildParameters? buildParameters = null,
             bool assertBuildResults = true
         )
         {
             var nodesToBuildResults = new Dictionary<ProjectGraphNode, BuildResult>();
-            MockLogger? logger;
+            MockLogger logger;
+            ProjectGraph graph;
 
             var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
 
@@ -616,46 +594,45 @@ public void ProjectCacheByVsWorkaroundShouldNotSupportSolutionOnlyDependencies()
                         visualStudioPath: currentBuildEnvironment.VisualStudioInstallRootDirectory));
 
                 // Reset the environment variables stored in the build params to take into account TestEnvironmentChanges.
-                buildParameters = buildParameters  is null
+                buildParameters = buildParameters is null
                     ? new BuildParameters()
                     : new BuildParameters(buildParameters, resetEnvironment: true);
 
                 BuildManager.ProjectCacheItems.ShouldBeEmpty();
 
-                var graph = graphProducer.Invoke();
+                graph = testData.CreateGraph(_env);
 
                 BuildManager.ProjectCacheItems.ShouldHaveSingleItem();
 
-                var projectPaths = graph.ProjectNodes.Select(n => n.ProjectInstance.FullPath).ToArray();
-
                 // VS sets this global property on every project it builds.
                 var solutionConfigurationGlobalProperty = CreateSolutionConfigurationProperty(graph.ProjectNodes);
 
-                using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
-
-                foreach (var node in graph.ProjectNodesTopologicallySorted)
+                using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
                 {
-                    var buildResult = buildSession.BuildProjectFile(
-                        node.ProjectInstance.FullPath,
-                        globalProperties:
-                            new Dictionary<string, string>
-                            {
+                    logger = buildSession.Logger;
+
+                    foreach (var node in graph.ProjectNodesTopologicallySorted)
+                    {
+                        var buildResult = buildSession.BuildProjectFile(
+                            node.ProjectInstance.FullPath,
+                            globalProperties:
+                                new Dictionary<string, string>
+                                {
                                 { SolutionProjectGenerator.SolutionPathPropertyName, graph.GraphRoots.First().ProjectInstance.FullPath },
                                 { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty },
                                 { PropertyNames.InnerBuildProperty, "TheInnerBuildProperty"},
                                 { "TheInnerBuildProperty", "FooBar"},
-                            });
+                                });
 
-                    if (assertBuildResults)
-                    {
-                        buildResult.ShouldHaveSucceeded();
-                    }
+                        if (assertBuildResults)
+                        {
+                            buildResult.ShouldHaveSucceeded();
+                        }
 
-                    nodesToBuildResults[node] = buildResult;
+                        nodesToBuildResults[node] = buildResult;
+                    }
                 }
 
-                logger = buildSession.Logger;
-
                 if (assertBuildResults)
                 {
                     logger.FullLog.ShouldContain("Visual Studio Workaround based");
@@ -682,7 +659,7 @@ public void ProjectCacheByVsWorkaroundShouldNotSupportSolutionOnlyDependencies()
                 BuildManager.ProjectCacheItems.Clear();
             }
 
-            return (logger, nodesToBuildResults);
+            return (logger, graph, nodesToBuildResults);
         }
 
         private static string CreateSolutionConfigurationProperty(IReadOnlyCollection<ProjectGraphNode> projectNodes)
@@ -715,7 +692,7 @@ private static string CreateSolutionConfigurationProperty(IReadOnlyCollection<Pr
         }
 
         [Fact]
-        public void DesignTimeBuildsDuringVsWorkaroundShouldDisableTheCache()
+        public void DesignTimeBuildsDuringVsScenarioShouldDisableTheCache()
         {
             var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
 
@@ -725,7 +702,7 @@ public void DesignTimeBuildsDuringVsWorkaroundShouldDisableTheCache()
             var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount()).ToArray();
 
             var testData = new GraphCacheResponse(
-                graphEdges: new Dictionary<int, int[]>
+                graphEdges: new Dictionary<int, int[]?>
                 {
                     {1, referenceNumbers}
                 },
@@ -747,38 +724,40 @@ public void DesignTimeBuildsDuringVsWorkaroundShouldDisableTheCache()
                 var rootNode = graph.GraphRoots.First();
                 var globalProperties = new Dictionary<string, string> { { "SolutionPath", rootNode.ProjectInstance.FullPath } };
 
-                using var buildSession = new Helpers.BuildManagerSession(_env);
-
-                // Build references in parallel.
-                var referenceBuildTasks = rootNode.ProjectReferences.Select(
-                    r => buildSession.BuildProjectFileAsync(
-                        r.ProjectInstance.FullPath,
-                        globalProperties: globalProperties));
-
-                foreach (var task in referenceBuildTasks)
+                MockLogger logger;
+                using (var buildSession = new Helpers.BuildManagerSession(_env))
                 {
-                    var buildResult = task.Result;
-                    buildResult.ShouldHaveSucceeded();
-                }
+                    logger = buildSession.Logger;
 
-                buildSession
-                    .BuildProjectFile(rootNode.ProjectInstance.FullPath, globalProperties: globalProperties)
-                    .ShouldHaveSucceeded();
+                    // Build references in parallel.
+                    var referenceBuildTasks = rootNode.ProjectReferences.Select(
+                        r => buildSession.BuildProjectFileAsync(
+                            r.ProjectInstance.FullPath,
+                            globalProperties: globalProperties));
 
-                buildSession.Dispose();
+                    foreach (var task in referenceBuildTasks)
+                    {
+                        var buildResult = task.Result;
+                        buildResult.ShouldHaveSucceeded();
+                    }
+
+                    buildSession
+                        .BuildProjectFile(rootNode.ProjectInstance.FullPath, globalProperties: globalProperties)
+                        .ShouldHaveSucceeded();
+                }
 
-                buildSession.Logger.FullLog.ShouldContain("Visual Studio Workaround based");
+                logger.FullLog.ShouldContain("Visual Studio Workaround based");
 
                 // Design time builds should not initialize the plugin.
-                buildSession.Logger.FullLog.ShouldNotContain("Running project cache with Visual Studio workaround");
+                logger.FullLog.ShouldNotContain("Running project cache with Visual Studio workaround");
 
                 // Cache doesn't get initialized and queried.
-                buildSession.Logger.FullLog.ShouldNotContain("BeginBuildAsync");
-                buildSession.Logger.FullLog.ShouldNotContain("GetCacheResultAsync for");
-                buildSession.Logger.FullLog.ShouldNotContain("Querying project cache for project");
+                logger.FullLog.ShouldNotContain("BeginBuildAsync");
+                logger.FullLog.ShouldNotContain("GetCacheResultAsync for");
+                logger.FullLog.ShouldNotContain("Querying project cache for project");
 
                 // Cache does get disposed.
-                StringShouldContainSubstring(buildSession.Logger.FullLog, "EndBuildAsync", 1);
+                StringShouldContainSubstring(logger.FullLog, "EndBuildAsync", 1);
             }
             finally
             {
@@ -793,7 +772,7 @@ public void DesignTimeBuildsDuringVsWorkaroundShouldDisableTheCache()
         public void RunningProxyBuildsOnOutOfProcNodesShouldIssueWarning(bool disableInprocNodeViaEnvironmentVariable)
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, new[] {2}}
                 },
@@ -824,17 +803,19 @@ public void RunningProxyBuildsOnOutOfProcNodesShouldIssueWarning(bool disableInp
                 buildParameters.DisableInProcNode = true;
             }
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
-
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             graphResult.ShouldHaveSucceeded();
 
-            buildSession.Dispose();
+            logger.FullLog.ShouldContain("Static graph based");
 
-            buildSession.Logger.FullLog.ShouldContain("Static graph based");
-
-            buildSession.Logger.AssertMessageCount("MSB4274", 1);
+            logger.AssertMessageCount("MSB4274", 1);
         }
 
         private void AssertCacheBuild(
@@ -847,25 +828,25 @@ private void AssertCacheBuild(
         {
             if (instanceMockCache != null)
             {
-                mockLogger.FullLog.ShouldContain("MockCache: BeginBuildAsync");
                 mockLogger.FullLog.ShouldContain("Instance based");
                 mockLogger.FullLog.ShouldNotContain("Assembly path based");
 
+                instanceMockCache.BeginBuildCalled.ShouldBeTrue();
                 instanceMockCache.Requests.Count.ShouldBe(graph.ProjectNodes.Count);
+                instanceMockCache.EndBuildCalled.ShouldBeTrue();
             }
             else
             {
-                mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: BeginBuildAsync");
                 mockLogger.FullLog.ShouldContain("Assembly path based");
                 mockLogger.FullLog.ShouldNotContain("Instance based");
 
+                mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: BeginBuildAsync");
                 Regex.Matches(mockLogger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for").Count.ShouldBe(graph.ProjectNodes.Count);
+                mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: EndBuildAsync");
             }
 
             foreach (var node in graph.ProjectNodes)
             {
-                var expectedCacheResponse = testData.GetExpectedCacheResultForNode(node);
-
                 if (string.IsNullOrEmpty(targets))
                 {
                     mockLogger.FullLog.ShouldContain(string.Format(ResourceUtilities.GetResourceString("ProjectCacheQueryStartedWithDefaultTargets"), node.ProjectInstance.FullPath));
@@ -878,46 +859,35 @@ private void AssertCacheBuild(
                 if (instanceMockCache != null)
                 {
                     instanceMockCache.Requests.ShouldContain(r => r.ProjectFullPath.Equals(node.ProjectInstance.FullPath));
-                    instanceMockCache.BeginBuildCalled.ShouldBeTrue();
-                    instanceMockCache.EndBuildCalled.ShouldBeTrue();
+
+                    var expectedCacheResponse = testData.GetExpectedCacheResultForNode(node);
+                    switch (expectedCacheResponse.ResultType)
+                    {
+                        case CacheResultType.CacheHit:
+                            AssertBuildResultForCacheHit(node.ProjectInstance.FullPath, projectPathToBuildResults[node], expectedCacheResponse);
+                            break;
+                        case CacheResultType.CacheMiss:
+                            break;
+                        case CacheResultType.CacheNotApplicable:
+                            break;
+                        case CacheResultType.None:
+                            break;
+                        default:
+                            throw new ArgumentOutOfRangeException();
+                    }
                 }
                 else
                 {
                     mockLogger.FullLog.ShouldContain($"{AssemblyMockCache}: GetCacheResultAsync for {node.ProjectInstance.FullPath}");
-                }
 
-                if (instanceMockCache == null)
-                {
                     // Too complicated, not worth it to send expected results to the assembly plugin, so skip checking the build results.
-                    continue;
-                }
-
-                switch (expectedCacheResponse.ResultType)
-                {
-                    case CacheResultType.CacheHit:
-                        AssertBuildResultForCacheHit(node.ProjectInstance.FullPath, projectPathToBuildResults[node], expectedCacheResponse);
-                        break;
-                    case CacheResultType.CacheMiss:
-                        break;
-                    case CacheResultType.CacheNotApplicable:
-                        break;
-                    case CacheResultType.None:
-                        break;
-                    default:
-                        throw new ArgumentOutOfRangeException();
                 }
             }
         }
 
-        private static int GetProjectNumber(ProjectGraphNode node)
-        {
-            return GetProjectNumber(node.ProjectInstance.FullPath);
-        }
+        private static int GetProjectNumber(ProjectGraphNode node) => GetProjectNumber(node.ProjectInstance.FullPath);
 
-        private static int GetProjectNumber(string projectPath)
-        {
-            return int.Parse(Path.GetFileNameWithoutExtension(projectPath));
-        }
+        private static int GetProjectNumber(string projectPath) => int.Parse(Path.GetFileNameWithoutExtension(projectPath));
 
         private void AssertBuildResultForCacheHit(
             string projectPath,
@@ -976,13 +946,17 @@ public void CacheShouldNotGetQueriedForNestedBuildRequests(BuildParameters build
                 new[] {new ProjectGraphEntryPoint(project1.Path)},
                 null);
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+            MockLogger logger;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
 
-            var buildResult = buildSession.BuildProjectFile(project1.Path);
+                BuildResult buildResult = buildSession.BuildProjectFile(project1.Path);
 
-            buildResult.ShouldHaveSucceeded();
+                buildResult.ShouldHaveSucceeded();
+            }
 
-            buildSession.Logger.ProjectStartedEvents.Count.ShouldBe(2);
+            logger.ProjectStartedEvents.Count.ShouldBe(2);
 
             mockCache.Requests.Count.ShouldBe(1);
             mockCache.Requests.First().ProjectFullPath.ShouldEndWith("1.proj");
@@ -992,7 +966,7 @@ public void CacheShouldNotGetQueriedForNestedBuildRequests(BuildParameters build
         public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, new[] {2, 3}}
                 }
@@ -1000,30 +974,34 @@ public void CacheViaBuildParametersCanDiscoverAndLoadPluginFromAssembly()
 
             var graph = testData.CreateGraph(_env);
 
-            using var buildSession = new Helpers.BuildManagerSession(
-                _env,
-                new BuildParameters
-                {
-                    ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
-                        SamplePluginAssemblyPath.Value,
-                        graph.EntryPointNodes.Select(n => new ProjectGraphEntryPoint(n.ProjectInstance.FullPath)).ToArray(),
-                        null)
-                });
+            var buildParameters = new BuildParameters
+            {
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromAssemblyPath(
+                    SamplePluginAssemblyPath.Value,
+                    graph.EntryPointNodes.Select(n => new ProjectGraphEntryPoint(n.ProjectInstance.FullPath)).ToArray(),
+                    null)
+            };
 
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             graphResult.ShouldHaveSucceeded();
 
-            buildSession.Logger.FullLog.ShouldContain("Explicit entry-point based");
+            logger.FullLog.ShouldContain("Explicit entry-point based");
 
-            AssertCacheBuild(graph, testData, null, buildSession.Logger, graphResult.ResultsByNode, targets: "Build");
+            AssertCacheBuild(graph, testData, null, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
         [Fact]
         public void GraphBuildCanDiscoverAndLoadPluginFromAssembly()
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, new[] {2, 3}}
                 }
@@ -1031,22 +1009,26 @@ public void GraphBuildCanDiscoverAndLoadPluginFromAssembly()
 
             var graph = testData.CreateGraph(_env);
 
-            using var buildSession = new Helpers.BuildManagerSession(_env);
-
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             graphResult.ShouldHaveSucceeded();
 
-            buildSession.Logger.FullLog.ShouldContain("Static graph based");
+            logger.FullLog.ShouldContain("Static graph based");
 
-            AssertCacheBuild(graph, testData, null, buildSession.Logger, graphResult.ResultsByNode, targets: "Build");
+            AssertCacheBuild(graph, testData, null, logger, graphResult.ResultsByNode, targets: "Build");
         }
 
         [Fact]
         public void BuildFailsWhenCacheBuildResultIsWrong()
         {
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, new[] {2}}
                 },
@@ -1077,24 +1059,27 @@ public void BuildFailsWhenCacheBuildResultIsWrong()
             var graph = testData.CreateGraph(_env);
             var mockCache = new InstanceMockCache(testData);
 
-            using var buildSession = new Helpers.BuildManagerSession(
-                _env,
-                new BuildParameters
-                {
-                    ProjectCacheDescriptor =
-                        ProjectCacheDescriptor.FromInstance(mockCache, null, graph)
-                });
+            var buildParameters = new BuildParameters
+            {
+                ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(mockCache, null, graph)
+            };
 
-            var buildResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             mockCache.Requests.Count.ShouldBe(2);
 
-            buildResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 2).Value.ShouldHaveSucceeded();
-            buildResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 1).Value.ShouldHaveFailed();
+            graphResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 2).Value.ShouldHaveSucceeded();
+            graphResult.ResultsByNode.First(r => GetProjectNumber(r.Key) == 1).Value.ShouldHaveFailed();
 
-            buildResult.ShouldHaveFailed();
+            graphResult.ShouldHaveFailed();
 
-            buildSession.Logger.FullLog.ShouldContain("Reference file [Invalid file] does not exist");
+            logger.FullLog.ShouldContain("Reference file [Invalid file] does not exist");
         }
 
         [Fact]
@@ -1102,20 +1087,23 @@ public void GraphBuildErrorsIfMultiplePluginsAreFound()
         {
             var graph = Helpers.CreateProjectGraph(
                 _env,
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
-                    {1, new[] {2}}
+                    { 1, new[] { 2 } },
                 },
-                extraContentPerProjectNumber: null,
                 extraContentForAllNodes: @$"
 <ItemGroup>
    <{ItemTypeNames.ProjectCachePlugin} Include='Plugin$(MSBuildProjectName)' />
 </ItemGroup>
 ");
 
-            using var buildSession = new Helpers.BuildManagerSession(_env);
-
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
             
             graphResult.ShouldHaveFailed("A single project cache plugin must be specified but multiple where found:");
         }
@@ -1125,9 +1113,9 @@ public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
         {
             var graph = Helpers.CreateProjectGraph(
                 _env,
-                dependencyEdges: new Dictionary<int, int[]>
+                dependencyEdges: new Dictionary<int, int[]?>
                 {
-                    {1, new[] {2}}
+                    { 1, new[] { 2 } },
                 },
                 extraContentPerProjectNumber: new Dictionary<int, string>
                 {
@@ -1141,9 +1129,13 @@ public void GraphBuildErrorsIfNotAllNodeDefineAPlugin()
                     }
                 });
 
-            using var buildSession = new Helpers.BuildManagerSession(_env);
-
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
             
             graphResult.ShouldHaveFailed("When any static graph node defines a project cache, all nodes must define the same project cache.");
         }
@@ -1174,7 +1166,7 @@ public static IEnumerable<object[]> CacheExceptionLocationsTestData
         [MemberData(nameof(CacheExceptionLocationsTestData))]
         public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorLocations errorLocations, ErrorKind errorKind)
         {
-            SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
+            SetEnvironmentForErrorLocations(errorLocations, errorKind);
 
             var project = _env.CreateFile("1.proj", @$"
                     <Project>
@@ -1293,15 +1285,14 @@ public void EngineShouldHandleExceptionsFromCachePluginViaBuildParameters(ErrorL
         [MemberData(nameof(CacheExceptionLocationsTestData))]
         public void EngineShouldHandleExceptionsFromCachePluginViaGraphBuild(ErrorLocations errorLocations, ErrorKind errorKind)
         {
-            SetEnvironmentForErrorLocations(errorLocations, errorKind.ToString());
+            SetEnvironmentForErrorLocations(errorLocations, errorKind);
 
             var graph = Helpers.CreateProjectGraph(
                 _env,
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, new []{2}}
                 },
-                extraContentPerProjectNumber: null,
                 extraContentForAllNodes: @$"
 <ItemGroup>
     <{ItemTypeNames.ProjectCachePlugin} Include=`{SamplePluginAssemblyPath.Value}` />
@@ -1392,29 +1383,24 @@ public void EndBuildShouldGetCalledOnceWhenItThrowsExceptionsFromGraphBuilds()
                         </Target>
                     </Project>".Cleanup());
 
-            SetEnvironmentForErrorLocations(ErrorLocations.EndBuildAsync, ErrorKind.Exception.ToString());
-
-            using var buildSession = new Helpers.BuildManagerSession(
-                _env,
-                new BuildParameters
-                {
-                    UseSynchronousLogging = true
-                });
+            SetEnvironmentForErrorLocations(ErrorLocations.EndBuildAsync, ErrorKind.Exception);
 
-            var logger = buildSession.Logger;
-
-            GraphBuildResult buildResult = null!;
-            Should.NotThrow(
-                () =>
-                {
-                    buildResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
-                });
+            var buildParameters = new BuildParameters
+            {
+                UseSynchronousLogging = true
+            };
 
-            buildResult.ShouldHaveFailed();
-            buildResult.Exception.InnerException!.ShouldNotBeNull();
-            buildResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(new ProjectGraph(project.Path));
+            }
 
-            buildSession.Dispose();
+            graphResult.ShouldHaveFailed();
+            graphResult.Exception.InnerException!.ShouldNotBeNull();
+            graphResult.Exception.InnerException!.Message.ShouldContain("Cache plugin exception from EndBuildAsync");
 
             StringShouldContainSubstring(logger.FullLog, $"{nameof(AssemblyMockCache)}: EndBuildAsync", expectedOccurrences: 1);
         }
@@ -1427,7 +1413,7 @@ public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousL
             var referenceNumbers = new []{2, 3, 4};
 
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, referenceNumbers}
                 },
@@ -1460,7 +1446,7 @@ public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousL
                     }
                 });
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, new BuildParameters()
+            var buildParameters = new BuildParameters()
             {
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
                 ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
@@ -1469,7 +1455,9 @@ public void CacheShouldBeQueriedInParallelDuringGraphBuilds(bool useSynchronousL
                     graph),
                 UseSynchronousLogging = useSynchronousLogging,
                 DisableInProcNode = disableInprocNode
-            });
+            };
+
+            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
 
             var task2 = BuildProjectFileAsync(2);
             var task3 = BuildProjectFileAsync(3);
@@ -1501,9 +1489,8 @@ Task<BuildResult> BuildProjectFileAsync(int projectNumber)
 
         [Theory]
         [InlineData(false, false)]
-        // TODO: Reenable when this gets into the main branch.
-        // [InlineData(true, true)]
-        public void ParallelStressTestForVsWorkaround(bool useSynchronousLogging, bool disableInprocNode)
+        [InlineData(true, true)]
+        public void ParallelStressTestForVsScenario(bool useSynchronousLogging, bool disableInprocNode)
         {
             var currentBuildEnvironment = BuildEnvironmentHelper.Instance;
 
@@ -1522,7 +1509,7 @@ public void ParallelStressTestForVsWorkaround(bool useSynchronousLogging, bool d
                 var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount() * 2).ToArray();
 
                 var testData = new GraphCacheResponse(
-                    new Dictionary<int, int[]>
+                    new Dictionary<int, int[]?>
                     {
                         {1, referenceNumbers}
                     },
@@ -1537,43 +1524,48 @@ public void ParallelStressTestForVsWorkaround(bool useSynchronousLogging, bool d
                 var solutionConfigurationGlobalProperty =
                     CreateSolutionConfigurationProperty(graph.ProjectNodes);
 
-                using var buildSession = new Helpers.BuildManagerSession(_env, new BuildParameters
+                var buildParameters = new BuildParameters
                 {
                     MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
                     UseSynchronousLogging = useSynchronousLogging,
                     DisableInProcNode = disableInprocNode
-                });
+                };
 
+                MockLogger logger;
                 var buildResultTasks = new List<Task<BuildResult>>();
-
-                foreach (var node in graph.ProjectNodes.Where(n => referenceNumbers.Contains(GetProjectNumber(n))))
+                using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
                 {
-                    var buildResultTask = buildSession.BuildProjectFileAsync(
-                        node.ProjectInstance.FullPath,
-                        globalProperties:
-                        new Dictionary<string, string>
-                        {
+                    logger = buildSession.Logger;
+
+                    foreach (var node in graph.ProjectNodes.Where(n => referenceNumbers.Contains(GetProjectNumber(n))))
+                    {
+                        var buildResultTask = buildSession.BuildProjectFileAsync(
+                            node.ProjectInstance.FullPath,
+                            globalProperties:
+                            new Dictionary<string, string>
+                            {
                             { SolutionProjectGenerator.SolutionPathPropertyName, graph.GraphRoots.First().ProjectInstance.FullPath },
                             { SolutionProjectGenerator.CurrentSolutionConfigurationContents, solutionConfigurationGlobalProperty }
-                        });
+                            });
 
-                    buildResultTasks.Add(buildResultTask);
-                }
+                        buildResultTasks.Add(buildResultTask);
+                    }
 
-                foreach (var buildResultTask in buildResultTasks)
-                {
-                    buildResultTask.Result.ShouldHaveSucceeded();
-                }
+                    foreach (var buildResultTask in buildResultTasks)
+                    {
+                        buildResultTask.Result.ShouldHaveSucceeded();
+                    }
 
-                buildSession.BuildProjectFile(
-                        graph.GraphRoots.First().ProjectInstance.FullPath,
-                        globalProperties:
-                        new Dictionary<string, string> {{"SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath}})
-                    .ShouldHaveSucceeded();
+                    buildSession.BuildProjectFile(
+                            graph.GraphRoots.First().ProjectInstance.FullPath,
+                            globalProperties:
+                            new Dictionary<string, string> { { "SolutionPath", graph.GraphRoots.First().ProjectInstance.FullPath } })
+                        .ShouldHaveSucceeded();
+                }
 
-                StringShouldContainSubstring(buildSession.Logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", graph.ProjectNodes.Count);
+                StringShouldContainSubstring(logger.FullLog, $"{AssemblyMockCache}: GetCacheResultAsync for", graph.ProjectNodes.Count);
 
-                buildSession.Logger.FullLog.ShouldContain("Visual Studio Workaround based");
+                logger.FullLog.ShouldContain("Visual Studio Workaround based");
             }
             finally
             {
@@ -1590,7 +1582,7 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
             var referenceNumbers = Enumerable.Range(2, NativeMethodsShared.GetLogicalCoreCount() * 2).ToArray();
 
             var testData = new GraphCacheResponse(
-                new Dictionary<int, int[]>
+                new Dictionary<int, int[]?>
                 {
                     {1, referenceNumbers}
                 },
@@ -1600,7 +1592,7 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
             var graph = testData.CreateGraph(_env);
             var cache = new InstanceMockCache(testData, TimeSpan.FromMilliseconds(50));
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, new BuildParameters()
+            var buildParameters = new BuildParameters()
             {
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount(),
                 ProjectCacheDescriptor = ProjectCacheDescriptor.FromInstance(
@@ -1609,9 +1601,15 @@ public void ParallelStressTest(bool useSynchronousLogging, bool disableInprocNod
                     graph),
                 UseSynchronousLogging = useSynchronousLogging,
                 DisableInProcNode = disableInprocNode
-            });
+            };
 
-            var graphResult = buildSession.BuildGraph(graph);
+            MockLogger logger;
+            GraphBuildResult graphResult;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
+                graphResult = buildSession.BuildGraph(graph);
+            }
 
             graphResult.ShouldHaveSucceeded();
             cache.QueryStartStops.Count.ShouldBe(graph.ProjectNodes.Count * 2);
@@ -1684,25 +1682,29 @@ public void ProxyCacheHitsOnPreviousCacheMissesShouldWork()
                 MaxNodeCount = NativeMethodsShared.GetLogicalCoreCount()
             };
 
-            using var buildSession = new Helpers.BuildManagerSession(_env, buildParameters);
+            MockLogger logger;
+            using (var buildSession = new Helpers.BuildManagerSession(_env, buildParameters))
+            {
+                logger = buildSession.Logger;
 
-            var buildRequests = new List<(string, string)>();
-            buildRequests.AddRange(projectPaths.Select(r => (r, cacheNotApplicableTarget)));
-            buildRequests.AddRange(projectPaths.Select(r => (r, cacheHitTarget)));
+                var buildRequests = new List<(string, string)>();
+                buildRequests.AddRange(projectPaths.Select(r => (r, cacheNotApplicableTarget)));
+                buildRequests.AddRange(projectPaths.Select(r => (r, cacheHitTarget)));
 
-            var buildTasks = new List<Task<BuildResult>>();
-            foreach (var (projectPath, target) in buildRequests)
-            {
-                buildTasks.Add(buildSession.BuildProjectFileAsync(projectPath, new[] {target}));
-            }
+                var buildTasks = new List<Task<BuildResult>>();
+                foreach (var (projectPath, target) in buildRequests)
+                {
+                    buildTasks.Add(buildSession.BuildProjectFileAsync(projectPath, new[] { target }));
+                }
 
-            foreach (var buildResult in buildTasks.Select(buildTask => buildTask.Result))
-            {
-                buildResult.Exception.ShouldBeNull();
-                buildResult.ShouldHaveSucceeded();
+                foreach (var buildResult in buildTasks.Select(buildTask => buildTask.Result))
+                {
+                    buildResult.Exception.ShouldBeNull();
+                    buildResult.ShouldHaveSucceeded();
+                }
             }
 
-            buildSession.Logger.ProjectStartedEvents.Count.ShouldBe(2 * projectPaths.Length);
+            logger.ProjectStartedEvents.Count.ShouldBe(2 * projectPaths.Length);
 
             cacheHitCount.ShouldBe(projectPaths.Length);
             nonCacheHitCount.ShouldBe(projectPaths.Length);
@@ -1714,7 +1716,7 @@ private static void StringShouldContainSubstring(string aString, string substrin
             Regex.Matches(aString, substring).Count.ShouldBe(expectedOccurrences);
         }
 
-        private void SetEnvironmentForErrorLocations(ErrorLocations errorLocations, string errorKind)
+        private void SetEnvironmentForErrorLocations(ErrorLocations errorLocations, ErrorKind errorKind)
         {
             foreach (var enumValue in Enum.GetValues(typeof(ErrorLocations)))
             {
@@ -1722,7 +1724,7 @@ private void SetEnvironmentForErrorLocations(ErrorLocations errorLocations, stri
                 if (errorLocations.HasFlag(typedValue))
                 {
                     var exceptionLocation = typedValue.ToString();
-                    _env.SetEnvironmentVariable(exceptionLocation, errorKind);
+                    _env.SetEnvironmentVariable(exceptionLocation, errorKind.ToString());
                     _output.WriteLine($"Set exception location: {exceptionLocation}");
                 }
             }
diff --git a/src/Build.UnitTests/Utilities_Tests.cs b/src/Build.UnitTests/Utilities_Tests.cs
index 6159f3af2c1..c6f7af84e57 100644
--- a/src/Build.UnitTests/Utilities_Tests.cs
+++ b/src/Build.UnitTests/Utilities_Tests.cs
@@ -22,7 +22,6 @@
 using System.Collections.Generic;
 using System.IO;
 using Xunit.Abstractions;
-using Shouldly;
 
 #nullable disable
 
@@ -81,41 +80,55 @@ public UtilitiesTestReadOnlyLoad()
         [Fact]
         public void CommentsInPreprocessing()
         {
-            using TestEnvironment env = TestEnvironment.Create();
-            XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();
+            Microsoft.Build.Construction.XmlDocumentWithLocation.ClearReadOnlyFlags_UnitTestsOnly();
 
-            TransientTestFile inputFile = env.CreateFile("tempInput.tmp", ObjectModelHelpers.CleanupFileContents(@"
-<Project DefaultTargets='Build'>
-<Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets'/>
-</Project>"));
-            TransientTestFile outputFile = env.CreateFile("tempOutput.tmp");
+            string input = FileUtilities.GetTemporaryFile();
+            string output = FileUtilities.GetTemporaryFile();
 
-            env.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
+            string _initialLoadFilesWriteable = Environment.GetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE");
+            try
+            {
+                Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", "1");
+
+                string content = ObjectModelHelpers.CleanupFileContents(@"
+<Project DefaultTargets='Build' ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'>
+  <Import Project='$(MSBuildToolsPath)\Microsoft.CSharp.targets'/>
+</Project>");
+                File.WriteAllText(input, content);
 
 #if FEATURE_GET_COMMANDLINE
-            MSBuildApp.Execute(@"c:\bin\msbuild.exe """ + inputFile.Path +
-                (NativeMethodsShared.IsUnixLike ? @""" -pp:""" : @""" /pp:""") + outputFile.Path + @"""")
-                .ShouldBe(MSBuildApp.ExitType.Success);
+                Assert.Equal(MSBuildApp.ExitType.Success, MSBuildApp.Execute(@"c:\bin\msbuild.exe """ + input +
+                    (NativeMethodsShared.IsUnixLike ? @""" -pp:""" : @""" /pp:""") + output + @""""));
 #else
-            Assert.Equal(
-                MSBuildApp.ExitType.Success,
-                MSBuildApp.Execute(
-                    new[] { @"c:\bin\msbuild.exe", '"' + inputFile.Path + '"',
-                '"' + (NativeMethodsShared.IsUnixLike ? "-pp:" : "/pp:") + outputFile.Path + '"'}));
+                Assert.Equal(
+                    MSBuildApp.ExitType.Success,
+                    MSBuildApp.Execute(
+                        new[] { @"c:\bin\msbuild.exe", '"' + input + '"',
+                    '"' + (NativeMethodsShared.IsUnixLike ? "-pp:" : "/pp:") + output + '"'}));
 #endif
 
-            bool foundDoNotModify = false;
-            foreach (string line in File.ReadLines(outputFile.Path))
-            {
-                line.ShouldNotContain("<!---->", "This is what it will look like if we're loading read/only");
-
-                if (line.Contains("DO NOT MODIFY")) // this is in a comment in our targets
+                bool foundDoNotModify = false;
+                foreach (string line in File.ReadLines(output))
                 {
-                    foundDoNotModify = true;
+                    if (line.Contains("<!---->")) // This is what it will look like if we're loading read/only
+                    {
+                        Assert.True(false);
+                    }
+
+                    if (line.Contains("DO NOT MODIFY")) // this is in a comment in our targets
+                    {
+                        foundDoNotModify = true;
+                    }
                 }
-            }
 
-            foundDoNotModify.ShouldBeTrue();
+                Assert.True(foundDoNotModify);
+            }
+            finally
+            {
+                File.Delete(input);
+                File.Delete(output);
+                Environment.SetEnvironmentVariable("MSBUILDLOADALLFILESASWRITEABLE", _initialLoadFilesWriteable);
+            }
         }
 
         [Fact]
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index c4a9d2c9523..606d1008930 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -6,6 +6,7 @@
 using System.Collections.Generic;
 using System.Collections.Immutable;
 using System.Collections.ObjectModel;
+using System.ComponentModel;
 using System.Diagnostics;
 using System.Diagnostics.CodeAnalysis;
 using System.Globalization;
@@ -25,17 +26,16 @@
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
 using Microsoft.Build.Graph;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.Debugging;
+using Microsoft.NET.StringTools;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 
-using Microsoft.NET.StringTools;
-using System.ComponentModel;
-
 #nullable disable
 
 namespace Microsoft.Build.Execution
@@ -456,7 +456,7 @@ public void BeginBuild(BuildParameters parameters)
                         _nodeManager?.ShutdownAllNodes();
                         _taskHostNodeManager?.ShutdownAllNodes();
                     }
-               }
+                }
             }
 
             _previousLowPriority = parameters.LowPriority;
@@ -470,6 +470,14 @@ public void BeginBuild(BuildParameters parameters)
 
                 MSBuildEventSource.Log.BuildStart();
 
+                // Initiate build telemetry data
+                DateTime now = DateTime.UtcNow;
+                KnownTelemetry.BuildTelemetry ??= new()
+                {
+                    StartAt = now,
+                };
+                KnownTelemetry.BuildTelemetry.InnerStartAt = now;
+
                 if (BuildParameters.DumpOpportunisticInternStats)
                 {
                     Strings.EnableDiagnostics();
@@ -796,6 +804,13 @@ public BuildSubmission PendBuildRequest(BuildRequestData requestData)
                 VerifyStateInternal(BuildManagerState.Building);
 
                 var newSubmission = new BuildSubmission(this, GetNextSubmissionId(), requestData, _buildParameters.LegacyThreadingSemantics);
+
+                if (KnownTelemetry.BuildTelemetry != null)
+                {
+                    KnownTelemetry.BuildTelemetry.Project ??= requestData.ProjectFullPath;
+                    KnownTelemetry.BuildTelemetry.Target ??= string.Join(",", requestData.TargetNames);
+                }
+
                 _buildSubmissions.Add(newSubmission.SubmissionId, newSubmission);
                 _noActiveSubmissionsEvent.Reset();
                 return newSubmission;
@@ -817,6 +832,15 @@ public GraphBuildSubmission PendBuildRequest(GraphBuildRequestData requestData)
                 VerifyStateInternal(BuildManagerState.Building);
 
                 var newSubmission = new GraphBuildSubmission(this, GetNextSubmissionId(), requestData);
+
+                if (KnownTelemetry.BuildTelemetry != null)
+                {
+                    // Project graph can have multiple entry points, for purposes of identifying event for same build project,
+                    // we believe that including only one entry point will provide enough precision.
+                    KnownTelemetry.BuildTelemetry.Project ??= requestData.ProjectGraphEntryPoints?.FirstOrDefault().ProjectFile;
+                    KnownTelemetry.BuildTelemetry.Target ??= string.Join(",", requestData.TargetNames);
+                }
+
                 _graphBuildSubmissions.Add(newSubmission.SubmissionId, newSubmission);
                 _noActiveSubmissionsEvent.Reset();
                 return newSubmission;
@@ -965,6 +989,35 @@ public void EndBuild()
                         }
 
                         loggingService.LogBuildFinished(_overallBuildSuccess);
+
+                        if (KnownTelemetry.BuildTelemetry != null)
+                        {
+                            KnownTelemetry.BuildTelemetry.FinishedAt = DateTime.UtcNow;
+                            KnownTelemetry.BuildTelemetry.Success = _overallBuildSuccess;
+                            KnownTelemetry.BuildTelemetry.Version = ProjectCollection.Version;
+                            KnownTelemetry.BuildTelemetry.DisplayVersion = ProjectCollection.DisplayVersion;
+                            KnownTelemetry.BuildTelemetry.FrameworkName = NativeMethodsShared.FrameworkName;
+
+                            string host = null;
+                            if (BuildEnvironmentState.s_runningInVisualStudio)
+                            {
+                                host = "VS";
+                            }
+                            else if (!string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILD_HOST_NAME")))
+                            {
+                                host = Environment.GetEnvironmentVariable("MSBUILD_HOST_NAME");
+                            }
+                            else if (!string.IsNullOrEmpty(Environment.GetEnvironmentVariable("VSCODE_CWD")) || Environment.GetEnvironmentVariable("TERM_PROGRAM") == "vscode")
+                            {
+                                host = "VSCode";
+                            }
+                            KnownTelemetry.BuildTelemetry.Host = host;
+
+                            KnownTelemetry.BuildTelemetry.UpdateEventProperties();
+                            loggingService.LogTelemetry(buildEventContext: null, KnownTelemetry.BuildTelemetry.EventName, KnownTelemetry.BuildTelemetry.Properties);
+                            // Clean telemetry to make it ready for next build submission.
+                            KnownTelemetry.BuildTelemetry = null;
+                        }
                     }
 
                     ShutdownLoggingService(loggingService);
@@ -1670,19 +1723,35 @@ private void WaitForAllLoggingServiceEventsToBeProcessed()
         /// </summary>
         private void HandleSubmissionException(GraphBuildSubmission submission, Exception ex)
         {
-            if (ex is InvalidProjectFileException projectException)
+            if (ex is AggregateException ae)
             {
-                if (!projectException.HasBeenLogged)
+                // If there's exactly 1, just flatten it
+                if (ae.InnerExceptions.Count == 1)
                 {
-                    BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-                    ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(buildEventContext, projectException);
-                    projectException.HasBeenLogged = true;
+                    ex = ae.InnerExceptions[0];
                 }
+                else
+                {
+                    // Log each InvalidProjectFileException encountered during ProjectGraph creation
+                    foreach (Exception innerException in ae.InnerExceptions)
+                    {
+                        if (innerException is InvalidProjectFileException innerProjectException)
+                        {
+                            LogInvalidProjectFileError(innerProjectException);
+                        }
+                    }
+                }
+            }
+
+            if (ex is InvalidProjectFileException projectException)
+            {
+                LogInvalidProjectFileError(projectException);
             }
 
-            ex = ex is AggregateException ae && ae.InnerExceptions.Count == 1
-                ? ae.InnerExceptions.First()
-                : ex;
+            if (ex is CircularDependencyException)
+            {
+                LogInvalidProjectFileError(new InvalidProjectFileException(ex.Message, ex));
+            }
 
             lock (_syncLock)
             {
@@ -1694,6 +1763,16 @@ private void HandleSubmissionException(GraphBuildSubmission submission, Exceptio
                 _overallBuildSuccess = false;
                 CheckSubmissionCompletenessAndRemove(submission);
             }
+
+            void LogInvalidProjectFileError(InvalidProjectFileException projectException)
+            {
+                if (!projectException.HasBeenLogged)
+                {
+                    BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
+                    ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(buildEventContext, projectException);
+                    projectException.HasBeenLogged = true;
+                }
+            }
         }
 
         private static void AddBuildRequestToSubmission(BuildSubmission submission, int configurationId, int projectContextId = BuildEventContext.InvalidProjectContextId)
@@ -1823,131 +1902,84 @@ private bool IsInvalidProjectOrIORelatedException(Exception e)
 
         private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
         {
-            try
+            if (_shuttingDown)
             {
-                if (_shuttingDown)
-                {
-                    throw new BuildAbortedException();
-                }
+                throw new BuildAbortedException();
+            }
 
-                var projectGraph = submission.BuildRequestData.ProjectGraph;
-                if (projectGraph == null)
-                {
-                    projectGraph = new ProjectGraph(
-                        submission.BuildRequestData.ProjectGraphEntryPoints,
-                        ProjectCollection.GlobalProjectCollection,
-                        (path, properties, collection) =>
+            var projectGraph = submission.BuildRequestData.ProjectGraph;
+            if (projectGraph == null)
+            {
+                projectGraph = new ProjectGraph(
+                    submission.BuildRequestData.ProjectGraphEntryPoints,
+                    ProjectCollection.GlobalProjectCollection,
+                    (path, properties, collection) =>
+                    {
+                        ProjectLoadSettings projectLoadSettings = _buildParameters.ProjectLoadSettings;
+                        if (submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports))
                         {
-                            ProjectLoadSettings projectLoadSettings = _buildParameters.ProjectLoadSettings;
-                            if (submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports))
-                            {
-                                projectLoadSettings |= ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.IgnoreInvalidImports | ProjectLoadSettings.IgnoreEmptyImports;
-                            }
+                            projectLoadSettings |= ProjectLoadSettings.IgnoreMissingImports | ProjectLoadSettings.IgnoreInvalidImports | ProjectLoadSettings.IgnoreEmptyImports;
+                        }
 
-                            if (submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags.FailOnUnresolvedSdk))
-                            {
-                                projectLoadSettings |= ProjectLoadSettings.FailOnUnresolvedSdk;
-                            }
+                        if (submission.BuildRequestData.Flags.HasFlag(BuildRequestDataFlags.FailOnUnresolvedSdk))
+                        {
+                            projectLoadSettings |= ProjectLoadSettings.FailOnUnresolvedSdk;
+                        }
 
-                            return new ProjectInstance(
-                                path,
-                                properties,
-                                null,
-                                _buildParameters,
-                                ((IBuildComponentHost)this).LoggingService,
-                                new BuildEventContext(
-                                    submission.SubmissionId,
-                                    _buildParameters.NodeId,
-                                    BuildEventContext.InvalidEvaluationId,
-                                    BuildEventContext.InvalidProjectInstanceId,
-                                    BuildEventContext.InvalidProjectContextId,
-                                    BuildEventContext.InvalidTargetId,
-                                    BuildEventContext.InvalidTaskId),
-                                SdkResolverService,
+                        return new ProjectInstance(
+                            path,
+                            properties,
+                            null,
+                            _buildParameters,
+                            ((IBuildComponentHost)this).LoggingService,
+                            new BuildEventContext(
                                 submission.SubmissionId,
-                                projectLoadSettings);
-                        });
-                }
+                                _buildParameters.NodeId,
+                                BuildEventContext.InvalidEvaluationId,
+                                BuildEventContext.InvalidProjectInstanceId,
+                                BuildEventContext.InvalidProjectContextId,
+                                BuildEventContext.InvalidTargetId,
+                                BuildEventContext.InvalidTaskId),
+                            SdkResolverService,
+                            submission.SubmissionId,
+                            projectLoadSettings);
+                    });
+            }
 
-                LogMessage(
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
-                        "StaticGraphConstructionMetrics",
-                        Math.Round(projectGraph.ConstructionMetrics.ConstructionTime.TotalSeconds, 3),
-                        projectGraph.ConstructionMetrics.NodeCount,
-                        projectGraph.ConstructionMetrics.EdgeCount));
+            LogMessage(
+                ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword(
+                    "StaticGraphConstructionMetrics",
+                    Math.Round(projectGraph.ConstructionMetrics.ConstructionTime.TotalSeconds, 3),
+                    projectGraph.ConstructionMetrics.NodeCount,
+                    projectGraph.ConstructionMetrics.EdgeCount));
 
-                Dictionary<ProjectGraphNode, BuildResult> resultsPerNode = null;
+            Dictionary<ProjectGraphNode, BuildResult> resultsPerNode = null;
 
-                if (submission.BuildRequestData.GraphBuildOptions.Build)
-                {
-                    var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
-                    var targetListTask = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
+            if (submission.BuildRequestData.GraphBuildOptions.Build)
+            {
+                var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
+                var targetListTask = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
 
-                    DumpGraph(projectGraph, targetListTask);
+                DumpGraph(projectGraph, targetListTask);
 
-                    using DisposablePluginService cacheService = cacheServiceTask.Result;
+                using DisposablePluginService cacheService = cacheServiceTask.Result;
 
-                    resultsPerNode = BuildGraph(projectGraph, targetListTask, submission.BuildRequestData);
-                }
-                else
-                {
-                    DumpGraph(projectGraph);
-                }
-
-                ErrorUtilities.VerifyThrow(
-                    submission.BuildResult?.Exception == null,
-                    "Exceptions only get set when the graph submission gets completed with an exception in OnThreadException. That should not happen during graph builds.");
-
-                // The overall submission is complete, so report it as complete
-                ReportResultsToSubmission(
-                    new GraphBuildResult(
-                        submission.SubmissionId,
-                        new ReadOnlyDictionary<ProjectGraphNode, BuildResult>(resultsPerNode ?? new Dictionary<ProjectGraphNode, BuildResult>())));
+                resultsPerNode = BuildGraph(projectGraph, targetListTask, submission.BuildRequestData);
             }
-            catch (Exception ex) when (IsInvalidProjectOrIORelatedException(ex))
+            else
             {
-                GraphBuildResult result = null;
-
-                // ProjectGraph throws an aggregate exception with InvalidProjectFileException inside when evaluation fails
-                if (ex is AggregateException aggregateException && aggregateException.InnerExceptions.All(innerException => innerException is InvalidProjectFileException))
-                {
-                    // Log each InvalidProjectFileException encountered during ProjectGraph creation
-                    foreach (Exception innerException in aggregateException.InnerExceptions)
-                    {
-                        var projectException = (InvalidProjectFileException) innerException;
-                        if (!projectException.HasBeenLogged)
-                        {
-                            BuildEventContext projectBuildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-                            ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(projectBuildEventContext, projectException);
-                            projectException.HasBeenLogged = true;
-                        }
-                    }
-                }
-                else if (ex is CircularDependencyException)
-                {
-                    result = new GraphBuildResult(submission.SubmissionId, true);
-
-                    BuildEventContext projectBuildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-                    ((IBuildComponentHost)this).LoggingService.LogInvalidProjectFileError(projectBuildEventContext, new InvalidProjectFileException(ex.Message, ex));
-                }
-                else
-                {
-                    // Arbitrarily just choose the first entry point project's path
-                    string projectFile = submission.BuildRequestData.ProjectGraph?.EntryPointNodes.First().ProjectInstance.FullPath
-                        ?? submission.BuildRequestData.ProjectGraphEntryPoints?.First().ProjectFile;
-                    BuildEventContext buildEventContext = new BuildEventContext(submission.SubmissionId, 1, BuildEventContext.InvalidProjectInstanceId, BuildEventContext.InvalidProjectContextId, BuildEventContext.InvalidTargetId, BuildEventContext.InvalidTaskId);
-                    ((IBuildComponentHost)this).LoggingService.LogFatalBuildError(buildEventContext, ex, new BuildEventFileInfo(projectFile));
-                }
-
-                result ??= new GraphBuildResult(submission.SubmissionId, ex);
+                DumpGraph(projectGraph);
+            }
 
-                ReportResultsToSubmission(result);
+            ErrorUtilities.VerifyThrow(
+                submission.BuildResult?.Exception == null,
+                "Exceptions only get set when the graph submission gets completed with an exception in OnThreadException. That should not happen during graph builds.");
 
-                lock (_syncLock)
-                {
-                    _overallBuildSuccess = false;
-                }
-            }
+            // The overall submission is complete, so report it as complete
+            ReportResultsToSubmission(
+                new GraphBuildResult(
+                    submission.SubmissionId,
+                    new ReadOnlyDictionary<ProjectGraphNode, BuildResult>(resultsPerNode ?? new Dictionary<ProjectGraphNode, BuildResult>())));
 
             static void DumpGraph(ProjectGraph graph, IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetList = null)
             {
@@ -1975,7 +2007,7 @@ GraphBuildRequestData graphBuildRequestData
             var finishedNodes = new HashSet<ProjectGraphNode>(projectGraph.ProjectNodes.Count);
             var buildingNodes = new Dictionary<BuildSubmission, ProjectGraphNode>();
             var resultsPerNode = new Dictionary<ProjectGraphNode, BuildResult>(projectGraph.ProjectNodes.Count);
-            Exception submissionException = null;
+            ExceptionDispatchInfo submissionException = null;
 
             while (blockedNodes.Count > 0 || buildingNodes.Count > 0)
             {
@@ -1985,7 +2017,7 @@ GraphBuildRequestData graphBuildRequestData
                 // Observe them here to keep the same exception flow with the case when there's no plugins and ExecuteSubmission(BuildSubmission) does not run on a separate thread.
                 if (submissionException != null)
                 {
-                    throw submissionException;
+                    submissionException.Throw();
                 }
 
                 lock (graphBuildStateLock)
@@ -2026,7 +2058,8 @@ GraphBuildRequestData graphBuildRequestData
                             {
                                 if (submissionException == null && finishedBuildSubmission.BuildResult.Exception != null)
                                 {
-                                    submissionException = finishedBuildSubmission.BuildResult.Exception;
+                                    // Preserve the original stack.
+                                    submissionException = ExceptionDispatchInfo.Capture(finishedBuildSubmission.BuildResult.Exception);
                                 }
 
                                 ProjectGraphNode finishedNode = buildingNodes[finishedBuildSubmission];
diff --git a/src/Build/BackEnd/Client/MSBuildClient.cs b/src/Build/BackEnd/Client/MSBuildClient.cs
new file mode 100644
index 00000000000..4e88c67398a
--- /dev/null
+++ b/src/Build/BackEnd/Client/MSBuildClient.cs
@@ -0,0 +1,561 @@
+// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Globalization;
+using System.IO;
+using System.IO.Pipes;
+using System.Threading;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.BackEnd.Client;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Eventing;
+using Microsoft.Build.Execution;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Framework.Telemetry;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.Experimental
+{
+    /// <summary>
+    /// This class is the public entry point for executing builds in msbuild server.
+    /// It processes command-line arguments and invokes the build engine.
+    /// </summary>
+    public sealed class MSBuildClient
+    {
+        /// <summary>
+        /// The build inherits all the environment variables from the client process.
+        /// This property allows to add extra environment variables or reset some of the existing ones.
+        /// </summary>
+        private readonly Dictionary<string, string> _serverEnvironmentVariables;
+
+        /// <summary>
+        /// Full path to current MSBuild.exe if executable is MSBuild.exe,
+        /// or to version of MSBuild.dll found to be associated with the current process.
+        /// </summary>
+        private readonly string _msbuildLocation;
+
+        /// <summary>
+        /// The command line to process.
+        /// The first argument on the command line is assumed to be the name/path of the executable, and is ignored.
+        /// </summary>
+#if FEATURE_GET_COMMANDLINE
+        private readonly string _commandLine;
+#else
+        private readonly string[] _commandLine;
+#endif
+
+        /// <summary>
+        /// The MSBuild client execution result.
+        /// </summary>
+        private readonly MSBuildClientExitResult _exitResult;
+
+        /// <summary>
+        /// Whether MSBuild server finished the build.
+        /// </summary>
+        private bool _buildFinished = false;
+
+        /// <summary>
+        /// Handshake between server and client.
+        /// </summary>
+        private readonly ServerNodeHandshake _handshake;
+
+        /// <summary>
+        /// The named pipe name for client-server communication.
+        /// </summary>
+        private readonly string _pipeName;
+
+        /// <summary>
+        /// The named pipe stream for client-server communication.
+        /// </summary>
+        private readonly NamedPipeClientStream _nodeStream;
+
+        /// <summary>
+        /// A way to cache a byte array when writing out packets
+        /// </summary>
+        private readonly MemoryStream _packetMemoryStream;
+
+        /// <summary>
+        /// A binary writer to help write into <see cref="_packetMemoryStream"/>
+        /// </summary>
+        private readonly BinaryWriter _binaryWriter;
+
+        /// <summary>
+        /// Used to estimate the size of the build with an ETW trace.
+        /// </summary>
+        private int _numConsoleWritePackets;
+        private long _sizeOfConsoleWritePackets;
+
+        /// <summary>
+        /// Capture configuration of Client Console.
+        /// </summary>
+        private TargetConsoleConfiguration? _consoleConfiguration;
+
+        /// <summary>
+        /// Public constructor with parameters.
+        /// </summary>
+        /// <param name="commandLine">The command line to process. The first argument
+        /// on the command line is assumed to be the name/path of the executable, and is ignored</param>
+        /// <param name="msbuildLocation"> Full path to current MSBuild.exe if executable is MSBuild.exe,
+        /// or to version of MSBuild.dll found to be associated with the current process.</param>
+        public MSBuildClient(
+#if FEATURE_GET_COMMANDLINE
+            string commandLine,
+#else
+            string[] commandLine,
+#endif
+            string msbuildLocation)
+        {
+            _serverEnvironmentVariables = new();
+            _exitResult = new();
+
+            // dll & exe locations
+            _commandLine = commandLine;
+            _msbuildLocation = msbuildLocation;
+
+            // Client <-> Server communication stream
+            _handshake = GetHandshake();
+            _pipeName = OutOfProcServerNode.GetPipeName(_handshake);
+            _nodeStream = new NamedPipeClientStream(".", _pipeName, PipeDirection.InOut, PipeOptions.Asynchronous
+#if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+                                                                         | PipeOptions.CurrentUserOnly
+#endif
+            );
+
+            _packetMemoryStream = new MemoryStream();
+            _binaryWriter = new BinaryWriter(_packetMemoryStream);
+        }
+
+        /// <summary>
+        /// Orchestrates the execution of the build on the server,
+        /// responsible for client-server communication.
+        /// </summary>
+        /// <param name="cancellationToken">Cancellation token.</param>
+        /// <returns>A value of type <see cref="MSBuildClientExitResult"/> that indicates whether the build succeeded,
+        /// or the manner in which it failed.</returns>
+        public MSBuildClientExitResult Execute(CancellationToken cancellationToken)
+        {
+            // Command line in one string used only in human readable content.
+            string descriptiveCommandLine =
+#if FEATURE_GET_COMMANDLINE
+                _commandLine;
+#else
+                string.Join(" ", _commandLine);
+#endif
+
+            CommunicationsUtilities.Trace("Executing build with command line '{0}'", descriptiveCommandLine);
+            string serverRunningMutexName = OutOfProcServerNode.GetRunningServerMutexName(_handshake);
+            string serverBusyMutexName = OutOfProcServerNode.GetBusyServerMutexName(_handshake);
+
+            // Start server it if is not running.
+            bool serverIsAlreadyRunning = ServerNamedMutex.WasOpen(serverRunningMutexName);
+            if (KnownTelemetry.BuildTelemetry != null)
+            {
+                KnownTelemetry.BuildTelemetry.InitialServerState = serverIsAlreadyRunning ? "hot" : "cold";
+            }
+            if (!serverIsAlreadyRunning)
+            {
+                CommunicationsUtilities.Trace("Server was not running. Starting server now.");
+                if (!TryLaunchServer())
+                {
+                    _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;
+                    return _exitResult;
+                }
+            }
+
+            // Check that server is not busy.
+            var serverWasBusy = ServerNamedMutex.WasOpen(serverBusyMutexName);
+            if (serverWasBusy)
+            {
+                CommunicationsUtilities.Trace("Server is busy, falling back to former behavior.");
+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;
+                return _exitResult;
+            }
+
+            // Connect to server.
+            if (!TryConnectToServer(serverIsAlreadyRunning ? 1_000 : 20_000))
+            {
+                return _exitResult;
+            }
+
+            ConfigureAndQueryConsoleProperties();
+
+            // Send build command.
+            // Let's send it outside the packet pump so that we easier and quicker deal with possible issues with connection to server.
+            MSBuildEventSource.Log.MSBuildServerBuildStart(descriptiveCommandLine);
+            if (!TrySendBuildCommand())
+            {
+                return _exitResult;
+            }
+
+            _numConsoleWritePackets = 0;
+            _sizeOfConsoleWritePackets = 0;
+
+            try
+            {
+                // Start packet pump
+                using MSBuildClientPacketPump packetPump = new(_nodeStream);
+
+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeConsoleWrite, ServerNodeConsoleWrite.FactoryForDeserialization, packetPump);
+                packetPump.RegisterPacketHandler(NodePacketType.ServerNodeBuildResult, ServerNodeBuildResult.FactoryForDeserialization, packetPump);
+                packetPump.Start();
+
+                WaitHandle[] waitHandles =
+                {
+                    cancellationToken.WaitHandle,
+                    packetPump.PacketPumpErrorEvent,
+                    packetPump.PacketReceivedEvent
+                };
+
+                while (!_buildFinished)
+                {
+                    int index = WaitHandle.WaitAny(waitHandles);
+                    switch (index)
+                    {
+                        case 0:
+                            HandleCancellation();
+                            // After the cancelation, we want to wait to server gracefuly finish the build.
+                            // We have to replace the cancelation handle, because WaitAny would cause to repeatedly hit this branch of code.
+                            waitHandles[0] = CancellationToken.None.WaitHandle;
+                            break;
+
+                        case 1:
+                            HandlePacketPumpError(packetPump);
+                            break;
+
+                        case 2:
+                            while (packetPump.ReceivedPacketsQueue.TryDequeue(out INodePacket? packet) &&
+                                   !_buildFinished)
+                            {
+                                if (packet != null)
+                                {
+                                    HandlePacket(packet);
+                                }
+                            }
+
+                            break;
+                    }
+                }
+            }
+            catch (Exception ex)
+            {
+                CommunicationsUtilities.Trace("MSBuild client error: problem during packet handling occurred: {0}.", ex);
+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;
+            }
+
+            MSBuildEventSource.Log.MSBuildServerBuildStop(descriptiveCommandLine, _numConsoleWritePackets, _sizeOfConsoleWritePackets, _exitResult.MSBuildClientExitType.ToString(), _exitResult.MSBuildAppExitTypeString);
+            CommunicationsUtilities.Trace("Build finished.");
+            return _exitResult;
+        }
+
+        private void ConfigureAndQueryConsoleProperties()
+        {
+            var (acceptAnsiColorCodes, outputIsScreen) = QueryIsScreenAndTryEnableAnsiColorCodes();
+            int bufferWidth = QueryConsoleBufferWidth();
+            ConsoleColor backgroundColor = QueryConsoleBackgroundColor();
+
+            _consoleConfiguration = new TargetConsoleConfiguration(bufferWidth, acceptAnsiColorCodes, outputIsScreen, backgroundColor);
+        }
+
+        private (bool acceptAnsiColorCodes, bool outputIsScreen) QueryIsScreenAndTryEnableAnsiColorCodes()
+        {
+            bool acceptAnsiColorCodes = false;
+            bool outputIsScreen = false;
+
+            if (NativeMethodsShared.IsWindows)
+            {
+                try
+                {
+                    IntPtr stdOut = NativeMethodsShared.GetStdHandle(NativeMethodsShared.STD_OUTPUT_HANDLE);
+                    if (NativeMethodsShared.GetConsoleMode(stdOut, out uint consoleMode))
+                    {
+                        bool success;
+                        if ((consoleMode & NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING) == NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING &&
+                            (consoleMode & NativeMethodsShared.DISABLE_NEWLINE_AUTO_RETURN) == NativeMethodsShared.DISABLE_NEWLINE_AUTO_RETURN)
+                        {
+                            // Console is already in required state
+                            success = true;
+                        }
+                        else
+                        {
+                            consoleMode |= NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING | NativeMethodsShared.DISABLE_NEWLINE_AUTO_RETURN;
+                            success = NativeMethodsShared.SetConsoleMode(stdOut, consoleMode);
+                        }
+
+                        if (success)
+                        {
+                            acceptAnsiColorCodes = true;
+                        }
+
+                        uint fileType = NativeMethodsShared.GetFileType(stdOut);
+                        // The std out is a char type(LPT or Console)
+                        outputIsScreen = fileType == NativeMethodsShared.FILE_TYPE_CHAR;
+                        acceptAnsiColorCodes &= outputIsScreen;
+                    }
+                }
+                catch (Exception ex)
+                {
+                    CommunicationsUtilities.Trace("MSBuild client warning: problem during enabling support for VT100: {0}.", ex);
+                }
+            }
+            else
+            {
+                // On posix OSes we expect console always supports VT100 coloring unless it is redirected
+                acceptAnsiColorCodes = outputIsScreen = !Console.IsOutputRedirected;
+            }
+
+            return (acceptAnsiColorCodes: acceptAnsiColorCodes, outputIsScreen: outputIsScreen);
+        }
+
+        private int QueryConsoleBufferWidth()
+        {
+            int consoleBufferWidth = -1;
+            try
+            {
+                consoleBufferWidth = Console.BufferWidth;
+            }
+            catch (Exception ex)
+            {
+                // on Win8 machines while in IDE Console.BufferWidth will throw (while it talks to native console it gets "operation aborted" native error)
+                // this is probably temporary workaround till we understand what is the reason for that exception
+                CommunicationsUtilities.Trace("MSBuild client warning: problem during querying console buffer width.", ex);
+            }
+
+            return consoleBufferWidth;
+        }
+
+        /// <summary>
+        /// Some platforms do not allow getting current background color. There
+        /// is not way to check, but not-supported exception is thrown. Assume
+        /// black, but don't crash.
+        /// </summary>
+        private ConsoleColor QueryConsoleBackgroundColor()
+        {
+            ConsoleColor consoleBackgroundColor;
+            try
+            {
+                consoleBackgroundColor = Console.BackgroundColor;
+            }
+            catch (PlatformNotSupportedException)
+            {
+                consoleBackgroundColor = ConsoleColor.Black;
+            }
+
+            return consoleBackgroundColor;
+        }
+
+        private bool TrySendPacket(Func<INodePacket> packetResolver)
+        {
+            INodePacket? packet = null;
+            try
+            {
+                packet = packetResolver();
+                WritePacket(_nodeStream, packet);
+                CommunicationsUtilities.Trace("Command packet of type '{0}' sent...", packet.Type);
+            }
+            catch (Exception ex)
+            {
+                CommunicationsUtilities.Trace("Failed to send command packet of type '{0}' to server: {1}", packet?.Type.ToString() ?? "Unknown", ex);
+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.Unexpected;
+                return false;
+            }
+
+            return true;
+        }
+
+        /// <summary>
+        /// Launches MSBuild server. 
+        /// </summary>
+        /// <returns> Whether MSBuild server was started successfully.</returns>
+        private bool TryLaunchServer()
+        {
+            string serverLaunchMutexName = $@"Global\msbuild-server-launch-{_handshake.ComputeHash()}";
+            using var serverLaunchMutex = ServerNamedMutex.OpenOrCreateMutex(serverLaunchMutexName, out bool mutexCreatedNew);
+            if (!mutexCreatedNew)
+            {
+                // Some other client process launching a server and setting a build request for it. Fallback to usual msbuild app build.
+                CommunicationsUtilities.Trace("Another process launching the msbuild server, falling back to former behavior.");
+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.ServerBusy;
+                return false;
+            }
+
+            string[] msBuildServerOptions = new string[] {
+                "/nologo",
+                "/nodemode:8"
+            };
+
+            try
+            {
+                NodeLauncher nodeLauncher = new NodeLauncher();
+                CommunicationsUtilities.Trace("Starting Server...");
+                Process msbuildProcess = nodeLauncher.Start(_msbuildLocation, string.Join(" ", msBuildServerOptions));
+                CommunicationsUtilities.Trace("Server started with PID: {0}", msbuildProcess?.Id);
+            }
+            catch (Exception ex)
+            {
+                CommunicationsUtilities.Trace("Failed to launch the msbuild server: {0}", ex);
+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.LaunchError;
+                return false;
+            }
+
+            return true;
+        }
+
+        private bool TrySendBuildCommand() => TrySendPacket(() => GetServerNodeBuildCommand());
+
+        private bool TrySendCancelCommand() => TrySendPacket(() => new ServerNodeBuildCancel());
+
+        private ServerNodeBuildCommand GetServerNodeBuildCommand()
+        {
+            Dictionary<string, string> envVars = new();
+
+            foreach (DictionaryEntry envVar in Environment.GetEnvironmentVariables())
+            {
+                envVars[(string)envVar.Key] = (envVar.Value as string) ?? string.Empty;
+            }
+
+            foreach (var pair in _serverEnvironmentVariables)
+            {
+                envVars[pair.Key] = pair.Value;
+            }
+
+            // We remove env variable used to invoke MSBuild server as that might be equal to 1, so we do not get an infinite recursion here. 
+            envVars.Remove(Traits.UseMSBuildServerEnvVarName);
+
+            Debug.Assert(KnownTelemetry.BuildTelemetry == null || KnownTelemetry.BuildTelemetry.StartAt.HasValue, "BuildTelemetry.StartAt was not initialized!");
+
+            PartialBuildTelemetry? partialBuildTelemetry = KnownTelemetry.BuildTelemetry == null
+                ? null
+                : new PartialBuildTelemetry(
+                    startedAt: KnownTelemetry.BuildTelemetry.StartAt.GetValueOrDefault(),
+                    initialServerState: KnownTelemetry.BuildTelemetry.InitialServerState,
+                    serverFallbackReason: KnownTelemetry.BuildTelemetry.ServerFallbackReason);
+
+            return new ServerNodeBuildCommand(
+                        _commandLine,
+                        startupDirectory: Directory.GetCurrentDirectory(),
+                        buildProcessEnvironment: envVars,
+                        CultureInfo.CurrentCulture,
+                        CultureInfo.CurrentUICulture,
+                        _consoleConfiguration!,
+                        partialBuildTelemetry);
+        }
+
+        private ServerNodeHandshake GetHandshake()
+        {
+            return new ServerNodeHandshake(CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));
+        }
+
+        /// <summary>
+        /// Handle cancellation.
+        /// </summary>
+        private void HandleCancellation()
+        {
+            TrySendCancelCommand();
+
+            CommunicationsUtilities.Trace("MSBuild client sent cancelation command.");
+        }
+
+        /// <summary>
+        /// Handle packet pump error.
+        /// </summary>
+        private void HandlePacketPumpError(MSBuildClientPacketPump packetPump)
+        {
+            CommunicationsUtilities.Trace("MSBuild client error: packet pump unexpectedly shut down: {0}", packetPump.PacketPumpException);
+            throw packetPump.PacketPumpException ?? new InternalErrorException("Packet pump unexpectedly shut down");
+        }
+
+        /// <summary>
+        /// Dispatches the packet to the correct handler.
+        /// </summary>
+        private void HandlePacket(INodePacket packet)
+        {
+            switch (packet.Type)
+            {
+                case NodePacketType.ServerNodeConsoleWrite:
+                    ServerNodeConsoleWrite writePacket = (packet as ServerNodeConsoleWrite)!;
+                    HandleServerNodeConsoleWrite(writePacket);
+                    _numConsoleWritePackets++;
+                    _sizeOfConsoleWritePackets += writePacket.Text.Length;
+                    break;
+                case NodePacketType.ServerNodeBuildResult:
+                    HandleServerNodeBuildResult((ServerNodeBuildResult)packet);
+                    break;
+                default:
+                    throw new InvalidOperationException($"Unexpected packet type {packet.GetType().Name}");
+            }
+        }
+
+        private void HandleServerNodeConsoleWrite(ServerNodeConsoleWrite consoleWrite)
+        {
+            switch (consoleWrite.OutputType)
+            {
+                case ConsoleOutput.Standard:
+                    Console.Write(consoleWrite.Text);
+                    break;
+                case ConsoleOutput.Error:
+                    Console.Error.Write(consoleWrite.Text);
+                    break;
+                default:
+                    throw new InvalidOperationException($"Unexpected console output type {consoleWrite.OutputType}");
+            }
+        }
+
+        private void HandleServerNodeBuildResult(ServerNodeBuildResult response)
+        {
+            CommunicationsUtilities.Trace("Build response received: exit code '{0}', exit type '{1}'", response.ExitCode, response.ExitType);
+            _exitResult.MSBuildClientExitType = MSBuildClientExitType.Success;
+            _exitResult.MSBuildAppExitTypeString = response.ExitType;
+            _buildFinished = true;
+        }
+
+        /// <summary>
+        /// Connects to MSBuild server.
+        /// </summary>
+        /// <returns> Whether the client connected to MSBuild server successfully.</returns>
+        private bool TryConnectToServer(int timeout)
+        {
+            try
+            {
+                NodeProviderOutOfProcBase.ConnectToPipeStream(_nodeStream, _pipeName, _handshake, timeout);
+            }
+            catch (Exception ex)
+            {
+                CommunicationsUtilities.Trace("Failed to connect to server: {0}", ex);
+                _exitResult.MSBuildClientExitType = MSBuildClientExitType.UnableToConnect;
+                return false;
+            }
+
+            return true;
+        }
+
+        private void WritePacket(Stream nodeStream, INodePacket packet)
+        {
+            MemoryStream memoryStream = _packetMemoryStream;
+            memoryStream.SetLength(0);
+
+            ITranslator writeTranslator = BinaryTranslator.GetWriteTranslator(memoryStream);
+
+            // Write header
+            memoryStream.WriteByte((byte)packet.Type);
+
+            // Pad for packet length
+            _binaryWriter.Write(0);
+
+            // Reset the position in the write buffer.
+            packet.Translate(writeTranslator);
+
+            int packetStreamLength = (int)memoryStream.Position;
+
+            // Now write in the actual packet length
+            memoryStream.Position = 1;
+            _binaryWriter.Write(packetStreamLength - 5);
+
+            nodeStream.Write(memoryStream.GetBuffer(), 0, packetStreamLength);
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Client/MSBuildClientExitResult.cs b/src/Build/BackEnd/Client/MSBuildClientExitResult.cs
new file mode 100644
index 00000000000..8cb466741fa
--- /dev/null
+++ b/src/Build/BackEnd/Client/MSBuildClientExitResult.cs
@@ -0,0 +1,24 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.Experimental
+{
+    /// <summary>
+    /// Enumeration of the various ways in which the MSBuildClient execution can exit.
+    /// </summary>
+    public sealed class MSBuildClientExitResult
+    {
+        /// <summary>
+        /// The MSBuild client exit type.
+        /// Covers different ways MSBuild client execution can finish.
+        /// Build errors are not included. The client could finish successfully and the build at the same time could result in a build error.
+        /// </summary>
+        public MSBuildClientExitType MSBuildClientExitType { get; set; }
+
+        /// <summary>
+        /// The build exit type. Possible values: MSBuildApp.ExitType serialized into a string.
+        /// This field is null if MSBuild client execution was not successful.
+        /// </summary>
+        public string? MSBuildAppExitTypeString { get; set; }
+    }
+}
diff --git a/src/Build/BackEnd/Client/MSBuildClientExitType.cs b/src/Build/BackEnd/Client/MSBuildClientExitType.cs
new file mode 100644
index 00000000000..e9916bd5414
--- /dev/null
+++ b/src/Build/BackEnd/Client/MSBuildClientExitType.cs
@@ -0,0 +1,29 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+namespace Microsoft.Build.Experimental
+{
+    public enum MSBuildClientExitType
+    {
+        /// <summary>
+        /// The MSBuild client successfully processed the build request.
+        /// </summary>
+        Success,
+        /// <summary>
+        /// Server is busy. This would invoke a fallback behavior.
+        /// </summary>
+        ServerBusy,
+        /// <summary>
+        /// Client was unable to connect to the server. This would invoke a fallback behavior.
+        /// </summary>
+        UnableToConnect,
+        /// <summary>
+        /// Client was unable to launch the server. This would invoke a fallback behavior.
+        /// </summary>
+        LaunchError,
+        /// <summary>
+        /// The build stopped unexpectedly, for example,
+        /// because a named pipe between the server and the client was unexpectedly closed.
+        /// </summary>
+        Unexpected
+    }
+}
diff --git a/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
new file mode 100644
index 00000000000..682fa1dfb94
--- /dev/null
+++ b/src/Build/BackEnd/Client/MSBuildClientPacketPump.cs
@@ -0,0 +1,304 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Buffers.Binary;
+using System.Collections.Concurrent;
+using System.IO;
+using System.Threading;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+#if !FEATURE_APM
+using System.Threading.Tasks;
+#endif
+
+namespace Microsoft.Build.BackEnd.Client
+{
+    internal sealed class MSBuildClientPacketPump : INodePacketHandler, INodePacketFactory, IDisposable
+    {
+        /// <summary>
+        /// The queue of packets we have received but which have not yet been processed.
+        /// </summary>
+        public ConcurrentQueue<INodePacket> ReceivedPacketsQueue { get; }
+
+        /// <summary>
+        /// Set when packet pump receive packets and put them to <see cref="ReceivedPacketsQueue"/>.
+        /// </summary>
+        public AutoResetEvent PacketReceivedEvent { get; }
+
+        /// <summary>
+        /// Set when the packet pump unexpectedly terminates (due to connection problems or because of deserialization issues).
+        /// </summary>
+        public ManualResetEvent PacketPumpErrorEvent { get; }
+
+        /// <summary>
+        /// Exception appeared when the packet pump unexpectedly terminates.
+        /// </summary>
+        public Exception? PacketPumpException { get; set; }
+
+        /// <summary>
+        /// Set when packet pump should shutdown.
+        /// </summary>
+        private readonly ManualResetEvent _packetPumpShutdownEvent;
+
+        /// <summary>
+        /// The packet factory.
+        /// </summary>
+        private readonly NodePacketFactory _packetFactory;
+
+        /// <summary>
+        /// The memory stream for a read buffer.
+        /// </summary>
+        private readonly MemoryStream _readBufferMemoryStream;
+
+        /// <summary>
+        /// The thread which runs the asynchronous packet pump
+        /// </summary>
+        private Thread? _packetPumpThread;
+
+        /// <summary>
+        /// The stream from where to read packets.
+        /// </summary>
+        private readonly Stream _stream;
+
+        /// <summary>
+        /// The binary translator for reading packets.
+        /// </summary>
+        readonly ITranslator _binaryReadTranslator;
+
+        public MSBuildClientPacketPump(Stream stream)
+        {
+            ErrorUtilities.VerifyThrowArgumentNull(stream, nameof(stream));
+
+            _stream = stream;
+            _packetFactory = new NodePacketFactory();
+
+            ReceivedPacketsQueue = new ConcurrentQueue<INodePacket>();
+            PacketReceivedEvent = new AutoResetEvent(false);
+            PacketPumpErrorEvent = new ManualResetEvent(false);
+            _packetPumpShutdownEvent = new ManualResetEvent(false);
+
+            _readBufferMemoryStream = new MemoryStream();
+            _binaryReadTranslator = BinaryTranslator.GetReadTranslator(_readBufferMemoryStream, InterningBinaryReader.CreateSharedBuffer());
+        }
+
+        #region INodePacketFactory Members
+
+        /// <summary>
+        /// Registers a packet handler.
+        /// </summary>
+        /// <param name="packetType">The packet type for which the handler should be registered.</param>
+        /// <param name="factory">The factory used to create packets.</param>
+        /// <param name="handler">The handler for the packets.</param>
+        public void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)
+        {
+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);
+        }
+
+        /// <summary>
+        /// Unregisters a packet handler.
+        /// </summary>
+        /// <param name="packetType">The type of packet for which the handler should be unregistered.</param>
+        public void UnregisterPacketHandler(NodePacketType packetType)
+        {
+            _packetFactory.UnregisterPacketHandler(packetType);
+        }
+
+        /// <summary>
+        /// Deserializes and routes a packer to the appropriate handler.
+        /// </summary>
+        /// <param name="nodeId">The node from which the packet was received.</param>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator to use as a source for packet data.</param>
+        public void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        {
+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+        }
+
+        /// <summary>
+        /// Routes a packet to the appropriate handler.
+        /// </summary>
+        /// <param name="nodeId">The node id from which the packet was received.</param>
+        /// <param name="packet">The packet to route.</param>
+        public void RoutePacket(int nodeId, INodePacket packet)
+        {
+            _packetFactory.RoutePacket(nodeId, packet);
+        }
+
+        #endregion
+
+        #region INodePacketHandler Members
+
+        /// <summary>
+        /// Called when a packet has been received.
+        /// </summary>
+        /// <param name="node">The node from which the packet was received.</param>
+        /// <param name="packet">The packet.</param>
+        public void PacketReceived(int node, INodePacket packet)
+        {
+            ReceivedPacketsQueue.Enqueue(packet);
+            PacketReceivedEvent.Set();
+        }
+
+        #endregion
+
+        #region Packet Pump
+        /// <summary>
+        /// Initializes the packet pump thread.
+        /// </summary>
+        public void Start()
+        {
+            _packetPumpThread = new Thread(PacketPumpProc)
+            {
+                IsBackground = true,
+                Name = "MSBuild Client Packet Pump"
+            };
+            _packetPumpThread.Start();
+        }
+
+        /// <summary>
+        /// Stops the packet pump thread.
+        /// </summary>
+        public void Stop()
+        {
+            _packetPumpShutdownEvent.Set();
+            _packetPumpThread?.Join();
+        }
+
+        /// <summary>
+        /// This method handles the packet pump reading. It will terminate when the terminate event is
+        /// set.
+        /// </summary>
+        /// <remarks>
+        /// Instead of throwing an exception, puts it in <see cref="PacketPumpException"/> and raises event <see cref="PacketPumpErrorEvent"/>.
+        /// </remarks>
+        private void PacketPumpProc()
+        {
+            RunReadLoop(_stream, _packetPumpShutdownEvent);
+        }
+
+        private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent)
+        {
+            CommunicationsUtilities.Trace("Entering read loop.");
+
+            try
+            {
+                byte[] headerByte = new byte[5];
+#if FEATURE_APM
+                IAsyncResult result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);
+#else
+                Task<int> readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);
+#endif
+
+                bool continueReading = true;
+                do
+                {
+                    // Ordering of the wait handles is important. The first signalled wait handle in the array 
+                    // will be returned by WaitAny if multiple wait handles are signalled. We prefer to have the
+                    // terminate event triggered so that we cannot get into a situation where packets are being
+                    // spammed to the client and it never gets an opportunity to shutdown.
+                    WaitHandle[] handles = new WaitHandle[] {
+                    localPacketPumpShutdownEvent,
+#if FEATURE_APM
+                    result.AsyncWaitHandle
+#else
+                    ((IAsyncResult)readTask).AsyncWaitHandle
+#endif
+                    };
+                    int waitId = WaitHandle.WaitAny(handles);
+                    switch (waitId)
+                    {
+                        case 0:
+                            // Fulfill the request for shutdown of the message pump.
+                            CommunicationsUtilities.Trace("Shutdown message pump thread.");
+                            continueReading = false;
+                            break;
+
+                        case 1:
+                            {
+                                // Client recieved a packet header. Read the rest of it.
+                                int headerBytesRead = 0;
+#if FEATURE_APM
+                                headerBytesRead = localStream.EndRead(result);
+#else
+                                headerBytesRead = readTask.Result;
+#endif
+
+                                if ((headerBytesRead != headerByte.Length) && !localPacketPumpShutdownEvent.WaitOne(0))
+                                {
+                                    // Incomplete read. Abort.
+                                    if (headerBytesRead == 0)
+                                    {
+                                        ErrorUtilities.ThrowInternalError("Server disconnected abruptly");
+                                    }
+                                    else
+                                    {
+                                        ErrorUtilities.ThrowInternalError("Incomplete header read from server.  {0} of {1} bytes read", headerBytesRead, headerByte.Length);
+                                    }
+                                }
+
+                                NodePacketType packetType = (NodePacketType)Enum.ToObject(typeof(NodePacketType), headerByte[0]);
+
+                                int packetLength = BinaryPrimitives.ReadInt32LittleEndian(new Span<byte>(headerByte, 1, 4));
+                                int packetBytesRead = 0;
+
+                                _readBufferMemoryStream.Position = 0;
+                                _readBufferMemoryStream.SetLength(packetLength);
+                                byte[] packetData = _readBufferMemoryStream.GetBuffer();
+
+                                packetBytesRead = localStream.Read(packetData, 0, packetLength);
+                                
+                                if (packetBytesRead != packetLength)
+                                {
+                                    // Incomplete read.  Abort.
+                                    ErrorUtilities.ThrowInternalError("Incomplete header read from server. {0} of {1} bytes read", headerBytesRead, headerByte.Length);
+                                }
+
+                                try
+                                {
+                                    _packetFactory.DeserializeAndRoutePacket(0, packetType, _binaryReadTranslator);
+                                }
+                                catch
+                                {
+                                    // Error while deserializing or handling packet. Logging additional info.
+                                    CommunicationsUtilities.Trace("Packet factory failed to receive package. Exception while deserializing packet {0}.", packetType);
+                                    throw;
+                                }
+
+                                if (packetType == NodePacketType.ServerNodeBuildResult)
+                                {
+                                    continueReading = false;
+                                }
+                                else
+                                {
+                                    // Start reading the next package header.
+#if FEATURE_APM
+                                    result = localStream.BeginRead(headerByte, 0, headerByte.Length, null, null);
+#else
+                                    readTask = CommunicationsUtilities.ReadAsync(localStream, headerByte, headerByte.Length);
+#endif
+                                }
+                            }
+                            break;
+
+                        default:
+                            ErrorUtilities.ThrowInternalError("WaitId {0} out of range.", waitId);
+                            break;
+                    }
+                }
+                while (continueReading);
+            }
+            catch (Exception ex)
+            {
+                CommunicationsUtilities.Trace("Exception occurred in the packet pump: {0}", ex);
+                PacketPumpException = ex;
+                PacketPumpErrorEvent.Set();
+            }
+
+            CommunicationsUtilities.Trace("Ending read loop.");
+        }
+        #endregion
+
+        public void Dispose() => Stop();
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/CurrentHost.cs b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
new file mode 100644
index 00000000000..81116ecb054
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/CurrentHost.cs
@@ -0,0 +1,49 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Diagnostics;
+using System.IO;
+using Microsoft.Build.Shared;
+
+#nullable disable
+
+namespace Microsoft.Build.BackEnd
+{
+    internal static class CurrentHost
+    {
+
+#if RUNTIME_TYPE_NETCORE || MONO
+        private static string s_currentHost;
+#endif
+
+        /// <summary>
+        /// Identify the .NET host of the current process.
+        /// </summary>
+        /// <returns>The full path to the executable hosting the current process, or null if running on Full Framework on Windows.</returns>
+        public static string GetCurrentHost()
+        {
+#if RUNTIME_TYPE_NETCORE || MONO
+            if (s_currentHost == null)
+            {
+                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
+                    NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet");
+                if (File.Exists(dotnetExe))
+                {
+                    s_currentHost = dotnetExe;
+                }
+                else
+                {
+                    using (Process currentProcess = Process.GetCurrentProcess())
+                    {
+                        s_currentHost = currentProcess.MainModule.FileName;
+                    }
+                }
+            }
+
+            return s_currentHost;
+#else
+            return null;
+#endif
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
index fe81fa4298d..35dcda21565 100644
--- a/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeEndpointInProc.cs
@@ -221,6 +221,12 @@ public void SendData(INodePacket packet)
                 EnqueuePacket(packet);
             }
         }
+
+        public void ClientWillDisconnect()
+        {
+            // We do not need to do anything here for InProc node.
+        }
+
         #endregion
 
         #region Internal Methods
diff --git a/src/Build/BackEnd/Components/Communications/NodeLauncher.cs b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
new file mode 100644
index 00000000000..9a08a3940a7
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/NodeLauncher.cs
@@ -0,0 +1,211 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Diagnostics;
+using System.Globalization;
+using System.IO;
+using System.Runtime.InteropServices;
+using Microsoft.Build.Exceptions;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.FileSystem;
+using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
+
+#nullable disable
+
+namespace Microsoft.Build.BackEnd
+{
+    internal class NodeLauncher
+    {
+        /// <summary>
+        /// Creates a new MSBuild process
+        /// </summary>
+        public Process Start(string msbuildLocation, string commandLineArgs)
+        {
+            // Disable MSBuild server for a child process.
+            // In case of starting msbuild server it prevents an infinite recurson. In case of starting msbuild node we also do not want this variable to be set.
+            return DisableMSBuildServer(() => StartInternal(msbuildLocation, commandLineArgs));
+        }
+
+        /// <summary>
+        /// Creates a new MSBuild process
+        /// </summary>
+        private Process StartInternal(string msbuildLocation, string commandLineArgs)
+        {
+            // Should always have been set already.
+            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
+
+            if (!FileSystems.Default.FileExists(msbuildLocation))
+            {
+                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotFindMSBuildExe", msbuildLocation));
+            }
+
+            // Repeat the executable name as the first token of the command line because the command line
+            // parser logic expects it and will otherwise skip the first argument
+            commandLineArgs = $"\"{msbuildLocation}\" {commandLineArgs}";
+
+            BackendNativeMethods.STARTUP_INFO startInfo = new();
+            startInfo.cb = Marshal.SizeOf<BackendNativeMethods.STARTUP_INFO>();
+
+            // Null out the process handles so that the parent process does not wait for the child process
+            // to exit before it can exit.
+            uint creationFlags = 0;
+            if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
+            {
+                creationFlags = BackendNativeMethods.NORMALPRIORITYCLASS;
+            }
+
+            if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDNODEWINDOW")))
+            {
+                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
+                {
+                    // Redirect the streams of worker nodes so that this MSBuild.exe's
+                    // parent doesn't wait on idle worker nodes to close streams
+                    // after the build is complete.
+                    startInfo.hStdError = BackendNativeMethods.InvalidHandle;
+                    startInfo.hStdInput = BackendNativeMethods.InvalidHandle;
+                    startInfo.hStdOutput = BackendNativeMethods.InvalidHandle;
+                    startInfo.dwFlags = BackendNativeMethods.STARTFUSESTDHANDLES;
+                    creationFlags |= BackendNativeMethods.CREATENOWINDOW;
+                }
+            }
+            else
+            {
+                creationFlags |= BackendNativeMethods.CREATE_NEW_CONSOLE;
+            }
+
+            CommunicationsUtilities.Trace("Launching node from {0}", msbuildLocation);
+
+            string exeName = msbuildLocation;
+
+#if RUNTIME_TYPE_NETCORE || MONO
+            // Mono automagically uses the current mono, to execute a managed assembly
+            if (!NativeMethodsShared.IsMono)
+            {
+                // Run the child process with the same host as the currently-running process.
+                exeName = CurrentHost.GetCurrentHost();
+            }
+#endif
+
+            if (!NativeMethodsShared.IsWindows)
+            {
+                ProcessStartInfo processStartInfo = new ProcessStartInfo();
+                processStartInfo.FileName = exeName;
+                processStartInfo.Arguments = commandLineArgs;
+                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
+                {
+                    // Redirect the streams of worker nodes so that this MSBuild.exe's
+                    // parent doesn't wait on idle worker nodes to close streams
+                    // after the build is complete.
+                    processStartInfo.RedirectStandardInput = true;
+                    processStartInfo.RedirectStandardOutput = true;
+                    processStartInfo.RedirectStandardError = true;
+                    processStartInfo.CreateNoWindow = (creationFlags | BackendNativeMethods.CREATENOWINDOW) == BackendNativeMethods.CREATENOWINDOW;
+                }
+                processStartInfo.UseShellExecute = false;
+
+                Process process;
+                try
+                {
+                    process = Process.Start(processStartInfo);
+                }
+                catch (Exception ex)
+                {
+                    CommunicationsUtilities.Trace
+                       (
+                           "Failed to launch node from {0}. CommandLine: {1}" + Environment.NewLine + "{2}",
+                           msbuildLocation,
+                           commandLineArgs,
+                           ex.ToString()
+                       );
+
+                    throw new NodeFailedToLaunchException(ex);
+                }
+
+                CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", process.Id, exeName);
+                return process;
+            }
+            else
+            {
+#if RUNTIME_TYPE_NETCORE
+                // Repeat the executable name in the args to suit CreateProcess
+                commandLineArgs = $"\"{exeName}\" {commandLineArgs}";
+#endif
+
+                BackendNativeMethods.PROCESS_INFORMATION processInfo = new();
+                BackendNativeMethods.SECURITY_ATTRIBUTES processSecurityAttributes = new();
+                BackendNativeMethods.SECURITY_ATTRIBUTES threadSecurityAttributes = new();
+                processSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
+                threadSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
+
+                bool result = BackendNativeMethods.CreateProcess
+                    (
+                        exeName,
+                        commandLineArgs,
+                        ref processSecurityAttributes,
+                        ref threadSecurityAttributes,
+                        false,
+                        creationFlags,
+                        BackendNativeMethods.NullPtr,
+                        null,
+                        ref startInfo,
+                        out processInfo
+                    );
+
+                if (!result)
+                {
+                    // Creating an instance of this exception calls GetLastWin32Error and also converts it to a user-friendly string.
+                    System.ComponentModel.Win32Exception e = new System.ComponentModel.Win32Exception();
+
+                    CommunicationsUtilities.Trace
+                        (
+                            "Failed to launch node from {0}. System32 Error code {1}. Description {2}. CommandLine: {2}",
+                            msbuildLocation,
+                            e.NativeErrorCode.ToString(CultureInfo.InvariantCulture),
+                            e.Message,
+                            commandLineArgs
+                        );
+
+                    throw new NodeFailedToLaunchException(e.NativeErrorCode.ToString(CultureInfo.InvariantCulture), e.Message);
+                }
+
+                int childProcessId = processInfo.dwProcessId;
+
+                if (processInfo.hProcess != IntPtr.Zero && processInfo.hProcess != NativeMethods.InvalidHandle)
+                {
+                    NativeMethodsShared.CloseHandle(processInfo.hProcess);
+                }
+
+                if (processInfo.hThread != IntPtr.Zero && processInfo.hThread != NativeMethods.InvalidHandle)
+                {
+                    NativeMethodsShared.CloseHandle(processInfo.hThread);
+                }
+
+                CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", childProcessId, exeName);
+                return Process.GetProcessById(childProcessId);
+            }
+        }
+
+        private Process DisableMSBuildServer(Func<Process> func)
+        {
+            string useMSBuildServerEnvVarValue = Environment.GetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName);
+            try
+            {
+                if (useMSBuildServerEnvVarValue is not null)
+                {
+                    Environment.SetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName, "0");
+                }
+                return func();
+            }
+            finally
+            {
+                if (useMSBuildServerEnvVarValue is not null)
+                {
+                    Environment.SetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName, useMSBuildServerEnvVarValue);
+                }
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
index c681f417bb5..cd5a88127e0 100644
--- a/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
+++ b/src/Build/BackEnd/Components/Communications/NodeProviderOutOfProcBase.cs
@@ -20,11 +20,8 @@
 #if FEATURE_APM
 using Microsoft.Build.Eventing;
 #endif
-using Microsoft.Build.Exceptions;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
-using Microsoft.Build.Shared.FileSystem;
-using BackendNativeMethods = Microsoft.Build.BackEnd.NativeMethods;
 using Task = System.Threading.Tasks.Task;
 using Microsoft.Build.Framework;
 using Microsoft.Build.BackEnd.Logging;
@@ -332,7 +329,8 @@ bool StartNewNode(int nodeId)
                     }
 #endif
                     // Create the node process
-                    Process msbuildProcess = LaunchNode(msbuildLocation, commandLineArgs);
+                    NodeLauncher nodeLauncher = new NodeLauncher();
+                    Process msbuildProcess = nodeLauncher.Start(msbuildLocation, commandLineArgs);
                     _processesToIgnore.TryAdd(GetProcessesToIgnoreKey(hostHandshake, msbuildProcess.Id), default);
 
                     // Note, when running under IMAGEFILEEXECUTIONOPTIONS registry key to debug, the process ID
@@ -398,7 +396,7 @@ void CreateNodeContext(int nodeId, Process nodeToReuse, Stream nodeStream)
                 msbuildLocation = "MSBuild.exe";
             }
 
-            var expectedProcessName = Path.GetFileNameWithoutExtension(GetCurrentHost() ?? msbuildLocation);
+            var expectedProcessName = Path.GetFileNameWithoutExtension(CurrentHost.GetCurrentHost() ?? msbuildLocation);
 
             var processes = Process.GetProcessesByName(expectedProcessName);
             Array.Sort(processes, (left, right) => left.Id.CompareTo(right.Id));
@@ -418,7 +416,7 @@ private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessI
 #if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
         // This code needs to be in a separate method so that we don't try (and fail) to load the Windows-only APIs when JIT-ing the code
         //  on non-Windows operating systems
-        private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStream)
+        private static void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStream)
         {
             SecurityIdentifier identifier = WindowsIdentity.GetCurrent().Owner;
 #if FEATURE_PIPE_SECURITY
@@ -442,7 +440,7 @@ private void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStrea
         private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake)
         {
             // Try and connect to the process.
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath(nodeProcessId);
+            string pipeName = NamedPipeUtil.GetPlatformSpecificPipeName(nodeProcessId);
 
             NamedPipeClientStream nodeStream = new NamedPipeClientStream(".", pipeName, PipeDirection.InOut, PipeOptions.Asynchronous
 #if FEATURE_PIPEOPTIONS_CURRENTUSERONLY
@@ -453,40 +451,7 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake han
 
             try
             {
-                nodeStream.Connect(timeout);
-
-#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
-                if (NativeMethodsShared.IsWindows && !NativeMethodsShared.IsMono)
-                {
-                    // Verify that the owner of the pipe is us.  This prevents a security hole where a remote node has
-                    // been faked up with ACLs that would let us attach to it.  It could then issue fake build requests back to
-                    // us, potentially causing us to execute builds that do harmful or unexpected things.  The pipe owner can
-                    // only be set to the user's own SID by a normal, unprivileged process.  The conditions where a faked up
-                    // remote node could set the owner to something else would also let it change owners on other objects, so
-                    // this would be a security flaw upstream of us.
-                    ValidateRemotePipeSecurityOnWindows(nodeStream);
-                }
-#endif
-
-                int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
-                for (int i = 0; i < handshakeComponents.Length; i++)
-                {
-                    CommunicationsUtilities.Trace("Writing handshake part {0} ({1}) to pipe {2}", i, handshakeComponents[i], pipeName);
-                    nodeStream.WriteIntForHandshake(handshakeComponents[i]);
-                }
-
-                // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.
-                nodeStream.WriteEndOfHandshakeSignal();
-
-                CommunicationsUtilities.Trace("Reading handshake from pipe {0}", pipeName);
-
-#if NETCOREAPP2_1_OR_GREATER || MONO
-                nodeStream.ReadEndOfHandshakeSignal(true, timeout);
-#else
-                nodeStream.ReadEndOfHandshakeSignal(true);
-#endif
-                // We got a connection.
-                CommunicationsUtilities.Trace("Successfully connected to pipe {0}...!", pipeName);
+                ConnectToPipeStream(nodeStream, pipeName, handshake, timeout);
                 return nodeStream;
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
@@ -506,196 +471,47 @@ private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake han
         }
 
         /// <summary>
-        /// Creates a new MSBuild process
+        /// Connect to named pipe stream and ensure validate handshake and security.
         /// </summary>
-        private Process LaunchNode(string msbuildLocation, string commandLineArgs)
+        /// <remarks>
+        /// Reused by MSBuild server client <see cref="Microsoft.Build.Experimental.MSBuildClient"/>.
+        /// </remarks>
+        internal static void ConnectToPipeStream(NamedPipeClientStream nodeStream, string pipeName, Handshake handshake, int timeout)
         {
-            // Should always have been set already.
-            ErrorUtilities.VerifyThrowInternalLength(msbuildLocation, nameof(msbuildLocation));
-
-            if (!FileSystems.Default.FileExists(msbuildLocation))
-            {
-                throw new BuildAbortedException(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("CouldNotFindMSBuildExe", msbuildLocation));
-            }
-
-            // Repeat the executable name as the first token of the command line because the command line
-            // parser logic expects it and will otherwise skip the first argument
-            commandLineArgs = $"\"{msbuildLocation}\" {commandLineArgs}";
+            nodeStream.Connect(timeout);
 
-            BackendNativeMethods.STARTUP_INFO startInfo = new();
-            startInfo.cb = Marshal.SizeOf<BackendNativeMethods.STARTUP_INFO>();
-
-            // Null out the process handles so that the parent process does not wait for the child process
-            // to exit before it can exit.
-            uint creationFlags = 0;
-            if (Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
-            {
-                creationFlags = BackendNativeMethods.NORMALPRIORITYCLASS;
-            }
-
-            if (String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDNODEWINDOW")))
-            {
-                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
-                {
-                    // Redirect the streams of worker nodes so that this MSBuild.exe's
-                    // parent doesn't wait on idle worker nodes to close streams
-                    // after the build is complete.
-                    startInfo.hStdError = BackendNativeMethods.InvalidHandle;
-                    startInfo.hStdInput = BackendNativeMethods.InvalidHandle;
-                    startInfo.hStdOutput = BackendNativeMethods.InvalidHandle;
-                    startInfo.dwFlags = BackendNativeMethods.STARTFUSESTDHANDLES;
-                    creationFlags |= BackendNativeMethods.CREATENOWINDOW;
-                }
-            }
-            else
-            {
-                creationFlags |= BackendNativeMethods.CREATE_NEW_CONSOLE;
-            }
-
-            CommunicationsUtilities.Trace("Launching node from {0}", msbuildLocation);
-
-            string exeName = msbuildLocation;
-
-#if RUNTIME_TYPE_NETCORE || MONO
-            // Mono automagically uses the current mono, to execute a managed assembly
-            if (!NativeMethodsShared.IsMono)
+#if !FEATURE_PIPEOPTIONS_CURRENTUSERONLY
+            if (NativeMethodsShared.IsWindows && !NativeMethodsShared.IsMono)
             {
-                // Run the child process with the same host as the currently-running process.
-                exeName = GetCurrentHost();
+                // Verify that the owner of the pipe is us.  This prevents a security hole where a remote node has
+                // been faked up with ACLs that would let us attach to it.  It could then issue fake build requests back to
+                // us, potentially causing us to execute builds that do harmful or unexpected things.  The pipe owner can
+                // only be set to the user's own SID by a normal, unprivileged process.  The conditions where a faked up
+                // remote node could set the owner to something else would also let it change owners on other objects, so
+                // this would be a security flaw upstream of us.
+                ValidateRemotePipeSecurityOnWindows(nodeStream);
             }
 #endif
 
-            if (!NativeMethodsShared.IsWindows)
-            {
-                ProcessStartInfo processStartInfo = new ProcessStartInfo();
-                processStartInfo.FileName = exeName;
-                processStartInfo.Arguments = commandLineArgs;
-                if (!Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout)
-                {
-                    // Redirect the streams of worker nodes so that this MSBuild.exe's
-                    // parent doesn't wait on idle worker nodes to close streams
-                    // after the build is complete.
-                    processStartInfo.RedirectStandardInput = true;
-                    processStartInfo.RedirectStandardOutput = true;
-                    processStartInfo.RedirectStandardError = true;
-                    processStartInfo.CreateNoWindow = (creationFlags | BackendNativeMethods.CREATENOWINDOW) == BackendNativeMethods.CREATENOWINDOW;
-                }
-                processStartInfo.UseShellExecute = false;
-
-                Process process;
-                try
-                {
-                    process = Process.Start(processStartInfo);
-                }
-                catch (Exception ex)
-                {
-                    CommunicationsUtilities.Trace
-                       (
-                           "Failed to launch node from {0}. CommandLine: {1}" + Environment.NewLine + "{2}",
-                           msbuildLocation,
-                           commandLineArgs,
-                           ex.ToString()
-                       );
-
-                    throw new NodeFailedToLaunchException(ex);
-                }
-
-                CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", process.Id, exeName);
-                return process;
-            }
-            else
+            int[] handshakeComponents = handshake.RetrieveHandshakeComponents();
+            for (int i = 0; i < handshakeComponents.Length; i++)
             {
-#if RUNTIME_TYPE_NETCORE
-                // Repeat the executable name in the args to suit CreateProcess
-                commandLineArgs = $"\"{exeName}\" {commandLineArgs}";
-#endif
-
-                BackendNativeMethods.PROCESS_INFORMATION processInfo = new();
-                BackendNativeMethods.SECURITY_ATTRIBUTES processSecurityAttributes = new();
-                BackendNativeMethods.SECURITY_ATTRIBUTES threadSecurityAttributes = new();
-                processSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
-                threadSecurityAttributes.nLength = Marshal.SizeOf<BackendNativeMethods.SECURITY_ATTRIBUTES>();
-
-                bool result = BackendNativeMethods.CreateProcess
-                    (
-                        exeName,
-                        commandLineArgs,
-                        ref processSecurityAttributes,
-                        ref threadSecurityAttributes,
-                        false,
-                        creationFlags,
-                        BackendNativeMethods.NullPtr,
-                        null,
-                        ref startInfo,
-                        out processInfo
-                    );
-
-                if (!result)
-                {
-                    // Creating an instance of this exception calls GetLastWin32Error and also converts it to a user-friendly string.
-                    System.ComponentModel.Win32Exception e = new System.ComponentModel.Win32Exception();
-
-                    CommunicationsUtilities.Trace
-                        (
-                            "Failed to launch node from {0}. System32 Error code {1}. Description {2}. CommandLine: {2}",
-                            msbuildLocation,
-                            e.NativeErrorCode.ToString(CultureInfo.InvariantCulture),
-                            e.Message,
-                            commandLineArgs
-                        );
-
-                    throw new NodeFailedToLaunchException(e.NativeErrorCode.ToString(CultureInfo.InvariantCulture), e.Message);
-                }
-
-                int childProcessId = processInfo.dwProcessId;
-
-                if (processInfo.hProcess != IntPtr.Zero && processInfo.hProcess != NativeMethods.InvalidHandle)
-                {
-                    NativeMethodsShared.CloseHandle(processInfo.hProcess);
-                }
-
-                if (processInfo.hThread != IntPtr.Zero && processInfo.hThread != NativeMethods.InvalidHandle)
-                {
-                    NativeMethodsShared.CloseHandle(processInfo.hThread);
-                }
-
-                CommunicationsUtilities.Trace("Successfully launched {1} node with PID {0}", childProcessId, exeName);
-                return Process.GetProcessById(childProcessId);
+                CommunicationsUtilities.Trace("Writing handshake part {0} ({1}) to pipe {2}", i, handshakeComponents[i], pipeName);
+                nodeStream.WriteIntForHandshake(handshakeComponents[i]);
             }
-        }
 
-#if RUNTIME_TYPE_NETCORE || MONO
-        private static string CurrentHost;
-#endif
+            // This indicates that we have finished all the parts of our handshake; hopefully the endpoint has as well.
+            nodeStream.WriteEndOfHandshakeSignal();
 
-        /// <summary>
-        /// Identify the .NET host of the current process.
-        /// </summary>
-        /// <returns>The full path to the executable hosting the current process, or null if running on Full Framework on Windows.</returns>
-        private static string GetCurrentHost()
-        {
-#if RUNTIME_TYPE_NETCORE || MONO
-            if (CurrentHost == null)
-            {
-                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
-                    NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet");
-                if (File.Exists(dotnetExe))
-                {
-                    CurrentHost = dotnetExe;
-                }
-                else
-                {
-                    using (Process currentProcess = Process.GetCurrentProcess())
-                    {
-                        CurrentHost = currentProcess.MainModule.FileName;
-                    }
-                }
-            }
+            CommunicationsUtilities.Trace("Reading handshake from pipe {0}", pipeName);
 
-            return CurrentHost;
+#if NETCOREAPP2_1_OR_GREATER || MONO
+            nodeStream.ReadEndOfHandshakeSignal(true, timeout);
 #else
-            return null;
+            nodeStream.ReadEndOfHandshakeSignal(true);
 #endif
+            // We got a connection.
+            CommunicationsUtilities.Trace("Successfully connected to pipe {0}...!", pipeName);
         }
 
         /// <summary>
diff --git a/src/Build/BackEnd/Components/Communications/ServerNodeEndpointOutOfProc.cs b/src/Build/BackEnd/Components/Communications/ServerNodeEndpointOutOfProc.cs
new file mode 100644
index 00000000000..9616f90964b
--- /dev/null
+++ b/src/Build/BackEnd/Components/Communications/ServerNodeEndpointOutOfProc.cs
@@ -0,0 +1,37 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Internal;
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// This is an implementation of out-of-proc server node endpoint.
+    /// </summary>
+    internal sealed class ServerNodeEndpointOutOfProc : NodeEndpointOutOfProcBase
+    {
+        private readonly Handshake _handshake;
+
+        /// <summary>
+        /// Instantiates an endpoint to act as a client
+        /// </summary>
+        /// <param name="pipeName">The name of the pipe to which we should connect.</param>
+        /// <param name="handshake"></param>
+        internal ServerNodeEndpointOutOfProc(
+            string pipeName,
+            Handshake handshake)
+        {
+            _handshake = handshake;
+
+            InternalConstruct(pipeName);
+        }
+
+        /// <summary>
+        /// Returns the host handshake for this node endpoint
+        /// </summary>
+        protected override Handshake GetHandshake()
+        {
+            return _handshake;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Components/Logging/LoggingService.cs b/src/Build/BackEnd/Components/Logging/LoggingService.cs
index 6cf71eac4e9..2f08099b333 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingService.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingService.cs
@@ -1432,8 +1432,20 @@ private void LoggingEventProcessor(object loggingEvent)
         /// </summary>
         private void RouteBuildEvent(object loggingEvent)
         {
-            BuildEventArgs buildEventArgs = loggingEvent as BuildEventArgs ?? (loggingEvent as KeyValuePair<int, BuildEventArgs>?)?.Value;
-            ErrorUtilities.VerifyThrow(buildEventArgs is not null, "Unknown logging item in queue:" + loggingEvent.GetType().FullName);
+            BuildEventArgs buildEventArgs = null;
+
+            if (loggingEvent is BuildEventArgs bea)
+            {
+                buildEventArgs = bea;
+            }
+            else if (loggingEvent is KeyValuePair<int, BuildEventArgs> kvp)
+            {
+                buildEventArgs = kvp.Value;
+            }
+            else
+            {
+                ErrorUtilities.ThrowInternalError("Unknown logging item in queue:" + loggingEvent.GetType().FullName);
+            }
 
             if (buildEventArgs is BuildWarningEventArgs warningEvent)
             {
@@ -1477,12 +1489,14 @@ private void RouteBuildEvent(object loggingEvent)
                     };
                 }
             }
-            else if (loggingEvent is BuildErrorEventArgs errorEvent)
+
+            if (loggingEvent is BuildErrorEventArgs errorEvent)
             {
                 // Keep track of build submissions that have logged errors.  If there is no build context, add BuildEventContext.InvalidSubmissionId.
                 _buildSubmissionIdsThatHaveLoggedErrors.Add(errorEvent.BuildEventContext?.SubmissionId ?? BuildEventContext.InvalidSubmissionId);
             }
-            else if (loggingEvent is ProjectFinishedEventArgs projectFinishedEvent && projectFinishedEvent.BuildEventContext != null)
+
+            if (loggingEvent is ProjectFinishedEventArgs projectFinishedEvent && projectFinishedEvent.BuildEventContext != null)
             {
                 int key = GetWarningsAsErrorOrMessageKey(projectFinishedEvent);
                 _warningsAsErrorsByProject?.Remove(key);
@@ -1527,7 +1541,7 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
             TryRaiseProjectStartedEvent(eventArg);
 
             // The event has not been through a filter yet. All events must go through a filter before they make it to a logger
-            if (_filterEventSource != null) // Loggers may not be registered
+            if (_filterEventSource != null)   // Loggers may not be registered
             {
                 // Send the event to the filter, the Consume will not return until all of the loggers which have registered to the event have process
                 // them.
@@ -1548,7 +1562,7 @@ private void RouteBuildEvent(BuildEventArgs eventArg)
                         {
                             if (!sink.HaveLoggedBuildStartedEvent)
                             {
-                                sink.Consume(eventArg, pair.Key);
+                                sink.Consume(eventArg, (int)pair.Key);
                             }
 
                             // Reset the HaveLoggedBuildStarted event because no one else will be sending a build started event to any loggers at this time.
diff --git a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
index b9348623878..214a5118c2c 100644
--- a/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
+++ b/src/Build/BackEnd/Components/Logging/LoggingServiceLogMethods.cs
@@ -388,11 +388,14 @@ public void LogBuildStarted()
                 message = ResourceUtilities.GetResourceString("BuildStarted");
             }
 
-            IDictionary<string, string> environmentProperties = _componentHost?.BuildParameters != null && Traits.Instance.LogAllEnvironmentVariables ?
-                _componentHost.BuildParameters.BuildProcessEnvironment
-                : null;
+            IDictionary<string, string> environmentProperties = null;
 
-            BuildStartedEventArgs buildEvent = new(message, helpKeyword: null, environmentProperties);
+            if (_componentHost?.BuildParameters != null)
+            {
+                environmentProperties = _componentHost.BuildParameters.BuildProcessEnvironment;
+            }
+
+            BuildStartedEventArgs buildEvent = new BuildStartedEventArgs(message, null /* no help keyword */, environmentProperties);
 
             // Raise the event with the filters
             ProcessLoggingEvent(buildEvent);
diff --git a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
index b7f2fcf4bc2..bc39a5ccd32 100644
--- a/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
+++ b/src/Build/BackEnd/Components/Logging/ProjectLoggingContext.cs
@@ -8,7 +8,6 @@
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
-using static Microsoft.Build.Execution.ProjectPropertyInstance;
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 
 #nullable disable
@@ -72,17 +71,6 @@ internal ProjectLoggingContext(
         {
         }
 
-        private IEnumerable<DictionaryEntry> FilterEnvironmentDerivedProperties(PropertyDictionary<ProjectPropertyInstance> properties)
-        {
-            foreach (ProjectPropertyInstance property in properties)
-            {
-                if (property is not EnvironmentDerivedProjectPropertyInstance)
-                {
-                    yield return new DictionaryEntry(property.Name, property.EvaluatedValue);
-                }
-            }
-        }
-
         /// <summary>
         /// Constructs a project logging contexts.
         /// </summary>
@@ -112,19 +100,7 @@ private ProjectLoggingContext(
                 !LoggingService.IncludeEvaluationPropertiesAndItems &&
                 (!LoggingService.RunningOnRemoteNode || LoggingService.SerializeAllProperties))
             {
-                if (projectProperties is null)
-                {
-                    properties = Enumerable.Empty<DictionaryEntry>();
-                }
-                else if (Traits.Instance.LogAllEnvironmentVariables)
-                {
-                    properties = projectProperties.GetCopyOnReadEnumerable(property => new DictionaryEntry(property.Name, property.EvaluatedValue));
-                }
-                else
-                {
-                    properties = FilterEnvironmentDerivedProperties(projectProperties);
-                }
-
+                properties = projectProperties?.GetCopyOnReadEnumerable(property => new DictionaryEntry(property.Name, property.EvaluatedValue)) ?? Enumerable.Empty<DictionaryEntry>();
                 items = projectItems?.GetCopyOnReadEnumerable(item => new DictionaryEntry(item.ItemType, new TaskItem(item))) ?? Enumerable.Empty<DictionaryEntry>();
             }
 
diff --git a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
index 4bbb3ae656d..8c3cdb46bb8 100644
--- a/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
+++ b/src/Build/BackEnd/Components/ProjectCache/ProjectCacheService.cs
@@ -345,17 +345,8 @@ void EvaluateProjectIfNecessary(CacheRequest request)
             async Task LateInitializePluginForVsWorkaround(CacheRequest request)
             {
                 var (_, configuration) = request;
-                var solutionPath = configuration.Project.GetPropertyValue(SolutionProjectGenerator.SolutionPathPropertyName);
                 var solutionConfigurationXml = configuration.Project.GetPropertyValue(SolutionProjectGenerator.CurrentSolutionConfigurationContents);
 
-                ErrorUtilities.VerifyThrow(
-                    solutionPath != null && !string.IsNullOrWhiteSpace(solutionPath) && solutionPath != "*Undefined*",
-                    $"Expected VS to set a valid SolutionPath property but got: {solutionPath}");
-
-                ErrorUtilities.VerifyThrow(
-                    FileSystems.Default.FileExists(solutionPath),
-                    $"Solution file does not exist: {solutionPath}");
-
                 ErrorUtilities.VerifyThrow(
                     string.IsNullOrWhiteSpace(solutionConfigurationXml) is false,
                     "Expected VS to set a xml with all the solution projects' configurations for the currently building solution configuration.");
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
index 32b7c6b1b1a..505bc1d2df1 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/ItemGroupIntrinsicTask.cs
@@ -15,7 +15,6 @@
 using ProjectItemInstanceFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.ProjectItemInstanceFactory;
 using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using TargetLoggingContext = Microsoft.Build.BackEnd.Logging.TargetLoggingContext;
-using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -84,7 +83,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.KeepMetadata))
                             {
-                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation, LoggingContext).ToList();
+                                var keepMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.KeepMetadata, ExpanderOptions.ExpandAll, child.KeepMetadataLocation).ToList();
                                 if (keepMetadataEvaluated.Count > 0)
                                 {
                                     keepMetadata = new HashSet<string>(keepMetadataEvaluated);
@@ -93,7 +92,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.RemoveMetadata))
                             {
-                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation, LoggingContext).ToList();
+                                var removeMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.RemoveMetadata, ExpanderOptions.ExpandAll, child.RemoveMetadataLocation).ToList();
                                 if (removeMetadataEvaluated.Count > 0)
                                 {
                                     removeMetadata = new HashSet<string>(removeMetadataEvaluated);
@@ -102,7 +101,7 @@ internal override void ExecuteTask(Lookup lookup)
 
                             if (!String.IsNullOrEmpty(child.MatchOnMetadata))
                             {
-                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation, LoggingContext).ToList();
+                                var matchOnMetadataEvaluated = bucket.Expander.ExpandIntoStringListLeaveEscaped(child.MatchOnMetadata, ExpanderOptions.ExpandAll, child.MatchOnMetadataLocation).ToList();
                                 if (matchOnMetadataEvaluated.Count > 0)
                                 {
                                     matchOnMetadata = new HashSet<string>(matchOnMetadataEvaluated);
@@ -115,7 +114,7 @@ internal override void ExecuteTask(Lookup lookup)
                                 (child.Exclude.Length != 0))
                             {
                                 // It's an item -- we're "adding" items to the world
-                                ExecuteAdd(child, bucket, keepMetadata, removeMetadata, LoggingContext);
+                                ExecuteAdd(child, bucket, keepMetadata, removeMetadata);
                             }
                             else if (child.Remove.Length != 0)
                             {
@@ -125,7 +124,7 @@ internal override void ExecuteTask(Lookup lookup)
                             else
                             {
                                 // It's a modify -- changing existing items
-                                ExecuteModify(child, bucket, keepMetadata, removeMetadata, LoggingContext);
+                                ExecuteModify(child, bucket, keepMetadata, removeMetadata);
                             }
                         }
                     }
@@ -151,8 +150,7 @@ internal override void ExecuteTask(Lookup lookup)
         /// <param name="bucket">The batching bucket.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        /// <param name="loggingContext">Context for logging</param>
-        private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata, LoggingContext loggingContext = null)
+        private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata)
         {
             // First, collect up the appropriate metadata collections.  We need the one from the item definition, if any, and
             // the one we are using for this batching bucket.
@@ -166,7 +164,7 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
             bucket.Expander.Metadata = metadataTable;
 
             // Second, expand the item include and exclude, and filter existing metadata as appropriate.
-            List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata, loggingContext);
+            List<ProjectItemInstance> itemsToAdd = ExpandItemIntoItems(child, bucket.Expander, keepMetadata, removeMetadata);
 
             // Third, expand the metadata.           
             foreach (ProjectItemGroupTaskMetadataInstance metadataInstance in child.Metadata)
@@ -181,12 +179,11 @@ private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucke
                     metadataInstance.Location,
                     LoggingContext.LoggingService,
                     LoggingContext.BuildEventContext,
-                    FileSystems.Default,
-                    loggingContext: loggingContext);
+                    FileSystems.Default);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
 
                     // This both stores the metadata so we can add it to all the items we just created later, and 
                     // exposes this metadata to further metadata evaluations in subsequent loop iterations.
@@ -248,7 +245,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
             List<ProjectItemInstance> itemsToRemove;
             if (matchOnMetadata == null)
             {
-                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander, LoggingContext);
+                itemsToRemove = FindItemsMatchingSpecification(group, child.Remove, child.RemoveLocation, bucket.Expander);
             }
             else
             {
@@ -280,8 +277,7 @@ private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bu
         /// <param name="bucket">The batching bucket.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        /// <param name="loggingContext">Context for this operation.</param>
-        private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata, LoggingContext loggingContext = null)
+        private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet<string> keepMetadata, ISet<string> removeMetadata)
         {
             ICollection<ProjectItemInstance> group = bucket.Lookup.GetItems(child.ItemType);
             if (group == null || group.Count == 0)
@@ -321,12 +317,11 @@ private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bu
                     metadataInstance.ConditionLocation,
                     LoggingContext.LoggingService,
                     LoggingContext.BuildEventContext,
-                    FileSystems.Default,
-                    loggingContext: loggingContext);
+                    FileSystems.Default);
 
                 if (condition)
                 {
-                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location, loggingContext);
+                    string evaluatedValue = bucket.Expander.ExpandIntoStringLeaveEscaped(metadataInstance.Value, ExpanderOptions.ExpandAll, metadataInstance.Location);
                     metadataToSet[metadataInstance.Name] = Lookup.MetadataModification.CreateFromNewValue(evaluatedValue);
                 }
             }
@@ -362,7 +357,6 @@ private void GetBatchableValuesFromBuildItemGroupChild(List<string> parameterVal
         /// <param name="expander">The expander to use.</param>
         /// <param name="keepMetadata">An <see cref="ISet{String}"/> of metadata names to keep.</param>
         /// <param name="removeMetadata">An <see cref="ISet{String}"/> of metadata names to remove.</param>
-        /// <param name="loggingContext">Context for logging</param>
         /// <remarks>
         /// This code is very close to that which exists in the Evaluator.EvaluateItemXml method.  However, because
         /// it invokes type constructors, and those constructors take arguments of fundamentally different types, it has not
@@ -374,8 +368,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             ProjectItemGroupTaskItemInstance originalItem,
             Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
             ISet<string> keepMetadata,
-            ISet<string> removeMetadata,
-            LoggingContext loggingContext = null
+            ISet<string> removeMetadata
         )
         {
             // todo this is duplicated logic with the item computation logic from evaluation (in LazyIncludeOperation.SelectItems)
@@ -383,7 +376,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             List<ProjectItemInstance> items = new List<ProjectItemInstance>();
 
             // Expand properties and metadata in Include
-            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation, loggingContext);
+            string evaluatedInclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Include, ExpanderOptions.ExpandPropertiesAndMetadata, originalItem.IncludeLocation);
 
             if (evaluatedInclude.Length == 0)
             {
@@ -394,7 +387,7 @@ private List<ProjectItemInstance> ExpandItemIntoItems
             var excludes = ImmutableList<string>.Empty.ToBuilder();
             if (originalItem.Exclude.Length > 0)
             {
-                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation, loggingContext);
+                string evaluatedExclude = expander.ExpandIntoStringLeaveEscaped(originalItem.Exclude, ExpanderOptions.ExpandAll, originalItem.ExcludeLocation);
 
                 if (evaluatedExclude.Length > 0)
                 {
@@ -523,15 +516,13 @@ private List<ProjectItemInstance> ExpandItemIntoItems
         /// <param name="specification">The specification to match against the items.</param>
         /// <param name="specificationLocation">The specification to match against the provided items</param>
         /// <param name="expander">The expander to use</param>
-        /// <param name="loggingContext">Context for logging</param>
         /// <returns>A list of matching items</returns>
         private List<ProjectItemInstance> FindItemsMatchingSpecification
             (
             ICollection<ProjectItemInstance> items,
             string specification,
             ElementLocation specificationLocation,
-            Expander<ProjectPropertyInstance, ProjectItemInstance> expander,
-            LoggingContext loggingContext = null
+            Expander<ProjectPropertyInstance, ProjectItemInstance> expander
             )
         {
             if (items.Count == 0 || specification.Length == 0)
@@ -544,7 +535,7 @@ private List<ProjectItemInstance> FindItemsMatchingSpecification
             HashSet<string> specificationsToFind = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
 
             // Split by semicolons
-            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation, loggingContext);
+            var specificationPieces = expander.ExpandIntoStringListLeaveEscaped(specification, ExpanderOptions.ExpandAll, specificationLocation);
 
             foreach (string piece in specificationPieces)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
index e05113ea688..a4c0de12aca 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/IntrinsicTasks/MSBuild.cs
@@ -25,8 +25,13 @@ internal class MSBuild : ITask
         /// <summary>
         /// Enum describing the behavior when a project doesn't exist on disk.
         /// </summary>
-        private enum SkipNonexistentProjectsBehavior
+        private enum SkipNonExistentProjectsBehavior
         {
+            /// <summary>
+            /// Default when unset by user.
+            /// </summary>
+            Undefined,
+
             /// <summary>
             /// Skip the project if there is no file on disk.
             /// </summary>
@@ -49,7 +54,7 @@ private enum SkipNonexistentProjectsBehavior
         private readonly List<ITaskItem> _targetOutputs = new List<ITaskItem>();
 
         // Whether to skip project files that don't exist on disk. By default we error for such projects.
-        private SkipNonexistentProjectsBehavior _skipNonexistentProjects = SkipNonexistentProjectsBehavior.Error;
+        private SkipNonExistentProjectsBehavior _skipNonExistentProjects = SkipNonExistentProjectsBehavior.Undefined;
 
         private TaskLoggingHelper _logHelper;
 
@@ -162,19 +167,22 @@ public string SkipNonexistentProjects
         {
             get
             {
-                switch (_skipNonexistentProjects)
+                switch (_skipNonExistentProjects)
                 {
-                    case SkipNonexistentProjectsBehavior.Build:
+                    case SkipNonExistentProjectsBehavior.Undefined:
+                        return "Undefined";
+
+                    case SkipNonExistentProjectsBehavior.Build:
                         return "Build";
 
-                    case SkipNonexistentProjectsBehavior.Error:
+                    case SkipNonExistentProjectsBehavior.Error:
                         return "False";
 
-                    case SkipNonexistentProjectsBehavior.Skip:
+                    case SkipNonExistentProjectsBehavior.Skip:
                         return "True";
 
                     default:
-                        ErrorUtilities.ThrowInternalError("Unexpected case {0}", _skipNonexistentProjects);
+                        ErrorUtilities.ThrowInternalError("Unexpected case {0}", _skipNonExistentProjects);
                         break;
                 }
 
@@ -184,15 +192,9 @@ public string SkipNonexistentProjects
 
             set
             {
-                if (String.Equals("Build", value, StringComparison.OrdinalIgnoreCase))
-                {
-                    _skipNonexistentProjects = SkipNonexistentProjectsBehavior.Build;
-                }
-                else
+                if (TryParseSkipNonExistentProjects(value, out SkipNonExistentProjectsBehavior behavior))
                 {
-                    ErrorUtilities.VerifyThrowArgument(ConversionUtilities.CanConvertStringToBool(value), "MSBuild.InvalidSkipNonexistentProjectValue");
-                    bool originalSkipValue = ConversionUtilities.ConvertStringToBool(value);
-                    _skipNonexistentProjects = originalSkipValue ? SkipNonexistentProjectsBehavior.Skip : SkipNonexistentProjectsBehavior.Error;
+                    _skipNonExistentProjects = behavior;
                 }
             }
         }
@@ -324,7 +326,21 @@ public async Task<bool> ExecuteInternal()
                     break;
                 }
 
-                if (FileSystems.Default.FileExists(projectPath) || (_skipNonexistentProjects == SkipNonexistentProjectsBehavior.Build))
+                // Try to get the behavior from metadata if it is undefined.
+                var skipNonExistProjects = _skipNonExistentProjects;
+                if (_skipNonExistentProjects == SkipNonExistentProjectsBehavior.Undefined)
+                {
+                    if (TryParseSkipNonExistentProjects(project.GetMetadata("SkipNonexistentProjects"), out SkipNonExistentProjectsBehavior behavior))
+                    {
+                        skipNonExistProjects = behavior;
+                    }
+                    else
+                    {
+                        skipNonExistProjects = SkipNonExistentProjectsBehavior.Error;
+                    }
+                }
+
+                if (FileSystems.Default.FileExists(projectPath) || (skipNonExistProjects == SkipNonExistentProjectsBehavior.Build))
                 {
                     if (FileUtilities.IsVCProjFilename(projectPath))
                     {
@@ -365,13 +381,13 @@ public async Task<bool> ExecuteInternal()
                 }
                 else
                 {
-                    if (_skipNonexistentProjects == SkipNonexistentProjectsBehavior.Skip)
+                    if (skipNonExistProjects == SkipNonExistentProjectsBehavior.Skip)
                     {
                         Log.LogMessageFromResources(MessageImportance.High, "MSBuild.ProjectFileNotFoundMessage", project.ItemSpec);
                     }
                     else
                     {
-                        ErrorUtilities.VerifyThrow(_skipNonexistentProjects == SkipNonexistentProjectsBehavior.Error, "skipNonexistentProjects has unexpected value {0}", _skipNonexistentProjects);
+                        ErrorUtilities.VerifyThrow(skipNonExistProjects == SkipNonExistentProjectsBehavior.Error, "skipNonexistentProjects has unexpected value {0}", skipNonExistProjects);
                         Log.LogErrorWithCodeFromResources("MSBuild.ProjectFileNotFound", project.ItemSpec);
                         success = false;
                     }
@@ -714,6 +730,27 @@ internal static async Task<bool> ExecuteTargets(
             return success;
         }
 
+        private bool TryParseSkipNonExistentProjects(string value, out SkipNonExistentProjectsBehavior behavior)
+        {
+            if (string.IsNullOrEmpty(value))
+            {
+                behavior = SkipNonExistentProjectsBehavior.Error;
+                return false;
+            }
+            else if (String.Equals("Build", value, StringComparison.OrdinalIgnoreCase))
+            {
+                behavior = SkipNonExistentProjectsBehavior.Build;
+            }
+            else
+            {
+                ErrorUtilities.VerifyThrowArgument(ConversionUtilities.CanConvertStringToBool(value), "MSBuild.InvalidSkipNonexistentProjectValue");
+                bool originalSkipValue = ConversionUtilities.ConvertStringToBool(value);
+                behavior = originalSkipValue ? SkipNonExistentProjectsBehavior.Skip : SkipNonExistentProjectsBehavior.Error;
+            }
+
+            return true;
+        }
+
         #endregion
     }
 }
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
index e1479768ff2..49a849c4313 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TargetEntry.cs
@@ -353,8 +353,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 _target.ConditionLocation,
                 projectLoggingContext.LoggingService,
                 projectLoggingContext.BuildEventContext,
-                FileSystems.Default,
-                loggingContext: projectLoggingContext);
+                FileSystems.Default);
 
             if (!condition)
             {
@@ -393,7 +392,7 @@ internal List<TargetSpecification> GetDependencies(ProjectLoggingContext project
                 return new List<TargetSpecification>();
             }
 
-            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation, projectLoggingContext);
+            var dependencies = _expander.ExpandIntoStringListLeaveEscaped(_target.DependsOnTargets, ExpanderOptions.ExpandPropertiesAndItems, _target.DependsOnTargetsLocation);
             List<TargetSpecification> dependencyTargets = new List<TargetSpecification>();
             foreach (string escapedDependency in dependencies)
             {
diff --git a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
index 4835778b4c1..ec05dfd174f 100644
--- a/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
+++ b/src/Build/BackEnd/Components/RequestBuilder/TaskBuilder.cs
@@ -381,8 +381,7 @@ private async Task<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket b
                 _targetChildInstance.ConditionLocation,
                 _targetLoggingContext.LoggingService,
                 _targetLoggingContext.BuildEventContext,
-                FileSystems.Default,
-                loggingContext: _targetLoggingContext);
+                FileSystems.Default);
 
             if (!condition)
             {
@@ -624,7 +623,7 @@ private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTas
                     if (!_targetLoggingContext.LoggingService.OnlyLogCriticalEvents)
                     {
                         // Expand the expression for the Log.  Since we know the condition evaluated to false, leave unexpandable properties in the condition so as not to cause an error
-                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation, loggingContext: _targetLoggingContext);
+                        string expanded = bucket.Expander.ExpandIntoStringAndUnescape(_targetChildInstance.Condition, ExpanderOptions.ExpandAll | ExpanderOptions.LeavePropertiesUnexpandedOnError | ExpanderOptions.Truncate, _targetChildInstance.ConditionLocation);
 
                         // Whilst we are within the processing of the task, we haven't actually started executing it, so
                         // our skip task message needs to be in the context of the target. However any errors should be reported
diff --git a/src/Build/BackEnd/Node/ConsoleOutput.cs b/src/Build/BackEnd/Node/ConsoleOutput.cs
new file mode 100644
index 00000000000..2a685c594d7
--- /dev/null
+++ b/src/Build/BackEnd/Node/ConsoleOutput.cs
@@ -0,0 +1,11 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.BackEnd
+{
+    internal enum ConsoleOutput
+    {
+        Standard = 1,
+        Error
+    }
+}
diff --git a/src/Build/BackEnd/Node/OutOfProcServerNode.cs b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
new file mode 100644
index 00000000000..55e08dc13bd
--- /dev/null
+++ b/src/Build/BackEnd/Node/OutOfProcServerNode.cs
@@ -0,0 +1,431 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Concurrent;
+using System.IO;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Shared;
+using Microsoft.Build.Internal;
+using Microsoft.Build.Execution;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Framework.Telemetry;
+
+namespace Microsoft.Build.Experimental
+{
+    /// <summary>
+    /// This class represents an implementation of INode for out-of-proc server nodes aka MSBuild server 
+    /// </summary>
+    public sealed class OutOfProcServerNode : INode, INodePacketFactory, INodePacketHandler
+    {
+        /// <summary>
+        /// A callback used to execute command line build.
+        /// </summary>
+        public delegate (int exitCode, string exitType) BuildCallback(
+#if FEATURE_GET_COMMANDLINE
+            string commandLine);
+#else
+            string[] commandLine);
+#endif
+
+        private readonly BuildCallback _buildFunction;
+
+        /// <summary>
+        /// The endpoint used to talk to the host.
+        /// </summary>
+        private INodeEndpoint _nodeEndpoint = default!;
+
+        /// <summary>
+        /// The packet factory.
+        /// </summary>
+        private readonly NodePacketFactory _packetFactory;
+
+        /// <summary>
+        /// The queue of packets we have received but which have not yet been processed.
+        /// </summary>
+        private readonly ConcurrentQueue<INodePacket> _receivedPackets;
+
+        /// <summary>
+        /// The event which is set when we receive packets.
+        /// </summary>
+        private readonly AutoResetEvent _packetReceivedEvent;
+
+        /// <summary>
+        /// The event which is set when we should shut down.
+        /// </summary>
+        private readonly ManualResetEvent _shutdownEvent;
+
+        /// <summary>
+        /// The reason we are shutting down.
+        /// </summary>
+        private NodeEngineShutdownReason _shutdownReason;
+
+        /// <summary>
+        /// The exception, if any, which caused shutdown.
+        /// </summary>
+        private Exception? _shutdownException = null;
+
+        private string _serverBusyMutexName = default!;
+
+        public OutOfProcServerNode(BuildCallback buildFunction)
+        {
+            _buildFunction = buildFunction;
+
+            _receivedPackets = new ConcurrentQueue<INodePacket>();
+            _packetReceivedEvent = new AutoResetEvent(false);
+            _shutdownEvent = new ManualResetEvent(false);
+            _packetFactory = new NodePacketFactory();
+
+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCommand, ServerNodeBuildCommand.FactoryForDeserialization, this);
+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.NodeBuildComplete, NodeBuildComplete.FactoryForDeserialization, this);
+            (this as INodePacketFactory).RegisterPacketHandler(NodePacketType.ServerNodeBuildCancel, ServerNodeBuildCancel.FactoryForDeserialization, this);
+        }
+
+        #region INode Members
+        
+        /// <summary>
+        /// Starts up the node and processes messages until the node is requested to shut down.
+        /// </summary>
+        /// <param name="shutdownException">The exception which caused shutdown, if any.</param> 
+        /// <returns>The reason for shutting down.</returns>
+        public NodeEngineShutdownReason Run(out Exception? shutdownException)
+        {
+            ServerNodeHandshake handshake = new(
+                CommunicationsUtilities.GetHandshakeOptions(taskHost: false, architectureFlagToSet: XMakeAttributes.GetCurrentMSBuildArchitecture()));
+
+            _serverBusyMutexName = GetBusyServerMutexName(handshake);
+
+            // Handled race condition. If two processes spawn to start build Server one will die while
+            // one Server client connects to the other one and run build on it.
+            CommunicationsUtilities.Trace("Starting new server node with handshake {0}", handshake);
+            using var serverRunningMutex = ServerNamedMutex.OpenOrCreateMutex(GetRunningServerMutexName(handshake), out bool mutexCreatedNew);
+            if (!mutexCreatedNew)
+            {
+                shutdownException = new InvalidOperationException("MSBuild server is already running!");
+                return NodeEngineShutdownReason.Error;
+            }
+
+            _nodeEndpoint = new ServerNodeEndpointOutOfProc(GetPipeName(handshake), handshake);
+            _nodeEndpoint.OnLinkStatusChanged += OnLinkStatusChanged;
+            _nodeEndpoint.Listen(this);
+
+            var waitHandles = new WaitHandle[] { _shutdownEvent, _packetReceivedEvent };
+            
+            // Get the current directory before doing any work. We need this so we can restore the directory when the node shutsdown.
+            while (true)
+            {
+                int index = WaitHandle.WaitAny(waitHandles);
+                switch (index)
+                {
+                    case 0:
+                        NodeEngineShutdownReason shutdownReason = HandleShutdown(out shutdownException);
+                        return shutdownReason;
+
+                    case 1:
+
+                        while (_receivedPackets.TryDequeue(out INodePacket? packet))
+                        {
+                            if (packet != null)
+                            {
+                                HandlePacket(packet);
+                            }
+                        }
+
+                        break;
+                }
+            }
+
+            // UNREACHABLE
+        }
+
+        #endregion
+
+        internal static string GetPipeName(ServerNodeHandshake handshake)
+            => NamedPipeUtil.GetPlatformSpecificPipeName($"MSBuildServer-{handshake.ComputeHash()}");
+
+        internal static string GetRunningServerMutexName(ServerNodeHandshake handshake)
+            => $@"Global\msbuild-server-running-{handshake.ComputeHash()}";
+
+        internal static string GetBusyServerMutexName(ServerNodeHandshake handshake)
+            => $@"Global\msbuild-server-busy-{handshake.ComputeHash()}";
+
+        #region INodePacketFactory Members
+
+        /// <summary>
+        /// Registers a packet handler.
+        /// </summary>
+        /// <param name="packetType">The packet type for which the handler should be registered.</param>
+        /// <param name="factory">The factory used to create packets.</param>
+        /// <param name="handler">The handler for the packets.</param>
+        void INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler)
+        {
+            _packetFactory.RegisterPacketHandler(packetType, factory, handler);
+        }
+
+        /// <summary>
+        /// Unregisters a packet handler.
+        /// </summary>
+        /// <param name="packetType">The type of packet for which the handler should be unregistered.</param>
+        void INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType)
+        {
+            _packetFactory.UnregisterPacketHandler(packetType);
+        }
+
+        /// <summary>
+        /// Deserializes and routes a packer to the appropriate handler.
+        /// </summary>
+        /// <param name="nodeId">The node from which the packet was received.</param>
+        /// <param name="packetType">The packet type.</param>
+        /// <param name="translator">The translator to use as a source for packet data.</param>
+        void INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator)
+        {
+            _packetFactory.DeserializeAndRoutePacket(nodeId, packetType, translator);
+        }
+
+        /// <summary>
+        /// Routes a packet to the appropriate handler.
+        /// </summary>
+        /// <param name="nodeId">The node id from which the packet was received.</param>
+        /// <param name="packet">The packet to route.</param>
+        void INodePacketFactory.RoutePacket(int nodeId, INodePacket packet)
+        {
+            _packetFactory.RoutePacket(nodeId, packet);
+        }
+
+        #endregion
+
+        #region INodePacketHandler Members
+
+        /// <summary>
+        /// Called when a packet has been received.
+        /// </summary>
+        /// <param name="node">The node from which the packet was received.</param>
+        /// <param name="packet">The packet.</param>
+        void INodePacketHandler.PacketReceived(int node, INodePacket packet)
+        {
+            _receivedPackets.Enqueue(packet);
+            _packetReceivedEvent.Set();
+        }
+
+        #endregion
+
+        /// <summary>
+        /// Perform necessary actions to shut down the node.
+        /// </summary>
+        // TODO: it is too complicated, for simple role of server node it needs to be simplified
+        private NodeEngineShutdownReason HandleShutdown(out Exception? exception)
+        {
+            CommunicationsUtilities.Trace("Shutting down with reason: {0}, and exception: {1}.", _shutdownReason, _shutdownException);
+
+            // On Windows, a process holds a handle to the current directory,
+            // so reset it away from a user-requested folder that may get deleted.
+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);
+
+            exception = _shutdownException;
+
+            _nodeEndpoint.OnLinkStatusChanged -= OnLinkStatusChanged;
+            _nodeEndpoint.Disconnect();
+
+            CommunicationsUtilities.Trace("Shut down complete.");
+
+            return _shutdownReason;
+        }
+
+        /// <summary>
+        /// Event handler for the node endpoint's LinkStatusChanged event.
+        /// </summary>
+        private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status)
+        {
+            switch (status)
+            {
+                case LinkStatus.ConnectionFailed:
+                case LinkStatus.Failed:
+                    _shutdownReason = NodeEngineShutdownReason.ConnectionFailed;
+                    _shutdownEvent.Set();
+                    break;
+
+                default:
+                    break;
+            }
+        }
+
+        /// <summary>
+        /// Callback for logging packets to be sent.
+        /// </summary>
+        private void SendPacket(INodePacket packet)
+        {
+            if (_nodeEndpoint.LinkStatus == LinkStatus.Active)
+            {
+                _nodeEndpoint.SendData(packet);
+            }
+        }
+
+        /// <summary>
+        /// Dispatches the packet to the correct handler.
+        /// </summary>
+        private void HandlePacket(INodePacket packet)
+        {
+            switch (packet.Type)
+            {
+                case NodePacketType.ServerNodeBuildCommand:
+                    HandleServerNodeBuildCommandAsync((ServerNodeBuildCommand)packet);
+                    break;
+                case NodePacketType.ServerNodeBuildCancel:
+                    BuildManager.DefaultBuildManager.CancelAllSubmissions();
+                    break;
+            }
+        }
+
+        private void HandleServerNodeBuildCommandAsync(ServerNodeBuildCommand command)
+        {
+            Task.Run(() =>
+            {
+                try
+                {
+                    HandleServerNodeBuildCommand(command);
+                }
+                catch(Exception e)
+                {
+                    _shutdownException = e;
+                    _shutdownReason = NodeEngineShutdownReason.Error;
+                    _shutdownEvent.Set();
+                }
+            });
+        }
+
+        private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command)
+        {
+            CommunicationsUtilities.Trace("Building with MSBuild server with command line {0}", command.CommandLine);
+            using var serverBusyMutex = ServerNamedMutex.OpenOrCreateMutex(name: _serverBusyMutexName, createdNew: out var holdsMutex);
+            if (!holdsMutex)
+            {
+                // Client must have send request message to server even though serer is busy.
+                // It is not a race condition, as client exclusivity is also guaranteed by name pipe which allows only one client to connect.
+                _shutdownException = new InvalidOperationException("Client requested build while server is busy processing previous client build request.");
+                _shutdownReason = NodeEngineShutdownReason.Error;
+                _shutdownEvent.Set();
+
+                return;
+            }
+
+            // Set build process context
+            Directory.SetCurrentDirectory(command.StartupDirectory);
+            CommunicationsUtilities.SetEnvironment(command.BuildProcessEnvironment);
+            Thread.CurrentThread.CurrentCulture = command.Culture;
+            Thread.CurrentThread.CurrentUICulture = command.UICulture;
+
+            // Configure console configuration so Loggers can change their behavior based on Target (client) Console properties.
+            ConsoleConfiguration.Provider = command.ConsoleConfiguration;
+
+            // Initiate build telemetry
+            if (KnownTelemetry.BuildTelemetry == null)
+            {
+                KnownTelemetry.BuildTelemetry = new BuildTelemetry();
+            }
+            if (command.PartialBuildTelemetry != null)
+            {
+                KnownTelemetry.BuildTelemetry.StartAt = command.PartialBuildTelemetry.StartedAt;
+                KnownTelemetry.BuildTelemetry.InitialServerState = command.PartialBuildTelemetry.InitialServerState;
+                KnownTelemetry.BuildTelemetry.ServerFallbackReason = command.PartialBuildTelemetry.ServerFallbackReason;
+            }
+
+            // Also try our best to increase chance custom Loggers which use Console static members will work as expected.
+            try
+            {
+                if (NativeMethodsShared.IsWindows && command.ConsoleConfiguration.BufferWidth > 0)
+                {
+                    Console.BufferWidth = command.ConsoleConfiguration.BufferWidth;
+                }
+
+                if ((int)command.ConsoleConfiguration.BackgroundColor != -1)
+                {
+                    Console.BackgroundColor = command.ConsoleConfiguration.BackgroundColor;
+                }
+            }
+            catch (Exception)
+            {
+                // Ignore exception, it is best effort only
+            }
+
+            // Configure console output redirection
+            var oldOut = Console.Out;
+            var oldErr = Console.Error;
+            (int exitCode, string exitType) buildResult;
+
+            // Dispose must be called before the server sends ServerNodeBuildResult packet
+            using (var outWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, ConsoleOutput.Standard))))
+            using (var errWriter = RedirectConsoleWriter.Create(text => SendPacket(new ServerNodeConsoleWrite(text, ConsoleOutput.Error))))
+            {
+                Console.SetOut(outWriter);
+                Console.SetError(errWriter);
+
+                buildResult = _buildFunction(command.CommandLine);
+
+                Console.SetOut(oldOut);
+                Console.SetError(oldErr);
+            }
+          
+            // On Windows, a process holds a handle to the current directory,
+            // so reset it away from a user-requested folder that may get deleted.
+            NativeMethodsShared.SetCurrentDirectory(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory);
+
+            _nodeEndpoint.ClientWillDisconnect();
+            var response = new ServerNodeBuildResult(buildResult.exitCode, buildResult.exitType);
+            SendPacket(response);
+
+            _shutdownReason = NodeEngineShutdownReason.BuildCompleteReuse;
+            _shutdownEvent.Set();
+        }
+
+        internal sealed class RedirectConsoleWriter : StringWriter
+        {
+            private readonly Action<string> _writeCallback;
+            private readonly Timer _timer;
+            private readonly TextWriter _syncWriter;
+
+            private RedirectConsoleWriter(Action<string> writeCallback)
+            {
+                _writeCallback = writeCallback;
+                _syncWriter = Synchronized(this);
+                _timer = new Timer(TimerCallback, null, 0, 40);
+            }
+
+            public static TextWriter Create(Action<string> writeCallback)
+            {
+                RedirectConsoleWriter writer = new(writeCallback);
+                return writer._syncWriter;
+            }
+
+            private void TimerCallback(object? state)
+            {
+                if (GetStringBuilder().Length > 0)
+                {
+                    _syncWriter.Flush();
+                }
+            }
+
+            protected override void Dispose(bool disposing)
+            {
+                if (disposing)
+                {
+                    _timer.Dispose();
+                    Flush();
+                }
+
+                base.Dispose(disposing);
+            }
+
+            public override void Flush()
+            {
+                var sb = GetStringBuilder();
+                var captured = sb.ToString();
+                sb.Clear();
+                _writeCallback(captured);
+
+                base.Flush();
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Node/PartialBuildTelemetry.cs b/src/Build/BackEnd/Node/PartialBuildTelemetry.cs
new file mode 100644
index 00000000000..b9960a0e752
--- /dev/null
+++ b/src/Build/BackEnd/Node/PartialBuildTelemetry.cs
@@ -0,0 +1,51 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+
+namespace Microsoft.Build.BackEnd;
+
+/// <summary>
+/// Part of BuildTelemetry which is collected on client and needs to be sent to server,
+/// so server can log BuildTelemetry once it is finished.
+/// </summary>
+internal sealed class PartialBuildTelemetry : ITranslatable
+{
+    private DateTime _startedAt = default;
+    private string? _initialServerState = default;
+    private string? _serverFallbackReason = default;
+
+    public PartialBuildTelemetry(DateTime startedAt, string? initialServerState, string? serverFallbackReason)
+    {
+        _startedAt = startedAt;
+        _initialServerState = initialServerState;
+        _serverFallbackReason = serverFallbackReason;
+    }
+
+    /// <summary>
+    /// Constructor for deserialization
+    /// </summary>
+    private PartialBuildTelemetry()
+    {
+    }
+
+    public DateTime? StartedAt => _startedAt;
+
+    public string? InitialServerState => _initialServerState;
+
+    public string? ServerFallbackReason => _serverFallbackReason;
+
+    public void Translate(ITranslator translator)
+    {
+        translator.Translate(ref _startedAt);
+        translator.Translate(ref _initialServerState);
+        translator.Translate(ref _serverFallbackReason);
+    }
+
+    internal static PartialBuildTelemetry FactoryForDeserialization(ITranslator translator)
+    {
+        PartialBuildTelemetry partialTelemetryData = new();
+        partialTelemetryData.Translate(translator);
+        return partialTelemetryData;
+    }
+}
diff --git a/src/Build/BackEnd/Node/ServerNamedMutex.cs b/src/Build/BackEnd/Node/ServerNamedMutex.cs
new file mode 100644
index 00000000000..ac7244a6cc0
--- /dev/null
+++ b/src/Build/BackEnd/Node/ServerNamedMutex.cs
@@ -0,0 +1,66 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Threading;
+
+namespace Microsoft.Build.Execution
+{
+    internal sealed class ServerNamedMutex : IDisposable
+    {
+        private readonly Mutex _serverMutex;
+
+        public bool IsDisposed { get; private set; }
+
+        public bool IsLocked { get; private set; }
+
+        public ServerNamedMutex(string mutexName, out bool createdNew)
+        {
+            _serverMutex = new Mutex(
+                initiallyOwned: true,
+                name: mutexName,
+                createdNew: out createdNew);
+
+            if (createdNew)
+            {
+                IsLocked = true;
+            }
+        }
+
+        internal static ServerNamedMutex OpenOrCreateMutex(string name, out bool createdNew)
+        {
+            return new ServerNamedMutex(name, out createdNew);
+        }
+
+        public static bool WasOpen(string mutexName)
+        {
+            bool result = Mutex.TryOpenExisting(mutexName, out Mutex? mutex);
+            mutex?.Dispose();
+
+            return result;
+        }
+
+        public void Dispose()
+        {
+            if (IsDisposed)
+            {
+                return;
+            }
+
+            IsDisposed = true;
+
+            try
+            {
+                if (IsLocked)
+                {
+                    _serverMutex.ReleaseMutex();
+                }
+            }
+            finally
+            {
+                _serverMutex.Dispose();
+                IsLocked = false;
+            }
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Node/ServerNodeBuildCancel.cs b/src/Build/BackEnd/Node/ServerNodeBuildCancel.cs
new file mode 100644
index 00000000000..67cd7f0df7f
--- /dev/null
+++ b/src/Build/BackEnd/Node/ServerNodeBuildCancel.cs
@@ -0,0 +1,19 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.BackEnd
+{
+    internal sealed class ServerNodeBuildCancel : INodePacket
+    { 
+        public NodePacketType Type => NodePacketType.ServerNodeBuildCancel;
+
+        public void Translate(ITranslator translator)
+        {
+        }
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            return new ServerNodeBuildCancel();
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Node/ServerNodeBuildCommand.cs b/src/Build/BackEnd/Node/ServerNodeBuildCommand.cs
new file mode 100644
index 00000000000..ee8bd565d25
--- /dev/null
+++ b/src/Build/BackEnd/Node/ServerNodeBuildCommand.cs
@@ -0,0 +1,130 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Collections.Generic;
+using System.Globalization;
+using Microsoft.Build.BackEnd.Logging;
+using Microsoft.Build.Shared;
+
+namespace Microsoft.Build.BackEnd
+{
+    /// <summary>
+    /// Contains all of the information necessary for a entry node to run a command line.
+    /// </summary>
+    internal sealed class ServerNodeBuildCommand : INodePacket
+    {
+#if FEATURE_GET_COMMANDLINE
+        private string _commandLine = default!;
+#else
+        private string[] _commandLine = default!;
+#endif
+        private string _startupDirectory = default!;
+        private Dictionary<string, string> _buildProcessEnvironment = default!;
+        private CultureInfo _culture = default!;
+        private CultureInfo _uiCulture = default!;
+        private TargetConsoleConfiguration _consoleConfiguration = default!;
+        private PartialBuildTelemetry? _partialBuildTelemetry = default;
+
+        /// <summary>
+        /// Retrieves the packet type.
+        /// </summary>
+        public NodePacketType Type => NodePacketType.ServerNodeBuildCommand;
+
+        /// <summary>
+        /// Command line including arguments
+        /// </summary>
+#if FEATURE_GET_COMMANDLINE
+        public string CommandLine => _commandLine;
+#else
+        public string[] CommandLine => _commandLine;
+#endif
+
+        /// <summary>
+        /// The startup directory
+        /// </summary>
+        public string StartupDirectory => _startupDirectory;
+
+        /// <summary>
+        /// The process environment.
+        /// </summary>
+        public Dictionary<string, string> BuildProcessEnvironment => _buildProcessEnvironment;
+
+        /// <summary>
+        /// The culture
+        /// </summary>
+        public CultureInfo Culture => _culture;
+
+        /// <summary>
+        /// The UI culture.
+        /// </summary>
+        public CultureInfo UICulture => _uiCulture;
+
+        /// <summary>
+        /// Console configuration of Client.
+        /// </summary>
+        public TargetConsoleConfiguration ConsoleConfiguration => _consoleConfiguration;
+
+        /// <summary>
+        /// Part of BuildTelemetry which is collected on client and needs to be sent to server,
+        /// so server can log BuildTelemetry once it is finished.
+        /// </summary>
+        public PartialBuildTelemetry? PartialBuildTelemetry => _partialBuildTelemetry;
+
+        /// <summary>
+        /// Private constructor for deserialization
+        /// </summary>
+        private ServerNodeBuildCommand()
+        {
+        }
+
+        public ServerNodeBuildCommand(
+#if FEATURE_GET_COMMANDLINE
+            string commandLine,
+#else
+            string[] commandLine,
+#endif
+            string startupDirectory,
+            Dictionary<string, string> buildProcessEnvironment,
+            CultureInfo culture, CultureInfo uiCulture,
+            TargetConsoleConfiguration consoleConfiguration,
+            PartialBuildTelemetry? partialBuildTelemetry)
+        {
+            ErrorUtilities.VerifyThrowInternalNull(consoleConfiguration, nameof(consoleConfiguration));
+
+            _commandLine = commandLine;
+            _startupDirectory = startupDirectory;
+            _buildProcessEnvironment = buildProcessEnvironment;
+            _culture = culture;
+            _uiCulture = uiCulture;
+            _consoleConfiguration = consoleConfiguration;
+            _partialBuildTelemetry = partialBuildTelemetry;
+        }
+
+        /// <summary>
+        /// Translates the packet to/from binary form.
+        /// </summary>
+        /// <param name="translator">The translator to use.</param>
+        public void Translate(ITranslator translator)
+        {
+            translator.Translate(ref _commandLine);
+            translator.Translate(ref _startupDirectory);
+            translator.TranslateDictionary(ref _buildProcessEnvironment, StringComparer.OrdinalIgnoreCase);
+            translator.TranslateCulture(ref _culture);
+            translator.TranslateCulture(ref _uiCulture);
+            translator.Translate(ref _consoleConfiguration, TargetConsoleConfiguration.FactoryForDeserialization);
+            translator.Translate(ref _partialBuildTelemetry, PartialBuildTelemetry.FactoryForDeserialization);
+        }
+
+        /// <summary>
+        /// Factory for deserialization.
+        /// </summary>
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            ServerNodeBuildCommand command = new();
+            command.Translate(translator);
+
+            return command;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Node/ServerNodeBuildResult.cs b/src/Build/BackEnd/Node/ServerNodeBuildResult.cs
new file mode 100644
index 00000000000..4ea012ebafd
--- /dev/null
+++ b/src/Build/BackEnd/Node/ServerNodeBuildResult.cs
@@ -0,0 +1,49 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.BackEnd
+{
+    internal sealed class ServerNodeBuildResult : INodePacket
+    {
+        private int _exitCode = default!;
+        private string _exitType = default!;
+
+        /// <summary>
+        /// Packet type.
+        /// This has to be in sync with <see cref="NodePacketType.ServerNodeBuildResult" />
+        /// </summary>
+        public NodePacketType Type => NodePacketType.ServerNodeBuildResult;
+
+        public int ExitCode => _exitCode;
+
+        public string ExitType => _exitType;
+
+        /// <summary>
+        /// Private constructor for deserialization
+        /// </summary>
+        private ServerNodeBuildResult() { }
+
+        public ServerNodeBuildResult(int exitCode, string exitType)
+        {
+            _exitCode = exitCode;
+            _exitType = exitType;
+        }
+
+        public void Translate(ITranslator translator)
+        {
+            translator.Translate(ref _exitCode);
+            translator.Translate(ref _exitType);
+        }
+
+        /// <summary>
+        /// Factory for deserialization.
+        /// </summary>
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            ServerNodeBuildResult command = new();
+            command.Translate(translator);
+
+            return command;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Node/ServerNodeConsoleWrite.cs b/src/Build/BackEnd/Node/ServerNodeConsoleWrite.cs
new file mode 100644
index 00000000000..da3f8473905
--- /dev/null
+++ b/src/Build/BackEnd/Node/ServerNodeConsoleWrite.cs
@@ -0,0 +1,48 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.BackEnd
+{
+    internal sealed class ServerNodeConsoleWrite : INodePacket
+    {
+        private string _text = default!;
+        private ConsoleOutput _outputType = default!;
+
+        /// <summary>
+        /// Packet type.
+        /// </summary>
+        public NodePacketType Type => NodePacketType.ServerNodeConsoleWrite;
+
+        public string Text => _text;
+
+        /// <summary>
+        /// Console output for the message
+        /// </summary>
+        public ConsoleOutput OutputType => _outputType;
+
+        /// <summary>
+        /// Private constructor for deserialization
+        /// </summary>
+        private ServerNodeConsoleWrite() { }
+
+        public ServerNodeConsoleWrite(string text, ConsoleOutput outputType)
+        {
+            _text = text;
+            _outputType = outputType;
+        }
+
+        public void Translate(ITranslator translator)
+        {
+            translator.Translate(ref _text);
+            translator.TranslateEnum(ref _outputType, (int)_outputType);
+        }
+
+        internal static INodePacket FactoryForDeserialization(ITranslator translator)
+        {
+            ServerNodeConsoleWrite command = new();
+            command.Translate(translator);
+
+            return command;
+        }
+    }
+}
diff --git a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
index 83b3218f3fe..8f951bbcab3 100644
--- a/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
+++ b/src/Build/BackEnd/Shared/ConfigurationMetadata.cs
@@ -58,12 +58,6 @@ public ConfigurationMetadata(string projectFullPath, PropertyDictionary<ProjectP
             _toolsVersion = MSBuildConstants.CurrentToolsVersion;
             _globalProperties = globalProperties;
         }
-        public ConfigurationMetadata(string projectFullPath, PropertyDictionary<ProjectPropertyInstance> globalProperties, string previousPlatform, string previousPlatformLookupTable, bool isSetPlatformHardCoded) : this(projectFullPath, globalProperties)
-        {
-            PreviousPlatform = previousPlatform;
-            PreviousPlatformLookupTable = previousPlatformLookupTable;
-            IsSetPlatformHardCoded = isSetPlatformHardCoded;
-        }
 
         public ConfigurationMetadata(ITranslator translator)
         {
@@ -87,11 +81,6 @@ public ConfigurationMetadata(ITranslator translator)
         /// </summary>
         public string ToolsVersion => _toolsVersion;
 
-        public string PreviousPlatform { get; } = "";
-
-        public string PreviousPlatformLookupTable { get; } = "";
-        public bool IsSetPlatformHardCoded { get; } = false;
-
         private PropertyDictionary<ProjectPropertyInstance> _globalProperties;
 
         /// <summary>
@@ -175,12 +164,9 @@ private bool InternalEquals(ConfigurationMetadata other)
             {
                 return true;
             }
-
             return ProjectFullPath.Equals(other.ProjectFullPath, StringComparison.OrdinalIgnoreCase) &&
-                   ToolsVersion.Equals(other.ToolsVersion, StringComparison.OrdinalIgnoreCase) &&
-                   GlobalProperties.Equals(other.GlobalProperties) &&
-                   PreviousPlatform.Equals(other.PreviousPlatform, StringComparison.OrdinalIgnoreCase) &&
-                   PreviousPlatformLookupTable.Equals(other.PreviousPlatformLookupTable, StringComparison.OrdinalIgnoreCase);
+                ToolsVersion.Equals(other.ToolsVersion, StringComparison.OrdinalIgnoreCase) &&
+                GlobalProperties.Equals(other.GlobalProperties);
         }
 
         private string DebugString()
diff --git a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
index bfbe4b83f41..6bbeea098dc 100644
--- a/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
+++ b/src/Build/BackEnd/TaskExecutionHost/TaskExecutionHost.cs
@@ -23,6 +23,7 @@
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
 using Task = System.Threading.Tasks.Task;
+using System.Linq;
 
 #nullable disable
 
@@ -256,12 +257,12 @@ void ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggi
 
             TaskRequirements requirements = TaskRequirements.None;
 
-            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute())
+            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasSTAThreadAttribute)
             {
                 requirements |= TaskRequirements.RequireSTAThread;
             }
 
-            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute())
+            if (_taskFactoryWrapper.TaskFactoryLoadedType.HasLoadInSeparateAppDomainAttribute)
             {
                 requirements |= TaskRequirements.RequireSeparateAppDomain;
 
@@ -399,6 +400,14 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
             try
             {
                 TaskPropertyInfo parameter = _taskFactoryWrapper.GetProperty(parameterName);
+                foreach (TaskPropertyInfo prop in _taskFactoryWrapper.TaskFactoryLoadedType.Properties)
+                {
+                    if (prop.Name.Equals(parameterName, StringComparison.OrdinalIgnoreCase))
+                    {
+                        parameter = prop;
+                        break;
+                    }
+                }
 
                 // flag an error if we find a parameter that has no .NET property equivalent
                 ProjectErrorUtilities.VerifyThrowInvalidProject
@@ -420,17 +429,14 @@ bool ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation
                     _taskName
                 );
 
-                // grab the outputs from the task's designated output parameter (which is a .NET property)
-                Type type = parameter.PropertyType;
-
                 EnsureParameterInitialized(parameter, _batchBucket.Lookup);
 
-                if (TaskParameterTypeVerifier.IsAssignableToITask(type))
+                if (parameter.IsAssignableToITask)
                 {
                     ITaskItem[] outputs = GetItemOutputs(parameter);
                     GatherTaskItemOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation, parameter);
                 }
-                else if (TaskParameterTypeVerifier.IsValueTypeOutputParameter(type))
+                else if (parameter.IsValueTypeOutputParameter)
                 {
                     string[] outputs = GetValueOutputs(parameter);
                     GatherArrayStringAndValueOutputs(outputTargetIsItem, outputTargetName, outputs, parameterLocation, parameter);
@@ -897,12 +903,14 @@ private TaskFactoryWrapper FindTaskInRegistry(IDictionary<string, string> taskId
                 // Map to an intrinsic task, if necessary.
                 if (String.Equals(returnClass.TaskFactory.TaskType.FullName, "Microsoft.Build.Tasks.MSBuild", StringComparison.OrdinalIgnoreCase))
                 {
-                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(MSBuild)), new LoadedType(typeof(MSBuild), AssemblyLoadInfo.Create(typeof(TaskExecutionHost).GetTypeInfo().Assembly.FullName, null)), _taskName, null);
+                    Assembly taskExecutionHostAssembly = typeof(TaskExecutionHost).GetTypeInfo().Assembly;
+                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(MSBuild)), new LoadedType(typeof(MSBuild), AssemblyLoadInfo.Create(taskExecutionHostAssembly.FullName, null), taskExecutionHostAssembly, typeof(ITaskItem)), _taskName, null);
                     _intrinsicTasks[_taskName] = returnClass;
                 }
                 else if (String.Equals(returnClass.TaskFactory.TaskType.FullName, "Microsoft.Build.Tasks.CallTarget", StringComparison.OrdinalIgnoreCase))
                 {
-                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(CallTarget)), new LoadedType(typeof(CallTarget), AssemblyLoadInfo.Create(typeof(TaskExecutionHost).GetTypeInfo().Assembly.FullName, null)), _taskName, null);
+                    Assembly taskExecutionHostAssembly = typeof(TaskExecutionHost).GetTypeInfo().Assembly;
+                    returnClass = new TaskFactoryWrapper(new IntrinsicTaskFactory(typeof(CallTarget)), new LoadedType(typeof(CallTarget), AssemblyLoadInfo.Create(taskExecutionHostAssembly.FullName, null), taskExecutionHostAssembly, typeof(ITaskItem)), _taskName, null);
                     _intrinsicTasks[_taskName] = returnClass;
                 }
             }
@@ -1008,12 +1016,43 @@ out bool parameterSet
             try
             {
                 // check if the task has a .NET property corresponding to the parameter
-                TaskPropertyInfo parameter = _taskFactoryWrapper.GetProperty(parameterName);
+                LoadedType loadedType = _taskFactoryWrapper.TaskFactoryLoadedType;
+                int indexOfParameter = -1;
+                for (int i = 0; i < loadedType.Properties.Length; i++)
+                {
+                    if (loadedType.Properties[i].Name.Equals(parameterName))
+                    {
+                        indexOfParameter = i;
+                        break;
+                    }
+                }
 
-                if (parameter != null)
+                // For most tasks, finding the parameter in our list of known properties is equivalent to
+                // saying the task was properly invoked, as far as this parameter is concerned. However,
+                // that is not true for CodeTaskFactories like RoslynCodeTaskFactory. In that case, they
+                // will often have a list of parameters under the UsingTask declaration. Fortunately, if
+                // your TaskFactory is RoslynCodeTaskFactory, it isn't TaskHostFactory, which means the
+                // types are fully loaded at this stage, and we can access them as we had in the past.
+                TaskPropertyInfo parameter = null;
+                Type parameterType = null;
+                if (indexOfParameter != -1)
+                {
+                    parameter = loadedType.Properties[indexOfParameter];
+                    parameterType = Type.GetType(
+                        loadedType.PropertyAssemblyQualifiedNames?[indexOfParameter] ??
+                        parameter.PropertyType.AssemblyQualifiedName);
+                }
+                else
                 {
-                    Type parameterType = parameter.PropertyType;
+                    parameter = _taskFactoryWrapper.GetProperty(parameterName);
+                    if (parameter != null)
+                    {
+                        parameterType = Type.GetType(parameter.PropertyType.AssemblyQualifiedName);
+                    }
+                }
 
+                if (parameter != null)
+                {
                     EnsureParameterInitialized(parameter, _batchBucket.Lookup);
 
                     // try to set the parameter
@@ -1068,30 +1107,15 @@ out parameterSet
                 else
                 {
                     // flag an error if we find a parameter that has no .NET property equivalent
-                    if (_taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly is null)
-                    {
-                        _taskLoggingContext.LogError
-                            (
-                            new BuildEventFileInfo( parameterLocation ),
-                            "UnexpectedTaskAttribute",
-                            parameterName,
-                            _taskName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.Type.Assembly.FullName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.Type.Assembly.Location
-                            );
-                    }
-                    else
-                    {
-                        _taskLoggingContext.LogError
-                            (
-                            new BuildEventFileInfo( parameterLocation ),
-                            "UnexpectedTaskAttribute",
-                            parameterName,
-                            _taskName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly.FullName,
-                            _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssembly.Location
-                            );
-                    }
+                    _taskLoggingContext.LogError
+                        (
+                        new BuildEventFileInfo( parameterLocation ),
+                        "UnexpectedTaskAttribute",
+                        parameterName,
+                        _taskName,
+                        _taskFactoryWrapper.TaskFactoryLoadedType.LoadedAssemblyName.FullName,
+                        _taskFactoryWrapper.TaskFactoryLoadedType.Path
+                        );
                 }
             }
             catch (AmbiguousMatchException)
@@ -1174,7 +1198,7 @@ out bool taskParameterSet
                 else
                 {
                     // Expand out all the metadata, properties, and item vectors in the string.
-                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation, _targetLoggingContext);
+                    string expandedParameterValue = _batchBucket.Expander.ExpandIntoStringAndUnescape(parameterValue, ExpanderOptions.ExpandAll, parameterLocation);
 
                     if (expandedParameterValue.Length == 0)
                     {
diff --git a/src/Build/Construction/Solution/SolutionProjectGenerator.cs b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
index f29666fd7a3..221c938e941 100644
--- a/src/Build/Construction/Solution/SolutionProjectGenerator.cs
+++ b/src/Build/Construction/Solution/SolutionProjectGenerator.cs
@@ -69,6 +69,11 @@ internal class SolutionProjectGenerator
         /// </summary>
         private const string SolutionConfigurationAndPlatformProperties = "Configuration=$(Configuration); Platform=$(Platform)";
 
+        /// <summary>
+        /// The Special Target name which when <see cref="_batchProjectTargets"/> is enabled, all P2P references will just execute this target.
+        /// </summary>
+        internal const string SolutionProjectReferenceAllTargets = "SlnProjectResolveProjectReference";
+
         /// <summary>
         /// A known list of target names to create.  This is for backwards compatibility.
         /// </summary>
@@ -156,6 +161,11 @@ internal class SolutionProjectGenerator
         /// </summary>
         private readonly int _submissionId;
 
+        /// <summary>
+        /// Create a solution metaproj with one MSBuild task with all project references.
+        /// </summary>
+        private readonly bool _batchProjectTargets;
+
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -176,6 +186,7 @@ private SolutionProjectGenerator(
             _loggingService = loggingService;
             _sdkResolverService = sdkResolverService ?? SdkResolverService.Instance;
             _submissionId = submissionId;
+            _batchProjectTargets = Traits.Instance.SolutionBatchTargets;
 
             if (targetNames != null)
             {
@@ -758,6 +769,24 @@ private ProjectInstance[] CreateSolutionProject(string wrapperProjectToolsVersio
             // Now evaluate all of the projects in the solution and handle them appropriately.
             EvaluateAndAddProjects(projectsInOrder, projectInstances, traversalInstance, _selectedSolutionConfiguration);
 
+            if (_batchProjectTargets)
+            {
+                var targetElement = traversalInstance.AddTarget(
+                    SolutionProjectReferenceAllTargets,
+                    string.Empty,
+                    string.Empty,
+                    string.Empty,
+                    null,
+                    string.Empty,
+                    string.Empty,
+                    string.Empty,
+                    string.Empty,
+                    false);
+
+                // Add global project reference
+                AddProjectBuildTask(traversalInstance, null, targetElement, string.Join(";", _targetNames), "@(ProjectReference)", string.Empty, string.Empty);
+            }
+
             // Special environment variable to allow people to see the in-memory MSBuild project generated
             // to represent the SLN.
             foreach (ProjectInstance instance in projectInstances)
@@ -814,7 +843,7 @@ private void EvaluateAndAddProjects(List<ProjectInSolution> projectsInOrder, Lis
             // Add any other targets specified by the user that were not already added
             foreach (string targetName in _targetNames.Where(i => !traversalInstance.Targets.ContainsKey(i)))
             {
-                AddTraversalReferencesTarget(traversalInstance, targetName, null);
+                AddTraversalReferencesTarget(traversalInstance, targetName, null, _batchProjectTargets);
             }
         }
 
@@ -827,10 +856,10 @@ private void AddStandardTraversalTargets(ProjectInstance traversalInstance, List
             AddInitialTargets(traversalInstance, projectsInOrder);
 
             // Add the targets to traverse the metaprojects.
-            AddTraversalReferencesTarget(traversalInstance, null, "CollectedBuildOutput");
-            AddTraversalReferencesTarget(traversalInstance, "Clean", null);
-            AddTraversalReferencesTarget(traversalInstance, "Rebuild", "CollectedBuildOutput");
-            AddTraversalReferencesTarget(traversalInstance, "Publish", null);
+            AddTraversalReferencesTarget(traversalInstance, null, "CollectedBuildOutput", _batchProjectTargets);
+            AddTraversalReferencesTarget(traversalInstance, "Clean", null, _batchProjectTargets);
+            AddTraversalReferencesTarget(traversalInstance, "Rebuild", "CollectedBuildOutput", _batchProjectTargets);
+            AddTraversalReferencesTarget(traversalInstance, "Publish", null, _batchProjectTargets);
         }
 
         /// <summary>
@@ -1353,9 +1382,17 @@ private static void AddProjectBuildTask(ProjectInstance traversalProject, Projec
             task.SetParameter("BuildInParallel", "True");
 
             task.SetParameter("ToolsVersion", GetToolsVersionAttributeForDirectMSBuildTask());
-            task.SetParameter("Properties", GetPropertiesAttributeForDirectMSBuildTask(projectConfiguration));
 
-            if (outputItem != null)
+            if (projectConfiguration != null)
+            {
+                task.SetParameter("Properties", GetPropertiesAttributeForDirectMSBuildTask(projectConfiguration));
+            }
+            else
+            {
+                task.SetParameter("Properties", SolutionProperties);
+            }
+
+            if (!string.IsNullOrEmpty(outputItem))
             {
                 task.AddOutputItem("TargetOutputs", outputItem, String.Empty);
             }
@@ -1377,7 +1414,6 @@ private void AddMetaprojectBuildTask(ProjectInSolution project, ProjectTargetIns
             task.SetParameter("BuildInParallel", "True");
             task.SetParameter("ToolsVersion", "Current");
             task.SetParameter("Properties", SolutionProperties);
-            task.SetParameter("SkipNonexistentProjects", "%(ProjectReference.SkipNonexistentProjects)");
 
             if (outputItem != null)
             {
@@ -1982,7 +2018,7 @@ private void AddValidateProjectsTarget(ProjectInstance traversalProject, List<Pr
         /// <summary>
         /// Creates the target used to build all of the references in the traversal project.
         /// </summary>
-        private static void AddTraversalReferencesTarget(ProjectInstance traversalProject, string targetName, string outputItem)
+        private static void AddTraversalReferencesTarget(ProjectInstance traversalProject, string targetName, string outputItem, bool batchBuildTargets)
         {
             string outputItemAsItem = null;
             if (!String.IsNullOrEmpty(outputItem))
@@ -1993,8 +2029,13 @@ private static void AddTraversalReferencesTarget(ProjectInstance traversalProjec
             string correctedTargetName = targetName ?? "Build";
 
             traversalProject.RemoveTarget(correctedTargetName);
-            ProjectTargetInstance target = traversalProject.AddTarget(correctedTargetName, string.Empty, string.Empty, outputItemAsItem, null, string.Empty, string.Empty, string.Empty, string.Empty, false /* legacy target returns behaviour */);
-            AddReferencesBuildTask(target, targetName, outputItem);
+            string dependOnTargets = batchBuildTargets ? SolutionProjectReferenceAllTargets : string.Empty;
+            ProjectTargetInstance target = traversalProject.AddTarget(correctedTargetName, string.Empty, string.Empty, outputItemAsItem, null, string.Empty, dependOnTargets, string.Empty, string.Empty, false /* legacy target returns behaviour */);
+
+            if (!batchBuildTargets)
+            {
+                AddReferencesBuildTask(target, targetName, outputItem);
+            }
         }
 
         /// <summary>
@@ -2020,10 +2061,6 @@ private static void AddReferencesBuildTask(ProjectTargetInstance target, string
             task.SetParameter("BuildInParallel", "True");
             task.SetParameter("Properties", SolutionProperties);
 
-            // We only want to build "nonexistent" projects if we're building metaprojects, since they don't exist on disk.  Otherwise, 
-            // we still want to error when the referenced project doesn't exist.  
-            task.SetParameter("SkipNonexistentProjects", "%(ProjectReference.SkipNonexistentProjects)");
-
             if (outputItem != null)
             {
                 task.AddOutputItem("TargetOutputs", outputItem, String.Empty);
diff --git a/src/Build/Definition/Project.cs b/src/Build/Definition/Project.cs
index 294b523e07e..6fb05e271d0 100644
--- a/src/Build/Definition/Project.cs
+++ b/src/Build/Definition/Project.cs
@@ -2924,7 +2924,7 @@ public override bool SetGlobalProperty(string name, string escapedValue)
                     string originalValue = (existing == null) ? String.Empty : ((IProperty)existing).EvaluatedValueEscaped;
 
                     _data.GlobalPropertiesDictionary.Set(ProjectPropertyInstance.Create(name, escapedValue));
-                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, isGlobalProperty: true, mayBeReserved: false, loggingContext: null));
+                    _data.Properties.Set(ProjectProperty.Create(Owner, name, escapedValue, true /* is global */, false /* may not be reserved name */));
 
                     ProjectCollection.AfterUpdateLoadedProjectGlobalProperties(Owner);
                     MarkDirty();
@@ -4394,9 +4394,9 @@ public IItemDefinition<ProjectMetadata> GetItemDefinition(string itemType)
             /// <summary>
             /// Sets a property which is not derived from Xml.
             /// </summary>
-            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
+            public ProjectProperty SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
             {
-                ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext);
+                ProjectProperty property = ProjectProperty.Create(Project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
                 Properties.Set(property);
 
                 AddToAllEvaluatedPropertiesList(property);
diff --git a/src/Build/Definition/ProjectCollection.cs b/src/Build/Definition/ProjectCollection.cs
index 32f9b37fe68..240fbd0d77f 100644
--- a/src/Build/Definition/ProjectCollection.cs
+++ b/src/Build/Definition/ProjectCollection.cs
@@ -82,47 +82,16 @@ public enum ToolsetDefinitionLocations
     [SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix", Justification = "This is a collection of projects API review has approved this")]
     public class ProjectCollection : IToolsetProvider, IBuildComponent, IDisposable
     {
-        // ProjectCollection is highly reentrant - project creation, toolset and logger changes, and so on
-        // all need lock protection, but there are a lot of read cases as well, and calls to create Projects
-        // call back to the ProjectCollection under locks. Use a RW lock, but default to always using
-        // upgradable read locks to avoid adding reentrancy bugs.
-        private class DisposableReaderWriterLockSlim
-        {
-            private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);
-            public bool IsWriteLockHeld => _lock.IsWriteLockHeld;
-
-            public IDisposable EnterUpgradeableReadLock()
-            {
-                _lock.EnterUpgradeableReadLock();
-                return new DelegateDisposable(() => _lock.ExitUpgradeableReadLock());
-            }
-
-            public IDisposable EnterWriteLock()
-            {
-                _lock.EnterWriteLock();
-                return new DelegateDisposable(() => _lock.ExitWriteLock());
-            }
-        }
-
-        private class DelegateDisposable : IDisposable
-        {
-            private readonly Action _disposeAction;
-
-            public DelegateDisposable(Action disposeAction)
-            {
-                _disposeAction = disposeAction;
-            }
-
-            public void Dispose()
-            {
-                _disposeAction();
-            }
-        }
-
         /// <summary>
         /// The object to synchronize with when accessing certain fields.
         /// </summary>
-        private readonly DisposableReaderWriterLockSlim _locker = new DisposableReaderWriterLockSlim();
+        /// <remarks>
+        /// ProjectCollection is highly reentrant - project creation, toolset and logger changes, and so on
+        /// all need lock protection, but there are a lot of read cases as well, and calls to create Projects
+        /// call back to the ProjectCollection under locks. Use a RW lock, but default to always using
+        /// upgradable read locks to avoid adding reentrancy bugs.
+        /// </remarks>
+        private readonly ReaderWriterLockSlim _locker = new ReaderWriterLockSlim(LockRecursionPolicy.SupportsRecursion);
 
         /// <summary>
         /// The global singleton project collection used as a default for otherwise
@@ -145,6 +114,8 @@ public void Dispose()
         /// </summary>
         private static string s_assemblyDisplayVersion;
 
+        private static ProjectRootElementCacheBase s_projectRootElementCache = null;
+
         /// <summary>
         /// The projects loaded into this collection.
         /// </summary>
@@ -308,7 +279,7 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab
         /// <param name="onlyLogCriticalEvents">If set to true, only critical events will be logged.</param>
         /// <param name="loadProjectsReadOnly">If set to true, load all projects as read-only.</param>
         public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly)
-            : this(globalProperties, loggers, remoteLoggers, toolsetDefinitionLocations, maxNodeCount, onlyLogCriticalEvents, loadProjectsReadOnly, useAsynchronousLogging: false)
+            : this(globalProperties, loggers, remoteLoggers, toolsetDefinitionLocations, maxNodeCount, onlyLogCriticalEvents, loadProjectsReadOnly, useAsynchronousLogging: false, reuseProjectRootElementCache: false)
         {
         }
 
@@ -328,7 +299,8 @@ public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerab
         /// <param name="onlyLogCriticalEvents">If set to true, only critical events will be logged.</param>
         /// <param name="loadProjectsReadOnly">If set to true, load all projects as read-only.</param>
         /// <param name="useAsynchronousLogging">If set to true, asynchronous logging will be used. <see cref="ProjectCollection.Dispose()"/> has to called to clear resources used by async logging.</param>
-        internal ProjectCollection(IDictionary<string, string> globalProperties, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging)
+        /// <param name="reuseProjectRootElementCache">If set to true, it will try to reuse <see cref="ProjectRootElementCacheBase"/> singleton.</param>
+        public ProjectCollection(IDictionary<string, string> globalProperties, IEnumerable<ILogger> loggers, IEnumerable<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging, bool reuseProjectRootElementCache)
         {
             _loadedProjects = new LoadedProjectCollection();
             ToolsetLocations = toolsetDefinitionLocations;
@@ -338,10 +310,23 @@ internal ProjectCollection(IDictionary<string, string> globalProperties, IEnumer
             {
                 ProjectRootElementCache = new SimpleProjectRootElementCache();
             }
+            else if (reuseProjectRootElementCache && s_projectRootElementCache != null)
+            {
+                ProjectRootElementCache = s_projectRootElementCache;
+            }
             else
             {
-                ProjectRootElementCache = new ProjectRootElementCache(autoReloadFromDisk: false, loadProjectsReadOnly);
+                // When we are reusing ProjectRootElementCache we need to reload XMLs if it has changed between MSBuild Server sessions/builds.
+                // If we are not reusing, cache will be released at end of build and as we do not support project files will changes during build
+                // we do not need to auto reload.
+                bool autoReloadFromDisk = reuseProjectRootElementCache;
+                ProjectRootElementCache = new ProjectRootElementCache(autoReloadFromDisk, loadProjectsReadOnly);
+                if (reuseProjectRootElementCache)
+                {
+                    s_projectRootElementCache = ProjectRootElementCache;
+                }
             }
+
             OnlyLogCriticalEvents = onlyLogCriticalEvents;
 
             try
@@ -447,7 +432,7 @@ public static ProjectCollection GlobalProjectCollection
                     // Take care to ensure that there is never more than one value observed
                     // from this property even in the case of race conditions while lazily initializing.
                     var local = new ProjectCollection(null, null, null, ToolsetDefinitionLocations.Default,
-                        maxNodeCount: 1, onlyLogCriticalEvents: false, loadProjectsReadOnly: false, useAsynchronousLogging: true);
+                        maxNodeCount: 1, onlyLogCriticalEvents: false, loadProjectsReadOnly: false, useAsynchronousLogging: true, reuseProjectRootElementCache: false);
 
                     if (Interlocked.CompareExchange(ref s_globalProjectCollection, local, null) != null)
                     {
@@ -524,7 +509,7 @@ public string DefaultToolsVersion
         {
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     ErrorUtilities.VerifyThrow(_defaultToolsVersion != null, "Should have a default");
                     return _defaultToolsVersion;
@@ -536,7 +521,7 @@ public string DefaultToolsVersion
                 ErrorUtilities.VerifyThrowArgumentLength(value, nameof(DefaultToolsVersion));
 
                 bool sendEvent = false;
-                using (_locker.EnterWriteLock())
+                using (_locker.EnterDisposableWriteLock())
                 {
                     if (!_toolsets.ContainsKey(value))
                     {
@@ -574,7 +559,7 @@ public IDictionary<string, string> GlobalProperties
             {
                 Dictionary<string, string> dictionary;
 
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     if (_globalProperties.Count == 0)
                     {
@@ -607,7 +592,7 @@ public int Count
         {
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     return _loadedProjects.Count;
                 }
@@ -625,7 +610,7 @@ public ICollection<ILogger> Loggers
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     return _loggingService.Loggers == null
                         ? (ICollection<ILogger>) ReadOnlyEmptyCollection<ILogger>.Instance
@@ -644,7 +629,7 @@ public ICollection<Toolset> Toolsets
         {
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     return new List<Toolset>(_toolsets.Values);
                 }
@@ -666,7 +651,7 @@ public bool IsBuildEnabled
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     return _isBuildEnabled;
                 }
@@ -676,7 +661,7 @@ public bool IsBuildEnabled
             set
             {
                 bool sendEvent = false;
-                using (_locker.EnterWriteLock())
+                using (_locker.EnterDisposableWriteLock())
                 {
                     if (_isBuildEnabled != value)
                     {
@@ -699,7 +684,7 @@ public bool OnlyLogCriticalEvents
         {
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     return _onlyLogCriticalEvents;
                 }
@@ -708,7 +693,7 @@ public bool OnlyLogCriticalEvents
             set
             {
                 bool sendEvent = false;
-                using (_locker.EnterWriteLock())
+                using (_locker.EnterDisposableWriteLock())
                 {
                     if (_onlyLogCriticalEvents != value)
                     {
@@ -736,14 +721,14 @@ public HostServices HostServices
             get
             {
                 // Avoid write lock if possible, this getter is called a lot during Project construction.
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     if (_hostServices != null)
                     {
                         return _hostServices;
                     }
 
-                    using (_locker.EnterWriteLock())
+                    using (_locker.EnterDisposableWriteLock())
                     {
                         return _hostServices ?? (_hostServices = new HostServices());
                     }
@@ -753,7 +738,7 @@ public HostServices HostServices
             set
             {
                 bool sendEvent = false;
-                using (_locker.EnterWriteLock())
+                using (_locker.EnterDisposableWriteLock())
                 {
                     if (_hostServices != value)
                     {
@@ -779,7 +764,7 @@ public bool SkipEvaluation
         {
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     return _skipEvaluation;
                 }
@@ -788,7 +773,7 @@ public bool SkipEvaluation
             set
             {
                 bool sendEvent = false;
-                using (_locker.EnterWriteLock())
+                using (_locker.EnterDisposableWriteLock())
                 {
                     if (_skipEvaluation != value)
                     {
@@ -815,7 +800,7 @@ public bool DisableMarkDirty
         {
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     return _disableMarkDirty;
                 }
@@ -824,7 +809,7 @@ public bool DisableMarkDirty
             set
             {
                 bool sendEvent = false;
-                using (_locker.EnterWriteLock())
+                using (_locker.EnterDisposableWriteLock())
                 {
                     if (_disableMarkDirty != value)
                     {
@@ -865,7 +850,7 @@ internal ILoggingService LoggingService
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     return _loggingService;
                 }
@@ -883,7 +868,7 @@ internal PropertyDictionary<ProjectPropertyInstance> GlobalPropertiesCollection
             {
                 var clone = new PropertyDictionary<ProjectPropertyInstance>();
 
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     foreach (ProjectPropertyInstance property in _globalProperties)
                     {
@@ -902,7 +887,7 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
         {
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     // Retrieves the environment properties.
                     // This is only done once, when the project collection is created. Any subsequent
@@ -910,7 +895,7 @@ internal PropertyDictionary<ProjectPropertyInstance> EnvironmentProperties
                     // of properties in their build parameters.
                     if (_environmentProperties == null)
                     {
-                        using (_locker.EnterWriteLock())
+                        using (_locker.EnterDisposableWriteLock())
                         {
                             if (_environmentProperties == null)
                             {
@@ -933,7 +918,7 @@ internal int ToolsetsVersion
             [DebuggerStepThrough]
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     return _toolsetsVersion;
                 }
@@ -947,7 +932,7 @@ internal int MaxNodeCount
         {
             get
             {
-                using (_locker.EnterUpgradeableReadLock())
+                using (_locker.EnterDisposableUpgradeableReadLock())
                 {
                     return _maxNodeCount;
                 }
@@ -955,7 +940,7 @@ internal int MaxNodeCount
 
             set
             {
-                using (_locker.EnterWriteLock())
+                using (_locker.EnterDisposableWriteLock())
                 {
                     _maxNodeCount = value;
                 }
@@ -1007,7 +992,7 @@ public static string Unescape(string escapedString)
         public void AddToolset(Toolset toolset)
         {
             ErrorUtilities.VerifyThrowArgumentNull(toolset, nameof(toolset));
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 _toolsets[toolset.ToolsVersion] = toolset;
                 _toolsetsVersion++;
@@ -1025,7 +1010,7 @@ public bool RemoveToolset(string toolsVersion)
             ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
 
             bool changed;
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 changed = RemoveToolsetInternal(toolsVersion);
             }
@@ -1044,7 +1029,7 @@ public bool RemoveToolset(string toolsVersion)
         public void RemoveAllToolsets()
         {
             bool changed = false;
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 var toolsets = new List<Toolset>(Toolsets);
 
@@ -1067,7 +1052,7 @@ public void RemoveAllToolsets()
         public Toolset GetToolset(string toolsVersion)
         {
             ErrorUtilities.VerifyThrowArgumentLength(toolsVersion, nameof(toolsVersion));
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 _toolsets.TryGetValue(toolsVersion, out var toolset);
                 return toolset;
@@ -1103,7 +1088,7 @@ public ICollection<Project> GetLoadedProjects(string fullPath)
         internal ICollection<Project> GetLoadedProjects(bool includeExternal, string fullPath = null)
         {
             List<Project> loaded;
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                     loaded = fullPath == null ? new List<Project>(_loadedProjects) : new List<Project>(_loadedProjects.GetMatchingProjectsIfAny(fullPath));
             }
@@ -1156,7 +1141,7 @@ public Project LoadProject(string fileName, IDictionary<string, string> globalPr
             ErrorUtilities.VerifyThrowArgumentLength(fileName, nameof(fileName));
             fileName = FileUtilities.NormalizePath(fileName);
 
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 if (globalProperties == null)
                 {
@@ -1257,7 +1242,7 @@ public Project LoadProject(XmlReader xmlReader, IDictionary<string, string> glob
         /// </summary>
         public void RegisterLogger(ILogger logger)
         {
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 RegisterLoggerInternal(logger);
             }
@@ -1275,7 +1260,7 @@ public void RegisterLoggers(IEnumerable<ILogger> loggers)
             bool changed = false;
             if (loggers != null)
             {
-                using (_locker.EnterWriteLock())
+                using (_locker.EnterDisposableWriteLock())
                 {
                     foreach (ILogger logger in loggers)
                     {
@@ -1297,7 +1282,7 @@ public void RegisterLoggers(IEnumerable<ILogger> loggers)
         /// </summary>
         public void RegisterForwardingLoggers(IEnumerable<ForwardingLoggerRecord> remoteLoggers)
         {
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 if (remoteLoggers != null)
                 {
@@ -1316,7 +1301,7 @@ public void RegisterForwardingLoggers(IEnumerable<ForwardingLoggerRecord> remote
         /// </summary>
         public void UnregisterAllLoggers()
         {
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 _loggingService.UnregisterAllLoggers();
 
@@ -1341,7 +1326,7 @@ public void UnloadProject(Project project)
                 return;
             }
 
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 bool existed = _loadedProjects.RemoveProject(project);
                 ErrorUtilities.VerifyThrowInvalidOperation(existed, "OM_ProjectWasNotLoaded");
@@ -1393,7 +1378,7 @@ public void UnloadProject(ProjectRootElement projectRootElement)
                 return;
             }
 
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 Project conflictingProject = GetLoadedProjects(false, null).FirstOrDefault(project => project.UsesProjectRootElement(projectRootElement));
                 if (conflictingProject != null)
@@ -1412,7 +1397,7 @@ public void UnloadProject(ProjectRootElement projectRootElement)
         /// </summary>
         public void UnloadAllProjects()
         {
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 foreach (Project project in _loadedProjects)
                 {
@@ -1435,7 +1420,7 @@ public void UnloadAllProjects()
         /// </summary>
         public ProjectPropertyInstance GetGlobalProperty(string name)
         {
-            using (_locker.EnterUpgradeableReadLock())
+            using (_locker.EnterDisposableUpgradeableReadLock())
             {
                 return _globalProperties[name];
             }
@@ -1448,7 +1433,7 @@ public ProjectPropertyInstance GetGlobalProperty(string name)
         public void SetGlobalProperty(string name, string value)
         {
             bool sendEvent = false;
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 ProjectPropertyInstance propertyInGlobalProperties = _globalProperties.GetProperty(name);
                 bool changed = propertyInGlobalProperties == null || !String.Equals(((IValued)propertyInGlobalProperties).EscapedValue, value, StringComparison.OrdinalIgnoreCase);
@@ -1481,7 +1466,7 @@ public void SetGlobalProperty(string name, string value)
         public bool RemoveGlobalProperty(string name)
         {
             bool set;
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 set = _globalProperties.Remove(name);
 
@@ -1544,7 +1529,7 @@ public bool TryUnloadProject(ProjectRootElement projectRootElement)
                 return false;
             }
 
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 ProjectRootElementCache.DiscardStrongReferences();
 
@@ -1575,7 +1560,7 @@ internal void OnAfterRenameLoadedProject(string oldFullPathIfAny, Project projec
                 return;
             }
 
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 if (oldFullPathIfAny != null)
                 {
@@ -1609,7 +1594,7 @@ internal void OnAfterRenameLoadedProject(string oldFullPathIfAny, Project projec
         /// </remarks>
         internal void AfterUpdateLoadedProjectGlobalProperties(Project project)
         {
-            using (_locker.EnterWriteLock())
+            using (_locker.EnterDisposableWriteLock())
             {
                 ErrorUtilities.VerifyThrowInvalidOperation(ReferenceEquals(project.ProjectCollection, this), "OM_IncorrectObjectAssociation", "Project", "ProjectCollection");
 
@@ -1637,6 +1622,12 @@ protected virtual void Dispose(bool disposing)
             if (disposing)
             {
                 ShutDownLoggingService();
+                if (ProjectRootElementCache != null)
+                {
+                    ProjectRootElementCache.ProjectRootElementAddedHandler -= ProjectRootElementCache_ProjectRootElementAddedHandler;
+                    ProjectRootElementCache.ProjectRootElementDirtied -= ProjectRootElementCache_ProjectRootElementDirtiedHandler;
+                    ProjectRootElementCache.ProjectDirtied -= ProjectRootElementCache_ProjectDirtiedHandler;
+                }
                 Tracing.Dump();
             }
         }
diff --git a/src/Build/Definition/ProjectProperty.cs b/src/Build/Definition/ProjectProperty.cs
index 157fc4366ec..b3e808c3c9a 100644
--- a/src/Build/Definition/ProjectProperty.cs
+++ b/src/Build/Definition/ProjectProperty.cs
@@ -3,10 +3,8 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Construction;
-using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
@@ -96,18 +94,7 @@ public string EvaluatedValue
         string IProperty.EvaluatedValueEscaped
         {
             [DebuggerStepThrough]
-            get
-            {
-                if (this is EnvironmentDerivedProjectProperty environmentProperty && environmentProperty.loggingContext is { IsValid: true } loggingContext && !environmentProperty._loggedEnvProperty)
-                {
-                    EnvironmentVariableReadEventArgs args = new(Name, EvaluatedValueEscapedInternal);
-                    args.BuildEventContext = loggingContext.BuildEventContext;
-                    loggingContext.LogBuildEvent(args);
-                    environmentProperty._loggedEnvProperty = true;
-                }
-
-                return EvaluatedValueEscapedInternal;
-            }
+            get => EvaluatedValueEscapedInternal;
         }
 
         /// <summary>
@@ -250,10 +237,9 @@ bool IEquatable<ProjectProperty>.Equals(ProjectProperty other)
         /// This is ONLY to be used by the Evaluator (and Project.SetGlobalProperty) and ONLY for Global, Environment, and Built-in properties.
         /// All other properties originate in XML, and should have a backing XML object.
         /// </summary>
-        internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext = null)
+        internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved)
         {
-            return !isGlobalProperty && !mayBeReserved ? new EnvironmentDerivedProjectProperty(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext) :
-                new ProjectPropertyNotXmlBacked(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
+            return new ProjectPropertyNotXmlBacked(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
         }
 
         /// <summary>
@@ -642,18 +628,5 @@ public override bool IsImported
                 get { return false; }
             }
         }
-
-        private class EnvironmentDerivedProjectProperty : ProjectPropertyNotXmlBacked
-        {
-            internal bool _loggedEnvProperty = false;
-            internal LoggingContext loggingContext;
-
-            internal EnvironmentDerivedProjectProperty(
-                Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext)
-                : base(project, name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved)
-            {
-                this.loggingContext = loggingContext;
-            }
-        }
     }
 }
diff --git a/src/Build/Definition/ToolsetReader.cs b/src/Build/Definition/ToolsetReader.cs
index 3f8499f4264..8887b9cca2b 100644
--- a/src/Build/Definition/ToolsetReader.cs
+++ b/src/Build/Definition/ToolsetReader.cs
@@ -16,6 +16,7 @@
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
 using InvalidToolsetDefinitionException = Microsoft.Build.Exceptions.InvalidToolsetDefinitionException;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
+using System.Runtime.CompilerServices;
 
 #nullable disable
 
@@ -128,10 +129,22 @@ ToolsetDefinitionLocations locations
                     configurationReader = new ToolsetConfigurationReader(environmentProperties, globalProperties);
                 }
 
-                // Accumulation of properties is okay in the config file because it's deterministically ordered
-                defaultToolsVersionFromConfiguration = configurationReader.ReadToolsets(toolsets, globalProperties,
-                    initialProperties, true /* accumulate properties */, out overrideTasksPathFromConfiguration,
-                    out defaultOverrideToolsVersionFromConfiguration);
+                ReadConfigToolset();
+
+                // This is isolated into its own function in order to isolate loading of
+                // System.Configuration.ConfigurationManager.dll to codepaths that really
+                // need it as a way of mitigating the need to update references to that
+                // assembly in API consumers.
+                //
+                // https://github.com/microsoft/MSBuildLocator/issues/159
+                [MethodImplAttribute(MethodImplOptions.NoInlining)]
+                void ReadConfigToolset()
+                {
+                    // Accumulation of properties is okay in the config file because it's deterministically ordered
+                    defaultToolsVersionFromConfiguration = configurationReader.ReadToolsets(toolsets, globalProperties,
+                                    initialProperties, true /* accumulate properties */, out overrideTasksPathFromConfiguration,
+                                    out defaultOverrideToolsVersionFromConfiguration);
+                }
             }
 
             string defaultToolsVersionFromRegistry = null;
diff --git a/src/Build/Evaluation/ConditionEvaluator.cs b/src/Build/Evaluation/ConditionEvaluator.cs
index 183ce5117d6..31dd956ed2e 100644
--- a/src/Build/Evaluation/ConditionEvaluator.cs
+++ b/src/Build/Evaluation/ConditionEvaluator.cs
@@ -17,7 +17,6 @@ namespace Microsoft.Build.Evaluation
     using ElementLocation = Microsoft.Build.Construction.ElementLocation;
     using Microsoft.Build.Shared;
     using Microsoft.Build.Shared.FileSystem;
-    using Microsoft.Build.BackEnd.Logging;
 
     internal static class ConditionEvaluator
     {
@@ -182,8 +181,7 @@ internal static bool EvaluateCondition<P, I>
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null,
-            LoggingContext loggingContext = null)
+            ProjectRootElementCacheBase projectRootElementCache = null)
             where P : class, IProperty
             where I : class, IItem
         {
@@ -198,8 +196,7 @@ internal static bool EvaluateCondition<P, I>
                 loggingServices,
                 buildEventContext,
                 fileSystem,
-                projectRootElementCache,
-                loggingContext);
+                projectRootElementCache);
         }
 
         /// <summary>
@@ -221,8 +218,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             ILoggingService loggingServices,
             BuildEventContext buildEventContext,
             IFileSystem fileSystem,
-            ProjectRootElementCacheBase projectRootElementCache = null,
-            LoggingContext loggingContext = null
+            ProjectRootElementCacheBase projectRootElementCache = null
         )
             where P : class, IProperty
             where I : class, IItem
@@ -283,7 +279,7 @@ internal static bool EvaluateConditionCollectingConditionedProperties<P, I>
             {
                 try
                 {
-                    result = parsedExpression.Evaluate(state, loggingContext);
+                    result = parsedExpression.Evaluate(state);
                 }
                 finally
                 {
@@ -357,7 +353,7 @@ internal interface IConditionEvaluationState
             ///     May return null if the expression would expand to non-empty and it broke out early.
             ///     Otherwise, returns the correctly expanded expression.
             /// </summary>
-            string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null);
+            string ExpandIntoStringBreakEarly(string expression);
 
             /// <summary>
             ///     Expands the specified expression into a list of TaskItem's.
@@ -367,7 +363,7 @@ internal interface IConditionEvaluationState
             /// <summary>
             ///     Expands the specified expression into a string.
             /// </summary>
-            string ExpandIntoString(string expression, LoggingContext loggingContext = null);
+            string ExpandIntoString(string expression);
 
             /// <summary>
             ///     PRE cache
@@ -444,11 +440,11 @@ internal ConditionEvaluationState
             /// May return null if the expression would expand to non-empty and it broke out early.
             /// Otherwise, returns the correctly expanded expression.
             /// </summary>
-            public string ExpandIntoStringBreakEarly(string expression, LoggingContext loggingContext = null)
+            public string ExpandIntoStringBreakEarly(string expression)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation, loggingContext);
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions | ExpanderOptions.BreakOnNotEmpty, ElementLocation);
 
                 _expander.WarnForUninitializedProperties = originalValue;
 
@@ -475,13 +471,12 @@ public IList<TaskItem> ExpandIntoTaskItems(string expression)
             /// Expands the specified expression into a string.
             /// </summary>
             /// <param name="expression">The expression to expand.</param>
-            /// <param name="loggingContext"></param>
             /// <returns>The expanded string.</returns>
-            public string ExpandIntoString(string expression, LoggingContext loggingContext = null)
+            public string ExpandIntoString(string expression)
             {
                 var originalValue = _expander.WarnForUninitializedProperties;
 
-                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation, loggingContext);
+                expression = _expander.ExpandIntoStringAndUnescape(expression, _expanderOptions, ElementLocation);
 
                 _expander.WarnForUninitializedProperties = originalValue;
 
diff --git a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
index 47481c625c3..94513436e9c 100644
--- a/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/AndExpressionNode.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -19,9 +18,9 @@ internal sealed class AndExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                      state.ElementLocation,
@@ -38,7 +37,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                          state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
index 4ec222243fd..e0b57181361 100644
--- a/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/FunctionCallExpressionNode.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 using TaskItem = Microsoft.Build.Execution.ProjectItemInstance.TaskItem;
@@ -30,7 +29,7 @@ internal FunctionCallExpressionNode(string functionName, List<GenericExpressionN
         /// <summary>
         /// Evaluate node as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (String.Equals(_functionName, "exists", StringComparison.OrdinalIgnoreCase))
             {
diff --git a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
index 50efb172cf7..d6007133404 100644
--- a/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/GenericExpressionNode.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.BackEnd.Logging;
+
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -14,9 +14,9 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class GenericExpressionNode
     {
-        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null);
-        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null);
-        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null);
+        internal abstract bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result);
+        internal abstract bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result);
+        internal abstract bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result);
 
         /// <summary>
         /// Returns true if this node evaluates to an empty string,
@@ -25,7 +25,7 @@ internal abstract class GenericExpressionNode
         /// to empty than to fully evaluate it.)
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
         {
             return false;
         }
@@ -34,7 +34,7 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
+        internal abstract string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state);
 
         /// <summary>
         /// Value before any item and property expressions are expanded
@@ -52,17 +52,16 @@ internal virtual bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationSt
         /// The main evaluate entry point for expression trees
         /// </summary>
         /// <param name="state"></param>
-        /// <param name="loggingContext"></param>
         /// <returns></returns>
-        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal bool Evaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!TryBoolEvaluate(state, out bool boolValue, loggingContext))
+            if (!TryBoolEvaluate(state, out bool boolValue))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ConditionNotBooleanDetail",
                     state.Condition,
-                    GetExpandedValue(state, loggingContext));
+                    GetExpandedValue(state));
             }
 
             return boolValue;
diff --git a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
index 1ef13748bdc..65e23c7718f 100644
--- a/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/MultipleComparisonExpressionNode.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -37,7 +36,7 @@ internal abstract class MultipleComparisonNode : OperatorExpressionNode
         /// Order in which comparisons are attempted is numeric, boolean, then string.
         /// Updates conditioned properties table.
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             ProjectErrorUtilities.VerifyThrowInvalidProject
                 (LeftChild != null && RightChild != null,
@@ -51,8 +50,8 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             // and we know which do, then we already have enough information to evaluate this expression.
             // That means we don't have to fully expand a condition like " '@(X)' == '' " 
             // which is a performance advantage if @(X) is a huge item list.
-            bool leftEmpty = LeftChild.EvaluatesToEmpty(state, loggingContext);
-            bool rightEmpty = RightChild.EvaluatesToEmpty(state, loggingContext);
+            bool leftEmpty = LeftChild.EvaluatesToEmpty(state);
+            bool rightEmpty = RightChild.EvaluatesToEmpty(state);
             if (leftEmpty || rightEmpty)
             {
                 UpdateConditionedProperties(state);
@@ -69,13 +68,13 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                 // is 17.0).
                 return Compare(leftNumericValue, rightNumericValue);
             }
-            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue, loggingContext) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue, loggingContext))
+            else if (LeftChild.TryBoolEvaluate(state, out bool leftBoolValue) && RightChild.TryBoolEvaluate(state, out bool rightBoolValue))
             {
                 return Compare(leftBoolValue, rightBoolValue);
             }
 
-            string leftExpandedValue = LeftChild.GetExpandedValue(state, loggingContext);
-            string rightExpandedValue = RightChild.GetExpandedValue(state, loggingContext);
+            string leftExpandedValue = LeftChild.GetExpandedValue(state);
+            string rightExpandedValue = RightChild.GetExpandedValue(state);
 
             ProjectErrorUtilities.VerifyThrowInvalidProject
                 (leftExpandedValue != null && rightExpandedValue != null,
diff --git a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
index 1d2e1d6311e..e5b00ac781a 100644
--- a/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NotExpressionNode.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -19,9 +18,9 @@ internal sealed class NotExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool boolValue))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
@@ -45,9 +44,9 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Returns expanded value with '!' prepended. Useful for error messages.
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
-            return "!" + LeftChild.GetExpandedValue(state, loggingContext);
+            return "!" + LeftChild.GetExpandedValue(state);
         }
 
         internal override string DebuggerDisplay => $"(not {LeftChild.DebuggerDisplay})";
diff --git a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
index f161ad5d18b..02c242ceef5 100644
--- a/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericComparisonExpressionNode.cs
@@ -2,7 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.BackEnd.Logging;
+
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -38,7 +38,7 @@ internal abstract class NumericComparisonExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
             bool isLeftNum = LeftChild.TryNumericEvaluate(state, out double leftNum);
             bool isLeftVersion = LeftChild.TryVersionEvaluate(state, out Version leftVersion);
@@ -53,7 +53,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
                     state.Condition,
                     /* helpfully display unexpanded token and expanded result in error message */
                     isLeftNum ? RightChild.GetUnexpandedValue(state) : LeftChild.GetUnexpandedValue(state),
-                    isLeftNum ? RightChild.GetExpandedValue(state, loggingContext) : LeftChild.GetExpandedValue(state, loggingContext));
+                    isLeftNum ? RightChild.GetExpandedValue(state) : LeftChild.GetExpandedValue(state));
             }
 
             return (isLeftNum, isLeftVersion, isRightNum, isRightVersion) switch
diff --git a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
index 7725d9962dc..66fa552443d 100644
--- a/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/NumericExpressionNode.cs
@@ -3,7 +3,7 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
+
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -23,18 +23,18 @@ internal NumericExpressionNode(string value)
             _value = value;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             return ConversionUtilities.TryConvertDecimalOrHexToDouble(_value, out result);
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
             return Version.TryParse(_value, out result);
         }
@@ -50,7 +50,7 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// <summary>
         /// Get the expanded value
         /// </summary>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             return _value;
         }
diff --git a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
index a3f76ff20ff..c6e4b4c349c 100644
--- a/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OperatorExpressionNode.cs
@@ -2,7 +2,6 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
-using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -13,21 +12,21 @@ namespace Microsoft.Build.Evaluation
     /// </summary>
     internal abstract class OperatorExpressionNode : GenericExpressionNode
     {
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            result = BoolEvaluate(state, loggingContext);
+            result = BoolEvaluate(state);
             return true;
         }
 
-        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null);
+        internal abstract bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state);
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
             result = default;
             return false;
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
             result = default;
             return false;
@@ -37,7 +36,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             return null;
         }
diff --git a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
index fa1816c2e1d..250e8c9602c 100644
--- a/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/OrExpressionNode.cs
@@ -1,7 +1,6 @@
 ﻿// Copyright (c) Microsoft. All rights reserved.
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 using System.Diagnostics;
 
@@ -19,15 +18,15 @@ internal sealed class OrExpressionNode : OperatorExpressionNode
         /// <summary>
         /// Evaluate as boolean
         /// </summary>
-        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState state)
         {
-            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool, loggingContext))
+            if (!LeftChild.TryBoolEvaluate(state, out bool leftBool))
             {
                 ProjectErrorUtilities.ThrowInvalidProject(
                     state.ElementLocation,
                     "ExpressionDoesNotEvaluateToBoolean",
                     LeftChild.GetUnexpandedValue(state),
-                    LeftChild.GetExpandedValue(state, loggingContext),
+                    LeftChild.GetExpandedValue(state),
                     state.Condition);
             }
 
@@ -38,7 +37,7 @@ internal override bool BoolEvaluate(ConditionEvaluator.IConditionEvaluationState
             }
             else
             {
-                if (!RightChild.TryBoolEvaluate(state, out bool rightBool, loggingContext))
+                if (!RightChild.TryBoolEvaluate(state, out bool rightBool))
                 {
                     ProjectErrorUtilities.ThrowInvalidProject(
                         state.ElementLocation,
diff --git a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
index 43dd324e7a8..7017b0b5023 100644
--- a/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
+++ b/src/Build/Evaluation/Conditionals/StringExpressionNode.cs
@@ -3,7 +3,6 @@
 
 using System;
 using System.Diagnostics;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -31,34 +30,34 @@ internal StringExpressionNode(string value, bool expandable)
             _expandable = expandable;
         }
 
-        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result, LoggingContext loggingContext = null)
+        internal override bool TryBoolEvaluate(ConditionEvaluator.IConditionEvaluationState state, out bool result)
         {
-            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state, loggingContext), out result);
+            return ConversionUtilities.TryConvertStringToBool(GetExpandedValue(state), out result);
         }
 
-        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result, LoggingContext loggingContext = null)
+        internal override bool TryNumericEvaluate(ConditionEvaluator.IConditionEvaluationState state, out double result)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
+            if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
                 result = ConversionUtilities.ConvertDecimalOrHexToDouble(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state, loggingContext), out result);
+                return ConversionUtilities.TryConvertDecimalOrHexToDouble(GetExpandedValue(state), out result);
             }
         }
 
-        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result, LoggingContext loggingContext = null)
+        internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluationState state, out Version result)
         {
-            if (ShouldBeTreatedAsVisualStudioVersion(state, loggingContext))
+            if (ShouldBeTreatedAsVisualStudioVersion(state))
             {
                 result = Version.Parse(MSBuildConstants.CurrentVisualStudioVersion);
                 return true;
             }
             else
             {
-                return Version.TryParse(GetExpandedValue(state, loggingContext), out result);
+                return Version.TryParse(GetExpandedValue(state), out result);
             }
         }
 
@@ -69,7 +68,7 @@ internal override bool TryVersionEvaluate(ConditionEvaluator.IConditionEvaluatio
         /// to empty than to fully evaluate it.
         /// Implementations should cache the result so that calls after the first are free.
         /// </summary>
-        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (_cachedExpandedValue == null)
             {
@@ -94,7 +93,7 @@ internal override bool EvaluatesToEmpty(ConditionEvaluator.IConditionEvaluationS
                             break;
                     }
 
-                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value, loggingContext);
+                    string expandBreakEarly = state.ExpandIntoStringBreakEarly(_value);
 
                     if (expandBreakEarly == null)
                     {
@@ -130,13 +129,13 @@ internal override string GetUnexpandedValue(ConditionEvaluator.IConditionEvaluat
         /// Value after any item and property expressions are expanded
         /// </summary>
         /// <returns></returns>
-        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        internal override string GetExpandedValue(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (_cachedExpandedValue == null)
             {
                 if (_expandable)
                 {
-                    _cachedExpandedValue = state.ExpandIntoString(_value, loggingContext);
+                    _cachedExpandedValue = state.ExpandIntoString(_value);
                 }
                 else
                 {
@@ -169,7 +168,7 @@ internal override void ResetState()
         /// but now cause the project to throw InvalidProjectException when
         /// ToolsVersion is "Current". https://github.com/dotnet/msbuild/issues/4150
         /// </remarks>
-        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state, LoggingContext loggingContext = null)
+        private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionEvaluationState state)
         {
             if (!_shouldBeTreatedAsVisualStudioVersion.HasValue)
             {
@@ -177,7 +176,7 @@ private bool ShouldBeTreatedAsVisualStudioVersion(ConditionEvaluator.IConditionE
 
                 // Do this check first, because if it's not (common) we can early-out and the next
                 // expansion will be cheap because this will populate the cached expanded value.
-                if (string.Equals(GetExpandedValue(state, loggingContext), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
+                if (string.Equals(GetExpandedValue(state), MSBuildConstants.CurrentToolsVersion, StringComparison.Ordinal))
                 {
                     // and it is just an expansion of MSBuildToolsVersion
                     _shouldBeTreatedAsVisualStudioVersion = string.Equals(_value, "$(MSBuildToolsVersion)", StringComparison.OrdinalIgnoreCase);
diff --git a/src/Build/Evaluation/Evaluator.cs b/src/Build/Evaluation/Evaluator.cs
index ebce24983ad..b3154221e9f 100644
--- a/src/Build/Evaluation/Evaluator.cs
+++ b/src/Build/Evaluation/Evaluator.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using ObjectModel = System.Collections.ObjectModel;
 using System.Diagnostics;
 using System.Globalization;
 using System.IO;
@@ -24,15 +25,13 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 using Microsoft.Build.Shared.FileSystem;
-using static Microsoft.Build.Execution.ProjectPropertyInstance;
-using Constants = Microsoft.Build.Internal.Constants;
-using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
+using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 using InvalidProjectFileException = Microsoft.Build.Exceptions.InvalidProjectFileException;
-using ObjectModel = System.Collections.ObjectModel;
+using Constants = Microsoft.Build.Internal.Constants;
+using EngineFileUtilities = Microsoft.Build.Internal.EngineFileUtilities;
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
 using SdkReferencePropertyExpansionMode = Microsoft.Build.Framework.EscapeHatches.SdkReferencePropertyExpansionMode;
-using SdkResult = Microsoft.Build.BackEnd.SdkResolution.SdkResult;
 
 #nullable disable
 
@@ -812,30 +811,13 @@ private void Evaluate()
             if (this._evaluationLoggingContext.LoggingService.IncludeEvaluationPropertiesAndItems)
             {
                 globalProperties = _data.GlobalPropertiesDictionary;
-                properties = Traits.Instance.LogAllEnvironmentVariables ? _data.Properties : FilterOutEnvironmentDerivedProperties(_data.Properties);
+                properties = _data.Properties;
                 items = _data.Items;
             }
 
             _evaluationLoggingContext.LogProjectEvaluationFinished(globalProperties, properties, items, _evaluationProfiler.ProfiledResult);
         }
 
-        private IEnumerable FilterOutEnvironmentDerivedProperties(PropertyDictionary<P> dictionary)
-        {
-            List<P> list = new(dictionary.Count);
-            foreach (P p in dictionary)
-            {
-                if (p is EnvironmentDerivedProjectPropertyInstance ||
-                    (p is ProjectProperty pp && pp.IsEnvironmentProperty))
-                {
-                    continue;
-                }
-
-                list.Add(p);
-            }
-
-            return list;
-        }
-
         private void CollectProjectCachePlugins()
         {
             foreach (var item in _data.GetItems(ItemTypeNames.ProjectCachePlugin))
@@ -1069,8 +1051,8 @@ private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList<Pr
         /// </summary>
         private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement, Dictionary<string, LinkedListNode<ProjectTargetElement>> activeTargets, Dictionary<string, List<TargetSpecification>> targetsWhichRunBeforeByTarget, Dictionary<string, List<TargetSpecification>> targetsWhichRunAfterByTarget)
         {
-            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation, _evaluationLoggingContext);
-            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation, _evaluationLoggingContext);
+            var beforeTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.BeforeTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.BeforeTargetsLocation);
+            var afterTargets = _expander.ExpandIntoStringListLeaveEscaped(targetElement.AfterTargets, ExpanderOptions.ExpandPropertiesAndItems, targetElement.AfterTargetsLocation);
 
             foreach (string beforeTarget in beforeTargets)
             {
@@ -1215,7 +1197,7 @@ private void AddEnvironmentProperties()
         {
             foreach (ProjectPropertyInstance environmentProperty in _environmentProperties)
             {
-                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true, loggingContext: _evaluationLoggingContext);
+                _data.SetProperty(environmentProperty.Name, ((IProperty)environmentProperty).EvaluatedValueEscaped, isGlobalProperty: false, mayBeReserved: false, isEnvironmentVariable: true);
             }
         }
 
@@ -1316,7 +1298,7 @@ private void EvaluatePropertyElement(ProjectPropertyElement propertyElement)
                 // it is the same as what we are setting the value on. Note: This needs to be set before we expand the property we are currently setting.
                 _expander.UsedUninitializedProperties.CurrentlyEvaluatingPropertyElementName = propertyElement.Name;
 
-                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location, _evaluationLoggingContext);
+                string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(propertyElement.Value, ExpanderOptions.ExpandProperties, propertyElement.Location);
 
                 // If we are going to set a property to a value other than null or empty we need to check to see if it has been used
                 // during evaluation.
@@ -2021,7 +2003,7 @@ private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(stri
         {
             imports = null;
 
-            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation, _evaluationLoggingContext);
+            string importExpressionEscaped = _expander.ExpandIntoStringLeaveEscaped(unescapedExpression, ExpanderOptions.ExpandProperties, importElement.ProjectLocation);
             ElementLocation importLocationInProject = importElement.Location;
 
             if (String.IsNullOrWhiteSpace(importExpressionEscaped))
@@ -2446,8 +2428,7 @@ private bool EvaluateCondition(ProjectElement element, string condition, Expande
                     element.ConditionLocation,
                     _evaluationLoggingContext.LoggingService,
                     _evaluationLoggingContext.BuildEventContext,
-                    _evaluationContext.FileSystem,
-                    loggingContext: _evaluationLoggingContext
+                    _evaluationContext.FileSystem
                     );
 
                 return result;
diff --git a/src/Build/Evaluation/Expander.cs b/src/Build/Evaluation/Expander.cs
index 88e5fea6c1b..9bc57cab1ed 100644
--- a/src/Build/Evaluation/Expander.cs
+++ b/src/Build/Evaluation/Expander.cs
@@ -26,7 +26,6 @@
 using TaskItemFactory = Microsoft.Build.Execution.ProjectItemInstance.TaskItem.TaskItemFactory;
 
 using Microsoft.NET.StringTools;
-using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -419,9 +418,9 @@ internal static bool ExpressionContainsItemVector(string expression)
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
-            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext);
+            string result = ExpandIntoStringLeaveEscaped(expression, options, elementLocation);
 
             return (result == null) ? null : EscapingUtilities.UnescapeAll(result);
         }
@@ -433,7 +432,7 @@ internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions o
         ///
         /// If ExpanderOptions.BreakOnNotEmpty was passed, expression was going to be non-empty, and it broke out early, returns null. Otherwise the result can be trusted.
         /// </summary>
-        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
             if (expression.Length == 0)
             {
@@ -443,7 +442,7 @@ internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions
             ErrorUtilities.VerifyThrowInternalNull(elementLocation, nameof(elementLocation));
 
             string result = MetadataExpander.ExpandMetadataLeaveEscaped(expression, _metadata, options, elementLocation);
-            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem, loggingContext);
+            result = PropertyExpander<P>.ExpandPropertiesLeaveEscaped(result, _properties, options, elementLocation, _usedUninitializedProperties, _fileSystem);
             result = ItemExpander.ExpandItemVectorsIntoString<I>(this, result, _items, options, elementLocation);
             result = FileUtilities.MaybeAdjustFilePath(result);
 
@@ -473,11 +472,11 @@ internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, Expander
         /// Use this form when the result is going to be processed further, for example by matching against the file system,
         /// so literals must be distinguished, and you promise to unescape after that.
         /// </summary>
-        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext = null)
+        internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation)
         {
             ErrorUtilities.VerifyThrow((options & ExpanderOptions.BreakOnNotEmpty) == 0, "not supported");
 
-            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation, loggingContext));
+            return ExpressionShredder.SplitSemiColonSeparatedList(ExpandIntoStringLeaveEscaped(expression, options, elementLocation));
         }
 
         /// <summary>
@@ -1077,8 +1076,7 @@ internal static string ExpandPropertiesLeaveEscaped(
                 ExpanderOptions options,
                 IElementLocation elementLocation,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext = null)
+                IFileSystem fileSystem)
             {
                 return
                     ConvertToString(
@@ -1088,8 +1086,7 @@ internal static string ExpandPropertiesLeaveEscaped(
                             options,
                             elementLocation,
                             usedUninitializedProperties,
-                            fileSystem,
-                            loggingContext));
+                            fileSystem));
             }
 
             /// <summary>
@@ -1115,8 +1112,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                 ExpanderOptions options,
                 IElementLocation elementLocation,
                 UsedUninitializedProperties usedUninitializedProperties,
-                IFileSystem fileSystem,
-                LoggingContext loggingContext = null)
+                IFileSystem fileSystem)
             {
                 if (((options & ExpanderOptions.ExpandProperties) == 0) || String.IsNullOrEmpty(expression))
                 {
@@ -1230,7 +1226,7 @@ internal static object ExpandPropertiesLeaveTypedAndEscaped(
                         }
                         else // This is a regular property
                         {
-                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties, loggingContext);
+                            propertyValue = LookupProperty(properties, expression, propertyStartIndex + 2, propertyEndIndex - 1, elementLocation, usedUninitializedProperties);
                         }
 
                         if (propertyValue != null)
@@ -1468,7 +1464,7 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
             /// <summary>
             /// Look up a simple property reference by the name of the property, e.g. "Foo" when expanding $(Foo).
             /// </summary>
-            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties, LoggingContext loggingContext = null)
+            private static object LookupProperty(IPropertyProvider<T> properties, string propertyName, int startIndex, int endIndex, IElementLocation elementLocation, UsedUninitializedProperties usedUninitializedProperties)
             {
                 T property = properties.GetProperty(propertyName, startIndex, endIndex);
 
@@ -1513,11 +1509,6 @@ private static object LookupProperty(IPropertyProvider<T> properties, string pro
                 }
                 else
                 {
-                    if (property is ProjectPropertyInstance.EnvironmentDerivedProjectPropertyInstance environmentDerivedProperty)
-                    {
-                        environmentDerivedProperty.loggingContext = loggingContext;
-                    }
-
                     propertyValue = property.EvaluatedValueEscaped;
                 }
 
diff --git a/src/Build/Evaluation/IEvaluatorData.cs b/src/Build/Evaluation/IEvaluatorData.cs
index 497207e7024..cf0b17d457f 100644
--- a/src/Build/Evaluation/IEvaluatorData.cs
+++ b/src/Build/Evaluation/IEvaluatorData.cs
@@ -267,7 +267,7 @@ List<ProjectItemElement> EvaluatedItemElements
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null);
+        P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false);
 
         /// <summary>
         /// Sets a property which comes from the Xml.
diff --git a/src/Build/Evaluation/ItemSpec.cs b/src/Build/Evaluation/ItemSpec.cs
index d7f58c8088a..65c1fd8b486 100644
--- a/src/Build/Evaluation/ItemSpec.cs
+++ b/src/Build/Evaluation/ItemSpec.cs
@@ -4,7 +4,6 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Globbing;
 using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
@@ -157,23 +156,21 @@ private bool InitReferencedItemsIfNecessary()
         /// <param name="itemSpecLocation">The xml location the itemspec comes from</param>
         /// <param name="projectDirectory">The directory that the project is in.</param>
         /// <param name="expandProperties">Expand properties before breaking down fragments. Defaults to true</param>
-        /// <param name="loggingContext">Context in which to log</param>
         public ItemSpec(
             string itemSpec,
             Expander<P, I> expander,
             IElementLocation itemSpecLocation,
             string projectDirectory,
-            bool expandProperties = true,
-            LoggingContext loggingContext = null)
+            bool expandProperties = true)
         {
             ItemSpecString = itemSpec;
             Expander = expander;
             ItemSpecLocation = itemSpecLocation;
 
-            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties, loggingContext);
+            Fragments = BuildItemFragments(itemSpecLocation, projectDirectory, expandProperties);
         }
 
-        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties, LoggingContext loggingContext)
+        private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties)
         {
             // Code corresponds to Evaluator.CreateItemsFromInclude
             var evaluatedItemspecEscaped = ItemSpecString;
@@ -189,8 +186,7 @@ private List<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocat
                 evaluatedItemspecEscaped = Expander.ExpandIntoStringLeaveEscaped(
                     ItemSpecString,
                     ExpanderOptions.ExpandProperties,
-                    itemSpecLocation,
-                    loggingContext);
+                    itemSpecLocation);
             }
 
             var semicolonCount = 0;
diff --git a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
index ecae588cd20..0255a8fbf2d 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.EvaluatorData.cs
@@ -9,7 +9,6 @@
 using Microsoft.Build.Construction;
 using Microsoft.Build.Evaluation.Context;
 using Microsoft.Build.Execution;
-using Microsoft.Build.BackEnd.Logging;
 
 #nullable disable
 
@@ -308,9 +307,9 @@ public P SetProperty(ProjectPropertyElement propertyElement, string evaluatedVal
                 return _wrappedData.SetProperty(propertyElement, evaluatedValueEscaped);
             }
 
-            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, LoggingContext loggingContext = null)
+            public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
             {
-                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, loggingContext: loggingContext);
+                return _wrappedData.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved);
             }
         }
     }
diff --git a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
index f0c19a5c681..f78cc28be71 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.LazyItemOperation.cs
@@ -262,7 +262,7 @@ protected void DecorateItemsWithMetadata(IEnumerable<ItemBatchingContext> itemBa
                                 continue;
                             }
 
-                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location, _lazyEvaluator._loggingContext);
+                            string evaluatedValue = _expander.ExpandIntoStringLeaveEscaped(metadataElement.Value, metadataExpansionOptions, metadataElement.Location);
                             evaluatedValue = FileUtilities.MaybeAdjustFilePath(evaluatedValue, metadataElement.ContainingProject.DirectoryPath);
 
                             metadataTable.SetValue(metadataElement, evaluatedValue);
diff --git a/src/Build/Evaluation/LazyItemEvaluator.cs b/src/Build/Evaluation/LazyItemEvaluator.cs
index 871ad820e6a..28fe97350da 100644
--- a/src/Build/Evaluation/LazyItemEvaluator.cs
+++ b/src/Build/Evaluation/LazyItemEvaluator.cs
@@ -99,8 +99,7 @@ LazyItemEvaluator<P, I, M, D> lazyEvaluator
                     element.ConditionLocation,
                     lazyEvaluator._loggingContext.LoggingService,
                     lazyEvaluator._loggingContext.BuildEventContext,
-                    lazyEvaluator.FileSystem,
-                    loggingContext: lazyEvaluator._loggingContext
+                    lazyEvaluator.FileSystem
                     );
                 MSBuildEventSource.Log.EvaluateConditionStop(condition, result);
 
@@ -625,7 +624,7 @@ private RemoveOperation BuildRemoveOperation(string rootDirectory, ProjectItemEl
 
         private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLocation itemSpecLocation, OperationBuilder builder)
         {
-            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory, loggingContext: _loggingContext);
+            builder.ItemSpec = new ItemSpec<P, I>(itemSpec, _outerExpander, itemSpecLocation, rootDirectory);
 
             foreach (ItemSpecFragment fragment in builder.ItemSpec.Fragments)
             {
@@ -636,7 +635,7 @@ private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLoca
             }
         }
 
-        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander, LoggingContext loggingContext = null)
+        private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(ICollection<ProjectMetadataElement> metadata, Expander<P, I> expander)
         {
             // Since we're just attempting to expand properties in order to find referenced items and not expanding metadata,
             // unexpected errors may occur when evaluating property functions on unexpanded metadata. Just ignore them if that happens.
@@ -650,8 +649,7 @@ private static IEnumerable<string> GetExpandedMetadataValuesAndConditions(IColle
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Value,
                     expanderOptions,
-                    metadatumElement.Location,
-                    loggingContext);
+                    metadatumElement.Location);
 
                 yield return expander.ExpandIntoStringLeaveEscaped(
                     metadatumElement.Condition,
@@ -666,7 +664,7 @@ private void ProcessMetadataElements(ProjectItemElement itemElement, OperationBu
             {
                 operationBuilder.Metadata.AddRange(itemElement.Metadata);
 
-                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander, _loggingContext));
+                var itemsAndMetadataFound = ExpressionShredder.GetReferencedItemNamesAndMetadata(GetExpandedMetadataValuesAndConditions(itemElement.Metadata, _expander));
                 if (itemsAndMetadataFound.Items != null)
                 {
                     foreach (var itemType in itemsAndMetadataFound.Items)
diff --git a/src/Build/Evaluation/ProjectRootElementCache.cs b/src/Build/Evaluation/ProjectRootElementCache.cs
index 17ecae43227..208a43ed668 100644
--- a/src/Build/Evaluation/ProjectRootElementCache.cs
+++ b/src/Build/Evaluation/ProjectRootElementCache.cs
@@ -415,6 +415,12 @@ internal override void Clear()
         /// </summary>
         internal override void DiscardImplicitReferences()
         {
+            if (_autoReloadFromDisk)
+            {
+                // no need to clear it, as auto reload properly invalidates caches if changed.
+                return;
+            }
+
             lock (_locker)
             {
                 // Make a new Weak cache only with items that have been explicitly loaded, this will be a small number, there will most likely
diff --git a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
index b113e73a6ec..da81aaf21b5 100644
--- a/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
+++ b/src/Build/Evaluation/PropertyTrackingEvaluatorDataWrapper.cs
@@ -79,10 +79,10 @@ public P GetProperty(string name, int startIndex, int endIndex)
         /// <summary>
         /// Sets a property which does not come from the Xml.
         /// </summary>
-        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false, BackEnd.Logging.LoggingContext loggingContext = null)
+        public P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable = false)
         {
             P originalProperty = _wrapped.GetProperty(name);
-            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable, loggingContext);
+            P newProperty = _wrapped.SetProperty(name, evaluatedValueEscaped, isGlobalProperty, mayBeReserved, isEnvironmentVariable);
 
             this.TrackPropertyWrite(
                 originalProperty,
diff --git a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
index a88d36f224c..71b55892b1c 100644
--- a/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
+++ b/src/Build/FileSystem/DirectoryCacheFileSystemWrapper.cs
@@ -87,8 +87,12 @@ private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string sea
             {
                 return FileMatcher.IsAllFilesWildcard(searchPattern) || FileMatcher.IsMatch(fileName, searchPattern);
             };
-            FindTransform<string> transform = (ref ReadOnlySpan<char> fileName) => Path.Join(path.AsSpan(), fileName);
 
+#if !FEATURE_MSIOREDIST && NETFRAMEWORK
+            FindTransform<string> transform = (ref ReadOnlySpan<char> fileName) => Path.Combine(path, fileName.ToString());
+#else
+            FindTransform<string> transform = (ref ReadOnlySpan<char> fileName) => Path.Join(path.AsSpan(), fileName);
+#endif
             IEnumerable<string> directories = includeDirectories
                 ? _directoryCache.EnumerateDirectories(path, searchPattern, predicate, transform)
                 : Enumerable.Empty<string>();
@@ -99,9 +103,9 @@ private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string sea
             return Enumerable.Concat(directories, files);
         }
 
-        #endregion
+#endregion
 
-        #region IFileSystem pass-through implementation
+#region IFileSystem pass-through implementation
 
         public FileAttributes GetAttributes(string path) => _fileSystem.GetAttributes(path);
 
@@ -115,6 +119,6 @@ private IEnumerable<string> EnumerateFullFileSystemPaths(string path, string sea
 
         public byte[] ReadFileAllBytes(string path) => _fileSystem.ReadFileAllBytes(path);
 
-        #endregion
+#endregion
     }
 }
diff --git a/src/Build/Graph/GraphBuildResult.cs b/src/Build/Graph/GraphBuildResult.cs
index a37dd86dd1f..8ed172972e0 100644
--- a/src/Build/Graph/GraphBuildResult.cs
+++ b/src/Build/Graph/GraphBuildResult.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 
 #nullable disable
@@ -22,17 +23,6 @@ internal GraphBuildResult(int submissionId, IReadOnlyDictionary<ProjectGraphNode
             ResultsByNode = resultsByNode;
         }
 
-        /// <summary>
-        /// Constructor creates a build result indicating a circular dependency was created.
-        /// </summary>
-        /// <param name="submissionId">The id of the build submission.</param>
-        /// <param name="circularDependency">Set to true if a circular dependency was detected.</param>
-        internal GraphBuildResult(int submissionId, bool circularDependency)
-        {
-            SubmissionId = submissionId;
-            CircularDependency = circularDependency;
-        }
-
         /// <summary>
         /// Constructs a graph build result with an exception
         /// </summary>
@@ -52,7 +42,7 @@ internal GraphBuildResult(int submissionId, Exception exception)
         /// <summary>
         /// Returns a flag indicating if a circular dependency was detected.
         /// </summary>
-        public bool CircularDependency { get; }
+        public bool CircularDependency => Exception is CircularDependencyException;
 
         /// <summary>
         /// Returns the exception generated while this result was run, if any.
@@ -66,7 +56,7 @@ public BuildResultCode OverallResult
         {
             get
             {
-                if (Exception != null || CircularDependency)
+                if (Exception != null)
                 {
                     return BuildResultCode.Failure;
                 }
diff --git a/src/Build/Graph/GraphBuilder.cs b/src/Build/Graph/GraphBuilder.cs
index 28387389e8c..fd84214f2d7 100644
--- a/src/Build/Graph/GraphBuilder.cs
+++ b/src/Build/Graph/GraphBuilder.cs
@@ -22,10 +22,6 @@ namespace Microsoft.Build.Graph
 {
     internal class GraphBuilder
     {
-        private const string PlatformLookupTableMetadataName = "PlatformLookupTable";
-        private const string PlatformMetadataName = "Platform";
-        private const string PlatformsMetadataName = "Platforms";
-        private const string EnableDynamicPlatformResolutionMetadataName = "EnableDynamicPlatformResolution";
         internal const string SolutionItemReference = "_SolutionReference";
         
         /// <summary>
@@ -52,8 +48,6 @@ internal class GraphBuilder
         private readonly ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory;
         private IReadOnlyDictionary<string, IReadOnlyCollection<string>> _solutionDependencies;
 
-        private bool PlatformNegotiationEnabled = false;
-
         public GraphBuilder(
             IEnumerable<ProjectGraphEntryPoint> entryPoints,
             ProjectCollection projectCollection,
@@ -505,44 +499,18 @@ private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata)
         {
             // TODO: ProjectInstance just converts the dictionary back to a PropertyDictionary, so find a way to directly provide it.
             var globalProperties = configurationMetadata.GlobalProperties.ToDictionary();
-            ProjectGraphNode graphNode;
-            ProjectInstance projectInstance;
-            var negotiatePlatform = PlatformNegotiationEnabled && !configurationMetadata.IsSetPlatformHardCoded;
-
-            projectInstance = _projectInstanceFactory(
-                                configurationMetadata.ProjectFullPath,
-                                negotiatePlatform ? null : globalProperties, // Platform negotiation requires an evaluation with no global properties first
-                                _projectCollection);
 
-            if (ConversionUtilities.ValidBooleanTrue(projectInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
-            {
-                PlatformNegotiationEnabled = true;
-            }
+            var projectInstance = _projectInstanceFactory(
+                configurationMetadata.ProjectFullPath,
+                globalProperties,
+                _projectCollection);
 
             if (projectInstance == null)
             {
                 throw new InvalidOperationException(ResourceUtilities.GetResourceString("NullReferenceFromProjectInstanceFactory"));
             }
 
-            if (negotiatePlatform)
-            {
-                var selectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), configurationMetadata.PreviousPlatformLookupTable, projectInstance.FullPath, configurationMetadata.PreviousPlatform);
-
-                if (selectedPlatform.Equals(String.Empty))
-                {
-                    globalProperties.Remove(PlatformMetadataName);
-                }
-                else
-                {
-                    globalProperties[PlatformMetadataName] = selectedPlatform;
-                }
-                projectInstance = _projectInstanceFactory(
-                                configurationMetadata.ProjectFullPath,
-                                globalProperties,
-                                _projectCollection);           
-            }
-
-            graphNode = new ProjectGraphNode(projectInstance);
+            var graphNode = new ProjectGraphNode(projectInstance);
 
             var referenceInfos = ParseReferences(graphNode);
 
@@ -578,8 +546,9 @@ private void SubmitProjectForParsing(ConfigurationMetadata projectToEvaluate)
         private List<ProjectInterpretation.ReferenceInfo> ParseReferences(ProjectGraphNode parsedProject)
         {
             var referenceInfos = new List<ProjectInterpretation.ReferenceInfo>();
+            
 
-            foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstance))
+            foreach (var referenceInfo in _projectInterpretation.GetReferences(parsedProject.ProjectInstance, _projectCollection, _projectInstanceFactory))
             {
                 if (FileUtilities.IsSolutionFilename(referenceInfo.ReferenceConfiguration.ProjectFullPath))
                 {
diff --git a/src/Build/Graph/ParallelWorkSet.cs b/src/Build/Graph/ParallelWorkSet.cs
index 15010e607b6..922d29fd39f 100644
--- a/src/Build/Graph/ParallelWorkSet.cs
+++ b/src/Build/Graph/ParallelWorkSet.cs
@@ -37,6 +37,8 @@ internal class ParallelWorkSet<TKey, TResult>
 
         private readonly List<Task> _tasks;
 
+        private readonly List<Exception> _exceptions = new List<Exception>(0);
+
         /// <summary>
         /// Retrieves all completed work items.
         /// </summary>
@@ -56,6 +58,11 @@ internal Dictionary<TKey, TResult> CompletedWork
                     }
                 }
 
+                if (_exceptions.Count > 0)
+                {
+                    throw new AggregateException(_exceptions);
+                }
+
                 return completedWork;
             }
         }
@@ -138,7 +145,12 @@ internal void WaitForAllWorkAndComplete()
 
             // Release one thread that will release all the threads when all the elements are processed.
             _semaphore.Release();
-            Task.WhenAll(_tasks.ToArray()).GetAwaiter().GetResult();
+            Task.WaitAll(_tasks.ToArray());
+
+            if (_exceptions.Count > 0)
+            {
+                throw new AggregateException(_exceptions);
+            }
         }
 
         private Task CreateProcessorItemTask()
@@ -179,7 +191,14 @@ private void ExecuteWorkItem()
             {
                 try
                 {
-                    TResult _ = workItem.Value;
+                    _ = workItem.Value;
+                }
+                catch (Exception ex)
+                {
+                    lock (_exceptions)
+                    {
+                        _exceptions.Add(ex);
+                    }
                 }
                 finally
                 {
diff --git a/src/Build/Graph/ProjectInterpretation.cs b/src/Build/Graph/ProjectInterpretation.cs
index a838844f160..6284bfdf816 100644
--- a/src/Build/Graph/ProjectInterpretation.cs
+++ b/src/Build/Graph/ProjectInterpretation.cs
@@ -29,6 +29,10 @@ internal sealed class ProjectInterpretation
         private const string InnerBuildReferenceItemName = "_ProjectSelfReference";
         internal static string TransitiveReferenceItemName = "_TransitiveProjectReference";
         internal const string AddTransitiveProjectReferencesInStaticGraphPropertyName = "AddTransitiveProjectReferencesInStaticGraph";
+        private const string PlatformLookupTableMetadataName = "PlatformLookupTable";
+        private const string PlatformMetadataName = "Platform";
+        private const string PlatformsMetadataName = "Platforms";
+        private const string EnableDynamicPlatformResolutionMetadataName = "EnableDynamicPlatformResolution";
 
         private static readonly char[] PropertySeparator = MSBuildConstants.SemicolonChar;
 
@@ -59,7 +63,7 @@ public ReferenceInfo(ConfigurationMetadata referenceConfiguration, ProjectItemIn
             }
         }
 
-        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance)
+        public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection _projectCollection, ProjectGraph.ProjectInstanceFactoryFunc _projectInstanceFactory)
         {
             IEnumerable<ProjectItemInstance> projectReferenceItems;
             IEnumerable<GlobalPropertiesModifier> globalPropertiesModifiers = null;
@@ -101,13 +105,30 @@ public IEnumerable<ReferenceInfo> GetReferences(ProjectInstance requesterInstanc
                 var requesterPlatform = "";
                 var requesterPlatformLookupTable = "";
 
-                if (ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue("EnableDynamicPlatformResolution")))
+                if ( !projectReferenceItem.HasMetadata(SetPlatformMetadataName) && ConversionUtilities.ValidBooleanTrue(requesterInstance.GetPropertyValue(EnableDynamicPlatformResolutionMetadataName)))
                 {
                     requesterPlatform = requesterInstance.GetPropertyValue("Platform");
                     requesterPlatformLookupTable = requesterInstance.GetPropertyValue("PlatformLookupTable");
+
+                    var  projectInstance = _projectInstanceFactory(
+                        projectReferenceFullPath,
+                        null, // Platform negotiation requires an evaluation with no global properties first
+                        _projectCollection);
+
+                    var selectedPlatform = PlatformNegotiation.GetNearestPlatform(projectInstance.GetPropertyValue(PlatformMetadataName), projectInstance.GetPropertyValue(PlatformsMetadataName), projectInstance.GetPropertyValue(PlatformLookupTableMetadataName), requesterInstance.GetPropertyValue(PlatformLookupTableMetadataName), projectInstance.FullPath, requesterInstance.GetPropertyValue(PlatformMetadataName));
+
+                    if (selectedPlatform.Equals(String.Empty))
+                    {
+                        referenceGlobalProperties.Remove(PlatformMetadataName);
+                    }
+                    else
+                    {
+                        var platformPropertyInstance = ProjectPropertyInstance.Create(PlatformMetadataName, selectedPlatform);
+                        referenceGlobalProperties[PlatformMetadataName] = platformPropertyInstance;
+                    }
                 }
 
-                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties, requesterPlatform, requesterPlatformLookupTable, projectReferenceItem.HasMetadata("SetPlatform"));
+                var referenceConfig = new ConfigurationMetadata(projectReferenceFullPath, referenceGlobalProperties);
 
                 yield return new ReferenceInfo(referenceConfig, projectReferenceItem);
             }
diff --git a/src/Build/Instance/ProjectInstance.cs b/src/Build/Instance/ProjectInstance.cs
index 0237d7f0ad8..94344843b96 100644
--- a/src/Build/Instance/ProjectInstance.cs
+++ b/src/Build/Instance/ProjectInstance.cs
@@ -1475,10 +1475,10 @@ IItemDefinition<ProjectMetadataInstance> IEvaluatorData<ProjectPropertyInstance,
         /// immutable if we are immutable.
         /// Only called during evaluation, so does not check for immutability.
         /// </summary>
-        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable, LoggingContext loggingContext)
+        ProjectPropertyInstance IEvaluatorData<ProjectPropertyInstance, ProjectItemInstance, ProjectMetadataInstance, ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable)
         {
             // Mutability not verified as this is being populated during evaluation
-            ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable, isEnvironmentVariable, loggingContext);
+            ProjectPropertyInstance property = ProjectPropertyInstance.Create(name, evaluatedValueEscaped, mayBeReserved, _isImmutable);
             _properties.Set(property);
             return property;
         }
@@ -2966,7 +2966,7 @@ private void CreatePropertiesSnapshot(ICollection<ProjectProperty> properties, b
             {
                 // Allow reserved property names, since this is how they are added to the project instance. 
                 // The caller has prevented users setting them themselves.
-                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable, property.IsEnvironmentProperty);
+                ProjectPropertyInstance instance = ProjectPropertyInstance.Create(property.Name, ((IProperty)property).EvaluatedValueEscaped, true /* MAY be reserved name */, isImmutable);
                 _properties.Set(instance);
             }
         }
diff --git a/src/Build/Instance/ProjectPropertyInstance.cs b/src/Build/Instance/ProjectPropertyInstance.cs
index c6fd6293e5d..e935b611067 100644
--- a/src/Build/Instance/ProjectPropertyInstance.cs
+++ b/src/Build/Instance/ProjectPropertyInstance.cs
@@ -10,8 +10,6 @@
 using Microsoft.Build.BackEnd;
 
 using ReservedPropertyNames = Microsoft.Build.Internal.ReservedPropertyNames;
-using Microsoft.Build.BackEnd.Logging;
-using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -86,21 +84,8 @@ public string EvaluatedValue
         /// Setter assumes caller has protected global properties, if necessary.
         /// </summary>
         [DebuggerBrowsable(DebuggerBrowsableState.Never)]
-        string IProperty.EvaluatedValueEscaped
-        {
-            get
-            {
-                if (this is EnvironmentDerivedProjectPropertyInstance envProperty && envProperty.loggingContext?.IsValid == true && !envProperty._loggedEnvProperty)
-                {
-                    EnvironmentVariableReadEventArgs args = new(Name, _escapedValue);
-                    args.BuildEventContext = envProperty.loggingContext.BuildEventContext;
-                    envProperty.loggingContext.LogBuildEvent(args);
-                    envProperty._loggedEnvProperty = true;
-                }
-
-                return _escapedValue;
-            }
-        }
+        string IProperty.EvaluatedValueEscaped => _escapedValue;
+
         /// <summary>
         /// Implementation of IKeyed exposing the property name
         /// </summary>
@@ -197,9 +182,9 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue,
         /// This flags should ONLY be set by the evaluator or by cloning; after the ProjectInstance is created, they must be illegal.
         /// If name is invalid or reserved, throws ArgumentException.
         /// </summary>
-        internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable, bool isEnvironmentProperty = false, LoggingContext loggingContext = null)
+        internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable)
         {
-            return Create(name, escapedValue, mayBeReserved, null, isImmutable, isEnvironmentProperty, loggingContext);
+            return Create(name, escapedValue, mayBeReserved, null, isImmutable);
         }
 
         /// <summary>
@@ -227,7 +212,7 @@ internal static ProjectPropertyInstance Create(string name, string escapedValue,
         /// </summary>
         internal static ProjectPropertyInstance Create(ProjectPropertyInstance that)
         {
-            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: that.IsImmutable, that is EnvironmentDerivedProjectPropertyInstance);
+            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: that.IsImmutable);
         }
 
         /// <summary>
@@ -236,7 +221,7 @@ internal static ProjectPropertyInstance Create(ProjectPropertyInstance that)
         /// </summary>
         internal static ProjectPropertyInstance Create(ProjectPropertyInstance that, bool isImmutable)
         {
-            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: isImmutable, that is EnvironmentDerivedProjectPropertyInstance);
+            return Create(that._name, that._escapedValue, mayBeReserved: true /* already validated */, isImmutable: isImmutable);
         }
 
         /// <summary>
@@ -293,7 +278,7 @@ internal ProjectPropertyElement ToProjectPropertyElement(ProjectElementContainer
         /// as it should never be needed for any subsequent messages, and is just extra bulk.
         /// Inherits mutability from project if any.
         /// </summary>
-        private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable, bool isEnvironmentProperty = false, LoggingContext loggingContext = null)
+        private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable)
         {
             // Does not check immutability as this is only called during build (which is already protected) or evaluation
             ErrorUtilities.VerifyThrowArgumentNull(escapedValue, nameof(escapedValue));
@@ -310,10 +295,11 @@ private static ProjectPropertyInstance Create(string name, string escapedValue,
                 XmlUtilities.VerifyThrowProjectValidElementName(name, location);
             }
 
-            ProjectPropertyInstance instance = isEnvironmentProperty ? new EnvironmentDerivedProjectPropertyInstance(name, escapedValue, loggingContext) :
-                isImmutable ? new ProjectPropertyInstanceImmutable(name, escapedValue) :
-                new ProjectPropertyInstance(name, escapedValue);
-            return instance;
+            if (isImmutable)
+            {
+                return new ProjectPropertyInstanceImmutable(name, escapedValue);
+            }
+            return new ProjectPropertyInstance(name, escapedValue);
         }
 
         /// <summary>
@@ -341,27 +327,5 @@ internal ProjectPropertyInstanceImmutable(string name, string escapedValue)
             /// </remarks>
             public override bool IsImmutable => true;
         }
-
-        internal class EnvironmentDerivedProjectPropertyInstance : ProjectPropertyInstance
-        {
-            internal EnvironmentDerivedProjectPropertyInstance(string name, string escapedValue, LoggingContext loggingContext)
-                : base(name, escapedValue)
-            {
-                this.loggingContext = loggingContext;
-            }
-
-            /// <summary>
-            /// Whether this object can be changed. An immutable object cannot be made mutable.
-            /// </summary>
-            /// <remarks>
-            /// The environment is captured at the start of the build, so environment-derived
-            /// properties can't change.
-            /// </remarks>
-            public override bool IsImmutable => true;
-
-            internal bool _loggedEnvProperty = false;
-
-            internal LoggingContext loggingContext;
-        }
     }
 }
diff --git a/src/Build/Instance/ReflectableTaskPropertyInfo.cs b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
index 571ba866933..66c846646dc 100644
--- a/src/Build/Instance/ReflectableTaskPropertyInfo.cs
+++ b/src/Build/Instance/ReflectableTaskPropertyInfo.cs
@@ -52,6 +52,22 @@ internal ReflectableTaskPropertyInfo(PropertyInfo propertyInfo)
             _propertyInfo = propertyInfo;
         }
 
+        /// <summary>
+        /// Initializes a new <see cref="ReflectableTaskPropertyInfo"/> with three precomputed parameters. This is specifically
+        /// used with MetadataLoadContext, as these parameters cannot be computed for the property type passed in directly but
+        /// rather the relevant base type.
+        /// </summary>
+        internal ReflectableTaskPropertyInfo(PropertyInfo propertyInfo, bool output, bool required, bool isAssignableToITaskItemType)
+            : base(
+            propertyInfo.Name,
+            propertyInfo.PropertyType,
+            output,
+            required)
+        {
+            _propertyInfo = propertyInfo;
+            IsAssignableToITask = isAssignableToITaskItemType;
+        }
+
         /// <summary>
         /// Gets or sets the reflection-produced PropertyInfo.
         /// </summary>
diff --git a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
index 37433613a00..bc191a256a9 100644
--- a/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
+++ b/src/Build/Instance/TaskFactories/AssemblyTaskFactory.cs
@@ -3,6 +3,7 @@
 
 using System;
 using System.Collections.Generic;
+using System.Linq;
 using System.Reflection;
 #if FEATURE_APPDOMAIN
 using System.Threading.Tasks;
@@ -149,14 +150,7 @@ public bool Initialize(string taskName, IDictionary<string, string> factoryIdent
         /// </summary>
         public TaskPropertyInfo[] GetTaskParameters()
         {
-            PropertyInfo[] infos = _loadedType.Type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
-            var propertyInfos = new TaskPropertyInfo[infos.Length];
-            for (int i = 0; i < infos.Length; i++)
-            {
-                propertyInfos[i] = new ReflectableTaskPropertyInfo(infos[i]);
-            }
-
-            return propertyInfos;
+            return _loadedType.Properties;
         }
 
         /// <summary>
@@ -279,7 +273,7 @@ string taskProjectFile
             {
                 ErrorUtilities.VerifyThrowArgumentLength(taskName, nameof(taskName));
                 _taskName = taskName;
-                _loadedType = _typeLoader.Load(taskName, loadInfo);
+                _loadedType = _typeLoader.Load(taskName, loadInfo, _taskHostFactoryExplicitlyRequested);
                 ProjectErrorUtilities.VerifyThrowInvalidProject(_loadedType != null, elementLocation, "TaskLoadFailure", taskName, loadInfo.AssemblyLocation, String.Empty);
             }
             catch (TargetInvocationException e)
diff --git a/src/Build/Instance/TaskRegistry.cs b/src/Build/Instance/TaskRegistry.cs
index c7169a09dad..458c6956422 100644
--- a/src/Build/Instance/TaskRegistry.cs
+++ b/src/Build/Instance/TaskRegistry.cs
@@ -436,7 +436,7 @@ ElementLocation elementLocation
                         targetLoggingContext.LogComment(MessageImportance.Low, "TaskFoundFromFactory", taskName, taskFactory.Name);
                     }
 
-                    if (taskFactory.TaskFactoryLoadedType.HasSTAThreadAttribute())
+                    if (taskFactory.TaskFactoryLoadedType.HasSTAThreadAttribute)
                     {
                         targetLoggingContext.LogComment(MessageImportance.Low, "TaskNeedsSTA", taskName);
                     }
diff --git a/src/Build/Logging/BaseConsoleLogger.cs b/src/Build/Logging/BaseConsoleLogger.cs
index ea87f587b70..b17d74baa50 100644
--- a/src/Build/Logging/BaseConsoleLogger.cs
+++ b/src/Build/Logging/BaseConsoleLogger.cs
@@ -28,38 +28,8 @@ namespace Microsoft.Build.BackEnd.Logging
 
     internal abstract class BaseConsoleLogger : INodeLogger
     {
-        /// <summary>
-        /// When set, we'll try reading background color.
-        /// </summary>
-        private static bool _supportReadingBackgroundColor = true;
-
         #region Properties
 
-        /// <summary>
-        /// Some platforms do not allow getting current background color. There
-        /// is not way to check, but not-supported exception is thrown. Assume
-        /// black, but don't crash.
-        /// </summary>
-        internal static ConsoleColor BackgroundColor
-        {
-            get
-            {
-                if (_supportReadingBackgroundColor)
-                {
-                    try
-                    {
-                        return Console.BackgroundColor;
-                    }
-                    catch (PlatformNotSupportedException)
-                    {
-                        _supportReadingBackgroundColor = false;
-                    }
-                }
-
-                return ConsoleColor.Black;
-            }
-        }
-
         /// <summary>
         /// Gets or sets the level of detail to show in the event log.
         /// </summary>
@@ -123,6 +93,10 @@ public void ParseParameters()
         /// <remarks>Uses CurrentCulture for display purposes</remarks>
         internal class DictionaryEntryKeyComparer : IComparer<DictionaryEntry>
         {
+            public static DictionaryEntryKeyComparer Instance { get; } = new();
+
+            private DictionaryEntryKeyComparer() { }
+
             public int Compare(DictionaryEntry a, DictionaryEntry b)
             {
                 return string.Compare((string) a.Key, (string) b.Key, StringComparison.CurrentCultureIgnoreCase);
@@ -314,16 +288,7 @@ internal void IsRunningWithCharacterFileType()
 
             if (NativeMethodsShared.IsWindows)
             {
-                // Get the std out handle
-                IntPtr stdHandle = NativeMethodsShared.GetStdHandle(NativeMethodsShared.STD_OUTPUT_HANDLE);
-
-                if (stdHandle != NativeMethods.InvalidHandle)
-                {
-                    uint fileType = NativeMethodsShared.GetFileType(stdHandle);
-
-                    // The std out is a char type(LPT or Console)
-                    runningWithCharacterFileType = (fileType == NativeMethodsShared.FILE_TYPE_CHAR);
-                }
+                runningWithCharacterFileType = ConsoleConfiguration.OutputIsScreen;
             }
         }
 
@@ -367,7 +332,7 @@ internal static void SetColor(ConsoleColor c)
         {
             try
             {
-                Console.ForegroundColor = TransformColor(c, BackgroundColor);
+                Console.ForegroundColor = TransformColor(c, ConsoleConfiguration.BackgroundColor);
             }
             catch (IOException)
             {
@@ -480,7 +445,7 @@ internal void InitializeConsoleMethods(LoggerVerbosity logverbosity, WriteHandle
 
             try
             {
-                ConsoleColor c = BackgroundColor;
+                ConsoleColor c = ConsoleConfiguration.BackgroundColor;
             }
             catch (IOException)
             {
@@ -559,9 +524,9 @@ internal List<DictionaryEntry> ExtractPropertyList(IEnumerable properties)
             // Gather a sorted list of all the properties.
             var list = new List<DictionaryEntry>(properties.FastCountOrZero());
 
-            Internal.Utilities.EnumerateProperties(properties, kvp => list.Add(new DictionaryEntry(kvp.Key, kvp.Value)));
+            Internal.Utilities.EnumerateProperties(properties, list, static (list, kvp) => list.Add(new DictionaryEntry(kvp.Key, kvp.Value)));
 
-            list.Sort(new DictionaryEntryKeyComparer());
+            list.Sort(DictionaryEntryKeyComparer.Instance);
             return list;
         }
 
diff --git a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
index 1089888ff12..7c0fe5bfc58 100644
--- a/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
+++ b/src/Build/Logging/BinaryLogger/BuildEventArgsWriter.cs
@@ -4,14 +4,18 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.Globalization;
 using System.IO;
+using System.Linq;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Collections;
 using Microsoft.Build.Evaluation;
+using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Framework.Profiler;
+using Microsoft.Build.Internal;
 using Microsoft.Build.Shared;
 
 #nullable disable
@@ -247,14 +251,7 @@ private void Write(BuildStartedEventArgs e)
         {
             Write(BinaryLogRecordKind.BuildStarted);
             WriteBuildEventArgsFields(e);
-            if (Traits.Instance.LogAllEnvironmentVariables)
-            {
-                Write(e.BuildEnvironment);
-            }
-            else
-            {
-                Write(0);
-            }
+            Write(e.BuildEnvironment);
         }
 
         private void Write(BuildFinishedEventArgs e)
@@ -944,7 +941,7 @@ private void WriteProperties(IEnumerable properties)
                 return;
             }
 
-            Internal.Utilities.EnumerateProperties(properties, kvp => nameValueListBuffer.Add(kvp));
+            Internal.Utilities.EnumerateProperties(properties, nameValueListBuffer, static (list, kvp) => list.Add(kvp));
 
             WriteNameValueList();
 
diff --git a/src/Build/Logging/ConsoleConfiguration.cs b/src/Build/Logging/ConsoleConfiguration.cs
new file mode 100644
index 00000000000..a826d0c24e5
--- /dev/null
+++ b/src/Build/Logging/ConsoleConfiguration.cs
@@ -0,0 +1,63 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable disable
+using System;
+
+namespace Microsoft.Build.BackEnd.Logging;
+
+/// <summary>
+/// Target console configuration.
+/// If console output is redirected to other process console, like for example MSBuild Server does,
+///    we need to know property of target/final console at which our output will be rendered.
+/// If console is rendered at current process Console, we grab properties from Console and/or by WinAPI.
+/// </summary>
+internal static class ConsoleConfiguration
+{
+    /// <summary>
+    /// Get or set current target console configuration provider.
+    /// </summary>
+    public static IConsoleConfiguration Provider
+    {
+        get { return Instance.s_instance; }
+        set { Instance.s_instance = value; }
+    }
+
+    private static class Instance
+    {
+        // Explicit static constructor to tell C# compiler
+        // not to mark type as beforefieldinit
+        static Instance()
+        {
+        }
+
+        internal static IConsoleConfiguration s_instance = new InProcessConsoleConfiguration();
+    }
+
+    /// <summary>
+    /// Buffer width of destination Console.
+    /// Console loggers are supposed, on Windows OS, to be wrapping to avoid output trimming.
+    /// -1 console buffer width can't be obtained.
+    /// </summary>
+    public static int BufferWidth => Provider.BufferWidth;
+
+    /// <summary>
+    /// True if console output accept ANSI colors codes.
+    /// False if output is redirected to non screen type such as file or nul.
+    /// </summary>
+    public static bool AcceptAnsiColorCodes => Provider.AcceptAnsiColorCodes;
+
+    /// <summary>
+    /// Background color of client console, -1 if not detectable
+    /// Some platforms do not allow getting current background color. There
+    /// is not way to check, but not-supported exception is thrown. Assume
+    /// black, but don't crash.
+    /// </summary>
+    public static ConsoleColor BackgroundColor => Provider.BackgroundColor;
+
+    /// <summary>
+    /// True if console output is screen. It is expected that non screen output is post-processed and often does not need wrapping and coloring.
+    /// False if output is redirected to non screen type such as file or nul.
+    /// </summary>
+    public static bool OutputIsScreen => Provider.OutputIsScreen;
+}
diff --git a/src/Build/Logging/ConsoleLogger.cs b/src/Build/Logging/ConsoleLogger.cs
index 543667811bf..d4320ced186 100644
--- a/src/Build/Logging/ConsoleLogger.cs
+++ b/src/Build/Logging/ConsoleLogger.cs
@@ -3,6 +3,7 @@
 
 using System;
 
+using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 
@@ -109,6 +110,7 @@ private void InitializeBaseConsoleLogger()
             bool useMPLogger = false;
             bool disableConsoleColor = false;
             bool forceConsoleColor = false;
+            bool preferConsoleColor = false;
             if (!string.IsNullOrEmpty(_parameters))
             {
                 string[] parameterComponents = _parameters.Split(BaseConsoleLogger.parameterDelimiters);
@@ -132,10 +134,15 @@ private void InitializeBaseConsoleLogger()
                     {
                         forceConsoleColor = true;
                     }
+                    if (string.Equals(param, "PREFERCONSOLECOLOR", StringComparison.OrdinalIgnoreCase))
+                    {
+                        // Use ansi color codes if current target console do support it
+                        preferConsoleColor = ConsoleConfiguration.AcceptAnsiColorCodes;
+                    }
                 }
             }
 
-            if (forceConsoleColor)
+            if (forceConsoleColor || (!disableConsoleColor && preferConsoleColor))
             {
                 _colorSet = BaseConsoleLogger.SetColorAnsi;
                 _colorReset = BaseConsoleLogger.ResetColorAnsi;
diff --git a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
index 0d97dd41083..64b994b85e2 100644
--- a/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
+++ b/src/Build/Logging/DistributedLoggers/ConfigurableForwardingLogger.cs
@@ -77,13 +77,12 @@ public int NodeId
         /// </summary>
         private void InitializeForwardingTable()
         {
-            _forwardingTable = new Dictionary<string, int>(17, StringComparer.OrdinalIgnoreCase);
+            _forwardingTable = new Dictionary<string, int>(16, StringComparer.OrdinalIgnoreCase);
             _forwardingTable[BuildStartedEventDescription] = 0;
             _forwardingTable[BuildFinishedEventDescription] = 0;
             _forwardingTable[ProjectStartedEventDescription] = 0;
             _forwardingTable[ProjectFinishedEventDescription] = 0;
-            _forwardingTable[ProjectEvaluationStartedEventDescription] = 0;
-            _forwardingTable[ProjectEvaluationFinishedEventDescription] = 0;
+            _forwardingTable[ProjectEvaluationEventDescription] = 0;
             _forwardingTable[TargetStartedEventDescription] = 0;
             _forwardingTable[TargetFinishedEventDescription] = 0;
             _forwardingTable[TaskStartedEventDescription] = 0;
@@ -127,7 +126,7 @@ private void ParseParameters()
                     // will be set on ProjectStarted or ProjectEvaluationFinished because we don't know
                     // all of the other loggers that will be attached. So turn both on.
                     _forwardingTable[ProjectStartedEventDescription] = 1;
-                    _forwardingTable[ProjectEvaluationFinishedEventDescription] = 1;
+                    _forwardingTable[ProjectEvaluationEventDescription] = 1;
                 }
             }
         }
@@ -145,6 +144,12 @@ private void ApplyParameter(string parameterName)
                 _forwardingSetFromParameters = true;
                 _forwardingTable[parameterName] = 1;
             }
+            else if (String.Equals(parameterName, ProjectEvaluationStartedEventDescription, StringComparison.OrdinalIgnoreCase) ||
+                String.Equals(parameterName, ProjectEvaluationFinishedEventDescription, StringComparison.OrdinalIgnoreCase))
+            {
+                _forwardingSetFromParameters = true;
+                _forwardingTable[ProjectEvaluationEventDescription] = 1;
+            }
 
             // If any of the following parameters are set, we will make sure we forward the events
             // necessary for the central logger to emit the requested information
@@ -243,8 +248,7 @@ private void SetForwardingBasedOnVerbosity()
             if (IsVerbosityAtLeast(LoggerVerbosity.Diagnostic))
             {
                 _forwardingTable[CustomEventDescription] = 1;
-                _forwardingTable[ProjectEvaluationStartedEventDescription] = 1;
-                _forwardingTable[ProjectEvaluationFinishedEventDescription] = 1;
+                _forwardingTable[ProjectEvaluationEventDescription] = 1;
             }
 
             if (_showSummary)
@@ -263,8 +267,7 @@ private void SetForwardingBasedOnVerbosity()
                 _forwardingTable[TargetFinishedEventDescription] = 1;
                 _forwardingTable[ProjectStartedEventDescription] = 1;
                 _forwardingTable[ProjectFinishedEventDescription] = 1;
-                _forwardingTable[ProjectEvaluationStartedEventDescription] = 1;
-                _forwardingTable[ProjectEvaluationFinishedEventDescription] = 1;
+                _forwardingTable[ProjectEvaluationEventDescription] = 1;
             }
 
             if (_showCommandLine)
@@ -487,12 +490,7 @@ private void CustomEventHandler(object sender, CustomBuildEventArgs e)
 
         private void BuildStatusHandler(object sender, BuildStatusEventArgs e)
         {
-            if (_forwardingTable[ProjectEvaluationStartedEventDescription] == 1 && e is ProjectEvaluationStartedEventArgs)
-            {
-                ForwardToCentralLogger(e);
-            }
-
-            if (_forwardingTable[ProjectEvaluationFinishedEventDescription] == 1 && e is ProjectEvaluationFinishedEventArgs)
+            if (_forwardingTable[ProjectEvaluationEventDescription] == 1 && (e is ProjectEvaluationStartedEventArgs || e is ProjectEvaluationFinishedEventArgs))
             {
                 ForwardToCentralLogger(e);
             }
@@ -542,6 +540,7 @@ private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity)
         private const string BuildFinishedEventDescription = "BUILDFINISHEDEVENT";
         private const string ProjectStartedEventDescription = "PROJECTSTARTEDEVENT";
         private const string ProjectFinishedEventDescription = "PROJECTFINISHEDEVENT";
+        private const string ProjectEvaluationEventDescription = "PROJECTEVALUATIONEVENT";
         private const string ProjectEvaluationStartedEventDescription = "PROJECTEVALUATIONSTARTEDEVENT";
         private const string ProjectEvaluationFinishedEventDescription = "PROJECTEVALUATIONFINISHEDEVENT";
         private const string TargetStartedEventDescription = "TARGETSTARTEDEVENT";
diff --git a/src/Build/Logging/IConsoleConfiguration.cs b/src/Build/Logging/IConsoleConfiguration.cs
new file mode 100644
index 00000000000..86ff9c4ea47
--- /dev/null
+++ b/src/Build/Logging/IConsoleConfiguration.cs
@@ -0,0 +1,40 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable disable
+using System;
+
+namespace Microsoft.Build.BackEnd.Logging;
+
+/// <summary>
+/// Console configuration needed for proper Console logging.
+/// </summary>
+internal interface IConsoleConfiguration
+{
+    /// <summary>
+    /// Buffer width of destination Console.
+    /// Console loggers are supposed, on Windows OS, to be wrapping to avoid output trimming.
+    /// -1 console buffer width can't be obtained.
+    /// </summary>
+    int BufferWidth { get; }
+
+    /// <summary>
+    /// True if console output accept ANSI colors codes.
+    /// False if output is redirected to non screen type such as file or nul.
+    /// </summary>
+    bool AcceptAnsiColorCodes { get; }
+
+    /// <summary>
+    /// True if console output is screen. It is expected that non screen output is post-processed and often does not need wrapping and coloring.
+    /// False if output is redirected to non screen type such as file or nul.
+    /// </summary>
+    bool OutputIsScreen { get; }
+
+    /// <summary>
+    /// Background color of client console, -1 if not detectable
+    /// Some platforms do not allow getting current background color. There
+    /// is not way to check, but not-supported exception is thrown. Assume
+    /// black, but don't crash.
+    /// </summary>
+    ConsoleColor BackgroundColor { get; }
+}
diff --git a/src/Build/Logging/InProcessConsoleConfiguration.cs b/src/Build/Logging/InProcessConsoleConfiguration.cs
new file mode 100644
index 00000000000..d070e246773
--- /dev/null
+++ b/src/Build/Logging/InProcessConsoleConfiguration.cs
@@ -0,0 +1,99 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable disable
+using System;
+using System.Diagnostics;
+
+namespace Microsoft.Build.BackEnd.Logging;
+
+/// <summary>
+/// Console configuration of current process Console.
+/// </summary>
+internal class InProcessConsoleConfiguration : IConsoleConfiguration
+{
+    /// <summary>
+    /// When set, we'll try reading background color.
+    /// </summary>
+    private static bool s_supportReadingBackgroundColor = true;
+
+    public int BufferWidth => Console.BufferWidth;
+
+    public bool AcceptAnsiColorCodes
+    {
+        get
+        {
+            bool acceptAnsiColorCodes = false;
+            if (NativeMethodsShared.IsWindows && !Console.IsOutputRedirected)
+            {
+                try
+                {
+                    IntPtr stdOut = NativeMethodsShared.GetStdHandle(NativeMethodsShared.STD_OUTPUT_HANDLE);
+                    if (NativeMethodsShared.GetConsoleMode(stdOut, out uint consoleMode))
+                    {
+                        acceptAnsiColorCodes = (consoleMode & NativeMethodsShared.ENABLE_VIRTUAL_TERMINAL_PROCESSING) != 0;
+                    }
+                }
+                catch (Exception ex)
+                {
+                    Debug.Assert(false, $"MSBuild client warning: problem during enabling support for VT100: {ex}.");
+                }
+            }
+            else
+            {
+                // On posix OSes we expect console always supports VT100 coloring unless it is redirected
+                acceptAnsiColorCodes = !Console.IsOutputRedirected;
+            }
+
+            return acceptAnsiColorCodes;
+        }
+    }
+
+    public ConsoleColor BackgroundColor
+    {
+        get
+        {
+            if (s_supportReadingBackgroundColor)
+            {
+                try
+                {
+                    return Console.BackgroundColor;
+                }
+                catch (PlatformNotSupportedException)
+                {
+                    s_supportReadingBackgroundColor = false;
+                }
+            }
+
+            return ConsoleColor.Black;
+        }
+    }
+
+    public bool OutputIsScreen
+    {
+        get
+        {
+            bool isScreen = false;
+
+            if (NativeMethodsShared.IsWindows)
+            {
+                // Get the std out handle
+                IntPtr stdHandle = NativeMethodsShared.GetStdHandle(NativeMethodsShared.STD_OUTPUT_HANDLE);
+
+                if (stdHandle != NativeMethods.InvalidHandle)
+                {
+                    uint fileType = NativeMethodsShared.GetFileType(stdHandle);
+
+                    // The std out is a char type(LPT or Console)
+                    isScreen = fileType == NativeMethodsShared.FILE_TYPE_CHAR;
+                }
+            }
+            else
+            {
+                isScreen = !Console.IsOutputRedirected;
+            }
+
+            return isScreen;
+        }
+    }
+}
diff --git a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
index 4c147958cb5..1833201110c 100644
--- a/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
+++ b/src/Build/Logging/ParallelLogger/ParallelConsoleLogger.cs
@@ -88,7 +88,7 @@ private void CheckIfOutputSupportsAlignment()
                     // Get the size of the console buffer so messages can be formatted to the console width
                     try
                     {
-                        _bufferWidth = Console.BufferWidth;
+                        _bufferWidth = ConsoleConfiguration.BufferWidth;
                         _alignMessages = true;
                     }
                     catch (Exception)
@@ -1204,21 +1204,16 @@ private void DisplayDeferredStartedEvents(BuildEventContext e)
         /// </summary>
         private void PrintMessage(BuildMessageEventArgs e, bool lightenText)
         {
-            string nonNullMessage = null;
-
-            if (e is EnvironmentVariableReadEventArgs environmentPropertyReadEventArgs)
-            {
-                nonNullMessage = ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentPropertyReadEventArgs.EnvironmentVariableName, e.Message);
-            }
+            string nonNullMessage;
 
             // Include file information if present.
             if (e.File != null)
             {
-                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e), nonNullMessage);
+                nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile, FindLogOutputProperties(e));
             }
             else
             {
-                nonNullMessage ??= e.Message ?? string.Empty;
+                nonNullMessage = e.Message ?? string.Empty;
             }
 
             int prefixAdjustment = 0;
@@ -1710,12 +1705,9 @@ internal void AddEventStarted(string projectTargetNames, BuildEventContext build
                     entryPoint.MessageIndentLevel = 7;
                 }
 
-                if (_startedEvent == null)
-                {
-                    _startedEvent = comparer == null
-                        ? new Dictionary<BuildEventContext, object>()
-                        : new Dictionary<BuildEventContext, object>(comparer);
-                }
+                _startedEvent ??= comparer == null
+                    ? new Dictionary<BuildEventContext, object>()
+                    : new Dictionary<BuildEventContext, object>(comparer);
 
                 if (!_startedEvent.ContainsKey(buildEventContext))
                 {
diff --git a/src/Build/Logging/SerialConsoleLogger.cs b/src/Build/Logging/SerialConsoleLogger.cs
index 4404357b05e..e677526406b 100644
--- a/src/Build/Logging/SerialConsoleLogger.cs
+++ b/src/Build/Logging/SerialConsoleLogger.cs
@@ -511,15 +511,18 @@ public override void MessageHandler(object sender, BuildMessageEventArgs e)
                     setColor(ConsoleColor.DarkGray);
                 }
 
-                string nonNullMessage = e is EnvironmentVariableReadEventArgs environmentDerivedProperty ?
-                    ResourceUtilities.FormatResourceStringIgnoreCodeAndKeyword("EnvironmentDerivedPropertyRead", environmentDerivedProperty.EnvironmentVariableName, e.Message)
-                    : e.Message ?? String.Empty;
+                string nonNullMessage;
 
                 // Include file information if present.
                 if (e.File != null)
                 {
                     nonNullMessage = EventArgsFormatting.FormatEventMessage(e, showProjectFile);
                 }
+                else
+                {
+                    // null messages are ok -- treat as blank line
+                    nonNullMessage = e.Message ?? String.Empty;
+                }
 
                 WriteLinePretty(nonNullMessage);
 
diff --git a/src/Build/Logging/TargetConsoleConfiguration.cs b/src/Build/Logging/TargetConsoleConfiguration.cs
new file mode 100644
index 00000000000..57f92dad1c5
--- /dev/null
+++ b/src/Build/Logging/TargetConsoleConfiguration.cs
@@ -0,0 +1,57 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+#nullable disable
+using System;
+
+namespace Microsoft.Build.BackEnd.Logging;
+
+/// <summary>
+/// Console configuration of target Console at which we will render output.
+/// It is supposed to be Console from other process to which output from this process will be redirected.
+/// </summary>
+internal class TargetConsoleConfiguration : IConsoleConfiguration, ITranslatable
+{
+    private int _bufferWidth;
+    private bool _acceptAnsiColorCodes;
+    private bool _outputIsScreen;
+    private ConsoleColor _backgroundColor;
+
+    public TargetConsoleConfiguration(int bufferWidth, bool acceptAnsiColorCodes, bool outputIsScreen, ConsoleColor backgroundColor)
+    {
+        _bufferWidth = bufferWidth;
+        _acceptAnsiColorCodes = acceptAnsiColorCodes;
+        _outputIsScreen = outputIsScreen;
+        _backgroundColor = backgroundColor;
+    }
+
+    /// <summary>
+    /// Constructor for deserialization
+    /// </summary>
+    private TargetConsoleConfiguration()
+    {
+    }
+
+    public int BufferWidth => _bufferWidth;
+
+    public bool AcceptAnsiColorCodes => _acceptAnsiColorCodes;
+
+    public bool OutputIsScreen => _outputIsScreen;
+
+    public ConsoleColor BackgroundColor => _backgroundColor;
+
+    public void Translate(ITranslator translator)
+    {
+        translator.Translate(ref _bufferWidth);
+        translator.Translate(ref _acceptAnsiColorCodes);
+        translator.Translate(ref _outputIsScreen);
+        translator.TranslateEnum(ref _backgroundColor, (int)_backgroundColor);
+    }
+
+    internal static TargetConsoleConfiguration FactoryForDeserialization(ITranslator translator)
+    {
+        TargetConsoleConfiguration configuration = new();
+        configuration.Translate(translator);
+        return configuration;
+    }
+}
diff --git a/src/Build/Microsoft.Build.csproj b/src/Build/Microsoft.Build.csproj
index 30c38da91e5..cb7786b3008 100644
--- a/src/Build/Microsoft.Build.csproj
+++ b/src/Build/Microsoft.Build.csproj
@@ -35,6 +35,7 @@
     <PackageReference Include="System.Text.Json" />
 
     <PackageReference Include="System.Reflection.Metadata" Condition="'$(MonoBuild)' == 'true'" />
+    <PackageReference Include="System.Reflection.MetadataLoadContext" />
 
     <PackageReference Include="Microsoft.IO.Redist" Condition="'$(FeatureMSIORedist)' == 'true'" />
   </ItemGroup>
@@ -146,12 +147,31 @@
     <Compile Include="BackEnd\BuildManager\BuildParameters.cs" />
     <Compile Include="BackEnd\BuildManager\CacheSerialization.cs" />
     <Compile Include="BackEnd\BuildManager\CacheAggregator.cs" />
+    <Compile Include="BackEnd\Client\MSBuildClientPacketPump.cs" />
+    <Compile Include="BackEnd\Client\MSBuildClientExitType.cs" />
+    <Compile Include="BackEnd\Client\MSBuildClientExitResult.cs" />
+    <Compile Include="BackEnd\Client\MSBuildClient.cs" />
     <Compile Include="BackEnd\Components\Caching\ConfigCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\Caching\ResultsCacheWithOverride.cs" />
     <Compile Include="BackEnd\Components\ProjectCache\*.cs" />
+    <Compile Include="BackEnd\Components\Communications\CurrentHost.cs" />
+    <Compile Include="BackEnd\Components\Communications\ServerNodeEndpointOutOfProc.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\SdkResolverException.cs" />
     <Compile Include="BackEnd\Components\SdkResolution\TranslationHelpers.cs" />
     <Compile Include="FileSystem\*.cs" />
+    <Compile Include="Utilities\ReaderWriterLockSlimExtensions.cs" />
+    <Compile Include="BackEnd\Node\ConsoleOutput.cs" />
+    <Compile Include="BackEnd\Node\PartialBuildTelemetry.cs" />
+    <Compile Include="BackEnd\Node\ServerNamedMutex.cs" />
+    <Compile Include="BackEnd\Node\ServerNodeBuildCancel.cs" />
+    <Compile Include="BackEnd\Node\ServerNodeBuildCommand.cs" />
+    <Compile Include="BackEnd\Node\ServerNodeConsoleWrite.cs" />
+    <Compile Include="BackEnd\Node\ServerNodeBuildResult.cs" />
+    <Compile Include="BackEnd\Node\OutOfProcServerNode.cs" />
+    <Compile Include="Logging\ConsoleConfiguration.cs" />
+    <Compile Include="Logging\IConsoleConfiguration.cs" />
+    <Compile Include="Logging\InProcessConsoleConfiguration.cs" />
+    <Compile Include="Logging\TargetConsoleConfiguration.cs" />
     <Compile Include="Utilities\ImmutableCollectionsExtensions.cs" />
     <Compile Include="Utilities\NuGetFrameworkWrapper.cs" />
     <Compile Include="ObjectModelRemoting\ConstructionObjectLinks\ProjectUsingTaskParameterElementLink.cs" />
@@ -342,6 +362,7 @@
     <Compile Include="BackEnd\Components\Communications\INodeProvider.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeEndpointInProc.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeInfo.cs" />
+    <Compile Include="BackEnd\Components\Communications\NodeLauncher.cs" />
     <Compile Include="BackEnd\Components\Communications\NodeProviderInProc.cs" />
     <Compile Include="BackEnd\Components\IBuildComponent.cs" />
     <Compile Include="BackEnd\Components\IBuildComponentHost.cs" />
diff --git a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
index e69de29bb2d..a8ca12cca99 100644
--- a/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -0,0 +1,20 @@
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging, bool reuseProjectRootElementCache) -> void
+Microsoft.Build.Experimental.MSBuildClient
+Microsoft.Build.Experimental.MSBuildClient.Execute(System.Threading.CancellationToken cancellationToken) -> Microsoft.Build.Experimental.MSBuildClientExitResult
+Microsoft.Build.Experimental.MSBuildClient.MSBuildClient(string commandLine, string msbuildLocation) -> void
+Microsoft.Build.Experimental.MSBuildClientExitResult
+Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.get -> string
+Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.set -> void
+Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitResult() -> void
+Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.get -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.set -> void
+Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitType.LaunchError = 3 -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitType.ServerBusy = 1 -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitType.Success = 0 -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitType.UnableToConnect = 2 -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitType.Unexpected = 4 -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.OutOfProcServerNode
+Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback
+Microsoft.Build.Experimental.OutOfProcServerNode.OutOfProcServerNode(Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback buildFunction) -> void
+Microsoft.Build.Experimental.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
index ecaad75bd4e..93740b15de2 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -1101,6 +1101,7 @@ Microsoft.Build.Execution.HostServices.GetNodeAffinity(string projectFile) -> Mi
 Microsoft.Build.Execution.HostServices.HostServices() -> void
 Microsoft.Build.Execution.HostServices.OnRenameProject(string oldFullPath, string newFullPath) -> void
 Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, Microsoft.Build.Framework.ITaskHost hostObject) -> void
+Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName) -> void
 Microsoft.Build.Execution.HostServices.SetNodeAffinity(string projectFile, Microsoft.Build.Execution.NodeAffinity nodeAffinity) -> void
 Microsoft.Build.Execution.HostServices.UnregisterProject(string projectFullPath) -> void
 Microsoft.Build.Execution.ITargetResult
diff --git a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index e610ce450ea..aa42c2c0ede 100644
--- a/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Build/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1 +1,21 @@
-Microsoft.Build.Execution.HostServices.RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName) -> void
+Microsoft.Build.Evaluation.ProjectCollection.ProjectCollection(System.Collections.Generic.IDictionary<string, string> globalProperties, System.Collections.Generic.IEnumerable<Microsoft.Build.Framework.ILogger> loggers, System.Collections.Generic.IEnumerable<Microsoft.Build.Logging.ForwardingLoggerRecord> remoteLoggers, Microsoft.Build.Evaluation.ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging, bool reuseProjectRootElementCache) -> void
+Microsoft.Build.Experimental.MSBuildClient
+Microsoft.Build.Experimental.MSBuildClient.Execute(System.Threading.CancellationToken cancellationToken) -> Microsoft.Build.Experimental.MSBuildClientExitResult
+Microsoft.Build.Experimental.MSBuildClient.MSBuildClient(string[] commandLine, string msbuildLocation) -> void
+Microsoft.Build.Experimental.MSBuildClientExitResult
+Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.get -> string
+Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildAppExitTypeString.set -> void
+Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitResult() -> void
+Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.get -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitResult.MSBuildClientExitType.set -> void
+Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitType.LaunchError = 3 -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitType.ServerBusy = 1 -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitType.Success = 0 -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitType.UnableToConnect = 2 -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.MSBuildClientExitType.Unexpected = 4 -> Microsoft.Build.Experimental.MSBuildClientExitType
+Microsoft.Build.Experimental.OutOfProcServerNode
+Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback
+Microsoft.Build.Experimental.OutOfProcServerNode.OutOfProcServerNode(Microsoft.Build.Experimental.OutOfProcServerNode.BuildCallback buildFunction) -> void
+Microsoft.Build.Experimental.OutOfProcServerNode.Run(out System.Exception shutdownException) -> Microsoft.Build.Execution.NodeEngineShutdownReason
+
diff --git a/src/Build/Resources/Strings.resx b/src/Build/Resources/Strings.resx
index db8651cce57..10018e5f8f1 100644
--- a/src/Build/Resources/Strings.resx
+++ b/src/Build/Resources/Strings.resx
@@ -142,9 +142,6 @@
   <data name="WaitingForEndOfBuild" xml:space="preserve">
     <value>The operation cannot be completed because EndBuild has already been called but existing submissions have not yet completed.</value>
   </data>
-  <data name="EnvironmentDerivedPropertyRead">
-    <value>Property '{0}' with value '{1}' expanded from the environment.</value>
-  </data>
   <data name="SubmissionAlreadyComplete" xml:space="preserve">
     <value>The operation cannot be completed because the submission has already been executed.</value>
   </data>
diff --git a/src/Build/Resources/xlf/Strings.cs.xlf b/src/Build/Resources/xlf/Strings.cs.xlf
index 295e744c203..bc4f28a26e1 100644
--- a/src/Build/Resources/xlf/Strings.cs.xlf
+++ b/src/Build/Resources/xlf/Strings.cs.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: Zadaný výstupní soubor mezipaměti pro výsledky je prázdný.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Číst proměnnou prostředí {0}</target>
diff --git a/src/Build/Resources/xlf/Strings.de.xlf b/src/Build/Resources/xlf/Strings.de.xlf
index 354bbd025b6..2d5371cd4e4 100644
--- a/src/Build/Resources/xlf/Strings.de.xlf
+++ b/src/Build/Resources/xlf/Strings.de.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: Die angegebene Cachedatei für Ausgabeergebnisse ist leer.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Umgebungsvariable "{0}" lesen</target>
diff --git a/src/Build/Resources/xlf/Strings.es.xlf b/src/Build/Resources/xlf/Strings.es.xlf
index 0ff85f2cfc1..ae8a6a1e189 100644
--- a/src/Build/Resources/xlf/Strings.es.xlf
+++ b/src/Build/Resources/xlf/Strings.es.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: El archivo de caché de resultados de salida especificado está vacío.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Leer la variable de entorno "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.fr.xlf b/src/Build/Resources/xlf/Strings.fr.xlf
index bd86334a1d6..0ffddfbe011 100644
--- a/src/Build/Resources/xlf/Strings.fr.xlf
+++ b/src/Build/Resources/xlf/Strings.fr.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: Le fichier cache des résultats de sortie spécifié est vide.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Lire la variable d'environnement "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.it.xlf b/src/Build/Resources/xlf/Strings.it.xlf
index b3ffd7d5a8f..11aec49efc6 100644
--- a/src/Build/Resources/xlf/Strings.it.xlf
+++ b/src/Build/Resources/xlf/Strings.it.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: il file della cache dei risultati di output specificato è vuoto.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Legge la variabile di ambiente "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ja.xlf b/src/Build/Resources/xlf/Strings.ja.xlf
index 20194a207f9..1bf7a2f0d24 100644
--- a/src/Build/Resources/xlf/Strings.ja.xlf
+++ b/src/Build/Resources/xlf/Strings.ja.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: 指定された出力結果キャッシュ ファイルは空です。</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">環境変数 "{0}" の読み取り</target>
diff --git a/src/Build/Resources/xlf/Strings.ko.xlf b/src/Build/Resources/xlf/Strings.ko.xlf
index 64edef66ee4..8f5d34f5cce 100644
--- a/src/Build/Resources/xlf/Strings.ko.xlf
+++ b/src/Build/Resources/xlf/Strings.ko.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: 지정한 출력 결과 캐시 파일이 비어 있습니다.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">환경 변수 "{0}" 읽기</target>
diff --git a/src/Build/Resources/xlf/Strings.pl.xlf b/src/Build/Resources/xlf/Strings.pl.xlf
index ef425e1af33..b893482a44e 100644
--- a/src/Build/Resources/xlf/Strings.pl.xlf
+++ b/src/Build/Resources/xlf/Strings.pl.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: Określony plik wyjściowej pamięci podręcznej wyników jest pusty.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Odczytaj zmienną środowiskową „{0}”</target>
diff --git a/src/Build/Resources/xlf/Strings.pt-BR.xlf b/src/Build/Resources/xlf/Strings.pt-BR.xlf
index 57edd51b8b6..ad14ba37ca1 100644
--- a/src/Build/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/Build/Resources/xlf/Strings.pt-BR.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: o arquivo de cache do resultado de saída especificado está vazio.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Ler a variável de ambiente "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.ru.xlf b/src/Build/Resources/xlf/Strings.ru.xlf
index 9355b218d8e..04004fbdfe1 100644
--- a/src/Build/Resources/xlf/Strings.ru.xlf
+++ b/src/Build/Resources/xlf/Strings.ru.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: указанный выходной файл кэша результатов пустой.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">Чтение переменной среды "{0}"</target>
diff --git a/src/Build/Resources/xlf/Strings.tr.xlf b/src/Build/Resources/xlf/Strings.tr.xlf
index 439af5cefad..5fc8f54ba4e 100644
--- a/src/Build/Resources/xlf/Strings.tr.xlf
+++ b/src/Build/Resources/xlf/Strings.tr.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: Belirtilen çıkış sonucu önbellek dosyası boş.</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">"{0}" ortam değişkenini oku</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hans.xlf b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
index ca550fb5c8d..4a9d18a374e 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hans.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: 指定的输出结果缓存文件为空。</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">读取环境变量“{0}”</target>
diff --git a/src/Build/Resources/xlf/Strings.zh-Hant.xlf b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
index f1f0c28e519..214240db01c 100644
--- a/src/Build/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/Build/Resources/xlf/Strings.zh-Hant.xlf
@@ -102,11 +102,6 @@
         <target state="translated">MSB4257: 指定的輸出結果快取檔案是空的。</target>
         <note />
       </trans-unit>
-      <trans-unit id="EnvironmentDerivedPropertyRead">
-        <source>Property '{0}' with value '{1}' expanded from the environment.</source>
-        <target state="new">Property '{0}' with value '{1}' expanded from the environment.</target>
-        <note />
-      </trans-unit>
       <trans-unit id="EnvironmentVariableRead">
         <source>Read environment variable "{0}"</source>
         <target state="translated">讀取環境變數 "{0}"</target>
diff --git a/src/Build/Utilities/ReaderWriterLockSlimExtensions.cs b/src/Build/Utilities/ReaderWriterLockSlimExtensions.cs
new file mode 100644
index 00000000000..d837ef7630c
--- /dev/null
+++ b/src/Build/Utilities/ReaderWriterLockSlimExtensions.cs
@@ -0,0 +1,65 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Threading;
+
+namespace Microsoft.Build.Internal;
+
+// This type inspired by https://github.com/dotnet/roslyn/blob/ec6da663c592238cca8e145044e7410c4ca9213a/src/Compilers/Core/Portable/InternalUtilities/SemaphoreSlimExtensions.cs
+
+internal static class ReaderWriterLockSlimExtensions
+{
+    public static UpgradeableReadLockDisposer EnterDisposableUpgradeableReadLock(this ReaderWriterLockSlim rwLock)
+    {
+        rwLock.EnterUpgradeableReadLock();
+        return new UpgradeableReadLockDisposer(rwLock);
+    }
+
+    public static DisposableWriteLock EnterDisposableWriteLock(this ReaderWriterLockSlim rwLock)
+    {
+        rwLock.EnterWriteLock();
+        return new DisposableWriteLock(rwLock);
+    }
+
+    // Officially, Dispose() being called more than once is allowable, but in this case if that were to happen
+    // that means something is very, very wrong. Since it's an internal type, better to be strict.
+
+    internal struct UpgradeableReadLockDisposer : IDisposable
+    {
+        private ReaderWriterLockSlim? _rwLock;
+
+        public UpgradeableReadLockDisposer(ReaderWriterLockSlim rwLock) => _rwLock = rwLock;
+
+        public void Dispose()
+        {
+            var rwLockToDispose = Interlocked.Exchange(ref _rwLock, null);
+
+            if (rwLockToDispose is null)
+            {
+                throw new ObjectDisposedException($"Somehow a {nameof(UpgradeableReadLockDisposer)} is being disposed twice.");
+            }
+
+            rwLockToDispose.ExitUpgradeableReadLock();
+        }
+    }
+
+    internal struct DisposableWriteLock : IDisposable
+    {
+        private ReaderWriterLockSlim? _rwLock;
+
+        public DisposableWriteLock(ReaderWriterLockSlim rwLock) => _rwLock = rwLock;
+
+        public void Dispose()
+        {
+            var rwLockToDispose = Interlocked.Exchange(ref _rwLock, null);
+
+            if (rwLockToDispose is null)
+            {
+                throw new ObjectDisposedException($"Somehow a {nameof(DisposableWriteLock)} is being disposed twice.");
+            }
+
+            rwLockToDispose.ExitWriteLock();
+        }
+    }
+}
diff --git a/src/Build/Utilities/Utilities.cs b/src/Build/Utilities/Utilities.cs
index 188c93e2bc9..3e8d07e7846 100644
--- a/src/Build/Utilities/Utilities.cs
+++ b/src/Build/Utilities/Utilities.cs
@@ -618,7 +618,7 @@ public static T[] ToArray<T>(this IEnumerator<T> enumerator)
             return enumerator.ToEnumerable().ToArray();
         }
 
-        public static void EnumerateProperties(IEnumerable properties, Action<KeyValuePair<string, string>> callback)
+        public static void EnumerateProperties<TArg>(IEnumerable properties, TArg arg, Action<TArg, KeyValuePair<string, string>> callback)
         {
             if (properties == null)
             {
@@ -629,14 +629,14 @@ public static void EnumerateProperties(IEnumerable properties, Action<KeyValuePa
             {
                 propertyInstanceDictionary.Enumerate((key, value) =>
                 {
-                    callback(new KeyValuePair<string, string>(key, value));
+                    callback(arg, new KeyValuePair<string, string>(key, value));
                 });
             }
             else if (properties is PropertyDictionary<ProjectProperty> propertyDictionary)
             {
                 propertyDictionary.Enumerate((key, value) =>
                 {
-                    callback(new KeyValuePair<string, string>(key, value));
+                    callback(arg, new KeyValuePair<string, string>(key, value));
                 });
             }
             else
@@ -645,15 +645,15 @@ public static void EnumerateProperties(IEnumerable properties, Action<KeyValuePa
                 {
                     if (item is IProperty property && !string.IsNullOrEmpty(property.Name))
                     {
-                        callback(new KeyValuePair<string, string>(property.Name, property.EvaluatedValue ?? string.Empty));
+                        callback(arg, new KeyValuePair<string, string>(property.Name, property.EvaluatedValue ?? string.Empty));
                     }
                     else if (item is DictionaryEntry dictionaryEntry && dictionaryEntry.Key is string key && !string.IsNullOrEmpty(key))
                     {
-                        callback(new KeyValuePair<string, string>(key, dictionaryEntry.Value as string ?? string.Empty));
+                        callback(arg, new KeyValuePair<string, string>(key, dictionaryEntry.Value as string ?? string.Empty));
                     }
                     else if (item is KeyValuePair<string, string> kvp)
                     {
-                        callback(kvp);
+                        callback(arg, kvp);
                     }
                     else
                     {
diff --git a/src/Directory.BeforeCommon.targets b/src/Directory.BeforeCommon.targets
index 6696e3861ba..1aac46b4e69 100644
--- a/src/Directory.BeforeCommon.targets
+++ b/src/Directory.BeforeCommon.targets
@@ -90,6 +90,7 @@
     <DefineConstants>$(DefineConstants);FEATURE_RUNTIMEINFORMATION</DefineConstants>
     <DefineConstants>$(DefineConstants);USE_MSBUILD_DLL_EXTN</DefineConstants>
     <DefineConstants>$(DefineConstants);WORKAROUND_COREFX_19110</DefineConstants>
+    <DefineConstants>$(DefineConstants);FEATURE_SYMLINK_TARGET</DefineConstants>
   </PropertyGroup>
 
   <PropertyGroup Condition="'$(TargetFramework)' == 'netcoreapp2.1' or '$(TargetFramework)' == 'net6.0'">
@@ -110,7 +111,7 @@
     <DocumentationFile Condition=" '$(GenerateDocumentationFile)' == 'true' ">$(IntermediateOutputPath)\$(AssemblyName).xml</DocumentationFile>
   </PropertyGroup>
 
-  <PropertyGroup Condition="'$(MonoBuild)' != 'true' and $([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETFramework'">
+  <PropertyGroup Condition="'$(MonoBuild)' != 'true' and '$(DotNetBuildFromSource)' != 'true' and $([MSBuild]::GetTargetFrameworkIdentifier('$(TargetFramework)')) == '.NETFramework'">
     <DefineConstants>$(DefineConstants);FEATURE_MSIOREDIST</DefineConstants>
     <FeatureMSIORedist>true</FeatureMSIORedist>
   </PropertyGroup>
diff --git a/src/Directory.Build.targets b/src/Directory.Build.targets
index de6fe3137d5..2495ec35840 100644
--- a/src/Directory.Build.targets
+++ b/src/Directory.Build.targets
@@ -59,6 +59,10 @@
          are netstandard1.6 and transitively bring in an old reference -->
     <PackageReference Include="System.Security.Cryptography.X509Certificates" />
 
+    <!-- As of 17.3, one TF of Microsoft.NET.Test.Sdk depends on Newtonsoft.Json
+         9.0.1, causing it to be downloaded and flagged by component governance -->
+    <PackageReference Include="Newtonsoft.Json" />
+
     <PackageReference Include="Microsoft.DotNet.XUnitExtensions" />
 
     <!-- Don't localize unit test projects -->
diff --git a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
index eca867cd1cc..2bf43e98406 100644
--- a/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
+++ b/src/Framework.UnitTests/BuildFinishedEventArgs_Tests.cs
@@ -27,7 +27,7 @@ public void EventArgsCtors()
             buildFinishedEvent = new BuildFinishedEventArgs("{0}", "HelpKeyword", true, new DateTime(), "Message");
             buildFinishedEvent = new BuildFinishedEventArgs(null, null, true);
             buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime());
-            buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime(), messageArgs: null);
+            buildFinishedEvent = new BuildFinishedEventArgs(null, null, true, new DateTime(), null);
         }
 
         /// <summary>
diff --git a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
index b66f3a66b80..e3b953a332a 100644
--- a/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
+++ b/src/Framework.UnitTests/Microsoft.Build.Framework.UnitTests.csproj
@@ -34,6 +34,7 @@
     <Compile Include="..\Shared\ErrorUtilities.cs" />
     <Compile Include="..\Shared\EscapingUtilities.cs" />
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs" />
+    <Compile Include="..\Shared\ProcessExtensions.cs" />
     <Compile Include="..\Shared\ResourceUtilities.cs" />
     <Compile Include="..\Shared\ExceptionHandling.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs" />
diff --git a/src/Framework/BuildEventArgs.cs b/src/Framework/BuildEventArgs.cs
index e949eafe240..df29067bea9 100644
--- a/src/Framework/BuildEventArgs.cs
+++ b/src/Framework/BuildEventArgs.cs
@@ -7,8 +7,6 @@
 using System.Text;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -27,17 +25,17 @@ public abstract class BuildEventArgs : EventArgs
         /// <summary>
         /// Message. Volatile because it may be updated lock-free after construction.
         /// </summary>
-        private volatile string message;
+        private volatile string? message;
 
         /// <summary>
         /// Help keyword
         /// </summary>
-        private string helpKeyword;
+        private string? helpKeyword;
 
         /// <summary>
         /// Sender name
         /// </summary>
-        private string senderName;
+        private string? senderName;
 
         /// <summary>
         /// Timestamp
@@ -56,7 +54,7 @@ public abstract class BuildEventArgs : EventArgs
         /// Build event context
         /// </summary>
         [OptionalField(VersionAdded = 2)]
-        private BuildEventContext buildEventContext;
+        private BuildEventContext? buildEventContext;
 
         /// <summary>
         /// Default constructor
@@ -72,7 +70,7 @@ protected BuildEventArgs()
         /// <param name="message">text message</param>
         /// <param name="helpKeyword">help keyword </param>
         /// <param name="senderName">name of event sender</param>
-        protected BuildEventArgs(string message, string helpKeyword, string senderName)
+        protected BuildEventArgs(string? message, string? helpKeyword, string? senderName)
             : this(message, helpKeyword, senderName, DateTime.UtcNow)
         {
         }
@@ -84,7 +82,7 @@ protected BuildEventArgs(string message, string helpKeyword, string senderName)
         /// <param name="helpKeyword">help keyword </param>
         /// <param name="senderName">name of event sender</param>
         /// <param name="eventTimestamp">TimeStamp of when the event was created</param>
-        protected BuildEventArgs(string message, string helpKeyword, string senderName, DateTime eventTimestamp)
+        protected BuildEventArgs(string? message, string? helpKeyword, string? senderName, DateTime eventTimestamp)
         {
             this.message = message;
             this.helpKeyword = helpKeyword;
@@ -133,7 +131,7 @@ protected internal DateTime RawTimestamp
         /// <summary>
         /// Text of event.
         /// </summary>
-        public virtual string Message
+        public virtual string? Message
         {
             get => message;
             protected set => message = value;
@@ -143,7 +141,7 @@ public virtual string Message
         /// Exposes the underlying message field without side-effects.
         /// Used for serialization.
         /// </summary>
-        protected internal string RawMessage
+        protected internal string? RawMessage
         {
             get => FormattedMessage;
             set => message = value;
@@ -153,7 +151,7 @@ protected internal string RawMessage
         /// Like <see cref="RawMessage"/> but returns a formatted message string if available.
         /// Used for serialization.
         /// </summary>
-        private protected virtual string FormattedMessage
+        private protected virtual string? FormattedMessage
         {
             get => message;
         }
@@ -161,17 +159,17 @@ private protected virtual string FormattedMessage
         /// <summary>
         /// Custom help keyword associated with event.
         /// </summary>
-        public string HelpKeyword => helpKeyword;
+        public string? HelpKeyword => helpKeyword;
 
         /// <summary>
         /// Name of the object sending this event.
         /// </summary>
-        public string SenderName => senderName;
+        public string? SenderName => senderName;
 
         /// <summary>
         /// Event contextual information for the build event argument
         /// </summary>
-        public BuildEventContext BuildEventContext
+        public BuildEventContext? BuildEventContext
         {
             get => buildEventContext;
             set => buildEventContext = value;
@@ -183,7 +181,7 @@ public BuildEventContext BuildEventContext
         /// </summary>
         /// <param name="writer">Binary writer which is attached to the stream the event will be serialized into</param>
         /// <param name="messageToWrite">The message to write to the stream.</param>
-        private protected void WriteToStreamWithExplicitMessage(BinaryWriter writer, string messageToWrite)
+        private protected void WriteToStreamWithExplicitMessage(BinaryWriter writer, string? messageToWrite)
         {
             writer.WriteOptionalString(messageToWrite);
             writer.WriteOptionalString(helpKeyword);
@@ -286,7 +284,7 @@ private void SetBuildEventContextDefaultAfterSerialization(StreamingContext sc)
         /// This is used by the Message property overrides to reconstruct the
         /// message lazily on demand.
         /// </summary>
-        internal static Func<string, string[], string> ResourceStringFormatter = (string resourceName, string[] arguments) =>
+        internal static Func<string, string?[], string> ResourceStringFormatter = (string resourceName, string?[] arguments) =>
         {
             var sb = new StringBuilder();
             sb.Append(resourceName);
@@ -317,7 +315,7 @@ private void SetBuildEventContextDefaultAfterSerialization(StreamingContext sc)
         /// <param name="resourceName">Name of the resource string.</param>
         /// <param name="arguments">Optional list of arguments to pass to the formatted string.</param>
         /// <returns>The concatenated formatted string.</returns>
-        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, params string[] arguments)
+        internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, params string?[] arguments)
         {
             return ResourceStringFormatter(resourceName, arguments);
         }
diff --git a/src/Framework/BuildEventContext.cs b/src/Framework/BuildEventContext.cs
index 94672522efb..92e7673f67a 100644
--- a/src/Framework/BuildEventContext.cs
+++ b/src/Framework/BuildEventContext.cs
@@ -3,8 +3,6 @@
 
 using System;
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -131,7 +129,7 @@ int taskId
         /// <summary>
         /// Returns a default invalid BuildEventContext
         /// </summary>
-        public static BuildEventContext Invalid => new BuildEventContext(InvalidNodeId, InvalidTargetId, InvalidProjectContextId, InvalidTaskId);
+        public static BuildEventContext Invalid { get; } = new BuildEventContext(InvalidNodeId, InvalidTargetId, InvalidProjectContextId, InvalidTaskId);
 
         /// <summary>
         /// Retrieves the Evaluation id.
@@ -237,7 +235,7 @@ public override int GetHashCode()
         /// </summary>
         /// <param name="obj"></param>
         /// <returns></returns>
-        public override bool Equals(object obj)
+        public override bool Equals(object? obj)
         {
             // If the references are the same no need to do any more comparing
             if (ReferenceEquals(this, obj))
@@ -265,7 +263,7 @@ public override bool Equals(object obj)
         /// <param name="left">Left hand side operand</param>
         /// <param name="right">Right hand side operand</param>
         /// <returns>True if the object values are identical, false if they are not identical</returns>
-        public static bool operator ==(BuildEventContext left, BuildEventContext right)
+        public static bool operator ==(BuildEventContext? left, BuildEventContext? right)
         {
             if (ReferenceEquals(left, right))
             {
@@ -287,7 +285,7 @@ public override bool Equals(object obj)
         /// <param name="left">Left hand side operand</param>
         /// <param name="right">Right hand side operand</param>
         /// <returns>True if the object values are not identical, false if they are identical</returns>
-        public static bool operator !=(BuildEventContext left, BuildEventContext right)
+        public static bool operator !=(BuildEventContext? left, BuildEventContext? right)
         {
             return !(left == right);
         }
diff --git a/src/Framework/BuildFinishedEventArgs.cs b/src/Framework/BuildFinishedEventArgs.cs
index 1647591416c..a496eefb701 100644
--- a/src/Framework/BuildFinishedEventArgs.cs
+++ b/src/Framework/BuildFinishedEventArgs.cs
@@ -4,8 +4,6 @@
 using System;
 using System.IO;
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -43,8 +41,8 @@ protected BuildFinishedEventArgs()
         /// <param name="succeeded">True indicates a successful build</param>
         public BuildFinishedEventArgs
         (
-            string message,
-            string helpKeyword,
+            string? message,
+            string? helpKeyword,
             bool succeeded
         )
             : this(message, helpKeyword, succeeded, DateTime.UtcNow)
@@ -60,8 +58,8 @@ bool succeeded
         /// <param name="eventTimestamp">Timestamp when the event was created</param>
         public BuildFinishedEventArgs
         (
-            string message,
-            string helpKeyword,
+            string? message,
+            string? helpKeyword,
             bool succeeded,
             DateTime eventTimestamp
         )
@@ -80,11 +78,11 @@ DateTime eventTimestamp
         /// <param name="messageArgs">message arguments</param>
         public BuildFinishedEventArgs
         (
-            string message,
-            string helpKeyword,
+            string? message,
+            string? helpKeyword,
             bool succeeded,
             DateTime eventTimestamp,
-            params object[] messageArgs
+            params object[]? messageArgs
         )
             : base(message, helpKeyword, "MSBuild", eventTimestamp, messageArgs)
         {
diff --git a/src/Framework/BuildStartedEventArgs.cs b/src/Framework/BuildStartedEventArgs.cs
index 9d35298dc83..ff0b6415c95 100644
--- a/src/Framework/BuildStartedEventArgs.cs
+++ b/src/Framework/BuildStartedEventArgs.cs
@@ -4,8 +4,6 @@
 using System;
 using System.Collections.Generic;
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -20,7 +18,7 @@ namespace Microsoft.Build.Framework
     [Serializable]
     public class BuildStartedEventArgs : BuildStatusEventArgs
     {
-        private IDictionary<string, string> environmentOnBuildStart;
+        private IDictionary<string, string>? environmentOnBuildStart;
 
         /// <summary>
         /// Default constructor
@@ -56,8 +54,8 @@ string helpKeyword
         /// <param name="environmentOfBuild">A dictionary which lists the environment of the build when the build is started.</param>
         public BuildStartedEventArgs
         (
-            string message,
-            string helpKeyword,
+            string? message,
+            string? helpKeyword,
             IDictionary<string, string> environmentOfBuild
         )
             : this(message, helpKeyword, DateTime.UtcNow)
@@ -73,8 +71,8 @@ IDictionary<string, string> environmentOfBuild
         /// <param name="eventTimestamp">Timestamp when the event was created</param>
         public BuildStartedEventArgs
         (
-            string message,
-            string helpKeyword,
+            string? message,
+            string? helpKeyword,
             DateTime eventTimestamp
         )
             : this(message, helpKeyword, eventTimestamp, null)
@@ -91,10 +89,10 @@ DateTime eventTimestamp
         /// <param name="messageArgs">message args</param>
         public BuildStartedEventArgs
         (
-            string message,
-            string helpKeyword,
+            string? message,
+            string? helpKeyword,
             DateTime eventTimestamp,
-            params object[] messageArgs
+            params object[]? messageArgs
         )
             : base(message, helpKeyword, "MSBuild", eventTimestamp, messageArgs)
         {
@@ -104,7 +102,7 @@ params object[] messageArgs
         /// <summary>
         /// The environment which is used at the start of the build
         /// </summary>
-        public IDictionary<string, string> BuildEnvironment
+        public IDictionary<string, string>? BuildEnvironment
         {
             get { return environmentOnBuildStart; }
         }
diff --git a/src/Framework/BuildStatusEventArgs.cs b/src/Framework/BuildStatusEventArgs.cs
index ef6146a6c6b..c7a9e9ad0d5 100644
--- a/src/Framework/BuildStatusEventArgs.cs
+++ b/src/Framework/BuildStatusEventArgs.cs
@@ -3,8 +3,6 @@
 
 using System;
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary> 
@@ -39,9 +37,9 @@ protected BuildStatusEventArgs()
         /// <param name="senderName">name of event sender</param> 
         protected BuildStatusEventArgs
         (
-            string message,
-            string helpKeyword,
-            string senderName
+            string? message,
+            string? helpKeyword,
+            string? senderName
         )
             : this(message, helpKeyword, senderName, DateTime.UtcNow)
         {
@@ -58,9 +56,9 @@ string senderName
         /// <param name="eventTimestamp">Timestamp when event was created</param>
         protected BuildStatusEventArgs
         (
-            string message,
-            string helpKeyword,
-            string senderName,
+            string? message,
+            string? helpKeyword,
+            string? senderName,
             DateTime eventTimestamp
         )
             : this(message, helpKeyword, senderName, eventTimestamp, messageArgs: null)
@@ -78,11 +76,11 @@ DateTime eventTimestamp
         /// <param name="messageArgs">Optional arguments for formatting the message string.</param>
         protected BuildStatusEventArgs
         (
-            string message,
-            string helpKeyword,
-            string senderName,
+            string? message,
+            string? helpKeyword,
+            string? senderName,
             DateTime eventTimestamp,
-            params object[] messageArgs
+            params object[]? messageArgs
         )
             : base(message, helpKeyword, senderName, eventTimestamp, messageArgs)
         {
diff --git a/src/Framework/LazyFormattedBuildEventArgs.cs b/src/Framework/LazyFormattedBuildEventArgs.cs
index 6a9ff54e92b..2597304fee5 100644
--- a/src/Framework/LazyFormattedBuildEventArgs.cs
+++ b/src/Framework/LazyFormattedBuildEventArgs.cs
@@ -5,8 +5,6 @@
 using System.Globalization;
 using System.IO;
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -18,12 +16,12 @@ public class LazyFormattedBuildEventArgs : BuildEventArgs
         /// <summary>
         /// Stores the message arguments.
         /// </summary>
-        private volatile object argumentsOrFormattedMessage;
+        private volatile object? argumentsOrFormattedMessage;
 
         /// <summary>
         /// Exposes the underlying arguments field to serializers.
         /// </summary>
-        internal object[] RawArguments
+        internal object[]? RawArguments
         {
             get => (argumentsOrFormattedMessage is object[] arguments) ? arguments : null;
         }
@@ -31,7 +29,7 @@ internal object[] RawArguments
         /// <summary>
         /// Exposes the formatted message string to serializers.
         /// </summary>
-        private protected override string FormattedMessage
+        private protected override string? FormattedMessage
         {
             get => (argumentsOrFormattedMessage is string formattedMessage) ? formattedMessage : base.FormattedMessage;
         }
@@ -44,9 +42,9 @@ private protected override string FormattedMessage
         /// <param name="senderName">name of event sender.</param>
         public LazyFormattedBuildEventArgs
         (
-            string message,
-            string helpKeyword,
-            string senderName
+            string? message,
+            string? helpKeyword,
+            string? senderName
         )
             : this(message, helpKeyword, senderName, DateTime.Now, null)
         {
@@ -62,11 +60,11 @@ string senderName
         /// <param name="messageArgs">Message arguments.</param>
         public LazyFormattedBuildEventArgs
         (
-            string message,
-            string helpKeyword,
-            string senderName,
+            string? message,
+            string? helpKeyword,
+            string? senderName,
             DateTime eventTimestamp,
-            params object[] messageArgs
+            params object[]? messageArgs
         )
             : base(message, helpKeyword, senderName, eventTimestamp)
         {
@@ -84,17 +82,17 @@ protected LazyFormattedBuildEventArgs()
         /// <summary>
         /// Gets the formatted message.
         /// </summary>
-        public override string Message
+        public override string? Message
         {
             get
             {
-                object argsOrMessage = argumentsOrFormattedMessage;
+                object? argsOrMessage = argumentsOrFormattedMessage;
                 if (argsOrMessage is string formattedMessage)
                 {
                     return formattedMessage;
                 }
 
-                if (argsOrMessage is object[] arguments && arguments.Length > 0)
+                if (argsOrMessage is object[] arguments && arguments.Length > 0 && base.Message is not null)
                 {
                     formattedMessage = FormatString(base.Message, arguments);
                     argumentsOrFormattedMessage = formattedMessage;
@@ -111,7 +109,7 @@ public override string Message
         /// <param name="writer">Binary writer which is attached to the stream the event will be serialized into.</param>
         internal override void WriteToStream(BinaryWriter writer)
         {
-            object argsOrMessage = argumentsOrFormattedMessage;
+            object? argsOrMessage = argumentsOrFormattedMessage;
             if (argsOrMessage is object[] arguments && arguments.Length > 0)
             {
                 base.WriteToStreamWithExplicitMessage(writer, base.Message);
@@ -121,7 +119,8 @@ internal override void WriteToStream(BinaryWriter writer)
                 {
                     // Arguments may be ints, etc, so explicitly convert
                     // Convert.ToString returns String.Empty when it cannot convert, rather than throwing
-                    writer.Write(Convert.ToString(argument, CultureInfo.CurrentCulture));
+                    // It returns null if the input is null.
+                    writer.Write(Convert.ToString(argument, CultureInfo.CurrentCulture) ?? "");
                 }
             }
             else
@@ -142,7 +141,7 @@ internal override void CreateFromStream(BinaryReader reader, Int32 version)
 
             if (version > 20)
             {
-                string[] messageArgs = null;
+                string[]? messageArgs = null;
                 int numArguments = reader.ReadInt32();
 
                 if (numArguments >= 0)
diff --git a/src/Framework/MSBuildEventSource.cs b/src/Framework/MSBuildEventSource.cs
index f2f4cc9070f..89b8370c392 100644
--- a/src/Framework/MSBuildEventSource.cs
+++ b/src/Framework/MSBuildEventSource.cs
@@ -623,6 +623,41 @@ public void SdkResolverServiceLoadResolversStop(string manifestName, int resolve
             WriteEvent(84, manifestName, resolverCount);
         }
 
+        [Event(85, Keywords = Keywords.All)]
+        public void CreateLoadedTypeStart(string assemblyName)
+        {
+            WriteEvent(85, assemblyName);
+        }
+
+        [Event(86, Keywords = Keywords.All)]
+        public void CreateLoadedTypeStop(string assemblyName)
+        {
+            WriteEvent(86, assemblyName);
+        }
+
+        [Event(87, Keywords = Keywords.All)]
+        public void LoadAssemblyAndFindTypeStart()
+        {
+            WriteEvent(87);
+        }
+
+        [Event(88, Keywords = Keywords.All)]
+        public void LoadAssemblyAndFindTypeStop(string assemblyPath, int numberOfPublicTypesSearched)
+        {
+            WriteEvent(88, assemblyPath, numberOfPublicTypesSearched);
+        }
+        
+        [Event(89, Keywords = Keywords.All)]
+        public void MSBuildServerBuildStart(string commandLine)
+        {
+            WriteEvent(89, commandLine);
+        }
+
+        [Event(90, Keywords = Keywords.All)]
+        public void MSBuildServerBuildStop(string commandLine, int countOfConsoleMessages, long sumSizeOfConsoleMessages, string clientExitType, string serverExitType)
+        {
+            WriteEvent(90, commandLine, countOfConsoleMessages, sumSizeOfConsoleMessages, clientExitType, serverExitType);
+        }
         #endregion
     }
 }
diff --git a/src/Framework/Microsoft.Build.Framework.csproj b/src/Framework/Microsoft.Build.Framework.csproj
index e24a13ff151..b4c3190f3b4 100644
--- a/src/Framework/Microsoft.Build.Framework.csproj
+++ b/src/Framework/Microsoft.Build.Framework.csproj
@@ -25,6 +25,11 @@
     <Reference Include="System.Xaml" />
   </ItemGroup>
 
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' == '.NETStandard'">
+    <!-- Need Win32 API on .NET Standard to ping registry for some methods in ToolLocationHelper -->
+    <PackageReference Include="Microsoft.Win32.Registry" />
+  </ItemGroup>
+
   <ItemGroup>
     <Compile Include="..\Shared\Constants.cs">
       <Link>Shared\Constants.cs</Link>
diff --git a/src/Framework/NativeMethods.cs b/src/Framework/NativeMethods.cs
index 9e68fc71c4e..d0c29652824 100644
--- a/src/Framework/NativeMethods.cs
+++ b/src/Framework/NativeMethods.cs
@@ -10,7 +10,6 @@
 using System.Reflection;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
-using System.Text;
 using System.Threading;
 
 using Microsoft.Build.Shared;
@@ -37,6 +36,8 @@ internal static class NativeMethods
     internal const uint RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG = 0x40;
     internal const uint FILE_TYPE_CHAR = 0x0002;
     internal const Int32 STD_OUTPUT_HANDLE = -11;
+    internal const uint DISABLE_NEWLINE_AUTO_RETURN = 0x0008;
+    internal const uint ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x0004;
     internal const uint RPC_S_CALLPENDING = 0x80010115;
     internal const uint E_ABORT = (uint)0x80004004;
 
@@ -59,6 +60,7 @@ internal static class NativeMethods
     internal static HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);
 
     internal static IntPtr NullIntPtr = new IntPtr(0);
+    internal static IntPtr InvalidHandle = new IntPtr(-1);
 
     // As defined in winnt.h:
     internal const ushort PROCESSOR_ARCHITECTURE_INTEL = 0;
@@ -237,6 +239,8 @@ internal class SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid
         private SafeProcessHandle() : base(true)
         {
         }
+
+        [SupportedOSPlatform("windows")]
         protected override bool ReleaseHandle()
         {
             return CloseHandle(handle);
@@ -254,7 +258,7 @@ internal class MemoryStatus
         /// </summary>
         public MemoryStatus()
         {
-#if (CLR2COMPATIBILITY)
+#if CLR2COMPATIBILITY
             _length = (uint)Marshal.SizeOf(typeof(MemoryStatus));
 #else
             _length = (uint)Marshal.SizeOf<MemoryStatus>();
@@ -530,6 +534,7 @@ public static int GetLogicalCoreCount()
     /// as Environment.ProcessorCount has a 32-core limit in that case.
     /// https://github.com/dotnet/runtime/blob/221ad5b728f93489655df290c1ea52956ad8f51c/src/libraries/System.Runtime.Extensions/src/System/Environment.Windows.cs#L171-L210
     /// </summary>
+    [SupportedOSPlatform("windows")]
     private unsafe static int GetLogicalCoreCountOnWindows()
     {
         uint len = 0;
@@ -718,10 +723,7 @@ internal static bool IsWindows
 #else
         get
         {
-            if (_isWindows == null)
-            {
-                _isWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
-            }
+            _isWindows ??= RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
             return _isWindows.Value;
         }
 #endif
@@ -741,10 +743,7 @@ internal static bool IsOSX
 #else
         get
         {
-            if (_isOSX == null)
-            {
-                _isOSX = RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
-            }
+            _isOSX ??= RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
             return _isOSX.Value;
         }
 #endif
@@ -759,6 +758,24 @@ internal static string OSName
         get { return IsWindows ? "Windows_NT" : "Unix"; }
     }
 
+    /// <summary>
+    /// Framework named as presented to users (for example in version info).
+    /// </summary>
+    internal static string FrameworkName
+    {
+        get
+        {
+#if RUNTIME_TYPE_NETCORE
+            const string frameworkName = ".NET";
+#elif MONO
+            const string frameworkName = "Mono";
+#else
+            const string frameworkName = ".NET Framework";
+#endif
+            return frameworkName;
+        }
+    }
+
     /// <summary>
     /// OS name that can be used for the msbuildExtensionsPathSearchPaths element
     /// for a toolset
@@ -869,21 +886,17 @@ private static SystemInformationData SystemInformation
 
 #region Wrapper methods
 
-    /// <summary>
-    /// Really truly non pumping wait.
-    /// Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
-    /// single SafeHandles.
-    /// </summary>
-    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
-    public static extern Int32 WaitForMultipleObjects(uint handle, IntPtr[] handles, bool waitAll, uint milliseconds);
 
     [DllImport("kernel32.dll", SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern void GetSystemInfo(ref SYSTEM_INFO lpSystemInfo);
 
     [DllImport("kernel32.dll", SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern void GetNativeSystemInfo(ref SYSTEM_INFO lpSystemInfo);
 
     [DllImport("kernel32.dll", SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, IntPtr Buffer, ref uint ReturnedLength);
 
     /// <summary>
@@ -973,6 +986,7 @@ internal static string GetShortFilePath(string path)
     /// </summary>
     /// <param name="path"></param>
     /// <returns></returns>
+    [SupportedOSPlatform("windows")]
     internal static string GetLongFilePath(string path)
     {
         if (IsUnixLike)
@@ -1112,6 +1126,7 @@ DateTime LastWriteFileUtcTime(string path)
     /// This is the most accurate timestamp-extraction mechanism, but it is too slow to use all the time.
     /// See https://github.com/dotnet/msbuild/issues/2052.
     /// </remarks>
+    [SupportedOSPlatform("windows")]
     private static DateTime GetContentLastWriteFileUtcTime(string fullPath)
     {
         DateTime fileModifiedTime = DateTime.MinValue;
@@ -1179,6 +1194,7 @@ public static void ThrowExceptionForErrorCode(int errorCode)
     /// <summary>
     /// Kills the specified process by id and all of its children recursively.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal static void KillTree(int processIdToKill)
     {
         // Note that GetProcessById does *NOT* internally hold on to the process handle.
@@ -1257,6 +1273,7 @@ internal static void KillTree(int processIdToKill)
     /// Returns the parent process id for the specified process.
     /// Returns zero if it cannot be gotten for some reason.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal static int GetParentProcessId(int processId)
     {
         int ParentID = 0;
@@ -1327,6 +1344,7 @@ internal static int GetParentProcessId(int processId)
     /// Returns an array of all the immediate child processes by id.
     /// NOTE: The IntPtr in the tuple is the handle of the child process.  CloseHandle MUST be called on this.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal static List<KeyValuePair<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime)
     {
         List<KeyValuePair<int, SafeProcessHandle>> myChildren = new List<KeyValuePair<int, SafeProcessHandle>>();
@@ -1391,6 +1409,7 @@ internal unsafe static string GetCurrentDirectory()
         return Directory.GetCurrentDirectory();
     }
 
+    [SupportedOSPlatform("windows")]
     private unsafe static int GetCurrentDirectoryWin32(int nBufferLength, char* lpBuffer)
     {
         int pathLength = GetCurrentDirectory(nBufferLength, lpBuffer);
@@ -1398,6 +1417,7 @@ private unsafe static int GetCurrentDirectoryWin32(int nBufferLength, char* lpBu
         return pathLength;
     }
 
+    [SupportedOSPlatform("windows")]
     internal unsafe static string GetFullPath(string path)
     {
         int bufferSize = GetFullPathWin32(path, 0, null, IntPtr.Zero);
@@ -1407,6 +1427,7 @@ internal unsafe static string GetFullPath(string path)
         return AreStringsEqual(buffer, fullPathLength, path) ? path : new string(buffer, startIndex: 0, length: fullPathLength);
     }
 
+    [SupportedOSPlatform("windows")]
     private unsafe static int GetFullPathWin32(string target, int bufferLength, char* buffer, IntPtr mustBeZero)
     {
         int pathLength = GetFullPathName(target, bufferLength, buffer, mustBeZero);
@@ -1460,20 +1481,25 @@ internal static void VerifyThrowWin32Result(int result)
     /// that needs to be used for instance when writing to batch files
     /// </summary>
     [DllImport(kernel32Dll)]
+    [SupportedOSPlatform("windows")]
     internal static extern int GetOEMCP();
 
     [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
     [return: MarshalAs(UnmanagedType.Bool)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool GetFileAttributesEx(String name, int fileInfoLevel, ref WIN32_FILE_ATTRIBUTE_DATA lpFileInformation);
 
     [DllImport("kernel32.dll", PreserveSig = true, SetLastError = true)]
     [return: MarshalAs(UnmanagedType.Bool)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool FreeLibrary([In] IntPtr module);
 
     [DllImport("kernel32.dll", PreserveSig = true, BestFitMapping = false, ThrowOnUnmappableChar = true, CharSet = CharSet.Ansi, SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern IntPtr GetProcAddress(IntPtr module, string procName);
 
     [DllImport("kernel32.dll", CharSet = CharSet.Unicode, PreserveSig = true, SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern IntPtr LoadLibrary(string fileName);
 
     /// <summary>
@@ -1483,21 +1509,32 @@ internal static void VerifyThrowWin32Result(int result)
     /// <param name="buffer">The character buffer used to return the file name.</param>
     /// <param name="length">The length of the buffer.</param>
     [DllImport(kernel32Dll, SetLastError = true, CharSet = CharSet.Unicode)]
+    [SupportedOSPlatform("windows")]
     internal static extern int GetModuleFileName(HandleRef hModule, [Out] char[] buffer, int length);
 
     [DllImport("kernel32.dll")]
+    [SupportedOSPlatform("windows")]
     internal static extern IntPtr GetStdHandle(int nStdHandle);
 
     [DllImport("kernel32.dll")]
+    [SupportedOSPlatform("windows")]
     internal static extern uint GetFileType(IntPtr hFile);
+    
+    [DllImport("kernel32.dll")]
+    internal static extern bool GetConsoleMode(IntPtr hConsoleHandle, out uint lpMode);
+
+    [DllImport("kernel32.dll")]
+    internal static extern bool SetConsoleMode(IntPtr hConsoleHandle, uint dwMode);
 
     [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
     [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    [SupportedOSPlatform("windows")]
     internal unsafe static extern int GetCurrentDirectory(int nBufferLength, char* lpBuffer);
 
     [SuppressMessage("Microsoft.Usage", "CA2205:UseManagedEquivalentsOfWin32Api", Justification = "Using unmanaged equivalent for performance reasons")]
     [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode, EntryPoint = "SetCurrentDirectory")]
     [return: MarshalAs(UnmanagedType.Bool)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool SetCurrentDirectoryWindows(string path);
 
     internal static bool SetCurrentDirectory(string path)
@@ -1519,28 +1556,36 @@ internal static bool SetCurrentDirectory(string path)
     }
 
     [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
+    [SupportedOSPlatform("windows")]
     internal static unsafe extern int GetFullPathName(string target, int bufferLength, char* buffer, IntPtr mustBeZero);
 
     [DllImport("KERNEL32.DLL")]
+    [SupportedOSPlatform("windows")]
     private static extern SafeProcessHandle OpenProcess(eDesiredAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, int dwProcessId);
 
     [DllImport("NTDLL.DLL")]
+    [SupportedOSPlatform("windows")]
     private static extern int NtQueryInformationProcess(SafeProcessHandle hProcess, PROCESSINFOCLASS pic, ref PROCESS_BASIC_INFORMATION pbi, uint cb, ref int pSize);
 
     [return: MarshalAs(UnmanagedType.Bool)]
     [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     private static extern bool GlobalMemoryStatusEx([In, Out] MemoryStatus lpBuffer);
 
     [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
+    [SupportedOSPlatform("windows")]
     internal static extern int GetShortPathName(string path, [Out] char[] fullpath, [In] int length);
 
     [DllImport("kernel32.dll", CharSet = CharSet.Unicode, BestFitMapping = false)]
+    [SupportedOSPlatform("windows")]
     internal static extern int GetLongPathName([In] string path, [Out] char[] fullpath, [In] int length);
 
     [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool CreatePipe(out SafeFileHandle hReadPipe, out SafeFileHandle hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
 
     [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool ReadFile(SafeFileHandle hFile, byte[] lpBuffer, uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, IntPtr lpOverlapped);
 
     /// <summary>
@@ -1549,6 +1594,7 @@ internal static bool SetCurrentDirectory(string path)
     /// build thread which the main thread (blocked on BuildSubmission.Execute) must service.
     /// </summary>
     [DllImport("ole32.dll")]
+    [SupportedOSPlatform("windows")]
     public static extern int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, [MarshalAs(UnmanagedType.LPArray)] IntPtr[] pHandles, out int pdwIndex);
 
     internal const uint GENERIC_READ = 0x80000000;
@@ -1559,6 +1605,7 @@ internal static bool SetCurrentDirectory(string path)
 
     [DllImport("kernel32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall,
         SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern SafeFileHandle CreateFile(
         string lpFileName,
         uint dwDesiredAccess,
@@ -1570,6 +1617,7 @@ IntPtr hTemplateFile
         );
 
     [DllImport("kernel32.dll", SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool GetFileTime(
         SafeFileHandle hFile,
         out FILETIME lpCreationTime,
@@ -1579,58 +1627,15 @@ out FILETIME lpLastWriteTime
 
     [DllImport("kernel32.dll", SetLastError = true)]
     [return: MarshalAs(UnmanagedType.Bool)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool CloseHandle(IntPtr hObject);
 
     [DllImport("kernel32.dll", SetLastError = true)]
+    [SupportedOSPlatform("windows")]
     internal static extern bool SetThreadErrorMode(int newMode, out int oldMode);
 
 #endregion
 
-#region Extensions
-
-    /// <summary>
-    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-    /// servicing COM calls from other threads.
-    /// </summary>
-    [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Scope = "member", Target = "Microsoft.Build.Shared.NativeMethodsShared.#MsgWaitOne(System.Threading.WaitHandle,System.Int32)", Justification = "This is necessary and it has been used for a long time. No need to change it now.")]
-    internal static bool MsgWaitOne(this WaitHandle handle)
-    {
-        return handle.MsgWaitOne(Timeout.Infinite);
-    }
-
-    /// <summary>
-    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-    /// servicing COM calls from other threads.
-    /// </summary>
-    internal static bool MsgWaitOne(this WaitHandle handle, TimeSpan timeout)
-    {
-        return MsgWaitOne(handle, (int)timeout.TotalMilliseconds);
-    }
-
-    /// <summary>
-    /// Waits while pumping APC messages.  This is important if the waiting thread is an STA thread which is potentially
-    /// servicing COM calls from other threads.
-    /// </summary>
-    [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Runtime.InteropServices.SafeHandle.DangerousGetHandle", Justification = "Necessary to avoid pumping")]
-    internal static bool MsgWaitOne(this WaitHandle handle, int timeout)
-    {
-        // CoWaitForMultipleHandles allows us to wait in an STA apartment and still service RPC requests from other threads.
-        // VS needs this in order to allow the in-proc compilers to properly initialize, since they will make calls from the
-        // build thread which the main thread (blocked on BuildSubmission.Execute) must service.
-        int waitIndex;
-        IntPtr handlePtr = handle.SafeWaitHandle.DangerousGetHandle();
-        int returnValue = CoWaitForMultipleHandles(COWAIT_FLAGS.COWAIT_NONE, timeout, 1, new IntPtr[] { handlePtr }, out waitIndex);
-
-        if (!(returnValue == 0 || ((uint)returnValue == RPC_S_CALLPENDING && timeout != Timeout.Infinite)))
-        {
-            throw new InternalErrorException($"Received {returnValue} from CoWaitForMultipleHandles, but expected 0 (S_OK)");
-        }
-
-        return returnValue == 0;
-    }
-
-#endregion
-
 #region helper methods
 
     internal static bool DirectoryExists(string fullPath)
@@ -1640,6 +1645,7 @@ internal static bool DirectoryExists(string fullPath)
             : Directory.Exists(fullPath);
     }
 
+    [SupportedOSPlatform("windows")]
     internal static bool DirectoryExistsWindows(string fullPath)
     {
         WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
@@ -1654,6 +1660,7 @@ internal static bool FileExists(string fullPath)
             : File.Exists(fullPath);
     }
 
+    [SupportedOSPlatform("windows")]
     internal static bool FileExistsWindows(string fullPath)
     {
         WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
@@ -1668,6 +1675,7 @@ internal static bool FileOrDirectoryExists(string path)
             : File.Exists(path) || Directory.Exists(path);
     }
 
+    [SupportedOSPlatform("windows")]
     internal static bool FileOrDirectoryExistsWindows(string path)
     {
         WIN32_FILE_ATTRIBUTE_DATA data = new WIN32_FILE_ATTRIBUTE_DATA();
diff --git a/src/Framework/ProjectEvaluationFinishedEventArgs.cs b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
index 530c52f09fd..e38b8cde8a1 100644
--- a/src/Framework/ProjectEvaluationFinishedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationFinishedEventArgs.cs
@@ -5,8 +5,6 @@
 using System.Collections;
 using Microsoft.Build.Framework.Profiler;
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -25,7 +23,7 @@ public ProjectEvaluationFinishedEventArgs()
         /// <summary>
         /// Initializes a new instance of the ProjectEvaluationFinishedEventArgs class.
         /// </summary>
-        public ProjectEvaluationFinishedEventArgs(string message, params object[] messageArgs)
+        public ProjectEvaluationFinishedEventArgs(string? message, params object[]? messageArgs)
             : base(message, helpKeyword: null, senderName: null, DateTime.UtcNow, messageArgs)
         {
         }
@@ -33,22 +31,22 @@ public ProjectEvaluationFinishedEventArgs(string message, params object[] messag
         /// <summary>
         /// Gets or sets the full path of the project that started evaluation.
         /// </summary>
-        public string ProjectFile { get; set; }
+        public string? ProjectFile { get; set; }
 
         /// <summary>
         /// Global properties used during this evaluation.
         /// </summary>
-        public IEnumerable GlobalProperties { get; set; }
+        public IEnumerable? GlobalProperties { get; set; }
 
         /// <summary>
         /// Final set of properties produced by this evaluation.
         /// </summary>
-        public IEnumerable Properties { get; set; }
+        public IEnumerable? Properties { get; set; }
 
         /// <summary>
         /// Final set of items produced by this evaluation.
         /// </summary>
-        public IEnumerable Items { get; set; }
+        public IEnumerable? Items { get; set; }
 
         /// <summary>
         /// The result of profiling a project.
diff --git a/src/Framework/ProjectEvaluationStartedEventArgs.cs b/src/Framework/ProjectEvaluationStartedEventArgs.cs
index 8f64d5c305d..41c0f8154ff 100644
--- a/src/Framework/ProjectEvaluationStartedEventArgs.cs
+++ b/src/Framework/ProjectEvaluationStartedEventArgs.cs
@@ -3,8 +3,6 @@
 
 using System;
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -23,7 +21,7 @@ public ProjectEvaluationStartedEventArgs()
         /// <summary>
         /// Initializes a new instance of the ProjectEvaluationStartedEventArgs class.
         /// </summary>
-        public ProjectEvaluationStartedEventArgs(string message, params object[] messageArgs)
+        public ProjectEvaluationStartedEventArgs(string? message, params object[]? messageArgs)
             : base(message, helpKeyword: null, senderName: null, DateTime.UtcNow, messageArgs)
         {
         }
@@ -31,6 +29,6 @@ public ProjectEvaluationStartedEventArgs(string message, params object[] message
         /// <summary>
         /// Gets or sets the full path of the project that started evaluation.
         /// </summary>
-        public string ProjectFile { get; set; }
+        public string? ProjectFile { get; set; }
     }
 }
diff --git a/src/Framework/ProjectFinishedEventArgs.cs b/src/Framework/ProjectFinishedEventArgs.cs
index 030eddb3e7c..04017a0f2d1 100644
--- a/src/Framework/ProjectFinishedEventArgs.cs
+++ b/src/Framework/ProjectFinishedEventArgs.cs
@@ -5,8 +5,6 @@
 using System.IO;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -40,9 +38,9 @@ protected ProjectFinishedEventArgs()
         /// <param name="succeeded">true indicates project built successfully</param>
         public ProjectFinishedEventArgs
         (
-            string message,
-            string helpKeyword,
-            string projectFile,
+            string? message,
+            string? helpKeyword,
+            string? projectFile,
             bool succeeded
         )
             : this(message, helpKeyword, projectFile, succeeded, DateTime.UtcNow)
@@ -60,9 +58,9 @@ bool succeeded
         /// <param name="eventTimestamp">Timestamp when the event was created</param>
         public ProjectFinishedEventArgs
         (
-            string message,
-            string helpKeyword,
-            string projectFile,
+            string? message,
+            string? helpKeyword,
+            string? projectFile,
             bool succeeded,
             DateTime eventTimestamp
         )
@@ -72,7 +70,7 @@ DateTime eventTimestamp
             this.succeeded = succeeded;
         }
 
-        private string projectFile;
+        private string? projectFile;
         private bool succeeded;
 
         #region CustomSerializationToStream
@@ -105,7 +103,7 @@ internal override void CreateFromStream(BinaryReader reader, int version)
         /// <summary>
         /// Project name
         /// </summary>
-        public string ProjectFile => projectFile;
+        public string? ProjectFile => projectFile;
 
         /// <summary>
         /// True if project built successfully, false otherwise
diff --git a/src/Framework/ProjectStartedEventArgs.cs b/src/Framework/ProjectStartedEventArgs.cs
index 6601476f8e7..2a005edc4c9 100644
--- a/src/Framework/ProjectStartedEventArgs.cs
+++ b/src/Framework/ProjectStartedEventArgs.cs
@@ -9,8 +9,6 @@
 using System.Linq;
 using Microsoft.Build.Shared;
 
-#nullable disable
-
 namespace Microsoft.Build.Framework
 {
     /// <summary>
@@ -203,12 +201,12 @@ public int ProjectId
         }
 
         [OptionalField(VersionAdded = 2)]
-        private BuildEventContext parentProjectBuildEventContext;
+        private BuildEventContext? parentProjectBuildEventContext;
 
         /// <summary>
         /// Event context information, where the event was fired from in terms of the build location
         /// </summary>
-        public BuildEventContext ParentProjectBuildEventContext
+        public BuildEventContext? ParentProjectBuildEventContext
         {
             get
             {
@@ -219,12 +217,12 @@ public BuildEventContext ParentProjectBuildEventContext
         /// <summary>
         /// The name of the project file
         /// </summary>
-        private string projectFile;
+        private string? projectFile;
 
         /// <summary>
         /// Project name
         /// </summary>
-        public string ProjectFile
+        public string? ProjectFile
         {
             get
             {
@@ -235,12 +233,12 @@ public string ProjectFile
         /// <summary>
         /// Targets that we will build in the project
         /// </summary>
-        private string targetNames;
+        private string? targetNames;
 
         /// <summary>
         /// Targets that we will build in the project
         /// </summary>
-        public string TargetNames
+        public string? TargetNames
         {
             get
             {
@@ -252,12 +250,12 @@ public string TargetNames
         /// Gets the set of global properties used to evaluate this project.
         /// </summary>
         [OptionalField(VersionAdded = 2)]
-        private IDictionary<string, string> globalProperties;
+        private IDictionary<string, string>? globalProperties;
 
         /// <summary>
         /// Gets the set of global properties used to evaluate this project.
         /// </summary>
-        public IDictionary<string, string> GlobalProperties
+        public IDictionary<string, string>? GlobalProperties
         {
             get
             {
@@ -271,12 +269,12 @@ internal set
         }
 
         [OptionalField(VersionAdded = 2)]
-        private string toolsVersion;
+        private string? toolsVersion;
 
         /// <summary>
         /// Gets the tools version used to evaluate this project.
         /// </summary>
-        public string ToolsVersion
+        public string? ToolsVersion
         {
             get
             {
@@ -293,12 +291,12 @@ internal set
         // (a) this event will not be thrown by tasks, so it should not generally cross AppDomain boundaries
         // (b) this event still makes sense when this field is "null"
         [NonSerialized]
-        private IEnumerable properties;
+        private IEnumerable? properties;
 
         /// <summary>
         /// List of properties in this project. This is a live, read-only list.
         /// </summary>
-        public IEnumerable Properties
+        public IEnumerable? Properties
         {
             get
             {
@@ -318,12 +316,12 @@ public IEnumerable Properties
         // (a) this event will not be thrown by tasks, so it should not generally cross AppDomain boundaries
         // (b) this event still makes sense when this field is "null"
         [NonSerialized]
-        private IEnumerable items;
+        private IEnumerable? items;
 
         /// <summary>
         /// List of items in this project. This is a live, read-only list.
         /// </summary>
-        public IEnumerable Items
+        public IEnumerable? Items
         {
             get
             {
@@ -367,7 +365,7 @@ internal override void WriteToStream(BinaryWriter writer)
             writer.WriteOptionalString(projectFile);
 
             // TargetNames cannot be null as per the constructor
-            writer.Write(targetNames);
+            writer.Write(targetNames!);
 
             // If no properties were added to the property list 
             // then we have nothing to create when it is deserialized
@@ -391,7 +389,7 @@ internal override void WriteToStream(BinaryWriter writer)
                 foreach (var propertyPair in validProperties)
                 {
                     writer.Write((string)propertyPair.Key);
-                    writer.Write((string)propertyPair.Value);
+                    writer.Write((string?)propertyPair.Value ?? "");
                 }
             }
         }
@@ -491,14 +489,14 @@ public override string Message
             {
                 if (RawMessage == null)
                 {
-                    string projectFilePath = Path.GetFileName(ProjectFile);
+                    string? projectFilePath = Path.GetFileName(ProjectFile);
 
                     // Check to see if the there are any specific target names to be built.
                     // If targetNames is null or empty then we will be building with the
                     // default targets.
                     if (!string.IsNullOrEmpty(TargetNames))
                     {
-                        RawMessage = FormatResourceStringIgnoreCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithTargetNames", projectFilePath, TargetNames);
+                        RawMessage = FormatResourceStringIgnoreCodeAndKeyword("ProjectStartedPrefixForTopLevelProjectWithTargetNames", projectFilePath, TargetNames!);
                     }
                     else
                     {
diff --git a/src/Framework/TaskPropertyInfo.cs b/src/Framework/TaskPropertyInfo.cs
index 449354b5e43..3d06ce4d747 100644
--- a/src/Framework/TaskPropertyInfo.cs
+++ b/src/Framework/TaskPropertyInfo.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Reflection;
 
 #nullable disable
 
@@ -26,6 +27,9 @@ public TaskPropertyInfo(string name, Type typeOfParameter, bool output, bool req
             PropertyType = typeOfParameter;
             Output = output;
             Required = required;
+            Type elementType = typeOfParameter.IsArray ? typeOfParameter.GetElementType() : typeOfParameter;
+            IsValueTypeOutputParameter = elementType.GetTypeInfo().IsValueType || elementType.FullName.Equals("System.String");
+            IsAssignableToITask = typeof(ITaskItem).IsAssignableFrom(elementType);
         }
 
         /// <summary>
@@ -62,5 +66,8 @@ public TaskPropertyInfo(string name, Type typeOfParameter, bool output, bool req
         /// Whether the Log and LogItemMetadata properties have been assigned already.
         /// </summary>
         internal bool Initialized = false;
+
+        internal bool IsValueTypeOutputParameter { get; private set; }
+        internal bool IsAssignableToITask { get; set; }
     }
 }
diff --git a/src/Framework/Telemetry/BuildTelemetry.cs b/src/Framework/Telemetry/BuildTelemetry.cs
new file mode 100644
index 00000000000..45e7537ff7c
--- /dev/null
+++ b/src/Framework/Telemetry/BuildTelemetry.cs
@@ -0,0 +1,145 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Globalization;
+
+namespace Microsoft.Build.Framework.Telemetry
+{
+    /// <summary>
+    /// Telemetry of build.
+    /// </summary>
+    internal class BuildTelemetry : TelemetryBase
+    {
+        public override string EventName => "build";
+
+        /// <summary>
+        /// Time at which build have started.
+        /// </summary>
+        /// <remarks>
+        /// It is time when build started, not when BuildManager start executing build.
+        /// For example in case of MSBuild Server it is time before we connected or launched MSBuild Server.
+        /// </remarks>
+        public DateTime? StartAt { get; set; }
+
+        /// <summary>
+        /// Time at which inner build have started.
+        /// </summary>
+        /// <remarks>
+        /// It is time when build internally started, i.e. when BuildManager starts it.
+        /// In case of MSBuild Server it is time when Server starts build.
+        /// </remarks>
+        public DateTime? InnerStartAt { get; set; }
+
+        /// <summary>
+        /// Time at which build have finished.
+        /// </summary>
+        public DateTime? FinishedAt { get; set; }
+
+        /// <summary>
+        /// Overall build success.
+        /// </summary>
+        public bool? Success { get; set; }
+
+        /// <summary>
+        /// Build Target.
+        /// </summary>
+        public string? Target { get; set; }
+
+        /// <summary>
+        /// MSBuild server fallback reason.
+        /// Either "ServerBusy", "ConnectionError" or null (no fallback).
+        /// </summary>
+        public string? ServerFallbackReason { get; set; }
+
+        /// <summary>
+        /// Version of MSBuild.
+        /// </summary>
+        public Version? Version { get; set; }
+
+        /// <summary>
+        /// Display version of the Engine suitable for display to a user.
+        /// </summary>
+        public string? DisplayVersion { get; set; }
+
+        /// <summary>
+        /// Path to project file.
+        /// </summary>
+        public string? Project { get; set; }
+
+        /// <summary>
+        /// Host in which MSBuild build was executed.
+        /// For example: "VS", "VSCode", "Azure DevOps", "GitHub Action", "CLI", ...
+        /// </summary>
+        public string? Host { get; set; }
+
+        /// <summary>
+        /// State of MSBuild server process before this build.
+        /// One of 'cold', 'hot', null (if not run as server)
+        /// </summary>
+        public string? InitialServerState { get; set; }
+
+        /// <summary>
+        /// Framework name suitable for display to a user.
+        /// </summary>
+        public string? FrameworkName { get; set; }
+
+        public override void UpdateEventProperties()
+        {
+            if (DisplayVersion != null)
+            {
+                Properties["BuildEngineDisplayVersion"] = DisplayVersion;
+            }
+
+            if (StartAt.HasValue && FinishedAt.HasValue)
+            {
+                Properties["BuildDurationInMilliseconds"] = (FinishedAt.Value - StartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+            }
+
+            if (InnerStartAt.HasValue && FinishedAt.HasValue)
+            {
+                Properties["InnerBuildDurationInMilliseconds"] = (FinishedAt.Value - InnerStartAt.Value).TotalMilliseconds.ToString(CultureInfo.InvariantCulture);
+            }
+
+            if (FrameworkName != null)
+            {
+                Properties["BuildEngineFrameworkName"] = FrameworkName;
+            }
+
+            if (Host != null)
+            {
+                Properties["BuildEngineHost"] = Host;
+            }
+
+            if (InitialServerState != null)
+            {
+                Properties["InitialMSBuildServerState"] = InitialServerState;
+            }
+
+            if (Project != null)
+            {
+                Properties["ProjectPath"] = Project;
+            }
+
+            if (ServerFallbackReason != null)
+            {
+                Properties["ServerFallbackReason"] = ServerFallbackReason;
+            }
+
+            if (Success.HasValue)
+            {
+                Properties["BuildSuccess"] = Success.HasValue.ToString(CultureInfo.InvariantCulture);
+            }
+
+            if (Target != null)
+            {
+                Properties["BuildTarget"] = Target;
+            }
+
+            if (Version != null)
+            {
+                Properties["BuildEngineVersion"] = Version.ToString();
+            }
+        }
+    }
+}
diff --git a/src/Framework/Telemetry/KnownTelemetry.cs b/src/Framework/Telemetry/KnownTelemetry.cs
new file mode 100644
index 00000000000..5f32304d7e6
--- /dev/null
+++ b/src/Framework/Telemetry/KnownTelemetry.cs
@@ -0,0 +1,17 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+namespace Microsoft.Build.Framework.Telemetry;
+
+/// <summary>
+/// Static class to help access and modify known telemetries.
+/// </summary>
+internal static class KnownTelemetry
+{
+    /// <summary>
+    /// Telemetry for build.
+    /// If null Telemetry is not supposed to be emitted.
+    /// After telemetry is emitted, sender shall null it.
+    /// </summary>
+    public static BuildTelemetry? BuildTelemetry { get; set; }
+}
diff --git a/src/Framework/Telemetry/TelemetryBase.cs b/src/Framework/Telemetry/TelemetryBase.cs
new file mode 100644
index 00000000000..26348f1ea4f
--- /dev/null
+++ b/src/Framework/Telemetry/TelemetryBase.cs
@@ -0,0 +1,24 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System.Collections.Generic;
+
+namespace Microsoft.Build.Framework.Telemetry;
+
+internal abstract class TelemetryBase
+{
+    /// <summary>
+    /// Gets or sets the name of the event.
+    /// </summary>
+    public abstract string EventName { get; }
+
+    /// <summary>
+    /// Gets or sets a list of properties associated with the event.
+    /// </summary>
+    public IDictionary<string, string> Properties { get; set; } = new Dictionary<string, string>();
+
+    /// <summary>
+    /// Translate all derived type members into properties which will be used to build <see cref="TelemetryEventArgs"/>.
+    /// </summary>
+    public abstract void UpdateEventProperties();
+}
diff --git a/src/Framework/Traits.cs b/src/Framework/Traits.cs
index e9f5083db68..72091def7ac 100644
--- a/src/Framework/Traits.cs
+++ b/src/Framework/Traits.cs
@@ -2,6 +2,7 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -87,18 +88,19 @@ public Traits()
         public readonly bool EmitSolutionMetaproj = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildEmitSolution"));
 
         /// <summary>
-        /// Log statistics about property functions which require reflection
+        /// Modifies Solution Generator to generate a metaproj that batches multiple Targets into one MSBuild task invoke.
         /// </summary>
-        public readonly bool LogPropertyFunctionsRequiringReflection = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection"));
+        /// <remarks>
+        /// For example, a run of Clean;Build target will first run Clean on all projects,
+        /// then run Build on all projects.  When enabled, it will run Clean;Build on all
+        /// Projects at the back to back.  Allowing the second target to start sooner than before.
+        /// </remarks>
+        public readonly bool SolutionBatchTargets = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildSolutionBatchTargets"));
 
         /// <summary>
-        /// Log all environment variables whether or not they are used in a build in the binary log.
+        /// Log statistics about property functions which require reflection
         /// </summary>
-        public readonly bool LogAllEnvironmentVariables = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDLOGALLENVIRONMENTVARIABLES"))
-#if !TASKHOST
-            && ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4)
-#endif
-            ;
+        public readonly bool LogPropertyFunctionsRequiringReflection = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildLogPropertyFunctionsRequiringReflection"));
 
         /// <summary>
         /// Log property tracking information.
@@ -110,6 +112,11 @@ public Traits()
         /// </summary>
         public readonly int DictionaryBasedItemRemoveThreshold = ParseIntFromEnvironmentVariableOrDefault("MSBUILDDICTIONARYBASEDITEMREMOVETHRESHOLD", 100);
 
+        /// <summary>
+        /// Name of environment variables used to enable MSBuild server.
+        /// </summary>
+        public const string UseMSBuildServerEnvVarName = "MSBUILDUSESERVER";
+
         public readonly bool DebugEngine = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildDebugEngine"));
         public readonly bool DebugScheduler;
         public readonly bool DebugNodeCommunication;
diff --git a/src/MSBuild.UnitTests/MSBuildServer_Tests.cs b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
new file mode 100644
index 00000000000..f521f0949f0
--- /dev/null
+++ b/src/MSBuild.UnitTests/MSBuildServer_Tests.cs
@@ -0,0 +1,233 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using System.Diagnostics;
+using System.Reflection;
+using System.Text.RegularExpressions;
+using System.Threading;
+using System.Threading.Tasks;
+using Microsoft.Build.Framework;
+using Microsoft.Build.Shared;
+using Microsoft.Build.UnitTests;
+using Microsoft.Build.UnitTests.Shared;
+#if NETFRAMEWORK
+using Microsoft.IO;
+#else
+using System.IO;
+#endif
+using Shouldly;
+using Xunit;
+using Xunit.Abstractions;
+
+namespace Microsoft.Build.Engine.UnitTests
+{
+    public class SleepingTask : Microsoft.Build.Utilities.Task
+    {
+        public int SleepTime { get; set; }
+
+        /// <summary>
+        /// Sleep for SleepTime milliseconds.
+        /// </summary>
+        /// <returns>Success on success.</returns>
+        public override bool Execute()
+        {
+            Thread.Sleep(SleepTime);
+            return !Log.HasLoggedErrors;
+        }
+    }
+
+    public class ProcessIdTask : Microsoft.Build.Utilities.Task
+    {
+        [Output]
+        public int Pid { get; set; }
+
+        /// <summary>
+        /// Log the id for this process.
+        /// </summary>
+        /// <returns></returns>
+        public override bool Execute()
+        {
+            Pid = Process.GetCurrentProcess().Id;
+            return true;
+        }
+    }
+
+    public class MSBuildServer_Tests : IDisposable
+    {
+        private readonly ITestOutputHelper _output;
+        private readonly TestEnvironment _env;
+        private static string printPidContents = @$"
+<Project>
+<UsingTask TaskName=""ProcessIdTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
+    <Target Name='AccessPID'>
+        <ProcessIdTask>
+            <Output PropertyName=""PID"" TaskParameter=""Pid"" />
+        </ProcessIdTask>
+        <Message Text=""Server ID is $(PID)"" Importance=""High"" />
+    </Target>
+</Project>";
+        private static string sleepingTaskContents = @$"
+<Project>
+<UsingTask TaskName=""SleepingTask"" AssemblyFile=""{Assembly.GetExecutingAssembly().Location}"" />
+    <Target Name='Sleep'>
+        <SleepingTask SleepTime=""100000"" />
+    </Target>
+</Project>";
+
+        public MSBuildServer_Tests(ITestOutputHelper output)
+        {
+            _output = output;
+            _env = TestEnvironment.Create(_output);
+        }
+
+        public void Dispose() => _env.Dispose();
+
+        [Fact]
+        public void MSBuildServerTest()
+        {
+            TransientTestFile project = _env.CreateFile("testProject.proj", printPidContents);
+            _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
+            string output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out bool success, false, _output);
+            success.ShouldBeTrue();
+            int pidOfInitialProcess = ParseNumber(output, "Process ID is ");
+            int pidOfServerProcess = ParseNumber(output, "Server ID is ");
+            pidOfInitialProcess.ShouldNotBe(pidOfServerProcess, "We started a server node to execute the target rather than running it in-proc, so its pid should be different.");
+
+            output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out success, false, _output);
+            success.ShouldBeTrue();
+            int newPidOfInitialProcess = ParseNumber(output, "Process ID is ");
+            newPidOfInitialProcess.ShouldNotBe(pidOfServerProcess, "We started a server node to execute the target rather than running it in-proc, so its pid should be different.");
+            newPidOfInitialProcess.ShouldNotBe(pidOfInitialProcess, "Process started by two MSBuild executions should be different.");
+            pidOfServerProcess.ShouldBe(ParseNumber(output, "Server ID is "), "Node used by both the first and second build should be the same.");
+
+            // Prep to kill the long-lived task we're about to start.
+            Task t = Task.Run(() =>
+            {
+                // Wait for the long-lived task to start
+                // If this test seems to fail randomly, increase this time.
+                Thread.Sleep(1000);
+
+                // Kill the server
+                Process.GetProcessById(pidOfServerProcess).KillTree(1000);
+            });
+
+            // Start long-lived task execution
+            TransientTestFile sleepProject = _env.CreateFile("napProject.proj", sleepingTaskContents);
+            RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, sleepProject.Path, out _);
+
+            t.Wait();
+
+            // Ensure that a new build can still succeed and that its server node is different.
+            output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out success, false, _output);
+
+            success.ShouldBeTrue();
+            newPidOfInitialProcess = ParseNumber(output, "Process ID is ");
+            int newServerProcessId = ParseNumber(output, "Server ID is ");
+            // Register process to clean up (be killed) after tests ends.
+            _env.WithTransientProcess(newServerProcessId);
+            newPidOfInitialProcess.ShouldNotBe(pidOfInitialProcess, "Process started by two MSBuild executions should be different.");
+            newPidOfInitialProcess.ShouldNotBe(newServerProcessId, "We started a server node to execute the target rather than running it in-proc, so its pid should be different.");
+            pidOfServerProcess.ShouldNotBe(newServerProcessId, "Node used by both the first and second build should not be the same.");
+        }
+
+        [Fact]
+        public void VerifyMixedLegacyBehavior()
+        {
+            TransientTestFile project = _env.CreateFile("testProject.proj", printPidContents);
+            _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
+
+            string output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out bool success, false, _output);
+            success.ShouldBeTrue();
+            int pidOfInitialProcess = ParseNumber(output, "Process ID is ");
+            int pidOfServerProcess = ParseNumber(output, "Server ID is ");
+            // Register process to clean up (be killed) after tests ends.
+            _env.WithTransientProcess(pidOfServerProcess);
+            pidOfInitialProcess.ShouldNotBe(pidOfServerProcess, "We started a server node to execute the target rather than running it in-proc, so its pid should be different.");
+
+            Environment.SetEnvironmentVariable("MSBUILDUSESERVER", "");
+            output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out success, false, _output);
+            success.ShouldBeTrue();
+            pidOfInitialProcess = ParseNumber(output, "Process ID is ");
+            int pidOfNewserverProcess = ParseNumber(output, "Server ID is ");
+            pidOfInitialProcess.ShouldBe(pidOfNewserverProcess, "We did not start a server node to execute the target, so its pid should be the same.");
+
+            Environment.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
+            output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out success, false, _output);
+            success.ShouldBeTrue();
+            pidOfInitialProcess = ParseNumber(output, "Process ID is ");
+            pidOfNewserverProcess = ParseNumber(output, "Server ID is ");
+            pidOfInitialProcess.ShouldNotBe(pidOfNewserverProcess, "We started a server node to execute the target rather than running it in-proc, so its pid should be different.");
+            pidOfServerProcess.ShouldBe(pidOfNewserverProcess, "Server node should be the same as from earlier.");
+
+            if (pidOfServerProcess != pidOfNewserverProcess)
+            {
+                // Register process to clean up (be killed) after tests ends.
+                _env.WithTransientProcess(pidOfNewserverProcess);
+            }
+        }
+
+        [Fact]
+        public void BuildsWhileBuildIsRunningOnServer()
+        {
+            _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
+            TransientTestFile project = _env.CreateFile("testProject.proj", printPidContents);
+            TransientTestFile sleepProject = _env.CreateFile("napProject.proj", sleepingTaskContents);
+
+            int pidOfServerProcess;
+            Task t;
+            // Start a server node and find its PID.
+            string output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out bool success, false, _output);
+            pidOfServerProcess = ParseNumber(output, "Server ID is ");
+            _env.WithTransientProcess(pidOfServerProcess);
+
+            t = Task.Run(() =>
+            {
+                RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, sleepProject.Path, out _, false, _output);
+            });
+
+            // The server will soon be in use; make sure we don't try to use it before that happens.
+            Thread.Sleep(1000);
+
+            Environment.SetEnvironmentVariable("MSBUILDUSESERVER", "0");
+
+            output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out success, false, _output);
+            success.ShouldBeTrue();
+            ParseNumber(output, "Server ID is ").ShouldBe(ParseNumber(output, "Process ID is "), "There should not be a server node for this build.");
+
+            Environment.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
+
+            output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path, out success, false, _output);
+            success.ShouldBeTrue();
+            pidOfServerProcess.ShouldNotBe(ParseNumber(output, "Server ID is "), "The server should be otherwise occupied.");
+            pidOfServerProcess.ShouldNotBe(ParseNumber(output, "Process ID is "), "There should not be a server node for this build.");
+            ParseNumber(output, "Server ID is ").ShouldBe(ParseNumber(output, "Process ID is "), "Process ID and Server ID should coincide.");
+
+            // Clean up process and tasks
+            // 1st kill registered processes
+            _env.Dispose();
+            // 2nd wait for sleep task which will ends as soon as the process is killed above.
+            t.Wait();
+        }
+
+        [Fact]
+        public void ServerShouldNotRunWhenNodeReuseEqualsFalse()
+        {
+            TransientTestFile project = _env.CreateFile("testProject.proj", printPidContents);
+            _env.SetEnvironmentVariable("MSBUILDUSESERVER", "1");
+
+            string output = RunnerUtilities.ExecMSBuild(BuildEnvironmentHelper.Instance.CurrentMSBuildExePath, project.Path + " /nodereuse:false", out bool success, false, _output);
+            success.ShouldBeTrue();
+            int pidOfInitialProcess = ParseNumber(output, "Process ID is ");
+            int pidOfServerProcess = ParseNumber(output, "Server ID is ");
+            pidOfInitialProcess.ShouldBe(pidOfServerProcess, "We started a server node even when nodereuse is false.");
+        }
+
+        private int ParseNumber(string searchString, string toFind)
+        {
+            Regex regex = new(@$"{toFind}(\d+)");
+            Match match = regex.Match(searchString);
+            return int.Parse(match.Groups[1].Value);
+        }
+    }
+}
diff --git a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
index e301c3a16b3..ea90a86c84e 100644
--- a/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
+++ b/src/MSBuild.UnitTests/Microsoft.Build.CommandLine.UnitTests.csproj
@@ -28,6 +28,7 @@
     <Compile Include="..\Shared\RegistryDelegates.cs">
       <Link>RegistryDelegates.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\ProcessExtensions.cs" />
     <Compile Include="..\Shared\RegistryHelper.cs">
       <Link>RegistryHelper.cs</Link>
     </Compile>
diff --git a/src/MSBuild/MSBuild.csproj b/src/MSBuild/MSBuild.csproj
index 9ea8cc2fcf8..2fd51da537c 100644
--- a/src/MSBuild/MSBuild.csproj
+++ b/src/MSBuild/MSBuild.csproj
@@ -76,6 +76,7 @@
       <Link>FileUtilities.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="..\Build\Instance\ReflectableTaskPropertyInfo.cs" />
     <Compile Include="..\Shared\FileUtilitiesRegex.cs">
       <Link>FileUtilitiesRegex.cs</Link>
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
@@ -174,6 +175,7 @@
     <Compile Include="InitializationException.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="MSBuildClientApp.cs" />
     <Compile Include="NodeEndpointOutOfProcTaskHost.cs" />
     <Compile Include="LogMessagePacket.cs" />
     <Compile Include="ProjectSchemaValidationHandler.cs">
@@ -228,10 +230,10 @@
     <Reference Include="System.Xml" />
     <PackageReference Include="LargeAddressAware" PrivateAssets="All" />
   </ItemGroup>
-  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
+  <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework' AND '$(DotNetBuildFromSource)' != 'true'">
     <!-- Bump these to the latest version despite transitive references to older -->
-    <PackageReference Include="System.Private.Uri" />
-    <PackageReference Include="System.Runtime" />
+    <PackageReference Include="System.Private.Uri" PrivateAssets="all" />
+    <PackageReference Include="System.Runtime" PrivateAssets="all" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\Build\Microsoft.Build.csproj" />
diff --git a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
index 132326e7230..c0bb91a4e56 100644
--- a/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
+++ b/src/MSBuild/MSBuild/Microsoft.Build.CommonTypes.xsd
@@ -1958,7 +1958,7 @@ elementFormDefault="qualified">
         <xs:documentation><!-- _locID_text="PreserveCompilationContext" _locComment="" -->Value indicating whether reference assemblies can be used in dynamic compilation</xs:documentation>
       </xs:annotation>
     </xs:element>
-    <xs:element name="ProduceReferenceAssemblies" type="msb:boolean" substitutionGroup="msb:Property" />
+    <xs:element name="ProduceReferenceAssembly" type="msb:boolean" substitutionGroup="msb:Property" />
     <xs:element name="ProductName" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ProductVersion" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
     <xs:element name="ProjectGuid" type="msb:StringPropertyType" substitutionGroup="msb:Property"/>
@@ -2356,9 +2356,14 @@ elementFormDefault="qualified">
         <xs:documentation><!-- _locID_text="PublishReadyToRun" _locComment="" -->Indicates whether the project should produce ReadyToRun images during publish.</xs:documentation>
       </xs:annotation>
     </xs:element>
+    <xs:element name="PublishAot" type="msb:boolean" substitutionGroup="msb:Property">
+      <xs:annotation>
+        <xs:documentation><!-- _locID_text="PublishAot" _locComment="" -->Indicates whether the project should produce native ahead-of-time compiled images during publish.</xs:documentation>
+      </xs:annotation>
+    </xs:element>
     <xs:element name="PublishSingleFile" type="msb:boolean" substitutionGroup="msb:Property">
       <xs:annotation>
-        <xs:documentation><!-- _locID_text="PublishSingleFile" _locComment="" -->Indicates whether the project should produce a self-extracting executable during publish.</xs:documentation>
+        <xs:documentation><!-- _locID_text="PublishSingleFile" _locComment="" -->Indicates whether the project should bundle all application-dependent files into a single binary during publish.</xs:documentation>
       </xs:annotation>
     </xs:element>
     <xs:element name="PublishTrimmed" type="msb:boolean" substitutionGroup="msb:Property">
@@ -2368,12 +2373,12 @@ elementFormDefault="qualified">
     </xs:element>
     <xs:element name="TrimmerRootAssembly" type="msb:StringPropertyType" substitutionGroup="msb:Property">
       <xs:annotation>
-        <xs:documentation><!-- _locID_text="TrimmerRootAssembly" _locComment="" -->Indicates to the linker to explicitly keep an assembly by adding it to your csproj (use the assembly name without extension).</xs:documentation>
+        <xs:documentation><!-- _locID_text="TrimmerRootAssembly" _locComment="" -->Assemblies that should not be trimmed (specify the assembly name without extension).</xs:documentation>
       </xs:annotation>
     </xs:element>
     <xs:element name="TrimmerRootDescriptor" type="msb:StringPropertyType" substitutionGroup="msb:Property">
       <xs:annotation>
-        <xs:documentation><!-- _locID_text="TrimmerRootDescriptor" _locComment="" -->Gives the linker a more specific list of types/methods, etc. to include. Path to an xml file.</xs:documentation>
+        <xs:documentation><!-- _locID_text="TrimmerRootDescriptor" _locComment="" -->XML files that specify assemblies, types, and their members that should not be trimmed.</xs:documentation>
       </xs:annotation>
     </xs:element>
 
diff --git a/src/MSBuild/MSBuildClientApp.cs b/src/MSBuild/MSBuildClientApp.cs
new file mode 100644
index 00000000000..9177f76aa19
--- /dev/null
+++ b/src/MSBuild/MSBuildClientApp.cs
@@ -0,0 +1,127 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using System;
+using Microsoft.Build.Shared;
+using System.Threading;
+using Microsoft.Build.Experimental;
+using Microsoft.Build.Framework.Telemetry;
+
+#if RUNTIME_TYPE_NETCORE || MONO
+using System.IO;
+using System.Diagnostics;
+#endif
+
+namespace Microsoft.Build.CommandLine
+{
+    /// <summary>
+    /// This class implements client for MSBuild server. It
+    /// 1. starts the MSBuild server in a separate process if it does not yet exist.
+    /// 2. establishes a connection with MSBuild server and sends a build request.
+    /// 3. if server is busy, it falls back to old build behavior.
+    /// </summary>
+    internal static class MSBuildClientApp
+    {
+        /// <summary>
+        /// This is the entry point for the MSBuild client.
+        /// </summary>
+        /// <param name="commandLine">The command line to process. The first argument
+        /// on the command line is assumed to be the name/path of the executable, and
+        /// is ignored.</param>
+        /// <param name="cancellationToken">Cancellation token.</param>
+        /// <returns>A value of type <see cref="MSBuildApp.ExitType"/> that indicates whether the build succeeded,
+        /// or the manner in which it failed.</returns>
+        /// <remarks>
+        /// The locations of msbuild exe/dll and dotnet.exe would be automatically detected if called from dotnet or msbuild cli. Calling this function from other executables might not work.
+        /// </remarks>
+        public static MSBuildApp.ExitType Execute(
+#if FEATURE_GET_COMMANDLINE
+            string commandLine,
+#else
+            string[] commandLine,
+#endif
+            CancellationToken cancellationToken
+            )
+        {
+            string msbuildLocation = BuildEnvironmentHelper.Instance.CurrentMSBuildExePath;
+
+            return Execute(
+                commandLine,
+                msbuildLocation,
+                cancellationToken);
+        }
+
+        /// <summary>
+        /// This is the entry point for the MSBuild client.
+        /// </summary>
+        /// <param name="commandLine">The command line to process. The first argument
+        /// on the command line is assumed to be the name/path of the executable, and
+        /// is ignored.</param>
+        /// <param name="msbuildLocation"> Full path to current MSBuild.exe if executable is MSBuild.exe,
+        /// or to version of MSBuild.dll found to be associated with the current process.</param>
+        /// <param name="cancellationToken">Cancellation token.</param>
+        /// <returns>A value of type <see cref="MSBuildApp.ExitType"/> that indicates whether the build succeeded,
+        /// or the manner in which it failed.</returns>
+        public static MSBuildApp.ExitType Execute(
+#if FEATURE_GET_COMMANDLINE
+            string commandLine,
+#else
+            string[] commandLine,
+#endif
+            string msbuildLocation,
+            CancellationToken cancellationToken)
+        {
+            MSBuildClient msbuildClient = new MSBuildClient(commandLine, msbuildLocation); 
+            MSBuildClientExitResult exitResult = msbuildClient.Execute(cancellationToken);
+
+            if (exitResult.MSBuildClientExitType == MSBuildClientExitType.ServerBusy ||
+                exitResult.MSBuildClientExitType == MSBuildClientExitType.UnableToConnect ||
+                exitResult.MSBuildClientExitType == MSBuildClientExitType.LaunchError)
+            {
+                if (KnownTelemetry.BuildTelemetry != null)
+                {
+                    KnownTelemetry.BuildTelemetry.ServerFallbackReason = exitResult.MSBuildClientExitType.ToString();
+                }
+
+                // Server is busy, fallback to old behavior.
+                return MSBuildApp.Execute(commandLine);
+            }
+
+            if (exitResult.MSBuildClientExitType == MSBuildClientExitType.Success &&
+                Enum.TryParse(exitResult.MSBuildAppExitTypeString, out MSBuildApp.ExitType MSBuildAppExitType))
+            {
+                // The client successfully set up a build task for MSBuild server and received the result.
+                // (Which could be a failure as well). Return the received exit type. 
+                return MSBuildAppExitType;
+            }
+
+            return MSBuildApp.ExitType.MSBuildClientFailure;
+        }
+
+        // Copied from NodeProviderOutOfProcBase.cs
+#if RUNTIME_TYPE_NETCORE || MONO
+        private static string? CurrentHost;
+        private static string GetCurrentHost()
+        {
+            if (CurrentHost == null)
+            {
+                string dotnetExe = Path.Combine(FileUtilities.GetFolderAbove(BuildEnvironmentHelper.Instance.CurrentMSBuildToolsDirectory, 2),
+                    NativeMethodsShared.IsWindows ? "dotnet.exe" : "dotnet");
+                if (File.Exists(dotnetExe))
+                {
+                    CurrentHost = dotnetExe;
+                }
+                else
+                {
+                    using (Process currentProcess = Process.GetCurrentProcess())
+                    {
+                        CurrentHost = currentProcess.MainModule?.FileName ?? throw new InvalidOperationException("Failed to retrieve process executable.");
+                    }
+                }
+            }
+
+            return CurrentHost;
+        }
+#endif
+    }
+}
diff --git a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
index adb4e7931cc..10655f84b09 100644
--- a/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
+++ b/src/MSBuild/OutOfProcTaskAppDomainWrapperBase.cs
@@ -115,7 +115,7 @@ IDictionary<string, TaskParameter> taskParams
             try
             {
                 TypeLoader typeLoader = new TypeLoader(TaskLoader.IsTaskClass);
-                taskType = typeLoader.Load(taskName, AssemblyLoadInfo.Create(null, taskLocation));
+                taskType = typeLoader.Load(taskName, AssemblyLoadInfo.Create(null, taskLocation), false);
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
@@ -133,7 +133,7 @@ IDictionary<string, TaskParameter> taskParams
             }
 
             OutOfProcTaskHostTaskResult taskResult;
-            if (taskType.HasSTAThreadAttribute())
+            if (taskType.HasSTAThreadAttribute)
             {
 #if FEATURE_APARTMENT_STATE
                 taskResult = InstantiateAndExecuteTaskInSTAThread(oopTaskHostNode, taskType, taskName, taskLocation, taskFile, taskLine, taskColumn,
diff --git a/src/MSBuild/Resources/Strings.resx b/src/MSBuild/Resources/Strings.resx
index 8bf7155cbac..5701c2d3cc9 100644
--- a/src/MSBuild/Resources/Strings.resx
+++ b/src/MSBuild/Resources/Strings.resx
@@ -317,7 +317,9 @@
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
diff --git a/src/MSBuild/Resources/xlf/Strings.cs.xlf b/src/MSBuild/Resources/xlf/Strings.cs.xlf
index 6119ea4e085..83498322bea 100644
--- a/src/MSBuild/Resources/xlf/Strings.cs.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.cs.xlf
@@ -508,13 +508,15 @@
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleloggerparameters:&lt;parameters&gt;
+        <target state="needs-review-translation">  -consoleloggerparameters:&lt;parameters&gt;
                      Parametry protokolovacího nástroje konzoly. (Krátký tvar: -clp)
                      Dostupné parametry:
                         PerformanceSummary – zobrazí dobu zpracování úloh, cílů
diff --git a/src/MSBuild/Resources/xlf/Strings.de.xlf b/src/MSBuild/Resources/xlf/Strings.de.xlf
index 2b6914c41b7..a4661df67c5 100644
--- a/src/MSBuild/Resources/xlf/Strings.de.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.de.xlf
@@ -505,13 +505,15 @@ Beispiel:
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleloggerparameters:&lt;Parameter&gt;
+        <target state="needs-review-translation">  -consoleloggerparameters:&lt;Parameter&gt;
                      Parameter für die Konsolenprotokollierung. (Kurzform: -clp)
                      Folgende Parameter sind verfügbar:
                         PerformanceSummary: Zeigt die in Aufgaben, Zielen und
diff --git a/src/MSBuild/Resources/xlf/Strings.es.xlf b/src/MSBuild/Resources/xlf/Strings.es.xlf
index e0d7c14e8ad..0264ff8e278 100644
--- a/src/MSBuild/Resources/xlf/Strings.es.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.es.xlf
@@ -509,13 +509,15 @@
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleLoggerParameters:&lt;parámetros&gt;
+        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parámetros&gt;
                      Parámetros del registrador de consola. (Forma corta: -clp)
                      Los parámetros disponibles son:
                         PerformanceSummary: muestra el tiempo empleado en tareas, destinos
diff --git a/src/MSBuild/Resources/xlf/Strings.fr.xlf b/src/MSBuild/Resources/xlf/Strings.fr.xlf
index 0372c4900f0..f67550e3ebe 100644
--- a/src/MSBuild/Resources/xlf/Strings.fr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.fr.xlf
@@ -505,13 +505,15 @@
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleLoggerParameters:&lt;paramètres&gt;
+        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;paramètres&gt;
          Paramètres du journaliseur de la console. (Forme abrégée : -clp)
          Paramètres disponibles :
             PerformanceSummary--Affiche la durée des tâches, des cibles
diff --git a/src/MSBuild/Resources/xlf/Strings.it.xlf b/src/MSBuild/Resources/xlf/Strings.it.xlf
index 4721ca9afcb..16817ae88bf 100644
--- a/src/MSBuild/Resources/xlf/Strings.it.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.it.xlf
@@ -515,13 +515,15 @@ Esempio:
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleLoggerParameters:&lt;parametri&gt;
+        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parametri&gt;
                       Parametri per il logger di console. Forma breve: -clp.
                       I parametri disponibili sono:
                       PerformanceSummary: indica il tempo impiegato per le
diff --git a/src/MSBuild/Resources/xlf/Strings.ja.xlf b/src/MSBuild/Resources/xlf/Strings.ja.xlf
index e3fd2d55895..0d83ec719f6 100644
--- a/src/MSBuild/Resources/xlf/Strings.ja.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ja.xlf
@@ -505,13 +505,15 @@
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parameters&gt;
                      コンソール ロガーへのパラメーターです。(短縮形: -clp)
                      利用可能なパラメーター:
                         PerformanceSummary--タスク、ターゲット、プロジェクトにかかった時間を
diff --git a/src/MSBuild/Resources/xlf/Strings.ko.xlf b/src/MSBuild/Resources/xlf/Strings.ko.xlf
index c15244ecb8c..996484c8d56 100644
--- a/src/MSBuild/Resources/xlf/Strings.ko.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ko.xlf
@@ -505,13 +505,15 @@
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parameters&gt;
                      콘솔 로거에 대한 매개 변수입니다. (약식: -clp)
                      사용 가능한 매개 변수는 다음과 같습니다.
                         PerformanceSummary--작업, 대상 및 프로젝트에서 소요된 시간을 
diff --git a/src/MSBuild/Resources/xlf/Strings.pl.xlf b/src/MSBuild/Resources/xlf/Strings.pl.xlf
index b170f13dc44..1e40a134ce5 100644
--- a/src/MSBuild/Resources/xlf/Strings.pl.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pl.xlf
@@ -515,13 +515,15 @@
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleLoggerParameters:&lt;parametry&gt;
+        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parametry&gt;
                      Parametry rejestratora konsoli. (Krótka wersja: -clp)
                      Dostępne parametry:
                         PerformanceSummary — pokazuje czas spędzony
diff --git a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
index 0d41ea796de..157b81ac122 100644
--- a/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.pt-BR.xlf
@@ -506,13 +506,15 @@ isoladamente.
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleLoggerParameters:&lt;parameters&gt;
+        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parameters&gt;
                      Parâmetros do agente do console. (Forma abreviada: -clp)
                      Os parâmetros disponíveis são:
                         PerformanceSummary – mostrar o tempo gasto nas tarefas, nos destinos
diff --git a/src/MSBuild/Resources/xlf/Strings.ru.xlf b/src/MSBuild/Resources/xlf/Strings.ru.xlf
index 9f729cfd401..339b3ce1319 100644
--- a/src/MSBuild/Resources/xlf/Strings.ru.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.ru.xlf
@@ -504,13 +504,15 @@
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleLoggerParameters:&lt;параметры&gt;
+        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;параметры&gt;
                      Параметры журнала консоли. (Краткая форма: -clp)
                      Доступны следующие параметры:
                         PerformanceSummary--выводить время, затраченное на выполнение задач,
diff --git a/src/MSBuild/Resources/xlf/Strings.tr.xlf b/src/MSBuild/Resources/xlf/Strings.tr.xlf
index 9d761e71fdf..3a7140e5fa4 100644
--- a/src/MSBuild/Resources/xlf/Strings.tr.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.tr.xlf
@@ -505,13 +505,15 @@
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleLoggerParameters:&lt;parametreler&gt;
+        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;parametreler&gt;
                      Konsol günlükçüsü için parametreler. (Kısa biçim: -clp)
                      Kullanılabilir parametreler:
                         PerformanceSummary--Görevlerde, hedeflerde ve 
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
index 98030b258e3..ce870f5b882 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hans.xlf
@@ -505,13 +505,15 @@
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleloggerparameters:&lt;parameters&gt;
+        <target state="needs-review-translation">  -consoleloggerparameters:&lt;parameters&gt;
            控制台记录器的参数。(缩写: -clp)
            可用参数包括:
             PerformanceSummary -- 显示在任务、目标和项目上
diff --git a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
index 1ea6492f634..4458f52f1cc 100644
--- a/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
+++ b/src/MSBuild/Resources/xlf/Strings.zh-Hant.xlf
@@ -505,13 +505,15 @@
                             mode. This logging style is on by default.
                         ForceConsoleColor--Use ANSI console colors even if
                             console does not support it
-                        Verbosity--overrides the -verbosity setting for this
+                        PreferConsoleColor--Use ANSI console colors only if
+                            target console does support it
+                     Verbosity--overrides the -verbosity setting for this
                             logger.
                      Example:
                         -consoleLoggerParameters:PerformanceSummary;NoSummary;
                                                  Verbosity=minimal
 </source>
-        <target state="translated">  -consoleLoggerParameters:&lt;參數&gt;
+        <target state="needs-review-translation">  -consoleLoggerParameters:&lt;參數&gt;
                      主控台記錄器的參數。(簡短形式: -clp)
                      可用的參數為:
                         PerformanceSummary--顯示工作、目標
diff --git a/src/MSBuild/XMake.cs b/src/MSBuild/XMake.cs
index c5f21d2b46d..af1472b56d1 100644
--- a/src/MSBuild/XMake.cs
+++ b/src/MSBuild/XMake.cs
@@ -35,6 +35,9 @@
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using BinaryLogger = Microsoft.Build.Logging.BinaryLogger;
 using Microsoft.Build.Shared.Debugging;
+using Microsoft.Build.Experimental;
+using Microsoft.Build.Framework.Telemetry;
+using Microsoft.Build.Internal;
 
 #nullable disable
 
@@ -84,7 +87,12 @@ public enum ExitType
             /// <summary>
             /// A project cache failed unexpectedly.
             /// </summary>
-            ProjectCacheFailure
+            ProjectCacheFailure,
+            /// <summary>
+            /// The client for MSBuild server failed unexpectedly, for example,
+            /// because the server process died or hung.
+            /// </summary>
+            MSBuildClientFailure
         }
 
         /// <summary>
@@ -209,6 +217,9 @@ string[] args
 #endif
             )
         {
+            // Initialize new build telemetry and record start of this build.
+            KnownTelemetry.BuildTelemetry = new BuildTelemetry { StartAt = DateTime.UtcNow };
+
             using PerformanceLogEventListener eventListener = PerformanceLogEventListener.Create();
 
             if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
@@ -216,14 +227,44 @@ string[] args
                 DumpCounters(true /* initialize only */);
             }
 
-            // return 0 on success, non-zero on failure
-            int exitCode = ((s_initialized && Execute(
+            int exitCode;
+            if (
+                ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_4) &&
+                Environment.GetEnvironmentVariable(Traits.UseMSBuildServerEnvVarName) == "1" &&
+                !Traits.Instance.EscapeHatches.EnsureStdOutForChildNodesIsPrimaryStdout &&
+                CanRunServerBasedOnCommandLineSwitches(
+#if FEATURE_GET_COMMANDLINE
+                    Environment.CommandLine
+#else
+                    ConstructArrayArg(args)
+#endif
+                ))
+            {
+                Console.CancelKeyPress += Console_CancelKeyPress;
+
+                DebuggerLaunchCheck();
+
+                // Use the client app to execute build in msbuild server. Opt-in feature.
+                exitCode = ((s_initialized && MSBuildClientApp.Execute(
+#if FEATURE_GET_COMMANDLINE
+                Environment.CommandLine,
+#else
+                ConstructArrayArg(args),
+#endif
+                s_buildCancellationSource.Token
+                ) == ExitType.Success) ? 0 : 1);
+            }
+            else
+            {
+                // return 0 on success, non-zero on failure
+                exitCode = ((s_initialized && Execute(
 #if FEATURE_GET_COMMANDLINE
                 Environment.CommandLine
 #else
                 ConstructArrayArg(args)
 #endif
-            ) == ExitType.Success) ? 0 : 1);
+                ) == ExitType.Success) ? 0 : 1);
+            }
 
             if (Environment.GetEnvironmentVariable("MSBUILDDUMPPROCESSCOUNTERS") == "1")
             {
@@ -233,6 +274,57 @@ string[] args
             return exitCode;
         }
 
+
+        /// <summary>
+        /// Returns true if arguments allows or make sense to leverage msbuild server.
+        /// </summary>
+        /// <remarks>
+        /// Will not throw. If arguments processing fails, we will not run it on server - no reason as it will not run any build anyway.
+        /// </remarks>
+        private static bool CanRunServerBasedOnCommandLineSwitches(
+#if FEATURE_GET_COMMANDLINE
+            string commandLine
+#else
+            string[] commandLine
+#endif
+            )
+        {
+            bool canRunServer = true;
+            try
+            {
+                GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile, out string fullCommandLine);
+                CommandLineSwitches commandLineSwitches = CombineSwitchesRespectingPriority(switchesFromAutoResponseFile, switchesNotFromAutoResponseFile, fullCommandLine);
+                if (CheckAndGatherProjectAutoResponseFile(switchesFromAutoResponseFile, commandLineSwitches, false, fullCommandLine, out string projectFile))
+                {
+                    commandLineSwitches = CombineSwitchesRespectingPriority(switchesFromAutoResponseFile, switchesNotFromAutoResponseFile, fullCommandLine);
+                }
+
+                if (commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Help] ||
+                    commandLineSwitches.IsParameterizedSwitchSet(CommandLineSwitches.ParameterizedSwitch.NodeMode) ||
+                    commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.Version] ||
+                    FileUtilities.IsBinaryLogFilename(projectFile) ||
+                    ProcessNodeReuseSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.NodeReuse]) == false)
+                {
+                    canRunServer = false;
+                    if (KnownTelemetry.BuildTelemetry != null)
+                    {
+                        KnownTelemetry.BuildTelemetry.ServerFallbackReason = "Arguments";
+                    }
+                }
+            }
+            catch (Exception ex)
+            {
+                CommunicationsUtilities.Trace("Unexpected exception during command line parsing. Can not determine if it is allowed to use Server. Fall back to old behavior. Exception: {0}", ex);
+                if (KnownTelemetry.BuildTelemetry != null)
+                {
+                    KnownTelemetry.BuildTelemetry.ServerFallbackReason = "ErrorParsingCommandLine";
+                }
+                canRunServer = false;
+            }
+
+            return canRunServer;
+        }
+
 #if !FEATURE_GET_COMMANDLINE
         /// <summary>
         /// Insert the command executable path as the first element of the args array.
@@ -461,6 +553,26 @@ private static string GetFriendlyCounterType(PerformanceCounterType type, string
             }
         }
 #endif
+        /// <summary>
+        /// Launch debugger if it's requested by environment variable "MSBUILDDEBUGONSTART".
+        /// </summary>
+        private static void DebuggerLaunchCheck()
+        {
+            switch (Environment.GetEnvironmentVariable("MSBUILDDEBUGONSTART"))
+            {
+#if FEATURE_DEBUG_LAUNCH
+                case "1":
+                    Debugger.Launch();
+                    break;
+#endif
+                case "2":
+                    // Sometimes easier to attach rather than deal with JIT prompt
+                    Process currentProcess = Process.GetCurrentProcess();
+                    Console.WriteLine($"Waiting for debugger to attach ({currentProcess.MainModule.FileName} PID {currentProcess.Id}).  Press enter to continue...");
+                    Console.ReadLine();
+                    break;
+            }
+        }
 
         /// <summary>
         /// Orchestrates the execution of the application, and is also responsible
@@ -479,26 +591,17 @@ string[] commandLine
 #endif
             )
         {
+            // Initialize new build telemetry and record start of this build, if not initialized already
+            KnownTelemetry.BuildTelemetry ??= new BuildTelemetry { StartAt = DateTime.UtcNow };
+
             // Indicate to the engine that it can toss extraneous file content
             // when it loads microsoft.*.targets. We can't do this in the general case,
             // because tasks in the build can (and occasionally do) load MSBuild format files
             // with our OM and modify and save them. They'll never do this for Microsoft.*.targets, though,
             // and those form the great majority of our unnecessary memory use.
             Environment.SetEnvironmentVariable("MSBuildLoadMicrosoftTargetsReadOnly", "true");
-            switch (Environment.GetEnvironmentVariable("MSBUILDDEBUGONSTART"))
-            {
-#if FEATURE_DEBUG_LAUNCH
-                case "1":
-                    Debugger.Launch();
-                    break;
-#endif
-                case "2":
-                    // Sometimes easier to attach rather than deal with JIT prompt
-                    Process currentProcess = Process.GetCurrentProcess();
-                    Console.WriteLine($"Waiting for debugger to attach ({currentProcess.MainModule.FileName} PID {currentProcess.Id}).  Press enter to continue...");
-                    Console.ReadLine();
-                    break;
-            }
+
+            DebuggerLaunchCheck();
 
 #if FEATURE_GET_COMMANDLINE
             ErrorUtilities.VerifyThrowArgumentLength(commandLine, nameof(commandLine));
@@ -564,9 +667,8 @@ string[] commandLine
                 bool lowPriority = false;
                 string[] inputResultsCaches = null;
                 string outputResultsCache = null;
-                CommandLineSwitches.SwitchesFromResponseFiles ??= new();
 
-                GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile);
+                GatherAllSwitches(commandLine, out var switchesFromAutoResponseFile, out var switchesNotFromAutoResponseFile, out _);
 
                 bool buildCanBeInvoked = ProcessCommandLineSwitches(
                                             switchesFromAutoResponseFile,
@@ -845,8 +947,7 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
         {
             if (e.SpecialKey == ConsoleSpecialKey.ControlBreak)
             {
-                e.Cancel = false; // required; the process will now be terminated rudely
-                return;
+                Environment.Exit(1); // the process will now be terminated rudely
             }
 
             e.Cancel = true; // do not terminate rudely
@@ -904,9 +1005,15 @@ private static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs
         /// member data in preparation for a new build.
         /// </summary>
         private static void ResetBuildState()
+        {
+            ResetGatheringSwitchesState();
+        }
+
+        private static void ResetGatheringSwitchesState()
         {
             s_includedResponseFiles = new List<string>();
             usingSwitchesFromAutoResponseFile = false;
+            CommandLineSwitches.SwitchesFromResponseFiles = new();
         }
 
         /// <summary>
@@ -1061,7 +1168,9 @@ string[] commandLine
                     toolsetDefinitionLocations,
                     cpuCount,
                     onlyLogCriticalEvents,
-                    loadProjectsReadOnly: !preprocessOnly
+                    loadProjectsReadOnly: !preprocessOnly,
+                    useAsynchronousLogging: true,
+                    reuseProjectRootElementCache: s_isServerNode
                 );
 
                 if (toolsVersion != null && !projectCollection.ContainsToolset(toolsVersion))
@@ -1251,7 +1360,8 @@ string[] commandLine
 
                         // InvalidProjectFileExceptions and its aggregates have already been logged.
                         if (exception is not InvalidProjectFileException
-                            && !(exception is AggregateException aggregateException && aggregateException.InnerExceptions.All(innerException => innerException is InvalidProjectFileException)))
+                            && !(exception is AggregateException aggregateException && aggregateException.InnerExceptions.All(innerException => innerException is InvalidProjectFileException))
+                            && exception is not CircularDependencyException)
                         {
                             if (exception is LoggerException or InternalLoggerException or ProjectCacheException)
                             {
@@ -1294,7 +1404,14 @@ string[] commandLine
                 FileUtilities.ClearCacheDirectory();
                 projectCollection?.Dispose();
 
-                BuildManager.DefaultBuildManager.Dispose();
+                // Build manager shall be reused for all build sessions.
+                // If, for one reason or another, this behavior needs to change in future
+                // please be aware that current code creates and keep running  InProcNode even
+                // when its owning default build manager is disposed resulting in leek of memory and threads.
+                if (!s_isServerNode)
+                {
+                    BuildManager.DefaultBuildManager.Dispose();
+                }
             }
 
             return success;
@@ -1501,6 +1618,7 @@ internal static void SetConsoleUI()
         /// <param name="commandLine"></param>
         /// <param name="switchesFromAutoResponseFile"></param>
         /// <param name="switchesNotFromAutoResponseFile"></param>
+        /// <param name="fullCommandLine"></param>
         /// <returns>Combined bag of switches.</returns>
         private static void GatherAllSwitches(
 #if FEATURE_GET_COMMANDLINE
@@ -1508,8 +1626,10 @@ private static void GatherAllSwitches(
 #else
             string[] commandLine,
 #endif
-            out CommandLineSwitches switchesFromAutoResponseFile, out CommandLineSwitches switchesNotFromAutoResponseFile)
+            out CommandLineSwitches switchesFromAutoResponseFile, out CommandLineSwitches switchesNotFromAutoResponseFile, out string fullCommandLine)
         {
+            ResetGatheringSwitchesState();
+
 #if FEATURE_GET_COMMANDLINE
             // split the command line on (unquoted) whitespace
             var commandLineArgs = QuotingUtilities.SplitUnquoted(commandLine);
@@ -1535,9 +1655,9 @@ private static void GatherAllSwitches(
             commandLineArgs.RemoveAt(0);
 
 #if FEATURE_GET_COMMANDLINE
-            string fullCommandLine = $"'{commandLine}'";
+            fullCommandLine = $"'{commandLine}'";
 #else
-            string fullCommandLine = $"'{string.Join(' ', commandLine)}'";
+            fullCommandLine = $"'{string.Join(' ', commandLine)}'";
 #endif
 
             // parse the command line, and flag syntax errors and obvious switch errors
@@ -1959,6 +2079,11 @@ private static bool IsEnvironmentVariable(string envVar)
         /// </summary>
         internal static bool usingSwitchesFromAutoResponseFile = false;
 
+        /// <summary>
+        /// Indicates that this process is working as a server.
+        /// </summary>
+        private static bool s_isServerNode;
+
         /// <summary>
         /// Parses the auto-response file (assumes the "/noautoresponse" switch is not specified on the command line), and combines the
         /// switches from the auto-response file with the switches passed in.
@@ -2044,14 +2169,7 @@ string commandLine
         {
             bool invokeBuild = false;
 
-            // combine the auto-response file switches with the command line switches in a left-to-right manner, where the
-            // auto-response file switches are on the left (default options), and the command line switches are on the
-            // right (overriding options) so that we consume switches in the following sequence of increasing priority:
-            // (1) switches from the msbuild.rsp file/s, including recursively included response files
-            // (2) switches from the command line, including recursively included response file switches inserted at the point they are declared with their "@" symbol
-            CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
-            commandLineSwitches.Append(switchesFromAutoResponseFile, commandLine);    // lowest precedence
-            commandLineSwitches.Append(switchesNotFromAutoResponseFile, commandLine);
+            CommandLineSwitches commandLineSwitches = CombineSwitchesRespectingPriority(switchesFromAutoResponseFile, switchesNotFromAutoResponseFile, commandLine);
 
 #if DEBUG
             if (commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.WaitForDebugger])
@@ -2119,69 +2237,50 @@ string commandLine
                 }
                 else
                 {
-                    // figure out what project we are building
-                    projectFile = ProcessProjectSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Project], commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.IgnoreProjectExtensions], Directory.GetFiles);
+                    bool foundProjectAutoResponseFile = CheckAndGatherProjectAutoResponseFile(switchesFromAutoResponseFile, commandLineSwitches, recursing, commandLine, out projectFile);
 
-                    if (!recursing && !commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoAutoResponse])
+                    if (foundProjectAutoResponseFile)
                     {
-                        // gather any switches from an msbuild.rsp that is next to the project or solution file itself
-                        string projectDirectory = Path.GetDirectoryName(Path.GetFullPath(projectFile));
-
-                        // gather any switches from the first Directory.Build.rsp found in the project directory or above
-                        string directoryResponseFile = FileUtilities.GetPathOfFileAbove(directoryResponseFileName, projectDirectory);
-
-                        bool found = !string.IsNullOrWhiteSpace(directoryResponseFile) && GatherAutoResponseFileSwitchesFromFullPath(directoryResponseFile, switchesFromAutoResponseFile, commandLine);
-
-                        // Don't look for more response files if it's only in the same place we already looked (next to the exe)
-                        if (!string.Equals(projectDirectory, s_exePath, StringComparison.OrdinalIgnoreCase))
-                        {
-                            // this combines any found, with higher precedence, with the switches from the original auto response file switches
-                            found |= GatherAutoResponseFileSwitches(projectDirectory, switchesFromAutoResponseFile, commandLine);
-                        }
-
-                        if (found)
-                        {
-                            // we presumably read in more switches, so start our switch processing all over again,
-                            // so that we consume switches in the following sequence of increasing priority:
-                            // (1) switches from the msbuild.rsp next to msbuild.exe, including recursively included response files
-                            // (2) switches from this msbuild.rsp next to the project or solution <<--------- these we have just now merged with (1)
-                            // (3) switches from the command line, including recursively included response file switches inserted at the point they are declared with their "@" symbol
-                            return ProcessCommandLineSwitches(
-                                                               switchesFromAutoResponseFile,
-                                                               switchesNotFromAutoResponseFile,
-                                                               ref projectFile,
-                                                               ref targets,
-                                                               ref toolsVersion,
-                                                               ref globalProperties,
-                                                               ref loggers,
-                                                               ref verbosity,
-                                                               ref distributedLoggerRecords,
+                        // we presumably read in more switches, so start our switch processing all over again,
+                        // so that we consume switches in the following sequence of increasing priority:
+                        // (1) switches from the msbuild.rsp next to msbuild.exe, including recursively included response files
+                        // (2) switches from this msbuild.rsp next to the project or solution <<--------- these we have just now merged with (1)
+                        // (3) switches from the command line, including recursively included response file switches inserted at the point they are declared with their "@" symbol
+                        return ProcessCommandLineSwitches(
+                                                           switchesFromAutoResponseFile,
+                                                           switchesNotFromAutoResponseFile,
+                                                           ref projectFile,
+                                                           ref targets,
+                                                           ref toolsVersion,
+                                                           ref globalProperties,
+                                                           ref loggers,
+                                                           ref verbosity,
+                                                           ref distributedLoggerRecords,
 #if FEATURE_XML_SCHEMA_VALIDATION
-                                                               ref needToValidateProject,
-                                                               ref schemaFile,
+                                                           ref needToValidateProject,
+                                                           ref schemaFile,
 #endif
-                                                               ref cpuCount,
-                                                               ref enableNodeReuse,
-                                                               ref preprocessWriter,
-                                                               ref targetsWriter,
-                                                               ref detailedSummary,
-                                                               ref warningsAsErrors,
-                                                               ref warningsNotAsErrors,
-                                                               ref warningsAsMessages,
-                                                               ref enableRestore,
-                                                               ref interactive,
-                                                               ref profilerLogger,
-                                                               ref enableProfiler,
-                                                               ref restoreProperties,
-                                                               ref isolateProjects,
-                                                               ref graphBuild,
-                                                               ref inputResultsCaches,
-                                                               ref outputResultsCache,
-                                                               ref lowPriority,
-                                                               recursing: true,
-                                                               commandLine
-                                                             );
-                        }
+                                                           ref cpuCount,
+                                                           ref enableNodeReuse,
+                                                           ref preprocessWriter,
+                                                           ref targetsWriter,
+                                                           ref detailedSummary,
+                                                           ref warningsAsErrors,
+                                                           ref warningsNotAsErrors,
+                                                           ref warningsAsMessages,
+                                                           ref enableRestore,
+                                                           ref interactive,
+                                                           ref profilerLogger,
+                                                           ref enableProfiler,
+                                                           ref restoreProperties,
+                                                           ref isolateProjects,
+                                                           ref graphBuild,
+                                                           ref inputResultsCaches,
+                                                           ref outputResultsCache,
+                                                           ref lowPriority,
+                                                           recursing: true,
+                                                           commandLine
+                                                         );
                     }
 
                     // figure out which targets we are building
@@ -2316,6 +2415,47 @@ out enableProfiler
             return invokeBuild;
         }
 
+        private static CommandLineSwitches CombineSwitchesRespectingPriority(CommandLineSwitches switchesFromAutoResponseFile, CommandLineSwitches switchesNotFromAutoResponseFile, string commandLine)
+        {
+            // combine the auto-response file switches with the command line switches in a left-to-right manner, where the
+            // auto-response file switches are on the left (default options), and the command line switches are on the
+            // right (overriding options) so that we consume switches in the following sequence of increasing priority:
+            // (1) switches from the msbuild.rsp file/s, including recursively included response files
+            // (2) switches from the command line, including recursively included response file switches inserted at the point they are declared with their "@" symbol
+            CommandLineSwitches commandLineSwitches = new CommandLineSwitches();
+            commandLineSwitches.Append(switchesFromAutoResponseFile, commandLine); // lowest precedence
+            commandLineSwitches.Append(switchesNotFromAutoResponseFile, commandLine);
+            return commandLineSwitches;
+        }
+
+        private static bool CheckAndGatherProjectAutoResponseFile(CommandLineSwitches switchesFromAutoResponseFile, CommandLineSwitches commandLineSwitches, bool recursing, string commandLine, out string projectFile)
+        {
+            bool found = false;
+
+            // figure out what project we are building
+            projectFile = ProcessProjectSwitch(commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.Project], commandLineSwitches[CommandLineSwitches.ParameterizedSwitch.IgnoreProjectExtensions], Directory.GetFiles);
+
+            if (!recursing && !commandLineSwitches[CommandLineSwitches.ParameterlessSwitch.NoAutoResponse])
+            {
+                // gather any switches from an msbuild.rsp that is next to the project or solution file itself
+                string projectDirectory = Path.GetDirectoryName(Path.GetFullPath(projectFile));
+
+                // gather any switches from the first Directory.Build.rsp found in the project directory or above
+                string directoryResponseFile = FileUtilities.GetPathOfFileAbove(directoryResponseFileName, projectDirectory);
+
+                found = !string.IsNullOrWhiteSpace(directoryResponseFile) && GatherAutoResponseFileSwitchesFromFullPath(directoryResponseFile, switchesFromAutoResponseFile, commandLine);
+
+                // Don't look for more response files if it's only in the same place we already looked (next to the exe)
+                if (!string.Equals(projectDirectory, s_exePath, StringComparison.OrdinalIgnoreCase))
+                {
+                    // this combines any found, with higher precedence, with the switches from the original auto response file switches
+                    found |= GatherAutoResponseFileSwitches(projectDirectory, switchesFromAutoResponseFile, commandLine);
+                }
+            }
+
+            return found;
+        }
+
         private static bool WarningsAsErrorsSwitchIsEmpty(CommandLineSwitches commandLineSwitches)
         {
             string val = commandLineSwitches.GetParameterizedSwitchCommandLineArg(CommandLineSwitches.ParameterizedSwitch.WarningsAsErrors);
@@ -2629,6 +2769,36 @@ private static void StartLocalNode(CommandLineSwitches commandLineSwitches, bool
                     OutOfProcTaskHostNode node = new OutOfProcTaskHostNode();
                     shutdownReason = node.Run(out nodeException);
                 }
+                else if (nodeModeNumber == 8)
+                {
+                    // Since build function has to reuse code from *this* class and OutOfProcServerNode is in different assembly
+                    // we have to pass down xmake build invocation to avoid circular dependency
+                    OutOfProcServerNode.BuildCallback buildFunction = (commandLine) =>
+                    {
+                        int exitCode;
+                        ExitType exitType;
+
+                        if (!s_initialized)
+                        {
+                            exitType = ExitType.InitializationError;
+                        }
+                        else
+                        {
+                            exitType = Execute(commandLine);
+                        }
+
+                        exitCode = exitType == ExitType.Success ? 0 : 1;
+
+                        return (exitCode, exitType.ToString());
+                    };
+
+                    OutOfProcServerNode node = new(buildFunction);
+
+                    s_isServerNode = true;
+                    shutdownReason = node.Run(out nodeException);
+
+                    FileUtilities.ClearCacheDirectory();
+                }
                 else
                 {
                     CommandLineSwitchException.Throw("InvalidNodeNumberValue", nodeModeNumber.ToString());
@@ -3019,6 +3189,12 @@ internal static string AggregateParameters(string anyPrefixingParameter, string[
             // Join the logger parameters into one string separated by semicolons
             string result = anyPrefixingParameter ?? string.Empty;
 
+            // Ensure traling ';' so parametersToAggregate are properly separated
+            if (!string.IsNullOrEmpty(result) && result[result.Length - 1] != ';')
+            {
+                result += ';';
+            }
+
             result += string.Join(";", parametersToAggregate);
 
             return result;
@@ -3124,6 +3300,12 @@ List<ILogger> loggers
                     consoleParameters = AggregateParameters(consoleParameters, consoleLoggerParameters);
                 }
 
+                // Always use ANSI escape codes when the build is initiated by server
+                if (s_isServerNode)
+                {
+                    consoleParameters = $"PREFERCONSOLECOLOR;{consoleParameters}";
+                }
+
                 // Check to see if there is a possibility we will be logging from an out-of-proc node.
                 // If so (we're multi-proc or the in-proc node is disabled), we register a distributed logger.
                 if (cpuCount == 1 && Environment.GetEnvironmentVariable("MSBUILDNOINPROCNODE") != "1")
@@ -3668,15 +3850,7 @@ private static void ThrowInvalidToolsVersionInitializationException(IEnumerable<
         /// </summary>
         private static void DisplayVersionMessage()
         {
-#if RUNTIME_TYPE_NETCORE
-            const string frameworkName = ".NET";
-#elif MONO
-            const string frameworkName = "Mono";
-#else
-            const string frameworkName = ".NET Framework";
-#endif
-
-            Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("MSBuildVersionMessage", ProjectCollection.DisplayVersion, frameworkName));
+            Console.WriteLine(ResourceUtilities.FormatResourceStringStripCodeAndKeyword("MSBuildVersionMessage", ProjectCollection.DisplayVersion, NativeMethods.FrameworkName));
         }
 
         /// <summary>
diff --git a/src/MSBuild/app.amd64.config b/src/MSBuild/app.amd64.config
index 941490997b3..4cdef2986d2 100644
--- a/src/MSBuild/app.amd64.config
+++ b/src/MSBuild/app.amd64.config
@@ -91,6 +91,16 @@
           <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
           <codeBase version="4.1.4.0" href="..\System.Numerics.Vectors.dll"/>
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Reflection.Metadata.dll" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+          <codeBase version="6.0.0.0" href="..\System.Reflection.MetadataLoadContext.dll" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
diff --git a/src/MSBuild/app.config b/src/MSBuild/app.config
index ad07688b88f..3f412c2716a 100644
--- a/src/MSBuild/app.config
+++ b/src/MSBuild/app.config
@@ -68,6 +68,14 @@
           <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-4.1.4.0" newVersion="4.1.4.0" />
         </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Reflection.Metadata" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+        </dependentAssembly>
+        <dependentAssembly>
+          <assemblyIdentity name="System.Reflection.MetadataLoadContext" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
+          <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
+        </dependentAssembly>
         <dependentAssembly>
           <assemblyIdentity name="System.Resources.Extensions" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
           <bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" />
diff --git a/src/MSBuildTaskHost/MSBuildTaskHost.csproj b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
index ec7f04055ae..beca5404f56 100644
--- a/src/MSBuildTaskHost/MSBuildTaskHost.csproj
+++ b/src/MSBuildTaskHost/MSBuildTaskHost.csproj
@@ -1,4 +1,4 @@
-<Project Sdk="Microsoft.NET.Sdk">
+﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <!-- The .NET Core version of MSBuild doesn't support targeting .NET Framework 3.5.  So in that case, we import
        a .props file that prevents building the project from doing much of anything. -->
@@ -39,10 +39,6 @@
     <Compile Include="..\Shared\BuildEnvironmentHelper.cs">
       <Link>BuildEnvironmentHelper.cs</Link>
     </Compile>
-    <!-- EnvironmentVariableReadEventArgs shouldn't be used in TaskHosts, but it means we need fewer ifdefs. -->
-    <Compile Include="..\Framework\EnvironmentVariableReadEventArgs.cs">
-      <Link>EnvironmentVariableReadEventArgs.cs</Link>
-    </Compile>
     <Compile Include="..\Framework\BuildEnvironmentState.cs">
       <Link>BuildEnvironmentState.cs</Link>
     </Compile>
diff --git a/src/MSBuildTaskHost/TypeLoader.cs b/src/MSBuildTaskHost/TypeLoader.cs
index 5b4833472c4..4c3df1e1d14 100644
--- a/src/MSBuildTaskHost/TypeLoader.cs
+++ b/src/MSBuildTaskHost/TypeLoader.cs
@@ -6,6 +6,7 @@
 using System.Reflection;
 using System.Collections.Generic;
 using System.Threading;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -126,11 +127,13 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
         /// Loads the specified type if it exists in the given assembly. If the type name is fully qualified, then a match (if
         /// any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type
         /// found will be returned.
+        /// The unusued bool is to match the signature of the Shared copy of TypeLoader.
         /// </summary>
         internal LoadedType Load
         (
             string typeName,
-            AssemblyLoadInfo assembly
+            AssemblyLoadInfo assembly,
+            bool _
         )
         {
             return GetLoadedType(s_cacheOfLoadedTypesByFilter, typeName, assembly);
@@ -284,7 +287,7 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)
                     return null;
                 });
 
-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;
+                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly ?? type.Assembly, typeof(ITaskItem)) : null;
             }
 
             /// <summary>
diff --git a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
index 37d86a19b97..dbdb1d17ad5 100644
--- a/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
+++ b/src/Package/MSBuild.VSSetup.Arm64/files.arm64.swr
@@ -47,28 +47,28 @@ folder InstallDir:\MSBuild\Current\Bin\arm64\MSBuild
   file source=$(Arm64BinPath)\MSBuild\Microsoft.Build.CommonTypes.xsd
 
 folder InstallDir:\MSBuild\Current\Bin\arm64\cs
-  file source=$(Arm64BinPath)cs\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)cs\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\de
-  file source=$(Arm64BinPath)de\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)de\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\es
-  file source=$(Arm64BinPath)es\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)es\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\fr
-  file source=$(Arm64BinPath)fr\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)fr\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\it
-  file source=$(Arm64BinPath)it\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)it\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ja
-  file source=$(Arm64BinPath)ja\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)ja\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ko
-  file source=$(Arm64BinPath)ko\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)ko\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\pl
-  file source=$(Arm64BinPath)pl\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)pl\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\pt-BR
-  file source=$(Arm64BinPath)pt-BR\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)pt-BR\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\ru
-  file source=$(Arm64BinPath)ru\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)ru\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\tr
-  file source=$(Arm64BinPath)tr\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)tr\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hans
-  file source=$(Arm64BinPath)zh-Hans\MSBuild.resources.dll vs.file.ngenArchitecture=all
+  file source=$(Arm64BinPath)zh-Hans\MSBuild.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\arm64\zh-Hant
-  file source=$(Arm64BinPath)zh-Hant\MSBuild.resources.dll vs.file.ngenArchitecture=all
\ No newline at end of file
+  file source=$(Arm64BinPath)zh-Hant\MSBuild.resources.dll
diff --git a/src/Package/MSBuild.VSSetup/files.swr b/src/Package/MSBuild.VSSetup/files.swr
index 793a3d5be1c..8f326c34c2f 100644
--- a/src/Package/MSBuild.VSSetup/files.swr
+++ b/src/Package/MSBuild.VSSetup/files.swr
@@ -40,6 +40,8 @@ folder InstallDir:\MSBuild\Current\Bin
   file source=$(TaskHostBinPath)MSBuildTaskHost.exe.config
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
   file source=$(X86BinPath)System.Text.Encodings.Web.dll vs.file.ngenApplications="[installDir]\MSBuild\Current\Bin\MSBuild.exe" vs.file.ngenArchitecture=all vs.file.ngenPriority=1
@@ -92,83 +94,83 @@ folder InstallDir:\MSBuild\Current\Bin\SdkResolvers\Microsoft.Build.NuGetSdkReso
   file source=$(SourceDir)MSBuild\SdkResolvers\VS\Microsoft.Build.NuGetSdkResolver.xml
 
 folder InstallDir:\MSBuild\Current\Bin\cs
-  file source=$(X86BinPath)cs\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)cs\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)cs\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)cs\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)cs\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)cs\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)cs\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)cs\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)cs\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)cs\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\de
-  file source=$(X86BinPath)de\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)de\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)de\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)de\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)de\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)de\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)de\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)de\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)de\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)de\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\es
-  file source=$(X86BinPath)es\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)es\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)es\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)es\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)es\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)es\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)es\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)es\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)es\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)es\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\fr
-  file source=$(X86BinPath)fr\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)fr\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)fr\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)fr\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)fr\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)fr\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)fr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)fr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)fr\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)fr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\it
-  file source=$(X86BinPath)it\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)it\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)it\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)it\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)it\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)it\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)it\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)it\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)it\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)it\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\ja
-  file source=$(X86BinPath)ja\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ja\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ja\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ja\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)ja\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)ja\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)ja\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)ja\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)ja\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)ja\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\ko
-  file source=$(X86BinPath)ko\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ko\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ko\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ko\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)ko\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)ko\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)ko\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)ko\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)ko\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)ko\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\pl
-  file source=$(X86BinPath)pl\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pl\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pl\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pl\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)pl\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)pl\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)pl\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)pl\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)pl\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)pl\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\pt-BR
-  file source=$(X86BinPath)pt-BR\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pt-BR\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pt-BR\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)pt-BR\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)pt-BR\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)pt-BR\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)pt-BR\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)pt-BR\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)pt-BR\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)pt-BR\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\ru
-  file source=$(X86BinPath)ru\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ru\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ru\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)ru\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)ru\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)ru\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)ru\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)ru\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)ru\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)ru\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\tr
-  file source=$(X86BinPath)tr\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)tr\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)tr\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)tr\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)tr\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)tr\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)tr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)tr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)tr\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)tr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\zh-Hans
-  file source=$(X86BinPath)zh-Hans\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hans\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hans\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hans\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)zh-Hans\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)zh-Hans\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)zh-Hans\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)zh-Hans\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)zh-Hans\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)zh-Hans\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\zh-Hant
-  file source=$(X86BinPath)zh-Hant\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hant\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hant\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X86BinPath)zh-Hant\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostBinPath)zh-Hant\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)zh-Hant\Microsoft.Build.resources.dll
+  file source=$(X86BinPath)zh-Hant\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X86BinPath)zh-Hant\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X86BinPath)zh-Hant\MSBuild.resources.dll
+  file source=$(TaskHostBinPath)zh-Hant\MSBuildTaskHost.resources.dll
 
 folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X64BinPath)MSBuild.exe vs.file.ngenArchitecture=x64
@@ -185,6 +187,8 @@ folder InstallDir:\MSBuild\Current\Bin\amd64
   file source=$(X86BinPath)Microsoft.Build.Utilities.Core.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Buffers.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Memory.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Reflection.Metadata.dll vs.file.ngenArchitecture=all
+  file source=$(X86BinPath)System.Reflection.MetadataLoadContext.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)System.Text.Json.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.Bcl.AsyncInterfaces.dll vs.file.ngenArchitecture=all
   file source=$(X86BinPath)Microsoft.IO.Redist.dll vs.file.ngenArchitecture=all
@@ -231,83 +235,83 @@ folder InstallDir:\MSBuild\Current\Bin\amd64\MSBuild
   file source=$(X86BinPath)\MSBuild\Microsoft.Build.CommonTypes.xsd
 
 folder InstallDir:\MSBuild\Current\Bin\amd64\cs
-  file source=$(X64BinPath)cs\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)cs\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)cs\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)cs\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)cs\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)cs\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)cs\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)cs\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)cs\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)cs\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\de
-  file source=$(X64BinPath)de\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)de\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)de\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)de\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)de\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)de\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)de\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)de\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)de\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)de\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\es
-  file source=$(X64BinPath)es\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)es\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)es\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)es\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)es\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)es\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)es\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)es\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)es\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)es\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\fr
-  file source=$(X64BinPath)fr\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)fr\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)fr\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)fr\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)fr\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)fr\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)fr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)fr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)fr\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)fr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\it
-  file source=$(X64BinPath)it\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)it\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)it\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)it\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)it\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)it\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)it\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)it\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)it\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)it\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\ja
-  file source=$(X64BinPath)ja\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ja\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ja\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ja\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)ja\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)ja\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)ja\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)ja\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)ja\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)ja\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\ko
-  file source=$(X64BinPath)ko\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ko\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ko\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ko\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)ko\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)ko\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)ko\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)ko\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)ko\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)ko\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\pl
-  file source=$(X64BinPath)pl\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pl\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pl\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pl\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)pl\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)pl\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)pl\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)pl\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)pl\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)pl\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\pt-BR
-  file source=$(X64BinPath)pt-BR\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pt-BR\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pt-BR\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)pt-BR\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)pt-BR\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)pt-BR\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)pt-BR\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)pt-BR\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)pt-BR\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)pt-BR\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\ru
-  file source=$(X64BinPath)ru\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ru\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ru\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)ru\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)ru\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)ru\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)ru\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)ru\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)ru\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)ru\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\tr
-  file source=$(X64BinPath)tr\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)tr\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)tr\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)tr\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)tr\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)tr\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)tr\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)tr\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)tr\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)tr\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hans
-  file source=$(X64BinPath)zh-Hans\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hans\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hans\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hans\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)zh-Hans\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)zh-Hans\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)zh-Hans\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)zh-Hans\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)zh-Hans\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)zh-Hans\MSBuildTaskHost.resources.dll
 folder InstallDir:\MSBuild\Current\Bin\amd64\zh-Hant
-  file source=$(X64BinPath)zh-Hant\Microsoft.Build.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hant\Microsoft.Build.Tasks.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hant\Microsoft.Build.Utilities.Core.resources.dll vs.file.ngenArchitecture=all
-  file source=$(X64BinPath)zh-Hant\MSBuild.resources.dll vs.file.ngenArchitecture=all
-  file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll vs.file.ngenArchitecture=all
+  file source=$(X64BinPath)zh-Hant\Microsoft.Build.resources.dll
+  file source=$(X64BinPath)zh-Hant\Microsoft.Build.Tasks.Core.resources.dll
+  file source=$(X64BinPath)zh-Hant\Microsoft.Build.Utilities.Core.resources.dll
+  file source=$(X64BinPath)zh-Hant\MSBuild.resources.dll
+  file source=$(TaskHostX64BinPath)zh-Hant\MSBuildTaskHost.resources.dll
 
 folder InstallDir:\Common7\IDE\CommonExtensions\MSBuild
   file source=$(SourceDir)Package\MSBuild.VSSetup\MSBuild.clientenabledpkg
diff --git a/src/Shared/BinaryReaderExtensions.cs b/src/Shared/BinaryReaderExtensions.cs
index ec48e932739..dbaad654b30 100644
--- a/src/Shared/BinaryReaderExtensions.cs
+++ b/src/Shared/BinaryReaderExtensions.cs
@@ -6,14 +6,12 @@
 using System.Runtime.CompilerServices;
 using Microsoft.Build.Framework;
 
-#nullable disable
-
 namespace Microsoft.Build.Shared
 {
     internal static class BinaryReaderExtensions
     {
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
-        public static string ReadOptionalString(this BinaryReader reader)
+        public static string? ReadOptionalString(this BinaryReader reader)
         {
             return reader.ReadByte() == 0 ? null : reader.ReadString();
         }
@@ -53,7 +51,7 @@ public static DateTime ReadTimestamp(this BinaryReader reader)
         }
 
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
-        public static BuildEventContext ReadOptionalBuildEventContext(this BinaryReader reader)
+        public static BuildEventContext? ReadOptionalBuildEventContext(this BinaryReader reader)
         {
             if (reader.ReadByte() == 0)
             {
diff --git a/src/Shared/BinaryTranslator.cs b/src/Shared/BinaryTranslator.cs
index 73888fa88a0..86438f1da31 100644
--- a/src/Shared/BinaryTranslator.cs
+++ b/src/Shared/BinaryTranslator.cs
@@ -455,6 +455,7 @@ private static bool TryLoadCulture(string cultureName, out CultureInfo cultureIn
             /// Finally, converting the enum to an int assumes that we always want to transport enums as ints.  This
             /// works in all of our current cases, but certainly isn't perfectly generic.</remarks>
             public void TranslateEnum<T>(ref T value, int numericValue)
+                where T : struct, Enum
             {
                 numericValue = _reader.ReadInt32();
                 Type enumType = value.GetType();
@@ -1079,10 +1080,8 @@ public void TranslateCulture(ref CultureInfo value)
             /// Finally, converting the enum to an int assumes that we always want to transport enums as ints.  This
             /// works in all of our current cases, but certainly isn't perfectly generic.</remarks>
             public void TranslateEnum<T>(ref T value, int numericValue)
+                where T : struct, Enum
             {
-                Type enumType = value.GetType();
-                ErrorUtilities.VerifyThrow(enumType.GetTypeInfo().IsEnum, "Must pass an enum type.");
-
                 _writer.Write(numericValue);
             }
 
diff --git a/src/Shared/BinaryWriterExtensions.cs b/src/Shared/BinaryWriterExtensions.cs
index 70d750aa883..ffc019dacba 100644
--- a/src/Shared/BinaryWriterExtensions.cs
+++ b/src/Shared/BinaryWriterExtensions.cs
@@ -6,14 +6,12 @@
 using System.Runtime.CompilerServices;
 using Microsoft.Build.Framework;
 
-#nullable disable
-
 namespace Microsoft.Build.Shared
 {
     internal static class BinaryWriterExtensions
     {
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
-        public static void WriteOptionalString(this BinaryWriter writer, string value)
+        public static void WriteOptionalString(this BinaryWriter writer, string? value)
         {
             if (value == null)
             {
@@ -49,7 +47,7 @@ public static void Write7BitEncodedInt(this BinaryWriter writer, int value)
         }
 
         [MethodImpl(MethodImplOptions.AggressiveInlining)]
-        public static void WriteOptionalBuildEventContext(this BinaryWriter writer, BuildEventContext context)
+        public static void WriteOptionalBuildEventContext(this BinaryWriter writer, BuildEventContext? context)
         {
             if (context == null)
             {
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index 73dcf6f5a93..f8106579fb7 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -14,6 +14,8 @@
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
 using System.Reflection;
+using System.Security.Cryptography;
+using System.Text;
 
 #if !CLR2COMPATIBILITY
 using Microsoft.Build.Shared.Debugging;
@@ -75,17 +77,17 @@ internal enum HandshakeOptions
         Arm64 = 128,
     }
 
-    internal readonly struct Handshake
+    internal class Handshake
     {
-        readonly int options;
-        readonly int salt;
-        readonly int fileVersionMajor;
-        readonly int fileVersionMinor;
-        readonly int fileVersionBuild;
-        readonly int fileVersionPrivate;
-        readonly int sessionId;
-
-        internal Handshake(HandshakeOptions nodeType)
+        protected readonly int options;
+        protected readonly int salt;
+        protected readonly int fileVersionMajor;
+        protected readonly int fileVersionMinor;
+        protected readonly int fileVersionBuild;
+        protected readonly int fileVersionPrivate;
+        private readonly int sessionId;
+
+        internal protected Handshake(HandshakeOptions nodeType)
         {
             const int handshakeVersion = (int)CommunicationsUtilities.handshakeVersion;
 
@@ -113,7 +115,7 @@ public override string ToString()
             return String.Format("{0} {1} {2} {3} {4} {5} {6}", options, salt, fileVersionMajor, fileVersionMinor, fileVersionBuild, fileVersionPrivate, sessionId);
         }
 
-        internal int[] RetrieveHandshakeComponents()
+        public virtual int[] RetrieveHandshakeComponents()
         {
             return new int[]
             {
@@ -126,6 +128,61 @@ internal int[] RetrieveHandshakeComponents()
                 CommunicationsUtilities.AvoidEndOfHandshakeSignal(sessionId)
             };
         }
+
+        public virtual string GetKey() => $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate} {sessionId}".ToString(CultureInfo.InvariantCulture);
+
+        public virtual byte? ExpectedVersionInFirstByte => CommunicationsUtilities.handshakeVersion;
+    }
+
+    internal sealed class ServerNodeHandshake : Handshake
+    {
+        /// <summary>
+        /// Caching computed hash.
+        /// </summary>
+        private string _computedHash = null;
+
+        public override byte? ExpectedVersionInFirstByte => null;
+
+        internal ServerNodeHandshake(HandshakeOptions nodeType)
+            : base(nodeType)
+        {
+        }
+
+        public override int[] RetrieveHandshakeComponents()
+        {
+            return new int[]
+            {
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(options),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(salt),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMajor),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionMinor),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionBuild),
+                CommunicationsUtilities.AvoidEndOfHandshakeSignal(fileVersionPrivate),
+            };
+        }
+
+        public override string GetKey()
+        {
+            return $"{options} {salt} {fileVersionMajor} {fileVersionMinor} {fileVersionBuild} {fileVersionPrivate}"
+                .ToString(CultureInfo.InvariantCulture);
+        }
+
+        /// <summary>
+        /// Computes Handshake stable hash string representing whole state of handshake.
+        /// </summary>
+        public string ComputeHash()
+        {
+            if (_computedHash == null)
+            {
+                var input = GetKey();
+                using var sha = SHA256.Create();
+                var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(input));
+                _computedHash = Convert.ToBase64String(bytes)
+                    .Replace("/", "_")
+                    .Replace("=", string.Empty);
+            }
+            return _computedHash;
+        }
     }
 
     /// <summary>
diff --git a/src/Shared/EnvironmentUtilities.cs b/src/Shared/EnvironmentUtilities.cs
index 01cf349f2f8..e9e0482619f 100644
--- a/src/Shared/EnvironmentUtilities.cs
+++ b/src/Shared/EnvironmentUtilities.cs
@@ -4,6 +4,8 @@
 using System;
 using System.Runtime.InteropServices;
 
+#nullable disable
+
 namespace Microsoft.Build.Shared
 {
     internal static partial class EnvironmentUtilities
diff --git a/src/Shared/EventArgsFormatting.cs b/src/Shared/EventArgsFormatting.cs
index 7c0db803f70..e3bcdf9fcba 100644
--- a/src/Shared/EventArgsFormatting.cs
+++ b/src/Shared/EventArgsFormatting.cs
@@ -53,11 +53,10 @@ internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProj
         /// <param name="e">Message to format</param>
         /// <param name="showProjectFile"><code>true</code> to show the project file which issued the event, otherwise <code>false</code>.</param>
         /// <param name="projectConfigurationDescription">Properties to Print along with message</param>
-        /// <param name="nonNullMessage">The complete message (including property name) for an environment-derived property</param>
         /// <returns>The formatted message string.</returns>
-        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription, string nonNullMessage = null)
+        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription)
         {
-            return FormatEventMessage("message", e.Subcategory, nonNullMessage ?? e.Message,
+            return FormatEventMessage("message", e.Subcategory, e.Message,
                             e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber,
                             e.ColumnNumber, e.EndColumnNumber, e.ThreadId, projectConfigurationDescription);
         }
@@ -145,14 +144,13 @@ internal static string FormatEventMessage(BuildMessageEventArgs e)
         /// </summary>
         /// <param name="e">Message to format</param>
         /// <param name="showProjectFile">Show project file or not</param>
-        /// <param name="nonNullMessage">For an EnvironmentVariableReadEventArgs, adds an explanatory note and the name of the variable.</param>
         /// <returns>The formatted message string.</returns>
-        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string nonNullMessage = null)
+        internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile)
         {
             ErrorUtilities.VerifyThrowArgumentNull(e, nameof(e));
 
             // "message" should not be localized
-            return FormatEventMessage("message", e.Subcategory, nonNullMessage ?? e.Message,
+            return FormatEventMessage("message", e.Subcategory, e.Message,
                 e.Code, e.File, showProjectFile ? e.ProjectFile : null, e.LineNumber, e.EndLineNumber, e.ColumnNumber, e.EndColumnNumber, e.ThreadId, null);
         }
 
diff --git a/src/Shared/FileMatcher.cs b/src/Shared/FileMatcher.cs
index 1fb4dd23850..89f0375ee55 100644
--- a/src/Shared/FileMatcher.cs
+++ b/src/Shared/FileMatcher.cs
@@ -2,13 +2,14 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Buffers;
 using System.Collections.Concurrent;
-using System.IO;
-using System.Text;
+using System.Collections.Generic;
 using System.Diagnostics;
+using System.IO;
 using System.Linq;
+using System.Text;
 using System.Text.RegularExpressions;
-using System.Collections.Generic;
 using System.Threading.Tasks;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared.FileSystem;
@@ -836,6 +837,29 @@ private void GetFilesRecursive(
             Dictionary<string, List<RecursionState>> searchesToExcludeInSubdirs,
             TaskOptions taskOptions)
         {
+#if FEATURE_SYMLINK_TARGET
+            // This is a pretty quick, simple check, but it misses some cases:
+            // symlink in folder A pointing to folder B and symlink in folder B pointing to folder A
+            // If folder C contains file Foo.cs and folder D, and folder D contains a symlink pointing to folder C, calling GetFilesRecursive and
+            // passing in folder D would currently find Foo.cs, whereas this would make us miss it.
+            // and most obviously, frameworks other than net6.0
+            // The solution I'd propose for the first two, if necessary, would be maintaining a set of symlinks and verifying, before following it,
+            // that we had not followed it previously. The third would require a more involved P/invoke-style fix.
+            // These issues should ideally be resolved as part of #703
+            try
+            {
+                FileSystemInfo linkTarget = Directory.ResolveLinkTarget(recursionState.BaseDirectory, returnFinalTarget: true);
+                if (linkTarget is not null && recursionState.BaseDirectory.Contains(linkTarget.FullName))
+                {
+                    return;
+                }
+            }
+            // This fails in tests with the MockFileSystem when they don't have real paths.
+            catch (IOException) { }
+            catch (ArgumentException) { }
+            catch (UnauthorizedAccessException) { }
+#endif
+
             ErrorUtilities.VerifyThrow((recursionState.SearchData.Filespec == null) || (recursionState.SearchData.RegexFileMatch == null),
                 "File-spec overrides the regular expression -- pass null for file-spec if you want to use the regular expression.");
 
@@ -954,15 +978,10 @@ private void GetFilesRecursive(
 
                 if (searchesToExcludeInSubdirs != null)
                 {
-                    List<RecursionState> searchesForSubdir;
-
-                    if (searchesToExcludeInSubdirs.TryGetValue(subdir, out searchesForSubdir))
+                    if (searchesToExcludeInSubdirs.TryGetValue(subdir, out List<RecursionState> searchesForSubdir))
                     {
                         // We've found the base directory that these exclusions apply to.  So now add them as normal searches
-                        if (newSearchesToExclude == null)
-                        {
-                            newSearchesToExclude = new List<RecursionState>();
-                        }
+                        newSearchesToExclude ??= new();
                         newSearchesToExclude.AddRange(searchesForSubdir);
                     }
                 }
@@ -1001,10 +1020,10 @@ private void GetFilesRecursive(
                     }
                 }
             }
-            // Use a foreach to reduce the overhead of Parallel.ForEach when we are not running in parallel
+            // Use a foreach to avoid the overhead of Parallel.ForEach when we are not running in parallel
             if (dop < 2)
             {
-                foreach (var subdir in _getFileSystemEntries(FileSystemEntity.Directories, recursionState.BaseDirectory, nextStep.DirectoryPattern, null, false))
+                foreach (string subdir in _getFileSystemEntries(FileSystemEntity.Directories, recursionState.BaseDirectory, nextStep.DirectoryPattern, null, false))
                 {
                     processSubdirectory(subdir);
                 }
@@ -1655,7 +1674,7 @@ internal static bool IsFileNameMatch(string path, string pattern)
             // Use a span-based Path.GetFileName if it is available.
 #if FEATURE_MSIOREDIST
             return IsMatch(Microsoft.IO.Path.GetFileName(path.AsSpan()), pattern);
-#elif NETSTANDARD2_0
+#elif NETSTANDARD2_0 || NETFRAMEWORK
             return IsMatch(Path.GetFileName(path), pattern);
 #else
             return IsMatch(Path.GetFileName(path.AsSpan()), pattern);
diff --git a/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs b/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
index 3dd41850342..8ba84cebe03 100644
--- a/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
+++ b/src/Shared/FileSystem/MSBuildOnWindowsFileSystem.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections.Generic;
 using System.IO;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -13,6 +14,7 @@ namespace Microsoft.Build.Shared.FileSystem
     /// Implementation of file system operations on windows. Combination of native and managed implementations.
     /// TODO Remove this class and replace with WindowsFileSystem. Test perf to ensure no regressions.
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal class MSBuildOnWindowsFileSystem : IFileSystem
     {
         private static readonly MSBuildOnWindowsFileSystem Instance = new MSBuildOnWindowsFileSystem();
diff --git a/src/Shared/FileSystem/WindowsFileSystem.cs b/src/Shared/FileSystem/WindowsFileSystem.cs
index 03c739e6710..60867009993 100644
--- a/src/Shared/FileSystem/WindowsFileSystem.cs
+++ b/src/Shared/FileSystem/WindowsFileSystem.cs
@@ -6,6 +6,7 @@
 using System.Diagnostics;
 using System.IO;
 using System.Runtime.InteropServices;
+using System.Runtime.Versioning;
 
 #nullable disable
 
@@ -28,9 +29,10 @@ internal enum FileArtifactType : byte
     /// Windows-specific implementation of file system operations using Windows native invocations.
     /// TODO For potential extra perf gains, provide native implementations for all IFileSystem methods and stop inheriting from ManagedFileSystem
     /// </summary>
+    [SupportedOSPlatform("windows")]
     internal class WindowsFileSystem : ManagedFileSystem
     {
-        private static readonly WindowsFileSystem Instance = new WindowsFileSystem();
+        private static readonly WindowsFileSystem Instance = new();
 
         public new static WindowsFileSystem Singleton() => WindowsFileSystem.Instance;
 
diff --git a/src/Shared/FileUtilities.cs b/src/Shared/FileUtilities.cs
index 9628a41db61..da24b87b134 100644
--- a/src/Shared/FileUtilities.cs
+++ b/src/Shared/FileUtilities.cs
@@ -174,6 +174,8 @@ internal static bool CanWriteToDirectory(string directory)
             try
             {
                 string testFilePath = Path.Combine(directory, $"MSBuild_{Guid.NewGuid().ToString("N")}_testFile.txt");
+                FileInfo file = new(testFilePath);
+                file.Directory.Create(); // If the directory already exists, this method does nothing.
                 File.WriteAllText(testFilePath, $"MSBuild process {Process.GetCurrentProcess().Id} successfully wrote to file.");
                 File.Delete(testFilePath);
                 return true;
diff --git a/src/Shared/INodeEndpoint.cs b/src/Shared/INodeEndpoint.cs
index cb8ce4a4c0a..ef2f319f023 100644
--- a/src/Shared/INodeEndpoint.cs
+++ b/src/Shared/INodeEndpoint.cs
@@ -103,5 +103,11 @@ LinkStatus LinkStatus
         /// <param name="packet">The packet to be sent.</param>
         void SendData(INodePacket packet);
         #endregion
+
+        /// <summary>
+        /// Called when we are about to send last packet to finalize graceful disconnection with client.
+        /// This is needed to handle race condition when both client and server is gracefully about to close connection.
+        /// </summary>
+        void ClientWillDisconnect();
     }
 }
diff --git a/src/Shared/INodePacket.cs b/src/Shared/INodePacket.cs
index 481a99bfce9..0ddbf49a0d7 100644
--- a/src/Shared/INodePacket.cs
+++ b/src/Shared/INodePacket.cs
@@ -189,6 +189,30 @@ internal enum NodePacketType : byte
         /// Message sent back to a node informing it about the resource that were granted by the scheduler.
         /// </summary>
         ResourceResponse,
+
+        /// <summary>
+        /// Command in form of MSBuild command line for server node - MSBuild Server.
+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI
+        /// </summary>
+        ServerNodeBuildCommand = 0xF0,
+
+        /// <summary>
+        /// Response from server node command
+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI
+        /// </summary>
+        ServerNodeBuildResult = 0xF1,
+
+        /// <summary>
+        /// Info about server console activity. 
+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI
+        /// </summary>
+        ServerNodeConsoleWrite = 0xF2,
+
+        /// <summary>
+        /// Command to cancel ongoing build. 
+        /// Keep this enum value constant intact as this is part of contract with dotnet CLI
+        /// </summary>
+        ServerNodeBuildCancel = 0xF3,
     }
     #endregion
 
diff --git a/src/Shared/ITranslator.cs b/src/Shared/ITranslator.cs
index 42274c2da1d..3a507470744 100644
--- a/src/Shared/ITranslator.cs
+++ b/src/Shared/ITranslator.cs
@@ -241,7 +241,8 @@ BinaryWriter Writer
         /// can you simply pass as ref Enum, because an enum instance doesn't match that function signature.
         /// Finally, converting the enum to an int assumes that we always want to transport enums as ints.  This
         /// works in all of our current cases, but certainly isn't perfectly generic.</remarks>
-        void TranslateEnum<T>(ref T value, int numericValue);
+        void TranslateEnum<T>(ref T value, int numericValue)
+            where T : struct, Enum;
 
         /// <summary>
         /// Translates a value using the .Net binary formatter.
diff --git a/src/Shared/InprocTrackingNativeMethods.cs b/src/Shared/InprocTrackingNativeMethods.cs
index 80da8f6abff..cbdd7b59d96 100644
--- a/src/Shared/InprocTrackingNativeMethods.cs
+++ b/src/Shared/InprocTrackingNativeMethods.cs
@@ -152,7 +152,7 @@ internal static void SetThreadCount(int threadCount)
 
         private static class FileTrackerDllStub
         {
-            private readonly static Lazy<string> fileTrackerDllName = new Lazy<string>(() => (IntPtr.Size == sizeof(Int32)) ? "FileTracker32.dll" : "FileTracker64.dll");
+            private readonly static Lazy<string> fileTrackerDllName = new Lazy<string>(() => RuntimeInformation.ProcessArchitecture == Architecture.Arm64 ? "FileTrackerA4.dll" : (IntPtr.Size == sizeof(Int32)) ? "FileTracker32.dll" : "FileTracker64.dll");
 
             // Handle for FileTracker.dll itself
             [SecurityCritical]
diff --git a/src/Shared/LoadedType.cs b/src/Shared/LoadedType.cs
index eeae7eb79ab..c7181787b69 100644
--- a/src/Shared/LoadedType.cs
+++ b/src/Shared/LoadedType.cs
@@ -2,7 +2,11 @@
 // Licensed under the MIT license. See LICENSE file in the project root for full license information.
 
 using System;
+using System.Collections.Generic;
+using System.Linq;
 using System.Reflection;
+using Microsoft.Build.BackEnd;
+using Microsoft.Build.Execution;
 using Microsoft.Build.Framework;
 
 #nullable disable
@@ -15,15 +19,7 @@ namespace Microsoft.Build.Shared
     /// </summary>
     internal sealed class LoadedType
     {
-        #region Constructors
-
-        /// <summary>
-        /// Creates an instance of this class for the given type.
-        /// </summary>
-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo)
-            : this(type, assemblyLoadInfo, null)
-        {
-        }
+        #region Constructor
 
         /// <summary>
         /// Creates an instance of this class for the given type.
@@ -31,75 +27,127 @@ internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo)
         /// <param name="type">The Type to be loaded</param>
         /// <param name="assemblyLoadInfo">Information used to load the assembly</param>
         /// <param name="loadedAssembly">The assembly which has been loaded, if any</param>
-        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly)
+        /// <param name="loadedViaMetadataLoadContext">Whether this type was loaded via MetadataLoadContext</param>
+        /// <param name="iTaskItemType">type of an ITaskItem</param>
+        internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly, Type iTaskItemType, bool loadedViaMetadataLoadContext = false)
         {
             ErrorUtilities.VerifyThrow(type != null, "We must have the type.");
             ErrorUtilities.VerifyThrow(assemblyLoadInfo != null, "We must have the assembly the type was loaded from.");
+            ErrorUtilities.VerifyThrow(loadedAssembly is not null, "The assembly should always be loaded even if only by MetadataLoadContext.");
+
+            Type = type;
+            Assembly = assemblyLoadInfo;
+
+            HasSTAThreadAttribute = CheckForHardcodedSTARequirement();
+            LoadedAssemblyName = loadedAssembly.GetName();
+            Path = loadedAssembly.Location;
+            LoadedAssembly = loadedAssembly;
+
+#if !NET35
+            // Properties set in this block aren't used by TaskHosts. Properties below are only used on the NodeProvider side to get information about the
+            // properties and reflect over them without needing them to be fully loaded, so it also isn't need for TaskHosts.
+            // MetadataLoadContext-loaded Type objects don't support testing for inherited attributes, so we manually walk the BaseType chain.
+            Type t = type;
+            while (t is not null)
+            {
+                if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(LoadInSeparateAppDomainAttribute))))
+                {
+                    HasLoadInSeparateAppDomainAttribute = true;
+                }
 
-            _type = type;
-            _assembly = assemblyLoadInfo;
-            _loadedAssembly = loadedAssembly;
+                if (CustomAttributeData.GetCustomAttributes(t).Any(attr => attr.AttributeType.Name.Equals(nameof(RunInSTAAttribute))))
+                {
+                    HasSTAThreadAttribute = true;
+                }
+
+                if (t.IsMarshalByRef)
+                {
+                    IsMarshalByRef = true;
+                }
+
+                t = t.BaseType;
+            }
+
+            PropertyInfo[] props = type.GetProperties(BindingFlags.Instance | BindingFlags.Public);
+            Properties = new ReflectableTaskPropertyInfo[props.Length];
+            if (loadedViaMetadataLoadContext)
+            {
+                PropertyAssemblyQualifiedNames = new string[props.Length];
+            }
 
-            CheckForHardcodedSTARequirement();
-            HasLoadInSeparateAppDomainAttribute();
-            HasSTAThreadAttribute();
+            for (int i = 0; i < props.Length; i++)
+            {
+                bool outputAttribute = false;
+                bool requiredAttribute = false;
+                foreach (CustomAttributeData attr in CustomAttributeData.GetCustomAttributes(props[i]))
+                {
+                    if (attr.AttributeType.Name.Equals(nameof(OutputAttribute)))
+                    {
+                        outputAttribute = true;
+                    }
+                    else if (attr.AttributeType.Name.Equals(nameof(RequiredAttribute)))
+                    {
+                        requiredAttribute = true;
+                    }
+                }
+
+                // Check whether it's assignable to ITaskItem or ITaskItem[]. Simplify to just checking for ITaskItem.
+                Type pt = props[i].PropertyType;
+                if (pt.IsArray)
+                {
+                    pt = pt.GetElementType();
+                }
+
+                bool isAssignableToITask = iTaskItemType.IsAssignableFrom(pt);
+
+                Properties[i] = new ReflectableTaskPropertyInfo(props[i], outputAttribute, requiredAttribute, isAssignableToITask);
+                if (loadedViaMetadataLoadContext)
+                {
+                    PropertyAssemblyQualifiedNames[i] = Properties[i].PropertyType.AssemblyQualifiedName;
+                }
+            }
+#endif
         }
 
 
         #endregion
 
-        #region Methods
         /// <summary>
         /// Gets whether there's a LoadInSeparateAppDomain attribute on this type.
-        /// Caches the result - since it can't change during the build.
         /// </summary>
-        /// <returns></returns>
-        public bool HasLoadInSeparateAppDomainAttribute()
-        {
-            if (_hasLoadInSeparateAppDomainAttribute == null)
-            {
-                _hasLoadInSeparateAppDomainAttribute = this.Type.GetTypeInfo().IsDefined(typeof(LoadInSeparateAppDomainAttribute), true /* inherited */);
-            }
-
-            return (bool)_hasLoadInSeparateAppDomainAttribute;
-        }
+        public bool HasLoadInSeparateAppDomainAttribute { get; }
 
         /// <summary>
         /// Gets whether there's a STAThread attribute on the Execute method of this type.
-        /// Caches the result - since it can't change during the build.
         /// </summary>
-        /// <returns></returns>
-        public bool HasSTAThreadAttribute()
-        {
-            if (_hasSTAThreadAttribute == null)
-            {
-                _hasSTAThreadAttribute = this.Type.GetTypeInfo().IsDefined(typeof(RunInSTAAttribute), true /* inherited */);
-            }
+        public bool HasSTAThreadAttribute { get; }
 
-            return (bool)_hasSTAThreadAttribute;
-        }
-
-        #endregion
+        /// <summary>
+        /// Gets whether this type implements MarshalByRefObject.
+        /// </summary>
+        public bool IsMarshalByRef { get; }
 
         /// <summary>
         /// Determines if the task has a hardcoded requirement for STA thread usage.
         /// </summary>
-        private void CheckForHardcodedSTARequirement()
+        private bool CheckForHardcodedSTARequirement()
         {
             // Special hard-coded attributes for certain legacy tasks which need to run as STA because they were written before
             // we changed to running all tasks in MTA.
-            if (String.Equals("Microsoft.Build.Tasks.Xaml.PartialClassGenerationTask", _type.FullName, StringComparison.OrdinalIgnoreCase))
+            if (String.Equals("Microsoft.Build.Tasks.Xaml.PartialClassGenerationTask", Type.FullName, StringComparison.OrdinalIgnoreCase))
             {
-                AssemblyName assemblyName = _type.GetTypeInfo().Assembly.GetName();
+                AssemblyName assemblyName = Type.GetTypeInfo().Assembly.GetName();
                 Version lastVersionToForce = new Version(3, 5);
                 if (assemblyName.Version.CompareTo(lastVersionToForce) > 0)
                 {
                     if (String.Equals(assemblyName.Name, "PresentationBuildTasks", StringComparison.OrdinalIgnoreCase))
                     {
-                        _hasSTAThreadAttribute = true;
+                        return true;
                     }
                 }
             }
+
+            return false;
         }
 
         #region Properties
@@ -108,55 +156,33 @@ private void CheckForHardcodedSTARequirement()
         /// Gets the type that was loaded from an assembly.
         /// </summary>
         /// <value>The loaded type.</value>
-        internal Type Type
-        {
-            get
-            {
-                return _type;
-            }
-        }
+        internal Type Type { get; private set; }
+
+        internal AssemblyName LoadedAssemblyName { get; private set; }
+
+        internal string Path { get; private set; }
 
         /// <summary>
         /// If we loaded an assembly for this type.
         /// We use this information to help created AppDomains to resolve types that it could not load successfully
         /// </summary>
-        internal Assembly LoadedAssembly
-        {
-            get
-            {
-                return _loadedAssembly;
-            }
-        }
+        internal Assembly LoadedAssembly { get; private set; }
+
+#if !NET35
+        internal ReflectableTaskPropertyInfo[] Properties { get; private set; }
+#endif
+
+        /// <summary>
+        /// Assembly-qualified names for properties. Only has a value if this type was loaded using MetadataLoadContext.
+        /// </summary>
+        internal string[] PropertyAssemblyQualifiedNames { get; private set; }
 
         /// <summary>
         /// Gets the assembly the type was loaded from.
         /// </summary>
         /// <value>The assembly info for the loaded type.</value>
-        internal AssemblyLoadInfo Assembly
-        {
-            get
-            {
-                return _assembly;
-            }
-        }
+        internal AssemblyLoadInfo Assembly { get; private set; }
 
         #endregion
-
-        // the type that was loaded
-        private Type _type;
-        // the assembly the type was loaded from
-        private AssemblyLoadInfo _assembly;
-
-        // whether the loadinseparateappdomain attribute is applied to this type
-        private bool? _hasLoadInSeparateAppDomainAttribute;
-
-        // whether the STAThread attribute is applied to this type
-        private bool? _hasSTAThreadAttribute;
-
-        /// <summary>
-        /// Assembly, if any, that we loaded for this type.
-        /// We use this information to help created AppDomains to resolve types that it could not load successfully
-        /// </summary>
-        private Assembly _loadedAssembly;
     }
 }
diff --git a/src/Shared/LogMessagePacketBase.cs b/src/Shared/LogMessagePacketBase.cs
index bd010ed294f..b1d737942b5 100644
--- a/src/Shared/LogMessagePacketBase.cs
+++ b/src/Shared/LogMessagePacketBase.cs
@@ -130,11 +130,6 @@ internal enum LoggingEventType : int
         /// Event is a TelemetryEventArgs
         /// </summary>
         Telemetry = 18,
-
-        /// <summary>
-        /// Event is an EnvironmentVariableReadEventArgs
-        /// </summary>
-        EnvironmentVariableReadEvent = 19,
     }
     #endregion
 
@@ -328,8 +323,7 @@ internal void WriteToStream(ITranslator translator)
 
 #if !TASKHOST && !MSBUILDENTRYPOINTEXE
                 if (_buildEvent is ProjectEvaluationStartedEventArgs ||
-                    _buildEvent is ProjectEvaluationFinishedEventArgs ||
-                    _buildEvent is EnvironmentVariableReadEventArgs)
+                    _buildEvent is ProjectEvaluationFinishedEventArgs)
                 {
                     // switch to serialization methods that we provide in this file
                     // and don't use the WriteToStream inherited from LazyFormattedBuildEventArgs
@@ -409,7 +403,6 @@ internal void ReadFromStream(ITranslator translator)
                 else
                 {
                     _buildEvent = ReadEventFromStream(_eventType, translator);
-                    ErrorUtilities.VerifyThrow(_buildEvent is not null, "Not Supported LoggingEventType {0}", _eventType.ToString());
                 }
             }
             else
@@ -516,7 +509,6 @@ private BuildEventArgs GetBuildEventArgFromId()
                 LoggingEventType.TaskStartedEvent => new TaskStartedEventArgs(null, null, null, null, null),
                 LoggingEventType.TaskFinishedEvent => new TaskFinishedEventArgs(null, null, null, null, null, false),
                 LoggingEventType.TaskCommandLineEvent => new TaskCommandLineEventArgs(null, null, MessageImportance.Normal),
-                LoggingEventType.EnvironmentVariableReadEvent => new EnvironmentVariableReadEventArgs(),
 #if !TASKHOST // MSBuildTaskHost is targeting Microsoft.Build.Framework.dll 3.5
                 LoggingEventType.TaskParameterEvent => new TaskParameterEventArgs(0, null, null, true, default),
                 LoggingEventType.ProjectEvaluationStartedEvent => new ProjectEvaluationStartedEventArgs(),
@@ -615,10 +607,6 @@ private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg)
             {
                 return LoggingEventType.BuildErrorEvent;
             }
-            else if (eventType == typeof(EnvironmentVariableReadEventArgs))
-            {
-                return LoggingEventType.EnvironmentVariableReadEvent;
-            }
             else
             {
                 return LoggingEventType.CustomEvent;
@@ -673,29 +661,12 @@ private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType even
                 case LoggingEventType.ProjectFinishedEvent:
                     WriteExternalProjectFinishedEventToStream((ExternalProjectFinishedEventArgs)buildEvent, translator);
                     break;
-                case LoggingEventType.EnvironmentVariableReadEvent:
-                    WriteEnvironmentVariableReadEventArgs((EnvironmentVariableReadEventArgs)buildEvent, translator);
-                    break;
                 default:
                     ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
                     break;
             }
         }
 
-        /// <summary>
-        /// Serializes EnvironmentVariableRead Event argument to the stream. Does not work properly on TaskHosts due to BuildEventContext serialization not being
-        /// enabled on TaskHosts, but that shouldn't matter, as this should never be called from a TaskHost anyway.
-        /// </summary>
-        private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator)
-        {
-            string name = environmentVariableReadEventArgs.EnvironmentVariableName;
-            translator.Translate(ref name);
-            BuildEventContext context = environmentVariableReadEventArgs.BuildEventContext;
-#if !CLR2COMPATIBILITY
-            translator.Translate(ref context);
-#endif
-        }
-
         /// <summary>
         /// Serialize ExternalProjectFinished Event Argument to the stream
         /// </summary>
@@ -911,7 +882,7 @@ private void WriteProperties(IEnumerable properties, ITranslator translator)
             // it is expensive to access a ThreadStatic field every time
             var list = reusablePropertyList;
 
-            Internal.Utilities.EnumerateProperties(properties, kvp => list.Add(kvp));
+            Internal.Utilities.EnumerateProperties(properties, list, static (list, kvp) => list.Add(kvp));
 
             BinaryWriterExtensions.Write7BitEncodedInt(writer, list.Count);
 
@@ -1030,33 +1001,33 @@ private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslat
             translator.Translate(ref helpKeyword);
             translator.Translate(ref senderName);
 
-            return eventType switch
+            BuildEventArgs buildEvent = null;
+            switch (eventType)
             {
-                LoggingEventType.TaskCommandLineEvent => ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.BuildErrorEvent => ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.ProjectStartedEvent => ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.ProjectFinishedEvent => ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.BuildMessageEvent => ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.BuildWarningEvent => ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName),
-                LoggingEventType.EnvironmentVariableReadEvent => ReadEnvironmentVariableReadEventFromStream(translator, message, helpKeyword, senderName),
-                _ => null,
-            };
-        }
+                case LoggingEventType.TaskCommandLineEvent:
+                    buildEvent = ReadTaskCommandLineEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                case LoggingEventType.BuildErrorEvent:
+                    buildEvent = ReadTaskBuildErrorEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                case LoggingEventType.ProjectStartedEvent:
+                    buildEvent = ReadExternalProjectStartedEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                case LoggingEventType.ProjectFinishedEvent:
+                    buildEvent = ReadExternalProjectFinishedEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                case LoggingEventType.BuildMessageEvent:
+                    buildEvent = ReadBuildMessageEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                case LoggingEventType.BuildWarningEvent:
+                    buildEvent = ReadBuildWarningEventFromStream(translator, message, helpKeyword, senderName);
+                    break;
+                default:
+                    ErrorUtilities.ThrowInternalError("Not Supported LoggingEventType {0}", eventType.ToString());
+                    break;
+            }
 
-        /// <summary>
-        /// Read and reconstruct an EnvironmentVariableReadEventArgs from the stream. This message should never be called from a TaskHost, so although the context translation does not work, that's ok.
-        /// </summary>
-        private EnvironmentVariableReadEventArgs ReadEnvironmentVariableReadEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName)
-        {
-            string environmentVariableName = null;
-            translator.Translate(ref environmentVariableName);
-            BuildEventContext context = null;
-#if !CLR2COMPATIBILITY
-            translator.Translate(ref context);
-#endif
-            EnvironmentVariableReadEventArgs args = new(environmentVariableName, message);
-            args.BuildEventContext = context;
-            return args;
+            return buildEvent;
         }
 
         /// <summary>
diff --git a/src/Shared/NamedPipeUtil.cs b/src/Shared/NamedPipeUtil.cs
index 4fbe37002a4..dfc76317e84 100644
--- a/src/Shared/NamedPipeUtil.cs
+++ b/src/Shared/NamedPipeUtil.cs
@@ -8,7 +8,7 @@ namespace Microsoft.Build.Shared
 {
     internal static class NamedPipeUtil
     {
-        internal static string GetPipeNameOrPath(int? processId = null)
+        internal static string GetPlatformSpecificPipeName(int? processId = null)
         {
             if (processId is null)
             {
@@ -17,6 +17,11 @@ internal static string GetPipeNameOrPath(int? processId = null)
 
             string pipeName = $"MSBuild{processId}";
 
+            return GetPlatformSpecificPipeName(pipeName);
+        }
+
+        internal static string GetPlatformSpecificPipeName(string pipeName)
+        {
             if (NativeMethodsShared.IsUnixLike)
             {
                 // If we're on a Unix machine then named pipes are implemented using Unix Domain Sockets.
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index ea696a53ec3..4c5a3357063 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -72,6 +72,13 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// </summary>
         private AutoResetEvent _terminatePacketPump;
 
+        /// <summary>
+        /// True if this side is gracefully disconnecting.
+        /// In such case we have sent last packet to client side and we expect
+        /// client will soon broke pipe connection - unless server do it first.
+        /// </summary>
+        private bool _isClientDisconnecting;
+
         /// <summary>
         /// The thread which runs the asynchronous packet pump
         /// </summary>
@@ -178,6 +185,14 @@ public void SendData(INodePacket packet)
             }
         }
 
+        /// <summary>
+        /// Called when we are about to send last packet to finalize graceful disconnection with client.
+        /// </summary>
+        public void ClientWillDisconnect()
+        {
+            _isClientDisconnecting = true;
+        }
+
 #endregion
 
 #region Construction
@@ -185,7 +200,7 @@ public void SendData(INodePacket packet)
         /// <summary>
         /// Instantiates an endpoint to act as a client
         /// </summary>
-        internal void InternalConstruct()
+        internal void InternalConstruct(string pipeName = null)
         {
             _status = LinkStatus.Inactive;
             _asyncDataMonitor = new object();
@@ -194,7 +209,7 @@ internal void InternalConstruct()
             _packetStream = new MemoryStream();
             _binaryWriter = new BinaryWriter(_packetStream);
 
-            string pipeName = NamedPipeUtil.GetPipeNameOrPath();
+            pipeName ??= NamedPipeUtil.GetPlatformSpecificPipeName();
 
 #if FEATURE_PIPE_SECURITY && FEATURE_NAMED_PIPE_SECURITY_CONSTRUCTOR
             if (!NativeMethodsShared.IsMono)
@@ -311,6 +326,7 @@ private void InitializeAsyncPacketThread()
         {
             lock (_asyncDataMonitor)
             {
+                _isClientDisconnecting = false;
                 _packetPump = new Thread(PacketPumpProc);
                 _packetPump.IsBackground = true;
                 _packetPump.Name = "OutOfProc Endpoint Packet Pump";
@@ -547,14 +563,25 @@ private void RunReadLoop(Stream localReadPipe, Stream localWritePipe,
                                 // Incomplete read.  Abort.
                                 if (bytesRead == 0)
                                 {
-                                    CommunicationsUtilities.Trace("Parent disconnected abruptly");
+                                    if (_isClientDisconnecting)
+                                    {
+                                        CommunicationsUtilities.Trace("Parent disconnected gracefully.");
+                                        // Do not change link status to failed as this could make node think connection has failed
+                                        // and recycle node, while this is perfectly expected and handled race condition
+                                        // (both client and node is about to close pipe and client can be faster).
+                                    }
+                                    else
+                                    {
+                                        CommunicationsUtilities.Trace("Parent disconnected abruptly.");
+                                        ChangeLinkStatus(LinkStatus.Failed);
+                                    }
                                 }
                                 else
                                 {
                                     CommunicationsUtilities.Trace("Incomplete header read from server.  {0} of {1} bytes read", bytesRead, headerByte.Length);
+                                    ChangeLinkStatus(LinkStatus.Failed);
                                 }
 
-                                ChangeLinkStatus(LinkStatus.Failed);
                                 exitLoop = true;
                                 break;
                             }
diff --git a/src/Shared/PlatformNegotiation.cs b/src/Shared/PlatformNegotiation.cs
index a0389604db3..d8102f69f4e 100644
--- a/src/Shared/PlatformNegotiation.cs
+++ b/src/Shared/PlatformNegotiation.cs
@@ -28,7 +28,7 @@ internal static string GetNearestPlatform(string referencedProjectPlatform, stri
                 // mappings on a per-ProjectReference basis.
                 Dictionary<string, string>? projectReferenceLookupTable = ExtractLookupTable(projectReferenceLookupTableMetadata, log);
 
-                HashSet<string> projectReferencePlatforms = new HashSet<string>();
+                HashSet<string> projectReferencePlatforms = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
                 foreach (string s in projectReferencePlatformsMetadata.Split(MSBuildConstants.SemicolonChar, StringSplitOptions.RemoveEmptyEntries))
                 {
                     projectReferencePlatforms.Add(s);
diff --git a/src/Shared/TaskLoader.cs b/src/Shared/TaskLoader.cs
index 0ab62f70203..f66497dc018 100644
--- a/src/Shared/TaskLoader.cs
+++ b/src/Shared/TaskLoader.cs
@@ -53,7 +53,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
             )
         {
 #if FEATURE_APPDOMAIN
-            bool separateAppDomain = loadedType.HasLoadInSeparateAppDomainAttribute();
+            bool separateAppDomain = loadedType.HasLoadInSeparateAppDomainAttribute;
             s_resolverLoadedType = null;
             taskAppDomain = null;
             ITask taskInstanceInOtherAppDomain = null;
@@ -64,7 +64,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
 #if FEATURE_APPDOMAIN
                 if (separateAppDomain)
                 {
-                    if (!loadedType.Type.GetTypeInfo().IsMarshalByRef)
+                    if (!loadedType.IsMarshalByRef)
                     {
                         logError
                         (
@@ -107,7 +107,7 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
 
                         if (loadedType.LoadedAssembly != null)
                         {
-                            taskAppDomain.Load(loadedType.LoadedAssembly.GetName());
+                            taskAppDomain.Load(loadedType.LoadedAssemblyName);
                         }
 
                         // Hook up last minute dumping of any exceptions 
@@ -176,13 +176,9 @@ internal static ITask CreateTask(LoadedType loadedType, string taskName, string
         /// </summary>
         internal static Assembly AssemblyResolver(object sender, ResolveEventArgs args)
         {
-            if ((s_resolverLoadedType?.LoadedAssembly != null))
+            if (args.Name.Equals(s_resolverLoadedType.LoadedAssemblyName.FullName, StringComparison.OrdinalIgnoreCase))
             {
-                // Match the name being requested by the resolver with the FullName of the assembly we have loaded
-                if (args.Name.Equals(s_resolverLoadedType.LoadedAssembly.FullName, StringComparison.Ordinal))
-                {
-                    return s_resolverLoadedType.LoadedAssembly;
-                }
+                return s_resolverLoadedType.LoadedAssembly ?? Assembly.Load(s_resolverLoadedType.Path);
             }
 
             return null;
diff --git a/src/Shared/TaskLoggingHelper.cs b/src/Shared/TaskLoggingHelper.cs
index 6afa121168a..d9cdca05e73 100644
--- a/src/Shared/TaskLoggingHelper.cs
+++ b/src/Shared/TaskLoggingHelper.cs
@@ -1364,7 +1364,7 @@ public bool LogMessagesFromStream(TextReader stream, MessageImportance messageIm
 
         /// <summary>
         /// Logs an error/warning/message from the given line of text. Errors/warnings are only logged for lines that fit a
-        /// particular (canonical) format -- all other lines are treated as messages.
+        /// <see href="https://docs.microsoft.com/visualstudio/msbuild/msbuild-diagnostic-format-for-tasks">particular (canonical) format</see> -- all other lines are treated as messages.
         /// Thread safe.
         /// </summary>
         /// <param name="lineOfText">The line of text to log from.</param>
diff --git a/src/Shared/TypeLoader.cs b/src/Shared/TypeLoader.cs
index fe5ea680c49..9a1b027bd35 100644
--- a/src/Shared/TypeLoader.cs
+++ b/src/Shared/TypeLoader.cs
@@ -5,10 +5,15 @@
 using System.Collections.Concurrent;
 using System.Collections.Generic;
 using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
 using System.IO;
 using System.Reflection;
+using System.Runtime.InteropServices;
+#if !NETFRAMEWORK
+using System.Runtime.Loader;
+#endif
 using System.Threading;
+using Microsoft.Build.Eventing;
+using Microsoft.Build.Framework;
 
 #nullable disable
 
@@ -41,6 +46,25 @@ internal class TypeLoader
         /// </summary>
         private Func<Type, object, bool> _isDesiredType;
 
+        private static MetadataLoadContext _context;
+
+        private static string[] runtimeAssemblies = findRuntimeAssembliesWithMicrosoftBuildFramework();
+        private static string microsoftBuildFrameworkPath;
+
+        // We need to append Microsoft.Build.Framework from next to the executing assembly first to make sure it's loaded before the runtime variant.
+        private static string[] findRuntimeAssembliesWithMicrosoftBuildFramework()
+        {
+            string msbuildDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
+            microsoftBuildFrameworkPath = Path.Combine(msbuildDirectory, "Microsoft.Build.Framework.dll");
+            string[] msbuildAssemblies = Directory.GetFiles(msbuildDirectory, "*.dll");
+            string[] runtimeAssemblies = Directory.GetFiles(RuntimeEnvironment.GetRuntimeDirectory(), "*.dll");
+
+            List<string> msbuildAssembliesList = new(msbuildAssemblies);
+            msbuildAssembliesList.AddRange(runtimeAssemblies);
+
+            return msbuildAssembliesList.ToArray();
+        }
+
         /// <summary>
         /// Constructor.
         /// </summary>
@@ -139,26 +163,20 @@ internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2)
         /// <returns></returns>
         private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)
         {
-            Assembly loadedAssembly = null;
-
             try
             {
                 if (assemblyLoadInfo.AssemblyName != null)
                 {
-#if !FEATURE_ASSEMBLYLOADCONTEXT
-                    loadedAssembly = Assembly.Load(assemblyLoadInfo.AssemblyName);
-#else
-                    loadedAssembly = Assembly.Load(new AssemblyName(assemblyLoadInfo.AssemblyName));
-#endif
+                    return Assembly.Load(assemblyLoadInfo.AssemblyName);
                 }
                 else
                 {
 #if !FEATURE_ASSEMBLYLOADCONTEXT
-                    loadedAssembly = Assembly.UnsafeLoadFrom(assemblyLoadInfo.AssemblyFile);
+                    return Assembly.UnsafeLoadFrom(assemblyLoadInfo.AssemblyFile);
 #else
-                    var baseDir = Path.GetDirectoryName(assemblyLoadInfo.AssemblyFile);
+                    string baseDir = Path.GetDirectoryName(assemblyLoadInfo.AssemblyFile);
                     s_coreClrAssemblyLoader.AddDependencyLocation(baseDir);
-                    loadedAssembly = s_coreClrAssemblyLoader.LoadFromPath(assemblyLoadInfo.AssemblyFile);
+                    return s_coreClrAssemblyLoader.LoadFromPath(assemblyLoadInfo.AssemblyFile);
 #endif
                 }
             }
@@ -169,8 +187,16 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)
                 // NOTE: don't use ErrorUtilities.VerifyThrowFileExists() here because that will hit the disk again
                 throw new FileNotFoundException(null, assemblyLoadInfo.AssemblyLocation, e);
             }
+        }
 
-            return loadedAssembly;
+        private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo)
+        {
+            string path = assemblyLoadInfo.AssemblyFile;
+            List<string> localPaths = new(Directory.GetFiles(Path.GetDirectoryName(path), "*.dll"));
+            localPaths.AddRange(runtimeAssemblies);
+
+            _context = new(new PathAssemblyResolver(localPaths));
+            return _context.LoadFromAssemblyPath(path);
         }
 
         /// <summary>
@@ -181,10 +207,11 @@ private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo)
         internal LoadedType Load
         (
             string typeName,
-            AssemblyLoadInfo assembly
+            AssemblyLoadInfo assembly,
+            bool useTaskHost = false
         )
         {
-            return GetLoadedType(s_cacheOfLoadedTypesByFilter, typeName, assembly);
+            return GetLoadedType(s_cacheOfLoadedTypesByFilter, typeName, assembly, useTaskHost);
         }
 
         /// <summary>
@@ -199,7 +226,7 @@ internal LoadedType ReflectionOnlyLoad
             AssemblyLoadInfo assembly
         )
         {
-            return GetLoadedType(s_cacheOfReflectionOnlyLoadedTypesByFilter, typeName, assembly);
+            return GetLoadedType(s_cacheOfReflectionOnlyLoadedTypesByFilter, typeName, assembly, useTaskHost: false);
         }
 
         /// <summary>
@@ -207,7 +234,7 @@ AssemblyLoadInfo assembly
         /// any) is unambiguous; otherwise, if there are multiple types with the same name in different namespaces, the first type
         /// found will be returned.
         /// </summary>
-        private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly)
+        private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>, ConcurrentDictionary<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly, bool useTaskHost)
         {
             // A given type filter have been used on a number of assemblies, Based on the type filter we will get another dictionary which 
             // will map a specific AssemblyLoadInfo to a AssemblyInfoToLoadedTypes class which knows how to find a typeName in a given assembly.
@@ -218,7 +245,7 @@ private LoadedType GetLoadedType(ConcurrentDictionary<Func<Type, object, bool>,
             AssemblyInfoToLoadedTypes typeNameToType =
                 loadInfoToType.GetOrAdd(assembly, (_) => new AssemblyInfoToLoadedTypes(_isDesiredType, _));
 
-            return typeNameToType.GetLoadedTypeByTypeName(typeName);
+            return typeNameToType.GetLoadedTypeByTypeName(typeName, useTaskHost);
         }
 
         /// <summary>
@@ -256,6 +283,8 @@ private class AssemblyInfoToLoadedTypes
             /// </summary>
             private Dictionary<string, Type> _publicTypeNameToType;
 
+            private ConcurrentDictionary<string, LoadedType> _publicTypeNameToLoadedType;
+
             /// <summary>
             /// Have we scanned the public types for this assembly yet.
             /// </summary>
@@ -278,19 +307,24 @@ internal AssemblyInfoToLoadedTypes(Func<Type, object, bool> typeFilter, Assembly
 
                 _isDesiredType = typeFilter;
                 _assemblyLoadInfo = loadInfo;
-                _typeNameToType = new ConcurrentDictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
+                _typeNameToType = new(StringComparer.OrdinalIgnoreCase);
                 _publicTypeNameToType = new Dictionary<string, Type>(StringComparer.OrdinalIgnoreCase);
+                _publicTypeNameToLoadedType = new(StringComparer.OrdinalIgnoreCase);
             }
 
             /// <summary>
             /// Determine if a given type name is in the assembly or not. Return null if the type is not in the assembly
             /// </summary>
-            internal LoadedType GetLoadedTypeByTypeName(string typeName)
+            internal LoadedType GetLoadedTypeByTypeName(string typeName, bool useTaskHost)
             {
                 ErrorUtilities.VerifyThrowArgumentNull(typeName, nameof(typeName));
 
-                // Only one thread should be doing operations on this instance of the object at a time.
+                if (useTaskHost && _assemblyLoadInfo.AssemblyFile is not null)
+                {
+                    return GetLoadedTypeFromTypeNameUsingMetadataLoadContext(typeName);
+                }
 
+                // Only one thread should be doing operations on this instance of the object at a time.
                 Type type = _typeNameToType.GetOrAdd(typeName, (key) =>
                 {
                     if ((_assemblyLoadInfo.AssemblyName != null) && (typeName.Length > 0))
@@ -336,14 +370,40 @@ internal LoadedType GetLoadedTypeByTypeName(string typeName)
                     return null;
                 });
 
-                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly) : null;
+                return type != null ? new LoadedType(type, _assemblyLoadInfo, _loadedAssembly ?? type.Assembly, typeof(ITaskItem), loadedViaMetadataLoadContext: false) : null;
+            }
+
+            private LoadedType GetLoadedTypeFromTypeNameUsingMetadataLoadContext(string typeName)
+            {
+                return _publicTypeNameToLoadedType.GetOrAdd(typeName, typeName =>
+                {
+                    MSBuildEventSource.Log.LoadAssemblyAndFindTypeStart();
+                    Assembly loadedAssembly = LoadAssemblyUsingMetadataLoadContext(_assemblyLoadInfo);
+                    int numberOfTypesSearched = 0;
+                    foreach (Type publicType in loadedAssembly.GetExportedTypes())
+                    {
+                        numberOfTypesSearched++;
+                        if (_isDesiredType(publicType, null) && (typeName.Length == 0 || TypeLoader.IsPartialTypeNameMatch(publicType.FullName, typeName)))
+                        {
+                            MSBuildEventSource.Log.CreateLoadedTypeStart(loadedAssembly.FullName);
+                            LoadedType loadedType = new(publicType, _assemblyLoadInfo, loadedAssembly, _context.LoadFromAssemblyPath(microsoftBuildFrameworkPath).GetType(typeof(ITaskItem).FullName), loadedViaMetadataLoadContext: true);
+                            _context?.Dispose();
+                            _context = null;
+                            MSBuildEventSource.Log.CreateLoadedTypeStop(loadedAssembly.FullName);
+                            return loadedType;
+                        }
+                    }
+
+                    MSBuildEventSource.Log.LoadAssemblyAndFindTypeStop(_assemblyLoadInfo.AssemblyFile, numberOfTypesSearched);
+
+                    return null;
+                });
             }
 
             /// <summary>
             /// Scan the assembly pointed to by the assemblyLoadInfo for public types. We will use these public types to do partial name matching on 
             /// to find tasks, loggers, and task factories.
             /// </summary>
-            [SuppressMessage("Microsoft.Reliability", "CA2001:AvoidCallingProblematicMethods", MessageId = "System.Reflection.Assembly.LoadFrom", Justification = "Necessary in this case.")]
             private void ScanAssemblyForPublicTypes()
             {
                 // we need to search the assembly for the type...
diff --git a/src/Shared/UnitTests/FileMatcher_Tests.cs b/src/Shared/UnitTests/FileMatcher_Tests.cs
index e83e0c56d1b..e29d3e3a89c 100644
--- a/src/Shared/UnitTests/FileMatcher_Tests.cs
+++ b/src/Shared/UnitTests/FileMatcher_Tests.cs
@@ -67,6 +67,30 @@ public void GetFilesPatternMatching(string pattern, int expectedMatchCount)
             fileMatches.Length.ShouldBe(expectedMatchCount, $"Matches: '{String.Join("', '", fileMatches)}'");
         }
 
+#if FEATURE_SYMLINK_TARGET
+        [Fact]
+        public void DoNotFollowRecursiveSymlinks()
+        {
+            TransientTestFolder testFolder = _env.CreateFolder();
+            TransientTestFile file = _env.CreateFile(testFolder, "Foo.cs");
+            TransientTestFolder tf2 = _env.CreateFolder(Path.Combine(testFolder.Path, "subfolder"));
+            string symlinkPath = Path.Combine(tf2.Path, "mySymlink");
+            try
+            {
+                Directory.CreateSymbolicLink(symlinkPath, testFolder.Path);
+                string[] fileMatches = FileMatcher.Default.GetFiles(testFolder.Path, "**").FileList;
+                fileMatches.Length.ShouldBe(1);
+            }
+            finally
+            {
+                if (Directory.Exists(symlinkPath))
+                {
+                    Directory.Delete(symlinkPath);
+                }
+            }
+        }
+#endif
+
         [Theory]
         [MemberData(nameof(GetFilesComplexGlobbingMatchingInfo.GetTestData), MemberType = typeof(GetFilesComplexGlobbingMatchingInfo))]
         public void GetFilesComplexGlobbingMatching(GetFilesComplexGlobbingMatchingInfo info)
@@ -2077,7 +2101,7 @@ out bool isLegalFileSpec
             isLegalFileSpec.ShouldBe(expectedIsLegalFileSpec);
         }
 
-        #region Support functions.
+#region Support functions.
 
         /// <summary>
         /// This support class simulates a file system.
@@ -2758,7 +2782,7 @@ bool shouldBeRecursive
             return match.isMatch;
         }
 
-        #endregion
+#endregion
 
         private class FileSystemAdapter : IFileSystem
         {
diff --git a/src/Shared/UnitTests/ObjectModelHelpers.cs b/src/Shared/UnitTests/ObjectModelHelpers.cs
index f8d6a15e9d3..3cb530afca4 100644
--- a/src/Shared/UnitTests/ObjectModelHelpers.cs
+++ b/src/Shared/UnitTests/ObjectModelHelpers.cs
@@ -1703,34 +1703,6 @@ internal static TransientTestFile CreateProjectFile(
             return env.CreateFile(projectNumber + ".proj", sb.ToString());
         }
 
-        internal static ProjectGraph CreateProjectGraph(
-            TestEnvironment env,
-            IDictionary<int, int[]> dependencyEdges,
-            IDictionary<int, string> extraContentPerProjectNumber,
-            string extraContentForAllNodes = null)
-        {
-            return CreateProjectGraph(
-                env: env,
-                dependencyEdges: dependencyEdges,
-                globalProperties: null,
-                createProjectFile: (environment, projectNumber, references, projectReferenceTargets, defaultTargets, extraContent) =>
-                {
-                    extraContent = extraContentPerProjectNumber != null && extraContentPerProjectNumber.TryGetValue(projectNumber, out var content)
-                        ? content
-                        : string.Empty;
-
-                    extraContent += extraContentForAllNodes ?? string.Empty;
-
-                    return CreateProjectFile(
-                        environment,
-                        projectNumber,
-                        references,
-                        projectReferenceTargets,
-                        defaultTargets,
-                        extraContent.Cleanup());
-                });
-        }
-
         internal static ProjectGraph CreateProjectGraph(
             TestEnvironment env,
             // direct dependencies that the kvp.key node has on the nodes represented by kvp.value
@@ -1738,7 +1710,9 @@ internal static ProjectGraph CreateProjectGraph(
             IDictionary<string, string> globalProperties = null,
             CreateProjectFileDelegate createProjectFile = null,
             IEnumerable<int> entryPoints = null,
-            ProjectCollection projectCollection = null)
+            ProjectCollection projectCollection = null,
+            IDictionary<int, string> extraContentPerProjectNumber = null,
+            string extraContentForAllNodes = null)
         {
             createProjectFile ??= CreateProjectFile;
 
@@ -1751,7 +1725,13 @@ internal static ProjectGraph CreateProjectGraph(
 
                 if (!nodes.ContainsKey(parent))
                 {
-                    var file = createProjectFile(env, parent, nodeDependencies.Value);
+                    TransientTestFile file = createProjectFile(
+                        env,
+                        parent,
+                        nodeDependencies.Value,
+                        projectReferenceTargets: null,
+                        defaultTargets: null,
+                        extraContent: GetExtraContent(parent));
                     nodes[parent] = (IsRoot(parent), file.Path);
                 }
             }
@@ -1768,7 +1748,12 @@ internal static ProjectGraph CreateProjectGraph(
                 {
                     if (!nodes.ContainsKey(reference))
                     {
-                        var file = createProjectFile(env, reference);
+                        TransientTestFile file = createProjectFile(
+                            env,
+                            reference,
+                            projectReferenceTargets: null,
+                            defaultTargets: null,
+                            extraContent: GetExtraContent(reference));
                         nodes[reference] = (false, file.Path);
                     }
                 }
@@ -1785,6 +1770,17 @@ internal static ProjectGraph CreateProjectGraph(
                     .Collection
                 );
 
+            string GetExtraContent(int projectNum)
+            {
+                string extraContent = extraContentPerProjectNumber != null && extraContentPerProjectNumber.TryGetValue(projectNum, out string extraContentForProject)
+                    ? extraContentForProject
+                    : string.Empty;
+
+                extraContent += extraContentForAllNodes ?? string.Empty;
+
+                return extraContent.Cleanup();
+            }
+
             bool IsRoot(int node)
             {
                 foreach (var nodeDependencies in dependencyEdges)
@@ -2084,15 +2080,12 @@ public async Task<BuildResult> BuildProjectFileAsync(
                 return await completion.Task;
             }
 
-            public GraphBuildResult BuildGraphSubmission(GraphBuildRequestData requestData)
-            {
-                return _buildManager.BuildRequest(requestData);
-            }
+            public BuildResult Build(BuildRequestData requestData) => _buildManager.BuildRequest(requestData);
+
+            public GraphBuildResult BuildGraphSubmission(GraphBuildRequestData requestData) => _buildManager.BuildRequest(requestData);
 
             public GraphBuildResult BuildGraph(ProjectGraph graph, string[] entryTargets = null)
-            {
-                return _buildManager.BuildRequest(new GraphBuildRequestData(graph, entryTargets ?? Array.Empty<string>()));
-            }
+                => _buildManager.BuildRequest(new GraphBuildRequestData(graph, entryTargets ?? Array.Empty<string>()));
 
             public void Dispose()
             {
diff --git a/src/Shared/UnitTests/TestEnvironment.cs b/src/Shared/UnitTests/TestEnvironment.cs
index 49e86433de5..2db94fa9e83 100644
--- a/src/Shared/UnitTests/TestEnvironment.cs
+++ b/src/Shared/UnitTests/TestEnvironment.cs
@@ -4,6 +4,7 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
+using System.Diagnostics;
 using System.IO;
 using System.IO.Compression;
 using System.Linq;
@@ -258,6 +259,17 @@ public TransientTestFile ExpectFile(string extension = ".tmp")
             return WithTransientTestState(new TransientTestFile(extension, createFile: false, expectedAsOutput: true));
         }
 
+        /// <summary>
+        /// Create a temp file name under a specific temporary folder. The file is expected to exist when the test completes.
+        /// </summary>
+        /// <param name="transientTestFolder">Temp folder</param>
+        /// <param name="extension">Extension of the file (defaults to '.tmp')</param>
+        /// <returns></returns>
+        public TransientTestFile ExpectFile(TransientTestFolder transientTestFolder, string extension = ".tmp")
+        {
+            return WithTransientTestState(new TransientTestFile(transientTestFolder.Path, extension, createFile: false, expectedAsOutput: true));
+        }
+
         /// <summary>
         ///     Creates a test variant used to add a unique temporary folder during a test. Will be deleted when the test
         ///     completes.
@@ -317,6 +329,15 @@ public TransientTestState SetCurrentDirectory(string newWorkingDirectory)
             return WithTransientTestState(new TransientWorkingDirectory(newWorkingDirectory));
         }
 
+        /// <summary>
+        /// Register process ID to be finished/killed after tests ends.
+        /// </summary>
+        public TransientTestProcess WithTransientProcess(int processId)
+        {
+            TransientTestProcess transientTestProcess = new(processId);
+            return WithTransientTestState(transientTestProcess);
+        }
+
         #endregion
 
         private class DefaultOutput : ITestOutputHelper
@@ -549,6 +570,24 @@ public override void Revert()
         }
     }
 
+    public class TransientTestProcess : TransientTestState
+    {
+        private readonly int _processId;
+
+        public TransientTestProcess(int processId)
+        {
+            _processId = processId;
+        }
+
+        public override void Revert()
+        {
+            if (_processId > -1)
+            {
+                Process.GetProcessById(_processId).KillTree(1000);
+            }
+        }
+    }
+
 
     public class TransientTestFile : TransientTestState
     {
diff --git a/src/Shared/XMakeAttributes.cs b/src/Shared/XMakeAttributes.cs
index 7a4d501e09c..1018c4b79aa 100644
--- a/src/Shared/XMakeAttributes.cs
+++ b/src/Shared/XMakeAttributes.cs
@@ -447,7 +447,11 @@ internal static string GetCurrentMSBuildArchitecture()
                     currentArchitecture = MSBuildArchitectureValues.arm64;
                     break;
                 default:
-                    throw new PlatformNotSupportedException(string.Format("{0} is not a supported architecture.", RuntimeInformation.ProcessArchitecture));
+                    // We're not sure what the architecture is, default to original 32/64bit logic.
+                    // This allows architectures like s390x to continue working.
+                    // https://github.com/dotnet/msbuild/issues/7729
+                    currentArchitecture = (IntPtr.Size == sizeof(Int64)) ? MSBuildArchitectureValues.x64 : MSBuildArchitectureValues.x86;
+                    break;
             }
 #else
             string currentArchitecture = (IntPtr.Size == sizeof(Int64)) ? MSBuildArchitectureValues.x64 : MSBuildArchitectureValues.x86;
diff --git a/src/StringTools.Benchmark/StringTools.Benchmark.csproj b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
index 92f0e8e82eb..95e3ca90a7a 100644
--- a/src/StringTools.Benchmark/StringTools.Benchmark.csproj
+++ b/src/StringTools.Benchmark/StringTools.Benchmark.csproj
@@ -14,6 +14,9 @@
 
   <ItemGroup>
     <PackageReference Include="BenchmarkDotNet" />
+  </ItemGroup>
+
+  <ItemGroup Condition="'$(DotNetBuildFromSource)' != 'true'">
     <!-- Bump these to the latest version despite transitive references to older -->
     <PackageReference Include="System.Private.Uri" />
     <PackageReference Include="System.Runtime" />
diff --git a/src/StringTools/StringTools.csproj b/src/StringTools/StringTools.csproj
index 15ac5335951..fb76d610862 100644
--- a/src/StringTools/StringTools.csproj
+++ b/src/StringTools/StringTools.csproj
@@ -3,15 +3,14 @@
     <TargetFrameworks>$(LibraryTargetFrameworks)</TargetFrameworks>
     <TargetFrameworks Condition="'$(MSBuildRuntimeType)' != 'Core' and '$(MonoBuild)' != 'true'">$(LibraryTargetFrameworks);net35</TargetFrameworks>
     <PlatformTarget>AnyCPU</PlatformTarget>
-    <WarningsAsErrors>true</WarningsAsErrors>
+    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
     <IsPackable>true</IsPackable>
     <GenerateReferenceAssemblySource>true</GenerateReferenceAssemblySource>
     <LangVersion>8.0</LangVersion>
     <PackageId>Microsoft.NET.StringTools</PackageId>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
 
-    <VersionPrefix>1.0.0</VersionPrefix>
-    <AssemblyVersion></AssemblyVersion>
+    <AssemblyVersion>1.0.0.0</AssemblyVersion>
     <SemanticVersioningV1>true</SemanticVersioningV1>
 
     <AssemblyName>Microsoft.NET.StringTools</AssemblyName>
diff --git a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
index 40f3e4615d4..020faf1e2fa 100644
--- a/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
+++ b/src/Tasks.UnitTests/GetInstalledSDKLocations_Tests.cs
@@ -149,6 +149,7 @@ private static string MakeFakeSDKStructure2()
     /// <summary>
     /// Test the GetInstalledSDKLocations task
     /// </summary>
+    [PlatformSpecific(TestPlatforms.Windows)]
     public class GetInstalledSDKLocationsTestFixture : IClassFixture<FakeSDKStructure>
     {
         private readonly string _fakeSDKStructureRoot;
diff --git a/src/Tasks.UnitTests/GetSDKReference_Tests.cs b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
index 691c7be48b6..0ab7c94a669 100644
--- a/src/Tasks.UnitTests/GetSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/GetSDKReference_Tests.cs
@@ -180,6 +180,7 @@ private static string CreateFakeSDKReferenceAssemblyDirectory2(out string sdkDir
     /// <summary>
     /// Test the expansion of sdk reference assemblies.
     /// </summary>
+    [PlatformSpecific(TestPlatforms.Windows)]
     public class GetSDKReferenceFilesTestFixture : IDisposable, IClassFixture<FakeSdkStructure>
     {
         private readonly ITestOutputHelper _output;
diff --git a/src/Tasks.UnitTests/MSBuild_Tests.cs b/src/Tasks.UnitTests/MSBuild_Tests.cs
index d2a6effe7d7..96bad83b931 100644
--- a/src/Tasks.UnitTests/MSBuild_Tests.cs
+++ b/src/Tasks.UnitTests/MSBuild_Tests.cs
@@ -290,6 +290,55 @@ public void SkipNonexistentProjectsBuildingInParallel()
             Assert.DoesNotContain("MSB3202", logger.FullLog); // project file not found error
         }
 
+
+        /// <summary>
+        /// </summary>
+        [Fact]
+        public void SkipNonexistentProjectsAsMetadataBuildingInParallel()
+        {
+            ObjectModelHelpers.DeleteTempProjectDirectory();
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(
+                "SkipNonexistentProjectsMain.csproj",
+                @"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                    <Target Name=`t` >
+                        <ItemGroup>
+                            <ProjectReference Include=`this_project_does_not_exist_warn.csproj` >
+                                <SkipNonexistentProjects>true</SkipNonexistentProjects>
+                            </ProjectReference>
+                            <ProjectReference Include=`this_project_does_not_exist_error.csproj` >
+                            </ProjectReference>
+                            <ProjectReference Include=`foo.csproj` >
+                                <SkipNonexistentProjects>false</SkipNonexistentProjects>
+                            </ProjectReference>
+                        </ItemGroup>
+                        <MSBuild Projects=`@(ProjectReference)` BuildInParallel=`true` />
+                    </Target>
+                </Project>
+                ");
+
+            ObjectModelHelpers.CreateFileInTempProjectDirectory(
+                "foo.csproj",
+                @"<Project ToolsVersion=`msbuilddefaulttoolsversion` xmlns=`msbuildnamespace`>
+                    <Target Name=`t` >
+                        <Message Text=`Hello from foo.csproj`/>
+                    </Target>
+                </Project>
+                ");
+
+            MockLogger logger = new MockLogger(_testOutput);
+            ObjectModelHelpers.BuildTempProjectFileExpectFailure(@"SkipNonexistentProjectsMain.csproj", logger);
+
+            logger.AssertLogContains("Hello from foo.csproj");
+            string message = String.Format(AssemblyResources.GetString("MSBuild.ProjectFileNotFoundMessage"), "this_project_does_not_exist_warn.csproj");
+            string error = String.Format(AssemblyResources.GetString("MSBuild.ProjectFileNotFound"), "this_project_does_not_exist_warn.csproj");
+            string error2 = String.Format(AssemblyResources.GetString("MSBuild.ProjectFileNotFound"), "this_project_does_not_exist_error.csproj");
+            Assert.Equal(0, logger.WarningCount);
+            Assert.Equal(1, logger.ErrorCount);
+            Assert.Contains(message, logger.FullLog); // for the missing project
+            Assert.Contains(error2, logger.FullLog);
+            Assert.DoesNotContain(error, logger.FullLog);
+        }
+
         [Fact]
         public void LogErrorWhenBuildingVCProj()
         {
diff --git a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
index e0f20bd2eec..3acd8c56824 100644
--- a/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
+++ b/src/Tasks.UnitTests/Microsoft.Build.Tasks.UnitTests.csproj
@@ -44,7 +44,6 @@
     <Compile Include="..\Shared\UnitTests\EscapingUtilities_Tests.cs" />
     <Compile Include="..\Shared\UnitTests\ErrorUtilities_Tests.cs" />
     <Compile Include="..\Shared\UnitTests\PrintLineDebugger_Tests.cs" />
-    <Compile Include="..\Shared\UnitTests\FileMatcher_Tests.cs" />
     <Compile Include="..\Shared\UnitTests\MockEngine.cs" />
     <Compile Include="..\Shared\UnitTests\MockLogger.cs" />
     <Compile Include="..\Shared\UnitTests\NativeMethodsShared_Tests.cs">
@@ -57,6 +56,7 @@
     <Compile Include="..\Shared\UnitTests\TestEnvironment.cs">
       <Link>TestEnvironment.cs</Link>
     </Compile>
+    <Compile Include="..\Shared\ProcessExtensions.cs" />
     <Compile Include="..\UnitTests.Shared\RunnerUtilities.cs" />
 
     <EmbeddedResource Include="SampleResx" />
@@ -71,6 +71,12 @@
     </None>
   </ItemGroup>
 
+  <ItemGroup> 
+    <Content Include="TestDocuments\**"> 
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> 
+    </Content> 
+  </ItemGroup>
+
   <ItemGroup Condition="'$(TargetFrameworkIdentifier)' != '.NETFramework'">
     <Compile Remove="CommandLineGenerator_Tests.cs" />
     <Compile Remove="XamlDataDrivenToolTask_Tests.cs" />
@@ -102,8 +108,6 @@
     <Compile Remove="ResourceHandling\GenerateResourceOutOfProc_Tests.cs" />
     <Compile Remove="ResourceHandling\ResGen_Tests.cs" />
     <Compile Remove="ResourceHandling\ResGenDependencies_Tests.cs" />
-    <Compile Remove="GetInstalledSDKLocations_Tests.cs" />
-    <Compile Remove="GetSDKReference_Tests.cs" />
     <Compile Remove="LC_Tests.cs" />
     <Compile Remove="MockTypeInfo.cs" />
     <Compile Remove="MockTypeLib.cs" />
@@ -124,7 +128,6 @@
     <Compile Remove="AssemblyDependency\VerifyTargetFrameworkHigherThanRedist.cs" />
     <Compile Remove="AssemblyDependency\WinMDTests.cs" />
     <Compile Remove="ResolveComReference_Tests.cs" />
-    <Compile Remove="ResolveSDKReference_Tests.cs" />
     <Compile Remove="SdkToolsPathUtility_Tests.cs" />
     <Compile Remove="TlbImp_Tests.cs" />
     <Compile Remove="VisualBasicParserUtilitites_Tests.cs" />
diff --git a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
index 8607667d3c3..8003c95c70a 100644
--- a/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
+++ b/src/Tasks.UnitTests/ResolveSDKReference_Tests.cs
@@ -20,6 +20,7 @@
 
 namespace Microsoft.Build.UnitTests.ResolveSDKReference_Tests
 {
+    [PlatformSpecific(TestPlatforms.Windows)]
     public class ResolveSDKReferenceTestFixture
     {
         private Microsoft.Build.UnitTests.MockEngine.GetStringDelegate _resourceDelegate = new Microsoft.Build.UnitTests.MockEngine.GetStringDelegate(AssemblyResources.GetString);
@@ -3701,6 +3702,7 @@ public void MultipleSupportedArchitectureDoesNotMatchProject()
     /// <summary>
     /// Test the output groups which will be used to generate the recipe fileGatherSDKOutputGroups
     /// </summary>
+    [PlatformSpecific(TestPlatforms.Windows)]
     public class GatherSDKOutputGroupsTestFixture
     {
         [Fact]
diff --git a/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/expected.proto b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/expected.proto
new file mode 100644
index 00000000000..7ae67b598cb
--- /dev/null
+++ b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/expected.proto
@@ -0,0 +1,32 @@
+syntax = "proto3";
+
+import "SiLAFramework.proto";
+
+package sila2.org.silastandard.examples.greetingprovider.v1;
+
+/* Example implementation of a minimum Feature. Provides a Greeting to the Client and a StartYear property, informing about the year the Server has been started. */
+service GreetingProvider {
+  /* Does what it says: returns "Hello SiLA 2 + [Name]" to the client. */
+  rpc SayHello (sila2.org.silastandard.examples.greetingprovider.v1.SayHello_Parameters) returns (sila2.org.silastandard.examples.greetingprovider.v1.SayHello_Responses) {}
+  /* Returns the year the SiLA Server has been started in. */
+  rpc Get_StartYear (sila2.org.silastandard.examples.greetingprovider.v1.Get_StartYear_Parameters) returns (sila2.org.silastandard.examples.greetingprovider.v1.Get_StartYear_Responses) {}
+}
+
+/* Parameters for SayHello */
+message SayHello_Parameters {
+  sila2.org.silastandard.String Name = 1;  /* The name, SayHello shall use to greet. */
+}
+
+/* Responses of SayHello */
+message SayHello_Responses {
+  sila2.org.silastandard.String Greeting = 1;  /* The greeting string, returned to the SiLA Client. */
+}
+
+/* Parameters for StartYear */
+message Get_StartYear_Parameters {
+}
+
+/* Responses of StartYear */
+message Get_StartYear_Responses {
+  sila2.org.silastandard.Integer StartYear = 1;  /* Returns the year the SiLA Server has been started in. */
+}
diff --git a/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl-validation.xsl b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl-validation.xsl
new file mode 100644
index 00000000000..1d8809b5bad
--- /dev/null
+++ b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl-validation.xsl
@@ -0,0 +1,455 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+                xmlns:sila="http://www.sila-standard.org"
+                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+                xsi:schemaLocation="http://www.sila-standard.org https://gitlab.com/SiLA2/sila_base/raw/master/schema/FeatureDefinition.xsd">
+    <xsl:output method="text" encoding="UTF-8" indent="no"/>
+
+    <xsl:template match="/sila:Feature">
+        <xsl:call-template name="detect-errors"/>
+    </xsl:template>
+
+    <xsl:template name="detect-errors">
+        <xsl:call-template name="detect-list-of-list"/>
+        <xsl:call-template name="detect-unknown-identifiers"/>
+        <xsl:call-template name="detect-invalid-constraint-base-type"/>
+        <xsl:call-template name="detect-invalid-constraint"/>
+        <xsl:call-template name="detect-duplicate-definitions"/>
+        <xsl:call-template name="detect-cyclic-references"/>
+        <xsl:call-template name="detect-invalid-sila2-version"/>
+        <xsl:call-template name="detect-invalid-constraint-values"/>
+        <xsl:call-template name="detect-intermediate-response-in-unobservable-command"/>
+    </xsl:template>
+
+    <xsl:template name="detect-list-of-list">
+        <xsl:for-each select="//sila:List">
+            <xsl:if test="./sila:DataType/sila:List">
+                <xsl:message terminate="yes">Nested lists are not allowed</xsl:message>
+            </xsl:if>
+        </xsl:for-each>
+    </xsl:template>
+
+    <xsl:template name="detect-unknown-identifiers">
+        <xsl:for-each select="//sila:DefinedExecutionErrors/sila:Identifier">
+            <xsl:if test="not(//sila:DefinedExecutionError/sila:Identifier/text() = ./text())">
+                <xsl:message terminate="yes">DefinedExecutionError '<xsl:value-of select="text()"/>' is not defined</xsl:message>
+            </xsl:if>
+        </xsl:for-each>
+        <xsl:for-each select="//sila:DataTypeIdentifier">
+            <xsl:if test="not(//sila:DataTypeDefinition/sila:Identifier/text() = ./text())">
+                <xsl:message terminate="yes">Data type identifier '<xsl:value-of select="text()"/>' is not defined</xsl:message>
+            </xsl:if>
+        </xsl:for-each>
+    </xsl:template>
+
+    <xsl:template name="detect-invalid-constraint-base-type">
+        <xsl:for-each select="//sila:Constrained">
+            <xsl:choose>
+                <xsl:when test="sila:DataType/sila:Structure">
+                    <xsl:message terminate="yes">Constrained structures are not allowed</xsl:message>
+                </xsl:when>
+                <xsl:when test="sila:DataType/sila:Constrained">
+                    <xsl:message terminate="yes">Constrained constrained types are not allowed</xsl:message>
+                </xsl:when>
+                <xsl:when test="sila:DataType/sila:DataTypeIdentifier">
+                    <xsl:message terminate="yes">Constrained data type identifiers are not allowed</xsl:message>
+                </xsl:when>
+                <xsl:when test="sila:DataType/sila:Basic/text() = 'Boolean'">
+                    <xsl:message terminate="yes">Constrained booleans are not allowed</xsl:message>
+                </xsl:when>
+            </xsl:choose>
+        </xsl:for-each>
+    </xsl:template>
+
+    <xsl:template name="detect-invalid-constraint">
+        <xsl:for-each select="//sila:Constrained">
+            <xsl:choose>
+                <xsl:when test="sila:DataType/sila:Basic/text() = 'String'">
+                    <xsl:for-each select="sila:Constraints/*">
+                        <xsl:if test="not(
+                                local-name() = 'Length'
+                                or local-name() = 'MinimalLength'
+                                or local-name() = 'MaximalLength'
+                                or local-name() = 'Pattern'
+                                or local-name() = 'ContentType'
+                                or local-name() = 'FullyQualifiedIdentifier'
+                                or local-name() = 'Schema'
+                                or local-name() = 'Set'
+                            )">
+                            <xsl:message terminate="yes">Invalid constraint on type String: '<xsl:value-of select="local-name()"/>'</xsl:message>
+                        </xsl:if>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="sila:DataType/sila:Basic/text() = 'Integer'">
+                    <xsl:for-each select="sila:Constraints/*">
+                        <xsl:if test="not(
+                                local-name() = 'Set'
+                                or local-name() = 'MaximalInclusive'
+                                or local-name() = 'MaximalExclusive'
+                                or local-name() = 'MinimalInclusive'
+                                or local-name() = 'MinimalExclusive'
+                                or local-name() = 'Unit'
+                            )">
+                            <xsl:message terminate="yes">Invalid constraint on type Integer: '<xsl:value-of select="local-name()"/>'</xsl:message>
+                        </xsl:if>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="sila:DataType/sila:Basic/text() = 'Real'">
+                    <xsl:for-each select="sila:Constraints/*">
+                        <xsl:if test="not(
+                                local-name() = 'Set'
+                                or local-name() = 'MaximalInclusive'
+                                or local-name() = 'MaximalExclusive'
+                                or local-name() = 'MinimalInclusive'
+                                or local-name() = 'MinimalExclusive'
+                                or local-name() = 'Unit'
+                            )">
+                            <xsl:message terminate="yes">Invalid constraint on type Real: '<xsl:value-of select="local-name()"/>'</xsl:message>
+                        </xsl:if>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="sila:DataType/sila:Basic/text() = 'Binary'">
+                    <xsl:for-each select="sila:Constraints/*">
+                        <xsl:if test="not(
+                                local-name() = 'Length'
+                                or local-name() = 'MinimalLength'
+                                or local-name() = 'MaximalLength'
+                                or local-name() = 'ContentType'
+                                or local-name() = 'Schema'
+                            )">
+                            <xsl:message terminate="yes">Invalid constraint on type Binary: '<xsl:value-of select="local-name()"/>'</xsl:message>
+                        </xsl:if>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="sila:DataType/sila:Basic/text() = 'Date'">
+                    <xsl:for-each select="sila:Constraints/*">
+                        <xsl:if test="not(
+                                local-name() = 'Set'
+                                or local-name() = 'MaximalInclusive'
+                                or local-name() = 'MaximalExclusive'
+                                or local-name() = 'MinimalInclusive'
+                                or local-name() = 'MinimalExclusive'
+                            )">
+                            <xsl:message terminate="yes">Invalid constraint on type Date: '<xsl:value-of select="local-name()"/>'</xsl:message>
+                        </xsl:if>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="sila:DataType/sila:Basic/text() = 'Time'">
+                    <xsl:for-each select="sila:Constraints/*">
+                        <xsl:if test="not(
+                                local-name() = 'Set'
+                                or local-name() = 'MaximalInclusive'
+                                or local-name() = 'MaximalExclusive'
+                                or local-name() = 'MinimalInclusive'
+                                or local-name() = 'MinimalExclusive'
+                            )">
+                            <xsl:message terminate="yes">Invalid constraint on type Time: '<xsl:value-of select="local-name()"/>'</xsl:message>
+                        </xsl:if>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="sila:DataType/sila:Basic/text() = 'Timestamp'">
+                    <xsl:for-each select="sila:Constraints/*">
+                        <xsl:if test="not(
+                                local-name() = 'Set'
+                                or local-name() = 'MaximalInclusive'
+                                or local-name() = 'MaximalExclusive'
+                                or local-name() = 'MinimalInclusive'
+                                or local-name() = 'MinimalExclusive'
+                            )">
+                            <xsl:message terminate="yes">Invalid constraint on type Timestamp: '<xsl:value-of select="local-name()"/>'</xsl:message>
+                        </xsl:if>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="sila:DataType/sila:Basic/text() = 'Any'">
+                    <xsl:for-each select="sila:Constraints/*">
+                        <xsl:if test="not(
+                                local-name() = 'AllowedTypes'
+                            )">
+                            <xsl:message terminate="yes">Invalid constraint on type Any: '<xsl:value-of select="local-name()"/>'</xsl:message>
+                        </xsl:if>
+                    </xsl:for-each>
+                </xsl:when>
+                <xsl:when test="sila:DataType/sila:List">
+                    <xsl:for-each select="sila:Constraints/*">
+                        <xsl:if test="not(
+                                local-name() = 'ElementCount'
+                                or local-name() = 'MinimalElementCount'
+                                or local-name() = 'MaximalElementCount'
+                            )">
+                            <xsl:message terminate="yes">Invalid constraint on type List: '<xsl:value-of select="local-name()"/>'</xsl:message>
+                        </xsl:if>
+                    </xsl:for-each>
+                </xsl:when>
+            </xsl:choose>
+        </xsl:for-each>
+    </xsl:template>
+
+    <xsl:template name="detect-duplicate-definitions">
+        <xsl:for-each select="//sila:DefinedExecutionError/sila:Identifier">
+            <xsl:variable name="current-id" select="."/>
+            <xsl:if test="count(//sila:DefinedExecutionError/sila:Identifier[text() = $current-id]) > 1">
+                <xsl:message terminate="yes">Execution error '<xsl:value-of select="."/>' is defined multiple times</xsl:message>
+            </xsl:if>
+        </xsl:for-each>
+        <xsl:for-each select="//sila:DataTypeDefinition/sila:Identifier/text()">
+            <xsl:variable name="current-id" select="."/>
+            <xsl:if test="count(//sila:DataTypeDefinition/sila:Identifier[text() = $current-id]) > 1">
+                <xsl:message terminate="yes">Data type '<xsl:value-of select="."/>' is defined multiple times</xsl:message>
+            </xsl:if>
+        </xsl:for-each>
+        <xsl:for-each select="//sila:Command/sila:Identifier/text()">
+            <xsl:variable name="current-id" select="."/>
+            <xsl:if test="count(//sila:Command/sila:Identifier[text() = $current-id]) > 1">
+                <xsl:message terminate="yes">Command '<xsl:value-of select="."/>' is defined multiple times</xsl:message>
+            </xsl:if>
+        </xsl:for-each>
+        <xsl:for-each select="//sila:Property/sila:Identifier/text()">
+            <xsl:variable name="current-id" select="."/>
+            <xsl:if test="count(//sila:Property/sila:Identifier[text() = $current-id]) > 1">
+                <xsl:message terminate="yes">Property '<xsl:value-of select="."/>' is defined multiple times</xsl:message>
+            </xsl:if>
+        </xsl:for-each>
+        <xsl:for-each select="//sila:Metadata/sila:Identifier/text()">
+            <xsl:variable name="current-id" select="."/>
+            <xsl:if test="count(//sila:Metadata/sila:Identifier[text() = $current-id]) > 1">
+                <xsl:message terminate="yes">Metadata '<xsl:value-of select="."/>' is defined multiple times</xsl:message>
+            </xsl:if>
+        </xsl:for-each>
+        <xsl:for-each select="//sila:Command">
+            <xsl:variable name="current-command" select="."/>
+            <xsl:for-each select="sila:Parameter/sila:Identifier/text()">
+                <xsl:variable name="current-id" select="."/>
+                <xsl:if test="count($current-command/sila:Parameter/sila:Identifier[text() = $current-id]) > 1">
+                    <xsl:message terminate="yes">Command '<xsl:value-of select="$current-command/sila:Identifier/text()"/>': parameter '<xsl:value-of select="."/>' is defined multiple times</xsl:message>
+                </xsl:if>
+            </xsl:for-each>
+            <xsl:for-each select="sila:IntermediateResponse/sila:Identifier/text()">
+                <xsl:variable name="current-id" select="."/>
+                <xsl:if test="count($current-command/sila:IntermediateResponse/sila:Identifier[text() = $current-id]) > 1">
+                    <xsl:message terminate="yes">Command '<xsl:value-of select="$current-command/sila:Identifier/text()"/>': intermediate response '<xsl:value-of select="."/>' is defined multiple times</xsl:message>
+                </xsl:if>
+            </xsl:for-each>
+            <xsl:for-each select="sila:Response/sila:Identifier/text()">
+                <xsl:variable name="current-id" select="."/>
+                <xsl:if test="count($current-command/sila:Response/sila:Identifier[text() = $current-id]) > 1">
+                    <xsl:message terminate="yes">Command '<xsl:value-of select="$current-command/sila:Identifier/text()"/>': response '<xsl:value-of select="."/>' is defined multiple times</xsl:message>
+                </xsl:if>
+            </xsl:for-each>
+            <xsl:for-each select="sila:DefinedExecutionErrors/sila:Identifier/text()">
+                <xsl:variable name="current-id" select="."/>
+                <xsl:if test="count($current-command/sila:DefinedExecutionErrors/sila:Identifier[text() = $current-id]) > 1">
+                    <xsl:message terminate="yes">Command '<xsl:value-of select="$current-command/sila:Identifier/text()"/>': execution error '<xsl:value-of select="."/>' is defined multiple times</xsl:message>
+                </xsl:if>
+            </xsl:for-each>
+        </xsl:for-each>
+    </xsl:template>
+
+    <xsl:template name="detect-cyclic-references">
+        <xsl:for-each select="//sila:DataTypeDefinition">
+            <xsl:variable name="outer-def" select="."/>
+            <xsl:variable name="outer-id" select="sila:Identifier/text()"/>
+            <xsl:for-each select="//sila:DataTypeDefinition">
+                <xsl:variable name="inner-def" select="."/>
+                <xsl:variable name="inner-id" select="sila:Identifier/text()"/>
+                <xsl:if test="($inner-id != $outer-id) and $inner-def/descendant::sila:DataTypeIdentifier[text() = $outer-id] and $outer-def/descendant::sila:DataTypeIdentifier[text() = $inner-id]">
+                    <xsl:message terminate="yes">Cyclic reference in data type definitions '<xsl:value-of select="$outer-id"/>' and '<xsl:value-of select="$inner-id"/>'</xsl:message>
+                </xsl:if>
+            </xsl:for-each>
+        </xsl:for-each>
+    </xsl:template>
+
+    <xsl:template name="detect-invalid-sila2-version">
+        <xsl:variable name="sila2-version" select="@SiLA2Version"/>
+        <xsl:if test="not ($sila2-version = '1.0' or $sila2-version = '1.1')">
+            <xsl:message terminate="yes">Invalid SiLA2 version: '<xsl:value-of select="$sila2-version"/>'</xsl:message>
+        </xsl:if>
+    </xsl:template>
+
+    <xsl:template name="detect-invalid-constraint-values">
+        <xsl:for-each select="//sila:Set/sila:Value | //sila:MaximalExclusive | //sila:MaximalInclusive | //sila:MinimalExclusive | //sila:MinimalInclusive">
+            <xsl:variable name="type" select="ancestor::sila:Constrained/sila:DataType/sila:Basic/text()"/>
+            <!-- Integer -->
+            <xsl:if test="$type = 'Integer' and local-name() = 'Value'">
+                <xsl:call-template name="validate-integer">
+                    <xsl:with-param name="value" select="text()"/>
+                </xsl:call-template>
+            </xsl:if>
+            <!-- Real -->
+            <xsl:if test="$type = 'Real' or ($type = 'Integer' and substring(local-name(), 1, 1) = 'M')">
+                <xsl:call-template name="validate-real">
+                    <xsl:with-param name="value" select="text()"/>
+                </xsl:call-template>
+            </xsl:if>
+            <!-- Date -->
+            <xsl:if test="$type = 'Date'">
+                <xsl:call-template name="validate-date">
+                    <xsl:with-param name="date" select="substring(text(), 1, 10)"/>
+                </xsl:call-template>
+                <xsl:call-template name="validate-timezone">
+                    <xsl:with-param name="timezone" select="substring(text(), 11)"/>
+                </xsl:call-template>
+            </xsl:if>
+            <!-- Time -->
+            <xsl:if test="$type = 'Time'">
+                <xsl:call-template name="validate-time">
+                    <xsl:with-param name="time" select="substring(text(), 1, 8)"/>
+                </xsl:call-template>
+                <xsl:call-template name="validate-timezone">
+                    <xsl:with-param name="timezone" select="substring(text(), 9)"/>
+                </xsl:call-template>
+            </xsl:if>
+            <!-- Timestamp -->
+            <xsl:if test="$type = 'Timestamp'">
+                <xsl:call-template name="validate-date">
+                    <xsl:with-param name="date" select="substring(text(), 1, 10)"/>
+                </xsl:call-template>
+                <xsl:if test="substring(text(), 11, 1) != 'T'">
+                    <xsl:message terminate="yes">Invalid Timestamp: 11th character must be 'T'</xsl:message>
+                </xsl:if>
+                <xsl:call-template name="validate-time">
+                    <xsl:with-param name="time" select="substring(text(), 12, 8)"/>
+                </xsl:call-template>
+                <xsl:call-template name="validate-timezone">
+                    <xsl:with-param name="timezone" select="substring(text(), 20)"/>
+                </xsl:call-template>
+            </xsl:if>
+        </xsl:for-each>
+        <xsl:for-each select="//sila:AllowedTypes//sila:DataTypeIdentifier">
+            <xsl:message terminate="yes">DataTypeIdentifier is not allowed in AllowedTypes</xsl:message>
+        </xsl:for-each>
+    </xsl:template>
+
+    <xsl:template name="validate-integer">
+        <xsl:param name="value"/>
+
+        <xsl:if test="not(string-length($value) > 0 and concat(translate(substring($value, 1, 1), '+-0123456789', ''), translate(substring($value, 2), '0123456789', '')) = '')">
+            <xsl:message terminate="yes">Not an integer value: '<xsl:value-of select="$value"/>'</xsl:message>
+        </xsl:if>
+    </xsl:template>
+
+    <xsl:template name="validate-real">
+        <xsl:param name="value"/>
+
+        <xsl:choose>
+            <xsl:when test="$value = 'INF' or $value = '-INF' or $value = '+INF' or $value = 'NaN'"/>
+            <xsl:when test="contains($value, 'e') or contains($value, 'E')">
+                <xsl:variable name="lowercase-value" select="translate($value, 'E', 'e')"/>
+                <xsl:call-template name="validate-float">
+                    <xsl:with-param name="value" select="substring-before($lowercase-value, 'e')"/>
+                </xsl:call-template>
+                <xsl:call-template name="validate-integer">
+                    <xsl:with-param name="value" select="substring-after($lowercase-value, 'e')"/>
+                </xsl:call-template>
+            </xsl:when>
+            <xsl:otherwise>
+                <xsl:call-template name="validate-float">
+                    <xsl:with-param name="value" select="$value"/>
+                </xsl:call-template>
+            </xsl:otherwise>
+        </xsl:choose>
+
+    </xsl:template>
+
+    <xsl:template name="validate-float">
+        <xsl:param name="value"/>
+
+        <!-- first character is in '+-.0123456789' and rest is in '.0123456789' -->
+        <xsl:if test="translate(substring($value, 1, 1), '+-.0123456789', '') != '' or translate(substring($value, 2), '.0123456789', '') != ''">
+            <xsl:message terminate="yes">Not a decimal value: '<xsl:value-of select="$value"/>'</xsl:message>
+        </xsl:if>
+        <!-- only '0123456789' is allowed after the first '.' -->
+        <xsl:if test="contains($value, '.') and translate(substring-after($value, '.'), '0123456789', '') != ''">
+            <xsl:message terminate="yes">Not a decimal value: '<xsl:value-of select="$value"/>'</xsl:message>
+        </xsl:if>
+    </xsl:template>
+
+    <xsl:template name="validate-timezone">
+        <xsl:param name="timezone"/>
+        <!-- Z -->
+        <xsl:if test="$timezone != 'Z'">
+            <!-- 6 chars -->
+            <xsl:if test="string-length($timezone) != 6">
+                <xsl:message terminate="yes">Invalid Timezone format: Must be 'Z' or '+HH:MM' or '-HH:MM', was '<xsl:value-of select="$timezone"/>'</xsl:message>
+            </xsl:if>
+            <!-- char 1 is + or - -->
+            <xsl:if test="not(contains('+-', substring($timezone, 1, 1)))">
+                <xsl:message terminate="yes">Invalid Timezone format: Must be 'Z' or '+HH:MM' or '-HH:MM', was '<xsl:value-of select="$timezone"/>'</xsl:message>
+            </xsl:if>
+            <!-- chars 2, 3, 5 and 6 are numbers - -->
+            <xsl:if test="not(translate(concat(substring($timezone, 2, 2), substring($timezone, 5, 2)), '0123456789', '') = '')">
+                <xsl:message terminate="yes">Invalid Timezone format: Must be 'Z' or '+HH:MM' or '-HH:MM', was '<xsl:value-of select="$timezone"/>'</xsl:message>
+            </xsl:if>
+            <!-- char 4 is : -->
+            <xsl:if test="not(substring($timezone, 4, 1) = ':')">
+                <xsl:message terminate="yes">Invalid Timezone format: Must be 'Z' or '+HH:MM' or '-HH:MM', was '<xsl:value-of select="$timezone"/>'</xsl:message>
+            </xsl:if>
+            <xsl:variable name="hour" select="number(substring($timezone, 2, 2))"/>
+            <xsl:variable name="minute" select="number(substring($timezone, 5, 2))"/>
+            <xsl:if test="0 > $minute or $minute > 59 or 0 > $hour">
+                <xsl:message terminate="yes">Invalid Timezone format: Minute must be in range 00-59, was '<xsl:value-of select="$timezone"/>'</xsl:message>
+            </xsl:if>
+            <xsl:if test="$minute + $hour * 60 > 840">
+                <xsl:message terminate="yes">Invalid Timezone format: Must be in range -14:00 to +14:00, was '<xsl:value-of select="$timezone"/>'</xsl:message>
+            </xsl:if>
+        </xsl:if>
+    </xsl:template>
+
+    <xsl:template name="validate-date">
+        <xsl:param name="date"/>
+        <xsl:if test="string-length($date) != 10">
+            <xsl:message terminate="yes">Invalid Date format: Must be 'YYYY-MM-DD', was '<xsl:value-of select="$date"/>'</xsl:message>
+        </xsl:if>
+        <xsl:if test="translate(concat(substring($date, 1, 4), substring($date, 6, 2), substring($date, 9, 2)), '0123456789', '') != ''">
+            <xsl:message terminate="yes">Invalid Date format: Must be 'YYYY-MM-DD', was '<xsl:value-of select="$date"/>'</xsl:message>
+        </xsl:if>
+        <xsl:if test="concat(substring($date, 5, 1), substring($date, 8, 1)) != '--'">
+            <xsl:message terminate="yes">Invalid Date format: Must be 'YYYY-MM-DD', was '<xsl:value-of select="$date"/>'</xsl:message>
+        </xsl:if>
+        <xsl:variable name="year" select="number(substring($date, 1, 4))"/>
+        <xsl:variable name="month" select="number(substring($date, 6, 2))"/>
+        <xsl:variable name="day" select="number(substring($date, 9, 2))"/>
+        <xsl:if test="$month > 12 or $day > 31">
+            <xsl:message terminate="yes">Invalid Date format: Must be 'YYYY-MM-DD' (month or day out of range), was '<xsl:value-of select="$date"/>'</xsl:message>
+        </xsl:if>
+        <xsl:if test="($month = 4 or $month = 6 or $month = 9 or $month = 11) and $day > 30">
+            <xsl:message terminate="yes">Invalid Date format: Must be 'YYYY-MM-DD' (day out of range), was '<xsl:value-of select="$date"/>'</xsl:message>
+        </xsl:if>
+        <xsl:if test="$month = 2">
+            <xsl:if test="$day > 29">
+                <xsl:message terminate="yes">Invalid Date format: Must be 'YYYY-MM-DD' (day out of range), was '<xsl:value-of select="$date"/>'</xsl:message>
+            </xsl:if>
+            <xsl:if test="$year mod 4 != 0 and $day > 28">
+                <xsl:message terminate="yes">Invalid Date format: Must be 'YYYY-MM-DD' (day out of range), was '<xsl:value-of select="$date"/>'</xsl:message>
+            </xsl:if>
+            <xsl:if test="$year mod 100 = 0 and $year mod 400 != 0 and $day > 28">
+                <xsl:message terminate="yes">Invalid Date format: Must be 'YYYY-MM-DD' (day out of range), was '<xsl:value-of select="$date"/>'</xsl:message>
+            </xsl:if>
+        </xsl:if>
+    </xsl:template>
+
+    <xsl:template name="validate-time">
+        <xsl:param name="time"/>
+        <xsl:if test="string-length($time) != 8">
+            <xsl:message terminate="yes">Invalid Date format: Must be 'HH:MM:SS', was '<xsl:value-of select="$time"/>'</xsl:message>
+        </xsl:if>
+        <xsl:if test="translate(concat(substring($time, 1, 2), substring($time, 4, 2), substring($time, 7, 2)), '0123456789', '') != ''">
+            <xsl:message terminate="yes">Invalid Date format: Must be 'HH:MM:SS', was '<xsl:value-of select="$time"/>'</xsl:message>
+        </xsl:if>
+        <xsl:if test="concat(substring($time, 3, 1), substring($time, 6, 1)) != '::'">
+            <xsl:message terminate="yes">Invalid Date format: Must be 'HH:MM:SS', was '<xsl:value-of select="$time"/>'</xsl:message>
+        </xsl:if>
+        <xsl:variable name="hour" select="number(substring($time, 1, 2))"/>
+        <xsl:variable name="minute" select="number(substring($time, 4, 2))"/>
+        <xsl:variable name="second" select="number(substring($time, 7, 2))"/>
+        <xsl:if test="$hour > 23 or $minute > 59 or $second > 59">
+            <xsl:message terminate="yes">Invalid Date format: Must be 'HH:MM:SS' (hour, minute or seconds out of range), was '<xsl:value-of select="$time"/>'</xsl:message>
+        </xsl:if>
+    </xsl:template>
+
+    <xsl:template name="detect-intermediate-response-in-unobservable-command">
+        <xsl:for-each select="//sila:Command[sila:Observable/text() = 'No']/sila:IntermediateResponse">
+            <xsl:message terminate="yes">Unobservable commands must not have intermediate responses</xsl:message>
+        </xsl:for-each>
+    </xsl:template>
+</xsl:stylesheet>
diff --git a/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl2proto-messages.xsl b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl2proto-messages.xsl
new file mode 100644
index 00000000000..c496631403c
--- /dev/null
+++ b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl2proto-messages.xsl
@@ -0,0 +1,202 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+                xmlns:sila="http://www.sila-standard.org"
+                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+                xsi:schemaLocation="http://www.sila-standard.org https://gitlab.com/SiLA2/sila_base/raw/master/schema/FeatureDefinition.xsd">
+    <xsl:output method="text" encoding="UTF-8" indent="no"/>
+    
+    <xsl:template name="generate-message">
+        <xsl:param name="feature-package"/>
+        <xsl:param name="parent-package"/>
+        <xsl:param name="message-name"/>
+        <xsl:param name="data-nodes"/>
+        <xsl:param name="indent-level" select="0"/>
+
+        <xsl:call-template name="indent"><xsl:with-param name="level" select="$indent-level"/></xsl:call-template>
+        <xsl:text>message </xsl:text><xsl:value-of select="$message-name"/><xsl:text> {</xsl:text>
+        <xsl:call-template name="newline"/>
+            <!-- generate messages for structure types -->
+            <xsl:for-each select="$data-nodes">
+                <xsl:if test="sila:DataType/sila:Structure">
+                    <xsl:call-template name="generate-message">
+                        <xsl:with-param name="message-name" select="concat(sila:Identifier, '_Struct')"/>
+                        <xsl:with-param name="data-nodes" select="sila:DataType/sila:Structure/sila:Element"/>
+                        <xsl:with-param name="feature-package" select="$feature-package"/>
+                        <xsl:with-param name="parent-package" select="concat($parent-package, '.', sila:Identifier, '_Struct')"/>
+                        <xsl:with-param name="indent-level" select="$indent-level + 1"/>
+                    </xsl:call-template>
+                </xsl:if>
+                <xsl:if test="sila:DataType/sila:List/sila:DataType/sila:Structure">
+                    <xsl:call-template name="generate-message">
+                        <xsl:with-param name="message-name" select="concat(sila:Identifier, '_Struct')"/>
+                        <xsl:with-param name="data-nodes" select="sila:DataType/sila:List/sila:DataType/sila:Structure/sila:Element"/>
+                        <xsl:with-param name="feature-package" select="$feature-package"/>
+                        <xsl:with-param name="parent-package" select="concat($parent-package, '.', sila:Identifier, '_Struct')"/>
+                        <xsl:with-param name="indent-level" select="$indent-level + 1"/>
+                    </xsl:call-template>
+                </xsl:if>
+            </xsl:for-each>
+        
+            <!-- generate entry for each message member -->
+            <xsl:for-each select="$data-nodes">
+                <xsl:call-template name="indent"><xsl:with-param name="level" select="$indent-level + 1"/></xsl:call-template>
+                <xsl:call-template name="generate-message-entry">
+                    <xsl:with-param name="parent-package" select="concat($parent-package, '.', sila:Identifier, '_Struct')"/>
+                    <xsl:with-param name="feature-package" select="$feature-package"/>
+                    <xsl:with-param name="datatype" select="sila:DataType"/>
+                    <xsl:with-param name="identifier" select="sila:Identifier"/>
+                </xsl:call-template> = <xsl:value-of select="position()"/>;  /* <xsl:value-of select="normalize-space(sila:Description)"/><xsl:text> */</xsl:text>
+                <xsl:call-template name="newline"/>
+            </xsl:for-each>
+        <xsl:call-template name="indent"><xsl:with-param name="level" select="$indent-level"/></xsl:call-template>
+        <xsl:text>}</xsl:text>
+        <xsl:call-template name="newline"/>
+    </xsl:template>
+
+    <!-- Message for data type definitions -->
+    <xsl:template match="sila:DataTypeDefinition">
+        <xsl:param name="package"/>
+
+        <xsl:call-template name="newline"/>
+        <xsl:text>/* </xsl:text><xsl:value-of select="sila:Description"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:call-template name="generate-message">
+            <xsl:with-param name="message-name" select="concat('DataType_', sila:Identifier)"/>
+            <xsl:with-param name="data-nodes" select="."/>
+            <xsl:with-param name="feature-package" select="$package"/>
+            <xsl:with-param name="parent-package" select="concat($package, '.', 'DataType_', sila:Identifier)"/>
+        </xsl:call-template>
+    </xsl:template>
+
+    <!-- Message for commands -->
+    <xsl:template match="sila:Command" mode="message">
+        <xsl:param name="package"/>
+
+        <xsl:call-template name="newline"/>
+        <xsl:text>/* Parameters for </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:call-template name="generate-message">
+            <xsl:with-param name="message-name" select="concat(sila:Identifier, '_Parameters')"/>
+            <xsl:with-param name="data-nodes" select="sila:Parameter"/>
+            <xsl:with-param name="feature-package" select="$package"/>
+            <xsl:with-param name="parent-package" select="concat($package, '.', sila:Identifier, '_Parameters')"/>
+        </xsl:call-template>
+
+        <xsl:call-template name="newline"/>
+        <xsl:text>/* Responses of </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:call-template name="generate-message">
+            <xsl:with-param name="message-name" select="concat(sila:Identifier, '_Responses')"/>
+            <xsl:with-param name="data-nodes" select="sila:Response"/>
+            <xsl:with-param name="feature-package" select="$package"/>
+            <xsl:with-param name="parent-package" select="concat($package, '.', sila:Identifier, '_Responses')"/>
+        </xsl:call-template>
+
+        <xsl:if test="sila:IntermediateResponse">
+            <xsl:call-template name="newline"/>
+            <xsl:text>/* Intermediate responses of </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+            <xsl:call-template name="newline"/>
+            <xsl:call-template name="generate-message">
+                <xsl:with-param name="message-name" select="concat(sila:Identifier, '_IntermediateResponses')"/>
+                <xsl:with-param name="data-nodes" select="sila:IntermediateResponse"/>
+                <xsl:with-param name="feature-package" select="$package"/>
+                <xsl:with-param name="parent-package" select="concat($package, '.', sila:Identifier, '_IntermediateResponses')"/>
+            </xsl:call-template>
+        </xsl:if>
+    </xsl:template>
+
+    <!-- Message for properties -->
+    <xsl:template match="sila:Property" mode="message">
+        <xsl:param name="package"/>
+        <xsl:variable name="property-name">
+            <xsl:call-template name="PropertyName"/>
+        </xsl:variable>
+
+        <xsl:call-template name="newline"/>
+        <xsl:text>/* Parameters for </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>message </xsl:text><xsl:value-of select="concat($property-name, '_Parameters')"/><xsl:text> {</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>}</xsl:text>
+        <xsl:call-template name="newline"/>
+
+        <xsl:call-template name="newline"/>
+        <xsl:text>/* Responses of </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:call-template name="generate-message">
+            <xsl:with-param name="message-name" select="concat($property-name, '_Responses')"/>
+            <xsl:with-param name="data-nodes" select="."/>
+            <xsl:with-param name="feature-package" select="$package"/>
+            <xsl:with-param name="parent-package" select="concat($package, '.', $property-name, '_Responses')"/>
+        </xsl:call-template>
+    </xsl:template>
+
+    <!-- Message for metadata -->
+    <xsl:template match="sila:Metadata" mode="message">
+        <xsl:param name="package"/>
+
+        <xsl:call-template name="newline"/>
+        <xsl:text>/* Parameters for Get_FCPAffectedByMetadata_</xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>message Get_FCPAffectedByMetadata_</xsl:text><xsl:value-of select="concat(sila:Identifier, '_Parameters')"/><xsl:text> {</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>}</xsl:text>
+        <xsl:call-template name="newline"/>
+
+        <xsl:call-template name="newline"/>
+        <xsl:text>/* Responses of Get_FCPAffectedByMetadata_</xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>message Get_FCPAffectedByMetadata_</xsl:text><xsl:value-of select="concat(sila:Identifier, '_Responses')"/><xsl:text> {</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>  repeated sila2.org.silastandard.String AffectedCalls = 1;  /* Fully qualified identifiers of all features, commands and properties affected by </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>}</xsl:text>
+        <xsl:call-template name="newline"/>
+
+        <xsl:call-template name="newline"/>
+        <xsl:text>/* </xsl:text><xsl:value-of select="sila:Description"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:call-template name="generate-message">
+            <xsl:with-param name="message-name" select="concat('Metadata_', sila:Identifier)"/>
+            <xsl:with-param name="data-nodes" select="."/>
+            <xsl:with-param name="feature-package" select="$package"/>
+            <xsl:with-param name="parent-package" select="concat($package, '.', 'Metadata_', sila:Identifier)"/>
+        </xsl:call-template>
+    </xsl:template>
+
+    <!-- Message entry -->
+    <xsl:template name="generate-message-entry">
+        <xsl:param name="feature-package"/>
+        <xsl:param name="parent-package"/>
+        <xsl:param name="identifier"/>
+        <xsl:param name="datatype"/>
+        <xsl:choose>
+            <xsl:when test="$datatype/sila:Basic">
+                <xsl:text>sila2.org.silastandard.</xsl:text><xsl:value-of select="$datatype/sila:Basic"/><xsl:text> </xsl:text><xsl:value-of select="$identifier"/>
+            </xsl:when>
+            <xsl:when test="$datatype/sila:Constrained">
+                <xsl:call-template name="generate-message-entry">
+                    <xsl:with-param name="feature-package" select="$feature-package"/>
+                    <xsl:with-param name="parent-package" select="$parent-package"/>
+                    <xsl:with-param name="identifier" select="sila:Identifier"/>
+                    <xsl:with-param name="datatype" select="$datatype/sila:Constrained/sila:DataType"/>
+                </xsl:call-template>
+            </xsl:when>
+            <xsl:when test="$datatype/sila:List">
+                <xsl:text>repeated </xsl:text><xsl:call-template name="generate-message-entry">
+                    <xsl:with-param name="feature-package" select="$feature-package"/>
+                    <xsl:with-param name="parent-package" select="$parent-package"/>
+                    <xsl:with-param name="identifier" select="sila:Identifier"/>
+                    <xsl:with-param name="datatype" select="$datatype/sila:List/sila:DataType"/>
+                </xsl:call-template>
+            </xsl:when>
+            <xsl:when test="$datatype/sila:DataTypeIdentifier">
+                <xsl:value-of select="$feature-package"/>.DataType_<xsl:value-of select="$datatype/sila:DataTypeIdentifier"/><xsl:text> </xsl:text><xsl:value-of select="$identifier"/>
+            </xsl:when>
+            <xsl:when test="$datatype/sila:Structure">
+                <xsl:value-of select="$parent-package"/><xsl:text> </xsl:text><xsl:value-of select="$identifier"/>
+            </xsl:when>
+        </xsl:choose>
+    </xsl:template>
+</xsl:stylesheet>
diff --git a/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl2proto-service.xsl b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl2proto-service.xsl
new file mode 100644
index 00000000000..ce200bc93c3
--- /dev/null
+++ b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl2proto-service.xsl
@@ -0,0 +1,83 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+                xmlns:sila="http://www.sila-standard.org"
+                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+                xsi:schemaLocation="http://www.sila-standard.org https://gitlab.com/SiLA2/sila_base/raw/master/schema/FeatureDefinition.xsd">
+    <xsl:output method="text" encoding="UTF-8" indent="no"/>
+
+    <!-- Service body for commands -->
+    <xsl:template match="sila:Command" mode="service">
+        <xsl:param name="package"/>
+        <xsl:choose>
+            <xsl:when test="sila:Observable = 'No'">
+                <xsl:call-template name="ServiceCommandUnobservable">
+                    <xsl:with-param name="package" select="$package"/>
+                </xsl:call-template>
+            </xsl:when>
+            <xsl:when test="sila:Observable = 'Yes'">
+                <xsl:call-template name="ServiceCommandObservable">
+                    <xsl:with-param name="package" select="$package"/>
+                </xsl:call-template>
+            </xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+    <!-- Service body for unobservable commands -->
+    <xsl:template name="ServiceCommandUnobservable">
+        <xsl:param name="package"/>
+        <xsl:text>  /* </xsl:text> <xsl:value-of select="normalize-space(sila:Description)"/> <xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>  rpc </xsl:text> <xsl:value-of select="sila:Identifier"/> <xsl:text> (</xsl:text>
+        <xsl:value-of select="$package"/>.<xsl:value-of select="sila:Identifier"/><xsl:text>_Parameters</xsl:text>
+        <xsl:text>) returns (</xsl:text>
+        <xsl:value-of select="$package"/>.<xsl:value-of select="sila:Identifier"/><xsl:text>_Responses</xsl:text>
+        <xsl:text>) {}</xsl:text>
+        <xsl:call-template name="newline"/>
+    </xsl:template>
+
+    <!-- Service body for observable commands -->
+    <xsl:template name="ServiceCommandObservable">
+        <xsl:param name="package"/>
+        <xsl:text>  /* </xsl:text><xsl:value-of select="sila:Description"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>  rpc </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> (</xsl:text><xsl:value-of select="$package"/>.<xsl:value-of select="sila:Identifier"/><xsl:text>_Parameters) returns (sila2.org.silastandard.CommandConfirmation) {}</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>  /* Monitor the state of </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>  rpc </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text>_Info (sila2.org.silastandard.CommandExecutionUUID) returns (stream sila2.org.silastandard.ExecutionInfo) {}</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:if test="sila:IntermediateResponse">
+            <xsl:text>  /* Retrieve intermediate responses of </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+            <xsl:call-template name="newline"/>
+            <xsl:text>  rpc </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text>_Intermediate (sila2.org.silastandard.CommandExecutionUUID) returns (stream </xsl:text><xsl:value-of select="$package"/>.<xsl:value-of select="sila:Identifier"/><xsl:text>_IntermediateResponses) {}</xsl:text>
+            <xsl:call-template name="newline"/>
+        </xsl:if>
+        <xsl:text>  /* Retrieve result of </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>  rpc </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text>_Result(sila2.org.silastandard.CommandExecutionUUID) returns (</xsl:text><xsl:value-of select="$package"/>.<xsl:value-of select="sila:Identifier"/><xsl:text>_Responses) {}</xsl:text>
+        <xsl:call-template name="newline"/>
+    </xsl:template>
+
+    <!-- Service body for properties -->
+    <xsl:template match="sila:Property" mode="service">
+        <xsl:param name="package"/>
+        <xsl:text>  /* </xsl:text><xsl:value-of select="sila:Description"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>  rpc </xsl:text> <xsl:call-template name="PropertyName"/>
+        <xsl:text> (</xsl:text> <xsl:value-of select="$package"/>.<xsl:call-template name="PropertyName"/><xsl:text>_Parameters</xsl:text>
+        <xsl:text>) returns (</xsl:text><xsl:if test="sila:Observable = 'Yes'">stream </xsl:if><xsl:value-of select="$package"/>.<xsl:call-template name="PropertyName"/><xsl:text>_Responses) {}</xsl:text>
+        <xsl:call-template name="newline"/>
+    </xsl:template>
+
+    <!-- Service body for metadata -->
+    <xsl:template match="sila:Metadata" mode="service">
+        <xsl:param name="package"/>
+        <xsl:text>  /* Get fully qualified identifiers of all features, commands and properties affected by </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>  rpc Get_FCPAffectedByMetadata_</xsl:text><xsl:value-of select="sila:Identifier"/>
+        <xsl:text> (</xsl:text><xsl:value-of select="$package"/>.Get_FCPAffectedByMetadata_<xsl:value-of select="sila:Identifier"/><xsl:text>_Parameters</xsl:text>
+        <xsl:text>) returns (</xsl:text><xsl:value-of select="$package"/>.Get_FCPAffectedByMetadata_<xsl:value-of select="sila:Identifier"/><xsl:text>_Responses) {}</xsl:text>
+        <xsl:call-template name="newline"/>
+    </xsl:template>
+</xsl:stylesheet>
diff --git a/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl2proto.xsl b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl2proto.xsl
new file mode 100644
index 00000000000..6d9ddcd99cf
--- /dev/null
+++ b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/fdl2proto.xsl
@@ -0,0 +1,101 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0"
+                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+                xmlns:sila="http://www.sila-standard.org"
+                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+                xsi:schemaLocation="http://www.sila-standard.org https://gitlab.com/SiLA2/sila_base/raw/master/schema/FeatureDefinition.xsd">
+    <xsl:import href="fdl2proto-service.xsl"/>
+    <xsl:import href="fdl2proto-messages.xsl"/>
+    <xsl:import href="fdl-validation.xsl"/>
+    <xsl:output method="text" encoding="UTF-8"/>
+
+    <!-- Root template -->
+    <xsl:template match="/sila:Feature">
+        <!-- Package identifier, e.g. 'sila2.org.silastandard.examples.greetingprovider.v1' -->
+        <xsl:param name="category">
+            <xsl:choose>
+                <xsl:when test="@Category">
+                    <xsl:value-of select="@Category"/>
+                </xsl:when>
+                <xsl:otherwise>
+                    <xsl:text>none</xsl:text>
+                </xsl:otherwise>
+            </xsl:choose>
+        </xsl:param>
+        <xsl:param name="package">sila2.<xsl:value-of select="@Originator"/>.<xsl:value-of select="$category"/>.<xsl:value-of select="translate(sila:Identifier, 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz')"/>.v<xsl:value-of select="substring-before(@FeatureVersion, '.')"/></xsl:param>
+        <xsl:call-template name="detect-errors"/>
+
+        <!-- declare syntax version -->
+        <text>syntax = "proto3";</text>
+        <xsl:call-template name="newline"/>
+        <xsl:call-template name="newline"/>
+
+        <!-- import SiLAFramework -->
+        <xsl:if test="//sila:Basic | //sila:Metadata | //sila:Command[sila:Observable = 'Yes']">
+            <xsl:text>import "SiLAFramework.proto";</xsl:text>
+            <xsl:call-template name="newline"/>
+            <xsl:call-template name="newline"/>
+        </xsl:if>
+
+        <!-- package -->
+        <xsl:text>package </xsl:text><xsl:value-of select="$package"/><xsl:text>;</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:call-template name="newline"/>
+
+        <!-- service and rpc declaration -->
+        <xsl:text>/* </xsl:text>
+            <xsl:value-of select="normalize-space(sila:Description)"/>
+        <xsl:text> */</xsl:text>
+        <xsl:call-template name="newline"/>
+        <xsl:text>service </xsl:text><xsl:value-of select="sila:Identifier"/><xsl:text> {</xsl:text>
+        <xsl:call-template name="newline"/>
+            <xsl:apply-templates select="sila:Command" mode="service">
+                <xsl:with-param name="package" select="$package"/>
+            </xsl:apply-templates>
+            <xsl:apply-templates select="sila:Property" mode="service">
+                <xsl:with-param name="package" select="$package"/>
+            </xsl:apply-templates>
+            <xsl:apply-templates select="sila:Metadata" mode="service">
+                <xsl:with-param name="package" select="$package"/>
+            </xsl:apply-templates>
+        <xsl:text>}</xsl:text>
+
+        <xsl:call-template name="newline"/>
+
+        <xsl:apply-templates select="sila:DataTypeDefinition">
+            <xsl:with-param name="package" select="$package"/>
+        </xsl:apply-templates>
+
+        <xsl:apply-templates select="sila:Command" mode="message">
+            <xsl:with-param name="package" select="$package"/>
+        </xsl:apply-templates>
+
+        <xsl:apply-templates select="sila:Property" mode="message">
+            <xsl:with-param name="package" select="$package"/>
+        </xsl:apply-templates>
+
+        <xsl:apply-templates select="sila:Metadata" mode="message">
+            <xsl:with-param name="package" select="$package"/>
+        </xsl:apply-templates>
+    </xsl:template>
+
+    <!-- Input node: sila:Property; returns name of property, depending on observability (prefix Get_ or Subscribe_) -->
+    <xsl:template name="PropertyName">
+        <xsl:choose>
+            <xsl:when test="sila:Observable = 'No'">Get_<xsl:value-of select="sila:Identifier"/></xsl:when>
+            <xsl:when test="sila:Observable = 'Yes'">Subscribe_<xsl:value-of select="sila:Identifier"/></xsl:when>
+        </xsl:choose>
+    </xsl:template>
+
+    <xsl:template name="newline">
+        <xsl:text>&#xa;</xsl:text>
+    </xsl:template>
+
+    <xsl:template name="indent">
+        <xsl:param name="level"/>
+        <xsl:if test="$level > 0">
+            <xsl:text>  </xsl:text>
+            <xsl:call-template name="indent"><xsl:with-param name="level" select="$level - 1"/></xsl:call-template>
+        </xsl:if>
+    </xsl:template>
+</xsl:stylesheet>
diff --git a/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/sila.xml b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/sila.xml
new file mode 100644
index 00000000000..cf9e71ecd1c
--- /dev/null
+++ b/src/Tasks.UnitTests/TestDocuments/Fdl2Proto/sila.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="utf-8" ?>
+<Feature SiLA2Version="1.0" FeatureVersion="1.0" MaturityLevel="Verified" Originator="org.silastandard"
+         Category="examples"
+         xmlns="http://www.sila-standard.org"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://www.sila-standard.org https://gitlab.com/SiLA2/sila_base/raw/master/schema/FeatureDefinition.xsd">
+  <Identifier>GreetingProvider</Identifier>
+  <DisplayName>Greeting Provider</DisplayName>
+  <Description>
+    Example implementation of a minimum Feature. Provides a Greeting to the Client
+    and a StartYear property, informing about the year the Server has been started.
+  </Description>
+  <Command>
+    <Identifier>SayHello</Identifier>
+    <DisplayName>Say Hello</DisplayName>
+    <Description>Does what it says: returns "Hello SiLA 2 + [Name]" to the client.</Description>
+    <Observable>No</Observable>
+    <Parameter>
+      <Identifier>Name</Identifier>
+      <DisplayName>Name</DisplayName>
+      <Description>The name, SayHello shall use to greet.</Description>
+      <DataType>
+        <Basic>String</Basic>
+      </DataType>
+    </Parameter>
+    <Response>
+      <Identifier>Greeting</Identifier>
+      <DisplayName>Greeting</DisplayName>
+      <Description>The greeting string, returned to the SiLA Client.</Description>
+      <DataType>
+        <Basic>String</Basic>
+      </DataType>
+    </Response>
+  </Command>
+  <Property>
+    <Identifier>StartYear</Identifier>
+    <DisplayName>Start Year</DisplayName>
+    <Description>Returns the year the SiLA Server has been started in.</Description>
+    <Observable>No</Observable>
+    <DataType>
+      <Basic>Integer</Basic>
+    </DataType>
+  </Property>
+</Feature>
\ No newline at end of file
diff --git a/src/Tasks.UnitTests/XslTransformation_Tests.cs b/src/Tasks.UnitTests/XslTransformation_Tests.cs
index 467ebc482cb..8241951081a 100644
--- a/src/Tasks.UnitTests/XslTransformation_Tests.cs
+++ b/src/Tasks.UnitTests/XslTransformation_Tests.cs
@@ -66,6 +66,8 @@ sealed public class XslTransformation_Tests
         /// The contents of xsl document for tests.
         /// </summary>
         private readonly string _xslDocument = "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:msxsl=\"urn:schemas-microsoft-com:xslt\" exclude-result-prefixes=\"msxsl\"><xsl:output method=\"xml\" indent=\"yes\"/><xsl:template match=\"@* | node()\"><surround><xsl:copy><xsl:apply-templates select=\"@* | node()\"/></xsl:copy></surround></xsl:template></xsl:stylesheet>";
+
+
 #if FEATURE_COMPILED_XSL
         /// <summary>
         /// The contents of another xsl document for tests
@@ -848,6 +850,55 @@ public void XsltDocumentThrowsError()
             CleanUp(dir);
         }
 
+        /// <summary>
+        /// Xslt PreserveWhitespace = true
+        /// </summary>
+        [Fact]
+        public void XsltPreserveWhitespace()
+        {
+            string dir;
+            TaskItem[] xmlPaths;
+            TaskItem xslPath;
+            TaskItem[] outputPaths;
+            MockEngine engine;
+
+            Prepare(out dir, out _, out _, out _, out outputPaths, out _, out _, out engine);
+
+            var testingDocsDir = Path.Combine("TestDocuments", "Fdl2Proto");
+
+            xmlPaths = new TaskItem[] { new TaskItem(Path.Combine(testingDocsDir, "sila.xml")) };
+            xslPath = new TaskItem(Path.Combine(testingDocsDir, "fdl2proto.xsl"));
+
+            // load transformed xsl and assert it is well formatted
+            {
+                XslTransformation t = new XslTransformation();
+                
+                t.BuildEngine = engine;
+                t.XslInputPath = xslPath;
+                t.XmlInputPaths = xmlPaths;
+                t.OutputPaths = outputPaths;
+                t.UseTrustedSettings = true;
+                t.PreserveWhitespace = true;
+
+                t.Execute();
+                Console.WriteLine(engine.Log);
+
+                string expectedOutput;
+                using (StreamReader sr = new StreamReader(Path.Combine(testingDocsDir, "expected.proto")))
+                {
+                    expectedOutput = sr.ReadToEnd();
+                }
+
+                using (StreamReader sr = new StreamReader(t.OutputPaths[0].ItemSpec))
+                {
+                    string fileContents = sr.ReadToEnd();
+                    Assert.Equal(expectedOutput, fileContents);
+                }
+            }
+
+            CleanUp(dir);
+        }
+
 #if FEATURE_COMPILED_XSL
         /// <summary>
         /// Passing a dll that has two types to XsltCompiledDll parameter without specifying a type.
diff --git a/src/Tasks/GetInstalledSDKLocations.cs b/src/Tasks/GetInstalledSDKLocations.cs
index fbbd450b0df..3f6e9524661 100644
--- a/src/Tasks/GetInstalledSDKLocations.cs
+++ b/src/Tasks/GetInstalledSDKLocations.cs
@@ -17,7 +17,9 @@ namespace Microsoft.Build.Tasks
     ///  Gathers the list of installed SDKS in the registry and on disk and outputs them into the project
     ///  so they can be used during SDK reference resolution and RAR for single files.
     /// </summary>
+#pragma warning disable RS0022 // Constructor make noninheritable base class inheritable: Longstanding API design that we shouldn't change now
     public class GetInstalledSDKLocations : TaskExtension
+#pragma warning restore RS0022 // Constructor make noninheritable base class inheritable
     {
         /// <summary>
         /// Metadata name for directory roots on installed SDK items
@@ -122,6 +124,12 @@ public string TargetPlatformIdentifier
         /// </summary>
         public override bool Execute()
         {
+            if (!NativeMethodsShared.IsWindows)
+            {
+                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(GetInstalledSDKLocations));
+                return false;
+            }
+
             // TargetPlatformVersion and TargetPlatformIdentifier are requried to correctly look for SDKs.
             if (String.IsNullOrEmpty(TargetPlatformVersion) || String.IsNullOrEmpty(TargetPlatformIdentifier))
             {
diff --git a/src/Tasks/GetSDKReferenceFiles.cs b/src/Tasks/GetSDKReferenceFiles.cs
index d559c588cc8..1af05538af3 100644
--- a/src/Tasks/GetSDKReferenceFiles.cs
+++ b/src/Tasks/GetSDKReferenceFiles.cs
@@ -24,7 +24,9 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Resolves an SDKReference to a full path on disk
     /// </summary>
+#pragma warning disable RS0022 // Constructor make noninheritable base class inheritable: Longstanding API design that we shouldn't change now
     public class GetSDKReferenceFiles : TaskExtension
+#pragma warning restore RS0022 // Constructor make noninheritable base class inheritable
     {
         /// <summary>
         /// Set of resolvedSDK references which we will use to find the reference assemblies.
@@ -225,6 +227,11 @@ public string[] ReferenceExtensions
         /// </summary>
         public override bool Execute()
         {
+            if (!NativeMethodsShared.IsWindows)
+            {
+                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(GetSDKReferenceFiles));
+                return false;
+            }
             return Execute(AssemblyNameExtension.GetAssemblyNameEx, AssemblyInformation.GetRuntimeVersion, p => FileUtilities.FileExistsNoThrow(p), synchronous: false);
         }
 
@@ -1084,7 +1091,11 @@ internal bool IsAssemblyListCacheFileUpToDate(string sdkIdentity, string sdkRoot
                 string currentAssembly = String.Empty;
                 try
                 {
+#if NETCOREAPP
+                    currentAssembly = Assembly.GetExecutingAssembly().Location;
+#else
                     currentAssembly = Assembly.GetExecutingAssembly().CodeBase;
+#endif
                     var codeBase = new Uri(currentAssembly);
                     DateTime currentCodeLastWriteTime = File.GetLastWriteTimeUtc(codeBase.LocalPath);
                     if (FileSystems.Default.FileExists(referencesCacheFile) && currentCodeLastWriteTime < referencesCacheFileLastWriteTimeUtc)
diff --git a/src/Tasks/MSBuild.cs b/src/Tasks/MSBuild.cs
index 868d9811bfa..ea4213c9688 100644
--- a/src/Tasks/MSBuild.cs
+++ b/src/Tasks/MSBuild.cs
@@ -25,8 +25,13 @@ public class MSBuild : TaskExtension
         /// <summary>
         /// Enum describing the behavior when a project doesn't exist on disk.
         /// </summary>
-        private enum SkipNonexistentProjectsBehavior
+        private enum SkipNonExistentProjectsBehavior
         {
+            /// <summary>
+            /// Default when unset by user.
+            /// </summary>
+            Undefined,
+
             /// <summary>
             /// Skip the project if there is no file on disk.
             /// </summary>
@@ -49,7 +54,7 @@ private enum SkipNonexistentProjectsBehavior
         private readonly List<ITaskItem> _targetOutputs = new List<ITaskItem>();
 
         // Whether to skip project files that don't exist on disk. By default we error for such projects.
-        private SkipNonexistentProjectsBehavior _skipNonexistentProjects = SkipNonexistentProjectsBehavior.Error;
+        private SkipNonExistentProjectsBehavior _skipNonExistentProjects = SkipNonExistentProjectsBehavior.Undefined;
 
         /// <summary>
         /// A list of property name/value pairs to apply as global properties to 
@@ -143,19 +148,22 @@ public string SkipNonexistentProjects
         {
             get
             {
-                switch (_skipNonexistentProjects)
+                switch (_skipNonExistentProjects)
                 {
-                    case SkipNonexistentProjectsBehavior.Build:
+                    case SkipNonExistentProjectsBehavior.Undefined:
+                        return "Undefined";
+
+                    case SkipNonExistentProjectsBehavior.Build:
                         return "Build";
 
-                    case SkipNonexistentProjectsBehavior.Error:
+                    case SkipNonExistentProjectsBehavior.Error:
                         return "False";
 
-                    case SkipNonexistentProjectsBehavior.Skip:
+                    case SkipNonExistentProjectsBehavior.Skip:
                         return "True";
 
                     default:
-                        ErrorUtilities.ThrowInternalError("Unexpected case {0}", _skipNonexistentProjects);
+                        ErrorUtilities.ThrowInternalError("Unexpected case {0}", _skipNonExistentProjects);
                         break;
                 }
 
@@ -165,19 +173,14 @@ public string SkipNonexistentProjects
 
             set
             {
-                if (String.Equals("Build", value, StringComparison.OrdinalIgnoreCase))
-                {
-                    _skipNonexistentProjects = SkipNonexistentProjectsBehavior.Build;
-                }
-                else
+                if (TryParseSkipNonExistentProjects(value, out SkipNonExistentProjectsBehavior behavior))
                 {
-                    ErrorUtilities.VerifyThrowArgument(ConversionUtilities.CanConvertStringToBool(value), "MSBuild.InvalidSkipNonexistentProjectValue");
-                    bool originalSkipValue = ConversionUtilities.ConvertStringToBool(value);
-                    _skipNonexistentProjects = originalSkipValue ? SkipNonexistentProjectsBehavior.Skip : SkipNonexistentProjectsBehavior.Error;
+                    _skipNonExistentProjects = behavior;
                 }
             }
         }
 
+
         /// <summary>
         /// Unescape Targets, Properties (including Properties and AdditionalProperties as Project item metadata)
         /// will be un-escaped before processing. e.g. %3B (an escaped ';') in the string for any of them will 
@@ -289,7 +292,21 @@ public override bool Execute()
                     break;
                 }
 
-                if (FileSystems.Default.FileExists(projectPath) || (_skipNonexistentProjects == SkipNonexistentProjectsBehavior.Build))
+                // Try to get the behavior from metadata if it is undefined.
+                var skipNonExistProjects = _skipNonExistentProjects;
+                if (_skipNonExistentProjects == SkipNonExistentProjectsBehavior.Undefined)
+                {
+                    if (TryParseSkipNonExistentProjects(project.GetMetadata("SkipNonexistentProjects"), out SkipNonExistentProjectsBehavior behavior))
+                    {
+                        skipNonExistProjects = behavior;
+                    }
+                    else
+                    {
+                        skipNonExistProjects = SkipNonExistentProjectsBehavior.Error;
+                    }
+                }
+
+                if (FileSystems.Default.FileExists(projectPath) || (skipNonExistProjects == SkipNonExistentProjectsBehavior.Build))
                 {
                     if (FileUtilities.IsVCProjFilename(projectPath))
                     {
@@ -330,13 +347,13 @@ public override bool Execute()
                 }
                 else
                 {
-                    if (_skipNonexistentProjects == SkipNonexistentProjectsBehavior.Skip)
+                    if (skipNonExistProjects == SkipNonExistentProjectsBehavior.Skip)
                     {
                         Log.LogMessageFromResources(MessageImportance.High, "MSBuild.ProjectFileNotFoundMessage", project.ItemSpec);
                     }
                     else
                     {
-                        ErrorUtilities.VerifyThrow(_skipNonexistentProjects == SkipNonexistentProjectsBehavior.Error, "skipNonexistentProjects has unexpected value {0}", _skipNonexistentProjects);
+                        ErrorUtilities.VerifyThrow(skipNonExistProjects == SkipNonExistentProjectsBehavior.Error, "skipNonexistentProjects has unexpected value {0}", skipNonExistProjects);
                         Log.LogErrorWithCodeFromResources("MSBuild.ProjectFileNotFound", project.ItemSpec);
                         success = false;
                     }
@@ -666,6 +683,27 @@ string toolsVersion
             return success;
         }
 
+        private bool TryParseSkipNonExistentProjects(string value, out SkipNonExistentProjectsBehavior behavior)
+        {
+            if (string.IsNullOrEmpty(value))
+            {
+                behavior = SkipNonExistentProjectsBehavior.Error;
+                return false;
+            }
+            else if (String.Equals("Build", value, StringComparison.OrdinalIgnoreCase))
+            {
+                behavior = SkipNonExistentProjectsBehavior.Build;
+            }
+            else
+            {
+                ErrorUtilities.VerifyThrowArgument(ConversionUtilities.CanConvertStringToBool(value), "MSBuild.InvalidSkipNonexistentProjectValue");
+                bool originalSkipValue = ConversionUtilities.ConvertStringToBool(value);
+                behavior = originalSkipValue ? SkipNonExistentProjectsBehavior.Skip : SkipNonExistentProjectsBehavior.Error;
+            }
+
+            return true;
+        }
+
         #endregion
     }
 }
diff --git a/src/Tasks/Microsoft.Build.Tasks.csproj b/src/Tasks/Microsoft.Build.Tasks.csproj
index c08a5129001..5bd98bfbe0c 100644
--- a/src/Tasks/Microsoft.Build.Tasks.csproj
+++ b/src/Tasks/Microsoft.Build.Tasks.csproj
@@ -417,6 +417,8 @@
     <Compile Include="GetAssemblyIdentity.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="GetInstalledSDKLocations.cs" />
+    <Compile Include="GetSDKReferenceFiles.cs" />
     <Compile Include="IAnalyzerHostObject.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -502,6 +504,7 @@
     <Compile Include="ResolveProjectBase.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
+    <Compile Include="ResolveSDKReference.cs" />
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactory.cs" />
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactoryCodeType.cs" />
     <Compile Include="RoslynCodeTaskFactory\RoslynCodeTaskFactoryCompilers.cs" />
@@ -604,8 +607,6 @@
     <Compile Include="GetFrameworkSDKPath.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="GetInstalledSDKLocations.cs" />
-    <Compile Include="GetSDKReferenceFiles.cs" />
     <Compile Include="IComReferenceResolver.cs">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
@@ -626,7 +627,6 @@
     <Compile Include="ResolveNativeReference.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
-    <Compile Include="ResolveSDKReference.cs" />
     <Compile Include="RequiresFramework35SP1Assembly.cs" Condition="'$(MonoBuild)' != 'true'">
       <ExcludeFromStyleCop>true</ExcludeFromStyleCop>
     </Compile>
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 7819000499b..b73ae1e6d85 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -1780,7 +1780,23 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         Properties="%(_MSBuildProjectReferenceExistent.SetConfiguration); %(_MSBuildProjectReferenceExistent.SetPlatform)"
         ContinueOnError="!$(BuildingProject)"
         RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier$(_GlobalPropertiesToRemoveFromProjectReferences)"
-        Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true'"
+        Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' != 'true'"
+        SkipNonexistentTargets="true">
+      <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
+    </MSBuild>
+    
+    <!--
+       SetPlatform negotiation requires the 'GetTargetFrameworks' MSBuild call to NOT pass global properties. This is to verify
+       whether or not the referenced project would build as the same platform as the current project by default. The above
+       MSBuild call is kept for legacy scenarios that may depend on passing %(SetConfiguration) and %(SetPlatform).
+    -->
+    <MSBuild
+        Projects="@(_MSBuildProjectReferenceExistent)"
+        Targets="GetTargetFrameworks"
+        BuildInParallel="$(BuildInParallel)"
+        ContinueOnError="!$(BuildingProject)"
+        RemoveProperties="%(_MSBuildProjectReferenceExistent.GlobalPropertiesToRemove);TargetFramework;RuntimeIdentifier;Platform;Configuration$(_GlobalPropertiesToRemoveFromProjectReferences)"
+        Condition="'%(_MSBuildProjectReferenceExistent.SkipGetTargetFrameworkProperties)' != 'true' and '$(EnableDynamicPlatformResolution)' == 'true'"
         SkipNonexistentTargets="true">
       <Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceTargetFrameworkPossibilities" />
     </MSBuild>
@@ -1891,7 +1907,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
         <Platforms>$(Platforms)</Platforms>
         <!-- .vcxproj and .nativeproj contain a `ProjectConfiguration` item that have `Platform` metadata within.
              Build the `Platforms` property from that. -->
-        <Platforms Condition="'@(ProjectConfiguration)' != '' and ('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj')">@(ProjectConfiguration->'%(Platform)'->Distinct())</Platforms>
+        <Platforms Condition="'$(UsePlatformFromProjectConfiguration)' != 'false' and '@(ProjectConfiguration)' != '' and ('$(MSBuildProjectExtension)' == '.vcxproj' or '$(MSBuildProjectExtension)' == '.nativeproj')">@(ProjectConfiguration->'%(Platform)'->Distinct())</Platforms>
       </_ThisProjectBuildMetadata>
     </ItemGroup>
 
@@ -4355,9 +4371,9 @@ Copyright (C) Microsoft Corporation. All rights reserved.
       <_ClickOnceFiles Include="@(ContentWithTargetPath);@(_DeploymentManifestIconFile);@(AppConfigWithTargetPath);@(NetCoreRuntimeJsonFilesForClickOnce);@(_ClickOnceRuntimeCopyLocalItems)"/>
     </ItemGroup>
 
-    <!-- For single file publish, we need to include the SF bundle EXE and files excluded from the bundle EXE in the clickonce manifest -->
+    <!-- For single file publish, we need to include the SF bundle EXE, application icon file and files excluded from the bundle EXE in the clickonce manifest -->
     <ItemGroup Condition="'$(PublishSingleFile)' == 'true'">
-      <_ClickOnceFiles Include="$(PublishedSingleFilePath)"/>
+      <_ClickOnceFiles Include="$(PublishedSingleFilePath);@(_DeploymentManifestIconFile)"/>
       <_ClickOnceFiles Include="@(_FilesExcludedFromBundle)"/>
 
       <!-- Include file association icons from Content as loose files -->
@@ -6670,4 +6686,4 @@ Copyright (C) Microsoft Corporation. All rights reserved.
   <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')"/>
   <Import Project="$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter\*" Condition="'$(ImportUserLocationsByWildcardAfterMicrosoftCommonTargets)' == 'true' and exists('$(MSBuildUserExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.targets\ImportAfter')"/>
 
-</Project>
\ No newline at end of file
+</Project>
diff --git a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
index e69de29bb2d..68779602973 100644
--- a/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/net/PublicAPI.Unshipped.txt
@@ -0,0 +1,2 @@
+Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.get -> bool
+Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
\ No newline at end of file
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
index 8f3cbf42ee6..942972d067e 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -1135,6 +1135,22 @@ Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion47Path.get -> string
 Microsoft.Build.Tasks.GetFrameworkPath.FrameworkVersion48Path.get -> string
 Microsoft.Build.Tasks.GetFrameworkPath.GetFrameworkPath() -> void
 Microsoft.Build.Tasks.GetFrameworkPath.Path.get -> string
+Microsoft.Build.Tasks.GetInstalledSDKLocations
+Microsoft.Build.Tasks.GetInstalledSDKLocations.GetInstalledSDKLocations() -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetInstalledSDKLocations.InstalledSDKs.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.get -> string[]
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKDirectoryRoots.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.get -> string[]
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKExtensionDirectoryRoots.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.get -> string
+Microsoft.Build.Tasks.GetInstalledSDKLocations.SDKRegistryRoot.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformIdentifier.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.get -> string
+Microsoft.Build.Tasks.GetInstalledSDKLocations.TargetPlatformVersion.set -> void
+Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.get -> bool
+Microsoft.Build.Tasks.GetInstalledSDKLocations.WarnWhenNoSDKsFound.set -> void
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.get -> bool
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths.BypassFrameworkInstallChecks.set -> void
@@ -1151,6 +1167,39 @@ Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.get -> st
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMoniker.set -> void
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.get -> string
 Microsoft.Build.Tasks.GetReferenceAssemblyPaths.TargetFrameworkMonikerDisplayName.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles
+Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.CacheFileFolderPath.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.CopyLocalFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.GetSDKReferenceFiles() -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogCacheFileExceptions.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictBetweenSDKsAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistConflictWithinSDKAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogRedistFilesList.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictBetweenSDKsAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferenceConflictWithinSDKAsWarning.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.get -> bool
+Microsoft.Build.Tasks.GetSDKReferenceFiles.LogReferencesList.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.RedistFiles.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.get -> string[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ReferenceExtensions.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.References.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.GetSDKReferenceFiles.ResolvedSDKReferences.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformIdentifier.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetPlatformVersion.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKIdentifier.set -> void
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.get -> string
+Microsoft.Build.Tasks.GetSDKReferenceFiles.TargetSDKVersion.set -> void
 Microsoft.Build.Tasks.Hash
 Microsoft.Build.Tasks.Hash.Hash() -> void
 Microsoft.Build.Tasks.Hash.HashResult.get -> string
@@ -1279,6 +1328,26 @@ Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetPlatformWith32BitPreference(str
 Microsoft.Build.Tasks.Hosting.IVbcHostObject5.SetSubsystemVersion(string subsystemVersion) -> bool
 Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded
 Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded.Compile() -> bool
+Microsoft.Build.Tasks.IFixedTypeInfo
+Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(object pUnkOuter, ref System.Guid riid, out object ppvObj) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(out System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, out int pIndex) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, System.IntPtr pBstrDllName, System.IntPtr pBstrName, System.IntPtr pwOrdinal) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(int index, out System.IntPtr ppFuncDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(int index, out System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(int memid, out string pBstrMops) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out Microsoft.Build.Tasks.IFixedTypeInfo ppTI) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeOfImplType(int index, out System.IntPtr href) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeAttr(out System.IntPtr ppTypeAttr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeComp(out System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.GetVarDesc(int index, out System.IntPtr ppVarDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, System.IntPtr pVarResult, System.IntPtr pExcepInfo, out int puArgErr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr pFuncDesc) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr pTypeAttr) -> void
+Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr pVarDesc) -> void
 Microsoft.Build.Tasks.LC
 Microsoft.Build.Tasks.LC.LC() -> void
 Microsoft.Build.Tasks.LC.LicenseTarget.get -> Microsoft.Build.Framework.ITaskItem
@@ -1604,6 +1673,35 @@ Microsoft.Build.Tasks.ResolveProjectBase.GetProjectItem(Microsoft.Build.Framewor
 Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.get -> Microsoft.Build.Framework.ITaskItem[]
 Microsoft.Build.Tasks.ResolveProjectBase.ProjectReferences.set -> void
 Microsoft.Build.Tasks.ResolveProjectBase.ResolveProjectBase() -> void
+Microsoft.Build.Tasks.ResolveSDKReference
+Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.DisallowedSDKDependencies.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.InstalledSDKs.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.get -> bool
+Microsoft.Build.Tasks.ResolveSDKReference.LogResolutionErrorsAsWarnings.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.get -> bool
+Microsoft.Build.Tasks.ResolveSDKReference.Prefer32Bit.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.ProjectName.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.References.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.References.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.ResolvedSDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.ResolveSDKReference() -> void
+Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.RuntimeReferenceOnlySDKDependencies.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.get -> Microsoft.Build.Framework.ITaskItem[]
+Microsoft.Build.Tasks.ResolveSDKReference.SDKReferences.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKArchitecture.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetedSDKConfiguration.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformIdentifier.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.get -> string
+Microsoft.Build.Tasks.ResolveSDKReference.TargetPlatformVersion.set -> void
+Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.get -> bool
+Microsoft.Build.Tasks.ResolveSDKReference.WarnOnMissingPlatformVersion.set -> void
 Microsoft.Build.Tasks.RoslynCodeTaskFactory
 Microsoft.Build.Tasks.RoslynCodeTaskFactory.CleanupTask(Microsoft.Build.Framework.ITask task) -> void
 Microsoft.Build.Tasks.RoslynCodeTaskFactory.CreateTask(Microsoft.Build.Framework.IBuildEngine taskFactoryLoggingHost) -> Microsoft.Build.Framework.ITask
@@ -1862,7 +1960,9 @@ override Microsoft.Build.Tasks.GetAssemblyIdentity.Execute() -> bool
 override Microsoft.Build.Tasks.GetCompatiblePlatform.Execute() -> bool
 override Microsoft.Build.Tasks.GetFileHash.Execute() -> bool
 override Microsoft.Build.Tasks.GetFrameworkPath.Execute() -> bool
+override Microsoft.Build.Tasks.GetInstalledSDKLocations.Execute() -> bool
 override Microsoft.Build.Tasks.GetReferenceAssemblyPaths.Execute() -> bool
+override Microsoft.Build.Tasks.GetSDKReferenceFiles.Execute() -> bool
 override Microsoft.Build.Tasks.Hash.Execute() -> bool
 override Microsoft.Build.Tasks.LC.AddCommandLineCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
 override Microsoft.Build.Tasks.LC.AddResponseFileCommands(Microsoft.Build.Tasks.CommandLineBuilderExtension commandLine) -> void
@@ -1883,6 +1983,7 @@ override Microsoft.Build.Tasks.ResolveComReference.Execute() -> bool
 override Microsoft.Build.Tasks.ResolveKeySource.Execute() -> bool
 override Microsoft.Build.Tasks.ResolveManifestFiles.Execute() -> bool
 override Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput.Execute() -> bool
+override Microsoft.Build.Tasks.ResolveSDKReference.Execute() -> bool
 override Microsoft.Build.Tasks.SGen.Execute() -> bool
 override Microsoft.Build.Tasks.SGen.GenerateFullPathToTool() -> string
 override Microsoft.Build.Tasks.SGen.ToolName.get -> string
diff --git a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index 886e91fbd48..68779602973 100644
--- a/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Tasks/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,20 +1,2 @@
-Microsoft.Build.Tasks.IFixedTypeInfo
-Microsoft.Build.Tasks.IFixedTypeInfo.AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, out System.IntPtr ppv) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.CreateInstance(object pUnkOuter, ref System.Guid riid, out object ppvObj) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetContainingTypeLib(out System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, out int pIndex) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, System.IntPtr pBstrDllName, System.IntPtr pBstrName, System.IntPtr pwOrdinal) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetDocumentation(int index, out string strName, out string strDocString, out int dwHelpContext, out string strHelpFile) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetFuncDesc(int index, out System.IntPtr ppFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetImplTypeFlags(int index, out System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetMops(int memid, out string pBstrMops) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetNames(int memid, string[] rgBstrNames, int cMaxNames, out int pcNames) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeInfo(System.IntPtr hRef, out Microsoft.Build.Tasks.IFixedTypeInfo ppTI) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetRefTypeOfImplType(int index, out System.IntPtr href) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeAttr(out System.IntPtr ppTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetTypeComp(out System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.GetVarDesc(int index, out System.IntPtr ppVarDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, System.IntPtr pVarResult, System.IntPtr pExcepInfo, out int puArgErr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseFuncDesc(System.IntPtr pFuncDesc) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseTypeAttr(System.IntPtr pTypeAttr) -> void
-Microsoft.Build.Tasks.IFixedTypeInfo.ReleaseVarDesc(System.IntPtr pVarDesc) -> void
+Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.get -> bool
+Microsoft.Build.Tasks.XslTransformation.PreserveWhitespace.set -> void
\ No newline at end of file
diff --git a/src/Tasks/ResolveSDKReference.cs b/src/Tasks/ResolveSDKReference.cs
index d479f1e3206..f45d483f733 100644
--- a/src/Tasks/ResolveSDKReference.cs
+++ b/src/Tasks/ResolveSDKReference.cs
@@ -19,7 +19,9 @@ namespace Microsoft.Build.Tasks
     /// <summary>
     /// Resolves an SDKReference to a full path on disk
     /// </summary>
+#pragma warning disable RS0022 // Constructor make noninheritable base class inheritable: Longstanding API design that we shouldn't change now
     public class ResolveSDKReference : TaskExtension
+#pragma warning restore RS0022 // Constructor make noninheritable base class inheritable
     {
         #region fields
 
@@ -257,6 +259,12 @@ private Version TargetPlatformAsVersion
         /// </summary>
         public override bool Execute()
         {
+            if (!NativeMethodsShared.IsWindows)
+            {
+                Log.LogErrorWithCodeFromResources("General.TaskRequiresWindows", nameof(ResolveSDKReference));
+                return false;
+            }
+
             ResolvedSDKReferences = Array.Empty<ITaskItem>();
 
             if (InstalledSDKs.Length == 0)
diff --git a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
index a9195d3f89d..7378f094c43 100644
--- a/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
+++ b/src/Tasks/XamlTaskFactory/XamlTaskFactory.cs
@@ -113,7 +113,8 @@ public bool Initialize(string taskName, IDictionary<string, TaskPropertyInfo> ta
 
             CodeCompileUnit dom = generator.GenerateCode();
 
-            string pathToMSBuildBinaries = ToolLocationHelper.GetPathToBuildTools(ToolLocationHelper.CurrentToolsVersion);
+            // MSBuildToolsDirectoryRoot is the canonical location for MSBuild dll's.
+            string pathToMSBuildBinaries = BuildEnvironmentHelper.Instance.MSBuildToolsDirectoryRoot;
 
             // create the code generator options    
             // Since we are running msbuild 12.0 these had better load.
diff --git a/src/Tasks/XslTransformation.cs b/src/Tasks/XslTransformation.cs
index 3763ba0da5b..a3f9bdb3bf4 100644
--- a/src/Tasks/XslTransformation.cs
+++ b/src/Tasks/XslTransformation.cs
@@ -52,6 +52,11 @@ public class XslTransformation : TaskExtension
         /// </summary>
         public string XslContent { get; set; }
 
+        /// <summary>
+        /// Flag to preserve whitespaces in the XSLT file.
+        /// </summary>
+        public bool PreserveWhitespace { get; set; }
+
         /// <summary>
         /// The XSLT input as compiled dll.
         /// </summary>
@@ -98,7 +103,7 @@ public override bool Execute()
             try
             {
                 xmlinput = new XmlInput(XmlInputPaths, XmlContent);
-                xsltinput = new XsltInput(XslInputPath, XslContent, XslCompiledDllPath, Log);
+                xsltinput = new XsltInput(XslInputPath, XslContent, XslCompiledDllPath, Log, PreserveWhitespace);
             }
             catch (Exception e) when (!ExceptionHandling.IsCriticalException(e))
             {
@@ -342,6 +347,11 @@ internal class XsltInput
             /// </summary>
             private readonly string _data;
 
+            /// <summary>
+            /// Flag to preserve whitespaces in the XSLT file.
+            /// </summary>
+            private bool _preserveWhitespace;
+
             /// <summary>
             /// Tool for logging build messages, warnings, and errors
             /// </summary>
@@ -355,7 +365,8 @@ internal class XsltInput
             /// <param name="xslt">The raw to XSLT or null.</param>
             /// <param name="xsltCompiledDll">The path to compiled XSLT file or null.</param>
             /// <param name="logTool">Log helper.</param>
-            public XsltInput(ITaskItem xsltFile, string xslt, ITaskItem xsltCompiledDll, TaskLoggingHelper logTool)
+            /// <param name="preserveWhitespace">Flag for xslt whitespace option.</param>
+            public XsltInput(ITaskItem xsltFile, string xslt, ITaskItem xsltCompiledDll, TaskLoggingHelper logTool, bool preserveWhitespace)
             {
                 _log = logTool;
                 if ((xsltFile != null && xslt != null) ||
@@ -384,6 +395,8 @@ public XsltInput(ITaskItem xsltFile, string xslt, ITaskItem xsltCompiledDll, Tas
                     _xslMode = XslModes.XsltCompiledDll;
                     _data = xsltCompiledDll.ItemSpec;
                 }
+
+                _preserveWhitespace = preserveWhitespace;
             }
 
             /// <summary>
@@ -443,7 +456,8 @@ public XslCompiledTransform LoadXslt(bool useTrustedSettings)
 
                         using (XmlReader reader = XmlReader.Create(new StreamReader(_data), new XmlReaderSettings { CloseInput = true }, _data))
                         {
-                            xslct.Load(new XPathDocument(reader), settings, new XmlUrlResolver());
+                            XmlSpace xmlSpaceOption = _preserveWhitespace ? XmlSpace.Preserve : XmlSpace.Default;
+                            xslct.Load(new XPathDocument(reader, xmlSpaceOption), settings, new XmlUrlResolver());
                         }
                         break;
                     case XslModes.XsltCompiledDll:
diff --git a/src/UnitTests.Shared/RunnerUtilities.cs b/src/UnitTests.Shared/RunnerUtilities.cs
index 7911ea669d6..366b1bc4280 100644
--- a/src/UnitTests.Shared/RunnerUtilities.cs
+++ b/src/UnitTests.Shared/RunnerUtilities.cs
@@ -1,5 +1,4 @@
 ﻿using Microsoft.Build.Shared;
-using Microsoft.Build.Utilities;
 using System;
 using System.Diagnostics;
 using Xunit.Abstractions;
@@ -18,7 +17,7 @@ public static class RunnerUtilities
         /// </summary>
         public static string ExecMSBuild(string msbuildParameters, out bool successfulExit, ITestOutputHelper outputHelper = null)
         {
-            return ExecMSBuild(PathToCurrentlyRunningMsBuildExe, msbuildParameters, out successfulExit, false, outputHelper);
+            return ExecMSBuild(PathToCurrentlyRunningMsBuildExe, msbuildParameters, out successfulExit, outputHelper: outputHelper);
         }
 
         /// <summary>
@@ -72,12 +71,15 @@ private static string ResolveRuntimeExecutableName()
         /// </summary>
         public static string RunProcessAndGetOutput(string process, string parameters, out bool successfulExit, bool shellExecute = false, ITestOutputHelper outputHelper = null)
         {
+            outputHelper?.WriteLine($"{DateTime.Now.ToString("hh:mm:ss tt")}:RunProcessAndGetOutput:1");
+
             if (shellExecute)
             {
                 // we adjust the psi data manually because on net core using ProcessStartInfo.UseShellExecute throws NotImplementedException
                 AdjustForShellExecution(ref process, ref parameters);
             }
 
+            outputHelper?.WriteLine($"{DateTime.Now.ToString("hh:mm:ss tt")}:RunProcessAndGetOutput:2");
             var psi = new ProcessStartInfo(process)
             {
                 CreateNoWindow = true,
@@ -87,11 +89,13 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
                 UseShellExecute = false,
                 Arguments = parameters
             };
-            var output = string.Empty;
+            string output = string.Empty;
+            int pid = -1;
 
+            outputHelper?.WriteLine($"{DateTime.Now.ToString("hh:mm:ss tt")}:RunProcessAndGetOutput:3");
             using (var p = new Process { EnableRaisingEvents = true, StartInfo = psi })
             {
-                p.OutputDataReceived += delegate (object sender, DataReceivedEventArgs args)
+                DataReceivedEventHandler handler = delegate (object sender, DataReceivedEventArgs args)
                 {
                     if (args != null)
                     {
@@ -99,13 +103,8 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
                     }
                 };
 
-                p.ErrorDataReceived += delegate (object sender, DataReceivedEventArgs args)
-                {
-                    if (args != null)
-                    {
-                        output += args.Data + "\r\n";
-                    }
-                };
+                p.OutputDataReceived += handler;
+                p.ErrorDataReceived += handler;
 
                 outputHelper?.WriteLine("Executing [{0} {1}]", process, parameters);
                 Console.WriteLine("Executing [{0} {1}]", process, parameters);
@@ -114,19 +113,35 @@ public static string RunProcessAndGetOutput(string process, string parameters, o
                 p.BeginOutputReadLine();
                 p.BeginErrorReadLine();
                 p.StandardInput.Dispose();
+
+                if (!p.WaitForExit(30_000))
+                {
+                    // Let's not create a unit test for which we need more than 30 sec to execute.
+                    // Please consider carefully if you would like to increase the timeout.
+                    p.KillTree(1000);
+                    throw new TimeoutException($"Test failed due to timeout: process {p.Id} is active for more than 30 sec.");
+                }
+
+                // We need the WaitForExit call without parameters because our processing of output/error streams is not synchronous.
+                // See https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.waitforexit?view=net-6.0#system-diagnostics-process-waitforexit(system-int32).
+                // The overload WaitForExit() waits for the error and output to be handled. The WaitForExit(int timeout) overload does not, so we could lose the data.
                 p.WaitForExit();
 
+                pid = p.Id;
                 successfulExit = p.ExitCode == 0;
             }
 
             outputHelper?.WriteLine("==== OUTPUT ====");
             outputHelper?.WriteLine(output);
+            outputHelper?.WriteLine("Process ID is " + pid + "\r\n");
             outputHelper?.WriteLine("==============");
 
             Console.WriteLine("==== OUTPUT ====");
             Console.WriteLine(output);
+            Console.WriteLine("Process ID is " + pid + "\r\n");
             Console.WriteLine("==============");
 
+            output += "Process ID is " + pid + "\r\n";
             return output;
         }
     }
diff --git a/src/Utilities/MuxLogger.cs b/src/Utilities/MuxLogger.cs
index f9532864e15..2629634f436 100644
--- a/src/Utilities/MuxLogger.cs
+++ b/src/Utilities/MuxLogger.cs
@@ -862,7 +862,7 @@ private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs bui
                         _firstProjectStartedEventContext = buildEvent.BuildEventContext;
 
                         // We've never seen a project started event, so raise the build started event and save this project started event.
-                        BuildStartedEventArgs startedEvent = new BuildStartedEventArgs(_buildStartedEvent.Message, _buildStartedEvent.HelpKeyword, Traits.Instance.LogAllEnvironmentVariables ? _buildStartedEvent.BuildEnvironment : null);
+                        BuildStartedEventArgs startedEvent = new BuildStartedEventArgs(_buildStartedEvent.Message, _buildStartedEvent.HelpKeyword, _buildStartedEvent.BuildEnvironment);
                         RaiseBuildStartedEvent(sender, startedEvent);
                     }
 
diff --git a/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt b/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
index f7bb4031d5e..9efcc6b3e9d 100644
--- a/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
+++ b/src/Utilities/PublicAPI/netstandard/PublicAPI.Shipped.txt
@@ -1,3 +1,4 @@
+abstract Microsoft.Build.Utilities.AppDomainIsolatedTask.Execute() -> bool
 abstract Microsoft.Build.Utilities.Logger.Initialize(Microsoft.Build.Framework.IEventSource eventSource) -> void
 abstract Microsoft.Build.Utilities.Task.Execute() -> bool
 abstract Microsoft.Build.Utilities.ToolTask.GenerateFullPathToTool() -> string
@@ -33,6 +34,26 @@ const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetedSDKConfiguration
 const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatform = "TargetPlatform" -> string
 const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformMinVersion = "TargetPlatformMinVersion" -> string
 const Microsoft.Build.Utilities.SDKManifest.Attributes.TargetPlatformVersion = "TargetPlatformVersion" -> string
+Microsoft.Build.Utilities.AppDomainIsolatedTask
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask() -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources) -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
+Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.get -> string
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
+Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.set -> void
+Microsoft.Build.Utilities.AppDomainIsolatedTask.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
+Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.get -> System.Resources.ResourceManager
+Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.set -> void
+Microsoft.Build.Utilities.AssemblyFoldersExInfo
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.AssemblyFoldersExInfo(Microsoft.Win32.RegistryHive hive, Microsoft.Win32.RegistryView view, string registryKey, string directoryPath, System.Version targetFrameworkVersion) -> void
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.DirectoryPath.get -> string
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.Hive.get -> Microsoft.Win32.RegistryHive
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.Key.get -> string
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.TargetFrameworkVersion.get -> System.Version
+Microsoft.Build.Utilities.AssemblyFoldersExInfo.View.get -> Microsoft.Win32.RegistryView
 Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo
 Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.AssemblyFoldersFromConfigInfo(string directoryPath, System.Version targetFrameworkVersion) -> void
 Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo.DirectoryPath.get -> string
@@ -278,6 +299,7 @@ Microsoft.Build.Utilities.VisualStudioVersion.Version150 = 4 -> Microsoft.Build.
 Microsoft.Build.Utilities.VisualStudioVersion.Version160 = 5 -> Microsoft.Build.Utilities.VisualStudioVersion
 Microsoft.Build.Utilities.VisualStudioVersion.Version170 = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
 Microsoft.Build.Utilities.VisualStudioVersion.VersionLatest = 6 -> Microsoft.Build.Utilities.VisualStudioVersion
+override Microsoft.Build.Utilities.AppDomainIsolatedTask.InitializeLifetimeService() -> object
 override Microsoft.Build.Utilities.CommandLineBuilder.ToString() -> string
 override Microsoft.Build.Utilities.TargetPlatformSDK.Equals(object obj) -> bool
 override Microsoft.Build.Utilities.TargetPlatformSDK.GetHashCode() -> int
@@ -290,6 +312,7 @@ static Microsoft.Build.Utilities.ToolLocationHelper.CurrentToolsVersion.get -> s
 static Microsoft.Build.Utilities.ToolLocationHelper.FilterPlatformExtensionSDKs(System.Version targetPlatformVersion, System.Collections.Generic.IDictionary<string, string> extensionSdks) -> System.Collections.Generic.IDictionary<string, string>
 static Microsoft.Build.Utilities.ToolLocationHelper.FilterTargetPlatformSdks(System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK> targetPlatformSdkList, System.Version osVersion, System.Version vsVersion) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.TargetPlatformSDK>
 static Microsoft.Build.Utilities.ToolLocationHelper.FindRootFolderWhereAllFilesExist(string possibleRoots, string relativeFilePaths) -> string
+static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersExInfo>
 static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersFromConfigInfo(string configFile, string targetFrameworkVersion, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>
 static Microsoft.Build.Utilities.ToolLocationHelper.GetDisplayNameForTargetFrameworkDirectory(string targetFrameworkDirectory, System.Runtime.Versioning.FrameworkName frameworkName) -> string
 static Microsoft.Build.Utilities.ToolLocationHelper.GetDotNetFrameworkRootRegistryKey(Microsoft.Build.Utilities.TargetDotNetFrameworkVersion version) -> string
diff --git a/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt b/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
index b08b45a21d6..e69de29bb2d 100644
--- a/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
+++ b/src/Utilities/PublicAPI/netstandard/PublicAPI.Unshipped.txt
@@ -1,23 +0,0 @@
-abstract Microsoft.Build.Utilities.AppDomainIsolatedTask.Execute() -> bool
-Microsoft.Build.Utilities.AppDomainIsolatedTask
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask() -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.AppDomainIsolatedTask(System.Resources.ResourceManager taskResources, string helpKeywordPrefix) -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.get -> Microsoft.Build.Framework.IBuildEngine
-Microsoft.Build.Utilities.AppDomainIsolatedTask.BuildEngine.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.get -> string
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HelpKeywordPrefix.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.get -> Microsoft.Build.Framework.ITaskHost
-Microsoft.Build.Utilities.AppDomainIsolatedTask.HostObject.set -> void
-Microsoft.Build.Utilities.AppDomainIsolatedTask.Log.get -> Microsoft.Build.Utilities.TaskLoggingHelper
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.get -> System.Resources.ResourceManager
-Microsoft.Build.Utilities.AppDomainIsolatedTask.TaskResources.set -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.AssemblyFoldersExInfo(Microsoft.Win32.RegistryHive hive, Microsoft.Win32.RegistryView view, string registryKey, string directoryPath, System.Version targetFrameworkVersion) -> void
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.DirectoryPath.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Hive.get -> Microsoft.Win32.RegistryHive
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.Key.get -> string
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.TargetFrameworkVersion.get -> System.Version
-Microsoft.Build.Utilities.AssemblyFoldersExInfo.View.get -> Microsoft.Win32.RegistryView
-override Microsoft.Build.Utilities.AppDomainIsolatedTask.InitializeLifetimeService() -> object
-static Microsoft.Build.Utilities.ToolLocationHelper.GetAssemblyFoldersExInfo(string registryRoot, string targetFrameworkVersion, string registryKeySuffix, string osVersion, string platform, System.Reflection.ProcessorArchitecture targetProcessorArchitecture) -> System.Collections.Generic.IList<Microsoft.Build.Utilities.AssemblyFoldersExInfo>
\ No newline at end of file
