diff --git a/documentation/wiki/ChangeWaves.md b/documentation/wiki/ChangeWaves.md
index e5fa1a91211..7f2ca5375ff 100644
--- a/documentation/wiki/ChangeWaves.md
+++ b/documentation/wiki/ChangeWaves.md
@@ -32,6 +32,7 @@ A wave of features is set to "rotate out" (i.e. become standard functionality) t
 - [Don't compile globbing regexes on .NET Framework](https://github.com/dotnet/msbuild/pull/6632)
 - [Default to transitively copying content items](https://github.com/dotnet/msbuild/pull/6622)
 - [Reference assemblies are now no longer placed in the `bin` directory by default](https://github.com/dotnet/msbuild/pull/6560)
+- [Improve debugging experience: add global switch MSBuildDebugEngine; Inject binary logger from BuildManager; print static graph as .dot file](https://github.com/dotnet/msbuild/pull/6639)
 
 ## Change Waves No Longer In Rotation
 ### 16.8
diff --git a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
index c94de3e3688..0e39d539eba 100644
--- a/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/net/Microsoft.Build.Tasks.Core.cs
@@ -207,6 +207,8 @@ public Copy() { }
         public Microsoft.Build.Framework.ITaskItem[] SourceFiles { get { throw null; } set { } }
         public bool UseHardlinksIfPossible { get { throw null; } set { } }
         public bool UseSymboliclinksIfPossible { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public bool WroteAtLeastOneFile { get { throw null; } }
         public void Cancel() { }
         public override bool Execute() { throw null; }
     }
diff --git a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
index 27ba53105be..18bd0c97245 100644
--- a/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
+++ b/ref/Microsoft.Build.Tasks.Core/netstandard/Microsoft.Build.Tasks.Core.cs
@@ -137,6 +137,8 @@ public Copy() { }
         public Microsoft.Build.Framework.ITaskItem[] SourceFiles { get { throw null; } set { } }
         public bool UseHardlinksIfPossible { get { throw null; } set { } }
         public bool UseSymboliclinksIfPossible { get { throw null; } set { } }
+        [Microsoft.Build.Framework.OutputAttribute]
+        public bool WroteAtLeastOneFile { get { throw null; } }
         public void Cancel() { }
         public override bool Execute() { throw null; }
     }
diff --git a/scripts/Deploy-MSBuild.ps1 b/scripts/Deploy-MSBuild.ps1
index 914f548cdd8..07b58d1f82d 100644
--- a/scripts/Deploy-MSBuild.ps1
+++ b/scripts/Deploy-MSBuild.ps1
@@ -11,13 +11,18 @@ Param(
 Set-StrictMode -Version "Latest"
 $ErrorActionPreference = "Stop"
 
-function Copy-WithBackup ($origin) {
-    $directoryPart = Join-Path -Path $destination $origin.IntermediaryDirectories
+function Copy-WithBackup ($origin, $destinationSubFolder = "") {
+    $directoryPart = [IO.Path]::Combine($destination, $destinationSubFolder, $origin.IntermediaryDirectories)
     $destinationPath = Join-Path -Path $directoryPart (Split-Path $origin.SourceFile -leaf)
 
+    $backupInto = [IO.Path]::Combine($BackupFolder, $destinationSubFolder)
+
     if (Test-Path $destinationPath -PathType Leaf) {
         # Back up previous copy of the file
-        Copy-Item $destinationPath $BackupFolder -ErrorAction Stop
+        if (!(Test-Path $backupInto)) {
+            [system.io.directory]::CreateDirectory($backupInto)
+        }
+        Copy-Item $destinationPath $backupInto -ErrorAction Stop
     }
 
     if (!(Test-Path $directoryPart)) {
@@ -60,19 +65,6 @@ $filesToCopyToBin = @(
     FileToCopy "$bootstrapBinDirectory\Microsoft.Build.Utilities.Core.dll"
     FileToCopy "$bootstrapBinDirectory\Microsoft.NET.StringTools.dll"
 
-    FileToCopy "$bootstrapBinDirectory\Microsoft.Bcl.AsyncInterfaces.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Buffers.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Collections.Immutable.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Memory.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Numerics.Vectors.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Resources.Extensions.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Runtime.CompilerServices.Unsafe.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Text.Encodings.Web.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Text.Json.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Dataflow.dll"
-    FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Extensions.dll"
-    FileToCopy "$bootstrapBinDirectory\System.ValueTuple.dll"
-
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.resources.dll" "en"
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.Tasks.Core.resources.dll" "en"
     FileToCopy "$bootstrapBinDirectory\en\Microsoft.Build.Utilities.Core.resources.dll" "en"
@@ -95,18 +87,16 @@ $filesToCopyToBin = @(
     FileToCopy "$bootstrapBinDirectory\Microsoft.VisualBasic.CrossTargeting.targets"
     FileToCopy "$bootstrapBinDirectory\Microsoft.VisualBasic.CurrentVersion.targets"
     FileToCopy "$bootstrapBinDirectory\Microsoft.VisualBasic.targets"
+
+    FileToCopy "$bootstrapBinDirectory\Microsoft.Common.tasks"
 )
 
 if ($runtime -eq "Desktop") {
     $runtimeSpecificFiles = @(
-        FileToCopy "$bootstrapBinDirectory\MSBuild.exe"
-        FileToCopy "$bootstrapBinDirectory\MSBuild.exe.config"
         FileToCopy "artifacts\bin\Microsoft.Build.Conversion\$configuration\$targetFramework\Microsoft.Build.Conversion.Core.dll"
         FileToCopy "artifacts\bin\Microsoft.Build.Engine\$configuration\$targetFramework\Microsoft.Build.Engine.dll"
 
-        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.exe"
-        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.pdb"
-
+        FileToCopy "$bootstrapBinDirectory\Microsoft.Bcl.AsyncInterfaces.dll"
         FileToCopy "$bootstrapBinDirectory\Microsoft.Data.Entity.targets"
         FileToCopy "$bootstrapBinDirectory\Microsoft.ServiceModel.targets"
         FileToCopy "$bootstrapBinDirectory\Microsoft.WinFx.targets"
@@ -114,6 +104,18 @@ if ($runtime -eq "Desktop") {
         FileToCopy "$bootstrapBinDirectory\Microsoft.Xaml.targets"
         FileToCopy "$bootstrapBinDirectory\Workflow.targets"
         FileToCopy "$bootstrapBinDirectory\Workflow.VisualBasic.targets"
+
+        FileToCopy "$bootstrapBinDirectory\System.Buffers.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Collections.Immutable.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Memory.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Numerics.Vectors.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Resources.Extensions.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Runtime.CompilerServices.Unsafe.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Text.Encodings.Web.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Text.Json.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Dataflow.dll"
+        FileToCopy "$bootstrapBinDirectory\System.Threading.Tasks.Extensions.dll"
+        FileToCopy "$bootstrapBinDirectory\System.ValueTuple.dll"    
     )
 } else {
     $runtimeSpecificFiles = @(
@@ -121,11 +123,40 @@ if ($runtime -eq "Desktop") {
     )
 }
 
+if ($runtime -eq "Desktop") {
+    $x86files = @(
+        FileToCopy "$bootstrapBinDirectory\MSBuild.exe"
+        FileToCopy "$bootstrapBinDirectory\MSBuild.exe.config"
+        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.exe"
+        FileToCopy "artifacts\bin\MSBuildTaskHost\$configuration\net35\MSBuildTaskHost.pdb"
+    )
+    $amd64files = @(
+        FileToCopy "artifacts\bin\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe"
+        FileToCopy "artifacts\bin\MSBuild\x64\$configuration\$targetFramework\MSBuild.exe.config"
+        FileToCopy "artifacts\bin\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.exe"
+        FileToCopy "artifacts\bin\MSBuildTaskHost\x64\$configuration\net35\MSBuildTaskHost.pdb"
+    )
+}
+
 $filesToCopyToBin += $runtimeSpecificFiles
 
 foreach ($file in $filesToCopyToBin) {
     Copy-WithBackup $file
 }
 
+if ($runtime -eq "Desktop") {
+    foreach ($file in $x86files) {
+        Copy-WithBackup $file
+    }
+
+    foreach ($file in $filesToCopyToBin) {
+        Copy-WithBackup $file "amd64"
+    }
+
+    foreach ($file in $amd64files) {
+        Copy-WithBackup $file "amd64"
+    }
+}
+
 Write-Host -ForegroundColor Green "Copy succeeded"
 Write-Verbose "Run $destination\MSBuild.exe"
diff --git a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
index 548a25b3858..c766c843e8d 100644
--- a/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
+++ b/src/Build.UnitTests/Graph/ProjectGraph_Tests.cs
@@ -1477,12 +1477,21 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
             var graph = Helpers.CreateProjectGraph(
                 _env,
                 edges,
-                new Dictionary<string, string> {{"a", "b"}});
+                globalProperties: new Dictionary<string, string> {{"a", "b"}},
+                createProjectFile: (env, projectId, references, _, _, _) => Helpers.CreateProjectFile(
+                    env,
+                    projectId,
+                    references,
+                    projectReferenceTargets: new Dictionary<string, string[]>
+                    {
+                        {"Build", new[] {$"TargetFrom{projectId}", "Build"}}
+                    }));
 
+            var targetsPerNode = graph.GetTargetLists(new []{ "Build" });
 
             Func<ProjectGraphNode, string> nodeIdProvider = GetProjectFileName;
 
-            var dot = graph.ToDot(nodeIdProvider);
+            var dot = graph.ToDot(nodeIdProvider, targetsPerNode);
 
             var edgeCount = 0;
 
@@ -1490,9 +1499,12 @@ public void DotNotationShouldRepresentGraph(Dictionary<int, int[]> edges)
             {
                 var nodeId = nodeIdProvider(node);
 
+                var targets = string.Join(".*", targetsPerNode[node]);
+                targets.ShouldNotBeNullOrEmpty();
+
                 foreach (var globalProperty in node.ProjectInstance.GlobalProperties)
                 {
-                    dot.ShouldMatch($@"{nodeId}\s*\[.*{globalProperty.Key}.*{globalProperty.Value}.*\]");
+                    dot.ShouldMatch($@"{nodeId}\s*\[.*{targets}.*{globalProperty.Key}.*{globalProperty.Value}.*\]");
                 }
 
                 foreach (var reference in node.ProjectReferences)
diff --git a/src/Build/BackEnd/BuildManager/BuildManager.cs b/src/Build/BackEnd/BuildManager/BuildManager.cs
index c624af051ac..42c230c97cb 100644
--- a/src/Build/BackEnd/BuildManager/BuildManager.cs
+++ b/src/Build/BackEnd/BuildManager/BuildManager.cs
@@ -30,7 +30,9 @@
 using Microsoft.Build.Internal;
 using Microsoft.Build.Logging;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Utilities;
 using ForwardingLoggerRecord = Microsoft.Build.Logging.ForwardingLoggerRecord;
 using LoggerDescription = Microsoft.Build.Logging.LoggerDescription;
 
@@ -486,7 +488,7 @@ public void BeginBuild(BuildParameters parameters)
             ILoggingService InitializeLoggingService()
             {
                 ILoggingService loggingService = CreateLoggingService(
-                    _buildParameters.Loggers,
+                    AppendDebuggingLoggers(_buildParameters.Loggers),
                     _buildParameters.ForwardingLoggers,
                     _buildParameters.WarningsAsErrors,
                     _buildParameters.WarningsAsMessages);
@@ -518,6 +520,22 @@ ILoggingService InitializeLoggingService()
                 return loggingService;
             }
 
+            // VS builds discard many msbuild events so attach a binlogger to capture them all.
+            IEnumerable<ILogger> AppendDebuggingLoggers(IEnumerable<ILogger> loggers)
+            {
+                if (DebugUtils.ShouldDebugCurrentProcess is false ||
+                    Traits.Instance.DebugEngine is false)
+                {
+                    return loggers;
+                }
+
+                var binlogPath = DebugUtils.FindNextAvailableDebugFilePath($"{DebugUtils.ProcessInfoString}_BuildManager_{_hostName}.binlog");
+
+                var logger = new BinaryLogger { Parameters = binlogPath };
+
+                return (loggers ?? Enumerable.Empty<ILogger>()).Concat(new[] { logger });
+            }
+
             void InitializeCaches()
             {
                 Debug.Assert(Monitor.IsEntered(_syncLock));
@@ -561,17 +579,14 @@ void InitializeCaches()
             }
         }
 
-        private void AttachDebugger()
+        private static void AttachDebugger()
         {
             if (Debugger.IsAttached)
             {
                 return;
             }
 
-            var processNameToBreakInto = Environment.GetEnvironmentVariable("MSBuildDebugBuildManagerOnStartProcessName");
-            var thisProcessMatchesName = string.IsNullOrWhiteSpace(processNameToBreakInto) || Process.GetCurrentProcess().ProcessName.Contains(processNameToBreakInto);
-
-            if (!thisProcessMatchesName)
+            if (!DebugUtils.ShouldDebugCurrentProcess)
             {
                 return;
             }
@@ -1757,11 +1772,17 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                 if (submission.BuildRequestData.GraphBuildOptions.Build)
                 {
                     var cacheServiceTask = Task.Run(() => SearchAndInitializeProjectCachePluginFromGraph(projectGraph));
-                    var targetListTask = Task.Run(() => projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames));
+                    var targetListTask = projectGraph.GetTargetLists(submission.BuildRequestData.TargetNames);
+
+                    DumpGraph(projectGraph, targetListTask);
 
                     using DisposablePluginService cacheService = cacheServiceTask.Result;
 
-                    resultsPerNode = BuildGraph(projectGraph, targetListTask.Result, submission.BuildRequestData);
+                    resultsPerNode = BuildGraph(projectGraph, targetListTask, submission.BuildRequestData);
+                }
+                else
+                {
+                    DumpGraph(projectGraph);
                 }
 
                 ErrorUtilities.VerifyThrow(
@@ -1825,6 +1846,18 @@ private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission)
                     _overallBuildSuccess = false;
                 }
             }
+
+            static void DumpGraph(ProjectGraph graph, IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetList = null)
+            {
+                if (Traits.Instance.DebugEngine is false)
+                {
+                    return;
+                }
+
+                var logPath = DebugUtils.FindNextAvailableDebugFilePath($"{DebugUtils.ProcessInfoString}_ProjectGraph.dot");
+
+                File.WriteAllText(logPath, graph.ToDot(targetList));
+            }
         }
 
         private Dictionary<ProjectGraphNode, BuildResult> BuildGraph(
diff --git a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
index 1038643d11f..2dbcd31ea0e 100644
--- a/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
+++ b/src/Build/BackEnd/Components/BuildRequestEngine/BuildRequestEngine.cs
@@ -12,6 +12,8 @@
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.Debugging;
+using Microsoft.Build.Utilities;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 
 namespace Microsoft.Build.BackEnd
@@ -115,8 +117,10 @@ internal class BuildRequestEngine : IBuildRequestEngine, IBuildComponent
         /// </summary>
         internal BuildRequestEngine()
         {
-            _debugDumpState = Environment.GetEnvironmentVariable("MSBUILDDEBUGSCHEDULER") == "1";
-            _debugDumpPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            _debugDumpState = Traits.Instance.DebugScheduler;
+            _debugDumpPath = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
+                ? DebugUtils.DebugPath
+                : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
             _debugForceCaching = Environment.GetEnvironmentVariable("MSBUILDDEBUGFORCECACHING") == "1";
 
             if (String.IsNullOrEmpty(_debugDumpPath))
diff --git a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
index 92a86164801..377e6805897 100644
--- a/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
+++ b/src/Build/BackEnd/Components/Scheduler/Scheduler.cs
@@ -14,6 +14,7 @@
 using Microsoft.Build.Experimental.ProjectCache;
 using Microsoft.Build.Framework;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.Debugging;
 using Microsoft.Build.Utilities;
 using BuildAbortedException = Microsoft.Build.Exceptions.BuildAbortedException;
 using ILoggingService = Microsoft.Build.BackEnd.Logging.ILoggingService;
@@ -176,8 +177,10 @@ internal class Scheduler : IScheduler
         /// </summary>
         public Scheduler()
         {
-            _debugDumpState = Environment.GetEnvironmentVariable("MSBUILDDEBUGSCHEDULER") == "1";
-            _debugDumpPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            _debugDumpState = Traits.Instance.DebugScheduler;
+            _debugDumpPath = ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
+                ? DebugUtils.DebugPath
+                : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
             _schedulingUnlimitedVariable = Environment.GetEnvironmentVariable("MSBUILDSCHEDULINGUNLIMITED");
             _nodeLimitOffset = 0;
 
diff --git a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
index c719a51d2df..b8546bbe1b6 100644
--- a/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
+++ b/src/Build/BackEnd/Components/Scheduler/SchedulingPlan.cs
@@ -10,6 +10,7 @@
 using Microsoft.Build.Shared;
 using Microsoft.Build.BackEnd.Logging;
 using Microsoft.Build.Shared.FileSystem;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.BackEnd
 {
@@ -316,7 +317,7 @@ private int GetConfigWithComparison(IEnumerable<int> realConfigsToSchedule, Comp
         private void AnalyzeData()
         {
             DoRecursiveAnalysis();
-            if (!String.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDEBUGSCHEDULER")))
+            if (Traits.Instance.DebugScheduler)
             {
                 DetermineExpensiveConfigs();
                 DetermineConfigsByNumberOfOccurrences();
diff --git a/src/Build/BackEnd/Node/OutOfProcNode.cs b/src/Build/BackEnd/Node/OutOfProcNode.cs
index 80e36648f23..9e500181510 100644
--- a/src/Build/BackEnd/Node/OutOfProcNode.cs
+++ b/src/Build/BackEnd/Node/OutOfProcNode.cs
@@ -118,11 +118,6 @@ public class OutOfProcNode : INode, IBuildComponentHost, INodePacketFactory, INo
         /// </summary>
         private Exception _shutdownException;
 
-        /// <summary>
-        /// Flag indicating if we should debug communications or not.
-        /// </summary>
-        private readonly bool _debugCommunications;
-
         /// <summary>
         /// Data for the use of LegacyThreading semantics.
         /// </summary>
@@ -140,8 +135,6 @@ public OutOfProcNode()
         {
             s_isOutOfProcNode = true;
 
-            _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
-
             _receivedPackets = new ConcurrentQueue<INodePacket>();
             _packetReceivedEvent = new AutoResetEvent(false);
             _shutdownEvent = new ManualResetEvent(false);
diff --git a/src/Build/Graph/ProjectGraph.cs b/src/Build/Graph/ProjectGraph.cs
index b445f72d83d..40cf6aee0ed 100644
--- a/src/Build/Graph/ProjectGraph.cs
+++ b/src/Build/Graph/ProjectGraph.cs
@@ -10,19 +10,20 @@
 using System.Linq;
 using System.Text;
 using System.Threading;
-using Microsoft.Build.BackEnd;
 using Microsoft.Build.Evaluation;
 using Microsoft.Build.Eventing;
 using Microsoft.Build.Exceptions;
 using Microsoft.Build.Execution;
 using Microsoft.Build.Shared;
+using Microsoft.Build.Shared.Debugging;
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Graph
 {
     /// <summary>
     ///     Represents a graph of evaluated projects.
     /// </summary>
-    [DebuggerDisplay(@"#roots={GraphRoots.Count}, #nodes={ProjectNodes.Count}, #entryPoints={EntryPointNodes.Count}")]
+    [DebuggerDisplay(@"{DebuggerDisplayString()}")]
     public sealed class ProjectGraph
     {
         /// <summary>
@@ -475,13 +476,16 @@ GraphConstructionMetrics EndMeasurement()
             }
         }
 
-        internal string ToDot()
+        internal string ToDot(IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode = null)
         {
             var nodeCount = 0;
-            return ToDot(node => nodeCount++.ToString());
+            return ToDot(node => nodeCount++.ToString(), targetsPerNode);
         }
 
-        internal string ToDot(Func<ProjectGraphNode, string> nodeIdProvider)
+        internal string ToDot(
+            Func<ProjectGraphNode, string> nodeIdProvider,
+            IReadOnlyDictionary<ProjectGraphNode, ImmutableList<string>> targetsPerNode = null
+        )
         {
             ErrorUtilities.VerifyThrowArgumentNull(nodeIdProvider, nameof(nodeIdProvider));
 
@@ -489,31 +493,56 @@ internal string ToDot(Func<ProjectGraphNode, string> nodeIdProvider)
 
             var sb = new StringBuilder();
 
-            sb.Append("digraph g\n{\n\tnode [shape=box]\n");
+            sb.AppendLine($"/* {DebuggerDisplayString()} */");
+
+            sb.AppendLine("digraph g")
+                .AppendLine("{")
+                .AppendLine("\tnode [shape=box]");
 
             foreach (var node in ProjectNodes)
             {
-                var nodeId = nodeIds.GetOrAdd(node, (n, idProvider) => idProvider(n), nodeIdProvider);
+                var nodeId = GetNodeId(node);
 
                 var nodeName = Path.GetFileNameWithoutExtension(node.ProjectInstance.FullPath);
+
                 var globalPropertiesString = string.Join(
                     "<br/>",
                     node.ProjectInstance.GlobalProperties.OrderBy(kvp => kvp.Key)
                         .Select(kvp => $"{kvp.Key}={kvp.Value}"));
 
-                sb.Append('\t').Append(nodeId).Append(" [label=<").Append(nodeName).Append("<br/>").Append(globalPropertiesString).AppendLine(">]");
+                var targetListString = GetTargetListString(node);
+
+                sb.AppendLine($"\t{nodeId} [label=<{nodeName}<br/>({targetListString})<br/>{globalPropertiesString}>]");
 
                 foreach (var reference in node.ProjectReferences)
                 {
-                    var referenceId = nodeIds.GetOrAdd(reference, (n, idProvider) => idProvider(n), nodeIdProvider);
+                    var referenceId = GetNodeId(reference);
 
-                    sb.Append('\t').Append(nodeId).Append(" -> ").AppendLine(referenceId);
+                    sb.AppendLine($"\t{nodeId} -> {referenceId}");
                 }
             }
 
             sb.Append("}");
 
             return sb.ToString();
+
+            string GetNodeId(ProjectGraphNode node)
+            {
+                return nodeIds.GetOrAdd(node, (n, idProvider) => idProvider(n), nodeIdProvider);
+            }
+
+            string GetTargetListString(ProjectGraphNode node)
+            {
+                var targetListString = targetsPerNode is null
+                    ? string.Empty
+                    : string.Join(", ", targetsPerNode[node]);
+                return targetListString;
+            }
+        }
+
+        private string DebuggerDisplayString()
+        {
+            return $"#roots={GraphRoots.Count}, #nodes={ProjectNodes.Count}, #entryPoints={EntryPointNodes.Count}";
         }
 
         private static IReadOnlyCollection<ProjectGraphNode> TopologicalSort(
diff --git a/src/MSBuild.UnitTests/XMake_Tests.cs b/src/MSBuild.UnitTests/XMake_Tests.cs
index d2a24d6b7f3..b3111ac86db 100644
--- a/src/MSBuild.UnitTests/XMake_Tests.cs
+++ b/src/MSBuild.UnitTests/XMake_Tests.cs
@@ -22,7 +22,7 @@
 
 namespace Microsoft.Build.UnitTests
 {
-    public class XMakeAppTests
+    public class XMakeAppTests : IDisposable
     {
 #if USE_MSBUILD_DLL_EXTN
         private const string MSBuildExeName = "MSBuild.dll";
@@ -31,10 +31,12 @@ public class XMakeAppTests
 #endif
 
         private readonly ITestOutputHelper _output;
+        private readonly TestEnvironment _env;
 
         public XMakeAppTests(ITestOutputHelper output)
         {
             _output = output;
+            _env = UnitTests.TestEnvironment.Create(_output);
         }
 
         private const string AutoResponseFileName = "MSBuild.rsp";
@@ -45,7 +47,7 @@ public void GatherCommandLineSwitchesTwoProperties()
             CommandLineSwitches switches = new CommandLineSwitches();
 
             var arguments = new List<string>();
-            arguments.AddRange(new string[] { "/p:a=b", "/p:c=d" });
+            arguments.AddRange(new[] { "/p:a=b", "/p:c=d" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
 
@@ -60,7 +62,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithArgument()
             CommandLineSwitches switches = new CommandLineSwitches();
 
             var arguments = new List<string>();
-            arguments.AddRange(new string[] { "/m:2" });
+            arguments.AddRange(new[] { "/m:2" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
 
@@ -77,7 +79,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgument()
             CommandLineSwitches switches = new CommandLineSwitches();
 
             var arguments = new List<string>();
-            arguments.AddRange(new string[] { "/m:3", "/m" });
+            arguments.AddRange(new[] { "/m:3", "/m" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
 
@@ -97,7 +99,7 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgumentButWithColon()
             CommandLineSwitches switches = new CommandLineSwitches();
 
             var arguments = new List<string>();
-            arguments.AddRange(new string[] { "/m:" });
+            arguments.AddRange(new[] { "/m:" });
 
             MSBuildApp.GatherCommandLineSwitches(arguments, switches);
 
@@ -137,11 +139,8 @@ public void GatherCommandLineSwitchesMaxCpuCountWithoutArgumentButWithColon()
         [Fact]
         public void SplitUnquotedTest()
         {
-            List<string> sa;
-            int emptySplits;
-
             // nothing quoted
-            sa = QuotingUtilities.SplitUnquoted("abcdxyz");
+            var sa = QuotingUtilities.SplitUnquoted("abcdxyz");
             sa.Count.ShouldBe(1);
             sa[0].ShouldBe("abcdxyz");
 
@@ -165,7 +164,7 @@ public void SplitUnquotedTest()
             sa[2].ShouldBe("dxyz");
 
             // nothing quoted
-            sa = QuotingUtilities.SplitUnquoted("abc,c;dxyz", 2, false, false, out emptySplits, ';', ',');
+            sa = QuotingUtilities.SplitUnquoted("abc,c;dxyz", 2, false, false, out var emptySplits, ';', ',');
             emptySplits.ShouldBe(0);
             sa.Count.ShouldBe(2);
             sa[0].ShouldBe("abc");
@@ -183,8 +182,8 @@ public void SplitUnquotedTest()
             emptySplits.ShouldBe(0);
             sa.Count.ShouldBe(4);
             sa[0].ShouldBe("abc");
-            sa[1].ShouldBe(String.Empty);
-            sa[2].ShouldBe(String.Empty);
+            sa[1].ShouldBe(string.Empty);
+            sa[2].ShouldBe(string.Empty);
             sa[3].ShouldBe("dxyz");
 
             // "c d" is quoted
@@ -330,10 +329,8 @@ public void SplitUnquotedTest()
         [Fact]
         public void UnquoteTest()
         {
-            int doubleQuotesRemoved;
-
             // "cde" is quoted
-            QuotingUtilities.Unquote("abc\"cde\"xyz", out doubleQuotesRemoved).ShouldBe("abccdexyz");
+            QuotingUtilities.Unquote("abc\"cde\"xyz", out var doubleQuotesRemoved).ShouldBe("abccdexyz");
             doubleQuotesRemoved.ShouldBe(2);
 
             // "xyz" is quoted (the terminal double-quote is assumed)
@@ -393,8 +390,7 @@ public void UnquoteTest()
         public void ExtractSwitchParametersTest()
         {
             string commandLineArg = "\"/p:foo=\"bar";
-            int doubleQuotesRemovedFromArg;
-            string unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out doubleQuotesRemovedFromArg);
+            string unquotedCommandLineArg = QuotingUtilities.Unquote(commandLineArg, out var doubleQuotesRemovedFromArg);
             MSBuildApp.ExtractSwitchParameters(commandLineArg, unquotedCommandLineArg, doubleQuotesRemovedFromArg, "p", unquotedCommandLineArg.IndexOf(':')).ShouldBe(":\"foo=\"bar");
             doubleQuotesRemovedFromArg.ShouldBe(2);
 
@@ -513,15 +509,15 @@ public void InvalidVerbosity()
         [Fact]
         public void ValidMaxCPUCountSwitch()
         {
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "1" }).ShouldBe(1);
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "2" }).ShouldBe(2);
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "3" }).ShouldBe(3);
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "4" }).ShouldBe(4);
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "8" }).ShouldBe(8);
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "63" }).ShouldBe(63);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "1" }).ShouldBe(1);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "2" }).ShouldBe(2);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "3" }).ShouldBe(3);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "4" }).ShouldBe(4);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "8" }).ShouldBe(8);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "63" }).ShouldBe(63);
 
             // Should pick last value
-            MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "8", "4" }).ShouldBe(4);
+            MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "8", "4" }).ShouldBe(4);
         }
 
         [Fact]
@@ -529,7 +525,7 @@ public void InvalidMaxCPUCountSwitch1()
         {
             Should.Throw<CommandLineSwitchException>(() =>
             {
-                MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "-1" });
+                MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "-1" });
             }
            );
         }
@@ -539,7 +535,7 @@ public void InvalidMaxCPUCountSwitch2()
         {
             Should.Throw<CommandLineSwitchException>(() =>
             {
-                MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "0" });
+                MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "0" });
             }
            );
         }
@@ -550,7 +546,7 @@ public void InvalidMaxCPUCountSwitch3()
             Should.Throw<CommandLineSwitchException>(() =>
             {
                 // Too big
-                MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "foo" });
+                MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "foo" });
             }
            );
         }
@@ -560,7 +556,7 @@ public void InvalidMaxCPUCountSwitch4()
         {
             Should.Throw<CommandLineSwitchException>(() =>
             {
-                MSBuildApp.ProcessMaxCPUCountSwitch(new string[] { "1025" });
+                MSBuildApp.ProcessMaxCPUCountSwitch(new[] { "1025" });
             }
            );
         }
@@ -586,7 +582,7 @@ public void SetConsoleUICulture()
             MSBuildApp.SetConsoleUI();
 
             // Make sure this doesn't throw an exception.
-            string bar = String.Format(CultureInfo.CurrentUICulture, "{0}", 1);
+            string bar = string.Format(CultureInfo.CurrentUICulture, "{0}", 1);
 
             // Restore the current UI culture back to the way it was at the beginning of this unit test.
             thisThread.CurrentUICulture = originalUICulture;
@@ -647,20 +643,19 @@ public void ConfigurationInvalid()
 
                 var msbuildParameters = "\"" + pathToProjectFile + "\"";
 
-                bool successfulExit;
-                output = RunnerUtilities.ExecMSBuild(newPathToMSBuildExe, msbuildParameters, out successfulExit);
+                output = RunnerUtilities.ExecMSBuild(newPathToMSBuildExe, msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeFalse();
             }
             catch (Exception ex)
             {
-                Console.WriteLine(ex.ToString());
+                _output.WriteLine(ex.ToString());
                 throw;
             }
             finally
             {
                 if (output != null)
                 {
-                    Console.WriteLine(output);
+                    _output.WriteLine(output);
                 }
 
                 try
@@ -800,7 +795,7 @@ public void MSBuildEngineLogger()
             }
         }
 
-        private string _pathToArbitraryBogusFile = NativeMethodsShared.IsWindows // OK on 64 bit as well
+        private readonly string _pathToArbitraryBogusFile = NativeMethodsShared.IsWindows // OK on 64 bit as well
                                                         ? Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "notepad.exe")
                                                         : "/bin/cat";
 
@@ -813,8 +808,7 @@ public void GetCommandLine()
             var msbuildParameters = "\"" + _pathToArbitraryBogusFile + "\"" + (NativeMethodsShared.IsWindows ? " /v:diag" : " -v:diag");
             File.Exists(_pathToArbitraryBogusFile).ShouldBeTrue();
 
-            bool successfulExit;
-            string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+            string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
             successfulExit.ShouldBeFalse();
 
             output.ShouldContain(RunnerUtilities.PathToCurrentlyRunningMsBuildExe + (NativeMethodsShared.IsWindows ? " /v:diag " : " -v:diag ") + _pathToArbitraryBogusFile, Case.Insensitive);
@@ -829,7 +823,6 @@ public void GetCommandLineQuotedExe()
             var msbuildParameters = "\"" + _pathToArbitraryBogusFile + "\"" + (NativeMethodsShared.IsWindows ? " /v:diag" : " -v:diag");
             File.Exists(_pathToArbitraryBogusFile).ShouldBeTrue();
 
-            bool successfulExit;
             string pathToMSBuildExe = RunnerUtilities.PathToCurrentlyRunningMsBuildExe;
             // This @pathToMSBuildExe is used directly with Process, so don't quote it on
             // Unix
@@ -838,7 +831,7 @@ public void GetCommandLineQuotedExe()
                 pathToMSBuildExe = "\"" + pathToMSBuildExe + "\"";
             }
 
-            string output = RunnerUtilities.ExecMSBuild(pathToMSBuildExe, msbuildParameters, out successfulExit);
+            string output = RunnerUtilities.ExecMSBuild(pathToMSBuildExe, msbuildParameters, out var successfulExit);
             successfulExit.ShouldBeFalse();
 
             output.ShouldContain(RunnerUtilities.PathToCurrentlyRunningMsBuildExe + (NativeMethodsShared.IsWindows ? " /v:diag " : " -v:diag ") + _pathToArbitraryBogusFile, Case.Insensitive);
@@ -850,7 +843,7 @@ public void GetCommandLineQuotedExe()
         [Fact]
         public void GetCommandLineQuotedExeOnPath()
         {
-            string output = null;
+            string output;
             string current = Directory.GetCurrentDirectory();
 
             try
@@ -859,8 +852,7 @@ public void GetCommandLineQuotedExeOnPath()
 
                 var msbuildParameters = "\"" + _pathToArbitraryBogusFile + "\"" + (NativeMethodsShared.IsWindows ? " /v:diag" : " -v:diag");
 
-                bool successfulExit;
-                output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeFalse();
             }
             finally
@@ -878,38 +870,23 @@ public void GetCommandLineQuotedExeOnPath()
         [Fact]
         public void ResponseFileInProjectDirectoryFoundImplicitly()
         {
-            string directory = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
+            string directory = _env.DefaultTestDirectory.Path;
             string projectPath = Path.Combine(directory, "my.proj");
             string rspPath = Path.Combine(directory, AutoResponseFileName);
 
-            string currentDirectory = Directory.GetCurrentDirectory();
-
-            try
-            {
-                Directory.CreateDirectory(directory);
-
-                string content = ObjectModelHelpers.CleanupFileContents("<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'><Target Name='t'><Warning Text='[A=$(A)]'/></Target></Project>");
-                File.WriteAllText(projectPath, content);
+            string content = ObjectModelHelpers.CleanupFileContents("<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'><Target Name='t'><Warning Text='[A=$(A)]'/></Target></Project>");
+            File.WriteAllText(projectPath, content);
 
-                string rspContent = "/p:A=1";
-                File.WriteAllText(rspPath, rspContent);
+            string rspContent = "/p:A=1";
+            File.WriteAllText(rspPath, rspContent);
 
-                // Find the project in the current directory
-                Directory.SetCurrentDirectory(directory);
+            // Find the project in the current directory
+            _env.SetCurrentDirectory(directory);
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(String.Empty, out successfulExit);
-                successfulExit.ShouldBeTrue();
+            string output = RunnerUtilities.ExecMSBuild(string.Empty, out var successfulExit);
+            successfulExit.ShouldBeTrue();
 
-                output.ShouldContain("[A=1]");
-            }
-            finally
-            {
-                Directory.SetCurrentDirectory(currentDirectory);
-                File.Delete(projectPath);
-                File.Delete(rspPath);
-                FileUtilities.DeleteWithoutTrailingBackslash(directory);
-            }
+            output.ShouldContain("[A=1]");
         }
 
         /// <summary>
@@ -935,8 +912,7 @@ public void ResponseFileInProjectDirectoryExplicit()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=1]");
@@ -971,8 +947,7 @@ public void ResponseFileInProjectDirectoryRandomName()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=]");
@@ -1008,8 +983,7 @@ public void ResponseFileInProjectDirectoryCommandLineWins()
 
                 var msbuildParameters = "\"" + projectPath + "\"" + " /p:A=2";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=2]");
@@ -1054,8 +1028,7 @@ public void ResponseFileInProjectDirectoryWinsOverMainMSBuildRsp()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(exePath, msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(exePath, msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=1]");
@@ -1090,8 +1063,7 @@ public void ProjectDirectoryIsMSBuildExeDirectory()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(exePath, msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(exePath, msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=1]");
@@ -1124,8 +1096,7 @@ public void ResponseFileInProjectDirectoryItselfWithNoAutoResponseSwitch()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeFalse();
 
                 output.ShouldContain("MSB1027"); // msbuild.rsp cannot have /noautoresponse in it
@@ -1160,8 +1131,7 @@ public void ResponseFileInProjectDirectoryButCommandLineNoAutoResponseSwitch()
 
                 var msbuildParameters = "\"" + projectPath + "\" /noautoresponse";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=]");
@@ -1193,8 +1163,7 @@ public void ResponseFileInProjectDirectoryNullCase()
 
                 var msbuildParameters = "\"" + projectPath + "\"";
 
-                bool successfulExit;
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out successfulExit);
+                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
                 successfulExit.ShouldBeTrue();
 
                 output.ShouldContain("[A=]");
@@ -1213,22 +1182,19 @@ public void ResponseFileInProjectDirectoryNullCase()
         [Fact]
         public void ResponseFileSupportsThisFileDirectory()
         {
-            using (var env = UnitTests.TestEnvironment.Create())
-            {
-                var content = ObjectModelHelpers.CleanupFileContents(
-                    "<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'><Target Name='t'><Warning Text='[A=$(A)]'/></Target></Project>");
+            var content = ObjectModelHelpers.CleanupFileContents(
+                "<Project ToolsVersion='msbuilddefaulttoolsversion' xmlns='msbuildnamespace'><Target Name='t'><Warning Text='[A=$(A)]'/></Target></Project>");
 
-                var directory = env.CreateFolder();
-                directory.CreateFile("Directory.Build.rsp", "/p:A=%MSBuildThisFileDirectory%");
-                var projectPath = directory.CreateFile("my.proj", content).Path;
+            var directory = _env.CreateFolder();
+            directory.CreateFile("Directory.Build.rsp", "/p:A=%MSBuildThisFileDirectory%");
+            var projectPath = directory.CreateFile("my.proj", content).Path;
 
-                var msbuildParameters = "\"" + projectPath + "\"";
+            var msbuildParameters = "\"" + projectPath + "\"";
 
-                string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
-                successfulExit.ShouldBeTrue();
+            string output = RunnerUtilities.ExecMSBuild(msbuildParameters, out var successfulExit);
+            successfulExit.ShouldBeTrue();
 
-                output.ShouldContain($"[A={directory.Path}{Path.DirectorySeparatorChar}]");
-            }
+            output.ShouldContain($"[A={directory.Path}{Path.DirectorySeparatorChar}]");
         }
 
         /// <summary>
@@ -1254,7 +1220,7 @@ public void NormalPriorityBuild()
 
         private void RunPriorityBuildTest(ProcessPriorityClass expectedPrority, params string[] arguments)
         {
-            string[] aggregateArguments = arguments.Union(new string[] { " /nr:false /v:diag "}).ToArray();
+            string[] aggregateArguments = arguments.Union(new[] { " /nr:false /v:diag "}).ToArray();
 
             string contents = ObjectModelHelpers.CleanupFileContents(@"
 <Project DefaultTargets=""Build"" xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
@@ -1275,7 +1241,7 @@ private void RunPriorityBuildTest(ProcessPriorityClass expectedPrority, params s
 
             string logContents = ExecuteMSBuildExeExpectSuccess(contents, envsToCreate: environmentVars, arguments: aggregateArguments);
 
-            string expected = string.Format(@"Task priority is '{0}'", expectedPrority);
+            string expected = $@"Task priority is '{expectedPrority}'";
             logContents.ShouldContain(expected, () => logContents);
         }
 
@@ -1283,11 +1249,11 @@ private void RunPriorityBuildTest(ProcessPriorityClass expectedPrority, params s
         /// Test the default file to build in cases involving at least one solution filter file.
         /// </summary>
         [Theory]
-        [InlineData(new string[] { "my.proj", "my.sln", "my.slnf" }, "my.sln")]
-        [InlineData(new string[] { "abc.proj", "bcd.csproj", "slnf.slnf", "other.slnf" }, "abc.proj")]
-        [InlineData(new string[] { "abc.sln", "slnf.slnf", "abc.slnf" }, "abc.sln")]
-        [InlineData(new string[] { "abc.csproj", "abc.slnf", "not.slnf" }, "abc.csproj")]
-        [InlineData(new string[] { "abc.slnf" }, "abc.slnf")]
+        [InlineData(new[] { "my.proj", "my.sln", "my.slnf" }, "my.sln")]
+        [InlineData(new[] { "abc.proj", "bcd.csproj", "slnf.slnf", "other.slnf" }, "abc.proj")]
+        [InlineData(new[] { "abc.sln", "slnf.slnf", "abc.slnf" }, "abc.sln")]
+        [InlineData(new[] { "abc.csproj", "abc.slnf", "not.slnf" }, "abc.csproj")]
+        [InlineData(new[] { "abc.slnf" }, "abc.slnf")]
         public void TestDefaultBuildWithSolutionFilter(string[] projects, string answer)
         {
             string[] extensionsToIgnore = Array.Empty<string>();
@@ -1304,10 +1270,10 @@ public void TestDefaultBuildWithSolutionFilter(string[] projects, string answer)
         [Fact]
         public void TestProcessProjectSwitchOneProjNotFoundExtension()
         {
-            string[] projects = new string[] { "my.proj" };
-            string[] extensionsToIgnore = new string[] { ".phantomextension" };
+            string[] projects = { "my.proj" };
+            string[] extensionsToIgnore = { ".phantomextension" };
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
         }
 
         /// <summary>
@@ -1316,10 +1282,10 @@ public void TestProcessProjectSwitchOneProjNotFoundExtension()
         [Fact]
         public void TestTwoIdenticalExtensionsToIgnore()
         {
-            string[] projects = new string[] { "my.proj" };
-            string[] extensionsToIgnore = new string[] { ".phantomextension", ".phantomextension" };
+            string[] projects = { "my.proj" };
+            string[] extensionsToIgnore = { ".phantomextension", ".phantomextension" };
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
         }
 
         /// <summary>
@@ -1328,13 +1294,13 @@ public void TestTwoIdenticalExtensionsToIgnore()
         [Fact]
         public void TestProcessProjectSwitchNullandEmptyProjectsToIgnore()
         {
-            string[] projects = new string[] { "my.proj" };
+            string[] projects = { "my.proj" };
             string[] extensionsToIgnore = null;
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
 
             extensionsToIgnore = new string[] { };
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
         }
 
         /// <summary>
@@ -1345,10 +1311,10 @@ public void TestProcessProjectSwitchNullInList()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "my.proj" };
-                string[] extensionsToIgnore = new string[] { ".phantomextension", null };
+                string[] projects = { "my.proj" };
+                string[] extensionsToIgnore = { ".phantomextension", null };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
             }
            );
         }
@@ -1361,10 +1327,10 @@ public void TestProcessProjectSwitchEmptyInList()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "my.proj" };
-                string[] extensionsToIgnore = new string[] { ".phantomextension", string.Empty };
+                string[] projects = { "my.proj" };
+                string[] extensionsToIgnore = { ".phantomextension", string.Empty };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
             }
            );
         }
@@ -1376,10 +1342,10 @@ public void TestProcessProjectSwitchExtensionWithoutDot()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "my.proj" };
-                string[] extensionsToIgnore = new string[] { "phantomextension" };
+                string[] projects = { "my.proj" };
+                string[] extensionsToIgnore = { "phantomextension" };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase);
             }
            );
         }
@@ -1391,10 +1357,10 @@ public void TestProcessProjectSwitchMalformed()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "my.proj" };
-                string[] extensionsToIgnore = new string[] { ".C:\\boocatmoo.a" };
+                string[] projects = { "my.proj" };
+                string[] extensionsToIgnore = { ".C:\\boocatmoo.a" };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("my.proj", StringCompareShould.IgnoreCase); // "Expected my.proj to be only project found"
             }
            );
         }
@@ -1406,65 +1372,65 @@ public void TestProcessProjectSwitchWildcards()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "my.proj" };
-                string[] extensionsToIgnore = new string[] { ".proj*", ".nativeproj?" };
+                string[] projects = { "my.proj" };
+                string[] extensionsToIgnore = { ".proj*", ".nativeproj?" };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
         [Fact]
         public void TestProcessProjectSwitch()
         {
-            string[] projects = new string[] { "test.nativeproj", "test.vcproj" };
-            string[] extensionsToIgnore = new string[] { ".phantomextension", ".vcproj" };
+            string[] projects = { "test.nativeproj", "test.vcproj" };
+            string[] extensionsToIgnore = { ".phantomextension", ".vcproj" };
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.nativeproj", StringCompareShould.IgnoreCase); // "Expected test.nativeproj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.nativeproj", StringCompareShould.IgnoreCase); // "Expected test.nativeproj to be only project found"
 
-            projects = new string[] { "test.nativeproj", "test.vcproj", "test.proj" };
-            extensionsToIgnore = new string[] { ".phantomextension", ".vcproj" };
+            projects = new[] { "test.nativeproj", "test.vcproj", "test.proj" };
+            extensionsToIgnore = new[] { ".phantomextension", ".vcproj" };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
 
-            projects = new string[] { "test.nativeproj", "test.vcproj" };
-            extensionsToIgnore = new string[] { ".vcproj" };
+            projects = new[] { "test.nativeproj", "test.vcproj" };
+            extensionsToIgnore = new[] { ".vcproj" };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.nativeproj", StringCompareShould.IgnoreCase); // "Expected test.nativeproj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.nativeproj", StringCompareShould.IgnoreCase); // "Expected test.nativeproj to be only project found"
 
-            projects = new string[] { "test.proj", "test.sln" };
-            extensionsToIgnore = new string[] { ".vcproj" };
+            projects = new[] { "test.proj", "test.sln" };
+            extensionsToIgnore = new[] { ".vcproj" };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
-            projects = new string[] { "test.proj", "test.sln", "test.proj~", "test.sln~" };
+            projects = new[] { "test.proj", "test.sln", "test.proj~", "test.sln~" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
-            projects = new string[] { "test.proj" };
+            projects = new[] { "test.proj" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
 
-            projects = new string[] { "test.proj", "test.proj~" };
+            projects = new[] { "test.proj", "test.proj~" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj", StringCompareShould.IgnoreCase); // "Expected test.proj to be only project found"
 
-            projects = new string[] { "test.sln" };
+            projects = new[] { "test.sln" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
-            projects = new string[] { "test.sln", "test.sln~" };
+            projects = new[] { "test.sln", "test.sln~" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
 
-            projects = new string[] { "test.sln~", "test.sln" };
+            projects = new[] { "test.sln~", "test.sln" };
             extensionsToIgnore = new string[] { };
             projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.sln", StringCompareShould.IgnoreCase); // "Expected test.sln to be only solution found"
         }
 
         /// <summary>
@@ -1473,10 +1439,10 @@ public void TestProcessProjectSwitch()
         [Fact]
         public void TestProcessProjectSwitchReplicateBuildingDFLKG()
         {
-            string[] projects = new string[] { "test.proj", "test.sln", "Foo.vcproj" };
+            string[] projects = { "test.proj", "test.sln", "Foo.vcproj" };
             string[] extensionsToIgnore = { ".sln", ".vcproj" };
             IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-            MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj"); // "Expected test.proj to be only project found"
+            MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles).ShouldBe("test.proj"); // "Expected test.proj to be only project found"
         }
 
         /// <summary>
@@ -1487,12 +1453,10 @@ public void TestProcessProjectSwitchRemovedAllprojects()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects;
-                string[] extensionsToIgnore = null;
-                projects = new string[] { "test.nativeproj", "test.vcproj" };
-                extensionsToIgnore = new string[] { ".nativeproj", ".vcproj" };
+                var projects = new[] { "test.nativeproj", "test.vcproj" };
+                var extensionsToIgnore = new[] { ".nativeproj", ".vcproj" };
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1504,10 +1468,10 @@ public void TestProcessProjectSwitchSlnProjDifferentNames()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "test.proj", "Different.sln" };
+                string[] projects = { "test.proj", "Different.sln" };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1519,10 +1483,10 @@ public void TestProcessProjectSwitchTwoProj()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "test.proj", "Different.proj" };
+                string[] projects = { "test.proj", "Different.proj" };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1534,10 +1498,10 @@ public void TestProcessProjectSwitchTwoNative()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "test.nativeproj", "Different.nativeproj" };
+                string[] projects = { "test.nativeproj", "Different.nativeproj" };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1549,10 +1513,10 @@ public void TestProcessProjectSwitchTwoSolutions()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "test.sln", "Different.sln" };
+                string[] projects = { "test.sln", "Different.sln" };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1564,10 +1528,10 @@ public void TestProcessProjectSwitchMoreThenTwoProj()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { "test.nativeproj", "Different.csproj", "Another.proj" };
+                string[] projects = { "test.nativeproj", "Different.csproj", "Another.proj" };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1579,10 +1543,10 @@ public void TestProcessProjectSwitchNoProjectOrSolution()
         {
             Should.Throw<InitializationException>(() =>
             {
-                string[] projects = new string[] { };
+                string[] projects = { };
                 string[] extensionsToIgnore = null;
                 IgnoreProjectExtensionsHelper projectHelper = new IgnoreProjectExtensionsHelper(projects);
-                MSBuildApp.ProcessProjectSwitch(new string[0] { }, extensionsToIgnore, projectHelper.GetFiles);
+                MSBuildApp.ProcessProjectSwitch(new string[] { }, extensionsToIgnore, projectHelper.GetFiles);
             }
            );
         }
@@ -1591,7 +1555,7 @@ public void TestProcessProjectSwitchNoProjectOrSolution()
         /// </summary>
         internal class IgnoreProjectExtensionsHelper
         {
-            private List<string> _directoryFileNameList;
+            private readonly List<string> _directoryFileNameList;
 
             /// <summary>
             /// Takes in a list of file names to simulate as being in a directory
@@ -1618,14 +1582,14 @@ internal string[] GetFiles(string path, string searchPattern)
                 List<string> fileNamesToReturn = new List<string>();
                 foreach (string file in _directoryFileNameList)
                 {
-                    if (String.Equals(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase))
+                    if (string.Equals(searchPattern, "*.sln", StringComparison.OrdinalIgnoreCase))
                     {
                         if (FileUtilities.IsSolutionFilename(file))
                         {
                             fileNamesToReturn.Add(file);
                         }
                     }
-                    else if (String.Equals(searchPattern, "*.*proj", StringComparison.OrdinalIgnoreCase))
+                    else if (string.Equals(searchPattern, "*.*proj", StringComparison.OrdinalIgnoreCase))
                     {
                         if (Path.GetExtension(file).Contains("proj"))
                         {
@@ -1759,7 +1723,7 @@ public void TestProcessFileLoggerSwitch3()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[1] { "Parameter" };
+            fileLoggerParameters = new[] { "Parameter" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1774,7 +1738,7 @@ public void TestProcessFileLoggerSwitch3()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[2] { "Parameter1", "Parameter" };
+            fileLoggerParameters = new[] { "Parameter1", "Parameter" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1814,7 +1778,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[1] { "verbosity=Normal;" };
+            fileLoggerParameters = new[] { "verbosity=Normal;" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1831,7 +1795,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[2] { "verbosity=Normal", "" };
+            fileLoggerParameters = new[] { "verbosity=Normal", "" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1848,7 +1812,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[2] { "", "Parameter1" };
+            fileLoggerParameters = new[] { "", "Parameter1" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1865,7 +1829,7 @@ public void TestProcessFileLoggerSwitch4()
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
 
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[2] { "Parameter1", "verbosity=Normal;logfile=" + (NativeMethodsShared.IsWindows ? "c:\\temp\\cat.log" : "/tmp/cat.log") };
+            fileLoggerParameters = new[] { "Parameter1", "verbosity=Normal;logfile=" + (NativeMethodsShared.IsWindows ? "c:\\temp\\cat.log" : "/tmp/cat.log") };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1880,7 +1844,7 @@ public void TestProcessFileLoggerSwitch4()
 
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
             loggers = new List<ILogger>();
-            fileLoggerParameters = new string[2] { "Parameter1", "verbosity=Normal;logfile=" + Path.Combine("..", "cat.log") + ";Parameter1" };
+            fileLoggerParameters = new[] { "Parameter1", "verbosity=Normal;logfile=" + Path.Combine("..", "cat.log") + ";Parameter1" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1895,7 +1859,7 @@ public void TestProcessFileLoggerSwitch4()
 
             loggers = new List<ILogger>();
             distributedLoggerRecords = new List<DistributedLoggerRecord>();
-            fileLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
+            fileLoggerParameters = new[] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
             MSBuildApp.ProcessDistributedFileLogger
                        (
                            distributedFileLogger,
@@ -1938,7 +1902,7 @@ public void ProcessConsoleLoggerSwitches()
             var loggers = new List<ILogger>();
             LoggerVerbosity verbosity = LoggerVerbosity.Normal;
             List<DistributedLoggerRecord> distributedLoggerRecords = new List<DistributedLoggerRecord>();
-            string[] consoleLoggerParameters = new string[6] { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
+            string[] consoleLoggerParameters = { "Parameter1", ";Parameter;", "", ";", ";Parameter", "Parameter;" };
 
             MSBuildApp.ProcessConsoleLoggerSwitch
                        (
@@ -2186,18 +2150,15 @@ public void MissingOptionalLoggersAreIgnored(string logger)
                 "<Project>" +
                 "<Target Name=\"t\"><Message Text=\"Hello\"/></Target>" +
                 "</Project>";
-            using (var env = UnitTests.TestEnvironment.Create())
-            {
-                var tempDir = env.CreateFolder();
-                var projectFile = tempDir.CreateFile("missingloggertest.proj", projectString);
+            var tempDir = _env.CreateFolder();
+            var projectFile = tempDir.CreateFile("missingloggertest.proj", projectString);
 
-                var parametersLoggerOptional = $"{logger} -verbosity:diagnostic \"{projectFile.Path}\"";
+            var parametersLoggerOptional = $"{logger} -verbosity:diagnostic \"{projectFile.Path}\"";
 
-                var output = RunnerUtilities.ExecMSBuild(parametersLoggerOptional, out bool successfulExit, _output);
-                successfulExit.ShouldBe(true);
-                output.ShouldContain("Hello", output);
-                output.ShouldContain("The specified logger could not be created and will not be used.", output);
-            }
+            var output = RunnerUtilities.ExecMSBuild(parametersLoggerOptional, out bool successfulExit, _output);
+            successfulExit.ShouldBe(true);
+            output.ShouldContain("Hello", output);
+            output.ShouldContain("The specified logger could not be created and will not be used.", output);
         }
 
         [Theory]
@@ -2225,45 +2186,38 @@ public void InteractiveSetsBuiltInProperty(string arguments)
         [Fact]
         public void BinaryLogContainsImportedFiles()
         {
-            using (TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create())
-            {
-                var testProject = testEnvironment.CreateFile("Importer.proj", ObjectModelHelpers.CleanupFileContents(@"
-                <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                    <Import Project=""TestProject.proj"" />
+            var testProject = _env.CreateFile("Importer.proj", ObjectModelHelpers.CleanupFileContents(@"
+            <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+                <Import Project=""TestProject.proj"" />
 
-                    <Target Name=""Build"">
-                    </Target>
+                <Target Name=""Build"">
+                </Target>
 
-                </Project>"));
+            </Project>"));
 
-                testEnvironment.CreateFile("TestProject.proj", @"
-                <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                  <Target Name=""Build"">
-                    <Message Text=""Hello from TestProject!"" />
-                  </Target>
-                </Project>
-                ");
+            _env.CreateFile("TestProject.proj", @"
+            <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+              <Target Name=""Build"">
+                <Message Text=""Hello from TestProject!"" />
+              </Target>
+            </Project>
+            ");
 
-                string binLogLocation = testEnvironment.DefaultTestDirectory.Path;
+            string binLogLocation = _env.DefaultTestDirectory.Path;
 
-                string output = RunnerUtilities.ExecMSBuild($"\"{testProject.Path}\" \"/bl:{binLogLocation}/output.binlog\"", out var success, _output);
+            string output = RunnerUtilities.ExecMSBuild($"\"{testProject.Path}\" \"/bl:{binLogLocation}/output.binlog\"", out var success, _output);
 
-                success.ShouldBeTrue(output);
+            success.ShouldBeTrue(output);
 
-                RunnerUtilities.ExecMSBuild($"\"{binLogLocation}/output.binlog\" \"/bl:{binLogLocation}/replay.binlog;ProjectImports=ZipFile\"", out success, _output);
+            RunnerUtilities.ExecMSBuild($"\"{binLogLocation}/output.binlog\" \"/bl:{binLogLocation}/replay.binlog;ProjectImports=ZipFile\"", out success, _output);
 
-                using (ZipArchive archive = ZipFile.OpenRead($"{binLogLocation}/replay.ProjectImports.zip"))
-                {
-                     archive.Entries.ShouldContain(e => e.FullName.EndsWith(".proj", StringComparison.OrdinalIgnoreCase), 2);
-                }
-            }
+            using ZipArchive archive = ZipFile.OpenRead($"{binLogLocation}/replay.ProjectImports.zip");
+            archive.Entries.ShouldContain(e => e.FullName.EndsWith(".proj", StringComparison.OrdinalIgnoreCase), 2);
         }
 
         [Fact]
         public void EndToEndWarnAsErrors()
         {
-            using TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create();
-
             string projectContents = ObjectModelHelpers.CleanupFileContents(@"<Project>
 
   <Target Name=""IssueWarning"">
@@ -2272,7 +2226,7 @@ public void EndToEndWarnAsErrors()
 
 </Project>");
 
-            TransientTestProjectWithFiles testProject = testEnvironment.CreateTestProjectWithFiles(projectContents);
+            TransientTestProjectWithFiles testProject = _env.CreateTestProjectWithFiles(projectContents);
 
             RunnerUtilities.ExecMSBuild($"\"{testProject.ProjectFile}\" -warnaserror", out bool success, _output);
 
@@ -2284,44 +2238,40 @@ public void EndToEndWarnAsErrors()
         [Fact]
         public void BuildSlnOutOfProc()
         {
-            using (TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create())
-            {
-                string solutionFileContents =
-                    @"
-Microsoft Visual Studio Solution File, Format Version 12.00
+            string solutionFileContents =
+@"Microsoft Visual Studio Solution File, Format Version 12.00
 # Visual Studio Version 16
 Project('{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}') = 'TestProject', 'TestProject.proj', '{6185CC21-BE89-448A-B3C0-D1C27112E595}'
 EndProject
 Global
-    GlobalSection(SolutionConfigurationPlatforms) = preSolution
-        Debug|Mixed Platforms = Debug|Mixed Platforms
-        Release|Any CPU = Release|Any CPU
-    EndGlobalSection
-    GlobalSection(ProjectConfigurationPlatforms) = postSolution
-        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.ActiveCfg = CSConfig1|Any CPU
-        {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.Build.0 = CSConfig1|Any CPU
-    EndGlobalSection
+GlobalSection(SolutionConfigurationPlatforms) = preSolution
+    Debug|Mixed Platforms = Debug|Mixed Platforms
+    Release|Any CPU = Release|Any CPU
+EndGlobalSection
+GlobalSection(ProjectConfigurationPlatforms) = postSolution
+    {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.ActiveCfg = CSConfig1|Any CPU
+    {6185CC21-BE89-448A-B3C0-D1C27112E595}.Debug|Mixed Platforms.Build.0 = CSConfig1|Any CPU
+EndGlobalSection
 EndGlobal
-                    ".Replace("'", "\"");
+                ".Replace("'", "\"");
 
-                var testSolution = testEnvironment.CreateFile("TestSolution.sln", ObjectModelHelpers.CleanupFileContents(solutionFileContents));
+            var testSolution = _env.CreateFile("TestSolution.sln", ObjectModelHelpers.CleanupFileContents(solutionFileContents));
 
-                string testMessage = "Hello from TestProject!";
-                testEnvironment.CreateFile("TestProject.proj", @$"
-                <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
-                  <Target Name=""Build"">
-                    <Message Text=""{testMessage}"" />
-                  </Target>
-                </Project>
-                ");
+            string testMessage = "Hello from TestProject!";
+            _env.CreateFile("TestProject.proj", @$"
+            <Project xmlns=""http://schemas.microsoft.com/developer/msbuild/2003"">
+              <Target Name=""Build"">
+                <Message Text=""{testMessage}"" />
+              </Target>
+            </Project>
+            ");
 
-                testEnvironment.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
+            _env.SetEnvironmentVariable("MSBUILDNOINPROCNODE", "1");
 
-                string output = RunnerUtilities.ExecMSBuild($"\"{testSolution.Path}\" /p:Configuration=Debug", out var success, _output);
+            string output = RunnerUtilities.ExecMSBuild($"\"{testSolution.Path}\" /p:Configuration=Debug", out var success, _output);
 
-                success.ShouldBeTrue(output);
-                output.ShouldContain(testMessage);
-            }
+            success.ShouldBeTrue(output);
+            output.ShouldContain(testMessage);
         }
 
 #if FEATURE_ASSEMBLYLOADCONTEXT
@@ -2417,32 +2367,32 @@ private string ExecuteMSBuildExeExpectFailure(string projectContents, IDictionar
 
         private (bool result, string output) ExecuteMSBuildExe(string projectContents, IDictionary<string, string> filesToCreate = null, IDictionary<string, string> envsToCreate = null, params string[] arguments)
         {
-            using (TestEnvironment testEnvironment = UnitTests.TestEnvironment.Create())
-            {
-                TransientTestProjectWithFiles testProject = testEnvironment.CreateTestProjectWithFiles(projectContents, new string[0]);
+            TransientTestProjectWithFiles testProject = _env.CreateTestProjectWithFiles(projectContents, new string[0]);
 
-                if (filesToCreate != null)
+            if (filesToCreate != null)
+            {
+                foreach (var item in filesToCreate)
                 {
-                    foreach (var item in filesToCreate)
-                    {
-                        File.WriteAllText(Path.Combine(testProject.TestRoot, item.Key), item.Value);
-                    }
+                    File.WriteAllText(Path.Combine(testProject.TestRoot, item.Key), item.Value);
                 }
+            }
 
-                if (envsToCreate != null)
+            if (envsToCreate != null)
+            {
+                foreach (var env in envsToCreate)
                 {
-                    foreach (var env in envsToCreate)
-                    {
-                        testEnvironment.SetEnvironmentVariable(env.Key, env.Value);
-                    }
+                    _env.SetEnvironmentVariable(env.Key, env.Value);
                 }
+            }
 
-                bool success;
+            string output = RunnerUtilities.ExecMSBuild($"\"{testProject.ProjectFile}\" {string.Join(" ", arguments)}", out var success, _output);
 
-                string output = RunnerUtilities.ExecMSBuild($"\"{testProject.ProjectFile}\" {String.Join(" ", arguments)}", out success, _output);
+            return (success, output);
+        }
 
-                return (success, output);
-            }
+        public void Dispose()
+        {
+            _env.Dispose();
         }
     }
 }
diff --git a/src/MSBuild/OutOfProcTaskHostNode.cs b/src/MSBuild/OutOfProcTaskHostNode.cs
index 34adcd7cb25..c0ca960bb76 100644
--- a/src/MSBuild/OutOfProcTaskHostNode.cs
+++ b/src/MSBuild/OutOfProcTaskHostNode.cs
@@ -172,7 +172,7 @@ public OutOfProcTaskHostNode()
             // We don't know what the current build thinks this variable should be until RunTask(), but as a fallback in case there are
             // communications before we get the configuration set up, just go with what was already in the environment from when this node
             // was initially launched.
-            _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
+            _debugCommunications = Traits.Instance.DebugNodeCommunication;
 
             _receivedPackets = new Queue<INodePacket>();
 
diff --git a/src/Shared/CommunicationsUtilities.cs b/src/Shared/CommunicationsUtilities.cs
index f8337625465..9f643cc6ea6 100644
--- a/src/Shared/CommunicationsUtilities.cs
+++ b/src/Shared/CommunicationsUtilities.cs
@@ -13,7 +13,11 @@
 
 using Microsoft.Build.Shared;
 using System.Reflection;
+using Microsoft.Build.Utilities;
 
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Shared.Debugging;
+#endif
 #if !FEATURE_APM
 using System.Threading.Tasks;
 #endif
@@ -131,7 +135,7 @@ static internal class CommunicationsUtilities
         /// <summary>
         /// Whether to trace communications
         /// </summary>
-        private static bool s_trace = String.Equals(Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM"), "1", StringComparison.Ordinal);
+        private static bool s_trace = Traits.Instance.DebugNodeCommunication;
 
         /// <summary>
         /// Place to dump trace
@@ -175,6 +179,13 @@ static internal int NodeConnectionTimeout
         /// </summary>
         internal static Dictionary<string, string> GetEnvironmentVariables()
         {
+#if !CLR2COMPATIBILITY
+            // The DebugUtils static constructor can set the MSBUILDDEBUGPATH environment variable to propagate the debug path to out of proc nodes.
+            // Need to ensure that constructor is called before this method returns in order to capture its env var write.
+            // Otherwise the env var is not captured and thus gets deleted when RequiestBuilder resets the environment based on the cached results of this method.
+            ErrorUtilities.VerifyThrowInternalNull(DebugUtils.DebugPath, nameof(DebugUtils.DebugPath));
+#endif
+
             Dictionary<string, string> table = new Dictionary<string, string>(200, StringComparer.OrdinalIgnoreCase); // Razzle has 150 environment variables
 
             if (NativeMethodsShared.IsWindows)
@@ -552,7 +563,14 @@ internal static void Trace(int nodeId, string format, params object[] args)
             {
                 if (s_debugDumpPath == null)
                 {
-                    s_debugDumpPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+                    s_debugDumpPath =
+#if CLR2COMPATIBILITY
+                        Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+#else
+                        ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
+                            ? DebugUtils.DebugPath
+                            : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+#endif
 
                     if (String.IsNullOrEmpty(s_debugDumpPath))
                     {
diff --git a/src/Shared/Debugging/DebugUtils.cs b/src/Shared/Debugging/DebugUtils.cs
new file mode 100644
index 00000000000..03736d2ad73
--- /dev/null
+++ b/src/Shared/Debugging/DebugUtils.cs
@@ -0,0 +1,99 @@
+﻿// Copyright (c) Microsoft. All rights reserved.
+// Licensed under the MIT license. See LICENSE file in the project root for full license information.
+
+using Microsoft.Build.Utilities;
+using System;
+using System.Diagnostics;
+using System.IO;
+using System.Text.RegularExpressions;
+
+namespace Microsoft.Build.Shared.Debugging
+{
+    internal static class DebugUtils
+    {
+        private enum NodeMode
+        {
+            CentralNode,
+            OutOfProcNode,
+            OutOfProcTaskHostNode
+        }
+
+        static DebugUtils()
+        {
+            string environmentDebugPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            var debugDirectory = environmentDebugPath ?? Path.Combine(Directory.GetCurrentDirectory(), "MSBuild_Logs");
+
+            if (Traits.Instance.DebugEngine)
+            {
+                FileUtilities.EnsureDirectoryExists(debugDirectory);
+
+                // Out of proc nodes do not know the startup directory so set the environment variable for them.
+                if (string.IsNullOrWhiteSpace(environmentDebugPath))
+                {
+                    Environment.SetEnvironmentVariable("MSBUILDDEBUGPATH", debugDirectory);
+                }
+            }
+
+            DebugPath = debugDirectory;
+        }
+
+        private static readonly Lazy<NodeMode> ProcessNodeMode = new(
+        () =>
+        {
+            return ScanNodeMode(Environment.CommandLine);
+
+            NodeMode ScanNodeMode(string input)
+            {
+                var match = Regex.Match(input, @"/nodemode:(?<nodemode>[12\s])(\s|$)", RegexOptions.IgnoreCase);
+
+                if (!match.Success)
+                {
+                    return NodeMode.CentralNode;
+                }
+                var nodeMode = match.Groups["nodemode"].Value;
+
+                Trace.Assert(!string.IsNullOrEmpty(nodeMode));
+
+                return nodeMode switch
+                {
+                    "1" => NodeMode.OutOfProcNode,
+                    "2" => NodeMode.OutOfProcTaskHostNode,
+                    _ => throw new NotImplementedException(),
+                };
+            }
+        });
+
+        private static bool CurrentProcessMatchesDebugName()
+        {
+            var processNameToBreakInto = Environment.GetEnvironmentVariable("MSBuildDebugProcessName");
+            var thisProcessMatchesName = string.IsNullOrWhiteSpace(processNameToBreakInto) ||
+                                         Process.GetCurrentProcess().ProcessName.Contains(processNameToBreakInto);
+
+            return thisProcessMatchesName;
+        }
+
+        public static readonly string ProcessInfoString =
+            $"{ProcessNodeMode.Value}_{Process.GetCurrentProcess().ProcessName}_PID={Process.GetCurrentProcess().Id}_x{(Environment.Is64BitProcess ? "64" : "86")}";
+
+        public static readonly bool ShouldDebugCurrentProcess = CurrentProcessMatchesDebugName();
+
+        public static string DebugPath { get; }
+
+        public static string FindNextAvailableDebugFilePath(string fileName)
+        {
+            var extension = Path.GetExtension(fileName);
+            var fileNameWithoutExtension = Path.GetFileNameWithoutExtension(fileName);
+
+            var fullPath = Path.Combine(DebugPath, fileName);
+
+            var counter = 0;
+            while (File.Exists(fullPath))
+            {
+                fileName = $"{fileNameWithoutExtension}_{counter++}{extension}";
+                fullPath = Path.Combine(DebugPath, fileName);
+            }
+
+            return fullPath;
+        }
+    }
+}
diff --git a/src/Shared/Debugging/PrintLineDebugger.cs b/src/Shared/Debugging/PrintLineDebugger.cs
index bfcdbfd57c4..28fe6c8587a 100644
--- a/src/Shared/Debugging/PrintLineDebugger.cs
+++ b/src/Shared/Debugging/PrintLineDebugger.cs
@@ -20,13 +20,6 @@ namespace Microsoft.Build.Shared.Debugging
     /// </summary>
     internal class PrintLineDebugger : IDisposable
     {
-        internal enum NodeMode
-        {
-            CentralNode,
-            OutOfProcNode,
-            OutOfProcTaskHostNode
-        }
-
         private static readonly Lazy<PropertyInfo> CommonWriterProperty = new Lazy<PropertyInfo>(
             () =>
             {
@@ -45,41 +38,10 @@ internal enum NodeMode
         public static Lazy<PrintLineDebugger> DefaultWithProcessInfo =
             new Lazy<PrintLineDebugger>(() => Create(null, null, true));
 
-        private static readonly Lazy<NodeMode> ProcessNodeMode = new Lazy<NodeMode>(
-            () =>
-            {
-                return ScanNodeMode(Environment.CommandLine);
-
-                NodeMode ScanNodeMode(string input)
-                {
-                    var match = Regex.Match(input, @"/nodemode:(?<nodemode>[12\s])(\s|$)", RegexOptions.IgnoreCase);
-
-                    if (!match.Success)
-                    {
-                        return NodeMode.CentralNode;
-                    }
-                    var nodeMode = match.Groups["nodemode"].Value;
-
-                    Trace.Assert(!string.IsNullOrEmpty(nodeMode));
-
-                    return nodeMode switch
-                    {
-                        "1" => NodeMode.OutOfProcNode,
-                        "2" => NodeMode.OutOfProcTaskHostNode,
-                        _ => throw new NotImplementedException(),
-                    };
-                }
-            });
-
         private readonly string _id;
 
         private readonly CommonWriterType _writerSetByThisInstance;
 
-        public static string ProcessInfo
-            =>
-                $"{ProcessNodeMode.Value}_PID={Process.GetCurrentProcess() .Id}({Process.GetCurrentProcess() .ProcessName})x{(Environment.Is64BitProcess ? "64" : "86")}"
-            ;
-
         public PrintLineDebugger(string id, CommonWriterType writer)
         {
             _id = id ?? string.Empty;
@@ -147,7 +109,7 @@ public static PrintLineDebugger Create(
         {
             return new PrintLineDebugger(
                 prependProcessInfo
-                    ? $"{ProcessInfo}_{id}"
+                    ? $"{DebugUtils.ProcessInfoString}_{id}"
                     : id,
                 writer);
         }
diff --git a/src/Shared/ExceptionHandling.cs b/src/Shared/ExceptionHandling.cs
index ae0dac9bfe3..8ba3e225520 100644
--- a/src/Shared/ExceptionHandling.cs
+++ b/src/Shared/ExceptionHandling.cs
@@ -19,6 +19,10 @@ namespace Microsoft.Build.AppxPackage.Shared
 using Microsoft.Build.Shared.FileSystem;
 using System.Xml.Schema;
 using System.Runtime.Serialization;
+#if !CLR2COMPATIBILITY
+using Microsoft.Build.Shared.Debugging;
+#endif
+using Microsoft.Build.Utilities;
 
 namespace Microsoft.Build.Shared
 #endif
@@ -41,7 +45,16 @@ static ExceptionHandling()
         /// <returns></returns>
         private static string GetDebugDumpPath()
         {
-            string debugPath = Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+            string debugPath =
+// Cannot access change wave logic from these assemblies (https://github.com/dotnet/msbuild/issues/6707)
+#if CLR2COMPATIBILITY || MICROSOFT_BUILD_ENGINE_OM_UNITTESTS
+                        Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+#else
+                ChangeWaves.AreFeaturesEnabled(ChangeWaves.Wave17_0)
+                    ? DebugUtils.DebugPath
+                    : Environment.GetEnvironmentVariable("MSBUILDDEBUGPATH");
+#endif
+
             return !string.IsNullOrEmpty(debugPath)
                     ? debugPath
                     : Path.GetTempPath();
diff --git a/src/Shared/InterningBinaryReader.cs b/src/Shared/InterningBinaryReader.cs
index dfe24659c01..389450a2242 100644
--- a/src/Shared/InterningBinaryReader.cs
+++ b/src/Shared/InterningBinaryReader.cs
@@ -7,6 +7,10 @@
 using System.Diagnostics;
 using System.Threading;
 
+#if !CLR2COMPATIBILITY
+using System.Buffers;
+#endif
+
 using ErrorUtilities = Microsoft.Build.Shared.ErrorUtilities;
 
 using Microsoft.NET.StringTools;
@@ -71,6 +75,7 @@ private InterningBinaryReader(Stream input, Buffer buffer, bool isPrivateBuffer)
         /// </summary>
         override public String ReadString()
         {
+            char[] resultBuffer = null;
             try
             {
                 MemoryStream memoryStream = this.BaseStream as MemoryStream;
@@ -94,7 +99,6 @@ override public String ReadString()
                 }
 
                 char[] charBuffer = _buffer.CharBuffer;
-                char[] resultBuffer = null;
                 do
                 {
                     readLength = ((stringLength - currPos) > MaxCharsBuffer) ? MaxCharsBuffer : (stringLength - currPos);
@@ -146,21 +150,37 @@ override public String ReadString()
                         charsRead = _decoder.GetChars(rawBuffer, rawPosition, n, charBuffer, 0);
                         return Strings.WeakIntern(charBuffer.AsSpan(0, charsRead));
                     }
-
+#if !CLR2COMPATIBILITY
+                    resultBuffer ??= ArrayPool<char>.Shared.Rent(stringLength); // Actual string length in chars may be smaller.
+#else
+                    // Since NET35 is only used in rare TaskHost processes, we decided to leave it as-is.
                     resultBuffer ??= new char[stringLength]; // Actual string length in chars may be smaller.
+#endif
                     charsRead += _decoder.GetChars(rawBuffer, rawPosition, n, resultBuffer, charsRead);
 
                     currPos += n;
                 }
                 while (currPos < stringLength);
 
-                return Strings.WeakIntern(resultBuffer.AsSpan(0, charsRead));
+                var retval = Strings.WeakIntern(resultBuffer.AsSpan(0, charsRead));
+
+                return retval;
             }
             catch (Exception e)
             {
                 Debug.Assert(false, e.ToString());
                 throw;
             }
+#if !CLR2COMPATIBILITY
+            finally
+            {
+                // resultBuffer shall always be either Rented or null
+                if (resultBuffer != null)
+                {
+                    ArrayPool<char>.Shared.Return(resultBuffer);
+                }
+            }
+#endif
         }
 
         /// <summary>
@@ -188,7 +208,7 @@ private static Buffer GetPooledBuffer()
             return new Buffer();
         }
 
-        #region IDisposable pattern
+#region IDisposable pattern
 
         /// <summary>
         /// Returns our buffer to the pool if we were not passed one by the caller.
@@ -204,7 +224,7 @@ protected override void Dispose(bool disposing)
             base.Dispose(disposing);
         }
 
-        #endregion
+#endregion
 
         /// <summary>
         /// Create a BinaryReader. It will either be an interning reader or standard binary reader
diff --git a/src/Shared/NodeEndpointOutOfProcBase.cs b/src/Shared/NodeEndpointOutOfProcBase.cs
index 99f43c83280..3d468e23e95 100644
--- a/src/Shared/NodeEndpointOutOfProcBase.cs
+++ b/src/Shared/NodeEndpointOutOfProcBase.cs
@@ -43,11 +43,6 @@ internal abstract class NodeEndpointOutOfProcBase : INodeEndpoint
         /// </summary>
         private const int PipeBufferSize = 131072;
 
-        /// <summary>
-        /// Flag indicating if we should debug communications or not.
-        /// </summary>
-        private bool _debugCommunications = false;
-
         /// <summary>
         /// The current communication status of the node.
         /// </summary>
@@ -193,8 +188,6 @@ internal void InternalConstruct(string pipeName)
         {
             ErrorUtilities.VerifyThrowArgumentLength(pipeName, nameof(pipeName));
 
-            _debugCommunications = (Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM") == "1");
-
             _status = LinkStatus.Inactive;
             _asyncDataMonitor = new object();
             _sharedReadBuffer = InterningBinaryReader.CreateSharedBuffer();
diff --git a/src/Shared/Traits.cs b/src/Shared/Traits.cs
index 72471dfa828..39fe9f7abb0 100644
--- a/src/Shared/Traits.cs
+++ b/src/Shared/Traits.cs
@@ -27,6 +27,9 @@ public static Traits Instance
         public Traits()
         {
             EscapeHatches = new EscapeHatches();
+
+            DebugScheduler = DebugEngine || !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDEBUGSCHEDULER"));
+            DebugNodeCommunication = DebugEngine || !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBUILDDEBUGCOMM"));
         }
 
         public EscapeHatches EscapeHatches { get; }
@@ -86,6 +89,10 @@ public Traits()
         /// </summary>
         public readonly int LogPropertyTracking = ParseIntFromEnvironmentVariableOrDefault("MsBuildLogPropertyTracking", 0); // Default to logging nothing via the property tracker.
 
+        public readonly bool DebugEngine = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("MSBuildDebugEngine"));
+        public readonly bool DebugScheduler;
+        public readonly bool DebugNodeCommunication;
+
         private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVariable, int defaultValue)
         {
             return int.TryParse(Environment.GetEnvironmentVariable(environmentVariable), out int result)
diff --git a/src/Tasks/Copy.cs b/src/Tasks/Copy.cs
index ba793b673d6..e22b7cc2372 100644
--- a/src/Tasks/Copy.cs
+++ b/src/Tasks/Copy.cs
@@ -139,6 +139,9 @@ public Copy()
         [Output]
         public ITaskItem[] CopiedFiles { get; private set; }
 
+        [Output]
+        public bool WroteAtLeastOneFile { get; private set; }
+
         /// <summary>
         /// Whether to overwrite files in the destination
         /// that have the read-only attribute set.
@@ -298,6 +301,9 @@ FileState destinationFileState  // The destination file
 
                 File.Copy(sourceFileState.Name, destinationFileState.Name, true);
             }
+            
+            // Files were successfully copied or linked. Those are equivalent here.
+            WroteAtLeastOneFile = true;
 
             destinationFileState.Reset();
 
diff --git a/src/Tasks/Microsoft.Common.CurrentVersion.targets b/src/Tasks/Microsoft.Common.CurrentVersion.targets
index 369130c9ced..7226919f37b 100644
--- a/src/Tasks/Microsoft.Common.CurrentVersion.targets
+++ b/src/Tasks/Microsoft.Common.CurrentVersion.targets
@@ -4696,6 +4696,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
 
       <Output TaskParameter="DestinationFiles" ItemName="FileWritesShareable"/>
       <Output TaskParameter="CopiedFiles" ItemName="ReferencesCopiedInThisBuild"/>
+      <Output TaskParameter="WroteAtLeastOneFile" PropertyName="WroteAtLeastOneFile"/>
 
     </Copy>
 
@@ -4705,7 +4706,7 @@ Copyright (C) Microsoft Corporation. All rights reserved.
          input to projects that reference this one. -->
     <Touch Files="@(CopyUpToDateMarker)"
            AlwaysCreate="true"
-           Condition="'@(ReferencesCopiedInThisBuild)' != ''">
+           Condition="'@(ReferencesCopiedInThisBuild)' != '' and '$(WroteAtLeastOneFile)' == 'true'">
         <Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
     </Touch>
 
